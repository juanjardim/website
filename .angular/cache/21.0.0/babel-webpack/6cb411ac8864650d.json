{"ast":null,"code":"'use strict';\n\n/**\n * @license Angular\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n(function (g, f) {\n  if (typeof define == \"function\" && define.amd) {\n    define(f);\n  } else if (typeof exports == \"object\" && typeof module < \"u\") {\n    module.exports = f();\n  } else {\n    var m = f();\n    for (var i in m) g[i] = m[i];\n  }\n})(typeof globalThis < \"u\" ? globalThis : typeof self < \"u\" ? self : this, function () {\n  var exports = {};\n  var __exports = exports;\n  var module = {\n    exports: exports\n  };\n  var __defProp = Object.defineProperty;\n  var __defProps = Object.defineProperties;\n  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;\n  var __getOwnPropSymbols = Object.getOwnPropertySymbols;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __propIsEnum = Object.prototype.propertyIsEnumerable;\n  var __defNormalProp = function (obj, key, value) {\n    return key in obj ? __defProp(obj, key, {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: value\n    }) : obj[key] = value;\n  };\n  var __spreadValues = function (a, b) {\n    for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols) for (var _i = 0, _b = __getOwnPropSymbols(b); _i < _b.length; _i++) {\n      var prop = _b[_i];\n      if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n  };\n  var __spreadProps = function (a, b) {\n    return __defProps(a, __getOwnPropDescs(b));\n  };\n  var __publicField = function (obj, key, value) {\n    __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n  };\n  // packages/zone.js/lib/zone-impl.js\n  var global = globalThis;\n  function __symbol__(name) {\n    var symbolPrefix = global[\"__Zone_symbol_prefix\"] || \"__zone_symbol__\";\n    return symbolPrefix + name;\n  }\n  function initZone() {\n    var performance = global[\"performance\"];\n    function mark(name) {\n      performance && performance[\"mark\"] && performance[\"mark\"](name);\n    }\n    function performanceMeasure(name, label) {\n      performance && performance[\"measure\"] && performance[\"measure\"](name, label);\n    }\n    mark(\"Zone\");\n    var _ZoneImpl = /** @class */function () {\n      function _ZoneImpl(parent, zoneSpec) {\n        __publicField(this, \"_parent\");\n        __publicField(this, \"_name\");\n        __publicField(this, \"_properties\");\n        __publicField(this, \"_zoneDelegate\");\n        this._parent = parent;\n        this._name = zoneSpec ? zoneSpec.name || \"unnamed\" : \"<root>\";\n        this._properties = zoneSpec && zoneSpec.properties || {};\n        this._zoneDelegate = new _ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);\n      }\n      _ZoneImpl.assertZonePatched = function () {\n        if (global[\"Promise\"] !== patches[\"ZoneAwarePromise\"]) {\n          throw new Error(\"Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)\");\n        }\n      };\n      Object.defineProperty(_ZoneImpl, \"root\", {\n        get: function () {\n          var zone = _ZoneImpl.current;\n          while (zone.parent) {\n            zone = zone.parent;\n          }\n          return zone;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(_ZoneImpl, \"current\", {\n        get: function () {\n          return _currentZoneFrame.zone;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(_ZoneImpl, \"currentTask\", {\n        get: function () {\n          return _currentTask;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      _ZoneImpl.__load_patch = function (name, fn, ignoreDuplicate) {\n        if (ignoreDuplicate === void 0) {\n          ignoreDuplicate = false;\n        }\n        if (patches.hasOwnProperty(name)) {\n          var checkDuplicate = global[__symbol__(\"forceDuplicateZoneCheck\")] === true;\n          if (!ignoreDuplicate && checkDuplicate) {\n            throw Error(\"Already loaded patch: \" + name);\n          }\n        } else if (!global[\"__Zone_disable_\" + name]) {\n          var perfName = \"Zone:\" + name;\n          mark(perfName);\n          patches[name] = fn(global, _ZoneImpl, _api);\n          performanceMeasure(perfName, perfName);\n        }\n      };\n      Object.defineProperty(_ZoneImpl.prototype, \"parent\", {\n        get: function () {\n          return this._parent;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(_ZoneImpl.prototype, \"name\", {\n        get: function () {\n          return this._name;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      _ZoneImpl.prototype.get = function (key) {\n        var zone = this.getZoneWith(key);\n        if (zone) return zone._properties[key];\n      };\n      _ZoneImpl.prototype.getZoneWith = function (key) {\n        var current = this;\n        while (current) {\n          if (current._properties.hasOwnProperty(key)) {\n            return current;\n          }\n          current = current._parent;\n        }\n        return null;\n      };\n      _ZoneImpl.prototype.fork = function (zoneSpec) {\n        if (!zoneSpec) throw new Error(\"ZoneSpec required!\");\n        return this._zoneDelegate.fork(this, zoneSpec);\n      };\n      _ZoneImpl.prototype.wrap = function (callback, source) {\n        if (typeof callback !== \"function\") {\n          throw new Error(\"Expecting function got: \" + callback);\n        }\n        var _callback = this._zoneDelegate.intercept(this, callback, source);\n        var zone = this;\n        return function () {\n          return zone.runGuarded(_callback, this, arguments, source);\n        };\n      };\n      _ZoneImpl.prototype.run = function (callback, applyThis, applyArgs, source) {\n        _currentZoneFrame = {\n          parent: _currentZoneFrame,\n          zone: this\n        };\n        try {\n          return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n        } finally {\n          _currentZoneFrame = _currentZoneFrame.parent;\n        }\n      };\n      _ZoneImpl.prototype.runGuarded = function (callback, applyThis, applyArgs, source) {\n        if (applyThis === void 0) {\n          applyThis = null;\n        }\n        _currentZoneFrame = {\n          parent: _currentZoneFrame,\n          zone: this\n        };\n        try {\n          try {\n            return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n          } catch (error) {\n            if (this._zoneDelegate.handleError(this, error)) {\n              throw error;\n            }\n          }\n        } finally {\n          _currentZoneFrame = _currentZoneFrame.parent;\n        }\n      };\n      _ZoneImpl.prototype.runTask = function (task, applyThis, applyArgs) {\n        if (task.zone != this) {\n          throw new Error(\"A task can only be run in the zone of creation! (Creation: \" + (task.zone || NO_ZONE).name + \"; Execution: \" + this.name + \")\");\n        }\n        var zoneTask = task;\n        var type = task.type,\n          _b = task.data,\n          _c = _b === void 0 ? {} : _b,\n          _d = _c.isPeriodic,\n          isPeriodic = _d === void 0 ? false : _d,\n          _e = _c.isRefreshable,\n          isRefreshable = _e === void 0 ? false : _e;\n        if (task.state === notScheduled && (type === eventTask || type === macroTask)) {\n          return;\n        }\n        var reEntryGuard = task.state != running;\n        reEntryGuard && zoneTask._transitionTo(running, scheduled);\n        var previousTask = _currentTask;\n        _currentTask = zoneTask;\n        _currentZoneFrame = {\n          parent: _currentZoneFrame,\n          zone: this\n        };\n        try {\n          if (type == macroTask && task.data && !isPeriodic && !isRefreshable) {\n            task.cancelFn = void 0;\n          }\n          try {\n            return this._zoneDelegate.invokeTask(this, zoneTask, applyThis, applyArgs);\n          } catch (error) {\n            if (this._zoneDelegate.handleError(this, error)) {\n              throw error;\n            }\n          }\n        } finally {\n          var state = task.state;\n          if (state !== notScheduled && state !== unknown) {\n            if (type == eventTask || isPeriodic || isRefreshable && state === scheduling) {\n              reEntryGuard && zoneTask._transitionTo(scheduled, running, scheduling);\n            } else {\n              var zoneDelegates = zoneTask._zoneDelegates;\n              this._updateTaskCount(zoneTask, -1);\n              reEntryGuard && zoneTask._transitionTo(notScheduled, running, notScheduled);\n              if (isRefreshable) {\n                zoneTask._zoneDelegates = zoneDelegates;\n              }\n            }\n          }\n          _currentZoneFrame = _currentZoneFrame.parent;\n          _currentTask = previousTask;\n        }\n      };\n      _ZoneImpl.prototype.scheduleTask = function (task) {\n        if (task.zone && task.zone !== this) {\n          var newZone = this;\n          while (newZone) {\n            if (newZone === task.zone) {\n              throw Error(\"can not reschedule task to \".concat(this.name, \" which is descendants of the original zone \").concat(task.zone.name));\n            }\n            newZone = newZone.parent;\n          }\n        }\n        task._transitionTo(scheduling, notScheduled);\n        var zoneDelegates = [];\n        task._zoneDelegates = zoneDelegates;\n        task._zone = this;\n        try {\n          task = this._zoneDelegate.scheduleTask(this, task);\n        } catch (err) {\n          task._transitionTo(unknown, scheduling, notScheduled);\n          this._zoneDelegate.handleError(this, err);\n          throw err;\n        }\n        if (task._zoneDelegates === zoneDelegates) {\n          this._updateTaskCount(task, 1);\n        }\n        if (task.state == scheduling) {\n          task._transitionTo(scheduled, scheduling);\n        }\n        return task;\n      };\n      _ZoneImpl.prototype.scheduleMicroTask = function (source, callback, data, customSchedule) {\n        return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, void 0));\n      };\n      _ZoneImpl.prototype.scheduleMacroTask = function (source, callback, data, customSchedule, customCancel) {\n        return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));\n      };\n      _ZoneImpl.prototype.scheduleEventTask = function (source, callback, data, customSchedule, customCancel) {\n        return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));\n      };\n      _ZoneImpl.prototype.cancelTask = function (task) {\n        if (task.zone != this) throw new Error(\"A task can only be cancelled in the zone of creation! (Creation: \" + (task.zone || NO_ZONE).name + \"; Execution: \" + this.name + \")\");\n        if (task.state !== scheduled && task.state !== running) {\n          return;\n        }\n        task._transitionTo(canceling, scheduled, running);\n        try {\n          this._zoneDelegate.cancelTask(this, task);\n        } catch (err) {\n          task._transitionTo(unknown, canceling);\n          this._zoneDelegate.handleError(this, err);\n          throw err;\n        }\n        this._updateTaskCount(task, -1);\n        task._transitionTo(notScheduled, canceling);\n        task.runCount = -1;\n        return task;\n      };\n      _ZoneImpl.prototype._updateTaskCount = function (task, count) {\n        var zoneDelegates = task._zoneDelegates;\n        if (count == -1) {\n          task._zoneDelegates = null;\n        }\n        for (var i = 0; i < zoneDelegates.length; i++) {\n          zoneDelegates[i]._updateTaskCount(task.type, count);\n        }\n      };\n      return _ZoneImpl;\n    }();\n    __publicField(_ZoneImpl, \"__symbol__\", __symbol__);\n    var ZoneImpl = _ZoneImpl;\n    var DELEGATE_ZS = {\n      name: \"\",\n      onHasTask: function (delegate, _, target, hasTaskState) {\n        return delegate.hasTask(target, hasTaskState);\n      },\n      onScheduleTask: function (delegate, _, target, task) {\n        return delegate.scheduleTask(target, task);\n      },\n      onInvokeTask: function (delegate, _, target, task, applyThis, applyArgs) {\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      },\n      onCancelTask: function (delegate, _, target, task) {\n        return delegate.cancelTask(target, task);\n      }\n    };\n    var _ZoneDelegate = /** @class */function () {\n      function _ZoneDelegate(zone, parentDelegate, zoneSpec) {\n        __publicField(this, \"_zone\");\n        __publicField(this, \"_taskCounts\", {\n          \"microTask\": 0,\n          \"macroTask\": 0,\n          \"eventTask\": 0\n        });\n        __publicField(this, \"_parentDelegate\");\n        __publicField(this, \"_forkDlgt\");\n        __publicField(this, \"_forkZS\");\n        __publicField(this, \"_forkCurrZone\");\n        __publicField(this, \"_interceptDlgt\");\n        __publicField(this, \"_interceptZS\");\n        __publicField(this, \"_interceptCurrZone\");\n        __publicField(this, \"_invokeDlgt\");\n        __publicField(this, \"_invokeZS\");\n        __publicField(this, \"_invokeCurrZone\");\n        __publicField(this, \"_handleErrorDlgt\");\n        __publicField(this, \"_handleErrorZS\");\n        __publicField(this, \"_handleErrorCurrZone\");\n        __publicField(this, \"_scheduleTaskDlgt\");\n        __publicField(this, \"_scheduleTaskZS\");\n        __publicField(this, \"_scheduleTaskCurrZone\");\n        __publicField(this, \"_invokeTaskDlgt\");\n        __publicField(this, \"_invokeTaskZS\");\n        __publicField(this, \"_invokeTaskCurrZone\");\n        __publicField(this, \"_cancelTaskDlgt\");\n        __publicField(this, \"_cancelTaskZS\");\n        __publicField(this, \"_cancelTaskCurrZone\");\n        __publicField(this, \"_hasTaskDlgt\");\n        __publicField(this, \"_hasTaskDlgtOwner\");\n        __publicField(this, \"_hasTaskZS\");\n        __publicField(this, \"_hasTaskCurrZone\");\n        this._zone = zone;\n        this._parentDelegate = parentDelegate;\n        this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);\n        this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);\n        this._forkCurrZone = zoneSpec && (zoneSpec.onFork ? this._zone : parentDelegate._forkCurrZone);\n        this._interceptZS = zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);\n        this._interceptDlgt = zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);\n        this._interceptCurrZone = zoneSpec && (zoneSpec.onIntercept ? this._zone : parentDelegate._interceptCurrZone);\n        this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);\n        this._invokeDlgt = zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);\n        this._invokeCurrZone = zoneSpec && (zoneSpec.onInvoke ? this._zone : parentDelegate._invokeCurrZone);\n        this._handleErrorZS = zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);\n        this._handleErrorDlgt = zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);\n        this._handleErrorCurrZone = zoneSpec && (zoneSpec.onHandleError ? this._zone : parentDelegate._handleErrorCurrZone);\n        this._scheduleTaskZS = zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);\n        this._scheduleTaskDlgt = zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);\n        this._scheduleTaskCurrZone = zoneSpec && (zoneSpec.onScheduleTask ? this._zone : parentDelegate._scheduleTaskCurrZone);\n        this._invokeTaskZS = zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);\n        this._invokeTaskDlgt = zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);\n        this._invokeTaskCurrZone = zoneSpec && (zoneSpec.onInvokeTask ? this._zone : parentDelegate._invokeTaskCurrZone);\n        this._cancelTaskZS = zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);\n        this._cancelTaskDlgt = zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);\n        this._cancelTaskCurrZone = zoneSpec && (zoneSpec.onCancelTask ? this._zone : parentDelegate._cancelTaskCurrZone);\n        this._hasTaskZS = null;\n        this._hasTaskDlgt = null;\n        this._hasTaskDlgtOwner = null;\n        this._hasTaskCurrZone = null;\n        var zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;\n        var parentHasTask = parentDelegate && parentDelegate._hasTaskZS;\n        if (zoneSpecHasTask || parentHasTask) {\n          this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;\n          this._hasTaskDlgt = parentDelegate;\n          this._hasTaskDlgtOwner = this;\n          this._hasTaskCurrZone = this._zone;\n          if (!zoneSpec.onScheduleTask) {\n            this._scheduleTaskZS = DELEGATE_ZS;\n            this._scheduleTaskDlgt = parentDelegate;\n            this._scheduleTaskCurrZone = this._zone;\n          }\n          if (!zoneSpec.onInvokeTask) {\n            this._invokeTaskZS = DELEGATE_ZS;\n            this._invokeTaskDlgt = parentDelegate;\n            this._invokeTaskCurrZone = this._zone;\n          }\n          if (!zoneSpec.onCancelTask) {\n            this._cancelTaskZS = DELEGATE_ZS;\n            this._cancelTaskDlgt = parentDelegate;\n            this._cancelTaskCurrZone = this._zone;\n          }\n        }\n      }\n      Object.defineProperty(_ZoneDelegate.prototype, \"zone\", {\n        get: function () {\n          return this._zone;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      _ZoneDelegate.prototype.fork = function (targetZone, zoneSpec) {\n        return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) : new ZoneImpl(targetZone, zoneSpec);\n      };\n      _ZoneDelegate.prototype.intercept = function (targetZone, callback, source) {\n        return this._interceptZS ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) : callback;\n      };\n      _ZoneDelegate.prototype.invoke = function (targetZone, callback, applyThis, applyArgs, source) {\n        return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) : callback.apply(applyThis, applyArgs);\n      };\n      _ZoneDelegate.prototype.handleError = function (targetZone, error) {\n        return this._handleErrorZS ? this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) : true;\n      };\n      _ZoneDelegate.prototype.scheduleTask = function (targetZone, task) {\n        var returnTask = task;\n        if (this._scheduleTaskZS) {\n          if (this._hasTaskZS) {\n            returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);\n          }\n          returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);\n          if (!returnTask) returnTask = task;\n        } else {\n          if (task.scheduleFn) {\n            task.scheduleFn(task);\n          } else if (task.type == microTask) {\n            scheduleMicroTask(task);\n          } else {\n            throw new Error(\"Task is missing scheduleFn.\");\n          }\n        }\n        return returnTask;\n      };\n      _ZoneDelegate.prototype.invokeTask = function (targetZone, task, applyThis, applyArgs) {\n        return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) : task.callback.apply(applyThis, applyArgs);\n      };\n      _ZoneDelegate.prototype.cancelTask = function (targetZone, task) {\n        var value;\n        if (this._cancelTaskZS) {\n          value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);\n        } else {\n          if (!task.cancelFn) {\n            throw Error(\"Task is not cancelable\");\n          }\n          value = task.cancelFn(task);\n        }\n        return value;\n      };\n      _ZoneDelegate.prototype.hasTask = function (targetZone, isEmpty) {\n        try {\n          this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);\n        } catch (err) {\n          this.handleError(targetZone, err);\n        }\n      };\n      _ZoneDelegate.prototype._updateTaskCount = function (type, count) {\n        var counts = this._taskCounts;\n        var prev = counts[type];\n        var next = counts[type] = prev + count;\n        if (next < 0) {\n          throw new Error(\"More tasks executed then were scheduled.\");\n        }\n        if (prev == 0 || next == 0) {\n          var isEmpty = {\n            microTask: counts[\"microTask\"] > 0,\n            macroTask: counts[\"macroTask\"] > 0,\n            eventTask: counts[\"eventTask\"] > 0,\n            change: type\n          };\n          this.hasTask(this._zone, isEmpty);\n        }\n      };\n      return _ZoneDelegate;\n    }();\n    var ZoneTask = /** @class */function () {\n      function ZoneTask(type, source, callback, options, scheduleFn, cancelFn) {\n        __publicField(this, \"type\");\n        __publicField(this, \"source\");\n        __publicField(this, \"invoke\");\n        __publicField(this, \"callback\");\n        __publicField(this, \"data\");\n        __publicField(this, \"scheduleFn\");\n        __publicField(this, \"cancelFn\");\n        __publicField(this, \"_zone\", null);\n        __publicField(this, \"runCount\", 0);\n        __publicField(this, \"_zoneDelegates\", null);\n        __publicField(this, \"_state\", \"notScheduled\");\n        this.type = type;\n        this.source = source;\n        this.data = options;\n        this.scheduleFn = scheduleFn;\n        this.cancelFn = cancelFn;\n        if (!callback) {\n          throw new Error(\"callback is not defined\");\n        }\n        this.callback = callback;\n        var self2 = this;\n        if (type === eventTask && options && options.useG) {\n          this.invoke = ZoneTask.invokeTask;\n        } else {\n          this.invoke = function () {\n            return ZoneTask.invokeTask.call(global, self2, this, arguments);\n          };\n        }\n      }\n      ZoneTask.invokeTask = function (task, target, args) {\n        if (!task) {\n          task = this;\n        }\n        _numberOfNestedTaskFrames++;\n        try {\n          task.runCount++;\n          return task.zone.runTask(task, target, args);\n        } finally {\n          if (_numberOfNestedTaskFrames == 1) {\n            drainMicroTaskQueue();\n          }\n          _numberOfNestedTaskFrames--;\n        }\n      };\n      Object.defineProperty(ZoneTask.prototype, \"zone\", {\n        get: function () {\n          return this._zone;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(ZoneTask.prototype, \"state\", {\n        get: function () {\n          return this._state;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      ZoneTask.prototype.cancelScheduleRequest = function () {\n        this._transitionTo(notScheduled, scheduling);\n      };\n      ZoneTask.prototype._transitionTo = function (toState, fromState1, fromState2) {\n        if (this._state === fromState1 || this._state === fromState2) {\n          this._state = toState;\n          if (toState == notScheduled) {\n            this._zoneDelegates = null;\n          }\n        } else {\n          throw new Error(\"\".concat(this.type, \" '\").concat(this.source, \"': can not transition to '\").concat(toState, \"', expecting state '\").concat(fromState1, \"'\").concat(fromState2 ? \" or '\" + fromState2 + \"'\" : \"\", \", was '\").concat(this._state, \"'.\"));\n        }\n      };\n      ZoneTask.prototype.toString = function () {\n        if (this.data && typeof this.data.handleId !== \"undefined\") {\n          return this.data.handleId.toString();\n        } else {\n          return Object.prototype.toString.call(this);\n        }\n      };\n      // add toJSON method to prevent cyclic error when\n      // call JSON.stringify(zoneTask)\n      ZoneTask.prototype.toJSON = function () {\n        return {\n          type: this.type,\n          state: this.state,\n          source: this.source,\n          zone: this.zone.name,\n          runCount: this.runCount\n        };\n      };\n      return ZoneTask;\n    }();\n    var symbolSetTimeout = __symbol__(\"setTimeout\");\n    var symbolPromise = __symbol__(\"Promise\");\n    var symbolThen = __symbol__(\"then\");\n    var _microTaskQueue = [];\n    var _isDrainingMicrotaskQueue = false;\n    var nativeMicroTaskQueuePromise;\n    function nativeScheduleMicroTask(func) {\n      if (!nativeMicroTaskQueuePromise) {\n        if (global[symbolPromise]) {\n          nativeMicroTaskQueuePromise = global[symbolPromise].resolve(0);\n        }\n      }\n      if (nativeMicroTaskQueuePromise) {\n        var nativeThen = nativeMicroTaskQueuePromise[symbolThen];\n        if (!nativeThen) {\n          nativeThen = nativeMicroTaskQueuePromise[\"then\"];\n        }\n        nativeThen.call(nativeMicroTaskQueuePromise, func);\n      } else {\n        global[symbolSetTimeout](func, 0);\n      }\n    }\n    function scheduleMicroTask(task) {\n      if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {\n        nativeScheduleMicroTask(drainMicroTaskQueue);\n      }\n      task && _microTaskQueue.push(task);\n    }\n    function drainMicroTaskQueue() {\n      if (!_isDrainingMicrotaskQueue) {\n        _isDrainingMicrotaskQueue = true;\n        while (_microTaskQueue.length) {\n          var queue = _microTaskQueue;\n          _microTaskQueue = [];\n          for (var i = 0; i < queue.length; i++) {\n            var task = queue[i];\n            try {\n              task.zone.runTask(task, null, null);\n            } catch (error) {\n              _api.onUnhandledError(error);\n            }\n          }\n        }\n        _api.microtaskDrainDone();\n        _isDrainingMicrotaskQueue = false;\n      }\n    }\n    var NO_ZONE = {\n      name: \"NO ZONE\"\n    };\n    var notScheduled = \"notScheduled\",\n      scheduling = \"scheduling\",\n      scheduled = \"scheduled\",\n      running = \"running\",\n      canceling = \"canceling\",\n      unknown = \"unknown\";\n    var microTask = \"microTask\",\n      macroTask = \"macroTask\",\n      eventTask = \"eventTask\";\n    var patches = {};\n    var _api = {\n      symbol: __symbol__,\n      currentZoneFrame: function () {\n        return _currentZoneFrame;\n      },\n      onUnhandledError: noop,\n      microtaskDrainDone: noop,\n      scheduleMicroTask: scheduleMicroTask,\n      showUncaughtError: function () {\n        return !ZoneImpl[__symbol__(\"ignoreConsoleErrorUncaughtError\")];\n      },\n      patchEventTarget: function () {\n        return [];\n      },\n      patchOnProperties: noop,\n      patchMethod: function () {\n        return noop;\n      },\n      bindArguments: function () {\n        return [];\n      },\n      patchThen: function () {\n        return noop;\n      },\n      patchMacroTask: function () {\n        return noop;\n      },\n      patchEventPrototype: function () {\n        return noop;\n      },\n      getGlobalObjects: function () {\n        return void 0;\n      },\n      ObjectDefineProperty: function () {\n        return noop;\n      },\n      ObjectGetOwnPropertyDescriptor: function () {\n        return void 0;\n      },\n      ObjectCreate: function () {\n        return void 0;\n      },\n      ArraySlice: function () {\n        return [];\n      },\n      patchClass: function () {\n        return noop;\n      },\n      wrapWithCurrentZone: function () {\n        return noop;\n      },\n      filterProperties: function () {\n        return [];\n      },\n      attachOriginToPatched: function () {\n        return noop;\n      },\n      _redefineProperty: function () {\n        return noop;\n      },\n      patchCallbacks: function () {\n        return noop;\n      },\n      nativeScheduleMicroTask: nativeScheduleMicroTask\n    };\n    var _currentZoneFrame = {\n      parent: null,\n      zone: new ZoneImpl(null, null)\n    };\n    var _currentTask = null;\n    var _numberOfNestedTaskFrames = 0;\n    function noop() {}\n    performanceMeasure(\"Zone\", \"Zone\");\n    return ZoneImpl;\n  }\n  // packages/zone.js/lib/zone.js\n  function loadZone() {\n    var _a;\n    var global2 = globalThis;\n    var checkDuplicate = global2[__symbol__(\"forceDuplicateZoneCheck\")] === true;\n    if (global2[\"Zone\"] && (checkDuplicate || typeof global2[\"Zone\"].__symbol__ !== \"function\")) {\n      throw new Error(\"Zone already loaded.\");\n    }\n    (_a = global2[\"Zone\"]) != null ? _a : global2[\"Zone\"] = initZone();\n    return global2[\"Zone\"];\n  }\n  // packages/zone.js/lib/common/utils.js\n  var ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n  var ObjectDefineProperty = Object.defineProperty;\n  var ObjectGetPrototypeOf = Object.getPrototypeOf;\n  var ObjectCreate = Object.create;\n  var ArraySlice = Array.prototype.slice;\n  var ADD_EVENT_LISTENER_STR = \"addEventListener\";\n  var REMOVE_EVENT_LISTENER_STR = \"removeEventListener\";\n  var ZONE_SYMBOL_ADD_EVENT_LISTENER = __symbol__(ADD_EVENT_LISTENER_STR);\n  var ZONE_SYMBOL_REMOVE_EVENT_LISTENER = __symbol__(REMOVE_EVENT_LISTENER_STR);\n  var TRUE_STR = \"true\";\n  var FALSE_STR = \"false\";\n  var ZONE_SYMBOL_PREFIX = __symbol__(\"\");\n  function wrapWithCurrentZone(callback, source) {\n    return Zone.current.wrap(callback, source);\n  }\n  function scheduleMacroTaskWithCurrentZone(source, callback, data, customSchedule, customCancel) {\n    return Zone.current.scheduleMacroTask(source, callback, data, customSchedule, customCancel);\n  }\n  var zoneSymbol = __symbol__;\n  var isWindowExists = typeof window !== \"undefined\";\n  var internalWindow = isWindowExists ? window : void 0;\n  var _global = isWindowExists && internalWindow || globalThis;\n  var REMOVE_ATTRIBUTE = \"removeAttribute\";\n  function bindArguments(args, source) {\n    for (var i = args.length - 1; i >= 0; i--) {\n      if (typeof args[i] === \"function\") {\n        args[i] = wrapWithCurrentZone(args[i], source + \"_\" + i);\n      }\n    }\n    return args;\n  }\n  function patchPrototype(prototype, fnNames) {\n    var source = prototype.constructor[\"name\"];\n    var _loop_1 = function (i) {\n      var name_1 = fnNames[i];\n      var delegate = prototype[name_1];\n      if (delegate) {\n        var prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, name_1);\n        if (!isPropertyWritable(prototypeDesc)) {\n          return \"continue\";\n        }\n        prototype[name_1] = function (delegate2) {\n          var patched = function () {\n            return delegate2.apply(this, bindArguments(arguments, source + \".\" + name_1));\n          };\n          attachOriginToPatched(patched, delegate2);\n          return patched;\n        }(delegate);\n      }\n    };\n    for (var i = 0; i < fnNames.length; i++) {\n      _loop_1(i);\n    }\n  }\n  function isPropertyWritable(propertyDesc) {\n    if (!propertyDesc) {\n      return true;\n    }\n    if (propertyDesc.writable === false) {\n      return false;\n    }\n    return !(typeof propertyDesc.get === \"function\" && typeof propertyDesc.set === \"undefined\");\n  }\n  var isWebWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n  var isNode = !(\"nw\" in _global) && typeof _global.process !== \"undefined\" && _global.process.toString() === \"[object process]\";\n  var isBrowser = !isNode && !isWebWorker && !!(isWindowExists && internalWindow[\"HTMLElement\"]);\n  var isMix = typeof _global.process !== \"undefined\" && _global.process.toString() === \"[object process]\" && !isWebWorker && !!(isWindowExists && internalWindow[\"HTMLElement\"]);\n  var zoneSymbolEventNames = {};\n  var enableBeforeunloadSymbol = zoneSymbol(\"enable_beforeunload\");\n  var wrapFn = function (event) {\n    event = event || _global.event;\n    if (!event) {\n      return;\n    }\n    var eventNameSymbol = zoneSymbolEventNames[event.type];\n    if (!eventNameSymbol) {\n      eventNameSymbol = zoneSymbolEventNames[event.type] = zoneSymbol(\"ON_PROPERTY\" + event.type);\n    }\n    var target = this || event.target || _global;\n    var listener = target[eventNameSymbol];\n    var result;\n    if (isBrowser && target === internalWindow && event.type === \"error\") {\n      var errorEvent = event;\n      result = listener && listener.call(this, errorEvent.message, errorEvent.filename, errorEvent.lineno, errorEvent.colno, errorEvent.error);\n      if (result === true) {\n        event.preventDefault();\n      }\n    } else {\n      result = listener && listener.apply(this, arguments);\n      if (\n      // https://github.com/angular/angular/issues/47579\n      // https://www.w3.org/TR/2011/WD-html5-20110525/history.html#beforeunloadevent\n      // This is the only specific case we should check for. The spec defines that the\n      // `returnValue` attribute represents the message to show the user. When the event\n      // is created, this attribute must be set to the empty string.\n      event.type === \"beforeunload\" &&\n      // To prevent any breaking changes resulting from this change, given that\n      // it was already causing a significant number of failures in G3, we have hidden\n      // that behavior behind a global configuration flag. Consumers can enable this\n      // flag explicitly if they want the `beforeunload` event to be handled as defined\n      // in the specification.\n      _global[enableBeforeunloadSymbol] &&\n      // The IDL event definition is `attribute DOMString returnValue`, so we check whether\n      // `typeof result` is a string.\n      typeof result === \"string\") {\n        event.returnValue = result;\n      } else if (result != void 0 && !result) {\n        event.preventDefault();\n      }\n    }\n    return result;\n  };\n  function patchProperty(obj, prop, prototype) {\n    var desc = ObjectGetOwnPropertyDescriptor(obj, prop);\n    if (!desc && prototype) {\n      var prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, prop);\n      if (prototypeDesc) {\n        desc = {\n          enumerable: true,\n          configurable: true\n        };\n      }\n    }\n    if (!desc || !desc.configurable) {\n      return;\n    }\n    var onPropPatchedSymbol = zoneSymbol(\"on\" + prop + \"patched\");\n    if (obj.hasOwnProperty(onPropPatchedSymbol) && obj[onPropPatchedSymbol]) {\n      return;\n    }\n    delete desc.writable;\n    delete desc.value;\n    var originalDescGet = desc.get;\n    var originalDescSet = desc.set;\n    var eventName = prop.slice(2);\n    var eventNameSymbol = zoneSymbolEventNames[eventName];\n    if (!eventNameSymbol) {\n      eventNameSymbol = zoneSymbolEventNames[eventName] = zoneSymbol(\"ON_PROPERTY\" + eventName);\n    }\n    desc.set = function (newValue) {\n      var target = this;\n      if (!target && obj === _global) {\n        target = _global;\n      }\n      if (!target) {\n        return;\n      }\n      var previousValue = target[eventNameSymbol];\n      if (typeof previousValue === \"function\") {\n        target.removeEventListener(eventName, wrapFn);\n      }\n      originalDescSet == null ? void 0 : originalDescSet.call(target, null);\n      target[eventNameSymbol] = newValue;\n      if (typeof newValue === \"function\") {\n        target.addEventListener(eventName, wrapFn, false);\n      }\n    };\n    desc.get = function () {\n      var target = this;\n      if (!target && obj === _global) {\n        target = _global;\n      }\n      if (!target) {\n        return null;\n      }\n      var listener = target[eventNameSymbol];\n      if (listener) {\n        return listener;\n      } else if (originalDescGet) {\n        var value = originalDescGet.call(this);\n        if (value) {\n          desc.set.call(this, value);\n          if (typeof target[REMOVE_ATTRIBUTE] === \"function\") {\n            target.removeAttribute(prop);\n          }\n          return value;\n        }\n      }\n      return null;\n    };\n    ObjectDefineProperty(obj, prop, desc);\n    obj[onPropPatchedSymbol] = true;\n  }\n  function patchOnProperties(obj, properties, prototype) {\n    if (properties) {\n      for (var i = 0; i < properties.length; i++) {\n        patchProperty(obj, \"on\" + properties[i], prototype);\n      }\n    } else {\n      var onProperties = [];\n      for (var prop in obj) {\n        if (prop.slice(0, 2) == \"on\") {\n          onProperties.push(prop);\n        }\n      }\n      for (var j = 0; j < onProperties.length; j++) {\n        patchProperty(obj, onProperties[j], prototype);\n      }\n    }\n  }\n  var originalInstanceKey = zoneSymbol(\"originalInstance\");\n  function patchClass(className) {\n    var OriginalClass = _global[className];\n    if (!OriginalClass) return;\n    _global[zoneSymbol(className)] = OriginalClass;\n    _global[className] = function () {\n      var a = bindArguments(arguments, className);\n      switch (a.length) {\n        case 0:\n          this[originalInstanceKey] = new OriginalClass();\n          break;\n        case 1:\n          this[originalInstanceKey] = new OriginalClass(a[0]);\n          break;\n        case 2:\n          this[originalInstanceKey] = new OriginalClass(a[0], a[1]);\n          break;\n        case 3:\n          this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);\n          break;\n        case 4:\n          this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);\n          break;\n        default:\n          throw new Error(\"Arg list too long.\");\n      }\n    };\n    attachOriginToPatched(_global[className], OriginalClass);\n    var instance = new OriginalClass(function () {});\n    var prop;\n    for (prop in instance) {\n      if (className === \"XMLHttpRequest\" && prop === \"responseBlob\") continue;\n      (function (prop2) {\n        if (typeof instance[prop2] === \"function\") {\n          _global[className].prototype[prop2] = function () {\n            return this[originalInstanceKey][prop2].apply(this[originalInstanceKey], arguments);\n          };\n        } else {\n          ObjectDefineProperty(_global[className].prototype, prop2, {\n            set: function (fn) {\n              if (typeof fn === \"function\") {\n                this[originalInstanceKey][prop2] = wrapWithCurrentZone(fn, className + \".\" + prop2);\n                attachOriginToPatched(this[originalInstanceKey][prop2], fn);\n              } else {\n                this[originalInstanceKey][prop2] = fn;\n              }\n            },\n            get: function () {\n              return this[originalInstanceKey][prop2];\n            }\n          });\n        }\n      })(prop);\n    }\n    for (prop in OriginalClass) {\n      if (prop !== \"prototype\" && OriginalClass.hasOwnProperty(prop)) {\n        _global[className][prop] = OriginalClass[prop];\n      }\n    }\n  }\n  function copySymbolProperties(src, dest) {\n    if (typeof Object.getOwnPropertySymbols !== \"function\") {\n      return;\n    }\n    var symbols = Object.getOwnPropertySymbols(src);\n    symbols.forEach(function (symbol) {\n      var desc = Object.getOwnPropertyDescriptor(src, symbol);\n      Object.defineProperty(dest, symbol, {\n        get: function () {\n          return src[symbol];\n        },\n        set: function (value) {\n          if (desc && (!desc.writable || typeof desc.set !== \"function\")) {\n            return;\n          }\n          src[symbol] = value;\n        },\n        enumerable: desc ? desc.enumerable : true,\n        configurable: desc ? desc.configurable : true\n      });\n    });\n  }\n  var shouldCopySymbolProperties = false;\n  function patchMethod(target, name, patchFn) {\n    var proto = target;\n    while (proto && !proto.hasOwnProperty(name)) {\n      proto = ObjectGetPrototypeOf(proto);\n    }\n    if (!proto && target[name]) {\n      proto = target;\n    }\n    var delegateName = zoneSymbol(name);\n    var delegate = null;\n    if (proto && (!(delegate = proto[delegateName]) || !proto.hasOwnProperty(delegateName))) {\n      delegate = proto[delegateName] = proto[name];\n      var desc = proto && ObjectGetOwnPropertyDescriptor(proto, name);\n      if (isPropertyWritable(desc)) {\n        var patchDelegate_1 = patchFn(delegate, delegateName, name);\n        proto[name] = function () {\n          return patchDelegate_1(this, arguments);\n        };\n        attachOriginToPatched(proto[name], delegate);\n        if (shouldCopySymbolProperties) {\n          copySymbolProperties(delegate, proto[name]);\n        }\n      }\n    }\n    return delegate;\n  }\n  function patchMacroTask(obj, funcName, metaCreator) {\n    var setNative = null;\n    function scheduleTask(task) {\n      var data = task.data;\n      data.args[data.cbIdx] = function () {\n        task.invoke.apply(this, arguments);\n      };\n      setNative.apply(data.target, data.args);\n      return task;\n    }\n    setNative = patchMethod(obj, funcName, function (delegate) {\n      return function (self2, args) {\n        var meta = metaCreator(self2, args);\n        if (meta.cbIdx >= 0 && typeof args[meta.cbIdx] === \"function\") {\n          return scheduleMacroTaskWithCurrentZone(meta.name, args[meta.cbIdx], meta, scheduleTask);\n        } else {\n          return delegate.apply(self2, args);\n        }\n      };\n    });\n  }\n  function attachOriginToPatched(patched, original) {\n    patched[zoneSymbol(\"OriginalDelegate\")] = original;\n  }\n  function isFunction(value) {\n    return typeof value === \"function\";\n  }\n  function isNumber(value) {\n    return typeof value === \"number\";\n  }\n  // packages/zone.js/lib/common/events.js\n  var OPTIMIZED_ZONE_EVENT_TASK_DATA = {\n    useG: true\n  };\n  var zoneSymbolEventNames2 = {};\n  var globalSources = {};\n  var EVENT_NAME_SYMBOL_REGX = new RegExp(\"^\" + ZONE_SYMBOL_PREFIX + \"(\\\\w+)(true|false)$\");\n  var IMMEDIATE_PROPAGATION_SYMBOL = zoneSymbol(\"propagationStopped\");\n  function prepareEventNames(eventName, eventNameToString) {\n    var falseEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + FALSE_STR;\n    var trueEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + TRUE_STR;\n    var symbol = ZONE_SYMBOL_PREFIX + falseEventName;\n    var symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;\n    zoneSymbolEventNames2[eventName] = {};\n    zoneSymbolEventNames2[eventName][FALSE_STR] = symbol;\n    zoneSymbolEventNames2[eventName][TRUE_STR] = symbolCapture;\n  }\n  function patchEventTarget(_global2, api, apis, patchOptions) {\n    var ADD_EVENT_LISTENER = patchOptions && patchOptions.add || ADD_EVENT_LISTENER_STR;\n    var REMOVE_EVENT_LISTENER = patchOptions && patchOptions.rm || REMOVE_EVENT_LISTENER_STR;\n    var LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.listeners || \"eventListeners\";\n    var REMOVE_ALL_LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.rmAll || \"removeAllListeners\";\n    var zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);\n    var ADD_EVENT_LISTENER_SOURCE = \".\" + ADD_EVENT_LISTENER + \":\";\n    var PREPEND_EVENT_LISTENER = \"prependListener\";\n    var PREPEND_EVENT_LISTENER_SOURCE = \".\" + PREPEND_EVENT_LISTENER + \":\";\n    var invokeTask = function (task, target, event) {\n      if (task.isRemoved) {\n        return;\n      }\n      var delegate = task.callback;\n      if (typeof delegate === \"object\" && delegate.handleEvent) {\n        task.callback = function (event2) {\n          return delegate.handleEvent(event2);\n        };\n        task.originalDelegate = delegate;\n      }\n      var error;\n      try {\n        task.invoke(task, target, [event]);\n      } catch (err) {\n        error = err;\n      }\n      var options = task.options;\n      if (options && typeof options === \"object\" && options.once) {\n        var delegate2 = task.originalDelegate ? task.originalDelegate : task.callback;\n        target[REMOVE_EVENT_LISTENER].call(target, event.type, delegate2, options);\n      }\n      return error;\n    };\n    function globalCallback(context, event, isCapture) {\n      event = event || _global2.event;\n      if (!event) {\n        return;\n      }\n      var target = context || event.target || _global2;\n      var tasks = target[zoneSymbolEventNames2[event.type][isCapture ? TRUE_STR : FALSE_STR]];\n      if (tasks) {\n        var errors = [];\n        if (tasks.length === 1) {\n          var err = invokeTask(tasks[0], target, event);\n          err && errors.push(err);\n        } else {\n          var copyTasks = tasks.slice();\n          for (var i = 0; i < copyTasks.length; i++) {\n            if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {\n              break;\n            }\n            var err = invokeTask(copyTasks[i], target, event);\n            err && errors.push(err);\n          }\n        }\n        if (errors.length === 1) {\n          throw errors[0];\n        } else {\n          var _loop_2 = function (i) {\n            var err = errors[i];\n            api.nativeScheduleMicroTask(function () {\n              throw err;\n            });\n          };\n          for (var i = 0; i < errors.length; i++) {\n            _loop_2(i);\n          }\n        }\n      }\n    }\n    var globalZoneAwareCallback = function (event) {\n      return globalCallback(this, event, false);\n    };\n    var globalZoneAwareCaptureCallback = function (event) {\n      return globalCallback(this, event, true);\n    };\n    function patchEventTargetMethods(obj, patchOptions2) {\n      if (!obj) {\n        return false;\n      }\n      var useGlobalCallback = true;\n      if (patchOptions2 && patchOptions2.useG !== void 0) {\n        useGlobalCallback = patchOptions2.useG;\n      }\n      var validateHandler = patchOptions2 && patchOptions2.vh;\n      var checkDuplicate = true;\n      if (patchOptions2 && patchOptions2.chkDup !== void 0) {\n        checkDuplicate = patchOptions2.chkDup;\n      }\n      var returnTarget = false;\n      if (patchOptions2 && patchOptions2.rt !== void 0) {\n        returnTarget = patchOptions2.rt;\n      }\n      var proto = obj;\n      while (proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {\n        proto = ObjectGetPrototypeOf(proto);\n      }\n      if (!proto && obj[ADD_EVENT_LISTENER]) {\n        proto = obj;\n      }\n      if (!proto) {\n        return false;\n      }\n      if (proto[zoneSymbolAddEventListener]) {\n        return false;\n      }\n      var eventNameToString = patchOptions2 && patchOptions2.eventNameToString;\n      var taskData = {};\n      var nativeAddEventListener = proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER];\n      var nativeRemoveEventListener = proto[zoneSymbol(REMOVE_EVENT_LISTENER)] = proto[REMOVE_EVENT_LISTENER];\n      var nativeListeners = proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] = proto[LISTENERS_EVENT_LISTENER];\n      var nativeRemoveAllListeners = proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] = proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER];\n      var nativePrependEventListener;\n      if (patchOptions2 && patchOptions2.prepend) {\n        nativePrependEventListener = proto[zoneSymbol(patchOptions2.prepend)] = proto[patchOptions2.prepend];\n      }\n      function buildEventListenerOptions(options, passive) {\n        if (!passive) {\n          return options;\n        }\n        if (typeof options === \"boolean\") {\n          return {\n            capture: options,\n            passive: true\n          };\n        }\n        if (!options) {\n          return {\n            passive: true\n          };\n        }\n        if (typeof options === \"object\" && options.passive !== false) {\n          return __spreadProps(__spreadValues({}, options), {\n            passive: true\n          });\n        }\n        return options;\n      }\n      var customScheduleGlobal = function (task) {\n        if (taskData.isExisting) {\n          return;\n        }\n        return nativeAddEventListener.call(taskData.target, taskData.eventName, taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, taskData.options);\n      };\n      var customCancelGlobal = function (task) {\n        if (!task.isRemoved) {\n          var symbolEventNames = zoneSymbolEventNames2[task.eventName];\n          var symbolEventName = void 0;\n          if (symbolEventNames) {\n            symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];\n          }\n          var existingTasks = symbolEventName && task.target[symbolEventName];\n          if (existingTasks) {\n            for (var i = 0; i < existingTasks.length; i++) {\n              var existingTask = existingTasks[i];\n              if (existingTask === task) {\n                existingTasks.splice(i, 1);\n                task.isRemoved = true;\n                if (task.removeAbortListener) {\n                  task.removeAbortListener();\n                  task.removeAbortListener = null;\n                }\n                if (existingTasks.length === 0) {\n                  task.allRemoved = true;\n                  task.target[symbolEventName] = null;\n                }\n                break;\n              }\n            }\n          }\n        }\n        if (!task.allRemoved) {\n          return;\n        }\n        return nativeRemoveEventListener.call(task.target, task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, task.options);\n      };\n      var customScheduleNonGlobal = function (task) {\n        return nativeAddEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);\n      };\n      var customSchedulePrepend = function (task) {\n        return nativePrependEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);\n      };\n      var customCancelNonGlobal = function (task) {\n        return nativeRemoveEventListener.call(task.target, task.eventName, task.invoke, task.options);\n      };\n      var customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;\n      var customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;\n      var compareTaskCallbackVsDelegate = function (task, delegate) {\n        var typeOfDelegate = typeof delegate;\n        return typeOfDelegate === \"function\" && task.callback === delegate || typeOfDelegate === \"object\" && task.originalDelegate === delegate;\n      };\n      var compare = (patchOptions2 == null ? void 0 : patchOptions2.diff) || compareTaskCallbackVsDelegate;\n      var unpatchedEvents = Zone[zoneSymbol(\"UNPATCHED_EVENTS\")];\n      var passiveEvents = _global2[zoneSymbol(\"PASSIVE_EVENTS\")];\n      function copyEventListenerOptions(options) {\n        if (typeof options === \"object\" && options !== null) {\n          var newOptions = __spreadValues({}, options);\n          if (options.signal) {\n            newOptions.signal = options.signal;\n          }\n          return newOptions;\n        }\n        return options;\n      }\n      var makeAddListener = function (nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget2, prepend) {\n        if (returnTarget2 === void 0) {\n          returnTarget2 = false;\n        }\n        if (prepend === void 0) {\n          prepend = false;\n        }\n        return function () {\n          var target = this || _global2;\n          var eventName = arguments[0];\n          if (patchOptions2 && patchOptions2.transferEventName) {\n            eventName = patchOptions2.transferEventName(eventName);\n          }\n          var delegate = arguments[1];\n          if (!delegate) {\n            return nativeListener.apply(this, arguments);\n          }\n          if (isNode && eventName === \"uncaughtException\") {\n            return nativeListener.apply(this, arguments);\n          }\n          var isEventListenerObject = false;\n          if (typeof delegate !== \"function\") {\n            if (!delegate.handleEvent) {\n              return nativeListener.apply(this, arguments);\n            }\n            isEventListenerObject = true;\n          }\n          if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) {\n            return;\n          }\n          var passive = !!passiveEvents && passiveEvents.indexOf(eventName) !== -1;\n          var options = copyEventListenerOptions(buildEventListenerOptions(arguments[2], passive));\n          var signal = options == null ? void 0 : options.signal;\n          if (signal == null ? void 0 : signal.aborted) {\n            return;\n          }\n          if (unpatchedEvents) {\n            for (var i = 0; i < unpatchedEvents.length; i++) {\n              if (eventName === unpatchedEvents[i]) {\n                if (passive) {\n                  return nativeListener.call(target, eventName, delegate, options);\n                } else {\n                  return nativeListener.apply(this, arguments);\n                }\n              }\n            }\n          }\n          var capture = !options ? false : typeof options === \"boolean\" ? true : options.capture;\n          var once = options && typeof options === \"object\" ? options.once : false;\n          var zone = Zone.current;\n          var symbolEventNames = zoneSymbolEventNames2[eventName];\n          if (!symbolEventNames) {\n            prepareEventNames(eventName, eventNameToString);\n            symbolEventNames = zoneSymbolEventNames2[eventName];\n          }\n          var symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];\n          var existingTasks = target[symbolEventName];\n          var isExisting = false;\n          if (existingTasks) {\n            isExisting = true;\n            if (checkDuplicate) {\n              for (var i = 0; i < existingTasks.length; i++) {\n                if (compare(existingTasks[i], delegate)) {\n                  return;\n                }\n              }\n            }\n          } else {\n            existingTasks = target[symbolEventName] = [];\n          }\n          var source;\n          var constructorName = target.constructor[\"name\"];\n          var targetSource = globalSources[constructorName];\n          if (targetSource) {\n            source = targetSource[eventName];\n          }\n          if (!source) {\n            source = constructorName + addSource + (eventNameToString ? eventNameToString(eventName) : eventName);\n          }\n          taskData.options = options;\n          if (once) {\n            taskData.options.once = false;\n          }\n          taskData.target = target;\n          taskData.capture = capture;\n          taskData.eventName = eventName;\n          taskData.isExisting = isExisting;\n          var data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : void 0;\n          if (data) {\n            data.taskData = taskData;\n          }\n          if (signal) {\n            taskData.options.signal = void 0;\n          }\n          var task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn);\n          if (signal) {\n            taskData.options.signal = signal;\n            var onAbort_1 = function () {\n              return task.zone.cancelTask(task);\n            };\n            nativeListener.call(signal, \"abort\", onAbort_1, {\n              once: true\n            });\n            task.removeAbortListener = function () {\n              return signal.removeEventListener(\"abort\", onAbort_1);\n            };\n          }\n          taskData.target = null;\n          if (data) {\n            data.taskData = null;\n          }\n          if (once) {\n            taskData.options.once = true;\n          }\n          if (typeof task.options !== \"boolean\") {\n            task.options = options;\n          }\n          task.target = target;\n          task.capture = capture;\n          task.eventName = eventName;\n          if (isEventListenerObject) {\n            task.originalDelegate = delegate;\n          }\n          if (!prepend) {\n            existingTasks.push(task);\n          } else {\n            existingTasks.unshift(task);\n          }\n          if (returnTarget2) {\n            return target;\n          }\n        };\n      };\n      proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);\n      if (nativePrependEventListener) {\n        proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);\n      }\n      proto[REMOVE_EVENT_LISTENER] = function () {\n        var target = this || _global2;\n        var eventName = arguments[0];\n        if (patchOptions2 && patchOptions2.transferEventName) {\n          eventName = patchOptions2.transferEventName(eventName);\n        }\n        var options = arguments[2];\n        var capture = !options ? false : typeof options === \"boolean\" ? true : options.capture;\n        var delegate = arguments[1];\n        if (!delegate) {\n          return nativeRemoveEventListener.apply(this, arguments);\n        }\n        if (validateHandler && !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {\n          return;\n        }\n        var symbolEventNames = zoneSymbolEventNames2[eventName];\n        var symbolEventName;\n        if (symbolEventNames) {\n          symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];\n        }\n        var existingTasks = symbolEventName && target[symbolEventName];\n        if (existingTasks) {\n          for (var i = 0; i < existingTasks.length; i++) {\n            var existingTask = existingTasks[i];\n            if (compare(existingTask, delegate)) {\n              existingTasks.splice(i, 1);\n              existingTask.isRemoved = true;\n              if (existingTasks.length === 0) {\n                existingTask.allRemoved = true;\n                target[symbolEventName] = null;\n                if (!capture && typeof eventName === \"string\") {\n                  var onPropertySymbol = ZONE_SYMBOL_PREFIX + \"ON_PROPERTY\" + eventName;\n                  target[onPropertySymbol] = null;\n                }\n              }\n              existingTask.zone.cancelTask(existingTask);\n              if (returnTarget) {\n                return target;\n              }\n              return;\n            }\n          }\n        }\n        return nativeRemoveEventListener.apply(this, arguments);\n      };\n      proto[LISTENERS_EVENT_LISTENER] = function () {\n        var target = this || _global2;\n        var eventName = arguments[0];\n        if (patchOptions2 && patchOptions2.transferEventName) {\n          eventName = patchOptions2.transferEventName(eventName);\n        }\n        var listeners = [];\n        var tasks = findEventTasks(target, eventNameToString ? eventNameToString(eventName) : eventName);\n        for (var i = 0; i < tasks.length; i++) {\n          var task = tasks[i];\n          var delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n          listeners.push(delegate);\n        }\n        return listeners;\n      };\n      proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function () {\n        var target = this || _global2;\n        var eventName = arguments[0];\n        if (!eventName) {\n          var keys = Object.keys(target);\n          for (var i = 0; i < keys.length; i++) {\n            var prop = keys[i];\n            var match = EVENT_NAME_SYMBOL_REGX.exec(prop);\n            var evtName = match && match[1];\n            if (evtName && evtName !== \"removeListener\") {\n              this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, evtName);\n            }\n          }\n          this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, \"removeListener\");\n        } else {\n          if (patchOptions2 && patchOptions2.transferEventName) {\n            eventName = patchOptions2.transferEventName(eventName);\n          }\n          var symbolEventNames = zoneSymbolEventNames2[eventName];\n          if (symbolEventNames) {\n            var symbolEventName = symbolEventNames[FALSE_STR];\n            var symbolCaptureEventName = symbolEventNames[TRUE_STR];\n            var tasks = target[symbolEventName];\n            var captureTasks = target[symbolCaptureEventName];\n            if (tasks) {\n              var removeTasks = tasks.slice();\n              for (var i = 0; i < removeTasks.length; i++) {\n                var task = removeTasks[i];\n                var delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n                this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);\n              }\n            }\n            if (captureTasks) {\n              var removeTasks = captureTasks.slice();\n              for (var i = 0; i < removeTasks.length; i++) {\n                var task = removeTasks[i];\n                var delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n                this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);\n              }\n            }\n          }\n        }\n        if (returnTarget) {\n          return this;\n        }\n      };\n      attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);\n      attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);\n      if (nativeRemoveAllListeners) {\n        attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);\n      }\n      if (nativeListeners) {\n        attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);\n      }\n      return true;\n    }\n    var results = [];\n    for (var i = 0; i < apis.length; i++) {\n      results[i] = patchEventTargetMethods(apis[i], patchOptions);\n    }\n    return results;\n  }\n  function findEventTasks(target, eventName) {\n    if (!eventName) {\n      var foundTasks = [];\n      for (var prop in target) {\n        var match = EVENT_NAME_SYMBOL_REGX.exec(prop);\n        var evtName = match && match[1];\n        if (evtName && (!eventName || evtName === eventName)) {\n          var tasks = target[prop];\n          if (tasks) {\n            for (var i = 0; i < tasks.length; i++) {\n              foundTasks.push(tasks[i]);\n            }\n          }\n        }\n      }\n      return foundTasks;\n    }\n    var symbolEventName = zoneSymbolEventNames2[eventName];\n    if (!symbolEventName) {\n      prepareEventNames(eventName);\n      symbolEventName = zoneSymbolEventNames2[eventName];\n    }\n    var captureFalseTasks = target[symbolEventName[FALSE_STR]];\n    var captureTrueTasks = target[symbolEventName[TRUE_STR]];\n    if (!captureFalseTasks) {\n      return captureTrueTasks ? captureTrueTasks.slice() : [];\n    } else {\n      return captureTrueTasks ? captureFalseTasks.concat(captureTrueTasks) : captureFalseTasks.slice();\n    }\n  }\n  function patchEventPrototype(global2, api) {\n    var Event = global2[\"Event\"];\n    if (Event && Event.prototype) {\n      api.patchMethod(Event.prototype, \"stopImmediatePropagation\", function (delegate) {\n        return function (self2, args) {\n          self2[IMMEDIATE_PROPAGATION_SYMBOL] = true;\n          delegate && delegate.apply(self2, args);\n        };\n      });\n    }\n  }\n  // packages/zone.js/lib/common/queue-microtask.js\n  function patchQueueMicrotask(global2, api) {\n    api.patchMethod(global2, \"queueMicrotask\", function (delegate) {\n      return function (self2, args) {\n        Zone.current.scheduleMicroTask(\"queueMicrotask\", args[0]);\n      };\n    });\n  }\n  // packages/zone.js/lib/common/timers.js\n  var taskSymbol = zoneSymbol(\"zoneTask\");\n  function patchTimer(window2, setName, cancelName, nameSuffix) {\n    var setNative = null;\n    var clearNative = null;\n    setName += nameSuffix;\n    cancelName += nameSuffix;\n    var tasksByHandleId = {};\n    function scheduleTask(task) {\n      var data = task.data;\n      data.args[0] = function () {\n        return task.invoke.apply(this, arguments);\n      };\n      var handleOrId = setNative.apply(window2, data.args);\n      if (isNumber(handleOrId)) {\n        data.handleId = handleOrId;\n      } else {\n        data.handle = handleOrId;\n        data.isRefreshable = isFunction(handleOrId.refresh);\n      }\n      return task;\n    }\n    function clearTask(task) {\n      var _b = task.data,\n        handle = _b.handle,\n        handleId = _b.handleId;\n      return clearNative.call(window2, handle != null ? handle : handleId);\n    }\n    setNative = patchMethod(window2, setName, function (delegate) {\n      return function (self2, args) {\n        var _a;\n        if (isFunction(args[0])) {\n          var options_1 = {\n            isRefreshable: false,\n            isPeriodic: nameSuffix === \"Interval\",\n            delay: nameSuffix === \"Timeout\" || nameSuffix === \"Interval\" ? args[1] || 0 : void 0,\n            args: args\n          };\n          var callback_1 = args[0];\n          args[0] = function timer() {\n            try {\n              return callback_1.apply(this, arguments);\n            } finally {\n              var handle2 = options_1.handle,\n                handleId2 = options_1.handleId,\n                isPeriodic2 = options_1.isPeriodic,\n                isRefreshable2 = options_1.isRefreshable;\n              if (!isPeriodic2 && !isRefreshable2) {\n                if (handleId2) {\n                  delete tasksByHandleId[handleId2];\n                } else if (handle2) {\n                  handle2[taskSymbol] = null;\n                }\n              }\n            }\n          };\n          var task_1 = scheduleMacroTaskWithCurrentZone(setName, args[0], options_1, scheduleTask, clearTask);\n          if (!task_1) {\n            return task_1;\n          }\n          var _b = task_1.data,\n            handleId = _b.handleId,\n            handle = _b.handle,\n            isRefreshable = _b.isRefreshable,\n            isPeriodic = _b.isPeriodic;\n          if (handleId) {\n            tasksByHandleId[handleId] = task_1;\n          } else if (handle) {\n            handle[taskSymbol] = task_1;\n            if (isRefreshable && !isPeriodic) {\n              var originalRefresh_1 = handle.refresh;\n              handle.refresh = function () {\n                var zone = task_1.zone,\n                  state = task_1.state;\n                if (state === \"notScheduled\") {\n                  task_1._state = \"scheduled\";\n                  zone._updateTaskCount(task_1, 1);\n                } else if (state === \"running\") {\n                  task_1._state = \"scheduling\";\n                }\n                return originalRefresh_1.call(this);\n              };\n            }\n          }\n          return (_a = handle != null ? handle : handleId) != null ? _a : task_1;\n        } else {\n          return delegate.apply(window2, args);\n        }\n      };\n    });\n    clearNative = patchMethod(window2, cancelName, function (delegate) {\n      return function (self2, args) {\n        var id = args[0];\n        var task;\n        if (isNumber(id)) {\n          task = tasksByHandleId[id];\n          delete tasksByHandleId[id];\n        } else {\n          task = id == null ? void 0 : id[taskSymbol];\n          if (task) {\n            id[taskSymbol] = null;\n          } else {\n            task = id;\n          }\n        }\n        if (task == null ? void 0 : task.type) {\n          if (task.cancelFn) {\n            task.zone.cancelTask(task);\n          }\n        } else {\n          delegate.apply(window2, args);\n        }\n      };\n    });\n  }\n  // packages/zone.js/lib/browser/custom-elements.js\n  function patchCustomElements(_global2, api) {\n    var _b = api.getGlobalObjects(),\n      isBrowser2 = _b.isBrowser,\n      isMix2 = _b.isMix;\n    if (!isBrowser2 && !isMix2 || !_global2[\"customElements\"] || !(\"customElements\" in _global2)) {\n      return;\n    }\n    var callbacks = [\"connectedCallback\", \"disconnectedCallback\", \"adoptedCallback\", \"attributeChangedCallback\", \"formAssociatedCallback\", \"formDisabledCallback\", \"formResetCallback\", \"formStateRestoreCallback\"];\n    api.patchCallbacks(api, _global2.customElements, \"customElements\", \"define\", callbacks);\n  }\n  // packages/zone.js/lib/browser/event-target.js\n  function eventTargetPatch(_global2, api) {\n    if (Zone[api.symbol(\"patchEventTarget\")]) {\n      return;\n    }\n    var _b = api.getGlobalObjects(),\n      eventNames = _b.eventNames,\n      zoneSymbolEventNames3 = _b.zoneSymbolEventNames,\n      TRUE_STR2 = _b.TRUE_STR,\n      FALSE_STR2 = _b.FALSE_STR,\n      ZONE_SYMBOL_PREFIX2 = _b.ZONE_SYMBOL_PREFIX;\n    for (var i = 0; i < eventNames.length; i++) {\n      var eventName = eventNames[i];\n      var falseEventName = eventName + FALSE_STR2;\n      var trueEventName = eventName + TRUE_STR2;\n      var symbol = ZONE_SYMBOL_PREFIX2 + falseEventName;\n      var symbolCapture = ZONE_SYMBOL_PREFIX2 + trueEventName;\n      zoneSymbolEventNames3[eventName] = {};\n      zoneSymbolEventNames3[eventName][FALSE_STR2] = symbol;\n      zoneSymbolEventNames3[eventName][TRUE_STR2] = symbolCapture;\n    }\n    var EVENT_TARGET = _global2[\"EventTarget\"];\n    if (!EVENT_TARGET || !EVENT_TARGET.prototype) {\n      return;\n    }\n    api.patchEventTarget(_global2, api, [EVENT_TARGET && EVENT_TARGET.prototype]);\n    return true;\n  }\n  function patchEvent(global2, api) {\n    api.patchEventPrototype(global2, api);\n  }\n  // packages/zone.js/lib/browser/property-descriptor.js\n  function filterProperties(target, onProperties, ignoreProperties) {\n    if (!ignoreProperties || ignoreProperties.length === 0) {\n      return onProperties;\n    }\n    var tip = ignoreProperties.filter(function (ip) {\n      return ip.target === target;\n    });\n    if (tip.length === 0) {\n      return onProperties;\n    }\n    var targetIgnoreProperties = tip[0].ignoreProperties;\n    return onProperties.filter(function (op) {\n      return targetIgnoreProperties.indexOf(op) === -1;\n    });\n  }\n  function patchFilteredProperties(target, onProperties, ignoreProperties, prototype) {\n    if (!target) {\n      return;\n    }\n    var filteredProperties = filterProperties(target, onProperties, ignoreProperties);\n    patchOnProperties(target, filteredProperties, prototype);\n  }\n  function getOnEventNames(target) {\n    return Object.getOwnPropertyNames(target).filter(function (name) {\n      return name.startsWith(\"on\") && name.length > 2;\n    }).map(function (name) {\n      return name.substring(2);\n    });\n  }\n  function propertyDescriptorPatch(api, _global2) {\n    if (isNode && !isMix) {\n      return;\n    }\n    if (Zone[api.symbol(\"patchEvents\")]) {\n      return;\n    }\n    var ignoreProperties = _global2[\"__Zone_ignore_on_properties\"];\n    var patchTargets = [];\n    if (isBrowser) {\n      var internalWindow2 = window;\n      patchTargets = patchTargets.concat([\"Document\", \"SVGElement\", \"Element\", \"HTMLElement\", \"HTMLBodyElement\", \"HTMLMediaElement\", \"HTMLFrameSetElement\", \"HTMLFrameElement\", \"HTMLIFrameElement\", \"HTMLMarqueeElement\", \"Worker\"]);\n      patchFilteredProperties(internalWindow2, getOnEventNames(internalWindow2), ignoreProperties, ObjectGetPrototypeOf(internalWindow2));\n    }\n    patchTargets = patchTargets.concat([\"XMLHttpRequest\", \"XMLHttpRequestEventTarget\", \"IDBIndex\", \"IDBRequest\", \"IDBOpenDBRequest\", \"IDBDatabase\", \"IDBTransaction\", \"IDBCursor\", \"WebSocket\"]);\n    for (var i = 0; i < patchTargets.length; i++) {\n      var target = _global2[patchTargets[i]];\n      (target == null ? void 0 : target.prototype) && patchFilteredProperties(target.prototype, getOnEventNames(target.prototype), ignoreProperties);\n    }\n  }\n  // packages/zone.js/lib/browser/browser.js\n  function patchBrowser(Zone3) {\n    Zone3.__load_patch(\"timers\", function (global2) {\n      var set = \"set\";\n      var clear = \"clear\";\n      patchTimer(global2, set, clear, \"Timeout\");\n      patchTimer(global2, set, clear, \"Interval\");\n      patchTimer(global2, set, clear, \"Immediate\");\n    });\n    Zone3.__load_patch(\"requestAnimationFrame\", function (global2) {\n      patchTimer(global2, \"request\", \"cancel\", \"AnimationFrame\");\n      patchTimer(global2, \"mozRequest\", \"mozCancel\", \"AnimationFrame\");\n      patchTimer(global2, \"webkitRequest\", \"webkitCancel\", \"AnimationFrame\");\n    });\n    Zone3.__load_patch(\"blocking\", function (global2, Zone4) {\n      var blockingMethods = [\"alert\", \"prompt\", \"confirm\"];\n      for (var i = 0; i < blockingMethods.length; i++) {\n        var name_2 = blockingMethods[i];\n        patchMethod(global2, name_2, function (delegate, symbol, name2) {\n          return function (s, args) {\n            return Zone4.current.run(delegate, global2, args, name2);\n          };\n        });\n      }\n    });\n    Zone3.__load_patch(\"EventTarget\", function (global2, Zone4, api) {\n      patchEvent(global2, api);\n      eventTargetPatch(global2, api);\n      var XMLHttpRequestEventTarget = global2[\"XMLHttpRequestEventTarget\"];\n      if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {\n        api.patchEventTarget(global2, api, [XMLHttpRequestEventTarget.prototype]);\n      }\n    });\n    Zone3.__load_patch(\"MutationObserver\", function (global2, Zone4, api) {\n      patchClass(\"MutationObserver\");\n      patchClass(\"WebKitMutationObserver\");\n    });\n    Zone3.__load_patch(\"IntersectionObserver\", function (global2, Zone4, api) {\n      patchClass(\"IntersectionObserver\");\n    });\n    Zone3.__load_patch(\"FileReader\", function (global2, Zone4, api) {\n      patchClass(\"FileReader\");\n    });\n    Zone3.__load_patch(\"on_property\", function (global2, Zone4, api) {\n      propertyDescriptorPatch(api, global2);\n    });\n    Zone3.__load_patch(\"customElements\", function (global2, Zone4, api) {\n      patchCustomElements(global2, api);\n    });\n    Zone3.__load_patch(\"XHR\", function (global2, Zone4) {\n      patchXHR(global2);\n      var XHR_TASK = zoneSymbol(\"xhrTask\");\n      var XHR_SYNC = zoneSymbol(\"xhrSync\");\n      var XHR_LISTENER = zoneSymbol(\"xhrListener\");\n      var XHR_SCHEDULED = zoneSymbol(\"xhrScheduled\");\n      var XHR_URL = zoneSymbol(\"xhrURL\");\n      var XHR_ERROR_BEFORE_SCHEDULED = zoneSymbol(\"xhrErrorBeforeScheduled\");\n      function patchXHR(window2) {\n        var XMLHttpRequest = window2[\"XMLHttpRequest\"];\n        if (!XMLHttpRequest) {\n          return;\n        }\n        var XMLHttpRequestPrototype = XMLHttpRequest.prototype;\n        function findPendingTask(target) {\n          return target[XHR_TASK];\n        }\n        var oriAddListener = XMLHttpRequestPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];\n        var oriRemoveListener = XMLHttpRequestPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\n        if (!oriAddListener) {\n          var XMLHttpRequestEventTarget_1 = window2[\"XMLHttpRequestEventTarget\"];\n          if (XMLHttpRequestEventTarget_1) {\n            var XMLHttpRequestEventTargetPrototype = XMLHttpRequestEventTarget_1.prototype;\n            oriAddListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];\n            oriRemoveListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\n          }\n        }\n        var READY_STATE_CHANGE = \"readystatechange\";\n        var SCHEDULED = \"scheduled\";\n        function scheduleTask(task) {\n          var data = task.data;\n          var target = data.target;\n          target[XHR_SCHEDULED] = false;\n          target[XHR_ERROR_BEFORE_SCHEDULED] = false;\n          var listener = target[XHR_LISTENER];\n          if (!oriAddListener) {\n            oriAddListener = target[ZONE_SYMBOL_ADD_EVENT_LISTENER];\n            oriRemoveListener = target[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\n          }\n          if (listener) {\n            oriRemoveListener.call(target, READY_STATE_CHANGE, listener);\n          }\n          var newListener = target[XHR_LISTENER] = function () {\n            if (target.readyState === target.DONE) {\n              if (!data.aborted && target[XHR_SCHEDULED] && task.state === SCHEDULED) {\n                var loadTasks = target[Zone4.__symbol__(\"loadfalse\")];\n                if (target.status !== 0 && loadTasks && loadTasks.length > 0) {\n                  var oriInvoke_1 = task.invoke;\n                  task.invoke = function () {\n                    var loadTasks2 = target[Zone4.__symbol__(\"loadfalse\")];\n                    for (var i = 0; i < loadTasks2.length; i++) {\n                      if (loadTasks2[i] === task) {\n                        loadTasks2.splice(i, 1);\n                      }\n                    }\n                    if (!data.aborted && task.state === SCHEDULED) {\n                      oriInvoke_1.call(task);\n                    }\n                  };\n                  loadTasks.push(task);\n                } else {\n                  task.invoke();\n                }\n              } else if (!data.aborted && target[XHR_SCHEDULED] === false) {\n                target[XHR_ERROR_BEFORE_SCHEDULED] = true;\n              }\n            }\n          };\n          oriAddListener.call(target, READY_STATE_CHANGE, newListener);\n          var storedTask = target[XHR_TASK];\n          if (!storedTask) {\n            target[XHR_TASK] = task;\n          }\n          sendNative.apply(target, data.args);\n          target[XHR_SCHEDULED] = true;\n          return task;\n        }\n        function placeholderCallback() {}\n        function clearTask(task) {\n          var data = task.data;\n          data.aborted = true;\n          return abortNative.apply(data.target, data.args);\n        }\n        var openNative = patchMethod(XMLHttpRequestPrototype, \"open\", function () {\n          return function (self2, args) {\n            self2[XHR_SYNC] = args[2] == false;\n            self2[XHR_URL] = args[1];\n            return openNative.apply(self2, args);\n          };\n        });\n        var XMLHTTPREQUEST_SOURCE = \"XMLHttpRequest.send\";\n        var fetchTaskAborting = zoneSymbol(\"fetchTaskAborting\");\n        var fetchTaskScheduling = zoneSymbol(\"fetchTaskScheduling\");\n        var sendNative = patchMethod(XMLHttpRequestPrototype, \"send\", function () {\n          return function (self2, args) {\n            if (Zone4.current[fetchTaskScheduling] === true) {\n              return sendNative.apply(self2, args);\n            }\n            if (self2[XHR_SYNC]) {\n              return sendNative.apply(self2, args);\n            } else {\n              var options = {\n                target: self2,\n                url: self2[XHR_URL],\n                isPeriodic: false,\n                args: args,\n                aborted: false\n              };\n              var task = scheduleMacroTaskWithCurrentZone(XMLHTTPREQUEST_SOURCE, placeholderCallback, options, scheduleTask, clearTask);\n              if (self2 && self2[XHR_ERROR_BEFORE_SCHEDULED] === true && !options.aborted && task.state === SCHEDULED) {\n                task.invoke();\n              }\n            }\n          };\n        });\n        var abortNative = patchMethod(XMLHttpRequestPrototype, \"abort\", function () {\n          return function (self2, args) {\n            var task = findPendingTask(self2);\n            if (task && typeof task.type == \"string\") {\n              if (task.cancelFn == null || task.data && task.data.aborted) {\n                return;\n              }\n              task.zone.cancelTask(task);\n            } else if (Zone4.current[fetchTaskAborting] === true) {\n              return abortNative.apply(self2, args);\n            }\n          };\n        });\n      }\n    });\n    Zone3.__load_patch(\"geolocation\", function (global2) {\n      if (global2[\"navigator\"] && global2[\"navigator\"].geolocation) {\n        patchPrototype(global2[\"navigator\"].geolocation, [\"getCurrentPosition\", \"watchPosition\"]);\n      }\n    });\n    Zone3.__load_patch(\"PromiseRejectionEvent\", function (global2, Zone4) {\n      function findPromiseRejectionHandler(evtName) {\n        return function (e) {\n          var eventTasks = findEventTasks(global2, evtName);\n          eventTasks.forEach(function (eventTask) {\n            var PromiseRejectionEvent = global2[\"PromiseRejectionEvent\"];\n            if (PromiseRejectionEvent) {\n              var evt = new PromiseRejectionEvent(evtName, {\n                promise: e.promise,\n                reason: e.rejection\n              });\n              eventTask.invoke(evt);\n            }\n          });\n        };\n      }\n      if (global2[\"PromiseRejectionEvent\"]) {\n        Zone4[zoneSymbol(\"unhandledPromiseRejectionHandler\")] = findPromiseRejectionHandler(\"unhandledrejection\");\n        Zone4[zoneSymbol(\"rejectionHandledHandler\")] = findPromiseRejectionHandler(\"rejectionhandled\");\n      }\n    });\n    Zone3.__load_patch(\"queueMicrotask\", function (global2, Zone4, api) {\n      patchQueueMicrotask(global2, api);\n    });\n  }\n  // packages/zone.js/lib/common/promise.js\n  function patchPromise(Zone3) {\n    Zone3.__load_patch(\"ZoneAwarePromise\", function (global2, Zone4, api) {\n      var ObjectGetOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;\n      var ObjectDefineProperty2 = Object.defineProperty;\n      function readableObjectToString(obj) {\n        if (obj && obj.toString === Object.prototype.toString) {\n          var className = obj.constructor && obj.constructor.name;\n          return (className ? className : \"\") + \": \" + JSON.stringify(obj);\n        }\n        return obj ? obj.toString() : Object.prototype.toString.call(obj);\n      }\n      var __symbol__2 = api.symbol;\n      var _uncaughtPromiseErrors = [];\n      var isDisableWrappingUncaughtPromiseRejection = global2[__symbol__2(\"DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION\")] !== false;\n      var symbolPromise = __symbol__2(\"Promise\");\n      var symbolThen = __symbol__2(\"then\");\n      var creationTrace = \"__creationTrace__\";\n      api.onUnhandledError = function (e) {\n        if (api.showUncaughtError()) {\n          var rejection = e && e.rejection;\n          if (rejection) {\n            console.error(\"Unhandled Promise rejection:\", rejection instanceof Error ? rejection.message : rejection, \"; Zone:\", e.zone.name, \"; Task:\", e.task && e.task.source, \"; Value:\", rejection, rejection instanceof Error ? rejection.stack : void 0);\n          } else {\n            console.error(e);\n          }\n        }\n      };\n      api.microtaskDrainDone = function () {\n        var _loop_3 = function () {\n          var uncaughtPromiseError = _uncaughtPromiseErrors.shift();\n          try {\n            uncaughtPromiseError.zone.runGuarded(function () {\n              if (uncaughtPromiseError.throwOriginal) {\n                throw uncaughtPromiseError.rejection;\n              }\n              throw uncaughtPromiseError;\n            });\n          } catch (error) {\n            handleUnhandledRejection(error);\n          }\n        };\n        while (_uncaughtPromiseErrors.length) {\n          _loop_3();\n        }\n      };\n      var UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL = __symbol__2(\"unhandledPromiseRejectionHandler\");\n      function handleUnhandledRejection(e) {\n        api.onUnhandledError(e);\n        try {\n          var handler = Zone4[UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL];\n          if (typeof handler === \"function\") {\n            handler.call(this, e);\n          }\n        } catch (err) {}\n      }\n      function isThenable(value) {\n        return value && typeof value.then === \"function\";\n      }\n      function forwardResolution(value) {\n        return value;\n      }\n      function forwardRejection(rejection) {\n        return ZoneAwarePromise.reject(rejection);\n      }\n      var symbolState = __symbol__2(\"state\");\n      var symbolValue = __symbol__2(\"value\");\n      var symbolFinally = __symbol__2(\"finally\");\n      var symbolParentPromiseValue = __symbol__2(\"parentPromiseValue\");\n      var symbolParentPromiseState = __symbol__2(\"parentPromiseState\");\n      var source = \"Promise.then\";\n      var UNRESOLVED = null;\n      var RESOLVED = true;\n      var REJECTED = false;\n      var REJECTED_NO_CATCH = 0;\n      function makeResolver(promise, state) {\n        return function (v) {\n          try {\n            resolvePromise(promise, state, v);\n          } catch (err) {\n            resolvePromise(promise, false, err);\n          }\n        };\n      }\n      var once = function () {\n        var wasCalled = false;\n        return function wrapper(wrappedFunction) {\n          return function () {\n            if (wasCalled) {\n              return;\n            }\n            wasCalled = true;\n            wrappedFunction.apply(null, arguments);\n          };\n        };\n      };\n      var TYPE_ERROR = \"Promise resolved with itself\";\n      var CURRENT_TASK_TRACE_SYMBOL = __symbol__2(\"currentTaskTrace\");\n      function resolvePromise(promise, state, value) {\n        var onceWrapper = once();\n        if (promise === value) {\n          throw new TypeError(TYPE_ERROR);\n        }\n        if (promise[symbolState] === UNRESOLVED) {\n          var then = null;\n          try {\n            if (typeof value === \"object\" || typeof value === \"function\") {\n              then = value && value.then;\n            }\n          } catch (err) {\n            onceWrapper(function () {\n              resolvePromise(promise, false, err);\n            })();\n            return promise;\n          }\n          if (state !== REJECTED && value instanceof ZoneAwarePromise && value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) && value[symbolState] !== UNRESOLVED) {\n            clearRejectedNoCatch(value);\n            resolvePromise(promise, value[symbolState], value[symbolValue]);\n          } else if (state !== REJECTED && typeof then === \"function\") {\n            try {\n              then.call(value, onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false)));\n            } catch (err) {\n              onceWrapper(function () {\n                resolvePromise(promise, false, err);\n              })();\n            }\n          } else {\n            promise[symbolState] = state;\n            var queue = promise[symbolValue];\n            promise[symbolValue] = value;\n            if (promise[symbolFinally] === symbolFinally) {\n              if (state === RESOLVED) {\n                promise[symbolState] = promise[symbolParentPromiseState];\n                promise[symbolValue] = promise[symbolParentPromiseValue];\n              }\n            }\n            if (state === REJECTED && value instanceof Error) {\n              var trace = Zone4.currentTask && Zone4.currentTask.data && Zone4.currentTask.data[creationTrace];\n              if (trace) {\n                ObjectDefineProperty2(value, CURRENT_TASK_TRACE_SYMBOL, {\n                  configurable: true,\n                  enumerable: false,\n                  writable: true,\n                  value: trace\n                });\n              }\n            }\n            for (var i = 0; i < queue.length;) {\n              scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);\n            }\n            if (queue.length == 0 && state == REJECTED) {\n              promise[symbolState] = REJECTED_NO_CATCH;\n              var uncaughtPromiseError = value;\n              try {\n                throw new Error(\"Uncaught (in promise): \" + readableObjectToString(value) + (value && value.stack ? \"\\n\" + value.stack : \"\"));\n              } catch (err) {\n                uncaughtPromiseError = err;\n              }\n              if (isDisableWrappingUncaughtPromiseRejection) {\n                uncaughtPromiseError.throwOriginal = true;\n              }\n              uncaughtPromiseError.rejection = value;\n              uncaughtPromiseError.promise = promise;\n              uncaughtPromiseError.zone = Zone4.current;\n              uncaughtPromiseError.task = Zone4.currentTask;\n              _uncaughtPromiseErrors.push(uncaughtPromiseError);\n              api.scheduleMicroTask();\n            }\n          }\n        }\n        return promise;\n      }\n      var REJECTION_HANDLED_HANDLER = __symbol__2(\"rejectionHandledHandler\");\n      function clearRejectedNoCatch(promise) {\n        if (promise[symbolState] === REJECTED_NO_CATCH) {\n          try {\n            var handler = Zone4[REJECTION_HANDLED_HANDLER];\n            if (handler && typeof handler === \"function\") {\n              handler.call(this, {\n                rejection: promise[symbolValue],\n                promise: promise\n              });\n            }\n          } catch (err) {}\n          promise[symbolState] = REJECTED;\n          for (var i = 0; i < _uncaughtPromiseErrors.length; i++) {\n            if (promise === _uncaughtPromiseErrors[i].promise) {\n              _uncaughtPromiseErrors.splice(i, 1);\n            }\n          }\n        }\n      }\n      function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {\n        clearRejectedNoCatch(promise);\n        var promiseState = promise[symbolState];\n        var delegate = promiseState ? typeof onFulfilled === \"function\" ? onFulfilled : forwardResolution : typeof onRejected === \"function\" ? onRejected : forwardRejection;\n        zone.scheduleMicroTask(source, function () {\n          try {\n            var parentPromiseValue = promise[symbolValue];\n            var isFinallyPromise = !!chainPromise && symbolFinally === chainPromise[symbolFinally];\n            if (isFinallyPromise) {\n              chainPromise[symbolParentPromiseValue] = parentPromiseValue;\n              chainPromise[symbolParentPromiseState] = promiseState;\n            }\n            var value = zone.run(delegate, void 0, isFinallyPromise && delegate !== forwardRejection && delegate !== forwardResolution ? [] : [parentPromiseValue]);\n            resolvePromise(chainPromise, true, value);\n          } catch (error) {\n            resolvePromise(chainPromise, false, error);\n          }\n        }, chainPromise);\n      }\n      var ZONE_AWARE_PROMISE_TO_STRING = \"function ZoneAwarePromise() { [native code] }\";\n      var noop = function () {};\n      var AggregateError = global2.AggregateError;\n      var ZoneAwarePromise = /** @class */function () {\n        function ZoneAwarePromise(executor) {\n          var promise = this;\n          if (!(promise instanceof ZoneAwarePromise)) {\n            throw new Error(\"Must be an instanceof Promise.\");\n          }\n          promise[symbolState] = UNRESOLVED;\n          promise[symbolValue] = [];\n          try {\n            var onceWrapper = once();\n            executor && executor(onceWrapper(makeResolver(promise, RESOLVED)), onceWrapper(makeResolver(promise, REJECTED)));\n          } catch (error) {\n            resolvePromise(promise, false, error);\n          }\n        }\n        ZoneAwarePromise.toString = function () {\n          return ZONE_AWARE_PROMISE_TO_STRING;\n        };\n        ZoneAwarePromise.resolve = function (value) {\n          if (value instanceof ZoneAwarePromise) {\n            return value;\n          }\n          return resolvePromise(new this(null), RESOLVED, value);\n        };\n        ZoneAwarePromise.reject = function (error) {\n          return resolvePromise(new this(null), REJECTED, error);\n        };\n        ZoneAwarePromise.withResolvers = function () {\n          var result = {};\n          result.promise = new ZoneAwarePromise(function (res, rej) {\n            result.resolve = res;\n            result.reject = rej;\n          });\n          return result;\n        };\n        ZoneAwarePromise.any = function (values) {\n          if (!values || typeof values[Symbol.iterator] !== \"function\") {\n            return Promise.reject(new AggregateError([], \"All promises were rejected\"));\n          }\n          var promises = [];\n          var count = 0;\n          try {\n            for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n              var v = values_1[_i];\n              count++;\n              promises.push(ZoneAwarePromise.resolve(v));\n            }\n          } catch (err) {\n            return Promise.reject(new AggregateError([], \"All promises were rejected\"));\n          }\n          if (count === 0) {\n            return Promise.reject(new AggregateError([], \"All promises were rejected\"));\n          }\n          var finished = false;\n          var errors = [];\n          return new ZoneAwarePromise(function (resolve, reject) {\n            for (var i = 0; i < promises.length; i++) {\n              promises[i].then(function (v) {\n                if (finished) {\n                  return;\n                }\n                finished = true;\n                resolve(v);\n              }, function (err) {\n                errors.push(err);\n                count--;\n                if (count === 0) {\n                  finished = true;\n                  reject(new AggregateError(errors, \"All promises were rejected\"));\n                }\n              });\n            }\n          });\n        };\n        ZoneAwarePromise.race = function (values) {\n          var resolve;\n          var reject;\n          var promise = new this(function (res, rej) {\n            resolve = res;\n            reject = rej;\n          });\n          function onResolve(value) {\n            resolve(value);\n          }\n          function onReject(error) {\n            reject(error);\n          }\n          for (var _i = 0, values_2 = values; _i < values_2.length; _i++) {\n            var value = values_2[_i];\n            if (!isThenable(value)) {\n              value = this.resolve(value);\n            }\n            value.then(onResolve, onReject);\n          }\n          return promise;\n        };\n        ZoneAwarePromise.all = function (values) {\n          return ZoneAwarePromise.allWithCallback(values);\n        };\n        ZoneAwarePromise.allSettled = function (values) {\n          var P = this && this.prototype instanceof ZoneAwarePromise ? this : ZoneAwarePromise;\n          return P.allWithCallback(values, {\n            thenCallback: function (value) {\n              return {\n                status: \"fulfilled\",\n                value: value\n              };\n            },\n            errorCallback: function (err) {\n              return {\n                status: \"rejected\",\n                reason: err\n              };\n            }\n          });\n        };\n        ZoneAwarePromise.allWithCallback = function (values, callback) {\n          var resolve;\n          var reject;\n          var promise = new this(function (res, rej) {\n            resolve = res;\n            reject = rej;\n          });\n          var unresolvedCount = 2;\n          var valueIndex = 0;\n          var resolvedValues = [];\n          var _loop_4 = function (value) {\n            if (!isThenable(value)) {\n              value = this_1.resolve(value);\n            }\n            var curValueIndex = valueIndex;\n            try {\n              value.then(function (value2) {\n                resolvedValues[curValueIndex] = callback ? callback.thenCallback(value2) : value2;\n                unresolvedCount--;\n                if (unresolvedCount === 0) {\n                  resolve(resolvedValues);\n                }\n              }, function (err) {\n                if (!callback) {\n                  reject(err);\n                } else {\n                  resolvedValues[curValueIndex] = callback.errorCallback(err);\n                  unresolvedCount--;\n                  if (unresolvedCount === 0) {\n                    resolve(resolvedValues);\n                  }\n                }\n              });\n            } catch (thenErr) {\n              reject(thenErr);\n            }\n            unresolvedCount++;\n            valueIndex++;\n          };\n          var this_1 = this;\n          for (var _i = 0, values_3 = values; _i < values_3.length; _i++) {\n            var value = values_3[_i];\n            _loop_4(value);\n          }\n          unresolvedCount -= 2;\n          if (unresolvedCount === 0) {\n            resolve(resolvedValues);\n          }\n          return promise;\n        };\n        Object.defineProperty(ZoneAwarePromise.prototype, Symbol.toStringTag, {\n          get: function () {\n            return \"Promise\";\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(ZoneAwarePromise.prototype, Symbol.species, {\n          get: function () {\n            return ZoneAwarePromise;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        ZoneAwarePromise.prototype.then = function (onFulfilled, onRejected) {\n          var _a;\n          var C = (_a = this.constructor) == null ? void 0 : _a[Symbol.species];\n          if (!C || typeof C !== \"function\") {\n            C = this.constructor || ZoneAwarePromise;\n          }\n          var chainPromise = new C(noop);\n          var zone = Zone4.current;\n          if (this[symbolState] == UNRESOLVED) {\n            this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);\n          } else {\n            scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);\n          }\n          return chainPromise;\n        };\n        ZoneAwarePromise.prototype.catch = function (onRejected) {\n          return this.then(null, onRejected);\n        };\n        ZoneAwarePromise.prototype.finally = function (onFinally) {\n          var _a;\n          var C = (_a = this.constructor) == null ? void 0 : _a[Symbol.species];\n          if (!C || typeof C !== \"function\") {\n            C = ZoneAwarePromise;\n          }\n          var chainPromise = new C(noop);\n          chainPromise[symbolFinally] = symbolFinally;\n          var zone = Zone4.current;\n          if (this[symbolState] == UNRESOLVED) {\n            this[symbolValue].push(zone, chainPromise, onFinally, onFinally);\n          } else {\n            scheduleResolveOrReject(this, zone, chainPromise, onFinally, onFinally);\n          }\n          return chainPromise;\n        };\n        return ZoneAwarePromise;\n      }();\n      ZoneAwarePromise[\"resolve\"] = ZoneAwarePromise.resolve;\n      ZoneAwarePromise[\"reject\"] = ZoneAwarePromise.reject;\n      ZoneAwarePromise[\"race\"] = ZoneAwarePromise.race;\n      ZoneAwarePromise[\"all\"] = ZoneAwarePromise.all;\n      var NativePromise = global2[symbolPromise] = global2[\"Promise\"];\n      global2[\"Promise\"] = ZoneAwarePromise;\n      var symbolThenPatched = __symbol__2(\"thenPatched\");\n      function patchThen(Ctor) {\n        var proto = Ctor.prototype;\n        var prop = ObjectGetOwnPropertyDescriptor2(proto, \"then\");\n        if (prop && (prop.writable === false || !prop.configurable)) {\n          return;\n        }\n        var originalThen = proto.then;\n        proto[symbolThen] = originalThen;\n        Ctor.prototype.then = function (onResolve, onReject) {\n          var _this = this;\n          var wrapped = new ZoneAwarePromise(function (resolve, reject) {\n            originalThen.call(_this, resolve, reject);\n          });\n          return wrapped.then(onResolve, onReject);\n        };\n        Ctor[symbolThenPatched] = true;\n      }\n      api.patchThen = patchThen;\n      function zoneify(fn) {\n        return function (self2, args) {\n          var resultPromise = fn.apply(self2, args);\n          if (resultPromise instanceof ZoneAwarePromise) {\n            return resultPromise;\n          }\n          var ctor = resultPromise.constructor;\n          if (!ctor[symbolThenPatched]) {\n            patchThen(ctor);\n          }\n          return resultPromise;\n        };\n      }\n      if (NativePromise) {\n        patchThen(NativePromise);\n        patchMethod(global2, \"fetch\", function (delegate) {\n          return zoneify(delegate);\n        });\n      }\n      Promise[Zone4.__symbol__(\"uncaughtPromiseErrors\")] = _uncaughtPromiseErrors;\n      return ZoneAwarePromise;\n    });\n  }\n  // packages/zone.js/lib/common/to-string.js\n  function patchToString(Zone3) {\n    Zone3.__load_patch(\"toString\", function (global2) {\n      var originalFunctionToString = Function.prototype.toString;\n      var ORIGINAL_DELEGATE_SYMBOL = zoneSymbol(\"OriginalDelegate\");\n      var PROMISE_SYMBOL = zoneSymbol(\"Promise\");\n      var ERROR_SYMBOL = zoneSymbol(\"Error\");\n      var newFunctionToString = function toString() {\n        if (typeof this === \"function\") {\n          var originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL];\n          if (originalDelegate) {\n            if (typeof originalDelegate === \"function\") {\n              return originalFunctionToString.call(originalDelegate);\n            } else {\n              return Object.prototype.toString.call(originalDelegate);\n            }\n          }\n          if (this === Promise) {\n            var nativePromise = global2[PROMISE_SYMBOL];\n            if (nativePromise) {\n              return originalFunctionToString.call(nativePromise);\n            }\n          }\n          if (this === Error) {\n            var nativeError = global2[ERROR_SYMBOL];\n            if (nativeError) {\n              return originalFunctionToString.call(nativeError);\n            }\n          }\n        }\n        return originalFunctionToString.call(this);\n      };\n      newFunctionToString[ORIGINAL_DELEGATE_SYMBOL] = originalFunctionToString;\n      Function.prototype.toString = newFunctionToString;\n      var originalObjectToString = Object.prototype.toString;\n      var PROMISE_OBJECT_TO_STRING = \"[object Promise]\";\n      Object.prototype.toString = function () {\n        if (typeof Promise === \"function\" && this instanceof Promise) {\n          return PROMISE_OBJECT_TO_STRING;\n        }\n        return originalObjectToString.call(this);\n      };\n    });\n  }\n  // packages/zone.js/lib/browser/browser-util.js\n  function patchCallbacks(api, target, targetName, method, callbacks) {\n    var symbol = Zone.__symbol__(method);\n    if (target[symbol]) {\n      return;\n    }\n    var nativeDelegate = target[symbol] = target[method];\n    target[method] = function (name, opts, options) {\n      if (opts && opts.prototype) {\n        callbacks.forEach(function (callback) {\n          var source = \"\".concat(targetName, \".\").concat(method, \"::\") + callback;\n          var prototype = opts.prototype;\n          try {\n            if (prototype.hasOwnProperty(callback)) {\n              var descriptor = api.ObjectGetOwnPropertyDescriptor(prototype, callback);\n              if (descriptor && descriptor.value) {\n                descriptor.value = api.wrapWithCurrentZone(descriptor.value, source);\n                api._redefineProperty(opts.prototype, callback, descriptor);\n              } else if (prototype[callback]) {\n                prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);\n              }\n            } else if (prototype[callback]) {\n              prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);\n            }\n          } catch (e) {}\n        });\n      }\n      return nativeDelegate.call(target, name, opts, options);\n    };\n    api.attachOriginToPatched(target[method], nativeDelegate);\n  }\n  // packages/zone.js/lib/browser/api-util.js\n  function patchUtil(Zone3) {\n    Zone3.__load_patch(\"util\", function (global2, Zone4, api) {\n      var eventNames = getOnEventNames(global2);\n      api.patchOnProperties = patchOnProperties;\n      api.patchMethod = patchMethod;\n      api.bindArguments = bindArguments;\n      api.patchMacroTask = patchMacroTask;\n      var SYMBOL_BLACK_LISTED_EVENTS = Zone4.__symbol__(\"BLACK_LISTED_EVENTS\");\n      var SYMBOL_UNPATCHED_EVENTS = Zone4.__symbol__(\"UNPATCHED_EVENTS\");\n      if (global2[SYMBOL_UNPATCHED_EVENTS]) {\n        global2[SYMBOL_BLACK_LISTED_EVENTS] = global2[SYMBOL_UNPATCHED_EVENTS];\n      }\n      if (global2[SYMBOL_BLACK_LISTED_EVENTS]) {\n        Zone4[SYMBOL_BLACK_LISTED_EVENTS] = Zone4[SYMBOL_UNPATCHED_EVENTS] = global2[SYMBOL_BLACK_LISTED_EVENTS];\n      }\n      api.patchEventPrototype = patchEventPrototype;\n      api.patchEventTarget = patchEventTarget;\n      api.ObjectDefineProperty = ObjectDefineProperty;\n      api.ObjectGetOwnPropertyDescriptor = ObjectGetOwnPropertyDescriptor;\n      api.ObjectCreate = ObjectCreate;\n      api.ArraySlice = ArraySlice;\n      api.patchClass = patchClass;\n      api.wrapWithCurrentZone = wrapWithCurrentZone;\n      api.filterProperties = filterProperties;\n      api.attachOriginToPatched = attachOriginToPatched;\n      api._redefineProperty = Object.defineProperty;\n      api.patchCallbacks = patchCallbacks;\n      api.getGlobalObjects = function () {\n        return {\n          globalSources: globalSources,\n          zoneSymbolEventNames: zoneSymbolEventNames2,\n          eventNames: eventNames,\n          isBrowser: isBrowser,\n          isMix: isMix,\n          isNode: isNode,\n          TRUE_STR: TRUE_STR,\n          FALSE_STR: FALSE_STR,\n          ZONE_SYMBOL_PREFIX: ZONE_SYMBOL_PREFIX,\n          ADD_EVENT_LISTENER_STR: ADD_EVENT_LISTENER_STR,\n          REMOVE_EVENT_LISTENER_STR: REMOVE_EVENT_LISTENER_STR\n        };\n      };\n    });\n  }\n  // packages/zone.js/lib/browser/rollup-common.js\n  function patchCommon(Zone3) {\n    patchPromise(Zone3);\n    patchToString(Zone3);\n    patchUtil(Zone3);\n  }\n  // packages/zone.js/lib/browser/rollup-main.js\n  var Zone2 = loadZone();\n  patchCommon(Zone2);\n  patchBrowser(Zone2);\n  if (__exports != exports) module.exports = exports;\n  return module.exports;\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}