{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/juanj/Desktop/juan_website/website2/my-website/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * @license Angular v21.0.0\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport * as i0 from '@angular/core';\nimport { Injectable, DeferBlockState, triggerResourceLoading, renderDeferBlockState, getDeferBlocks, DeferBlockBehavior, ApplicationRef, getDebugNode, RendererFactory2, Directive, Component, Pipe, NgModule, ReflectionCapabilities, depsTracker, isComponentDefPendingResolution, resolveComponentResources, NgModuleRef, ApplicationInitStatus, LOCALE_ID, DEFAULT_LOCALE_ID, setLocaleId, ComponentFactory, getAsyncClassMetadataFn, compileComponent, compileDirective, compilePipe, patchComponentDefWithScope, compileNgModuleDefs, clearResolutionOfComponentResourcesQueue, restoreComponentResolutionQueue, provideZonelessChangeDetectionInternal, COMPILER_OPTIONS, generateStandaloneInDeclarationsError, transitiveScopesFor, Compiler, DEFER_BLOCK_CONFIG, ANIMATIONS_DISABLED, NgModuleFactory, ModuleWithComponentFactories, resetCompiledComponents, ɵsetUnknownElementStrictMode as _setUnknownElementStrictMode, ɵsetUnknownPropertyStrictMode as _setUnknownPropertyStrictMode, ɵgetUnknownElementStrictMode as _getUnknownElementStrictMode, ɵgetUnknownPropertyStrictMode as _getUnknownPropertyStrictMode, inferTagNameFromDefinition, flushModuleScopingQueueAsMuchAsPossible, setAllowDuplicateNgModuleIdsForTest } from './_debug_node-chunk.mjs';\nimport { Subscription } from 'rxjs';\nimport { inject as inject$1, NgZone, EnvironmentInjector, ErrorHandler, CONTAINER_HEADER_OFFSET, InjectionToken, NoopNgZone, PendingTasksInternal, ZONELESS_ENABLED, ChangeDetectionScheduler, EffectScheduler, stringify, getInjectableDef, resolveForwardRef, NG_COMP_DEF, NG_DIR_DEF, NG_PIPE_DEF, NG_INJ_DEF, NG_MOD_DEF, ENVIRONMENT_INITIALIZER, Injector, isEnvironmentProviders, INTERNAL_APPLICATION_ERROR_HANDLER, runInInjectionContext, getComponentDef as getComponentDef$1 } from './_untracked-chunk.mjs';\nimport { ResourceLoader } from '@angular/compiler';\nimport './_effect-chunk.mjs';\nimport '@angular/core/primitives/signals';\nimport 'rxjs/operators';\nimport './_attribute-chunk.mjs';\nimport './_not_found-chunk.mjs';\nimport '@angular/core/primitives/di';\nfunction waitForAsync(fn) {\n  const _Zone = typeof Zone !== 'undefined' ? Zone : null;\n  if (!_Zone) {\n    return function () {\n      return Promise.reject('Zone is needed for the waitForAsync() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js');\n    };\n  }\n  const asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n  if (typeof asyncTest === 'function') {\n    return asyncTest(fn);\n  }\n  return function () {\n    return Promise.reject('zone-testing.js is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/testing');\n  };\n}\nconst RETHROW_APPLICATION_ERRORS_DEFAULT = true;\nclass TestBedApplicationErrorHandler {\n  zone = inject$1(NgZone);\n  injector = inject$1(EnvironmentInjector);\n  userErrorHandler;\n  whenStableRejectFunctions = new Set();\n  handleError(e) {\n    try {\n      this.zone.runOutsideAngular(() => {\n        this.userErrorHandler ??= this.injector.get(ErrorHandler);\n        this.userErrorHandler.handleError(e);\n      });\n    } catch (userError) {\n      e = userError;\n    }\n    if (this.whenStableRejectFunctions.size > 0) {\n      for (const fn of this.whenStableRejectFunctions.values()) {\n        fn(e);\n      }\n      this.whenStableRejectFunctions.clear();\n    } else {\n      throw e;\n    }\n  }\n  static ɵfac = function TestBedApplicationErrorHandler_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TestBedApplicationErrorHandler)();\n  };\n  static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: TestBedApplicationErrorHandler,\n    factory: TestBedApplicationErrorHandler.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TestBedApplicationErrorHandler, [{\n    type: Injectable\n  }], null, null);\n})();\nclass DeferBlockFixture {\n  block;\n  componentFixture;\n  constructor(block, componentFixture) {\n    this.block = block;\n    this.componentFixture = componentFixture;\n  }\n  render(state) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (!hasStateTemplate(state, _this.block)) {\n        const stateAsString = getDeferBlockStateNameFromEnum(state);\n        throw new Error(`Tried to render this defer block in the \\`${stateAsString}\\` state, ` + `but there was no @${stateAsString.toLowerCase()} block defined in a template.`);\n      }\n      if (state === DeferBlockState.Complete) {\n        yield triggerResourceLoading(_this.block.tDetails, _this.block.lView, _this.block.tNode);\n      }\n      const skipTimerScheduling = true;\n      renderDeferBlockState(state, _this.block.tNode, _this.block.lContainer, skipTimerScheduling);\n      _this.componentFixture.detectChanges();\n    })();\n  }\n  getDeferBlocks() {\n    const deferBlocks = [];\n    const deferBlockFixtures = [];\n    if (this.block.lContainer.length >= CONTAINER_HEADER_OFFSET) {\n      const lView = this.block.lContainer[CONTAINER_HEADER_OFFSET];\n      getDeferBlocks(lView, deferBlocks);\n      for (const block of deferBlocks) {\n        deferBlockFixtures.push(new DeferBlockFixture(block, this.componentFixture));\n      }\n    }\n    return Promise.resolve(deferBlockFixtures);\n  }\n}\nfunction hasStateTemplate(state, block) {\n  switch (state) {\n    case DeferBlockState.Placeholder:\n      return block.tDetails.placeholderTmplIndex !== null;\n    case DeferBlockState.Loading:\n      return block.tDetails.loadingTmplIndex !== null;\n    case DeferBlockState.Error:\n      return block.tDetails.errorTmplIndex !== null;\n    case DeferBlockState.Complete:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction getDeferBlockStateNameFromEnum(state) {\n  switch (state) {\n    case DeferBlockState.Placeholder:\n      return 'Placeholder';\n    case DeferBlockState.Loading:\n      return 'Loading';\n    case DeferBlockState.Error:\n      return 'Error';\n    default:\n      return 'Main';\n  }\n}\nconst TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT = true;\nconst THROW_ON_UNKNOWN_ELEMENTS_DEFAULT = false;\nconst THROW_ON_UNKNOWN_PROPERTIES_DEFAULT = false;\nconst DEFER_BLOCK_DEFAULT_BEHAVIOR = DeferBlockBehavior.Playthrough;\nconst ANIMATIONS_ENABLED_DEFAULT = false;\nclass TestComponentRenderer {\n  insertRootElement(rootElementId, tagName) {}\n  removeAllRootElements() {}\n}\nconst ComponentFixtureAutoDetect = new InjectionToken('ComponentFixtureAutoDetect');\nconst ComponentFixtureNoNgZone = new InjectionToken('ComponentFixtureNoNgZone');\nclass ComponentFixture {\n  componentRef;\n  debugElement;\n  componentInstance;\n  nativeElement;\n  elementRef;\n  changeDetectorRef;\n  _renderer;\n  _isDestroyed = false;\n  _noZoneOptionIsSet = inject$1(ComponentFixtureNoNgZone, {\n    optional: true\n  });\n  _ngZone = this._noZoneOptionIsSet ? new NoopNgZone() : inject$1(NgZone);\n  _appRef = inject$1(ApplicationRef);\n  _testAppRef = this._appRef;\n  pendingTasks = inject$1(PendingTasksInternal);\n  appErrorHandler = inject$1(TestBedApplicationErrorHandler);\n  zonelessEnabled = inject$1(ZONELESS_ENABLED);\n  scheduler = inject$1(ChangeDetectionScheduler);\n  rootEffectScheduler = inject$1(EffectScheduler);\n  autoDetectDefault = this.zonelessEnabled ? true : false;\n  autoDetect = inject$1(ComponentFixtureAutoDetect, {\n    optional: true\n  }) ?? this.autoDetectDefault;\n  subscriptions = new Subscription();\n  ngZone = this._noZoneOptionIsSet ? null : this._ngZone;\n  constructor(componentRef) {\n    this.componentRef = componentRef;\n    this.changeDetectorRef = componentRef.changeDetectorRef;\n    this.elementRef = componentRef.location;\n    this.debugElement = getDebugNode(this.elementRef.nativeElement);\n    this.componentInstance = componentRef.instance;\n    this.nativeElement = this.elementRef.nativeElement;\n    this.componentRef = componentRef;\n    this._testAppRef.allTestViews.add(this.componentRef.hostView);\n    if (this.autoDetect) {\n      this._testAppRef.autoDetectTestViews.add(this.componentRef.hostView);\n      this.scheduler?.notify(8);\n      this.scheduler?.notify(0);\n    }\n    this.componentRef.hostView.onDestroy(() => {\n      this._testAppRef.allTestViews.delete(this.componentRef.hostView);\n      this._testAppRef.autoDetectTestViews.delete(this.componentRef.hostView);\n    });\n    this._ngZone.runOutsideAngular(() => {\n      this.subscriptions.add(this._ngZone.onError.subscribe({\n        next: error => {\n          if (typeof Zone === 'undefined' || Zone.current.get('FakeAsyncTestZoneSpec')) {\n            return;\n          }\n          throw error;\n        }\n      }));\n    });\n  }\n  detectChanges(checkNoChanges = true) {\n    const originalCheckNoChanges = this.componentRef.changeDetectorRef.checkNoChanges;\n    try {\n      if (!checkNoChanges) {\n        this.componentRef.changeDetectorRef.checkNoChanges = () => {};\n      }\n      if (this.zonelessEnabled) {\n        try {\n          this._testAppRef.includeAllTestViews = true;\n          this._appRef.tick();\n        } finally {\n          this._testAppRef.includeAllTestViews = false;\n        }\n      } else {\n        this._ngZone.run(() => {\n          this.rootEffectScheduler.flush();\n          this.changeDetectorRef.detectChanges();\n          this.checkNoChanges();\n        });\n      }\n    } finally {\n      this.componentRef.changeDetectorRef.checkNoChanges = originalCheckNoChanges;\n    }\n  }\n  checkNoChanges() {\n    this.changeDetectorRef.checkNoChanges();\n  }\n  autoDetectChanges(autoDetect = true) {\n    if (!autoDetect && this.zonelessEnabled) {\n      throw new Error('Cannot set autoDetect to false with zoneless change detection.');\n    }\n    if (this._noZoneOptionIsSet && !this.zonelessEnabled) {\n      throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set.');\n    }\n    if (autoDetect) {\n      this._testAppRef.autoDetectTestViews.add(this.componentRef.hostView);\n    } else {\n      this._testAppRef.autoDetectTestViews.delete(this.componentRef.hostView);\n    }\n    this.autoDetect = autoDetect;\n    this.detectChanges();\n  }\n  isStable() {\n    return !this.pendingTasks.hasPendingTasks;\n  }\n  whenStable() {\n    if (this.isStable()) {\n      return Promise.resolve(false);\n    }\n    return new Promise((resolve, reject) => {\n      this.appErrorHandler.whenStableRejectFunctions.add(reject);\n      this._appRef.whenStable().then(() => {\n        this.appErrorHandler.whenStableRejectFunctions.delete(reject);\n        resolve(true);\n      });\n    });\n  }\n  getDeferBlocks() {\n    const deferBlocks = [];\n    const lView = this.componentRef.hostView['_lView'];\n    getDeferBlocks(lView, deferBlocks);\n    const deferBlockFixtures = [];\n    for (const block of deferBlocks) {\n      deferBlockFixtures.push(new DeferBlockFixture(block, this));\n    }\n    return Promise.resolve(deferBlockFixtures);\n  }\n  _getRenderer() {\n    if (this._renderer === undefined) {\n      this._renderer = this.componentRef.injector.get(RendererFactory2, null);\n    }\n    return this._renderer;\n  }\n  whenRenderingDone() {\n    const renderer = this._getRenderer();\n    if (renderer && renderer.whenRenderingDone) {\n      return renderer.whenRenderingDone();\n    }\n    return this.whenStable();\n  }\n  destroy() {\n    this.subscriptions.unsubscribe();\n    this._testAppRef.autoDetectTestViews.delete(this.componentRef.hostView);\n    this._testAppRef.allTestViews.delete(this.componentRef.hostView);\n    if (!this._isDestroyed) {\n      this.componentRef.destroy();\n      this._isDestroyed = true;\n    }\n  }\n}\nconst _Zone = typeof Zone !== 'undefined' ? Zone : null;\nfunction getFakeAsyncTestModule() {\n  return _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\n}\nfunction withFakeAsyncTestModule(fn) {\n  const fakeAsyncTestModule = getFakeAsyncTestModule();\n  if (!fakeAsyncTestModule) {\n    throw new Error(`zone-testing.js is needed for the fakeAsync() test helper but could not be found.\n        Please make sure that your environment includes zone.js/testing`);\n  }\n  return fn(fakeAsyncTestModule);\n}\nfunction resetFakeAsyncZone() {\n  withFakeAsyncTestModule(v => v.resetFakeAsyncZone());\n}\nfunction resetFakeAsyncZoneIfExists() {\n  if (getFakeAsyncTestModule() && Zone['ProxyZoneSpec']?.isLoaded()) {\n    getFakeAsyncTestModule().resetFakeAsyncZone();\n  }\n}\nfunction fakeAsync(fn, options) {\n  return withFakeAsyncTestModule(v => v.fakeAsync(fn, options));\n}\nfunction tick(millis = 0, tickOptions = {\n  processNewMacroTasksSynchronously: true\n}) {\n  return withFakeAsyncTestModule(m => m.tick(millis, tickOptions));\n}\nfunction flush(maxTurns) {\n  return withFakeAsyncTestModule(m => m.flush(maxTurns));\n}\nfunction discardPeriodicTasks() {\n  return withFakeAsyncTestModule(m => m.discardPeriodicTasks());\n}\nfunction flushMicrotasks() {\n  return withFakeAsyncTestModule(m => m.flushMicrotasks());\n}\nlet _nextReferenceId = 0;\nclass MetadataOverrider {\n  _references = new Map();\n  overrideMetadata(metadataClass, oldMetadata, override) {\n    const props = {};\n    if (oldMetadata) {\n      _valueProps(oldMetadata).forEach(prop => props[prop] = oldMetadata[prop]);\n    }\n    if (override.set) {\n      if (override.remove || override.add) {\n        throw new Error(`Cannot set and add/remove ${stringify(metadataClass)} at the same time!`);\n      }\n      setMetadata(props, override.set);\n    }\n    if (override.remove) {\n      removeMetadata(props, override.remove, this._references);\n    }\n    if (override.add) {\n      addMetadata(props, override.add);\n    }\n    return new metadataClass(props);\n  }\n}\nfunction removeMetadata(metadata, remove, references) {\n  const removeObjects = new Set();\n  for (const prop in remove) {\n    const removeValue = remove[prop];\n    if (Array.isArray(removeValue)) {\n      removeValue.forEach(value => {\n        removeObjects.add(_propHashKey(prop, value, references));\n      });\n    } else {\n      removeObjects.add(_propHashKey(prop, removeValue, references));\n    }\n  }\n  for (const prop in metadata) {\n    const propValue = metadata[prop];\n    if (Array.isArray(propValue)) {\n      metadata[prop] = propValue.filter(value => !removeObjects.has(_propHashKey(prop, value, references)));\n    } else {\n      if (removeObjects.has(_propHashKey(prop, propValue, references))) {\n        metadata[prop] = undefined;\n      }\n    }\n  }\n}\nfunction addMetadata(metadata, add) {\n  for (const prop in add) {\n    const addValue = add[prop];\n    const propValue = metadata[prop];\n    if (propValue != null && Array.isArray(propValue)) {\n      metadata[prop] = propValue.concat(addValue);\n    } else {\n      metadata[prop] = addValue;\n    }\n  }\n}\nfunction setMetadata(metadata, set) {\n  for (const prop in set) {\n    metadata[prop] = set[prop];\n  }\n}\nfunction _propHashKey(propName, propValue, references) {\n  let nextObjectId = 0;\n  const objectIds = new Map();\n  const replacer = (key, value) => {\n    if (value !== null && typeof value === 'object') {\n      if (objectIds.has(value)) {\n        return objectIds.get(value);\n      }\n      objectIds.set(value, `ɵobj#${nextObjectId++}`);\n      return value;\n    } else if (typeof value === 'function') {\n      value = _serializeReference(value, references);\n    }\n    return value;\n  };\n  return `${propName}:${JSON.stringify(propValue, replacer)}`;\n}\nfunction _serializeReference(ref, references) {\n  let id = references.get(ref);\n  if (!id) {\n    id = `${stringify(ref)}${_nextReferenceId++}`;\n    references.set(ref, id);\n  }\n  return id;\n}\nfunction _valueProps(obj) {\n  const props = [];\n  Object.keys(obj).forEach(prop => {\n    if (!prop.startsWith('_')) {\n      props.push(prop);\n    }\n  });\n  let proto = obj;\n  while (proto = Object.getPrototypeOf(proto)) {\n    Object.keys(proto).forEach(protoProp => {\n      const desc = Object.getOwnPropertyDescriptor(proto, protoProp);\n      if (!protoProp.startsWith('_') && desc && 'get' in desc) {\n        props.push(protoProp);\n      }\n    });\n  }\n  return props;\n}\nconst reflection = new ReflectionCapabilities();\nclass OverrideResolver {\n  overrides = new Map();\n  resolved = new Map();\n  addOverride(type, override) {\n    const overrides = this.overrides.get(type) || [];\n    overrides.push(override);\n    this.overrides.set(type, overrides);\n    this.resolved.delete(type);\n  }\n  setOverrides(overrides) {\n    this.overrides.clear();\n    overrides.forEach(([type, override]) => {\n      this.addOverride(type, override);\n    });\n  }\n  getAnnotation(type) {\n    const annotations = reflection.annotations(type);\n    for (let i = annotations.length - 1; i >= 0; i--) {\n      const annotation = annotations[i];\n      const isKnownType = annotation instanceof Directive || annotation instanceof Component || annotation instanceof Pipe || annotation instanceof NgModule;\n      if (isKnownType) {\n        return annotation instanceof this.type ? annotation : null;\n      }\n    }\n    return null;\n  }\n  resolve(type) {\n    let resolved = this.resolved.get(type) || null;\n    if (!resolved) {\n      resolved = this.getAnnotation(type);\n      if (resolved) {\n        const overrides = this.overrides.get(type);\n        if (overrides) {\n          const overrider = new MetadataOverrider();\n          overrides.forEach(override => {\n            resolved = overrider.overrideMetadata(this.type, resolved, override);\n          });\n        }\n      }\n      this.resolved.set(type, resolved);\n    }\n    return resolved;\n  }\n}\nclass DirectiveResolver extends OverrideResolver {\n  get type() {\n    return Directive;\n  }\n}\nclass ComponentResolver extends OverrideResolver {\n  get type() {\n    return Component;\n  }\n}\nclass PipeResolver extends OverrideResolver {\n  get type() {\n    return Pipe;\n  }\n}\nclass NgModuleResolver extends OverrideResolver {\n  get type() {\n    return NgModule;\n  }\n}\nvar TestingModuleOverride;\n(function (TestingModuleOverride) {\n  TestingModuleOverride[TestingModuleOverride[\"DECLARATION\"] = 0] = \"DECLARATION\";\n  TestingModuleOverride[TestingModuleOverride[\"OVERRIDE_TEMPLATE\"] = 1] = \"OVERRIDE_TEMPLATE\";\n})(TestingModuleOverride || (TestingModuleOverride = {}));\nfunction isTestingModuleOverride(value) {\n  return value === TestingModuleOverride.DECLARATION || value === TestingModuleOverride.OVERRIDE_TEMPLATE;\n}\nfunction assertNoStandaloneComponents(types, resolver, location) {\n  types.forEach(type => {\n    if (!getAsyncClassMetadataFn(type)) {\n      const component = resolver.resolve(type);\n      if (component && (component.standalone == null || component.standalone)) {\n        throw new Error(generateStandaloneInDeclarationsError(type, location));\n      }\n    }\n  });\n}\nclass TestBedCompiler {\n  platform;\n  additionalModuleTypes;\n  originalComponentResolutionQueue = null;\n  declarations = [];\n  imports = [];\n  providers = [];\n  schemas = [];\n  pendingComponents = new Set();\n  pendingDirectives = new Set();\n  pendingPipes = new Set();\n  componentsWithAsyncMetadata = new Set();\n  seenComponents = new Set();\n  seenDirectives = new Set();\n  overriddenModules = new Set();\n  existingComponentStyles = new Map();\n  resolvers = initResolvers();\n  componentToModuleScope = new Map();\n  initialNgDefs = new Map();\n  defCleanupOps = [];\n  _injector = null;\n  compilerProviders = null;\n  providerOverrides = [];\n  rootProviderOverrides = [];\n  providerOverridesByModule = new Map();\n  providerOverridesByToken = new Map();\n  scopesWithOverriddenProviders = new Set();\n  testModuleType;\n  testModuleRef = null;\n  animationsEnabled = ANIMATIONS_ENABLED_DEFAULT;\n  deferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n  rethrowApplicationTickErrors = RETHROW_APPLICATION_ERRORS_DEFAULT;\n  constructor(platform, additionalModuleTypes) {\n    this.platform = platform;\n    this.additionalModuleTypes = additionalModuleTypes;\n    class DynamicTestModule {}\n    this.testModuleType = DynamicTestModule;\n  }\n  setCompilerProviders(providers) {\n    this.compilerProviders = providers;\n    this._injector = null;\n  }\n  configureTestingModule(moduleDef) {\n    if (moduleDef.declarations !== undefined) {\n      assertNoStandaloneComponents(moduleDef.declarations, this.resolvers.component, '\"TestBed.configureTestingModule\" call');\n      this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\n      this.declarations.push(...moduleDef.declarations);\n    }\n    if (moduleDef.imports !== undefined) {\n      this.queueTypesFromModulesArray(moduleDef.imports);\n      this.imports.push(...moduleDef.imports);\n    }\n    if (moduleDef.providers !== undefined) {\n      this.providers.push(...moduleDef.providers);\n    }\n    if (moduleDef.schemas !== undefined) {\n      this.schemas.push(...moduleDef.schemas);\n    }\n    this.deferBlockBehavior = moduleDef.deferBlockBehavior ?? DEFER_BLOCK_DEFAULT_BEHAVIOR;\n    this.animationsEnabled = moduleDef.animationsEnabled ?? ANIMATIONS_ENABLED_DEFAULT;\n    this.rethrowApplicationTickErrors = moduleDef.rethrowApplicationErrors ?? RETHROW_APPLICATION_ERRORS_DEFAULT;\n  }\n  overrideModule(ngModule, override) {\n    depsTracker.clearScopeCacheFor(ngModule);\n    this.overriddenModules.add(ngModule);\n    this.resolvers.module.addOverride(ngModule, override);\n    const metadata = this.resolvers.module.resolve(ngModule);\n    if (metadata === null) {\n      throw invalidTypeError(ngModule.name, 'NgModule');\n    }\n    this.recompileNgModule(ngModule, metadata);\n    this.queueTypesFromModulesArray([ngModule]);\n  }\n  overrideComponent(component, override) {\n    this.verifyNoStandaloneFlagOverrides(component, override);\n    this.resolvers.component.addOverride(component, override);\n    this.pendingComponents.add(component);\n    this.maybeRegisterComponentWithAsyncMetadata(component);\n  }\n  overrideDirective(directive, override) {\n    this.verifyNoStandaloneFlagOverrides(directive, override);\n    this.resolvers.directive.addOverride(directive, override);\n    this.pendingDirectives.add(directive);\n  }\n  overridePipe(pipe, override) {\n    this.verifyNoStandaloneFlagOverrides(pipe, override);\n    this.resolvers.pipe.addOverride(pipe, override);\n    this.pendingPipes.add(pipe);\n  }\n  verifyNoStandaloneFlagOverrides(type, override) {\n    if (override.add?.hasOwnProperty('standalone') || override.set?.hasOwnProperty('standalone') || override.remove?.hasOwnProperty('standalone')) {\n      throw new Error(`An override for the ${type.name} class has the \\`standalone\\` flag. ` + `Changing the \\`standalone\\` flag via TestBed overrides is not supported.`);\n    }\n  }\n  overrideProvider(token, provider) {\n    let providerDef;\n    if (provider.useFactory !== undefined) {\n      providerDef = {\n        provide: token,\n        useFactory: provider.useFactory,\n        deps: provider.deps || [],\n        multi: provider.multi\n      };\n    } else if (provider.useValue !== undefined) {\n      providerDef = {\n        provide: token,\n        useValue: provider.useValue,\n        multi: provider.multi\n      };\n    } else {\n      providerDef = {\n        provide: token\n      };\n    }\n    const injectableDef = typeof token !== 'string' ? getInjectableDef(token) : null;\n    const providedIn = injectableDef === null ? null : resolveForwardRef(injectableDef.providedIn);\n    const overridesBucket = providedIn === 'root' ? this.rootProviderOverrides : this.providerOverrides;\n    overridesBucket.push(providerDef);\n    this.providerOverridesByToken.set(token, providerDef);\n    if (injectableDef !== null && providedIn !== null && typeof providedIn !== 'string') {\n      const existingOverrides = this.providerOverridesByModule.get(providedIn);\n      if (existingOverrides !== undefined) {\n        existingOverrides.push(providerDef);\n      } else {\n        this.providerOverridesByModule.set(providedIn, [providerDef]);\n      }\n    }\n  }\n  overrideTemplateUsingTestingModule(type, template) {\n    const def = type[NG_COMP_DEF];\n    const hasStyleUrls = () => {\n      const metadata = this.resolvers.component.resolve(type);\n      return !!metadata.styleUrl || !!metadata.styleUrls?.length;\n    };\n    const overrideStyleUrls = !!def && !isComponentDefPendingResolution(type) && hasStyleUrls();\n    const override = overrideStyleUrls ? {\n      template,\n      styles: [],\n      styleUrls: [],\n      styleUrl: undefined\n    } : {\n      template\n    };\n    this.overrideComponent(type, {\n      set: override\n    });\n    if (overrideStyleUrls && def.styles && def.styles.length > 0) {\n      this.existingComponentStyles.set(type, def.styles);\n    }\n    this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\n  }\n  resolvePendingComponentsWithAsyncMetadata() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.componentsWithAsyncMetadata.size === 0) return;\n      const promises = [];\n      for (const component of _this2.componentsWithAsyncMetadata) {\n        const asyncMetadataFn = getAsyncClassMetadataFn(component);\n        if (asyncMetadataFn) {\n          promises.push(asyncMetadataFn());\n        }\n      }\n      _this2.componentsWithAsyncMetadata.clear();\n      const resolvedDeps = yield Promise.all(promises);\n      const flatResolvedDeps = resolvedDeps.flat(2);\n      _this2.queueTypesFromModulesArray(flatResolvedDeps);\n      for (const component of flatResolvedDeps) {\n        _this2.applyProviderOverridesInScope(component);\n      }\n    })();\n  }\n  compileComponents() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      _this3.clearComponentResolutionQueue();\n      yield _this3.resolvePendingComponentsWithAsyncMetadata();\n      assertNoStandaloneComponents(_this3.declarations, _this3.resolvers.component, '\"TestBed.configureTestingModule\" call');\n      let needsAsyncResources = _this3.compileTypesSync();\n      if (needsAsyncResources) {\n        let resourceLoader;\n        let resolver = url => {\n          if (!resourceLoader) {\n            resourceLoader = _this3.injector.get(ResourceLoader);\n          }\n          return Promise.resolve(resourceLoader.get(url));\n        };\n        yield resolveComponentResources(resolver);\n      }\n    })();\n  }\n  finalize() {\n    this.compileTypesSync();\n    this.compileTestModule();\n    this.applyTransitiveScopes();\n    this.applyProviderOverrides();\n    this.patchComponentsWithExistingStyles();\n    this.componentToModuleScope.clear();\n    const parentInjector = this.platform.injector;\n    this.testModuleRef = new NgModuleRef(this.testModuleType, parentInjector, []);\n    this.testModuleRef.injector.get(ApplicationInitStatus).runInitializers();\n    const localeId = this.testModuleRef.injector.get(LOCALE_ID, DEFAULT_LOCALE_ID);\n    setLocaleId(localeId);\n    return this.testModuleRef;\n  }\n  _compileNgModuleSync(moduleType) {\n    this.queueTypesFromModulesArray([moduleType]);\n    this.compileTypesSync();\n    this.applyProviderOverrides();\n    this.applyProviderOverridesInScope(moduleType);\n    this.applyTransitiveScopes();\n  }\n  _compileNgModuleAsync(moduleType) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      _this4.queueTypesFromModulesArray([moduleType]);\n      yield _this4.compileComponents();\n      _this4.applyProviderOverrides();\n      _this4.applyProviderOverridesInScope(moduleType);\n      _this4.applyTransitiveScopes();\n    })();\n  }\n  _getModuleResolver() {\n    return this.resolvers.module;\n  }\n  _getComponentFactories(moduleType) {\n    return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce((factories, declaration) => {\n      const componentDef = declaration.ɵcmp;\n      componentDef && factories.push(new ComponentFactory(componentDef, this.testModuleRef));\n      return factories;\n    }, []);\n  }\n  compileTypesSync() {\n    let needsAsyncResources = false;\n    this.pendingComponents.forEach(declaration => {\n      if (getAsyncClassMetadataFn(declaration)) {\n        throw new Error(`Component '${declaration.name}' has unresolved metadata. ` + `Please call \\`await TestBed.compileComponents()\\` before running this test.`);\n      }\n      needsAsyncResources = needsAsyncResources || isComponentDefPendingResolution(declaration);\n      const metadata = this.resolvers.component.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Component');\n      }\n      this.maybeStoreNgDef(NG_COMP_DEF, declaration);\n      depsTracker.clearScopeCacheFor(declaration);\n      compileComponent(declaration, metadata);\n    });\n    this.pendingComponents.clear();\n    this.pendingDirectives.forEach(declaration => {\n      const metadata = this.resolvers.directive.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Directive');\n      }\n      this.maybeStoreNgDef(NG_DIR_DEF, declaration);\n      compileDirective(declaration, metadata);\n    });\n    this.pendingDirectives.clear();\n    this.pendingPipes.forEach(declaration => {\n      const metadata = this.resolvers.pipe.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Pipe');\n      }\n      this.maybeStoreNgDef(NG_PIPE_DEF, declaration);\n      compilePipe(declaration, metadata);\n    });\n    this.pendingPipes.clear();\n    return needsAsyncResources;\n  }\n  applyTransitiveScopes() {\n    if (this.overriddenModules.size > 0) {\n      const testingModuleDef = this.testModuleType[NG_MOD_DEF];\n      const affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);\n      if (affectedModules.size > 0) {\n        affectedModules.forEach(moduleType => {\n          depsTracker.clearScopeCacheFor(moduleType);\n        });\n      }\n    }\n    const moduleToScope = new Map();\n    const getScopeOfModule = moduleType => {\n      if (!moduleToScope.has(moduleType)) {\n        const isTestingModule = isTestingModuleOverride(moduleType);\n        const realType = isTestingModule ? this.testModuleType : moduleType;\n        moduleToScope.set(moduleType, transitiveScopesFor(realType));\n      }\n      return moduleToScope.get(moduleType);\n    };\n    this.componentToModuleScope.forEach((moduleType, componentType) => {\n      if (moduleType !== null) {\n        const moduleScope = getScopeOfModule(moduleType);\n        this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, 'directiveDefs');\n        this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, 'pipeDefs');\n        patchComponentDefWithScope(getComponentDef(componentType), moduleScope);\n      }\n      this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, 'tView');\n    });\n    this.componentToModuleScope.clear();\n  }\n  applyProviderOverrides() {\n    const maybeApplyOverrides = field => type => {\n      const resolver = field === NG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;\n      const metadata = resolver.resolve(type);\n      if (this.hasProviderOverrides(metadata.providers)) {\n        this.patchDefWithProviderOverrides(type, field);\n      }\n    };\n    this.seenComponents.forEach(maybeApplyOverrides(NG_COMP_DEF));\n    this.seenDirectives.forEach(maybeApplyOverrides(NG_DIR_DEF));\n    this.seenComponents.clear();\n    this.seenDirectives.clear();\n  }\n  applyProviderOverridesInScope(type) {\n    const hasScope = isStandaloneComponent(type) || isNgModule(type);\n    if (!hasScope || this.scopesWithOverriddenProviders.has(type)) {\n      return;\n    }\n    this.scopesWithOverriddenProviders.add(type);\n    const injectorDef = type[NG_INJ_DEF];\n    if (this.providerOverridesByToken.size === 0) return;\n    if (isStandaloneComponent(type)) {\n      const def = getComponentDef(type);\n      const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n      for (const dependency of dependencies) {\n        this.applyProviderOverridesInScope(dependency);\n      }\n    } else {\n      const providers = [...injectorDef.providers, ...(this.providerOverridesByModule.get(type) || [])];\n      if (this.hasProviderOverrides(providers)) {\n        this.maybeStoreNgDef(NG_INJ_DEF, type);\n        this.storeFieldOfDefOnType(type, NG_INJ_DEF, 'providers');\n        injectorDef.providers = this.getOverriddenProviders(providers);\n      }\n      const moduleDef = type[NG_MOD_DEF];\n      const imports = maybeUnwrapFn(moduleDef.imports);\n      for (const importedModule of imports) {\n        this.applyProviderOverridesInScope(importedModule);\n      }\n      for (const importedModule of flatten(injectorDef.imports)) {\n        if (isModuleWithProviders(importedModule)) {\n          this.defCleanupOps.push({\n            object: importedModule,\n            fieldName: 'providers',\n            originalValue: importedModule.providers\n          });\n          importedModule.providers = this.getOverriddenProviders(importedModule.providers);\n        }\n      }\n    }\n  }\n  patchComponentsWithExistingStyles() {\n    this.existingComponentStyles.forEach((styles, type) => type[NG_COMP_DEF].styles = styles);\n    this.existingComponentStyles.clear();\n  }\n  queueTypeArray(arr, moduleType) {\n    for (const value of arr) {\n      if (Array.isArray(value)) {\n        this.queueTypeArray(value, moduleType);\n      } else {\n        this.queueType(value, moduleType);\n      }\n    }\n  }\n  recompileNgModule(ngModule, metadata) {\n    this.maybeStoreNgDef(NG_MOD_DEF, ngModule);\n    this.maybeStoreNgDef(NG_INJ_DEF, ngModule);\n    compileNgModuleDefs(ngModule, metadata);\n  }\n  maybeRegisterComponentWithAsyncMetadata(type) {\n    const asyncMetadataFn = getAsyncClassMetadataFn(type);\n    if (asyncMetadataFn) {\n      this.componentsWithAsyncMetadata.add(type);\n    }\n  }\n  queueType(type, moduleType) {\n    this.maybeRegisterComponentWithAsyncMetadata(type);\n    const component = this.resolvers.component.resolve(type);\n    if (component) {\n      if (isComponentDefPendingResolution(type) || !type.hasOwnProperty(NG_COMP_DEF)) {\n        this.pendingComponents.add(type);\n      }\n      this.seenComponents.add(type);\n      if (!this.componentToModuleScope.has(type) || this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION) {\n        this.componentToModuleScope.set(type, moduleType);\n      }\n      return;\n    }\n    const directive = this.resolvers.directive.resolve(type);\n    if (directive) {\n      if (!type.hasOwnProperty(NG_DIR_DEF)) {\n        this.pendingDirectives.add(type);\n      }\n      this.seenDirectives.add(type);\n      return;\n    }\n    const pipe = this.resolvers.pipe.resolve(type);\n    if (pipe && !type.hasOwnProperty(NG_PIPE_DEF)) {\n      this.pendingPipes.add(type);\n      return;\n    }\n  }\n  queueTypesFromModulesArray(arr) {\n    const processedDefs = new Set();\n    const queueTypesFromModulesArrayRecur = arr => {\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          queueTypesFromModulesArrayRecur(value);\n        } else if (hasNgModuleDef(value)) {\n          const def = value.ɵmod;\n          if (processedDefs.has(def)) {\n            continue;\n          }\n          processedDefs.add(def);\n          this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\n        } else if (isModuleWithProviders(value)) {\n          queueTypesFromModulesArrayRecur([value.ngModule]);\n        } else if (isStandaloneComponent(value)) {\n          this.queueType(value, null);\n          const def = getComponentDef(value);\n          if (processedDefs.has(def)) {\n            continue;\n          }\n          processedDefs.add(def);\n          const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n          dependencies.forEach(dependency => {\n            if (isStandaloneComponent(dependency) || hasNgModuleDef(dependency)) {\n              queueTypesFromModulesArrayRecur([dependency]);\n            } else {\n              this.queueType(dependency, null);\n            }\n          });\n        }\n      }\n    };\n    queueTypesFromModulesArrayRecur(arr);\n  }\n  collectModulesAffectedByOverrides(arr) {\n    const seenModules = new Set();\n    const affectedModules = new Set();\n    const calcAffectedModulesRecur = (arr, path) => {\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          calcAffectedModulesRecur(value, path);\n        } else if (hasNgModuleDef(value)) {\n          if (seenModules.has(value)) {\n            if (affectedModules.has(value)) {\n              path.forEach(item => affectedModules.add(item));\n            }\n            continue;\n          }\n          seenModules.add(value);\n          if (this.overriddenModules.has(value)) {\n            path.forEach(item => affectedModules.add(item));\n          }\n          const moduleDef = value[NG_MOD_DEF];\n          calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports), path.concat(value));\n        }\n      }\n    };\n    calcAffectedModulesRecur(arr, []);\n    return affectedModules;\n  }\n  maybeStoreNgDef(prop, type) {\n    if (!this.initialNgDefs.has(type)) {\n      this.initialNgDefs.set(type, new Map());\n    }\n    const currentDefs = this.initialNgDefs.get(type);\n    if (!currentDefs.has(prop)) {\n      const currentDef = Object.getOwnPropertyDescriptor(type, prop);\n      currentDefs.set(prop, currentDef);\n    }\n  }\n  storeFieldOfDefOnType(type, defField, fieldName) {\n    const def = type[defField];\n    const originalValue = def[fieldName];\n    this.defCleanupOps.push({\n      object: def,\n      fieldName,\n      originalValue\n    });\n  }\n  clearComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue === null) {\n      this.originalComponentResolutionQueue = new Map();\n    }\n    clearResolutionOfComponentResourcesQueue().forEach((value, key) => this.originalComponentResolutionQueue.set(key, value));\n  }\n  restoreComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue !== null) {\n      restoreComponentResolutionQueue(this.originalComponentResolutionQueue);\n      this.originalComponentResolutionQueue = null;\n    }\n  }\n  restoreOriginalState() {\n    forEachRight(this.defCleanupOps, op => {\n      op.object[op.fieldName] = op.originalValue;\n    });\n    this.initialNgDefs.forEach((defs, type) => {\n      depsTracker.clearScopeCacheFor(type);\n      defs.forEach((descriptor, prop) => {\n        if (!descriptor) {\n          delete type[prop];\n        } else {\n          Object.defineProperty(type, prop, descriptor);\n        }\n      });\n    });\n    this.initialNgDefs.clear();\n    this.scopesWithOverriddenProviders.clear();\n    this.restoreComponentResolutionQueue();\n    setLocaleId(DEFAULT_LOCALE_ID);\n  }\n  compileTestModule() {\n    class RootScopeModule {}\n    compileNgModuleDefs(RootScopeModule, {\n      providers: [...this.rootProviderOverrides, provideZonelessChangeDetectionInternal(), TestBedApplicationErrorHandler, {\n        provide: ENVIRONMENT_INITIALIZER,\n        multi: true,\n        useValue: () => {\n          inject$1(ErrorHandler);\n        }\n      }]\n    });\n    const providers = [{\n      provide: Compiler,\n      useFactory: () => new R3TestCompiler(this)\n    }, {\n      provide: DEFER_BLOCK_CONFIG,\n      useValue: {\n        behavior: this.deferBlockBehavior\n      }\n    }, {\n      provide: ANIMATIONS_DISABLED,\n      useValue: !this.animationsEnabled\n    }, {\n      provide: INTERNAL_APPLICATION_ERROR_HANDLER,\n      useFactory: () => {\n        if (this.rethrowApplicationTickErrors) {\n          const handler = inject$1(TestBedApplicationErrorHandler);\n          return e => {\n            handler.handleError(e);\n          };\n        } else {\n          const userErrorHandler = inject$1(ErrorHandler);\n          const ngZone = inject$1(NgZone);\n          return e => ngZone.runOutsideAngular(() => userErrorHandler.handleError(e));\n        }\n      }\n    }, ...this.providers, ...this.providerOverrides];\n    const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []];\n    compileNgModuleDefs(this.testModuleType, {\n      declarations: this.declarations,\n      imports,\n      schemas: this.schemas,\n      providers\n    }, true);\n    this.applyProviderOverridesInScope(this.testModuleType);\n  }\n  get injector() {\n    if (this._injector !== null) {\n      return this._injector;\n    }\n    const providers = [];\n    const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS, []);\n    compilerOptions.forEach(opts => {\n      if (opts.providers) {\n        providers.push(opts.providers);\n      }\n    });\n    if (this.compilerProviders !== null) {\n      providers.push(...this.compilerProviders);\n    }\n    this._injector = Injector.create({\n      providers,\n      parent: this.platform.injector\n    });\n    return this._injector;\n  }\n  getSingleProviderOverrides(provider) {\n    const token = getProviderToken(provider);\n    return this.providerOverridesByToken.get(token) || null;\n  }\n  getProviderOverrides(providers) {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return [];\n    return flatten(flattenProviders(providers, provider => this.getSingleProviderOverrides(provider) || []));\n  }\n  getOverriddenProviders(providers) {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return [];\n    const flattenedProviders = flattenProviders(providers);\n    const overrides = this.getProviderOverrides(flattenedProviders);\n    const overriddenProviders = [...flattenedProviders, ...overrides];\n    const final = [];\n    const seenOverriddenProviders = new Set();\n    forEachRight(overriddenProviders, provider => {\n      const token = getProviderToken(provider);\n      if (this.providerOverridesByToken.has(token)) {\n        if (!seenOverriddenProviders.has(token)) {\n          seenOverriddenProviders.add(token);\n          final.unshift({\n            ...provider,\n            multi: false\n          });\n        }\n      } else {\n        final.unshift(provider);\n      }\n    });\n    return final;\n  }\n  hasProviderOverrides(providers) {\n    return this.getProviderOverrides(providers).length > 0;\n  }\n  patchDefWithProviderOverrides(declaration, field) {\n    const def = declaration[field];\n    if (def && def.providersResolver) {\n      this.maybeStoreNgDef(field, declaration);\n      const resolver = def.providersResolver;\n      const processProvidersFn = providers => this.getOverriddenProviders(providers);\n      this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\n      def.providersResolver = ngDef => resolver(ngDef, processProvidersFn);\n    }\n  }\n}\nfunction initResolvers() {\n  return {\n    module: new NgModuleResolver(),\n    component: new ComponentResolver(),\n    directive: new DirectiveResolver(),\n    pipe: new PipeResolver()\n  };\n}\nfunction isStandaloneComponent(value) {\n  const def = getComponentDef(value);\n  return !!def?.standalone;\n}\nfunction getComponentDef(value) {\n  return value.ɵcmp ?? null;\n}\nfunction hasNgModuleDef(value) {\n  return value.hasOwnProperty('ɵmod');\n}\nfunction isNgModule(value) {\n  return hasNgModuleDef(value);\n}\nfunction maybeUnwrapFn(maybeFn) {\n  return maybeFn instanceof Function ? maybeFn() : maybeFn;\n}\nfunction flatten(values) {\n  const out = [];\n  values.forEach(value => {\n    if (Array.isArray(value)) {\n      out.push(...flatten(value));\n    } else {\n      out.push(value);\n    }\n  });\n  return out;\n}\nfunction identityFn(value) {\n  return value;\n}\nfunction flattenProviders(providers, mapFn = identityFn) {\n  const out = [];\n  for (let provider of providers) {\n    if (isEnvironmentProviders(provider)) {\n      provider = provider.ɵproviders;\n    }\n    if (Array.isArray(provider)) {\n      out.push(...flattenProviders(provider, mapFn));\n    } else {\n      out.push(mapFn(provider));\n    }\n  }\n  return out;\n}\nfunction getProviderField(provider, field) {\n  return provider && typeof provider === 'object' && provider[field];\n}\nfunction getProviderToken(provider) {\n  return getProviderField(provider, 'provide') || provider;\n}\nfunction isModuleWithProviders(value) {\n  return value.hasOwnProperty('ngModule');\n}\nfunction forEachRight(values, fn) {\n  for (let idx = values.length - 1; idx >= 0; idx--) {\n    fn(values[idx], idx);\n  }\n}\nfunction invalidTypeError(name, expectedType) {\n  return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);\n}\nclass R3TestCompiler {\n  testBed;\n  constructor(testBed) {\n    this.testBed = testBed;\n  }\n  compileModuleSync(moduleType) {\n    this.testBed._compileNgModuleSync(moduleType);\n    return new NgModuleFactory(moduleType);\n  }\n  compileModuleAsync(moduleType) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      yield _this5.testBed._compileNgModuleAsync(moduleType);\n      return new NgModuleFactory(moduleType);\n    })();\n  }\n  compileModuleAndAllComponentsSync(moduleType) {\n    const ngModuleFactory = this.compileModuleSync(moduleType);\n    const componentFactories = this.testBed._getComponentFactories(moduleType);\n    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n  }\n  compileModuleAndAllComponentsAsync(moduleType) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const ngModuleFactory = yield _this6.compileModuleAsync(moduleType);\n      const componentFactories = _this6.testBed._getComponentFactories(moduleType);\n      return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    })();\n  }\n  clearCache() {}\n  clearCacheFor(type) {}\n  getModuleId(moduleType) {\n    const meta = this.testBed._getModuleResolver().resolve(moduleType);\n    return meta && meta.id || undefined;\n  }\n}\nlet _nextRootElementId = 0;\nfunction getTestBed() {\n  return TestBedImpl.INSTANCE;\n}\nclass TestBedImpl {\n  static _INSTANCE = null;\n  static get INSTANCE() {\n    return TestBedImpl._INSTANCE = TestBedImpl._INSTANCE || new TestBedImpl();\n  }\n  static _environmentTeardownOptions;\n  static _environmentErrorOnUnknownElementsOption;\n  static _environmentErrorOnUnknownPropertiesOption;\n  _instanceTeardownOptions;\n  _instanceDeferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n  _instanceAnimationsEnabled = ANIMATIONS_ENABLED_DEFAULT;\n  _instanceErrorOnUnknownElementsOption;\n  _instanceErrorOnUnknownPropertiesOption;\n  _previousErrorOnUnknownElementsOption;\n  _previousErrorOnUnknownPropertiesOption;\n  _instanceInferTagName;\n  static initTestEnvironment(ngModule, platform, options) {\n    const testBed = TestBedImpl.INSTANCE;\n    testBed.initTestEnvironment(ngModule, platform, options);\n    return testBed;\n  }\n  static resetTestEnvironment() {\n    TestBedImpl.INSTANCE.resetTestEnvironment();\n  }\n  static configureCompiler(config) {\n    return TestBedImpl.INSTANCE.configureCompiler(config);\n  }\n  static configureTestingModule(moduleDef) {\n    return TestBedImpl.INSTANCE.configureTestingModule(moduleDef);\n  }\n  static compileComponents() {\n    return TestBedImpl.INSTANCE.compileComponents();\n  }\n  static overrideModule(ngModule, override) {\n    return TestBedImpl.INSTANCE.overrideModule(ngModule, override);\n  }\n  static overrideComponent(component, override) {\n    return TestBedImpl.INSTANCE.overrideComponent(component, override);\n  }\n  static overrideDirective(directive, override) {\n    return TestBedImpl.INSTANCE.overrideDirective(directive, override);\n  }\n  static overridePipe(pipe, override) {\n    return TestBedImpl.INSTANCE.overridePipe(pipe, override);\n  }\n  static overrideTemplate(component, template) {\n    return TestBedImpl.INSTANCE.overrideTemplate(component, template);\n  }\n  static overrideTemplateUsingTestingModule(component, template) {\n    return TestBedImpl.INSTANCE.overrideTemplateUsingTestingModule(component, template);\n  }\n  static overrideProvider(token, provider) {\n    return TestBedImpl.INSTANCE.overrideProvider(token, provider);\n  }\n  static inject(token, notFoundValue, options) {\n    return TestBedImpl.INSTANCE.inject(token, notFoundValue, options);\n  }\n  static runInInjectionContext(fn) {\n    return TestBedImpl.INSTANCE.runInInjectionContext(fn);\n  }\n  static createComponent(component, options) {\n    return TestBedImpl.INSTANCE.createComponent(component, options);\n  }\n  static resetTestingModule() {\n    return TestBedImpl.INSTANCE.resetTestingModule();\n  }\n  static execute(tokens, fn, context) {\n    return TestBedImpl.INSTANCE.execute(tokens, fn, context);\n  }\n  static get platform() {\n    return TestBedImpl.INSTANCE.platform;\n  }\n  static get ngModule() {\n    return TestBedImpl.INSTANCE.ngModule;\n  }\n  static flushEffects() {\n    return TestBedImpl.INSTANCE.tick();\n  }\n  static tick() {\n    return TestBedImpl.INSTANCE.tick();\n  }\n  platform = null;\n  ngModule = null;\n  _compiler = null;\n  _testModuleRef = null;\n  _activeFixtures = [];\n  globalCompilationChecked = false;\n  initTestEnvironment(ngModule, platform, options) {\n    if (this.platform || this.ngModule) {\n      throw new Error('Cannot set base providers because it has already been called');\n    }\n    TestBedImpl._environmentTeardownOptions = options?.teardown;\n    TestBedImpl._environmentErrorOnUnknownElementsOption = options?.errorOnUnknownElements;\n    TestBedImpl._environmentErrorOnUnknownPropertiesOption = options?.errorOnUnknownProperties;\n    this.platform = platform;\n    this.ngModule = ngModule;\n    this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n    setAllowDuplicateNgModuleIdsForTest(true);\n  }\n  resetTestEnvironment() {\n    this.resetTestingModule();\n    this._compiler = null;\n    this.platform = null;\n    this.ngModule = null;\n    TestBedImpl._environmentTeardownOptions = undefined;\n    setAllowDuplicateNgModuleIdsForTest(false);\n  }\n  resetTestingModule() {\n    this.checkGlobalCompilationFinished();\n    resetCompiledComponents();\n    if (this._compiler !== null) {\n      this.compiler.restoreOriginalState();\n    }\n    this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n    _setUnknownElementStrictMode(this._previousErrorOnUnknownElementsOption ?? THROW_ON_UNKNOWN_ELEMENTS_DEFAULT);\n    _setUnknownPropertyStrictMode(this._previousErrorOnUnknownPropertiesOption ?? THROW_ON_UNKNOWN_PROPERTIES_DEFAULT);\n    try {\n      this.destroyActiveFixtures();\n    } finally {\n      try {\n        if (this.shouldTearDownTestingModule()) {\n          this.tearDownTestingModule();\n        }\n      } finally {\n        this._testModuleRef = null;\n        this._instanceTeardownOptions = undefined;\n        this._instanceErrorOnUnknownElementsOption = undefined;\n        this._instanceErrorOnUnknownPropertiesOption = undefined;\n        this._instanceInferTagName = undefined;\n        this._instanceDeferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n        this._instanceAnimationsEnabled = ANIMATIONS_ENABLED_DEFAULT;\n      }\n    }\n    return this;\n  }\n  configureCompiler(config) {\n    if (config.useJit != null) {\n      throw new Error('JIT compiler is not configurable via TestBed APIs.');\n    }\n    if (config.providers !== undefined) {\n      this.compiler.setCompilerProviders(config.providers);\n    }\n    return this;\n  }\n  configureTestingModule(moduleDef) {\n    this.assertNotInstantiated('TestBed.configureTestingModule', 'configure the test module');\n    this.checkGlobalCompilationFinished();\n    this._instanceTeardownOptions = moduleDef.teardown;\n    this._instanceErrorOnUnknownElementsOption = moduleDef.errorOnUnknownElements;\n    this._instanceErrorOnUnknownPropertiesOption = moduleDef.errorOnUnknownProperties;\n    this._instanceInferTagName = moduleDef.inferTagName;\n    this._instanceDeferBlockBehavior = moduleDef.deferBlockBehavior ?? DEFER_BLOCK_DEFAULT_BEHAVIOR;\n    this._instanceAnimationsEnabled = moduleDef.animationsEnabled ?? ANIMATIONS_ENABLED_DEFAULT;\n    this._previousErrorOnUnknownElementsOption = _getUnknownElementStrictMode();\n    _setUnknownElementStrictMode(this.shouldThrowErrorOnUnknownElements());\n    this._previousErrorOnUnknownPropertiesOption = _getUnknownPropertyStrictMode();\n    _setUnknownPropertyStrictMode(this.shouldThrowErrorOnUnknownProperties());\n    this.compiler.configureTestingModule(moduleDef);\n    return this;\n  }\n  compileComponents() {\n    return this.compiler.compileComponents();\n  }\n  inject(token, notFoundValue, options) {\n    if (token === TestBed) {\n      return this;\n    }\n    const UNDEFINED = {};\n    const result = this.testModuleRef.injector.get(token, UNDEFINED, options);\n    return result === UNDEFINED ? this.compiler.injector.get(token, notFoundValue, options) : result;\n  }\n  runInInjectionContext(fn) {\n    return runInInjectionContext(this.inject(EnvironmentInjector), fn);\n  }\n  execute(tokens, fn, context) {\n    const params = tokens.map(t => this.inject(t));\n    return fn.apply(context, params);\n  }\n  overrideModule(ngModule, override) {\n    this.assertNotInstantiated('overrideModule', 'override module metadata');\n    this.compiler.overrideModule(ngModule, override);\n    return this;\n  }\n  overrideComponent(component, override) {\n    this.assertNotInstantiated('overrideComponent', 'override component metadata');\n    this.compiler.overrideComponent(component, override);\n    return this;\n  }\n  overrideTemplateUsingTestingModule(component, template) {\n    this.assertNotInstantiated('TestBed.overrideTemplateUsingTestingModule', 'Cannot override template when the test module has already been instantiated');\n    this.compiler.overrideTemplateUsingTestingModule(component, template);\n    return this;\n  }\n  overrideDirective(directive, override) {\n    this.assertNotInstantiated('overrideDirective', 'override directive metadata');\n    this.compiler.overrideDirective(directive, override);\n    return this;\n  }\n  overridePipe(pipe, override) {\n    this.assertNotInstantiated('overridePipe', 'override pipe metadata');\n    this.compiler.overridePipe(pipe, override);\n    return this;\n  }\n  overrideProvider(token, provider) {\n    this.assertNotInstantiated('overrideProvider', 'override provider');\n    this.compiler.overrideProvider(token, provider);\n    return this;\n  }\n  overrideTemplate(component, template) {\n    return this.overrideComponent(component, {\n      set: {\n        template,\n        templateUrl: null\n      }\n    });\n  }\n  createComponent(type, options) {\n    if (getAsyncClassMetadataFn(type)) {\n      throw new Error(`Component '${type.name}' has unresolved metadata. ` + `Please call \\`await TestBed.compileComponents()\\` before running this test.`);\n    }\n    const testComponentRenderer = this.inject(TestComponentRenderer);\n    const shouldInferTagName = options?.inferTagName ?? this._instanceInferTagName ?? false;\n    const componentDef = getComponentDef$1(type);\n    const rootElId = `root${_nextRootElementId++}`;\n    if (!componentDef) {\n      throw new Error(`It looks like '${stringify(type)}' has not been compiled.`);\n    }\n    testComponentRenderer.insertRootElement(rootElId, shouldInferTagName ? inferTagNameFromDefinition(componentDef) : undefined);\n    const componentFactory = new ComponentFactory(componentDef);\n    const initComponent = () => {\n      const componentRef = componentFactory.create(Injector.NULL, [], `#${rootElId}`, this.testModuleRef, undefined, options?.bindings);\n      return this.runInInjectionContext(() => new ComponentFixture(componentRef));\n    };\n    const noNgZone = this.inject(ComponentFixtureNoNgZone, false);\n    const ngZone = noNgZone ? null : this.inject(NgZone, null);\n    const fixture = ngZone ? ngZone.run(initComponent) : initComponent();\n    this._activeFixtures.push(fixture);\n    return fixture;\n  }\n  get compiler() {\n    if (this._compiler === null) {\n      throw new Error(`Need to call TestBed.initTestEnvironment() first`);\n    }\n    return this._compiler;\n  }\n  get testModuleRef() {\n    if (this._testModuleRef === null) {\n      this._testModuleRef = this.compiler.finalize();\n    }\n    return this._testModuleRef;\n  }\n  assertNotInstantiated(methodName, methodDescription) {\n    if (this._testModuleRef !== null) {\n      throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` + `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n    }\n  }\n  checkGlobalCompilationFinished() {\n    if (!this.globalCompilationChecked && this._testModuleRef === null) {\n      flushModuleScopingQueueAsMuchAsPossible();\n    }\n    this.globalCompilationChecked = true;\n  }\n  destroyActiveFixtures() {\n    let errorCount = 0;\n    this._activeFixtures.forEach(fixture => {\n      try {\n        fixture.destroy();\n      } catch (e) {\n        errorCount++;\n        console.error('Error during cleanup of component', {\n          component: fixture.componentInstance,\n          stacktrace: e\n        });\n      }\n    });\n    this._activeFixtures = [];\n    if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\n      throw Error(`${errorCount} ${errorCount === 1 ? 'component' : 'components'} ` + `threw errors during cleanup`);\n    }\n  }\n  shouldRethrowTeardownErrors() {\n    const instanceOptions = this._instanceTeardownOptions;\n    const environmentOptions = TestBedImpl._environmentTeardownOptions;\n    if (!instanceOptions && !environmentOptions) {\n      return TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n    }\n    return instanceOptions?.rethrowErrors ?? environmentOptions?.rethrowErrors ?? this.shouldTearDownTestingModule();\n  }\n  shouldThrowErrorOnUnknownElements() {\n    return this._instanceErrorOnUnknownElementsOption ?? TestBedImpl._environmentErrorOnUnknownElementsOption ?? THROW_ON_UNKNOWN_ELEMENTS_DEFAULT;\n  }\n  shouldThrowErrorOnUnknownProperties() {\n    return this._instanceErrorOnUnknownPropertiesOption ?? TestBedImpl._environmentErrorOnUnknownPropertiesOption ?? THROW_ON_UNKNOWN_PROPERTIES_DEFAULT;\n  }\n  shouldTearDownTestingModule() {\n    return this._instanceTeardownOptions?.destroyAfterEach ?? TestBedImpl._environmentTeardownOptions?.destroyAfterEach ?? TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n  }\n  getDeferBlockBehavior() {\n    return this._instanceDeferBlockBehavior;\n  }\n  getAnimationsEnabled() {\n    return this._instanceAnimationsEnabled;\n  }\n  tearDownTestingModule() {\n    if (this._testModuleRef === null) {\n      return;\n    }\n    const testRenderer = this.inject(TestComponentRenderer);\n    try {\n      this._testModuleRef.destroy();\n    } catch (e) {\n      if (this.shouldRethrowTeardownErrors()) {\n        throw e;\n      } else {\n        console.error('Error during cleanup of a testing module', {\n          component: this._testModuleRef.instance,\n          stacktrace: e\n        });\n      }\n    } finally {\n      testRenderer.removeAllRootElements?.();\n    }\n  }\n  flushEffects() {\n    this.tick();\n  }\n  tick() {\n    const appRef = this.inject(ApplicationRef);\n    try {\n      appRef.includeAllTestViews = true;\n      appRef.tick();\n    } finally {\n      appRef.includeAllTestViews = false;\n    }\n  }\n}\nconst TestBed = TestBedImpl;\nfunction inject(tokens, fn) {\n  const testBed = TestBedImpl.INSTANCE;\n  return function () {\n    return testBed.execute(tokens, fn, this);\n  };\n}\nclass InjectSetupWrapper {\n  _moduleDef;\n  constructor(_moduleDef) {\n    this._moduleDef = _moduleDef;\n  }\n  _addModule() {\n    const moduleDef = this._moduleDef();\n    if (moduleDef) {\n      TestBedImpl.configureTestingModule(moduleDef);\n    }\n  }\n  inject(tokens, fn) {\n    const self = this;\n    return function () {\n      self._addModule();\n      return inject(tokens, fn).call(this);\n    };\n  }\n}\nfunction withModule(moduleDef, fn) {\n  if (fn) {\n    return function () {\n      const testBed = TestBedImpl.INSTANCE;\n      if (moduleDef) {\n        testBed.configureTestingModule(moduleDef);\n      }\n      return fn.apply(this);\n    };\n  }\n  return new InjectSetupWrapper(() => moduleDef);\n}\nclass FakeNavigation {\n  entriesArr = [];\n  currentEntryIndex = 0;\n  navigateEvent = null;\n  traversalQueue = new Map();\n  nextTraversal = Promise.resolve();\n  prospectiveEntryIndex = 0;\n  synchronousTraversals = false;\n  canSetInitialEntry = true;\n  eventTarget;\n  nextId = 0;\n  nextKey = 0;\n  disposed = false;\n  get currentEntry() {\n    return this.entriesArr[this.currentEntryIndex];\n  }\n  get canGoBack() {\n    return this.currentEntryIndex > 0;\n  }\n  get canGoForward() {\n    return this.currentEntryIndex < this.entriesArr.length - 1;\n  }\n  createEventTarget;\n  _window;\n  get window() {\n    return this._window;\n  }\n  constructor(doc, startURL) {\n    this.createEventTarget = () => {\n      try {\n        return doc.createElement('div');\n      } catch {\n        return new EventTarget();\n      }\n    };\n    this._window = document.defaultView ?? this.createEventTarget();\n    this.eventTarget = this.createEventTarget();\n    this.setInitialEntryForTesting(startURL);\n  }\n  setInitialEntryForTesting(url, options = {\n    historyState: null\n  }) {\n    if (!this.canSetInitialEntry) {\n      throw new Error('setInitialEntryForTesting can only be called before any ' + 'navigation has occurred');\n    }\n    const currentInitialEntry = this.entriesArr[0];\n    this.entriesArr[0] = new FakeNavigationHistoryEntry(this.eventTarget, new URL(url).toString(), {\n      index: 0,\n      key: currentInitialEntry?.key ?? String(this.nextKey++),\n      id: currentInitialEntry?.id ?? String(this.nextId++),\n      sameDocument: true,\n      historyState: options?.historyState,\n      state: options.state\n    });\n  }\n  canSetInitialEntryForTesting() {\n    return this.canSetInitialEntry;\n  }\n  setSynchronousTraversalsForTesting(synchronousTraversals) {\n    this.synchronousTraversals = synchronousTraversals;\n  }\n  entries() {\n    return this.entriesArr.slice();\n  }\n  navigate(url, options) {\n    const fromUrl = new URL(this.currentEntry.url);\n    const toUrl = new URL(url, this.currentEntry.url);\n    let navigationType;\n    if (!options?.history || options.history === 'auto') {\n      if (fromUrl.toString() === toUrl.toString()) {\n        navigationType = 'replace';\n      } else {\n        navigationType = 'push';\n      }\n    } else {\n      navigationType = options.history;\n    }\n    const hashChange = isHashChange(fromUrl, toUrl);\n    const destination = new FakeNavigationDestination({\n      url: toUrl.toString(),\n      state: options?.state,\n      sameDocument: hashChange,\n      historyState: null\n    });\n    const result = new InternalNavigationResult(this);\n    const intercepted = this.userAgentNavigate(destination, result, {\n      navigationType,\n      cancelable: true,\n      canIntercept: true,\n      userInitiated: false,\n      hashChange,\n      info: options?.info\n    });\n    if (!intercepted) {\n      this.updateNavigationEntriesForSameDocumentNavigation(this.navigateEvent);\n    }\n    return {\n      committed: result.committed,\n      finished: result.finished\n    };\n  }\n  pushState(data, title, url) {\n    this.pushOrReplaceState('push', data, title, url);\n  }\n  replaceState(data, title, url) {\n    this.pushOrReplaceState('replace', data, title, url);\n  }\n  pushOrReplaceState(navigationType, data, _title, url) {\n    const fromUrl = new URL(this.currentEntry.url);\n    const toUrl = url ? new URL(url, this.currentEntry.url) : fromUrl;\n    const hashChange = isHashChange(fromUrl, toUrl);\n    const destination = new FakeNavigationDestination({\n      url: toUrl.toString(),\n      sameDocument: true,\n      historyState: data,\n      state: undefined\n    });\n    const result = new InternalNavigationResult(this);\n    const intercepted = this.userAgentNavigate(destination, result, {\n      navigationType,\n      cancelable: true,\n      canIntercept: true,\n      userInitiated: false,\n      hashChange\n    });\n    if (intercepted) {\n      return;\n    }\n    this.updateNavigationEntriesForSameDocumentNavigation(this.navigateEvent);\n  }\n  traverseTo(key, options) {\n    const fromUrl = new URL(this.currentEntry.url);\n    const entry = this.findEntry(key);\n    if (!entry) {\n      const domException = new DOMException('Invalid key', 'InvalidStateError');\n      const committed = Promise.reject(domException);\n      const finished = Promise.reject(domException);\n      committed.catch(() => {});\n      finished.catch(() => {});\n      return {\n        committed,\n        finished\n      };\n    }\n    if (entry === this.currentEntry) {\n      return {\n        committed: Promise.resolve(this.currentEntry),\n        finished: Promise.resolve(this.currentEntry)\n      };\n    }\n    if (this.traversalQueue.has(entry.key)) {\n      const existingResult = this.traversalQueue.get(entry.key);\n      return {\n        committed: existingResult.committed,\n        finished: existingResult.finished\n      };\n    }\n    const hashChange = isHashChange(fromUrl, new URL(entry.url, this.currentEntry.url));\n    const destination = new FakeNavigationDestination({\n      url: entry.url,\n      state: entry.getState(),\n      historyState: entry.getHistoryState(),\n      key: entry.key,\n      id: entry.id,\n      index: entry.index,\n      sameDocument: entry.sameDocument\n    });\n    this.prospectiveEntryIndex = entry.index;\n    const result = new InternalNavigationResult(this);\n    this.traversalQueue.set(entry.key, result);\n    this.runTraversal(() => {\n      this.traversalQueue.delete(entry.key);\n      const intercepted = this.userAgentNavigate(destination, result, {\n        navigationType: 'traverse',\n        cancelable: true,\n        canIntercept: true,\n        userInitiated: false,\n        hashChange,\n        info: options?.info\n      });\n      if (!intercepted) {\n        this.userAgentTraverse(this.navigateEvent);\n      }\n    });\n    return {\n      committed: result.committed,\n      finished: result.finished\n    };\n  }\n  back(options) {\n    if (this.currentEntryIndex === 0) {\n      const domException = new DOMException('Cannot go back', 'InvalidStateError');\n      const committed = Promise.reject(domException);\n      const finished = Promise.reject(domException);\n      committed.catch(() => {});\n      finished.catch(() => {});\n      return {\n        committed,\n        finished\n      };\n    }\n    const entry = this.entriesArr[this.currentEntryIndex - 1];\n    return this.traverseTo(entry.key, options);\n  }\n  forward(options) {\n    if (this.currentEntryIndex === this.entriesArr.length - 1) {\n      const domException = new DOMException('Cannot go forward', 'InvalidStateError');\n      const committed = Promise.reject(domException);\n      const finished = Promise.reject(domException);\n      committed.catch(() => {});\n      finished.catch(() => {});\n      return {\n        committed,\n        finished\n      };\n    }\n    const entry = this.entriesArr[this.currentEntryIndex + 1];\n    return this.traverseTo(entry.key, options);\n  }\n  go(direction) {\n    const targetIndex = this.prospectiveEntryIndex + direction;\n    if (targetIndex >= this.entriesArr.length || targetIndex < 0) {\n      return;\n    }\n    this.prospectiveEntryIndex = targetIndex;\n    this.runTraversal(() => {\n      if (targetIndex >= this.entriesArr.length || targetIndex < 0) {\n        return;\n      }\n      const fromUrl = new URL(this.currentEntry.url);\n      const entry = this.entriesArr[targetIndex];\n      const hashChange = isHashChange(fromUrl, new URL(entry.url, this.currentEntry.url));\n      const destination = new FakeNavigationDestination({\n        url: entry.url,\n        state: entry.getState(),\n        historyState: entry.getHistoryState(),\n        key: entry.key,\n        id: entry.id,\n        index: entry.index,\n        sameDocument: entry.sameDocument\n      });\n      const result = new InternalNavigationResult(this);\n      const intercepted = this.userAgentNavigate(destination, result, {\n        navigationType: 'traverse',\n        cancelable: true,\n        canIntercept: true,\n        userInitiated: false,\n        hashChange\n      });\n      if (!intercepted) {\n        this.userAgentTraverse(this.navigateEvent);\n      }\n    });\n  }\n  runTraversal(traversal) {\n    if (this.synchronousTraversals) {\n      traversal();\n      return;\n    }\n    this.nextTraversal = this.nextTraversal.then(() => {\n      return new Promise(resolve => {\n        setTimeout(() => {\n          resolve();\n          traversal();\n        });\n      });\n    });\n  }\n  addEventListener(type, callback, options) {\n    this.eventTarget.addEventListener(type, callback, options);\n  }\n  removeEventListener(type, callback, options) {\n    this.eventTarget.removeEventListener(type, callback, options);\n  }\n  dispatchEvent(event) {\n    return this.eventTarget.dispatchEvent(event);\n  }\n  dispose() {\n    this.eventTarget = this.createEventTarget();\n    this.disposed = true;\n  }\n  isDisposed() {\n    return this.disposed;\n  }\n  abortOngoingNavigation(eventToAbort, reason) {\n    if (this.navigateEvent !== eventToAbort) {\n      return;\n    }\n    if (this.navigateEvent.abortController.signal.aborted) {\n      return;\n    }\n    const abortReason = reason ?? new DOMException('Navigation aborted', 'AbortError');\n    this.navigateEvent.abort(abortReason);\n  }\n  userAgentNavigate(destination, result, options) {\n    this.canSetInitialEntry = false;\n    if (this.navigateEvent) {\n      this.abortOngoingNavigation(this.navigateEvent, new DOMException('Navigation superseded by a new navigation.', 'AbortError'));\n    }\n    const dispatchResultIsTrueIfNoInterception = dispatchNavigateEvent({\n      navigationType: options.navigationType,\n      cancelable: options.cancelable,\n      canIntercept: options.canIntercept,\n      userInitiated: options.userInitiated,\n      hashChange: options.hashChange,\n      destination,\n      info: options.info,\n      sameDocument: destination.sameDocument,\n      result\n    });\n    return !dispatchResultIsTrueIfNoInterception;\n  }\n  urlAndHistoryUpdateSteps(navigateEvent) {\n    this.updateNavigationEntriesForSameDocumentNavigation(navigateEvent);\n  }\n  userAgentTraverse(navigateEvent) {\n    const oldUrl = this.currentEntry.url;\n    this.updateNavigationEntriesForSameDocumentNavigation(navigateEvent);\n    const popStateEvent = createPopStateEvent({\n      state: navigateEvent.destination.getHistoryState()\n    });\n    this._window.dispatchEvent(popStateEvent);\n    if (navigateEvent.hashChange) {\n      const hashchangeEvent = createHashChangeEvent(oldUrl, this.currentEntry.url);\n      this._window.dispatchEvent(hashchangeEvent);\n    }\n  }\n  updateNavigationEntriesForSameDocumentNavigation({\n    destination,\n    navigationType,\n    result\n  }) {\n    const oldCurrentNHE = this.currentEntry;\n    const disposedNHEs = [];\n    if (navigationType === 'traverse') {\n      this.currentEntryIndex = destination.index;\n      if (this.currentEntryIndex === -1) {\n        throw new Error('unexpected current entry index');\n      }\n    } else if (navigationType === 'push') {\n      this.currentEntryIndex++;\n      this.prospectiveEntryIndex = this.currentEntryIndex;\n      disposedNHEs.push(...this.entriesArr.splice(this.currentEntryIndex));\n    } else if (navigationType === 'replace') {\n      disposedNHEs.push(oldCurrentNHE);\n    }\n    if (navigationType === 'push' || navigationType === 'replace') {\n      const index = this.currentEntryIndex;\n      const key = navigationType === 'push' ? String(this.nextKey++) : oldCurrentNHE?.key ?? String(this.nextKey++);\n      const newNHE = new FakeNavigationHistoryEntry(this.eventTarget, destination.url, {\n        id: String(this.nextId++),\n        key,\n        index,\n        sameDocument: true,\n        state: destination.getState(),\n        historyState: destination.getHistoryState()\n      });\n      this.entriesArr[this.currentEntryIndex] = newNHE;\n    }\n    result.committedResolve(this.currentEntry);\n    const currentEntryChangeEvent = createFakeNavigationCurrentEntryChangeEvent({\n      from: oldCurrentNHE,\n      navigationType: navigationType\n    });\n    this.eventTarget.dispatchEvent(currentEntryChangeEvent);\n    for (const disposedNHE of disposedNHEs) {\n      disposedNHE.dispose();\n    }\n  }\n  findEntry(key) {\n    for (const entry of this.entriesArr) {\n      if (entry.key === key) return entry;\n    }\n    return undefined;\n  }\n  set onnavigate(_handler) {\n    throw new Error('unimplemented');\n  }\n  get onnavigate() {\n    throw new Error('unimplemented');\n  }\n  set oncurrententrychange(_handler) {\n    throw new Error('unimplemented');\n  }\n  get oncurrententrychange() {\n    throw new Error('unimplemented');\n  }\n  set onnavigatesuccess(_handler) {\n    throw new Error('unimplemented');\n  }\n  get onnavigatesuccess() {\n    throw new Error('unimplemented');\n  }\n  set onnavigateerror(_handler) {\n    throw new Error('unimplemented');\n  }\n  get onnavigateerror() {\n    throw new Error('unimplemented');\n  }\n  _transition = null;\n  set transition(t) {\n    this._transition = t;\n  }\n  get transition() {\n    return this._transition;\n  }\n  updateCurrentEntry(_options) {\n    throw new Error('unimplemented');\n  }\n  reload(_options) {\n    throw new Error('unimplemented');\n  }\n}\nclass FakeNavigationHistoryEntry {\n  eventTarget;\n  url;\n  sameDocument;\n  id;\n  key;\n  index;\n  state;\n  historyState;\n  ondispose = null;\n  constructor(eventTarget, url, {\n    id,\n    key,\n    index,\n    sameDocument,\n    state,\n    historyState\n  }) {\n    this.eventTarget = eventTarget;\n    this.url = url;\n    this.id = id;\n    this.key = key;\n    this.index = index;\n    this.sameDocument = sameDocument;\n    this.state = state;\n    this.historyState = historyState;\n  }\n  getState() {\n    return this.state ? JSON.parse(JSON.stringify(this.state)) : this.state;\n  }\n  getHistoryState() {\n    return this.historyState ? JSON.parse(JSON.stringify(this.historyState)) : this.historyState;\n  }\n  addEventListener(type, callback, options) {\n    this.eventTarget.addEventListener(type, callback, options);\n  }\n  removeEventListener(type, callback, options) {\n    this.eventTarget.removeEventListener(type, callback, options);\n  }\n  dispatchEvent(event) {\n    return this.eventTarget.dispatchEvent(event);\n  }\n  dispose() {\n    const disposeEvent = new Event('disposed');\n    this.dispatchEvent(disposeEvent);\n    this.eventTarget = null;\n  }\n}\nfunction dispatchNavigateEvent({\n  cancelable,\n  canIntercept,\n  userInitiated,\n  hashChange,\n  navigationType,\n  destination,\n  info,\n  sameDocument,\n  result\n}) {\n  const {\n    navigation\n  } = result;\n  const eventAbortController = new AbortController();\n  const event = new Event('navigate', {\n    bubbles: false,\n    cancelable\n  });\n  event.navigationType = navigationType;\n  event.destination = destination;\n  event.canIntercept = canIntercept;\n  event.userInitiated = userInitiated;\n  event.hashChange = hashChange;\n  event.signal = eventAbortController.signal;\n  event.abortController = eventAbortController;\n  event.info = info;\n  event.focusResetBehavior = null;\n  event.scrollBehavior = null;\n  event.interceptionState = 'none';\n  event.downloadRequest = null;\n  event.formData = null;\n  event.result = result;\n  event.sameDocument = sameDocument;\n  let precommitHandlers = [];\n  let handlers = [];\n  event.intercept = function (options) {\n    if (!this.canIntercept) {\n      throw new DOMException(`Cannot intercept when canIntercept is 'false'`, 'SecurityError');\n    }\n    this.interceptionState = 'intercepted';\n    event.sameDocument = true;\n    const precommitHandler = options?.precommitHandler;\n    if (precommitHandler) {\n      if (!this.cancelable) {\n        throw new DOMException(`Cannot use precommitHandler when cancelable is 'false'`, 'InvalidStateError');\n      }\n      precommitHandlers.push(precommitHandler);\n    }\n    if (event.interceptionState !== 'none' && event.interceptionState !== 'intercepted') {\n      throw new Error('Event interceptionState should be \"none\" or \"intercepted\"');\n    }\n    event.interceptionState = 'intercepted';\n    const handler = options?.handler;\n    if (handler) {\n      handlers.push(handler);\n    }\n    event.focusResetBehavior = options?.focusReset ?? event.focusResetBehavior;\n    event.scrollBehavior = options?.scroll ?? event.scrollBehavior;\n  };\n  event.scroll = function () {\n    if (event.interceptionState !== 'committed') {\n      throw new DOMException(`Failed to execute 'scroll' on 'NavigateEvent': scroll() must be ` + `called after commit() and interception options must specify manual scroll.`, 'InvalidStateError');\n    }\n    processScrollBehavior(event);\n  };\n  function redirect(url, options = {}) {\n    if (event.interceptionState === 'none') {\n      throw new Error('cannot redirect when event is not intercepted');\n    }\n    if (event.interceptionState !== 'intercepted') {\n      throw new DOMException(`cannot redirect when event is not in 'intercepted' state`, 'InvalidStateError');\n    }\n    if (event.navigationType !== 'push' && event.navigationType !== 'replace') {\n      throw new DOMException(`cannot redirect when navigationType is not 'push' or 'replace`, 'InvalidStateError');\n    }\n    const destinationUrl = new URL(url, navigation.currentEntry.url);\n    if (options.history === 'push' || options.history === 'replace') {\n      event.navigationType = options.history;\n    }\n    if (options.hasOwnProperty('state')) {\n      event.destination.state = options.state;\n    }\n    event.destination.url = destinationUrl.href;\n    if (options.hasOwnProperty('info')) {\n      event.info = options.info;\n    }\n  }\n  function processNavigateEventHandlerFailure(reason) {\n    if (event.abortController.signal.aborted) {\n      return;\n    }\n    if (event !== navigation.navigateEvent) {\n      throw new Error('Event is no longer the current navigation event');\n    }\n    if (event.interceptionState !== 'intercepted') {\n      finishNavigationEvent(event, false);\n    }\n    event.abort(reason);\n  }\n  function commit() {\n    if (result.signal.aborted) {\n      return;\n    }\n    if (event.interceptionState !== 'none') {\n      event.interceptionState = 'committed';\n      switch (event.navigationType) {\n        case 'push':\n        case 'replace':\n          {\n            navigation.urlAndHistoryUpdateSteps(event);\n            break;\n          }\n        case 'reload':\n          {\n            navigation.updateNavigationEntriesForSameDocumentNavigation(event);\n            break;\n          }\n        case 'traverse':\n          {\n            navigation.userAgentTraverse(event);\n            break;\n          }\n      }\n    }\n    navigation.transition?.committedResolve();\n    const promisesList = handlers.map(handler => handler());\n    if (promisesList.length === 0) {\n      promisesList.push(Promise.resolve());\n    }\n    Promise.all(promisesList).then(() => {\n      if (result.signal.aborted) {\n        return;\n      }\n      if (event !== navigation.navigateEvent) {\n        if (!result.signal.aborted && result.committedTo) {\n          result.finishedReject(new DOMException('Navigation superseded before handler completion', 'AbortError'));\n        }\n        return;\n      }\n      navigation.navigateEvent = null;\n      finishNavigationEvent(event, true);\n      result.finishedResolve();\n      const navigatesuccessEvent = new Event('navigatesuccess', {\n        bubbles: false,\n        cancelable: false\n      });\n      navigation.eventTarget.dispatchEvent(navigatesuccessEvent);\n      navigation.transition?.finishedResolve();\n      navigation.transition = null;\n    }).catch(processNavigateEventHandlerFailure);\n  }\n  event.abort = function (reason) {\n    this.abortController.abort(reason);\n    navigation.navigateEvent = null;\n    result.finishedReject(reason);\n    const navigateerrorEvent = new Event('navigateerror', {\n      bubbles: false,\n      cancelable\n    });\n    navigateerrorEvent.error = reason;\n    navigation.eventTarget.dispatchEvent(navigateerrorEvent);\n    const transition = navigation.transition;\n    transition?.committedReject(reason);\n    transition?.finishedReject(reason);\n    navigation.transition = null;\n  };\n  function dispatch() {\n    navigation.navigateEvent = event;\n    const dispatchResult = navigation.eventTarget.dispatchEvent(event);\n    if (event.interceptionState === 'intercepted') {\n      if (!navigation.currentEntry) {\n        event.abort(new DOMException('Cannot create transition without a currentEntry for intercepted navigation.', 'InvalidStateError'));\n        return;\n      }\n      const transition = new InternalNavigationTransition(navigation.currentEntry, navigationType);\n      navigation.transition = transition;\n      transition.finished.catch(() => {});\n      transition.committed.catch(() => {});\n    }\n    if (!dispatchResult && event.cancelable) {\n      if (!event.abortController.signal.aborted) {\n        event.abort(new DOMException('Navigation prevented by event.preventDefault()', 'AbortError'));\n      }\n    } else {\n      if (precommitHandlers.length === 0) {\n        commit();\n      } else {\n        const precommitController = {\n          redirect\n        };\n        const precommitPromisesList = precommitHandlers.map(handler => {\n          let p;\n          try {\n            p = handler(precommitController);\n          } catch (e) {\n            p = Promise.reject(e);\n          }\n          p.catch(() => {});\n          return p;\n        });\n        Promise.all(precommitPromisesList).then(() => commit()).catch(processNavigateEventHandlerFailure);\n      }\n    }\n  }\n  dispatch();\n  return event.interceptionState === 'none';\n}\nfunction finishNavigationEvent(event, didFulfill) {\n  if (event.interceptionState === 'finished') {\n    throw new Error('Attempting to finish navigation event that was already finished');\n  }\n  if (event.interceptionState === 'intercepted') {\n    if (didFulfill === true) {\n      throw new Error('didFulfill should be false');\n    }\n    event.interceptionState = 'finished';\n    return;\n  }\n  if (event.interceptionState === 'none') {\n    return;\n  }\n  potentiallyResetFocus(event);\n  if (didFulfill) {\n    potentiallyResetScroll(event);\n  }\n  event.interceptionState = 'finished';\n}\nfunction potentiallyResetFocus(event) {\n  if (event.interceptionState !== 'committed' && event.interceptionState !== 'scrolled') {\n    throw new Error('cannot reset focus if navigation event is not committed or scrolled');\n  }\n  if (event.focusResetBehavior === 'manual') {\n    return;\n  }\n}\nfunction potentiallyResetScroll(event) {\n  if (event.interceptionState !== 'committed' && event.interceptionState !== 'scrolled') {\n    throw new Error('cannot reset scroll if navigation event is not committed or scrolled');\n  }\n  if (event.interceptionState === 'scrolled' || event.scrollBehavior === 'manual') {\n    return;\n  }\n  processScrollBehavior(event);\n}\nfunction processScrollBehavior(event) {\n  if (event.interceptionState !== 'committed') {\n    throw new Error('invalid event interception state when processing scroll behavior');\n  }\n  event.interceptionState = 'scrolled';\n}\nfunction createFakeNavigationCurrentEntryChangeEvent({\n  from,\n  navigationType\n}) {\n  const event = new Event('currententrychange', {\n    bubbles: false,\n    cancelable: false\n  });\n  event.from = from;\n  event.navigationType = navigationType;\n  return event;\n}\nfunction createPopStateEvent({\n  state\n}) {\n  const event = new Event('popstate', {\n    bubbles: false,\n    cancelable: false\n  });\n  event.state = state;\n  return event;\n}\nfunction createHashChangeEvent(newURL, oldURL) {\n  const event = new Event('hashchange', {\n    bubbles: false,\n    cancelable: false\n  });\n  event.newURL = newURL;\n  event.oldURL = oldURL;\n  return event;\n}\nclass FakeNavigationDestination {\n  url;\n  sameDocument;\n  key;\n  id;\n  index;\n  state;\n  historyState;\n  constructor({\n    url,\n    sameDocument,\n    historyState,\n    state,\n    key = null,\n    id = null,\n    index = -1\n  }) {\n    this.url = url;\n    this.sameDocument = sameDocument;\n    this.state = state;\n    this.historyState = historyState;\n    this.key = key;\n    this.id = id;\n    this.index = index;\n  }\n  getState() {\n    return this.state;\n  }\n  getHistoryState() {\n    return this.historyState;\n  }\n}\nfunction isHashChange(from, to) {\n  return to.hash !== from.hash && to.hostname === from.hostname && to.pathname === from.pathname && to.search === from.search;\n}\nclass InternalNavigationTransition {\n  from;\n  navigationType;\n  finished;\n  committed;\n  finishedResolve;\n  finishedReject;\n  committedResolve;\n  committedReject;\n  constructor(from, navigationType) {\n    this.from = from;\n    this.navigationType = navigationType;\n    this.finished = new Promise((resolve, reject) => {\n      this.finishedReject = reject;\n      this.finishedResolve = resolve;\n    });\n    this.committed = new Promise((resolve, reject) => {\n      this.committedReject = reject;\n      this.committedResolve = resolve;\n    });\n    this.finished.catch(() => {});\n    this.committed.catch(() => {});\n  }\n}\nclass InternalNavigationResult {\n  navigation;\n  committedTo = null;\n  committedResolve;\n  committedReject;\n  finishedResolve;\n  finishedReject;\n  committed;\n  finished;\n  get signal() {\n    return this.abortController.signal;\n  }\n  abortController = new AbortController();\n  constructor(navigation) {\n    this.navigation = navigation;\n    this.committed = new Promise((resolve, reject) => {\n      this.committedResolve = entry => {\n        this.committedTo = entry;\n        resolve(entry);\n      };\n      this.committedReject = reject;\n    });\n    this.finished = new Promise((resolve, reject) => {\n      this.finishedResolve = () => {\n        if (this.committedTo === null) {\n          throw new Error('NavigateEvent should have been committed before resolving finished promise.');\n        }\n        resolve(this.committedTo);\n      };\n      this.finishedReject = reason => {\n        this.committedReject(reason);\n        reject(reason);\n      };\n    });\n    this.committed.catch(() => {});\n    this.finished.catch(() => {});\n  }\n}\nglobalThis.beforeEach?.(getCleanupHook(false));\nglobalThis.afterEach?.(getCleanupHook(true));\nfunction getCleanupHook(expectedTeardownValue) {\n  return () => {\n    const testBed = TestBedImpl.INSTANCE;\n    if (testBed.shouldTearDownTestingModule() === expectedTeardownValue) {\n      testBed.resetTestingModule();\n      resetFakeAsyncZoneIfExists();\n    }\n  };\n}\nclass Log {\n  logItems;\n  constructor() {\n    this.logItems = [];\n  }\n  add(value) {\n    this.logItems.push(value);\n  }\n  fn(value) {\n    return () => {\n      this.logItems.push(value);\n    };\n  }\n  clear() {\n    this.logItems = [];\n  }\n  result() {\n    return this.logItems.join('; ');\n  }\n  static ɵfac = function Log_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || Log)();\n  };\n  static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: Log,\n    factory: Log.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Log, [{\n    type: Injectable\n  }], () => [], null);\n})();\nexport { ComponentFixture, ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, DeferBlockBehavior, DeferBlockFixture, DeferBlockState, InjectSetupWrapper, TestBed, TestComponentRenderer, discardPeriodicTasks, fakeAsync, flush, flushMicrotasks, getTestBed, inject, resetFakeAsyncZone, tick, waitForAsync, withModule, FakeNavigation as ɵFakeNavigation, Log as ɵLog, MetadataOverrider as ɵMetadataOverrider, getCleanupHook as ɵgetCleanupHook };","map":{"version":3,"names":["i0","Injectable","DeferBlockState","triggerResourceLoading","renderDeferBlockState","getDeferBlocks","DeferBlockBehavior","ApplicationRef","getDebugNode","RendererFactory2","Directive","Component","Pipe","NgModule","ReflectionCapabilities","depsTracker","isComponentDefPendingResolution","resolveComponentResources","NgModuleRef","ApplicationInitStatus","LOCALE_ID","DEFAULT_LOCALE_ID","setLocaleId","ComponentFactory","getAsyncClassMetadataFn","compileComponent","compileDirective","compilePipe","patchComponentDefWithScope","compileNgModuleDefs","clearResolutionOfComponentResourcesQueue","restoreComponentResolutionQueue","provideZonelessChangeDetectionInternal","COMPILER_OPTIONS","generateStandaloneInDeclarationsError","transitiveScopesFor","Compiler","DEFER_BLOCK_CONFIG","ANIMATIONS_DISABLED","NgModuleFactory","ModuleWithComponentFactories","resetCompiledComponents","ɵsetUnknownElementStrictMode","_setUnknownElementStrictMode","ɵsetUnknownPropertyStrictMode","_setUnknownPropertyStrictMode","ɵgetUnknownElementStrictMode","_getUnknownElementStrictMode","ɵgetUnknownPropertyStrictMode","_getUnknownPropertyStrictMode","inferTagNameFromDefinition","flushModuleScopingQueueAsMuchAsPossible","setAllowDuplicateNgModuleIdsForTest","Subscription","inject","inject$1","NgZone","EnvironmentInjector","ErrorHandler","CONTAINER_HEADER_OFFSET","InjectionToken","NoopNgZone","PendingTasksInternal","ZONELESS_ENABLED","ChangeDetectionScheduler","EffectScheduler","stringify","getInjectableDef","resolveForwardRef","NG_COMP_DEF","NG_DIR_DEF","NG_PIPE_DEF","NG_INJ_DEF","NG_MOD_DEF","ENVIRONMENT_INITIALIZER","Injector","isEnvironmentProviders","INTERNAL_APPLICATION_ERROR_HANDLER","runInInjectionContext","getComponentDef","getComponentDef$1","ResourceLoader","waitForAsync","fn","_Zone","Zone","Promise","reject","asyncTest","__symbol__","RETHROW_APPLICATION_ERRORS_DEFAULT","TestBedApplicationErrorHandler","zone","injector","userErrorHandler","whenStableRejectFunctions","Set","handleError","e","runOutsideAngular","get","userError","size","values","clear","ɵfac","TestBedApplicationErrorHandler_Factory","__ngFactoryType__","ɵprov","ɵɵdefineInjectable","token","factory","ngDevMode","ɵsetClassMetadata","type","DeferBlockFixture","block","componentFixture","constructor","render","state","_this","_asyncToGenerator","hasStateTemplate","stateAsString","getDeferBlockStateNameFromEnum","Error","toLowerCase","Complete","tDetails","lView","tNode","skipTimerScheduling","lContainer","detectChanges","deferBlocks","deferBlockFixtures","length","push","resolve","Placeholder","placeholderTmplIndex","Loading","loadingTmplIndex","errorTmplIndex","TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT","THROW_ON_UNKNOWN_ELEMENTS_DEFAULT","THROW_ON_UNKNOWN_PROPERTIES_DEFAULT","DEFER_BLOCK_DEFAULT_BEHAVIOR","Playthrough","ANIMATIONS_ENABLED_DEFAULT","TestComponentRenderer","insertRootElement","rootElementId","tagName","removeAllRootElements","ComponentFixtureAutoDetect","ComponentFixtureNoNgZone","ComponentFixture","componentRef","debugElement","componentInstance","nativeElement","elementRef","changeDetectorRef","_renderer","_isDestroyed","_noZoneOptionIsSet","optional","_ngZone","_appRef","_testAppRef","pendingTasks","appErrorHandler","zonelessEnabled","scheduler","rootEffectScheduler","autoDetectDefault","autoDetect","subscriptions","ngZone","location","instance","allTestViews","add","hostView","autoDetectTestViews","notify","onDestroy","delete","onError","subscribe","next","error","current","checkNoChanges","originalCheckNoChanges","includeAllTestViews","tick","run","flush","autoDetectChanges","isStable","hasPendingTasks","whenStable","then","_getRenderer","undefined","whenRenderingDone","renderer","destroy","unsubscribe","getFakeAsyncTestModule","withFakeAsyncTestModule","fakeAsyncTestModule","resetFakeAsyncZone","v","resetFakeAsyncZoneIfExists","isLoaded","fakeAsync","options","millis","tickOptions","processNewMacroTasksSynchronously","m","maxTurns","discardPeriodicTasks","flushMicrotasks","_nextReferenceId","MetadataOverrider","_references","Map","overrideMetadata","metadataClass","oldMetadata","override","props","_valueProps","forEach","prop","set","remove","setMetadata","removeMetadata","addMetadata","metadata","references","removeObjects","removeValue","Array","isArray","value","_propHashKey","propValue","filter","has","addValue","concat","propName","nextObjectId","objectIds","replacer","key","_serializeReference","JSON","ref","id","obj","Object","keys","startsWith","proto","getPrototypeOf","protoProp","desc","getOwnPropertyDescriptor","reflection","OverrideResolver","overrides","resolved","addOverride","setOverrides","getAnnotation","annotations","i","annotation","isKnownType","overrider","DirectiveResolver","ComponentResolver","PipeResolver","NgModuleResolver","TestingModuleOverride","isTestingModuleOverride","DECLARATION","OVERRIDE_TEMPLATE","assertNoStandaloneComponents","types","resolver","component","standalone","TestBedCompiler","platform","additionalModuleTypes","originalComponentResolutionQueue","declarations","imports","providers","schemas","pendingComponents","pendingDirectives","pendingPipes","componentsWithAsyncMetadata","seenComponents","seenDirectives","overriddenModules","existingComponentStyles","resolvers","initResolvers","componentToModuleScope","initialNgDefs","defCleanupOps","_injector","compilerProviders","providerOverrides","rootProviderOverrides","providerOverridesByModule","providerOverridesByToken","scopesWithOverriddenProviders","testModuleType","testModuleRef","animationsEnabled","deferBlockBehavior","rethrowApplicationTickErrors","DynamicTestModule","setCompilerProviders","configureTestingModule","moduleDef","queueTypeArray","queueTypesFromModulesArray","rethrowApplicationErrors","overrideModule","ngModule","clearScopeCacheFor","module","invalidTypeError","name","recompileNgModule","overrideComponent","verifyNoStandaloneFlagOverrides","maybeRegisterComponentWithAsyncMetadata","overrideDirective","directive","overridePipe","pipe","hasOwnProperty","overrideProvider","provider","providerDef","useFactory","provide","deps","multi","useValue","injectableDef","providedIn","overridesBucket","existingOverrides","overrideTemplateUsingTestingModule","template","def","hasStyleUrls","styleUrl","styleUrls","overrideStyleUrls","styles","resolvePendingComponentsWithAsyncMetadata","_this2","promises","asyncMetadataFn","resolvedDeps","all","flatResolvedDeps","flat","applyProviderOverridesInScope","compileComponents","_this3","clearComponentResolutionQueue","needsAsyncResources","compileTypesSync","resourceLoader","url","finalize","compileTestModule","applyTransitiveScopes","applyProviderOverrides","patchComponentsWithExistingStyles","parentInjector","runInitializers","localeId","_compileNgModuleSync","moduleType","_compileNgModuleAsync","_this4","_getModuleResolver","_getComponentFactories","maybeUnwrapFn","ɵmod","reduce","factories","declaration","componentDef","ɵcmp","maybeStoreNgDef","testingModuleDef","affectedModules","collectModulesAffectedByOverrides","moduleToScope","getScopeOfModule","isTestingModule","realType","componentType","moduleScope","storeFieldOfDefOnType","maybeApplyOverrides","field","hasProviderOverrides","patchDefWithProviderOverrides","hasScope","isStandaloneComponent","isNgModule","injectorDef","dependencies","dependency","getOverriddenProviders","importedModule","flatten","isModuleWithProviders","object","fieldName","originalValue","arr","queueType","processedDefs","queueTypesFromModulesArrayRecur","hasNgModuleDef","exports","seenModules","calcAffectedModulesRecur","path","item","currentDefs","currentDef","defField","restoreOriginalState","forEachRight","op","defs","descriptor","defineProperty","RootScopeModule","R3TestCompiler","behavior","handler","compilerOptions","opts","create","parent","getSingleProviderOverrides","getProviderToken","getProviderOverrides","flattenProviders","flattenedProviders","overriddenProviders","final","seenOverriddenProviders","unshift","providersResolver","processProvidersFn","ngDef","maybeFn","Function","out","identityFn","mapFn","ɵproviders","getProviderField","idx","expectedType","testBed","compileModuleSync","compileModuleAsync","_this5","compileModuleAndAllComponentsSync","ngModuleFactory","componentFactories","compileModuleAndAllComponentsAsync","_this6","clearCache","clearCacheFor","getModuleId","meta","_nextRootElementId","getTestBed","TestBedImpl","INSTANCE","_INSTANCE","_environmentTeardownOptions","_environmentErrorOnUnknownElementsOption","_environmentErrorOnUnknownPropertiesOption","_instanceTeardownOptions","_instanceDeferBlockBehavior","_instanceAnimationsEnabled","_instanceErrorOnUnknownElementsOption","_instanceErrorOnUnknownPropertiesOption","_previousErrorOnUnknownElementsOption","_previousErrorOnUnknownPropertiesOption","_instanceInferTagName","initTestEnvironment","resetTestEnvironment","configureCompiler","config","overrideTemplate","notFoundValue","createComponent","resetTestingModule","execute","tokens","context","flushEffects","_compiler","_testModuleRef","_activeFixtures","globalCompilationChecked","teardown","errorOnUnknownElements","errorOnUnknownProperties","checkGlobalCompilationFinished","compiler","destroyActiveFixtures","shouldTearDownTestingModule","tearDownTestingModule","useJit","assertNotInstantiated","inferTagName","shouldThrowErrorOnUnknownElements","shouldThrowErrorOnUnknownProperties","TestBed","UNDEFINED","result","params","map","t","apply","templateUrl","testComponentRenderer","shouldInferTagName","rootElId","componentFactory","initComponent","NULL","bindings","noNgZone","fixture","methodName","methodDescription","errorCount","console","stacktrace","shouldRethrowTeardownErrors","instanceOptions","environmentOptions","rethrowErrors","destroyAfterEach","getDeferBlockBehavior","getAnimationsEnabled","testRenderer","appRef","InjectSetupWrapper","_moduleDef","_addModule","self","call","withModule","FakeNavigation","entriesArr","currentEntryIndex","navigateEvent","traversalQueue","nextTraversal","prospectiveEntryIndex","synchronousTraversals","canSetInitialEntry","eventTarget","nextId","nextKey","disposed","currentEntry","canGoBack","canGoForward","createEventTarget","_window","window","doc","startURL","createElement","EventTarget","document","defaultView","setInitialEntryForTesting","historyState","currentInitialEntry","FakeNavigationHistoryEntry","URL","toString","index","String","sameDocument","canSetInitialEntryForTesting","setSynchronousTraversalsForTesting","entries","slice","navigate","fromUrl","toUrl","navigationType","history","hashChange","isHashChange","destination","FakeNavigationDestination","InternalNavigationResult","intercepted","userAgentNavigate","cancelable","canIntercept","userInitiated","info","updateNavigationEntriesForSameDocumentNavigation","committed","finished","pushState","data","title","pushOrReplaceState","replaceState","_title","traverseTo","entry","findEntry","domException","DOMException","catch","existingResult","getState","getHistoryState","runTraversal","userAgentTraverse","back","forward","go","direction","targetIndex","traversal","setTimeout","addEventListener","callback","removeEventListener","dispatchEvent","event","dispose","isDisposed","abortOngoingNavigation","eventToAbort","reason","abortController","signal","aborted","abortReason","abort","dispatchResultIsTrueIfNoInterception","dispatchNavigateEvent","urlAndHistoryUpdateSteps","oldUrl","popStateEvent","createPopStateEvent","hashchangeEvent","createHashChangeEvent","oldCurrentNHE","disposedNHEs","splice","newNHE","committedResolve","currentEntryChangeEvent","createFakeNavigationCurrentEntryChangeEvent","from","disposedNHE","onnavigate","_handler","oncurrententrychange","onnavigatesuccess","onnavigateerror","_transition","transition","updateCurrentEntry","_options","reload","ondispose","parse","disposeEvent","Event","navigation","eventAbortController","AbortController","bubbles","focusResetBehavior","scrollBehavior","interceptionState","downloadRequest","formData","precommitHandlers","handlers","intercept","precommitHandler","focusReset","scroll","processScrollBehavior","redirect","destinationUrl","href","processNavigateEventHandlerFailure","finishNavigationEvent","commit","promisesList","committedTo","finishedReject","finishedResolve","navigatesuccessEvent","navigateerrorEvent","committedReject","dispatch","dispatchResult","InternalNavigationTransition","precommitController","precommitPromisesList","p","didFulfill","potentiallyResetFocus","potentiallyResetScroll","newURL","oldURL","to","hash","hostname","pathname","search","globalThis","beforeEach","getCleanupHook","afterEach","expectedTeardownValue","Log","logItems","join","Log_Factory","ɵFakeNavigation","ɵLog","ɵMetadataOverrider","ɵgetCleanupHook"],"sources":["C:/Users/juanj/Desktop/juan_website/website2/my-website/node_modules/@angular/core/fesm2022/testing.mjs"],"sourcesContent":["/**\n * @license Angular v21.0.0\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport * as i0 from '@angular/core';\nimport { Injectable, DeferBlockState, triggerResourceLoading, renderDeferBlockState, getDeferBlocks, DeferBlockBehavior, ApplicationRef, getDebugNode, RendererFactory2, Directive, Component, Pipe, NgModule, ReflectionCapabilities, depsTracker, isComponentDefPendingResolution, resolveComponentResources, NgModuleRef, ApplicationInitStatus, LOCALE_ID, DEFAULT_LOCALE_ID, setLocaleId, ComponentFactory, getAsyncClassMetadataFn, compileComponent, compileDirective, compilePipe, patchComponentDefWithScope, compileNgModuleDefs, clearResolutionOfComponentResourcesQueue, restoreComponentResolutionQueue, provideZonelessChangeDetectionInternal, COMPILER_OPTIONS, generateStandaloneInDeclarationsError, transitiveScopesFor, Compiler, DEFER_BLOCK_CONFIG, ANIMATIONS_DISABLED, NgModuleFactory, ModuleWithComponentFactories, resetCompiledComponents, ɵsetUnknownElementStrictMode as _setUnknownElementStrictMode, ɵsetUnknownPropertyStrictMode as _setUnknownPropertyStrictMode, ɵgetUnknownElementStrictMode as _getUnknownElementStrictMode, ɵgetUnknownPropertyStrictMode as _getUnknownPropertyStrictMode, inferTagNameFromDefinition, flushModuleScopingQueueAsMuchAsPossible, setAllowDuplicateNgModuleIdsForTest } from './_debug_node-chunk.mjs';\nimport { Subscription } from 'rxjs';\nimport { inject as inject$1, NgZone, EnvironmentInjector, ErrorHandler, CONTAINER_HEADER_OFFSET, InjectionToken, NoopNgZone, PendingTasksInternal, ZONELESS_ENABLED, ChangeDetectionScheduler, EffectScheduler, stringify, getInjectableDef, resolveForwardRef, NG_COMP_DEF, NG_DIR_DEF, NG_PIPE_DEF, NG_INJ_DEF, NG_MOD_DEF, ENVIRONMENT_INITIALIZER, Injector, isEnvironmentProviders, INTERNAL_APPLICATION_ERROR_HANDLER, runInInjectionContext, getComponentDef as getComponentDef$1 } from './_untracked-chunk.mjs';\nimport { ResourceLoader } from '@angular/compiler';\nimport './_effect-chunk.mjs';\nimport '@angular/core/primitives/signals';\nimport 'rxjs/operators';\nimport './_attribute-chunk.mjs';\nimport './_not_found-chunk.mjs';\nimport '@angular/core/primitives/di';\n\nfunction waitForAsync(fn) {\n  const _Zone = typeof Zone !== 'undefined' ? Zone : null;\n  if (!_Zone) {\n    return function () {\n      return Promise.reject('Zone is needed for the waitForAsync() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js');\n    };\n  }\n  const asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n  if (typeof asyncTest === 'function') {\n    return asyncTest(fn);\n  }\n  return function () {\n    return Promise.reject('zone-testing.js is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/testing');\n  };\n}\n\nconst RETHROW_APPLICATION_ERRORS_DEFAULT = true;\nclass TestBedApplicationErrorHandler {\n  zone = inject$1(NgZone);\n  injector = inject$1(EnvironmentInjector);\n  userErrorHandler;\n  whenStableRejectFunctions = new Set();\n  handleError(e) {\n    try {\n      this.zone.runOutsideAngular(() => {\n        this.userErrorHandler ??= this.injector.get(ErrorHandler);\n        this.userErrorHandler.handleError(e);\n      });\n    } catch (userError) {\n      e = userError;\n    }\n    if (this.whenStableRejectFunctions.size > 0) {\n      for (const fn of this.whenStableRejectFunctions.values()) {\n        fn(e);\n      }\n      this.whenStableRejectFunctions.clear();\n    } else {\n      throw e;\n    }\n  }\n  static ɵfac = function TestBedApplicationErrorHandler_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TestBedApplicationErrorHandler)();\n  };\n  static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: TestBedApplicationErrorHandler,\n    factory: TestBedApplicationErrorHandler.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TestBedApplicationErrorHandler, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass DeferBlockFixture {\n  block;\n  componentFixture;\n  constructor(block, componentFixture) {\n    this.block = block;\n    this.componentFixture = componentFixture;\n  }\n  async render(state) {\n    if (!hasStateTemplate(state, this.block)) {\n      const stateAsString = getDeferBlockStateNameFromEnum(state);\n      throw new Error(`Tried to render this defer block in the \\`${stateAsString}\\` state, ` + `but there was no @${stateAsString.toLowerCase()} block defined in a template.`);\n    }\n    if (state === DeferBlockState.Complete) {\n      await triggerResourceLoading(this.block.tDetails, this.block.lView, this.block.tNode);\n    }\n    const skipTimerScheduling = true;\n    renderDeferBlockState(state, this.block.tNode, this.block.lContainer, skipTimerScheduling);\n    this.componentFixture.detectChanges();\n  }\n  getDeferBlocks() {\n    const deferBlocks = [];\n    const deferBlockFixtures = [];\n    if (this.block.lContainer.length >= CONTAINER_HEADER_OFFSET) {\n      const lView = this.block.lContainer[CONTAINER_HEADER_OFFSET];\n      getDeferBlocks(lView, deferBlocks);\n      for (const block of deferBlocks) {\n        deferBlockFixtures.push(new DeferBlockFixture(block, this.componentFixture));\n      }\n    }\n    return Promise.resolve(deferBlockFixtures);\n  }\n}\nfunction hasStateTemplate(state, block) {\n  switch (state) {\n    case DeferBlockState.Placeholder:\n      return block.tDetails.placeholderTmplIndex !== null;\n    case DeferBlockState.Loading:\n      return block.tDetails.loadingTmplIndex !== null;\n    case DeferBlockState.Error:\n      return block.tDetails.errorTmplIndex !== null;\n    case DeferBlockState.Complete:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction getDeferBlockStateNameFromEnum(state) {\n  switch (state) {\n    case DeferBlockState.Placeholder:\n      return 'Placeholder';\n    case DeferBlockState.Loading:\n      return 'Loading';\n    case DeferBlockState.Error:\n      return 'Error';\n    default:\n      return 'Main';\n  }\n}\n\nconst TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT = true;\nconst THROW_ON_UNKNOWN_ELEMENTS_DEFAULT = false;\nconst THROW_ON_UNKNOWN_PROPERTIES_DEFAULT = false;\nconst DEFER_BLOCK_DEFAULT_BEHAVIOR = DeferBlockBehavior.Playthrough;\nconst ANIMATIONS_ENABLED_DEFAULT = false;\nclass TestComponentRenderer {\n  insertRootElement(rootElementId, tagName) {}\n  removeAllRootElements() {}\n}\nconst ComponentFixtureAutoDetect = new InjectionToken('ComponentFixtureAutoDetect');\nconst ComponentFixtureNoNgZone = new InjectionToken('ComponentFixtureNoNgZone');\n\nclass ComponentFixture {\n  componentRef;\n  debugElement;\n  componentInstance;\n  nativeElement;\n  elementRef;\n  changeDetectorRef;\n  _renderer;\n  _isDestroyed = false;\n  _noZoneOptionIsSet = inject$1(ComponentFixtureNoNgZone, {\n    optional: true\n  });\n  _ngZone = this._noZoneOptionIsSet ? new NoopNgZone() : inject$1(NgZone);\n  _appRef = inject$1(ApplicationRef);\n  _testAppRef = this._appRef;\n  pendingTasks = inject$1(PendingTasksInternal);\n  appErrorHandler = inject$1(TestBedApplicationErrorHandler);\n  zonelessEnabled = inject$1(ZONELESS_ENABLED);\n  scheduler = inject$1(ChangeDetectionScheduler);\n  rootEffectScheduler = inject$1(EffectScheduler);\n  autoDetectDefault = this.zonelessEnabled ? true : false;\n  autoDetect = inject$1(ComponentFixtureAutoDetect, {\n    optional: true\n  }) ?? this.autoDetectDefault;\n  subscriptions = new Subscription();\n  ngZone = this._noZoneOptionIsSet ? null : this._ngZone;\n  constructor(componentRef) {\n    this.componentRef = componentRef;\n    this.changeDetectorRef = componentRef.changeDetectorRef;\n    this.elementRef = componentRef.location;\n    this.debugElement = getDebugNode(this.elementRef.nativeElement);\n    this.componentInstance = componentRef.instance;\n    this.nativeElement = this.elementRef.nativeElement;\n    this.componentRef = componentRef;\n    this._testAppRef.allTestViews.add(this.componentRef.hostView);\n    if (this.autoDetect) {\n      this._testAppRef.autoDetectTestViews.add(this.componentRef.hostView);\n      this.scheduler?.notify(8);\n      this.scheduler?.notify(0);\n    }\n    this.componentRef.hostView.onDestroy(() => {\n      this._testAppRef.allTestViews.delete(this.componentRef.hostView);\n      this._testAppRef.autoDetectTestViews.delete(this.componentRef.hostView);\n    });\n    this._ngZone.runOutsideAngular(() => {\n      this.subscriptions.add(this._ngZone.onError.subscribe({\n        next: error => {\n          if (typeof Zone === 'undefined' || Zone.current.get('FakeAsyncTestZoneSpec')) {\n            return;\n          }\n          throw error;\n        }\n      }));\n    });\n  }\n  detectChanges(checkNoChanges = true) {\n    const originalCheckNoChanges = this.componentRef.changeDetectorRef.checkNoChanges;\n    try {\n      if (!checkNoChanges) {\n        this.componentRef.changeDetectorRef.checkNoChanges = () => {};\n      }\n      if (this.zonelessEnabled) {\n        try {\n          this._testAppRef.includeAllTestViews = true;\n          this._appRef.tick();\n        } finally {\n          this._testAppRef.includeAllTestViews = false;\n        }\n      } else {\n        this._ngZone.run(() => {\n          this.rootEffectScheduler.flush();\n          this.changeDetectorRef.detectChanges();\n          this.checkNoChanges();\n        });\n      }\n    } finally {\n      this.componentRef.changeDetectorRef.checkNoChanges = originalCheckNoChanges;\n    }\n  }\n  checkNoChanges() {\n    this.changeDetectorRef.checkNoChanges();\n  }\n  autoDetectChanges(autoDetect = true) {\n    if (!autoDetect && this.zonelessEnabled) {\n      throw new Error('Cannot set autoDetect to false with zoneless change detection.');\n    }\n    if (this._noZoneOptionIsSet && !this.zonelessEnabled) {\n      throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set.');\n    }\n    if (autoDetect) {\n      this._testAppRef.autoDetectTestViews.add(this.componentRef.hostView);\n    } else {\n      this._testAppRef.autoDetectTestViews.delete(this.componentRef.hostView);\n    }\n    this.autoDetect = autoDetect;\n    this.detectChanges();\n  }\n  isStable() {\n    return !this.pendingTasks.hasPendingTasks;\n  }\n  whenStable() {\n    if (this.isStable()) {\n      return Promise.resolve(false);\n    }\n    return new Promise((resolve, reject) => {\n      this.appErrorHandler.whenStableRejectFunctions.add(reject);\n      this._appRef.whenStable().then(() => {\n        this.appErrorHandler.whenStableRejectFunctions.delete(reject);\n        resolve(true);\n      });\n    });\n  }\n  getDeferBlocks() {\n    const deferBlocks = [];\n    const lView = this.componentRef.hostView['_lView'];\n    getDeferBlocks(lView, deferBlocks);\n    const deferBlockFixtures = [];\n    for (const block of deferBlocks) {\n      deferBlockFixtures.push(new DeferBlockFixture(block, this));\n    }\n    return Promise.resolve(deferBlockFixtures);\n  }\n  _getRenderer() {\n    if (this._renderer === undefined) {\n      this._renderer = this.componentRef.injector.get(RendererFactory2, null);\n    }\n    return this._renderer;\n  }\n  whenRenderingDone() {\n    const renderer = this._getRenderer();\n    if (renderer && renderer.whenRenderingDone) {\n      return renderer.whenRenderingDone();\n    }\n    return this.whenStable();\n  }\n  destroy() {\n    this.subscriptions.unsubscribe();\n    this._testAppRef.autoDetectTestViews.delete(this.componentRef.hostView);\n    this._testAppRef.allTestViews.delete(this.componentRef.hostView);\n    if (!this._isDestroyed) {\n      this.componentRef.destroy();\n      this._isDestroyed = true;\n    }\n  }\n}\n\nconst _Zone = typeof Zone !== 'undefined' ? Zone : null;\nfunction getFakeAsyncTestModule() {\n  return _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\n}\nfunction withFakeAsyncTestModule(fn) {\n  const fakeAsyncTestModule = getFakeAsyncTestModule();\n  if (!fakeAsyncTestModule) {\n    throw new Error(`zone-testing.js is needed for the fakeAsync() test helper but could not be found.\n        Please make sure that your environment includes zone.js/testing`);\n  }\n  return fn(fakeAsyncTestModule);\n}\nfunction resetFakeAsyncZone() {\n  withFakeAsyncTestModule(v => v.resetFakeAsyncZone());\n}\nfunction resetFakeAsyncZoneIfExists() {\n  if (getFakeAsyncTestModule() && Zone['ProxyZoneSpec']?.isLoaded()) {\n    getFakeAsyncTestModule().resetFakeAsyncZone();\n  }\n}\nfunction fakeAsync(fn, options) {\n  return withFakeAsyncTestModule(v => v.fakeAsync(fn, options));\n}\nfunction tick(millis = 0, tickOptions = {\n  processNewMacroTasksSynchronously: true\n}) {\n  return withFakeAsyncTestModule(m => m.tick(millis, tickOptions));\n}\nfunction flush(maxTurns) {\n  return withFakeAsyncTestModule(m => m.flush(maxTurns));\n}\nfunction discardPeriodicTasks() {\n  return withFakeAsyncTestModule(m => m.discardPeriodicTasks());\n}\nfunction flushMicrotasks() {\n  return withFakeAsyncTestModule(m => m.flushMicrotasks());\n}\n\nlet _nextReferenceId = 0;\nclass MetadataOverrider {\n  _references = new Map();\n  overrideMetadata(metadataClass, oldMetadata, override) {\n    const props = {};\n    if (oldMetadata) {\n      _valueProps(oldMetadata).forEach(prop => props[prop] = oldMetadata[prop]);\n    }\n    if (override.set) {\n      if (override.remove || override.add) {\n        throw new Error(`Cannot set and add/remove ${stringify(metadataClass)} at the same time!`);\n      }\n      setMetadata(props, override.set);\n    }\n    if (override.remove) {\n      removeMetadata(props, override.remove, this._references);\n    }\n    if (override.add) {\n      addMetadata(props, override.add);\n    }\n    return new metadataClass(props);\n  }\n}\nfunction removeMetadata(metadata, remove, references) {\n  const removeObjects = new Set();\n  for (const prop in remove) {\n    const removeValue = remove[prop];\n    if (Array.isArray(removeValue)) {\n      removeValue.forEach(value => {\n        removeObjects.add(_propHashKey(prop, value, references));\n      });\n    } else {\n      removeObjects.add(_propHashKey(prop, removeValue, references));\n    }\n  }\n  for (const prop in metadata) {\n    const propValue = metadata[prop];\n    if (Array.isArray(propValue)) {\n      metadata[prop] = propValue.filter(value => !removeObjects.has(_propHashKey(prop, value, references)));\n    } else {\n      if (removeObjects.has(_propHashKey(prop, propValue, references))) {\n        metadata[prop] = undefined;\n      }\n    }\n  }\n}\nfunction addMetadata(metadata, add) {\n  for (const prop in add) {\n    const addValue = add[prop];\n    const propValue = metadata[prop];\n    if (propValue != null && Array.isArray(propValue)) {\n      metadata[prop] = propValue.concat(addValue);\n    } else {\n      metadata[prop] = addValue;\n    }\n  }\n}\nfunction setMetadata(metadata, set) {\n  for (const prop in set) {\n    metadata[prop] = set[prop];\n  }\n}\nfunction _propHashKey(propName, propValue, references) {\n  let nextObjectId = 0;\n  const objectIds = new Map();\n  const replacer = (key, value) => {\n    if (value !== null && typeof value === 'object') {\n      if (objectIds.has(value)) {\n        return objectIds.get(value);\n      }\n      objectIds.set(value, `ɵobj#${nextObjectId++}`);\n      return value;\n    } else if (typeof value === 'function') {\n      value = _serializeReference(value, references);\n    }\n    return value;\n  };\n  return `${propName}:${JSON.stringify(propValue, replacer)}`;\n}\nfunction _serializeReference(ref, references) {\n  let id = references.get(ref);\n  if (!id) {\n    id = `${stringify(ref)}${_nextReferenceId++}`;\n    references.set(ref, id);\n  }\n  return id;\n}\nfunction _valueProps(obj) {\n  const props = [];\n  Object.keys(obj).forEach(prop => {\n    if (!prop.startsWith('_')) {\n      props.push(prop);\n    }\n  });\n  let proto = obj;\n  while (proto = Object.getPrototypeOf(proto)) {\n    Object.keys(proto).forEach(protoProp => {\n      const desc = Object.getOwnPropertyDescriptor(proto, protoProp);\n      if (!protoProp.startsWith('_') && desc && 'get' in desc) {\n        props.push(protoProp);\n      }\n    });\n  }\n  return props;\n}\n\nconst reflection = new ReflectionCapabilities();\nclass OverrideResolver {\n  overrides = new Map();\n  resolved = new Map();\n  addOverride(type, override) {\n    const overrides = this.overrides.get(type) || [];\n    overrides.push(override);\n    this.overrides.set(type, overrides);\n    this.resolved.delete(type);\n  }\n  setOverrides(overrides) {\n    this.overrides.clear();\n    overrides.forEach(([type, override]) => {\n      this.addOverride(type, override);\n    });\n  }\n  getAnnotation(type) {\n    const annotations = reflection.annotations(type);\n    for (let i = annotations.length - 1; i >= 0; i--) {\n      const annotation = annotations[i];\n      const isKnownType = annotation instanceof Directive || annotation instanceof Component || annotation instanceof Pipe || annotation instanceof NgModule;\n      if (isKnownType) {\n        return annotation instanceof this.type ? annotation : null;\n      }\n    }\n    return null;\n  }\n  resolve(type) {\n    let resolved = this.resolved.get(type) || null;\n    if (!resolved) {\n      resolved = this.getAnnotation(type);\n      if (resolved) {\n        const overrides = this.overrides.get(type);\n        if (overrides) {\n          const overrider = new MetadataOverrider();\n          overrides.forEach(override => {\n            resolved = overrider.overrideMetadata(this.type, resolved, override);\n          });\n        }\n      }\n      this.resolved.set(type, resolved);\n    }\n    return resolved;\n  }\n}\nclass DirectiveResolver extends OverrideResolver {\n  get type() {\n    return Directive;\n  }\n}\nclass ComponentResolver extends OverrideResolver {\n  get type() {\n    return Component;\n  }\n}\nclass PipeResolver extends OverrideResolver {\n  get type() {\n    return Pipe;\n  }\n}\nclass NgModuleResolver extends OverrideResolver {\n  get type() {\n    return NgModule;\n  }\n}\n\nvar TestingModuleOverride;\n(function (TestingModuleOverride) {\n  TestingModuleOverride[TestingModuleOverride[\"DECLARATION\"] = 0] = \"DECLARATION\";\n  TestingModuleOverride[TestingModuleOverride[\"OVERRIDE_TEMPLATE\"] = 1] = \"OVERRIDE_TEMPLATE\";\n})(TestingModuleOverride || (TestingModuleOverride = {}));\nfunction isTestingModuleOverride(value) {\n  return value === TestingModuleOverride.DECLARATION || value === TestingModuleOverride.OVERRIDE_TEMPLATE;\n}\nfunction assertNoStandaloneComponents(types, resolver, location) {\n  types.forEach(type => {\n    if (!getAsyncClassMetadataFn(type)) {\n      const component = resolver.resolve(type);\n      if (component && (component.standalone == null || component.standalone)) {\n        throw new Error(generateStandaloneInDeclarationsError(type, location));\n      }\n    }\n  });\n}\nclass TestBedCompiler {\n  platform;\n  additionalModuleTypes;\n  originalComponentResolutionQueue = null;\n  declarations = [];\n  imports = [];\n  providers = [];\n  schemas = [];\n  pendingComponents = new Set();\n  pendingDirectives = new Set();\n  pendingPipes = new Set();\n  componentsWithAsyncMetadata = new Set();\n  seenComponents = new Set();\n  seenDirectives = new Set();\n  overriddenModules = new Set();\n  existingComponentStyles = new Map();\n  resolvers = initResolvers();\n  componentToModuleScope = new Map();\n  initialNgDefs = new Map();\n  defCleanupOps = [];\n  _injector = null;\n  compilerProviders = null;\n  providerOverrides = [];\n  rootProviderOverrides = [];\n  providerOverridesByModule = new Map();\n  providerOverridesByToken = new Map();\n  scopesWithOverriddenProviders = new Set();\n  testModuleType;\n  testModuleRef = null;\n  animationsEnabled = ANIMATIONS_ENABLED_DEFAULT;\n  deferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n  rethrowApplicationTickErrors = RETHROW_APPLICATION_ERRORS_DEFAULT;\n  constructor(platform, additionalModuleTypes) {\n    this.platform = platform;\n    this.additionalModuleTypes = additionalModuleTypes;\n    class DynamicTestModule {}\n    this.testModuleType = DynamicTestModule;\n  }\n  setCompilerProviders(providers) {\n    this.compilerProviders = providers;\n    this._injector = null;\n  }\n  configureTestingModule(moduleDef) {\n    if (moduleDef.declarations !== undefined) {\n      assertNoStandaloneComponents(moduleDef.declarations, this.resolvers.component, '\"TestBed.configureTestingModule\" call');\n      this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\n      this.declarations.push(...moduleDef.declarations);\n    }\n    if (moduleDef.imports !== undefined) {\n      this.queueTypesFromModulesArray(moduleDef.imports);\n      this.imports.push(...moduleDef.imports);\n    }\n    if (moduleDef.providers !== undefined) {\n      this.providers.push(...moduleDef.providers);\n    }\n    if (moduleDef.schemas !== undefined) {\n      this.schemas.push(...moduleDef.schemas);\n    }\n    this.deferBlockBehavior = moduleDef.deferBlockBehavior ?? DEFER_BLOCK_DEFAULT_BEHAVIOR;\n    this.animationsEnabled = moduleDef.animationsEnabled ?? ANIMATIONS_ENABLED_DEFAULT;\n    this.rethrowApplicationTickErrors = moduleDef.rethrowApplicationErrors ?? RETHROW_APPLICATION_ERRORS_DEFAULT;\n  }\n  overrideModule(ngModule, override) {\n    depsTracker.clearScopeCacheFor(ngModule);\n    this.overriddenModules.add(ngModule);\n    this.resolvers.module.addOverride(ngModule, override);\n    const metadata = this.resolvers.module.resolve(ngModule);\n    if (metadata === null) {\n      throw invalidTypeError(ngModule.name, 'NgModule');\n    }\n    this.recompileNgModule(ngModule, metadata);\n    this.queueTypesFromModulesArray([ngModule]);\n  }\n  overrideComponent(component, override) {\n    this.verifyNoStandaloneFlagOverrides(component, override);\n    this.resolvers.component.addOverride(component, override);\n    this.pendingComponents.add(component);\n    this.maybeRegisterComponentWithAsyncMetadata(component);\n  }\n  overrideDirective(directive, override) {\n    this.verifyNoStandaloneFlagOverrides(directive, override);\n    this.resolvers.directive.addOverride(directive, override);\n    this.pendingDirectives.add(directive);\n  }\n  overridePipe(pipe, override) {\n    this.verifyNoStandaloneFlagOverrides(pipe, override);\n    this.resolvers.pipe.addOverride(pipe, override);\n    this.pendingPipes.add(pipe);\n  }\n  verifyNoStandaloneFlagOverrides(type, override) {\n    if (override.add?.hasOwnProperty('standalone') || override.set?.hasOwnProperty('standalone') || override.remove?.hasOwnProperty('standalone')) {\n      throw new Error(`An override for the ${type.name} class has the \\`standalone\\` flag. ` + `Changing the \\`standalone\\` flag via TestBed overrides is not supported.`);\n    }\n  }\n  overrideProvider(token, provider) {\n    let providerDef;\n    if (provider.useFactory !== undefined) {\n      providerDef = {\n        provide: token,\n        useFactory: provider.useFactory,\n        deps: provider.deps || [],\n        multi: provider.multi\n      };\n    } else if (provider.useValue !== undefined) {\n      providerDef = {\n        provide: token,\n        useValue: provider.useValue,\n        multi: provider.multi\n      };\n    } else {\n      providerDef = {\n        provide: token\n      };\n    }\n    const injectableDef = typeof token !== 'string' ? getInjectableDef(token) : null;\n    const providedIn = injectableDef === null ? null : resolveForwardRef(injectableDef.providedIn);\n    const overridesBucket = providedIn === 'root' ? this.rootProviderOverrides : this.providerOverrides;\n    overridesBucket.push(providerDef);\n    this.providerOverridesByToken.set(token, providerDef);\n    if (injectableDef !== null && providedIn !== null && typeof providedIn !== 'string') {\n      const existingOverrides = this.providerOverridesByModule.get(providedIn);\n      if (existingOverrides !== undefined) {\n        existingOverrides.push(providerDef);\n      } else {\n        this.providerOverridesByModule.set(providedIn, [providerDef]);\n      }\n    }\n  }\n  overrideTemplateUsingTestingModule(type, template) {\n    const def = type[NG_COMP_DEF];\n    const hasStyleUrls = () => {\n      const metadata = this.resolvers.component.resolve(type);\n      return !!metadata.styleUrl || !!metadata.styleUrls?.length;\n    };\n    const overrideStyleUrls = !!def && !isComponentDefPendingResolution(type) && hasStyleUrls();\n    const override = overrideStyleUrls ? {\n      template,\n      styles: [],\n      styleUrls: [],\n      styleUrl: undefined\n    } : {\n      template\n    };\n    this.overrideComponent(type, {\n      set: override\n    });\n    if (overrideStyleUrls && def.styles && def.styles.length > 0) {\n      this.existingComponentStyles.set(type, def.styles);\n    }\n    this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\n  }\n  async resolvePendingComponentsWithAsyncMetadata() {\n    if (this.componentsWithAsyncMetadata.size === 0) return;\n    const promises = [];\n    for (const component of this.componentsWithAsyncMetadata) {\n      const asyncMetadataFn = getAsyncClassMetadataFn(component);\n      if (asyncMetadataFn) {\n        promises.push(asyncMetadataFn());\n      }\n    }\n    this.componentsWithAsyncMetadata.clear();\n    const resolvedDeps = await Promise.all(promises);\n    const flatResolvedDeps = resolvedDeps.flat(2);\n    this.queueTypesFromModulesArray(flatResolvedDeps);\n    for (const component of flatResolvedDeps) {\n      this.applyProviderOverridesInScope(component);\n    }\n  }\n  async compileComponents() {\n    this.clearComponentResolutionQueue();\n    await this.resolvePendingComponentsWithAsyncMetadata();\n    assertNoStandaloneComponents(this.declarations, this.resolvers.component, '\"TestBed.configureTestingModule\" call');\n    let needsAsyncResources = this.compileTypesSync();\n    if (needsAsyncResources) {\n      let resourceLoader;\n      let resolver = url => {\n        if (!resourceLoader) {\n          resourceLoader = this.injector.get(ResourceLoader);\n        }\n        return Promise.resolve(resourceLoader.get(url));\n      };\n      await resolveComponentResources(resolver);\n    }\n  }\n  finalize() {\n    this.compileTypesSync();\n    this.compileTestModule();\n    this.applyTransitiveScopes();\n    this.applyProviderOverrides();\n    this.patchComponentsWithExistingStyles();\n    this.componentToModuleScope.clear();\n    const parentInjector = this.platform.injector;\n    this.testModuleRef = new NgModuleRef(this.testModuleType, parentInjector, []);\n    this.testModuleRef.injector.get(ApplicationInitStatus).runInitializers();\n    const localeId = this.testModuleRef.injector.get(LOCALE_ID, DEFAULT_LOCALE_ID);\n    setLocaleId(localeId);\n    return this.testModuleRef;\n  }\n  _compileNgModuleSync(moduleType) {\n    this.queueTypesFromModulesArray([moduleType]);\n    this.compileTypesSync();\n    this.applyProviderOverrides();\n    this.applyProviderOverridesInScope(moduleType);\n    this.applyTransitiveScopes();\n  }\n  async _compileNgModuleAsync(moduleType) {\n    this.queueTypesFromModulesArray([moduleType]);\n    await this.compileComponents();\n    this.applyProviderOverrides();\n    this.applyProviderOverridesInScope(moduleType);\n    this.applyTransitiveScopes();\n  }\n  _getModuleResolver() {\n    return this.resolvers.module;\n  }\n  _getComponentFactories(moduleType) {\n    return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce((factories, declaration) => {\n      const componentDef = declaration.ɵcmp;\n      componentDef && factories.push(new ComponentFactory(componentDef, this.testModuleRef));\n      return factories;\n    }, []);\n  }\n  compileTypesSync() {\n    let needsAsyncResources = false;\n    this.pendingComponents.forEach(declaration => {\n      if (getAsyncClassMetadataFn(declaration)) {\n        throw new Error(`Component '${declaration.name}' has unresolved metadata. ` + `Please call \\`await TestBed.compileComponents()\\` before running this test.`);\n      }\n      needsAsyncResources = needsAsyncResources || isComponentDefPendingResolution(declaration);\n      const metadata = this.resolvers.component.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Component');\n      }\n      this.maybeStoreNgDef(NG_COMP_DEF, declaration);\n      depsTracker.clearScopeCacheFor(declaration);\n      compileComponent(declaration, metadata);\n    });\n    this.pendingComponents.clear();\n    this.pendingDirectives.forEach(declaration => {\n      const metadata = this.resolvers.directive.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Directive');\n      }\n      this.maybeStoreNgDef(NG_DIR_DEF, declaration);\n      compileDirective(declaration, metadata);\n    });\n    this.pendingDirectives.clear();\n    this.pendingPipes.forEach(declaration => {\n      const metadata = this.resolvers.pipe.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Pipe');\n      }\n      this.maybeStoreNgDef(NG_PIPE_DEF, declaration);\n      compilePipe(declaration, metadata);\n    });\n    this.pendingPipes.clear();\n    return needsAsyncResources;\n  }\n  applyTransitiveScopes() {\n    if (this.overriddenModules.size > 0) {\n      const testingModuleDef = this.testModuleType[NG_MOD_DEF];\n      const affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);\n      if (affectedModules.size > 0) {\n        affectedModules.forEach(moduleType => {\n          depsTracker.clearScopeCacheFor(moduleType);\n        });\n      }\n    }\n    const moduleToScope = new Map();\n    const getScopeOfModule = moduleType => {\n      if (!moduleToScope.has(moduleType)) {\n        const isTestingModule = isTestingModuleOverride(moduleType);\n        const realType = isTestingModule ? this.testModuleType : moduleType;\n        moduleToScope.set(moduleType, transitiveScopesFor(realType));\n      }\n      return moduleToScope.get(moduleType);\n    };\n    this.componentToModuleScope.forEach((moduleType, componentType) => {\n      if (moduleType !== null) {\n        const moduleScope = getScopeOfModule(moduleType);\n        this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, 'directiveDefs');\n        this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, 'pipeDefs');\n        patchComponentDefWithScope(getComponentDef(componentType), moduleScope);\n      }\n      this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, 'tView');\n    });\n    this.componentToModuleScope.clear();\n  }\n  applyProviderOverrides() {\n    const maybeApplyOverrides = field => type => {\n      const resolver = field === NG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;\n      const metadata = resolver.resolve(type);\n      if (this.hasProviderOverrides(metadata.providers)) {\n        this.patchDefWithProviderOverrides(type, field);\n      }\n    };\n    this.seenComponents.forEach(maybeApplyOverrides(NG_COMP_DEF));\n    this.seenDirectives.forEach(maybeApplyOverrides(NG_DIR_DEF));\n    this.seenComponents.clear();\n    this.seenDirectives.clear();\n  }\n  applyProviderOverridesInScope(type) {\n    const hasScope = isStandaloneComponent(type) || isNgModule(type);\n    if (!hasScope || this.scopesWithOverriddenProviders.has(type)) {\n      return;\n    }\n    this.scopesWithOverriddenProviders.add(type);\n    const injectorDef = type[NG_INJ_DEF];\n    if (this.providerOverridesByToken.size === 0) return;\n    if (isStandaloneComponent(type)) {\n      const def = getComponentDef(type);\n      const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n      for (const dependency of dependencies) {\n        this.applyProviderOverridesInScope(dependency);\n      }\n    } else {\n      const providers = [...injectorDef.providers, ...(this.providerOverridesByModule.get(type) || [])];\n      if (this.hasProviderOverrides(providers)) {\n        this.maybeStoreNgDef(NG_INJ_DEF, type);\n        this.storeFieldOfDefOnType(type, NG_INJ_DEF, 'providers');\n        injectorDef.providers = this.getOverriddenProviders(providers);\n      }\n      const moduleDef = type[NG_MOD_DEF];\n      const imports = maybeUnwrapFn(moduleDef.imports);\n      for (const importedModule of imports) {\n        this.applyProviderOverridesInScope(importedModule);\n      }\n      for (const importedModule of flatten(injectorDef.imports)) {\n        if (isModuleWithProviders(importedModule)) {\n          this.defCleanupOps.push({\n            object: importedModule,\n            fieldName: 'providers',\n            originalValue: importedModule.providers\n          });\n          importedModule.providers = this.getOverriddenProviders(importedModule.providers);\n        }\n      }\n    }\n  }\n  patchComponentsWithExistingStyles() {\n    this.existingComponentStyles.forEach((styles, type) => type[NG_COMP_DEF].styles = styles);\n    this.existingComponentStyles.clear();\n  }\n  queueTypeArray(arr, moduleType) {\n    for (const value of arr) {\n      if (Array.isArray(value)) {\n        this.queueTypeArray(value, moduleType);\n      } else {\n        this.queueType(value, moduleType);\n      }\n    }\n  }\n  recompileNgModule(ngModule, metadata) {\n    this.maybeStoreNgDef(NG_MOD_DEF, ngModule);\n    this.maybeStoreNgDef(NG_INJ_DEF, ngModule);\n    compileNgModuleDefs(ngModule, metadata);\n  }\n  maybeRegisterComponentWithAsyncMetadata(type) {\n    const asyncMetadataFn = getAsyncClassMetadataFn(type);\n    if (asyncMetadataFn) {\n      this.componentsWithAsyncMetadata.add(type);\n    }\n  }\n  queueType(type, moduleType) {\n    this.maybeRegisterComponentWithAsyncMetadata(type);\n    const component = this.resolvers.component.resolve(type);\n    if (component) {\n      if (isComponentDefPendingResolution(type) || !type.hasOwnProperty(NG_COMP_DEF)) {\n        this.pendingComponents.add(type);\n      }\n      this.seenComponents.add(type);\n      if (!this.componentToModuleScope.has(type) || this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION) {\n        this.componentToModuleScope.set(type, moduleType);\n      }\n      return;\n    }\n    const directive = this.resolvers.directive.resolve(type);\n    if (directive) {\n      if (!type.hasOwnProperty(NG_DIR_DEF)) {\n        this.pendingDirectives.add(type);\n      }\n      this.seenDirectives.add(type);\n      return;\n    }\n    const pipe = this.resolvers.pipe.resolve(type);\n    if (pipe && !type.hasOwnProperty(NG_PIPE_DEF)) {\n      this.pendingPipes.add(type);\n      return;\n    }\n  }\n  queueTypesFromModulesArray(arr) {\n    const processedDefs = new Set();\n    const queueTypesFromModulesArrayRecur = arr => {\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          queueTypesFromModulesArrayRecur(value);\n        } else if (hasNgModuleDef(value)) {\n          const def = value.ɵmod;\n          if (processedDefs.has(def)) {\n            continue;\n          }\n          processedDefs.add(def);\n          this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\n        } else if (isModuleWithProviders(value)) {\n          queueTypesFromModulesArrayRecur([value.ngModule]);\n        } else if (isStandaloneComponent(value)) {\n          this.queueType(value, null);\n          const def = getComponentDef(value);\n          if (processedDefs.has(def)) {\n            continue;\n          }\n          processedDefs.add(def);\n          const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n          dependencies.forEach(dependency => {\n            if (isStandaloneComponent(dependency) || hasNgModuleDef(dependency)) {\n              queueTypesFromModulesArrayRecur([dependency]);\n            } else {\n              this.queueType(dependency, null);\n            }\n          });\n        }\n      }\n    };\n    queueTypesFromModulesArrayRecur(arr);\n  }\n  collectModulesAffectedByOverrides(arr) {\n    const seenModules = new Set();\n    const affectedModules = new Set();\n    const calcAffectedModulesRecur = (arr, path) => {\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          calcAffectedModulesRecur(value, path);\n        } else if (hasNgModuleDef(value)) {\n          if (seenModules.has(value)) {\n            if (affectedModules.has(value)) {\n              path.forEach(item => affectedModules.add(item));\n            }\n            continue;\n          }\n          seenModules.add(value);\n          if (this.overriddenModules.has(value)) {\n            path.forEach(item => affectedModules.add(item));\n          }\n          const moduleDef = value[NG_MOD_DEF];\n          calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports), path.concat(value));\n        }\n      }\n    };\n    calcAffectedModulesRecur(arr, []);\n    return affectedModules;\n  }\n  maybeStoreNgDef(prop, type) {\n    if (!this.initialNgDefs.has(type)) {\n      this.initialNgDefs.set(type, new Map());\n    }\n    const currentDefs = this.initialNgDefs.get(type);\n    if (!currentDefs.has(prop)) {\n      const currentDef = Object.getOwnPropertyDescriptor(type, prop);\n      currentDefs.set(prop, currentDef);\n    }\n  }\n  storeFieldOfDefOnType(type, defField, fieldName) {\n    const def = type[defField];\n    const originalValue = def[fieldName];\n    this.defCleanupOps.push({\n      object: def,\n      fieldName,\n      originalValue\n    });\n  }\n  clearComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue === null) {\n      this.originalComponentResolutionQueue = new Map();\n    }\n    clearResolutionOfComponentResourcesQueue().forEach((value, key) => this.originalComponentResolutionQueue.set(key, value));\n  }\n  restoreComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue !== null) {\n      restoreComponentResolutionQueue(this.originalComponentResolutionQueue);\n      this.originalComponentResolutionQueue = null;\n    }\n  }\n  restoreOriginalState() {\n    forEachRight(this.defCleanupOps, op => {\n      op.object[op.fieldName] = op.originalValue;\n    });\n    this.initialNgDefs.forEach((defs, type) => {\n      depsTracker.clearScopeCacheFor(type);\n      defs.forEach((descriptor, prop) => {\n        if (!descriptor) {\n          delete type[prop];\n        } else {\n          Object.defineProperty(type, prop, descriptor);\n        }\n      });\n    });\n    this.initialNgDefs.clear();\n    this.scopesWithOverriddenProviders.clear();\n    this.restoreComponentResolutionQueue();\n    setLocaleId(DEFAULT_LOCALE_ID);\n  }\n  compileTestModule() {\n    class RootScopeModule {}\n    compileNgModuleDefs(RootScopeModule, {\n      providers: [...this.rootProviderOverrides, provideZonelessChangeDetectionInternal(), TestBedApplicationErrorHandler, {\n        provide: ENVIRONMENT_INITIALIZER,\n        multi: true,\n        useValue: () => {\n          inject$1(ErrorHandler);\n        }\n      }]\n    });\n    const providers = [{\n      provide: Compiler,\n      useFactory: () => new R3TestCompiler(this)\n    }, {\n      provide: DEFER_BLOCK_CONFIG,\n      useValue: {\n        behavior: this.deferBlockBehavior\n      }\n    }, {\n      provide: ANIMATIONS_DISABLED,\n      useValue: !this.animationsEnabled\n    }, {\n      provide: INTERNAL_APPLICATION_ERROR_HANDLER,\n      useFactory: () => {\n        if (this.rethrowApplicationTickErrors) {\n          const handler = inject$1(TestBedApplicationErrorHandler);\n          return e => {\n            handler.handleError(e);\n          };\n        } else {\n          const userErrorHandler = inject$1(ErrorHandler);\n          const ngZone = inject$1(NgZone);\n          return e => ngZone.runOutsideAngular(() => userErrorHandler.handleError(e));\n        }\n      }\n    }, ...this.providers, ...this.providerOverrides];\n    const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []];\n    compileNgModuleDefs(this.testModuleType, {\n      declarations: this.declarations,\n      imports,\n      schemas: this.schemas,\n      providers\n    }, true);\n    this.applyProviderOverridesInScope(this.testModuleType);\n  }\n  get injector() {\n    if (this._injector !== null) {\n      return this._injector;\n    }\n    const providers = [];\n    const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS, []);\n    compilerOptions.forEach(opts => {\n      if (opts.providers) {\n        providers.push(opts.providers);\n      }\n    });\n    if (this.compilerProviders !== null) {\n      providers.push(...this.compilerProviders);\n    }\n    this._injector = Injector.create({\n      providers,\n      parent: this.platform.injector\n    });\n    return this._injector;\n  }\n  getSingleProviderOverrides(provider) {\n    const token = getProviderToken(provider);\n    return this.providerOverridesByToken.get(token) || null;\n  }\n  getProviderOverrides(providers) {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return [];\n    return flatten(flattenProviders(providers, provider => this.getSingleProviderOverrides(provider) || []));\n  }\n  getOverriddenProviders(providers) {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return [];\n    const flattenedProviders = flattenProviders(providers);\n    const overrides = this.getProviderOverrides(flattenedProviders);\n    const overriddenProviders = [...flattenedProviders, ...overrides];\n    const final = [];\n    const seenOverriddenProviders = new Set();\n    forEachRight(overriddenProviders, provider => {\n      const token = getProviderToken(provider);\n      if (this.providerOverridesByToken.has(token)) {\n        if (!seenOverriddenProviders.has(token)) {\n          seenOverriddenProviders.add(token);\n          final.unshift({\n            ...provider,\n            multi: false\n          });\n        }\n      } else {\n        final.unshift(provider);\n      }\n    });\n    return final;\n  }\n  hasProviderOverrides(providers) {\n    return this.getProviderOverrides(providers).length > 0;\n  }\n  patchDefWithProviderOverrides(declaration, field) {\n    const def = declaration[field];\n    if (def && def.providersResolver) {\n      this.maybeStoreNgDef(field, declaration);\n      const resolver = def.providersResolver;\n      const processProvidersFn = providers => this.getOverriddenProviders(providers);\n      this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\n      def.providersResolver = ngDef => resolver(ngDef, processProvidersFn);\n    }\n  }\n}\nfunction initResolvers() {\n  return {\n    module: new NgModuleResolver(),\n    component: new ComponentResolver(),\n    directive: new DirectiveResolver(),\n    pipe: new PipeResolver()\n  };\n}\nfunction isStandaloneComponent(value) {\n  const def = getComponentDef(value);\n  return !!def?.standalone;\n}\nfunction getComponentDef(value) {\n  return value.ɵcmp ?? null;\n}\nfunction hasNgModuleDef(value) {\n  return value.hasOwnProperty('ɵmod');\n}\nfunction isNgModule(value) {\n  return hasNgModuleDef(value);\n}\nfunction maybeUnwrapFn(maybeFn) {\n  return maybeFn instanceof Function ? maybeFn() : maybeFn;\n}\nfunction flatten(values) {\n  const out = [];\n  values.forEach(value => {\n    if (Array.isArray(value)) {\n      out.push(...flatten(value));\n    } else {\n      out.push(value);\n    }\n  });\n  return out;\n}\nfunction identityFn(value) {\n  return value;\n}\nfunction flattenProviders(providers, mapFn = identityFn) {\n  const out = [];\n  for (let provider of providers) {\n    if (isEnvironmentProviders(provider)) {\n      provider = provider.ɵproviders;\n    }\n    if (Array.isArray(provider)) {\n      out.push(...flattenProviders(provider, mapFn));\n    } else {\n      out.push(mapFn(provider));\n    }\n  }\n  return out;\n}\nfunction getProviderField(provider, field) {\n  return provider && typeof provider === 'object' && provider[field];\n}\nfunction getProviderToken(provider) {\n  return getProviderField(provider, 'provide') || provider;\n}\nfunction isModuleWithProviders(value) {\n  return value.hasOwnProperty('ngModule');\n}\nfunction forEachRight(values, fn) {\n  for (let idx = values.length - 1; idx >= 0; idx--) {\n    fn(values[idx], idx);\n  }\n}\nfunction invalidTypeError(name, expectedType) {\n  return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);\n}\nclass R3TestCompiler {\n  testBed;\n  constructor(testBed) {\n    this.testBed = testBed;\n  }\n  compileModuleSync(moduleType) {\n    this.testBed._compileNgModuleSync(moduleType);\n    return new NgModuleFactory(moduleType);\n  }\n  async compileModuleAsync(moduleType) {\n    await this.testBed._compileNgModuleAsync(moduleType);\n    return new NgModuleFactory(moduleType);\n  }\n  compileModuleAndAllComponentsSync(moduleType) {\n    const ngModuleFactory = this.compileModuleSync(moduleType);\n    const componentFactories = this.testBed._getComponentFactories(moduleType);\n    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n  }\n  async compileModuleAndAllComponentsAsync(moduleType) {\n    const ngModuleFactory = await this.compileModuleAsync(moduleType);\n    const componentFactories = this.testBed._getComponentFactories(moduleType);\n    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n  }\n  clearCache() {}\n  clearCacheFor(type) {}\n  getModuleId(moduleType) {\n    const meta = this.testBed._getModuleResolver().resolve(moduleType);\n    return meta && meta.id || undefined;\n  }\n}\n\nlet _nextRootElementId = 0;\nfunction getTestBed() {\n  return TestBedImpl.INSTANCE;\n}\nclass TestBedImpl {\n  static _INSTANCE = null;\n  static get INSTANCE() {\n    return TestBedImpl._INSTANCE = TestBedImpl._INSTANCE || new TestBedImpl();\n  }\n  static _environmentTeardownOptions;\n  static _environmentErrorOnUnknownElementsOption;\n  static _environmentErrorOnUnknownPropertiesOption;\n  _instanceTeardownOptions;\n  _instanceDeferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n  _instanceAnimationsEnabled = ANIMATIONS_ENABLED_DEFAULT;\n  _instanceErrorOnUnknownElementsOption;\n  _instanceErrorOnUnknownPropertiesOption;\n  _previousErrorOnUnknownElementsOption;\n  _previousErrorOnUnknownPropertiesOption;\n  _instanceInferTagName;\n  static initTestEnvironment(ngModule, platform, options) {\n    const testBed = TestBedImpl.INSTANCE;\n    testBed.initTestEnvironment(ngModule, platform, options);\n    return testBed;\n  }\n  static resetTestEnvironment() {\n    TestBedImpl.INSTANCE.resetTestEnvironment();\n  }\n  static configureCompiler(config) {\n    return TestBedImpl.INSTANCE.configureCompiler(config);\n  }\n  static configureTestingModule(moduleDef) {\n    return TestBedImpl.INSTANCE.configureTestingModule(moduleDef);\n  }\n  static compileComponents() {\n    return TestBedImpl.INSTANCE.compileComponents();\n  }\n  static overrideModule(ngModule, override) {\n    return TestBedImpl.INSTANCE.overrideModule(ngModule, override);\n  }\n  static overrideComponent(component, override) {\n    return TestBedImpl.INSTANCE.overrideComponent(component, override);\n  }\n  static overrideDirective(directive, override) {\n    return TestBedImpl.INSTANCE.overrideDirective(directive, override);\n  }\n  static overridePipe(pipe, override) {\n    return TestBedImpl.INSTANCE.overridePipe(pipe, override);\n  }\n  static overrideTemplate(component, template) {\n    return TestBedImpl.INSTANCE.overrideTemplate(component, template);\n  }\n  static overrideTemplateUsingTestingModule(component, template) {\n    return TestBedImpl.INSTANCE.overrideTemplateUsingTestingModule(component, template);\n  }\n  static overrideProvider(token, provider) {\n    return TestBedImpl.INSTANCE.overrideProvider(token, provider);\n  }\n  static inject(token, notFoundValue, options) {\n    return TestBedImpl.INSTANCE.inject(token, notFoundValue, options);\n  }\n  static runInInjectionContext(fn) {\n    return TestBedImpl.INSTANCE.runInInjectionContext(fn);\n  }\n  static createComponent(component, options) {\n    return TestBedImpl.INSTANCE.createComponent(component, options);\n  }\n  static resetTestingModule() {\n    return TestBedImpl.INSTANCE.resetTestingModule();\n  }\n  static execute(tokens, fn, context) {\n    return TestBedImpl.INSTANCE.execute(tokens, fn, context);\n  }\n  static get platform() {\n    return TestBedImpl.INSTANCE.platform;\n  }\n  static get ngModule() {\n    return TestBedImpl.INSTANCE.ngModule;\n  }\n  static flushEffects() {\n    return TestBedImpl.INSTANCE.tick();\n  }\n  static tick() {\n    return TestBedImpl.INSTANCE.tick();\n  }\n  platform = null;\n  ngModule = null;\n  _compiler = null;\n  _testModuleRef = null;\n  _activeFixtures = [];\n  globalCompilationChecked = false;\n  initTestEnvironment(ngModule, platform, options) {\n    if (this.platform || this.ngModule) {\n      throw new Error('Cannot set base providers because it has already been called');\n    }\n    TestBedImpl._environmentTeardownOptions = options?.teardown;\n    TestBedImpl._environmentErrorOnUnknownElementsOption = options?.errorOnUnknownElements;\n    TestBedImpl._environmentErrorOnUnknownPropertiesOption = options?.errorOnUnknownProperties;\n    this.platform = platform;\n    this.ngModule = ngModule;\n    this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n    setAllowDuplicateNgModuleIdsForTest(true);\n  }\n  resetTestEnvironment() {\n    this.resetTestingModule();\n    this._compiler = null;\n    this.platform = null;\n    this.ngModule = null;\n    TestBedImpl._environmentTeardownOptions = undefined;\n    setAllowDuplicateNgModuleIdsForTest(false);\n  }\n  resetTestingModule() {\n    this.checkGlobalCompilationFinished();\n    resetCompiledComponents();\n    if (this._compiler !== null) {\n      this.compiler.restoreOriginalState();\n    }\n    this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n    _setUnknownElementStrictMode(this._previousErrorOnUnknownElementsOption ?? THROW_ON_UNKNOWN_ELEMENTS_DEFAULT);\n    _setUnknownPropertyStrictMode(this._previousErrorOnUnknownPropertiesOption ?? THROW_ON_UNKNOWN_PROPERTIES_DEFAULT);\n    try {\n      this.destroyActiveFixtures();\n    } finally {\n      try {\n        if (this.shouldTearDownTestingModule()) {\n          this.tearDownTestingModule();\n        }\n      } finally {\n        this._testModuleRef = null;\n        this._instanceTeardownOptions = undefined;\n        this._instanceErrorOnUnknownElementsOption = undefined;\n        this._instanceErrorOnUnknownPropertiesOption = undefined;\n        this._instanceInferTagName = undefined;\n        this._instanceDeferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n        this._instanceAnimationsEnabled = ANIMATIONS_ENABLED_DEFAULT;\n      }\n    }\n    return this;\n  }\n  configureCompiler(config) {\n    if (config.useJit != null) {\n      throw new Error('JIT compiler is not configurable via TestBed APIs.');\n    }\n    if (config.providers !== undefined) {\n      this.compiler.setCompilerProviders(config.providers);\n    }\n    return this;\n  }\n  configureTestingModule(moduleDef) {\n    this.assertNotInstantiated('TestBed.configureTestingModule', 'configure the test module');\n    this.checkGlobalCompilationFinished();\n    this._instanceTeardownOptions = moduleDef.teardown;\n    this._instanceErrorOnUnknownElementsOption = moduleDef.errorOnUnknownElements;\n    this._instanceErrorOnUnknownPropertiesOption = moduleDef.errorOnUnknownProperties;\n    this._instanceInferTagName = moduleDef.inferTagName;\n    this._instanceDeferBlockBehavior = moduleDef.deferBlockBehavior ?? DEFER_BLOCK_DEFAULT_BEHAVIOR;\n    this._instanceAnimationsEnabled = moduleDef.animationsEnabled ?? ANIMATIONS_ENABLED_DEFAULT;\n    this._previousErrorOnUnknownElementsOption = _getUnknownElementStrictMode();\n    _setUnknownElementStrictMode(this.shouldThrowErrorOnUnknownElements());\n    this._previousErrorOnUnknownPropertiesOption = _getUnknownPropertyStrictMode();\n    _setUnknownPropertyStrictMode(this.shouldThrowErrorOnUnknownProperties());\n    this.compiler.configureTestingModule(moduleDef);\n    return this;\n  }\n  compileComponents() {\n    return this.compiler.compileComponents();\n  }\n  inject(token, notFoundValue, options) {\n    if (token === TestBed) {\n      return this;\n    }\n    const UNDEFINED = {};\n    const result = this.testModuleRef.injector.get(token, UNDEFINED, options);\n    return result === UNDEFINED ? this.compiler.injector.get(token, notFoundValue, options) : result;\n  }\n  runInInjectionContext(fn) {\n    return runInInjectionContext(this.inject(EnvironmentInjector), fn);\n  }\n  execute(tokens, fn, context) {\n    const params = tokens.map(t => this.inject(t));\n    return fn.apply(context, params);\n  }\n  overrideModule(ngModule, override) {\n    this.assertNotInstantiated('overrideModule', 'override module metadata');\n    this.compiler.overrideModule(ngModule, override);\n    return this;\n  }\n  overrideComponent(component, override) {\n    this.assertNotInstantiated('overrideComponent', 'override component metadata');\n    this.compiler.overrideComponent(component, override);\n    return this;\n  }\n  overrideTemplateUsingTestingModule(component, template) {\n    this.assertNotInstantiated('TestBed.overrideTemplateUsingTestingModule', 'Cannot override template when the test module has already been instantiated');\n    this.compiler.overrideTemplateUsingTestingModule(component, template);\n    return this;\n  }\n  overrideDirective(directive, override) {\n    this.assertNotInstantiated('overrideDirective', 'override directive metadata');\n    this.compiler.overrideDirective(directive, override);\n    return this;\n  }\n  overridePipe(pipe, override) {\n    this.assertNotInstantiated('overridePipe', 'override pipe metadata');\n    this.compiler.overridePipe(pipe, override);\n    return this;\n  }\n  overrideProvider(token, provider) {\n    this.assertNotInstantiated('overrideProvider', 'override provider');\n    this.compiler.overrideProvider(token, provider);\n    return this;\n  }\n  overrideTemplate(component, template) {\n    return this.overrideComponent(component, {\n      set: {\n        template,\n        templateUrl: null\n      }\n    });\n  }\n  createComponent(type, options) {\n    if (getAsyncClassMetadataFn(type)) {\n      throw new Error(`Component '${type.name}' has unresolved metadata. ` + `Please call \\`await TestBed.compileComponents()\\` before running this test.`);\n    }\n    const testComponentRenderer = this.inject(TestComponentRenderer);\n    const shouldInferTagName = options?.inferTagName ?? this._instanceInferTagName ?? false;\n    const componentDef = getComponentDef$1(type);\n    const rootElId = `root${_nextRootElementId++}`;\n    if (!componentDef) {\n      throw new Error(`It looks like '${stringify(type)}' has not been compiled.`);\n    }\n    testComponentRenderer.insertRootElement(rootElId, shouldInferTagName ? inferTagNameFromDefinition(componentDef) : undefined);\n    const componentFactory = new ComponentFactory(componentDef);\n    const initComponent = () => {\n      const componentRef = componentFactory.create(Injector.NULL, [], `#${rootElId}`, this.testModuleRef, undefined, options?.bindings);\n      return this.runInInjectionContext(() => new ComponentFixture(componentRef));\n    };\n    const noNgZone = this.inject(ComponentFixtureNoNgZone, false);\n    const ngZone = noNgZone ? null : this.inject(NgZone, null);\n    const fixture = ngZone ? ngZone.run(initComponent) : initComponent();\n    this._activeFixtures.push(fixture);\n    return fixture;\n  }\n  get compiler() {\n    if (this._compiler === null) {\n      throw new Error(`Need to call TestBed.initTestEnvironment() first`);\n    }\n    return this._compiler;\n  }\n  get testModuleRef() {\n    if (this._testModuleRef === null) {\n      this._testModuleRef = this.compiler.finalize();\n    }\n    return this._testModuleRef;\n  }\n  assertNotInstantiated(methodName, methodDescription) {\n    if (this._testModuleRef !== null) {\n      throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` + `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n    }\n  }\n  checkGlobalCompilationFinished() {\n    if (!this.globalCompilationChecked && this._testModuleRef === null) {\n      flushModuleScopingQueueAsMuchAsPossible();\n    }\n    this.globalCompilationChecked = true;\n  }\n  destroyActiveFixtures() {\n    let errorCount = 0;\n    this._activeFixtures.forEach(fixture => {\n      try {\n        fixture.destroy();\n      } catch (e) {\n        errorCount++;\n        console.error('Error during cleanup of component', {\n          component: fixture.componentInstance,\n          stacktrace: e\n        });\n      }\n    });\n    this._activeFixtures = [];\n    if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\n      throw Error(`${errorCount} ${errorCount === 1 ? 'component' : 'components'} ` + `threw errors during cleanup`);\n    }\n  }\n  shouldRethrowTeardownErrors() {\n    const instanceOptions = this._instanceTeardownOptions;\n    const environmentOptions = TestBedImpl._environmentTeardownOptions;\n    if (!instanceOptions && !environmentOptions) {\n      return TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n    }\n    return instanceOptions?.rethrowErrors ?? environmentOptions?.rethrowErrors ?? this.shouldTearDownTestingModule();\n  }\n  shouldThrowErrorOnUnknownElements() {\n    return this._instanceErrorOnUnknownElementsOption ?? TestBedImpl._environmentErrorOnUnknownElementsOption ?? THROW_ON_UNKNOWN_ELEMENTS_DEFAULT;\n  }\n  shouldThrowErrorOnUnknownProperties() {\n    return this._instanceErrorOnUnknownPropertiesOption ?? TestBedImpl._environmentErrorOnUnknownPropertiesOption ?? THROW_ON_UNKNOWN_PROPERTIES_DEFAULT;\n  }\n  shouldTearDownTestingModule() {\n    return this._instanceTeardownOptions?.destroyAfterEach ?? TestBedImpl._environmentTeardownOptions?.destroyAfterEach ?? TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n  }\n  getDeferBlockBehavior() {\n    return this._instanceDeferBlockBehavior;\n  }\n  getAnimationsEnabled() {\n    return this._instanceAnimationsEnabled;\n  }\n  tearDownTestingModule() {\n    if (this._testModuleRef === null) {\n      return;\n    }\n    const testRenderer = this.inject(TestComponentRenderer);\n    try {\n      this._testModuleRef.destroy();\n    } catch (e) {\n      if (this.shouldRethrowTeardownErrors()) {\n        throw e;\n      } else {\n        console.error('Error during cleanup of a testing module', {\n          component: this._testModuleRef.instance,\n          stacktrace: e\n        });\n      }\n    } finally {\n      testRenderer.removeAllRootElements?.();\n    }\n  }\n  flushEffects() {\n    this.tick();\n  }\n  tick() {\n    const appRef = this.inject(ApplicationRef);\n    try {\n      appRef.includeAllTestViews = true;\n      appRef.tick();\n    } finally {\n      appRef.includeAllTestViews = false;\n    }\n  }\n}\nconst TestBed = TestBedImpl;\nfunction inject(tokens, fn) {\n  const testBed = TestBedImpl.INSTANCE;\n  return function () {\n    return testBed.execute(tokens, fn, this);\n  };\n}\nclass InjectSetupWrapper {\n  _moduleDef;\n  constructor(_moduleDef) {\n    this._moduleDef = _moduleDef;\n  }\n  _addModule() {\n    const moduleDef = this._moduleDef();\n    if (moduleDef) {\n      TestBedImpl.configureTestingModule(moduleDef);\n    }\n  }\n  inject(tokens, fn) {\n    const self = this;\n    return function () {\n      self._addModule();\n      return inject(tokens, fn).call(this);\n    };\n  }\n}\nfunction withModule(moduleDef, fn) {\n  if (fn) {\n    return function () {\n      const testBed = TestBedImpl.INSTANCE;\n      if (moduleDef) {\n        testBed.configureTestingModule(moduleDef);\n      }\n      return fn.apply(this);\n    };\n  }\n  return new InjectSetupWrapper(() => moduleDef);\n}\n\nclass FakeNavigation {\n  entriesArr = [];\n  currentEntryIndex = 0;\n  navigateEvent = null;\n  traversalQueue = new Map();\n  nextTraversal = Promise.resolve();\n  prospectiveEntryIndex = 0;\n  synchronousTraversals = false;\n  canSetInitialEntry = true;\n  eventTarget;\n  nextId = 0;\n  nextKey = 0;\n  disposed = false;\n  get currentEntry() {\n    return this.entriesArr[this.currentEntryIndex];\n  }\n  get canGoBack() {\n    return this.currentEntryIndex > 0;\n  }\n  get canGoForward() {\n    return this.currentEntryIndex < this.entriesArr.length - 1;\n  }\n  createEventTarget;\n  _window;\n  get window() {\n    return this._window;\n  }\n  constructor(doc, startURL) {\n    this.createEventTarget = () => {\n      try {\n        return doc.createElement('div');\n      } catch {\n        return new EventTarget();\n      }\n    };\n    this._window = document.defaultView ?? this.createEventTarget();\n    this.eventTarget = this.createEventTarget();\n    this.setInitialEntryForTesting(startURL);\n  }\n  setInitialEntryForTesting(url, options = {\n    historyState: null\n  }) {\n    if (!this.canSetInitialEntry) {\n      throw new Error('setInitialEntryForTesting can only be called before any ' + 'navigation has occurred');\n    }\n    const currentInitialEntry = this.entriesArr[0];\n    this.entriesArr[0] = new FakeNavigationHistoryEntry(this.eventTarget, new URL(url).toString(), {\n      index: 0,\n      key: currentInitialEntry?.key ?? String(this.nextKey++),\n      id: currentInitialEntry?.id ?? String(this.nextId++),\n      sameDocument: true,\n      historyState: options?.historyState,\n      state: options.state\n    });\n  }\n  canSetInitialEntryForTesting() {\n    return this.canSetInitialEntry;\n  }\n  setSynchronousTraversalsForTesting(synchronousTraversals) {\n    this.synchronousTraversals = synchronousTraversals;\n  }\n  entries() {\n    return this.entriesArr.slice();\n  }\n  navigate(url, options) {\n    const fromUrl = new URL(this.currentEntry.url);\n    const toUrl = new URL(url, this.currentEntry.url);\n    let navigationType;\n    if (!options?.history || options.history === 'auto') {\n      if (fromUrl.toString() === toUrl.toString()) {\n        navigationType = 'replace';\n      } else {\n        navigationType = 'push';\n      }\n    } else {\n      navigationType = options.history;\n    }\n    const hashChange = isHashChange(fromUrl, toUrl);\n    const destination = new FakeNavigationDestination({\n      url: toUrl.toString(),\n      state: options?.state,\n      sameDocument: hashChange,\n      historyState: null\n    });\n    const result = new InternalNavigationResult(this);\n    const intercepted = this.userAgentNavigate(destination, result, {\n      navigationType,\n      cancelable: true,\n      canIntercept: true,\n      userInitiated: false,\n      hashChange,\n      info: options?.info\n    });\n    if (!intercepted) {\n      this.updateNavigationEntriesForSameDocumentNavigation(this.navigateEvent);\n    }\n    return {\n      committed: result.committed,\n      finished: result.finished\n    };\n  }\n  pushState(data, title, url) {\n    this.pushOrReplaceState('push', data, title, url);\n  }\n  replaceState(data, title, url) {\n    this.pushOrReplaceState('replace', data, title, url);\n  }\n  pushOrReplaceState(navigationType, data, _title, url) {\n    const fromUrl = new URL(this.currentEntry.url);\n    const toUrl = url ? new URL(url, this.currentEntry.url) : fromUrl;\n    const hashChange = isHashChange(fromUrl, toUrl);\n    const destination = new FakeNavigationDestination({\n      url: toUrl.toString(),\n      sameDocument: true,\n      historyState: data,\n      state: undefined\n    });\n    const result = new InternalNavigationResult(this);\n    const intercepted = this.userAgentNavigate(destination, result, {\n      navigationType,\n      cancelable: true,\n      canIntercept: true,\n      userInitiated: false,\n      hashChange\n    });\n    if (intercepted) {\n      return;\n    }\n    this.updateNavigationEntriesForSameDocumentNavigation(this.navigateEvent);\n  }\n  traverseTo(key, options) {\n    const fromUrl = new URL(this.currentEntry.url);\n    const entry = this.findEntry(key);\n    if (!entry) {\n      const domException = new DOMException('Invalid key', 'InvalidStateError');\n      const committed = Promise.reject(domException);\n      const finished = Promise.reject(domException);\n      committed.catch(() => {});\n      finished.catch(() => {});\n      return {\n        committed,\n        finished\n      };\n    }\n    if (entry === this.currentEntry) {\n      return {\n        committed: Promise.resolve(this.currentEntry),\n        finished: Promise.resolve(this.currentEntry)\n      };\n    }\n    if (this.traversalQueue.has(entry.key)) {\n      const existingResult = this.traversalQueue.get(entry.key);\n      return {\n        committed: existingResult.committed,\n        finished: existingResult.finished\n      };\n    }\n    const hashChange = isHashChange(fromUrl, new URL(entry.url, this.currentEntry.url));\n    const destination = new FakeNavigationDestination({\n      url: entry.url,\n      state: entry.getState(),\n      historyState: entry.getHistoryState(),\n      key: entry.key,\n      id: entry.id,\n      index: entry.index,\n      sameDocument: entry.sameDocument\n    });\n    this.prospectiveEntryIndex = entry.index;\n    const result = new InternalNavigationResult(this);\n    this.traversalQueue.set(entry.key, result);\n    this.runTraversal(() => {\n      this.traversalQueue.delete(entry.key);\n      const intercepted = this.userAgentNavigate(destination, result, {\n        navigationType: 'traverse',\n        cancelable: true,\n        canIntercept: true,\n        userInitiated: false,\n        hashChange,\n        info: options?.info\n      });\n      if (!intercepted) {\n        this.userAgentTraverse(this.navigateEvent);\n      }\n    });\n    return {\n      committed: result.committed,\n      finished: result.finished\n    };\n  }\n  back(options) {\n    if (this.currentEntryIndex === 0) {\n      const domException = new DOMException('Cannot go back', 'InvalidStateError');\n      const committed = Promise.reject(domException);\n      const finished = Promise.reject(domException);\n      committed.catch(() => {});\n      finished.catch(() => {});\n      return {\n        committed,\n        finished\n      };\n    }\n    const entry = this.entriesArr[this.currentEntryIndex - 1];\n    return this.traverseTo(entry.key, options);\n  }\n  forward(options) {\n    if (this.currentEntryIndex === this.entriesArr.length - 1) {\n      const domException = new DOMException('Cannot go forward', 'InvalidStateError');\n      const committed = Promise.reject(domException);\n      const finished = Promise.reject(domException);\n      committed.catch(() => {});\n      finished.catch(() => {});\n      return {\n        committed,\n        finished\n      };\n    }\n    const entry = this.entriesArr[this.currentEntryIndex + 1];\n    return this.traverseTo(entry.key, options);\n  }\n  go(direction) {\n    const targetIndex = this.prospectiveEntryIndex + direction;\n    if (targetIndex >= this.entriesArr.length || targetIndex < 0) {\n      return;\n    }\n    this.prospectiveEntryIndex = targetIndex;\n    this.runTraversal(() => {\n      if (targetIndex >= this.entriesArr.length || targetIndex < 0) {\n        return;\n      }\n      const fromUrl = new URL(this.currentEntry.url);\n      const entry = this.entriesArr[targetIndex];\n      const hashChange = isHashChange(fromUrl, new URL(entry.url, this.currentEntry.url));\n      const destination = new FakeNavigationDestination({\n        url: entry.url,\n        state: entry.getState(),\n        historyState: entry.getHistoryState(),\n        key: entry.key,\n        id: entry.id,\n        index: entry.index,\n        sameDocument: entry.sameDocument\n      });\n      const result = new InternalNavigationResult(this);\n      const intercepted = this.userAgentNavigate(destination, result, {\n        navigationType: 'traverse',\n        cancelable: true,\n        canIntercept: true,\n        userInitiated: false,\n        hashChange\n      });\n      if (!intercepted) {\n        this.userAgentTraverse(this.navigateEvent);\n      }\n    });\n  }\n  runTraversal(traversal) {\n    if (this.synchronousTraversals) {\n      traversal();\n      return;\n    }\n    this.nextTraversal = this.nextTraversal.then(() => {\n      return new Promise(resolve => {\n        setTimeout(() => {\n          resolve();\n          traversal();\n        });\n      });\n    });\n  }\n  addEventListener(type, callback, options) {\n    this.eventTarget.addEventListener(type, callback, options);\n  }\n  removeEventListener(type, callback, options) {\n    this.eventTarget.removeEventListener(type, callback, options);\n  }\n  dispatchEvent(event) {\n    return this.eventTarget.dispatchEvent(event);\n  }\n  dispose() {\n    this.eventTarget = this.createEventTarget();\n    this.disposed = true;\n  }\n  isDisposed() {\n    return this.disposed;\n  }\n  abortOngoingNavigation(eventToAbort, reason) {\n    if (this.navigateEvent !== eventToAbort) {\n      return;\n    }\n    if (this.navigateEvent.abortController.signal.aborted) {\n      return;\n    }\n    const abortReason = reason ?? new DOMException('Navigation aborted', 'AbortError');\n    this.navigateEvent.abort(abortReason);\n  }\n  userAgentNavigate(destination, result, options) {\n    this.canSetInitialEntry = false;\n    if (this.navigateEvent) {\n      this.abortOngoingNavigation(this.navigateEvent, new DOMException('Navigation superseded by a new navigation.', 'AbortError'));\n    }\n    const dispatchResultIsTrueIfNoInterception = dispatchNavigateEvent({\n      navigationType: options.navigationType,\n      cancelable: options.cancelable,\n      canIntercept: options.canIntercept,\n      userInitiated: options.userInitiated,\n      hashChange: options.hashChange,\n      destination,\n      info: options.info,\n      sameDocument: destination.sameDocument,\n      result\n    });\n    return !dispatchResultIsTrueIfNoInterception;\n  }\n  urlAndHistoryUpdateSteps(navigateEvent) {\n    this.updateNavigationEntriesForSameDocumentNavigation(navigateEvent);\n  }\n  userAgentTraverse(navigateEvent) {\n    const oldUrl = this.currentEntry.url;\n    this.updateNavigationEntriesForSameDocumentNavigation(navigateEvent);\n    const popStateEvent = createPopStateEvent({\n      state: navigateEvent.destination.getHistoryState()\n    });\n    this._window.dispatchEvent(popStateEvent);\n    if (navigateEvent.hashChange) {\n      const hashchangeEvent = createHashChangeEvent(oldUrl, this.currentEntry.url);\n      this._window.dispatchEvent(hashchangeEvent);\n    }\n  }\n  updateNavigationEntriesForSameDocumentNavigation({\n    destination,\n    navigationType,\n    result\n  }) {\n    const oldCurrentNHE = this.currentEntry;\n    const disposedNHEs = [];\n    if (navigationType === 'traverse') {\n      this.currentEntryIndex = destination.index;\n      if (this.currentEntryIndex === -1) {\n        throw new Error('unexpected current entry index');\n      }\n    } else if (navigationType === 'push') {\n      this.currentEntryIndex++;\n      this.prospectiveEntryIndex = this.currentEntryIndex;\n      disposedNHEs.push(...this.entriesArr.splice(this.currentEntryIndex));\n    } else if (navigationType === 'replace') {\n      disposedNHEs.push(oldCurrentNHE);\n    }\n    if (navigationType === 'push' || navigationType === 'replace') {\n      const index = this.currentEntryIndex;\n      const key = navigationType === 'push' ? String(this.nextKey++) : oldCurrentNHE?.key ?? String(this.nextKey++);\n      const newNHE = new FakeNavigationHistoryEntry(this.eventTarget, destination.url, {\n        id: String(this.nextId++),\n        key,\n        index,\n        sameDocument: true,\n        state: destination.getState(),\n        historyState: destination.getHistoryState()\n      });\n      this.entriesArr[this.currentEntryIndex] = newNHE;\n    }\n    result.committedResolve(this.currentEntry);\n    const currentEntryChangeEvent = createFakeNavigationCurrentEntryChangeEvent({\n      from: oldCurrentNHE,\n      navigationType: navigationType\n    });\n    this.eventTarget.dispatchEvent(currentEntryChangeEvent);\n    for (const disposedNHE of disposedNHEs) {\n      disposedNHE.dispose();\n    }\n  }\n  findEntry(key) {\n    for (const entry of this.entriesArr) {\n      if (entry.key === key) return entry;\n    }\n    return undefined;\n  }\n  set onnavigate(_handler) {\n    throw new Error('unimplemented');\n  }\n  get onnavigate() {\n    throw new Error('unimplemented');\n  }\n  set oncurrententrychange(_handler) {\n    throw new Error('unimplemented');\n  }\n  get oncurrententrychange() {\n    throw new Error('unimplemented');\n  }\n  set onnavigatesuccess(_handler) {\n    throw new Error('unimplemented');\n  }\n  get onnavigatesuccess() {\n    throw new Error('unimplemented');\n  }\n  set onnavigateerror(_handler) {\n    throw new Error('unimplemented');\n  }\n  get onnavigateerror() {\n    throw new Error('unimplemented');\n  }\n  _transition = null;\n  set transition(t) {\n    this._transition = t;\n  }\n  get transition() {\n    return this._transition;\n  }\n  updateCurrentEntry(_options) {\n    throw new Error('unimplemented');\n  }\n  reload(_options) {\n    throw new Error('unimplemented');\n  }\n}\nclass FakeNavigationHistoryEntry {\n  eventTarget;\n  url;\n  sameDocument;\n  id;\n  key;\n  index;\n  state;\n  historyState;\n  ondispose = null;\n  constructor(eventTarget, url, {\n    id,\n    key,\n    index,\n    sameDocument,\n    state,\n    historyState\n  }) {\n    this.eventTarget = eventTarget;\n    this.url = url;\n    this.id = id;\n    this.key = key;\n    this.index = index;\n    this.sameDocument = sameDocument;\n    this.state = state;\n    this.historyState = historyState;\n  }\n  getState() {\n    return this.state ? JSON.parse(JSON.stringify(this.state)) : this.state;\n  }\n  getHistoryState() {\n    return this.historyState ? JSON.parse(JSON.stringify(this.historyState)) : this.historyState;\n  }\n  addEventListener(type, callback, options) {\n    this.eventTarget.addEventListener(type, callback, options);\n  }\n  removeEventListener(type, callback, options) {\n    this.eventTarget.removeEventListener(type, callback, options);\n  }\n  dispatchEvent(event) {\n    return this.eventTarget.dispatchEvent(event);\n  }\n  dispose() {\n    const disposeEvent = new Event('disposed');\n    this.dispatchEvent(disposeEvent);\n    this.eventTarget = null;\n  }\n}\nfunction dispatchNavigateEvent({\n  cancelable,\n  canIntercept,\n  userInitiated,\n  hashChange,\n  navigationType,\n  destination,\n  info,\n  sameDocument,\n  result\n}) {\n  const {\n    navigation\n  } = result;\n  const eventAbortController = new AbortController();\n  const event = new Event('navigate', {\n    bubbles: false,\n    cancelable\n  });\n  event.navigationType = navigationType;\n  event.destination = destination;\n  event.canIntercept = canIntercept;\n  event.userInitiated = userInitiated;\n  event.hashChange = hashChange;\n  event.signal = eventAbortController.signal;\n  event.abortController = eventAbortController;\n  event.info = info;\n  event.focusResetBehavior = null;\n  event.scrollBehavior = null;\n  event.interceptionState = 'none';\n  event.downloadRequest = null;\n  event.formData = null;\n  event.result = result;\n  event.sameDocument = sameDocument;\n  let precommitHandlers = [];\n  let handlers = [];\n  event.intercept = function (options) {\n    if (!this.canIntercept) {\n      throw new DOMException(`Cannot intercept when canIntercept is 'false'`, 'SecurityError');\n    }\n    this.interceptionState = 'intercepted';\n    event.sameDocument = true;\n    const precommitHandler = options?.precommitHandler;\n    if (precommitHandler) {\n      if (!this.cancelable) {\n        throw new DOMException(`Cannot use precommitHandler when cancelable is 'false'`, 'InvalidStateError');\n      }\n      precommitHandlers.push(precommitHandler);\n    }\n    if (event.interceptionState !== 'none' && event.interceptionState !== 'intercepted') {\n      throw new Error('Event interceptionState should be \"none\" or \"intercepted\"');\n    }\n    event.interceptionState = 'intercepted';\n    const handler = options?.handler;\n    if (handler) {\n      handlers.push(handler);\n    }\n    event.focusResetBehavior = options?.focusReset ?? event.focusResetBehavior;\n    event.scrollBehavior = options?.scroll ?? event.scrollBehavior;\n  };\n  event.scroll = function () {\n    if (event.interceptionState !== 'committed') {\n      throw new DOMException(`Failed to execute 'scroll' on 'NavigateEvent': scroll() must be ` + `called after commit() and interception options must specify manual scroll.`, 'InvalidStateError');\n    }\n    processScrollBehavior(event);\n  };\n  function redirect(url, options = {}) {\n    if (event.interceptionState === 'none') {\n      throw new Error('cannot redirect when event is not intercepted');\n    }\n    if (event.interceptionState !== 'intercepted') {\n      throw new DOMException(`cannot redirect when event is not in 'intercepted' state`, 'InvalidStateError');\n    }\n    if (event.navigationType !== 'push' && event.navigationType !== 'replace') {\n      throw new DOMException(`cannot redirect when navigationType is not 'push' or 'replace`, 'InvalidStateError');\n    }\n    const destinationUrl = new URL(url, navigation.currentEntry.url);\n    if (options.history === 'push' || options.history === 'replace') {\n      event.navigationType = options.history;\n    }\n    if (options.hasOwnProperty('state')) {\n      event.destination.state = options.state;\n    }\n    event.destination.url = destinationUrl.href;\n    if (options.hasOwnProperty('info')) {\n      event.info = options.info;\n    }\n  }\n  function processNavigateEventHandlerFailure(reason) {\n    if (event.abortController.signal.aborted) {\n      return;\n    }\n    if (event !== navigation.navigateEvent) {\n      throw new Error('Event is no longer the current navigation event');\n    }\n    if (event.interceptionState !== 'intercepted') {\n      finishNavigationEvent(event, false);\n    }\n    event.abort(reason);\n  }\n  function commit() {\n    if (result.signal.aborted) {\n      return;\n    }\n    if (event.interceptionState !== 'none') {\n      event.interceptionState = 'committed';\n      switch (event.navigationType) {\n        case 'push':\n        case 'replace':\n          {\n            navigation.urlAndHistoryUpdateSteps(event);\n            break;\n          }\n        case 'reload':\n          {\n            navigation.updateNavigationEntriesForSameDocumentNavigation(event);\n            break;\n          }\n        case 'traverse':\n          {\n            navigation.userAgentTraverse(event);\n            break;\n          }\n      }\n    }\n    navigation.transition?.committedResolve();\n    const promisesList = handlers.map(handler => handler());\n    if (promisesList.length === 0) {\n      promisesList.push(Promise.resolve());\n    }\n    Promise.all(promisesList).then(() => {\n      if (result.signal.aborted) {\n        return;\n      }\n      if (event !== navigation.navigateEvent) {\n        if (!result.signal.aborted && result.committedTo) {\n          result.finishedReject(new DOMException('Navigation superseded before handler completion', 'AbortError'));\n        }\n        return;\n      }\n      navigation.navigateEvent = null;\n      finishNavigationEvent(event, true);\n      result.finishedResolve();\n      const navigatesuccessEvent = new Event('navigatesuccess', {\n        bubbles: false,\n        cancelable: false\n      });\n      navigation.eventTarget.dispatchEvent(navigatesuccessEvent);\n      navigation.transition?.finishedResolve();\n      navigation.transition = null;\n    }).catch(processNavigateEventHandlerFailure);\n  }\n  event.abort = function (reason) {\n    this.abortController.abort(reason);\n    navigation.navigateEvent = null;\n    result.finishedReject(reason);\n    const navigateerrorEvent = new Event('navigateerror', {\n      bubbles: false,\n      cancelable\n    });\n    navigateerrorEvent.error = reason;\n    navigation.eventTarget.dispatchEvent(navigateerrorEvent);\n    const transition = navigation.transition;\n    transition?.committedReject(reason);\n    transition?.finishedReject(reason);\n    navigation.transition = null;\n  };\n  function dispatch() {\n    navigation.navigateEvent = event;\n    const dispatchResult = navigation.eventTarget.dispatchEvent(event);\n    if (event.interceptionState === 'intercepted') {\n      if (!navigation.currentEntry) {\n        event.abort(new DOMException('Cannot create transition without a currentEntry for intercepted navigation.', 'InvalidStateError'));\n        return;\n      }\n      const transition = new InternalNavigationTransition(navigation.currentEntry, navigationType);\n      navigation.transition = transition;\n      transition.finished.catch(() => {});\n      transition.committed.catch(() => {});\n    }\n    if (!dispatchResult && event.cancelable) {\n      if (!event.abortController.signal.aborted) {\n        event.abort(new DOMException('Navigation prevented by event.preventDefault()', 'AbortError'));\n      }\n    } else {\n      if (precommitHandlers.length === 0) {\n        commit();\n      } else {\n        const precommitController = {\n          redirect\n        };\n        const precommitPromisesList = precommitHandlers.map(handler => {\n          let p;\n          try {\n            p = handler(precommitController);\n          } catch (e) {\n            p = Promise.reject(e);\n          }\n          p.catch(() => {});\n          return p;\n        });\n        Promise.all(precommitPromisesList).then(() => commit()).catch(processNavigateEventHandlerFailure);\n      }\n    }\n  }\n  dispatch();\n  return event.interceptionState === 'none';\n}\nfunction finishNavigationEvent(event, didFulfill) {\n  if (event.interceptionState === 'finished') {\n    throw new Error('Attempting to finish navigation event that was already finished');\n  }\n  if (event.interceptionState === 'intercepted') {\n    if (didFulfill === true) {\n      throw new Error('didFulfill should be false');\n    }\n    event.interceptionState = 'finished';\n    return;\n  }\n  if (event.interceptionState === 'none') {\n    return;\n  }\n  potentiallyResetFocus(event);\n  if (didFulfill) {\n    potentiallyResetScroll(event);\n  }\n  event.interceptionState = 'finished';\n}\nfunction potentiallyResetFocus(event) {\n  if (event.interceptionState !== 'committed' && event.interceptionState !== 'scrolled') {\n    throw new Error('cannot reset focus if navigation event is not committed or scrolled');\n  }\n  if (event.focusResetBehavior === 'manual') {\n    return;\n  }\n}\nfunction potentiallyResetScroll(event) {\n  if (event.interceptionState !== 'committed' && event.interceptionState !== 'scrolled') {\n    throw new Error('cannot reset scroll if navigation event is not committed or scrolled');\n  }\n  if (event.interceptionState === 'scrolled' || event.scrollBehavior === 'manual') {\n    return;\n  }\n  processScrollBehavior(event);\n}\nfunction processScrollBehavior(event) {\n  if (event.interceptionState !== 'committed') {\n    throw new Error('invalid event interception state when processing scroll behavior');\n  }\n  event.interceptionState = 'scrolled';\n}\nfunction createFakeNavigationCurrentEntryChangeEvent({\n  from,\n  navigationType\n}) {\n  const event = new Event('currententrychange', {\n    bubbles: false,\n    cancelable: false\n  });\n  event.from = from;\n  event.navigationType = navigationType;\n  return event;\n}\nfunction createPopStateEvent({\n  state\n}) {\n  const event = new Event('popstate', {\n    bubbles: false,\n    cancelable: false\n  });\n  event.state = state;\n  return event;\n}\nfunction createHashChangeEvent(newURL, oldURL) {\n  const event = new Event('hashchange', {\n    bubbles: false,\n    cancelable: false\n  });\n  event.newURL = newURL;\n  event.oldURL = oldURL;\n  return event;\n}\nclass FakeNavigationDestination {\n  url;\n  sameDocument;\n  key;\n  id;\n  index;\n  state;\n  historyState;\n  constructor({\n    url,\n    sameDocument,\n    historyState,\n    state,\n    key = null,\n    id = null,\n    index = -1\n  }) {\n    this.url = url;\n    this.sameDocument = sameDocument;\n    this.state = state;\n    this.historyState = historyState;\n    this.key = key;\n    this.id = id;\n    this.index = index;\n  }\n  getState() {\n    return this.state;\n  }\n  getHistoryState() {\n    return this.historyState;\n  }\n}\nfunction isHashChange(from, to) {\n  return to.hash !== from.hash && to.hostname === from.hostname && to.pathname === from.pathname && to.search === from.search;\n}\nclass InternalNavigationTransition {\n  from;\n  navigationType;\n  finished;\n  committed;\n  finishedResolve;\n  finishedReject;\n  committedResolve;\n  committedReject;\n  constructor(from, navigationType) {\n    this.from = from;\n    this.navigationType = navigationType;\n    this.finished = new Promise((resolve, reject) => {\n      this.finishedReject = reject;\n      this.finishedResolve = resolve;\n    });\n    this.committed = new Promise((resolve, reject) => {\n      this.committedReject = reject;\n      this.committedResolve = resolve;\n    });\n    this.finished.catch(() => {});\n    this.committed.catch(() => {});\n  }\n}\nclass InternalNavigationResult {\n  navigation;\n  committedTo = null;\n  committedResolve;\n  committedReject;\n  finishedResolve;\n  finishedReject;\n  committed;\n  finished;\n  get signal() {\n    return this.abortController.signal;\n  }\n  abortController = new AbortController();\n  constructor(navigation) {\n    this.navigation = navigation;\n    this.committed = new Promise((resolve, reject) => {\n      this.committedResolve = entry => {\n        this.committedTo = entry;\n        resolve(entry);\n      };\n      this.committedReject = reject;\n    });\n    this.finished = new Promise((resolve, reject) => {\n      this.finishedResolve = () => {\n        if (this.committedTo === null) {\n          throw new Error('NavigateEvent should have been committed before resolving finished promise.');\n        }\n        resolve(this.committedTo);\n      };\n      this.finishedReject = reason => {\n        this.committedReject(reason);\n        reject(reason);\n      };\n    });\n    this.committed.catch(() => {});\n    this.finished.catch(() => {});\n  }\n}\n\nglobalThis.beforeEach?.(getCleanupHook(false));\nglobalThis.afterEach?.(getCleanupHook(true));\nfunction getCleanupHook(expectedTeardownValue) {\n  return () => {\n    const testBed = TestBedImpl.INSTANCE;\n    if (testBed.shouldTearDownTestingModule() === expectedTeardownValue) {\n      testBed.resetTestingModule();\n      resetFakeAsyncZoneIfExists();\n    }\n  };\n}\n\nclass Log {\n  logItems;\n  constructor() {\n    this.logItems = [];\n  }\n  add(value) {\n    this.logItems.push(value);\n  }\n  fn(value) {\n    return () => {\n      this.logItems.push(value);\n    };\n  }\n  clear() {\n    this.logItems = [];\n  }\n  result() {\n    return this.logItems.join('; ');\n  }\n  static ɵfac = function Log_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || Log)();\n  };\n  static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: Log,\n    factory: Log.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Log, [{\n    type: Injectable\n  }], () => [], null);\n})();\n\nexport { ComponentFixture, ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, DeferBlockBehavior, DeferBlockFixture, DeferBlockState, InjectSetupWrapper, TestBed, TestComponentRenderer, discardPeriodicTasks, fakeAsync, flush, flushMicrotasks, getTestBed, inject, resetFakeAsyncZone, tick, waitForAsync, withModule, FakeNavigation as ɵFakeNavigation, Log as ɵLog, MetadataOverrider as ɵMetadataOverrider, getCleanupHook as ɵgetCleanupHook };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}