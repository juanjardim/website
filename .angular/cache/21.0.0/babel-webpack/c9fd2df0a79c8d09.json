{"ast":null,"code":"/**\n * @license Angular v21.0.0\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nconst _SELECTOR_REGEXP = new RegExp('(\\\\:not\\\\()|' + '(([\\\\.\\\\#]?)[-\\\\w]+)|' + '(?:\\\\[([-.\\\\w*\\\\\\\\$]+)(?:=([\"\\']?)([^\\\\]\"\\']*)\\\\5)?\\\\])|' + '(\\\\))|' + '(\\\\s*,\\\\s*)', 'g');\nclass CssSelector {\n  element = null;\n  classNames = [];\n  attrs = [];\n  notSelectors = [];\n  static parse(selector) {\n    const results = [];\n    const _addResult = (res, cssSel) => {\n      if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 && cssSel.attrs.length == 0) {\n        cssSel.element = '*';\n      }\n      res.push(cssSel);\n    };\n    let cssSelector = new CssSelector();\n    let match;\n    let current = cssSelector;\n    let inNot = false;\n    _SELECTOR_REGEXP.lastIndex = 0;\n    while (match = _SELECTOR_REGEXP.exec(selector)) {\n      if (match[1]) {\n        if (inNot) {\n          throw new Error('Nesting :not in a selector is not allowed');\n        }\n        inNot = true;\n        current = new CssSelector();\n        cssSelector.notSelectors.push(current);\n      }\n      const tag = match[2];\n      if (tag) {\n        const prefix = match[3];\n        if (prefix === '#') {\n          current.addAttribute('id', tag.slice(1));\n        } else if (prefix === '.') {\n          current.addClassName(tag.slice(1));\n        } else {\n          current.setElement(tag);\n        }\n      }\n      const attribute = match[4];\n      if (attribute) {\n        current.addAttribute(current.unescapeAttribute(attribute), match[6]);\n      }\n      if (match[7]) {\n        inNot = false;\n        current = cssSelector;\n      }\n      if (match[8]) {\n        if (inNot) {\n          throw new Error('Multiple selectors in :not are not supported');\n        }\n        _addResult(results, cssSelector);\n        cssSelector = current = new CssSelector();\n      }\n    }\n    _addResult(results, cssSelector);\n    return results;\n  }\n  unescapeAttribute(attr) {\n    let result = '';\n    let escaping = false;\n    for (let i = 0; i < attr.length; i++) {\n      const char = attr.charAt(i);\n      if (char === '\\\\') {\n        escaping = true;\n        continue;\n      }\n      if (char === '$' && !escaping) {\n        throw new Error(`Error in attribute selector \"${attr}\". ` + `Unescaped \"$\" is not supported. Please escape with \"\\\\$\".`);\n      }\n      escaping = false;\n      result += char;\n    }\n    return result;\n  }\n  escapeAttribute(attr) {\n    return attr.replace(/\\\\/g, '\\\\\\\\').replace(/\\$/g, '\\\\$');\n  }\n  isElementSelector() {\n    return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 && this.notSelectors.length === 0;\n  }\n  hasElementSelector() {\n    return !!this.element;\n  }\n  setElement(element = null) {\n    this.element = element;\n  }\n  getAttrs() {\n    const result = [];\n    if (this.classNames.length > 0) {\n      result.push('class', this.classNames.join(' '));\n    }\n    return result.concat(this.attrs);\n  }\n  addAttribute(name, value = '') {\n    this.attrs.push(name, value && value.toLowerCase() || '');\n  }\n  addClassName(name) {\n    this.classNames.push(name.toLowerCase());\n  }\n  toString() {\n    let res = this.element || '';\n    if (this.classNames) {\n      this.classNames.forEach(klass => res += `.${klass}`);\n    }\n    if (this.attrs) {\n      for (let i = 0; i < this.attrs.length; i += 2) {\n        const name = this.escapeAttribute(this.attrs[i]);\n        const value = this.attrs[i + 1];\n        res += `[${name}${value ? '=' + value : ''}]`;\n      }\n    }\n    this.notSelectors.forEach(notSelector => res += `:not(${notSelector})`);\n    return res;\n  }\n}\nclass SelectorMatcher {\n  static createNotMatcher(notSelectors) {\n    const notMatcher = new SelectorMatcher();\n    notMatcher.addSelectables(notSelectors, null);\n    return notMatcher;\n  }\n  _elementMap = new Map();\n  _elementPartialMap = new Map();\n  _classMap = new Map();\n  _classPartialMap = new Map();\n  _attrValueMap = new Map();\n  _attrValuePartialMap = new Map();\n  _listContexts = [];\n  addSelectables(cssSelectors, callbackCtxt) {\n    let listContext = null;\n    if (cssSelectors.length > 1) {\n      listContext = new SelectorListContext(cssSelectors);\n      this._listContexts.push(listContext);\n    }\n    for (let i = 0; i < cssSelectors.length; i++) {\n      this._addSelectable(cssSelectors[i], callbackCtxt, listContext);\n    }\n  }\n  _addSelectable(cssSelector, callbackCtxt, listContext) {\n    let matcher = this;\n    const element = cssSelector.element;\n    const classNames = cssSelector.classNames;\n    const attrs = cssSelector.attrs;\n    const selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n    if (element) {\n      const isTerminal = attrs.length === 0 && classNames.length === 0;\n      if (isTerminal) {\n        this._addTerminal(matcher._elementMap, element, selectable);\n      } else {\n        matcher = this._addPartial(matcher._elementPartialMap, element);\n      }\n    }\n    if (classNames) {\n      for (let i = 0; i < classNames.length; i++) {\n        const isTerminal = attrs.length === 0 && i === classNames.length - 1;\n        const className = classNames[i];\n        if (isTerminal) {\n          this._addTerminal(matcher._classMap, className, selectable);\n        } else {\n          matcher = this._addPartial(matcher._classPartialMap, className);\n        }\n      }\n    }\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i += 2) {\n        const isTerminal = i === attrs.length - 2;\n        const name = attrs[i];\n        const value = attrs[i + 1];\n        if (isTerminal) {\n          const terminalMap = matcher._attrValueMap;\n          let terminalValuesMap = terminalMap.get(name);\n          if (!terminalValuesMap) {\n            terminalValuesMap = new Map();\n            terminalMap.set(name, terminalValuesMap);\n          }\n          this._addTerminal(terminalValuesMap, value, selectable);\n        } else {\n          const partialMap = matcher._attrValuePartialMap;\n          let partialValuesMap = partialMap.get(name);\n          if (!partialValuesMap) {\n            partialValuesMap = new Map();\n            partialMap.set(name, partialValuesMap);\n          }\n          matcher = this._addPartial(partialValuesMap, value);\n        }\n      }\n    }\n  }\n  _addTerminal(map, name, selectable) {\n    let terminalList = map.get(name);\n    if (!terminalList) {\n      terminalList = [];\n      map.set(name, terminalList);\n    }\n    terminalList.push(selectable);\n  }\n  _addPartial(map, name) {\n    let matcher = map.get(name);\n    if (!matcher) {\n      matcher = new SelectorMatcher();\n      map.set(name, matcher);\n    }\n    return matcher;\n  }\n  match(cssSelector, matchedCallback) {\n    let result = false;\n    const element = cssSelector.element;\n    const classNames = cssSelector.classNames;\n    const attrs = cssSelector.attrs;\n    for (let i = 0; i < this._listContexts.length; i++) {\n      this._listContexts[i].alreadyMatched = false;\n    }\n    result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n    result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) || result;\n    if (classNames) {\n      for (let i = 0; i < classNames.length; i++) {\n        const className = classNames[i];\n        result = this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n        result = this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) || result;\n      }\n    }\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i += 2) {\n        const name = attrs[i];\n        const value = attrs[i + 1];\n        const terminalValuesMap = this._attrValueMap.get(name);\n        if (value) {\n          result = this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result = this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n        const partialValuesMap = this._attrValuePartialMap.get(name);\n        if (value) {\n          result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result = this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n      }\n    }\n    return result;\n  }\n  _matchTerminal(map, name, cssSelector, matchedCallback) {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n    let selectables = map.get(name) || [];\n    const starSelectables = map.get('*');\n    if (starSelectables) {\n      selectables = selectables.concat(starSelectables);\n    }\n    if (selectables.length === 0) {\n      return false;\n    }\n    let selectable;\n    let result = false;\n    for (let i = 0; i < selectables.length; i++) {\n      selectable = selectables[i];\n      result = selectable.finalize(cssSelector, matchedCallback) || result;\n    }\n    return result;\n  }\n  _matchPartial(map, name, cssSelector, matchedCallback) {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n    const nestedSelector = map.get(name);\n    if (!nestedSelector) {\n      return false;\n    }\n    return nestedSelector.match(cssSelector, matchedCallback);\n  }\n}\nclass SelectorListContext {\n  selectors;\n  alreadyMatched = false;\n  constructor(selectors) {\n    this.selectors = selectors;\n  }\n}\nclass SelectorContext {\n  selector;\n  cbContext;\n  listContext;\n  notSelectors;\n  constructor(selector, cbContext, listContext) {\n    this.selector = selector;\n    this.cbContext = cbContext;\n    this.listContext = listContext;\n    this.notSelectors = selector.notSelectors;\n  }\n  finalize(cssSelector, callback) {\n    let result = true;\n    if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n      const notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n      result = !notMatcher.match(cssSelector, null);\n    }\n    if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n      if (this.listContext) {\n        this.listContext.alreadyMatched = true;\n      }\n      callback(this.selector, this.cbContext);\n    }\n    return result;\n  }\n}\nclass SelectorlessMatcher {\n  registry;\n  constructor(registry) {\n    this.registry = registry;\n  }\n  match(name) {\n    return this.registry.has(name) ? this.registry.get(name) : [];\n  }\n}\nconst emitDistinctChangesOnlyDefaultValue = true;\nvar ViewEncapsulation$1;\n(function (ViewEncapsulation) {\n  ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n  ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n  ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n  ViewEncapsulation[ViewEncapsulation[\"ExperimentalIsolatedShadowDom\"] = 4] = \"ExperimentalIsolatedShadowDom\";\n})(ViewEncapsulation$1 || (ViewEncapsulation$1 = {}));\nvar ChangeDetectionStrategy;\n(function (ChangeDetectionStrategy) {\n  ChangeDetectionStrategy[ChangeDetectionStrategy[\"OnPush\"] = 0] = \"OnPush\";\n  ChangeDetectionStrategy[ChangeDetectionStrategy[\"Default\"] = 1] = \"Default\";\n})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));\nvar InputFlags;\n(function (InputFlags) {\n  InputFlags[InputFlags[\"None\"] = 0] = \"None\";\n  InputFlags[InputFlags[\"SignalBased\"] = 1] = \"SignalBased\";\n  InputFlags[InputFlags[\"HasDecoratorInputTransform\"] = 2] = \"HasDecoratorInputTransform\";\n})(InputFlags || (InputFlags = {}));\nconst CUSTOM_ELEMENTS_SCHEMA = {\n  name: 'custom-elements'\n};\nconst NO_ERRORS_SCHEMA = {\n  name: 'no-errors-schema'\n};\nconst Type$1 = Function;\nvar SecurityContext;\n(function (SecurityContext) {\n  SecurityContext[SecurityContext[\"NONE\"] = 0] = \"NONE\";\n  SecurityContext[SecurityContext[\"HTML\"] = 1] = \"HTML\";\n  SecurityContext[SecurityContext[\"STYLE\"] = 2] = \"STYLE\";\n  SecurityContext[SecurityContext[\"SCRIPT\"] = 3] = \"SCRIPT\";\n  SecurityContext[SecurityContext[\"URL\"] = 4] = \"URL\";\n  SecurityContext[SecurityContext[\"RESOURCE_URL\"] = 5] = \"RESOURCE_URL\";\n})(SecurityContext || (SecurityContext = {}));\nvar MissingTranslationStrategy;\n(function (MissingTranslationStrategy) {\n  MissingTranslationStrategy[MissingTranslationStrategy[\"Error\"] = 0] = \"Error\";\n  MissingTranslationStrategy[MissingTranslationStrategy[\"Warning\"] = 1] = \"Warning\";\n  MissingTranslationStrategy[MissingTranslationStrategy[\"Ignore\"] = 2] = \"Ignore\";\n})(MissingTranslationStrategy || (MissingTranslationStrategy = {}));\nfunction parserSelectorToSimpleSelector(selector) {\n  const classes = selector.classNames && selector.classNames.length ? [8, ...selector.classNames] : [];\n  const elementName = selector.element && selector.element !== '*' ? selector.element : '';\n  return [elementName, ...selector.attrs, ...classes];\n}\nfunction parserSelectorToNegativeSelector(selector) {\n  const classes = selector.classNames && selector.classNames.length ? [8, ...selector.classNames] : [];\n  if (selector.element) {\n    return [1 | 4, selector.element, ...selector.attrs, ...classes];\n  } else if (selector.attrs.length) {\n    return [1 | 2, ...selector.attrs, ...classes];\n  } else {\n    return selector.classNames && selector.classNames.length ? [1 | 8, ...selector.classNames] : [];\n  }\n}\nfunction parserSelectorToR3Selector(selector) {\n  const positive = parserSelectorToSimpleSelector(selector);\n  const negative = selector.notSelectors && selector.notSelectors.length ? selector.notSelectors.map(notSelector => parserSelectorToNegativeSelector(notSelector)) : [];\n  return positive.concat(...negative);\n}\nfunction parseSelectorToR3Selector(selector) {\n  return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];\n}\nvar core = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  CUSTOM_ELEMENTS_SCHEMA: CUSTOM_ELEMENTS_SCHEMA,\n  get ChangeDetectionStrategy() {\n    return ChangeDetectionStrategy;\n  },\n  get InputFlags() {\n    return InputFlags;\n  },\n  get MissingTranslationStrategy() {\n    return MissingTranslationStrategy;\n  },\n  NO_ERRORS_SCHEMA: NO_ERRORS_SCHEMA,\n  get SecurityContext() {\n    return SecurityContext;\n  },\n  Type: Type$1,\n  get ViewEncapsulation() {\n    return ViewEncapsulation$1;\n  },\n  emitDistinctChangesOnlyDefaultValue: emitDistinctChangesOnlyDefaultValue,\n  parseSelectorToR3Selector: parseSelectorToR3Selector\n});\nvar FactoryTarget;\n(function (FactoryTarget) {\n  FactoryTarget[FactoryTarget[\"Directive\"] = 0] = \"Directive\";\n  FactoryTarget[FactoryTarget[\"Component\"] = 1] = \"Component\";\n  FactoryTarget[FactoryTarget[\"Injectable\"] = 2] = \"Injectable\";\n  FactoryTarget[FactoryTarget[\"Pipe\"] = 3] = \"Pipe\";\n  FactoryTarget[FactoryTarget[\"NgModule\"] = 4] = \"NgModule\";\n})(FactoryTarget || (FactoryTarget = {}));\nvar R3TemplateDependencyKind$1;\n(function (R3TemplateDependencyKind) {\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"Directive\"] = 0] = \"Directive\";\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"Pipe\"] = 1] = \"Pipe\";\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"NgModule\"] = 2] = \"NgModule\";\n})(R3TemplateDependencyKind$1 || (R3TemplateDependencyKind$1 = {}));\nvar ViewEncapsulation;\n(function (ViewEncapsulation) {\n  ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n  ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n  ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n  ViewEncapsulation[ViewEncapsulation[\"ExperimentalIsolatedShadowDom\"] = 4] = \"ExperimentalIsolatedShadowDom\";\n})(ViewEncapsulation || (ViewEncapsulation = {}));\nlet textEncoder;\nfunction digest$1(message) {\n  return message.id || computeDigest(message);\n}\nfunction computeDigest(message) {\n  return sha1(serializeNodes(message.nodes).join('') + `[${message.meaning}]`);\n}\nfunction decimalDigest(message) {\n  return message.id || computeDecimalDigest(message);\n}\nfunction computeDecimalDigest(message) {\n  const visitor = new _SerializerIgnoreIcuExpVisitor();\n  const parts = message.nodes.map(a => a.visit(visitor, null));\n  return computeMsgId(parts.join(''), message.meaning);\n}\nclass _SerializerVisitor {\n  visitText(text, context) {\n    return text.value;\n  }\n  visitContainer(container, context) {\n    return `[${container.children.map(child => child.visit(this)).join(', ')}]`;\n  }\n  visitIcu(icu, context) {\n    const strCases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n    return `{${icu.expression}, ${icu.type}, ${strCases.join(', ')}}`;\n  }\n  visitTagPlaceholder(ph, context) {\n    return ph.isVoid ? `<ph tag name=\"${ph.startName}\"/>` : `<ph tag name=\"${ph.startName}\">${ph.children.map(child => child.visit(this)).join(', ')}</ph name=\"${ph.closeName}\">`;\n  }\n  visitPlaceholder(ph, context) {\n    return ph.value ? `<ph name=\"${ph.name}\">${ph.value}</ph>` : `<ph name=\"${ph.name}\"/>`;\n  }\n  visitIcuPlaceholder(ph, context) {\n    return `<ph icu name=\"${ph.name}\">${ph.value.visit(this)}</ph>`;\n  }\n  visitBlockPlaceholder(ph, context) {\n    return `<ph block name=\"${ph.startName}\">${ph.children.map(child => child.visit(this)).join(', ')}</ph name=\"${ph.closeName}\">`;\n  }\n}\nconst serializerVisitor$1 = new _SerializerVisitor();\nfunction serializeNodes(nodes) {\n  return nodes.map(a => a.visit(serializerVisitor$1, null));\n}\nclass _SerializerIgnoreIcuExpVisitor extends _SerializerVisitor {\n  visitIcu(icu) {\n    let strCases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n    return `{${icu.type}, ${strCases.join(', ')}}`;\n  }\n}\nfunction sha1(str) {\n  textEncoder ??= new TextEncoder();\n  const utf8 = [...textEncoder.encode(str)];\n  const words32 = bytesToWords32(utf8, Endian.Big);\n  const len = utf8.length * 8;\n  const w = new Uint32Array(80);\n  let a = 0x67452301,\n    b = 0xefcdab89,\n    c = 0x98badcfe,\n    d = 0x10325476,\n    e = 0xc3d2e1f0;\n  words32[len >> 5] |= 0x80 << 24 - len % 32;\n  words32[(len + 64 >> 9 << 4) + 15] = len;\n  for (let i = 0; i < words32.length; i += 16) {\n    const h0 = a,\n      h1 = b,\n      h2 = c,\n      h3 = d,\n      h4 = e;\n    for (let j = 0; j < 80; j++) {\n      if (j < 16) {\n        w[j] = words32[i + j];\n      } else {\n        w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n      }\n      const fkVal = fk(j, b, c, d);\n      const f = fkVal[0];\n      const k = fkVal[1];\n      const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n      e = d;\n      d = c;\n      c = rol32(b, 30);\n      b = a;\n      a = temp;\n    }\n    a = add32(a, h0);\n    b = add32(b, h1);\n    c = add32(c, h2);\n    d = add32(d, h3);\n    e = add32(e, h4);\n  }\n  return toHexU32(a) + toHexU32(b) + toHexU32(c) + toHexU32(d) + toHexU32(e);\n}\nfunction toHexU32(value) {\n  return (value >>> 0).toString(16).padStart(8, '0');\n}\nfunction fk(index, b, c, d) {\n  if (index < 20) {\n    return [b & c | ~b & d, 0x5a827999];\n  }\n  if (index < 40) {\n    return [b ^ c ^ d, 0x6ed9eba1];\n  }\n  if (index < 60) {\n    return [b & c | b & d | c & d, 0x8f1bbcdc];\n  }\n  return [b ^ c ^ d, 0xca62c1d6];\n}\nfunction fingerprint(str) {\n  textEncoder ??= new TextEncoder();\n  const utf8 = textEncoder.encode(str);\n  const view = new DataView(utf8.buffer, utf8.byteOffset, utf8.byteLength);\n  let hi = hash32(view, utf8.length, 0);\n  let lo = hash32(view, utf8.length, 102072);\n  if (hi == 0 && (lo == 0 || lo == 1)) {\n    hi = hi ^ 0x130f9bef;\n    lo = lo ^ -0x6b5f56d8;\n  }\n  return BigInt.asUintN(32, BigInt(hi)) << BigInt(32) | BigInt.asUintN(32, BigInt(lo));\n}\nfunction computeMsgId(msg, meaning = '') {\n  let msgFingerprint = fingerprint(msg);\n  if (meaning) {\n    msgFingerprint = BigInt.asUintN(64, msgFingerprint << BigInt(1)) | msgFingerprint >> BigInt(63) & BigInt(1);\n    msgFingerprint += fingerprint(meaning);\n  }\n  return BigInt.asUintN(63, msgFingerprint).toString();\n}\nfunction hash32(view, length, c) {\n  let a = 0x9e3779b9,\n    b = 0x9e3779b9;\n  let index = 0;\n  const end = length - 12;\n  for (; index <= end; index += 12) {\n    a += view.getUint32(index, true);\n    b += view.getUint32(index + 4, true);\n    c += view.getUint32(index + 8, true);\n    const res = mix(a, b, c);\n    a = res[0], b = res[1], c = res[2];\n  }\n  const remainder = length - index;\n  c += length;\n  if (remainder >= 4) {\n    a += view.getUint32(index, true);\n    index += 4;\n    if (remainder >= 8) {\n      b += view.getUint32(index, true);\n      index += 4;\n      if (remainder >= 9) {\n        c += view.getUint8(index++) << 8;\n      }\n      if (remainder >= 10) {\n        c += view.getUint8(index++) << 16;\n      }\n      if (remainder === 11) {\n        c += view.getUint8(index++) << 24;\n      }\n    } else {\n      if (remainder >= 5) {\n        b += view.getUint8(index++);\n      }\n      if (remainder >= 6) {\n        b += view.getUint8(index++) << 8;\n      }\n      if (remainder === 7) {\n        b += view.getUint8(index++) << 16;\n      }\n    }\n  } else {\n    if (remainder >= 1) {\n      a += view.getUint8(index++);\n    }\n    if (remainder >= 2) {\n      a += view.getUint8(index++) << 8;\n    }\n    if (remainder === 3) {\n      a += view.getUint8(index++) << 16;\n    }\n  }\n  return mix(a, b, c)[2];\n}\nfunction mix(a, b, c) {\n  a -= b;\n  a -= c;\n  a ^= c >>> 13;\n  b -= c;\n  b -= a;\n  b ^= a << 8;\n  c -= a;\n  c -= b;\n  c ^= b >>> 13;\n  a -= b;\n  a -= c;\n  a ^= c >>> 12;\n  b -= c;\n  b -= a;\n  b ^= a << 16;\n  c -= a;\n  c -= b;\n  c ^= b >>> 5;\n  a -= b;\n  a -= c;\n  a ^= c >>> 3;\n  b -= c;\n  b -= a;\n  b ^= a << 10;\n  c -= a;\n  c -= b;\n  c ^= b >>> 15;\n  return [a, b, c];\n}\nvar Endian;\n(function (Endian) {\n  Endian[Endian[\"Little\"] = 0] = \"Little\";\n  Endian[Endian[\"Big\"] = 1] = \"Big\";\n})(Endian || (Endian = {}));\nfunction add32(a, b) {\n  return add32to64(a, b)[1];\n}\nfunction add32to64(a, b) {\n  const low = (a & 0xffff) + (b & 0xffff);\n  const high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n  return [high >>> 16, high << 16 | low & 0xffff];\n}\nfunction rol32(a, count) {\n  return a << count | a >>> 32 - count;\n}\nfunction bytesToWords32(bytes, endian) {\n  const size = bytes.length + 3 >>> 2;\n  const words32 = [];\n  for (let i = 0; i < size; i++) {\n    words32[i] = wordAt(bytes, i * 4, endian);\n  }\n  return words32;\n}\nfunction byteAt(bytes, index) {\n  return index >= bytes.length ? 0 : bytes[index];\n}\nfunction wordAt(bytes, index, endian) {\n  let word = 0;\n  if (endian === Endian.Big) {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(bytes, index + i) << 24 - 8 * i;\n    }\n  } else {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(bytes, index + i) << 8 * i;\n    }\n  }\n  return word;\n}\nvar TypeModifier;\n(function (TypeModifier) {\n  TypeModifier[TypeModifier[\"None\"] = 0] = \"None\";\n  TypeModifier[TypeModifier[\"Const\"] = 1] = \"Const\";\n})(TypeModifier || (TypeModifier = {}));\nclass Type {\n  modifiers;\n  constructor(modifiers = TypeModifier.None) {\n    this.modifiers = modifiers;\n  }\n  hasModifier(modifier) {\n    return (this.modifiers & modifier) !== 0;\n  }\n}\nvar BuiltinTypeName;\n(function (BuiltinTypeName) {\n  BuiltinTypeName[BuiltinTypeName[\"Dynamic\"] = 0] = \"Dynamic\";\n  BuiltinTypeName[BuiltinTypeName[\"Bool\"] = 1] = \"Bool\";\n  BuiltinTypeName[BuiltinTypeName[\"String\"] = 2] = \"String\";\n  BuiltinTypeName[BuiltinTypeName[\"Int\"] = 3] = \"Int\";\n  BuiltinTypeName[BuiltinTypeName[\"Number\"] = 4] = \"Number\";\n  BuiltinTypeName[BuiltinTypeName[\"Function\"] = 5] = \"Function\";\n  BuiltinTypeName[BuiltinTypeName[\"Inferred\"] = 6] = \"Inferred\";\n  BuiltinTypeName[BuiltinTypeName[\"None\"] = 7] = \"None\";\n})(BuiltinTypeName || (BuiltinTypeName = {}));\nclass BuiltinType extends Type {\n  name;\n  constructor(name, modifiers) {\n    super(modifiers);\n    this.name = name;\n  }\n  visitType(visitor, context) {\n    return visitor.visitBuiltinType(this, context);\n  }\n}\nclass ExpressionType extends Type {\n  value;\n  typeParams;\n  constructor(value, modifiers, typeParams = null) {\n    super(modifiers);\n    this.value = value;\n    this.typeParams = typeParams;\n  }\n  visitType(visitor, context) {\n    return visitor.visitExpressionType(this, context);\n  }\n}\nclass ArrayType extends Type {\n  of;\n  constructor(of, modifiers) {\n    super(modifiers);\n    this.of = of;\n  }\n  visitType(visitor, context) {\n    return visitor.visitArrayType(this, context);\n  }\n}\nclass MapType extends Type {\n  valueType;\n  constructor(valueType, modifiers) {\n    super(modifiers);\n    this.valueType = valueType || null;\n  }\n  visitType(visitor, context) {\n    return visitor.visitMapType(this, context);\n  }\n}\nclass TransplantedType extends Type {\n  type;\n  constructor(type, modifiers) {\n    super(modifiers);\n    this.type = type;\n  }\n  visitType(visitor, context) {\n    return visitor.visitTransplantedType(this, context);\n  }\n}\nconst DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\nconst INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\nconst BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\nconst INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\nconst NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\nconst STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\nconst FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\nconst NONE_TYPE = new BuiltinType(BuiltinTypeName.None);\nvar UnaryOperator;\n(function (UnaryOperator) {\n  UnaryOperator[UnaryOperator[\"Minus\"] = 0] = \"Minus\";\n  UnaryOperator[UnaryOperator[\"Plus\"] = 1] = \"Plus\";\n})(UnaryOperator || (UnaryOperator = {}));\nvar BinaryOperator;\n(function (BinaryOperator) {\n  BinaryOperator[BinaryOperator[\"Equals\"] = 0] = \"Equals\";\n  BinaryOperator[BinaryOperator[\"NotEquals\"] = 1] = \"NotEquals\";\n  BinaryOperator[BinaryOperator[\"Assign\"] = 2] = \"Assign\";\n  BinaryOperator[BinaryOperator[\"Identical\"] = 3] = \"Identical\";\n  BinaryOperator[BinaryOperator[\"NotIdentical\"] = 4] = \"NotIdentical\";\n  BinaryOperator[BinaryOperator[\"Minus\"] = 5] = \"Minus\";\n  BinaryOperator[BinaryOperator[\"Plus\"] = 6] = \"Plus\";\n  BinaryOperator[BinaryOperator[\"Divide\"] = 7] = \"Divide\";\n  BinaryOperator[BinaryOperator[\"Multiply\"] = 8] = \"Multiply\";\n  BinaryOperator[BinaryOperator[\"Modulo\"] = 9] = \"Modulo\";\n  BinaryOperator[BinaryOperator[\"And\"] = 10] = \"And\";\n  BinaryOperator[BinaryOperator[\"Or\"] = 11] = \"Or\";\n  BinaryOperator[BinaryOperator[\"BitwiseOr\"] = 12] = \"BitwiseOr\";\n  BinaryOperator[BinaryOperator[\"BitwiseAnd\"] = 13] = \"BitwiseAnd\";\n  BinaryOperator[BinaryOperator[\"Lower\"] = 14] = \"Lower\";\n  BinaryOperator[BinaryOperator[\"LowerEquals\"] = 15] = \"LowerEquals\";\n  BinaryOperator[BinaryOperator[\"Bigger\"] = 16] = \"Bigger\";\n  BinaryOperator[BinaryOperator[\"BiggerEquals\"] = 17] = \"BiggerEquals\";\n  BinaryOperator[BinaryOperator[\"NullishCoalesce\"] = 18] = \"NullishCoalesce\";\n  BinaryOperator[BinaryOperator[\"Exponentiation\"] = 19] = \"Exponentiation\";\n  BinaryOperator[BinaryOperator[\"In\"] = 20] = \"In\";\n  BinaryOperator[BinaryOperator[\"AdditionAssignment\"] = 21] = \"AdditionAssignment\";\n  BinaryOperator[BinaryOperator[\"SubtractionAssignment\"] = 22] = \"SubtractionAssignment\";\n  BinaryOperator[BinaryOperator[\"MultiplicationAssignment\"] = 23] = \"MultiplicationAssignment\";\n  BinaryOperator[BinaryOperator[\"DivisionAssignment\"] = 24] = \"DivisionAssignment\";\n  BinaryOperator[BinaryOperator[\"RemainderAssignment\"] = 25] = \"RemainderAssignment\";\n  BinaryOperator[BinaryOperator[\"ExponentiationAssignment\"] = 26] = \"ExponentiationAssignment\";\n  BinaryOperator[BinaryOperator[\"AndAssignment\"] = 27] = \"AndAssignment\";\n  BinaryOperator[BinaryOperator[\"OrAssignment\"] = 28] = \"OrAssignment\";\n  BinaryOperator[BinaryOperator[\"NullishCoalesceAssignment\"] = 29] = \"NullishCoalesceAssignment\";\n})(BinaryOperator || (BinaryOperator = {}));\nfunction nullSafeIsEquivalent(base, other) {\n  if (base == null || other == null) {\n    return base == other;\n  }\n  return base.isEquivalent(other);\n}\nfunction areAllEquivalentPredicate(base, other, equivalentPredicate) {\n  const len = base.length;\n  if (len !== other.length) {\n    return false;\n  }\n  for (let i = 0; i < len; i++) {\n    if (!equivalentPredicate(base[i], other[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction areAllEquivalent(base, other) {\n  return areAllEquivalentPredicate(base, other, (baseElement, otherElement) => baseElement.isEquivalent(otherElement));\n}\nclass Expression {\n  type;\n  sourceSpan;\n  constructor(type, sourceSpan) {\n    this.type = type || null;\n    this.sourceSpan = sourceSpan || null;\n  }\n  prop(name, sourceSpan) {\n    return new ReadPropExpr(this, name, null, sourceSpan);\n  }\n  key(index, type, sourceSpan) {\n    return new ReadKeyExpr(this, index, type, sourceSpan);\n  }\n  callFn(params, sourceSpan, pure) {\n    return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);\n  }\n  instantiate(params, type, sourceSpan) {\n    return new InstantiateExpr(this, params, type, sourceSpan);\n  }\n  conditional(trueCase, falseCase = null, sourceSpan) {\n    return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n  }\n  equals(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n  }\n  notEquals(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n  }\n  identical(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n  }\n  notIdentical(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n  }\n  minus(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n  }\n  plus(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n  }\n  divide(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n  }\n  multiply(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n  }\n  modulo(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n  }\n  power(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Exponentiation, this, rhs, null, sourceSpan);\n  }\n  and(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n  }\n  bitwiseOr(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.BitwiseOr, this, rhs, null, sourceSpan);\n  }\n  bitwiseAnd(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan);\n  }\n  or(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n  }\n  lower(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n  }\n  lowerEquals(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n  }\n  bigger(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n  }\n  biggerEquals(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n  }\n  isBlank(sourceSpan) {\n    return this.equals(TYPED_NULL_EXPR, sourceSpan);\n  }\n  nullishCoalesce(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.NullishCoalesce, this, rhs, null, sourceSpan);\n  }\n  toStmt() {\n    return new ExpressionStatement(this, null);\n  }\n}\nclass ReadVarExpr extends Expression {\n  name;\n  constructor(name, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.name = name;\n  }\n  isEquivalent(e) {\n    return e instanceof ReadVarExpr && this.name === e.name;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitReadVarExpr(this, context);\n  }\n  clone() {\n    return new ReadVarExpr(this.name, this.type, this.sourceSpan);\n  }\n  set(value) {\n    return new BinaryOperatorExpr(BinaryOperator.Assign, this, value, null, this.sourceSpan);\n  }\n}\nclass TypeofExpr extends Expression {\n  expr;\n  constructor(expr, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.expr = expr;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitTypeofExpr(this, context);\n  }\n  isEquivalent(e) {\n    return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);\n  }\n  isConstant() {\n    return this.expr.isConstant();\n  }\n  clone() {\n    return new TypeofExpr(this.expr.clone());\n  }\n}\nclass VoidExpr extends Expression {\n  expr;\n  constructor(expr, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.expr = expr;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitVoidExpr(this, context);\n  }\n  isEquivalent(e) {\n    return e instanceof VoidExpr && e.expr.isEquivalent(this.expr);\n  }\n  isConstant() {\n    return this.expr.isConstant();\n  }\n  clone() {\n    return new VoidExpr(this.expr.clone());\n  }\n}\nclass WrappedNodeExpr extends Expression {\n  node;\n  constructor(node, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.node = node;\n  }\n  isEquivalent(e) {\n    return e instanceof WrappedNodeExpr && this.node === e.node;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitWrappedNodeExpr(this, context);\n  }\n  clone() {\n    return new WrappedNodeExpr(this.node, this.type, this.sourceSpan);\n  }\n}\nclass InvokeFunctionExpr extends Expression {\n  fn;\n  args;\n  pure;\n  constructor(fn, args, type, sourceSpan, pure = false) {\n    super(type, sourceSpan);\n    this.fn = fn;\n    this.args = args;\n    this.pure = pure;\n  }\n  get receiver() {\n    return this.fn;\n  }\n  isEquivalent(e) {\n    return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) && areAllEquivalent(this.args, e.args) && this.pure === e.pure;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitInvokeFunctionExpr(this, context);\n  }\n  clone() {\n    return new InvokeFunctionExpr(this.fn.clone(), this.args.map(arg => arg.clone()), this.type, this.sourceSpan, this.pure);\n  }\n}\nclass TaggedTemplateLiteralExpr extends Expression {\n  tag;\n  template;\n  constructor(tag, template, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.tag = tag;\n    this.template = template;\n  }\n  isEquivalent(e) {\n    return e instanceof TaggedTemplateLiteralExpr && this.tag.isEquivalent(e.tag) && this.template.isEquivalent(e.template);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitTaggedTemplateLiteralExpr(this, context);\n  }\n  clone() {\n    return new TaggedTemplateLiteralExpr(this.tag.clone(), this.template.clone(), this.type, this.sourceSpan);\n  }\n}\nclass InstantiateExpr extends Expression {\n  classExpr;\n  args;\n  constructor(classExpr, args, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.classExpr = classExpr;\n    this.args = args;\n  }\n  isEquivalent(e) {\n    return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) && areAllEquivalent(this.args, e.args);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitInstantiateExpr(this, context);\n  }\n  clone() {\n    return new InstantiateExpr(this.classExpr.clone(), this.args.map(arg => arg.clone()), this.type, this.sourceSpan);\n  }\n}\nclass RegularExpressionLiteralExpr extends Expression {\n  body;\n  flags;\n  constructor(body, flags, sourceSpan) {\n    super(null, sourceSpan);\n    this.body = body;\n    this.flags = flags;\n  }\n  isEquivalent(e) {\n    return e instanceof RegularExpressionLiteralExpr && this.body === e.body && this.flags === e.flags;\n  }\n  isConstant() {\n    return true;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitRegularExpressionLiteral(this, context);\n  }\n  clone() {\n    return new RegularExpressionLiteralExpr(this.body, this.flags, this.sourceSpan);\n  }\n}\nclass LiteralExpr extends Expression {\n  value;\n  constructor(value, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.value = value;\n  }\n  isEquivalent(e) {\n    return e instanceof LiteralExpr && this.value === e.value;\n  }\n  isConstant() {\n    return true;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitLiteralExpr(this, context);\n  }\n  clone() {\n    return new LiteralExpr(this.value, this.type, this.sourceSpan);\n  }\n}\nclass TemplateLiteralExpr extends Expression {\n  elements;\n  expressions;\n  constructor(elements, expressions, sourceSpan) {\n    super(null, sourceSpan);\n    this.elements = elements;\n    this.expressions = expressions;\n  }\n  isEquivalent(e) {\n    return e instanceof TemplateLiteralExpr && areAllEquivalentPredicate(this.elements, e.elements, (a, b) => a.text === b.text) && areAllEquivalent(this.expressions, e.expressions);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitTemplateLiteralExpr(this, context);\n  }\n  clone() {\n    return new TemplateLiteralExpr(this.elements.map(el => el.clone()), this.expressions.map(expr => expr.clone()));\n  }\n}\nclass TemplateLiteralElementExpr extends Expression {\n  text;\n  rawText;\n  constructor(text, sourceSpan, rawText) {\n    super(STRING_TYPE, sourceSpan);\n    this.text = text;\n    this.rawText = rawText ?? escapeForTemplateLiteral(escapeSlashes(text));\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitTemplateLiteralElementExpr(this, context);\n  }\n  isEquivalent(e) {\n    return e instanceof TemplateLiteralElementExpr && e.text === this.text && e.rawText === this.rawText;\n  }\n  isConstant() {\n    return true;\n  }\n  clone() {\n    return new TemplateLiteralElementExpr(this.text, this.sourceSpan, this.rawText);\n  }\n}\nclass LiteralPiece {\n  text;\n  sourceSpan;\n  constructor(text, sourceSpan) {\n    this.text = text;\n    this.sourceSpan = sourceSpan;\n  }\n}\nclass PlaceholderPiece {\n  text;\n  sourceSpan;\n  associatedMessage;\n  constructor(text, sourceSpan, associatedMessage) {\n    this.text = text;\n    this.sourceSpan = sourceSpan;\n    this.associatedMessage = associatedMessage;\n  }\n}\nconst MEANING_SEPARATOR$1 = '|';\nconst ID_SEPARATOR$1 = '@@';\nconst LEGACY_ID_INDICATOR = 'âŸ';\nclass LocalizedString extends Expression {\n  metaBlock;\n  messageParts;\n  placeHolderNames;\n  expressions;\n  constructor(metaBlock, messageParts, placeHolderNames, expressions, sourceSpan) {\n    super(STRING_TYPE, sourceSpan);\n    this.metaBlock = metaBlock;\n    this.messageParts = messageParts;\n    this.placeHolderNames = placeHolderNames;\n    this.expressions = expressions;\n  }\n  isEquivalent(e) {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitLocalizedString(this, context);\n  }\n  clone() {\n    return new LocalizedString(this.metaBlock, this.messageParts, this.placeHolderNames, this.expressions.map(expr => expr.clone()), this.sourceSpan);\n  }\n  serializeI18nHead() {\n    let metaBlock = this.metaBlock.description || '';\n    if (this.metaBlock.meaning) {\n      metaBlock = `${this.metaBlock.meaning}${MEANING_SEPARATOR$1}${metaBlock}`;\n    }\n    if (this.metaBlock.customId) {\n      metaBlock = `${metaBlock}${ID_SEPARATOR$1}${this.metaBlock.customId}`;\n    }\n    if (this.metaBlock.legacyIds) {\n      this.metaBlock.legacyIds.forEach(legacyId => {\n        metaBlock = `${metaBlock}${LEGACY_ID_INDICATOR}${legacyId}`;\n      });\n    }\n    return createCookedRawString(metaBlock, this.messageParts[0].text, this.getMessagePartSourceSpan(0));\n  }\n  getMessagePartSourceSpan(i) {\n    return this.messageParts[i]?.sourceSpan ?? this.sourceSpan;\n  }\n  getPlaceholderSourceSpan(i) {\n    return this.placeHolderNames[i]?.sourceSpan ?? this.expressions[i]?.sourceSpan ?? this.sourceSpan;\n  }\n  serializeI18nTemplatePart(partIndex) {\n    const placeholder = this.placeHolderNames[partIndex - 1];\n    const messagePart = this.messageParts[partIndex];\n    let metaBlock = placeholder.text;\n    if (placeholder.associatedMessage?.legacyIds.length === 0) {\n      metaBlock += `${ID_SEPARATOR$1}${computeMsgId(placeholder.associatedMessage.messageString, placeholder.associatedMessage.meaning)}`;\n    }\n    return createCookedRawString(metaBlock, messagePart.text, this.getMessagePartSourceSpan(partIndex));\n  }\n}\nconst escapeSlashes = str => str.replace(/\\\\/g, '\\\\\\\\');\nconst escapeStartingColon = str => str.replace(/^:/, '\\\\:');\nconst escapeColons = str => str.replace(/:/g, '\\\\:');\nconst escapeForTemplateLiteral = str => str.replace(/`/g, '\\\\`').replace(/\\${/g, '$\\\\{');\nfunction createCookedRawString(metaBlock, messagePart, range) {\n  if (metaBlock === '') {\n    return {\n      cooked: messagePart,\n      raw: escapeForTemplateLiteral(escapeStartingColon(escapeSlashes(messagePart))),\n      range\n    };\n  } else {\n    return {\n      cooked: `:${metaBlock}:${messagePart}`,\n      raw: escapeForTemplateLiteral(`:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`),\n      range\n    };\n  }\n}\nclass ExternalExpr extends Expression {\n  value;\n  typeParams;\n  constructor(value, type, typeParams = null, sourceSpan) {\n    super(type, sourceSpan);\n    this.value = value;\n    this.typeParams = typeParams;\n  }\n  isEquivalent(e) {\n    return e instanceof ExternalExpr && this.value.name === e.value.name && this.value.moduleName === e.value.moduleName;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitExternalExpr(this, context);\n  }\n  clone() {\n    return new ExternalExpr(this.value, this.type, this.typeParams, this.sourceSpan);\n  }\n}\nclass ExternalReference {\n  moduleName;\n  name;\n  constructor(moduleName, name) {\n    this.moduleName = moduleName;\n    this.name = name;\n  }\n}\nclass ConditionalExpr extends Expression {\n  condition;\n  falseCase;\n  trueCase;\n  constructor(condition, trueCase, falseCase = null, type, sourceSpan) {\n    super(type || trueCase.type, sourceSpan);\n    this.condition = condition;\n    this.falseCase = falseCase;\n    this.trueCase = trueCase;\n  }\n  isEquivalent(e) {\n    return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) && this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitConditionalExpr(this, context);\n  }\n  clone() {\n    return new ConditionalExpr(this.condition.clone(), this.trueCase.clone(), this.falseCase?.clone(), this.type, this.sourceSpan);\n  }\n}\nclass DynamicImportExpr extends Expression {\n  url;\n  urlComment;\n  constructor(url, sourceSpan, urlComment) {\n    super(null, sourceSpan);\n    this.url = url;\n    this.urlComment = urlComment;\n  }\n  isEquivalent(e) {\n    return e instanceof DynamicImportExpr && this.url === e.url && this.urlComment === e.urlComment;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitDynamicImportExpr(this, context);\n  }\n  clone() {\n    return new DynamicImportExpr(typeof this.url === 'string' ? this.url : this.url.clone(), this.sourceSpan, this.urlComment);\n  }\n}\nclass NotExpr extends Expression {\n  condition;\n  constructor(condition, sourceSpan) {\n    super(BOOL_TYPE, sourceSpan);\n    this.condition = condition;\n  }\n  isEquivalent(e) {\n    return e instanceof NotExpr && this.condition.isEquivalent(e.condition);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitNotExpr(this, context);\n  }\n  clone() {\n    return new NotExpr(this.condition.clone(), this.sourceSpan);\n  }\n}\nclass FnParam {\n  name;\n  type;\n  constructor(name, type = null) {\n    this.name = name;\n    this.type = type;\n  }\n  isEquivalent(param) {\n    return this.name === param.name;\n  }\n  clone() {\n    return new FnParam(this.name, this.type);\n  }\n}\nclass FunctionExpr extends Expression {\n  params;\n  statements;\n  name;\n  constructor(params, statements, type, sourceSpan, name) {\n    super(type, sourceSpan);\n    this.params = params;\n    this.statements = statements;\n    this.name = name;\n  }\n  isEquivalent(e) {\n    return (e instanceof FunctionExpr || e instanceof DeclareFunctionStmt) && areAllEquivalent(this.params, e.params) && areAllEquivalent(this.statements, e.statements);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitFunctionExpr(this, context);\n  }\n  toDeclStmt(name, modifiers) {\n    return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\n  }\n  clone() {\n    return new FunctionExpr(this.params.map(p => p.clone()), this.statements, this.type, this.sourceSpan, this.name);\n  }\n}\nclass ArrowFunctionExpr extends Expression {\n  params;\n  body;\n  constructor(params, body, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.params = params;\n    this.body = body;\n  }\n  isEquivalent(e) {\n    if (!(e instanceof ArrowFunctionExpr) || !areAllEquivalent(this.params, e.params)) {\n      return false;\n    }\n    if (this.body instanceof Expression && e.body instanceof Expression) {\n      return this.body.isEquivalent(e.body);\n    }\n    if (Array.isArray(this.body) && Array.isArray(e.body)) {\n      return areAllEquivalent(this.body, e.body);\n    }\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitArrowFunctionExpr(this, context);\n  }\n  clone() {\n    return new ArrowFunctionExpr(this.params.map(p => p.clone()), Array.isArray(this.body) ? this.body : this.body.clone(), this.type, this.sourceSpan);\n  }\n  toDeclStmt(name, modifiers) {\n    return new DeclareVarStmt(name, this, INFERRED_TYPE, modifiers, this.sourceSpan);\n  }\n}\nclass UnaryOperatorExpr extends Expression {\n  operator;\n  expr;\n  parens;\n  constructor(operator, expr, type, sourceSpan, parens = true) {\n    super(type || NUMBER_TYPE, sourceSpan);\n    this.operator = operator;\n    this.expr = expr;\n    this.parens = parens;\n  }\n  isEquivalent(e) {\n    return e instanceof UnaryOperatorExpr && this.operator === e.operator && this.expr.isEquivalent(e.expr);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitUnaryOperatorExpr(this, context);\n  }\n  clone() {\n    return new UnaryOperatorExpr(this.operator, this.expr.clone(), this.type, this.sourceSpan, this.parens);\n  }\n}\nclass ParenthesizedExpr extends Expression {\n  expr;\n  constructor(expr, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.expr = expr;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitParenthesizedExpr(this, context);\n  }\n  isEquivalent(e) {\n    return e instanceof ParenthesizedExpr && e.expr.isEquivalent(this.expr);\n  }\n  isConstant() {\n    return this.expr.isConstant();\n  }\n  clone() {\n    return new ParenthesizedExpr(this.expr.clone());\n  }\n}\nclass BinaryOperatorExpr extends Expression {\n  operator;\n  rhs;\n  lhs;\n  constructor(operator, lhs, rhs, type, sourceSpan) {\n    super(type || lhs.type, sourceSpan);\n    this.operator = operator;\n    this.rhs = rhs;\n    this.lhs = lhs;\n  }\n  isEquivalent(e) {\n    return e instanceof BinaryOperatorExpr && this.operator === e.operator && this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitBinaryOperatorExpr(this, context);\n  }\n  clone() {\n    return new BinaryOperatorExpr(this.operator, this.lhs.clone(), this.rhs.clone(), this.type, this.sourceSpan);\n  }\n  isAssignment() {\n    const op = this.operator;\n    return op === BinaryOperator.Assign || op === BinaryOperator.AdditionAssignment || op === BinaryOperator.SubtractionAssignment || op === BinaryOperator.MultiplicationAssignment || op === BinaryOperator.DivisionAssignment || op === BinaryOperator.RemainderAssignment || op === BinaryOperator.ExponentiationAssignment || op === BinaryOperator.AndAssignment || op === BinaryOperator.OrAssignment || op === BinaryOperator.NullishCoalesceAssignment;\n  }\n}\nclass ReadPropExpr extends Expression {\n  receiver;\n  name;\n  constructor(receiver, name, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.receiver = receiver;\n    this.name = name;\n  }\n  get index() {\n    return this.name;\n  }\n  isEquivalent(e) {\n    return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitReadPropExpr(this, context);\n  }\n  set(value) {\n    return new BinaryOperatorExpr(BinaryOperator.Assign, this.receiver.prop(this.name), value, null, this.sourceSpan);\n  }\n  clone() {\n    return new ReadPropExpr(this.receiver.clone(), this.name, this.type, this.sourceSpan);\n  }\n}\nclass ReadKeyExpr extends Expression {\n  receiver;\n  index;\n  constructor(receiver, index, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.receiver = receiver;\n    this.index = index;\n  }\n  isEquivalent(e) {\n    return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) && this.index.isEquivalent(e.index);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitReadKeyExpr(this, context);\n  }\n  set(value) {\n    return new BinaryOperatorExpr(BinaryOperator.Assign, this.receiver.key(this.index), value, null, this.sourceSpan);\n  }\n  clone() {\n    return new ReadKeyExpr(this.receiver.clone(), this.index.clone(), this.type, this.sourceSpan);\n  }\n}\nclass LiteralArrayExpr extends Expression {\n  entries;\n  constructor(entries, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.entries = entries;\n  }\n  isConstant() {\n    return this.entries.every(e => e.isConstant());\n  }\n  isEquivalent(e) {\n    return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitLiteralArrayExpr(this, context);\n  }\n  clone() {\n    return new LiteralArrayExpr(this.entries.map(e => e.clone()), this.type, this.sourceSpan);\n  }\n}\nclass LiteralMapEntry {\n  key;\n  value;\n  quoted;\n  constructor(key, value, quoted) {\n    this.key = key;\n    this.value = value;\n    this.quoted = quoted;\n  }\n  isEquivalent(e) {\n    return this.key === e.key && this.value.isEquivalent(e.value);\n  }\n  clone() {\n    return new LiteralMapEntry(this.key, this.value.clone(), this.quoted);\n  }\n}\nclass LiteralMapExpr extends Expression {\n  entries;\n  valueType = null;\n  constructor(entries, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.entries = entries;\n    if (type) {\n      this.valueType = type.valueType;\n    }\n  }\n  isEquivalent(e) {\n    return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);\n  }\n  isConstant() {\n    return this.entries.every(e => e.value.isConstant());\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitLiteralMapExpr(this, context);\n  }\n  clone() {\n    const entriesClone = this.entries.map(entry => entry.clone());\n    return new LiteralMapExpr(entriesClone, this.type, this.sourceSpan);\n  }\n}\nclass CommaExpr extends Expression {\n  parts;\n  constructor(parts, sourceSpan) {\n    super(parts[parts.length - 1].type, sourceSpan);\n    this.parts = parts;\n  }\n  isEquivalent(e) {\n    return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitCommaExpr(this, context);\n  }\n  clone() {\n    return new CommaExpr(this.parts.map(p => p.clone()));\n  }\n}\nconst NULL_EXPR = new LiteralExpr(null, null, null);\nconst TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);\nvar StmtModifier;\n(function (StmtModifier) {\n  StmtModifier[StmtModifier[\"None\"] = 0] = \"None\";\n  StmtModifier[StmtModifier[\"Final\"] = 1] = \"Final\";\n  StmtModifier[StmtModifier[\"Private\"] = 2] = \"Private\";\n  StmtModifier[StmtModifier[\"Exported\"] = 4] = \"Exported\";\n  StmtModifier[StmtModifier[\"Static\"] = 8] = \"Static\";\n})(StmtModifier || (StmtModifier = {}));\nclass LeadingComment {\n  text;\n  multiline;\n  trailingNewline;\n  constructor(text, multiline, trailingNewline) {\n    this.text = text;\n    this.multiline = multiline;\n    this.trailingNewline = trailingNewline;\n  }\n  toString() {\n    return this.multiline ? ` ${this.text} ` : this.text;\n  }\n}\nclass JSDocComment extends LeadingComment {\n  tags;\n  constructor(tags) {\n    super('', true, true);\n    this.tags = tags;\n  }\n  toString() {\n    return serializeTags(this.tags);\n  }\n}\nclass Statement {\n  modifiers;\n  sourceSpan;\n  leadingComments;\n  constructor(modifiers = StmtModifier.None, sourceSpan = null, leadingComments) {\n    this.modifiers = modifiers;\n    this.sourceSpan = sourceSpan;\n    this.leadingComments = leadingComments;\n  }\n  hasModifier(modifier) {\n    return (this.modifiers & modifier) !== 0;\n  }\n  addLeadingComment(leadingComment) {\n    this.leadingComments = this.leadingComments ?? [];\n    this.leadingComments.push(leadingComment);\n  }\n}\nclass DeclareVarStmt extends Statement {\n  name;\n  value;\n  type;\n  constructor(name, value, type, modifiers, sourceSpan, leadingComments) {\n    super(modifiers, sourceSpan, leadingComments);\n    this.name = name;\n    this.value = value;\n    this.type = type || value && value.type || null;\n  }\n  isEquivalent(stmt) {\n    return stmt instanceof DeclareVarStmt && this.name === stmt.name && (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);\n  }\n  visitStatement(visitor, context) {\n    return visitor.visitDeclareVarStmt(this, context);\n  }\n}\nclass DeclareFunctionStmt extends Statement {\n  name;\n  params;\n  statements;\n  type;\n  constructor(name, params, statements, type, modifiers, sourceSpan, leadingComments) {\n    super(modifiers, sourceSpan, leadingComments);\n    this.name = name;\n    this.params = params;\n    this.statements = statements;\n    this.type = type || null;\n  }\n  isEquivalent(stmt) {\n    return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) && areAllEquivalent(this.statements, stmt.statements);\n  }\n  visitStatement(visitor, context) {\n    return visitor.visitDeclareFunctionStmt(this, context);\n  }\n}\nclass ExpressionStatement extends Statement {\n  expr;\n  constructor(expr, sourceSpan, leadingComments) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n    this.expr = expr;\n  }\n  isEquivalent(stmt) {\n    return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);\n  }\n  visitStatement(visitor, context) {\n    return visitor.visitExpressionStmt(this, context);\n  }\n}\nclass ReturnStatement extends Statement {\n  value;\n  constructor(value, sourceSpan = null, leadingComments) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n    this.value = value;\n  }\n  isEquivalent(stmt) {\n    return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);\n  }\n  visitStatement(visitor, context) {\n    return visitor.visitReturnStmt(this, context);\n  }\n}\nclass IfStmt extends Statement {\n  condition;\n  trueCase;\n  falseCase;\n  constructor(condition, trueCase, falseCase = [], sourceSpan, leadingComments) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n    this.condition = condition;\n    this.trueCase = trueCase;\n    this.falseCase = falseCase;\n  }\n  isEquivalent(stmt) {\n    return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) && areAllEquivalent(this.trueCase, stmt.trueCase) && areAllEquivalent(this.falseCase, stmt.falseCase);\n  }\n  visitStatement(visitor, context) {\n    return visitor.visitIfStmt(this, context);\n  }\n}\nlet RecursiveAstVisitor$1 = class RecursiveAstVisitor {\n  visitType(ast, context) {\n    return ast;\n  }\n  visitExpression(ast, context) {\n    if (ast.type) {\n      ast.type.visitType(this, context);\n    }\n    return ast;\n  }\n  visitBuiltinType(type, context) {\n    return this.visitType(type, context);\n  }\n  visitExpressionType(type, context) {\n    type.value.visitExpression(this, context);\n    if (type.typeParams !== null) {\n      type.typeParams.forEach(param => this.visitType(param, context));\n    }\n    return this.visitType(type, context);\n  }\n  visitArrayType(type, context) {\n    return this.visitType(type, context);\n  }\n  visitMapType(type, context) {\n    return this.visitType(type, context);\n  }\n  visitTransplantedType(type, context) {\n    return type;\n  }\n  visitWrappedNodeExpr(ast, context) {\n    return ast;\n  }\n  visitReadVarExpr(ast, context) {\n    return this.visitExpression(ast, context);\n  }\n  visitDynamicImportExpr(ast, context) {\n    return this.visitExpression(ast, context);\n  }\n  visitInvokeFunctionExpr(ast, context) {\n    ast.fn.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTaggedTemplateLiteralExpr(ast, context) {\n    ast.tag.visitExpression(this, context);\n    ast.template.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitInstantiateExpr(ast, context) {\n    ast.classExpr.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralExpr(ast, context) {\n    return this.visitExpression(ast, context);\n  }\n  visitRegularExpressionLiteral(ast, context) {\n    return this.visitExpression(ast, context);\n  }\n  visitLocalizedString(ast, context) {\n    return this.visitExpression(ast, context);\n  }\n  visitExternalExpr(ast, context) {\n    if (ast.typeParams) {\n      ast.typeParams.forEach(type => type.visitType(this, context));\n    }\n    return this.visitExpression(ast, context);\n  }\n  visitConditionalExpr(ast, context) {\n    ast.condition.visitExpression(this, context);\n    ast.trueCase.visitExpression(this, context);\n    ast.falseCase.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitNotExpr(ast, context) {\n    ast.condition.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitFunctionExpr(ast, context) {\n    this.visitAllStatements(ast.statements, context);\n    return this.visitExpression(ast, context);\n  }\n  visitArrowFunctionExpr(ast, context) {\n    if (Array.isArray(ast.body)) {\n      this.visitAllStatements(ast.body, context);\n    } else {\n      ast.body.visitExpression(this, context);\n    }\n    return this.visitExpression(ast, context);\n  }\n  visitUnaryOperatorExpr(ast, context) {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTypeofExpr(ast, context) {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitVoidExpr(ast, context) {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitBinaryOperatorExpr(ast, context) {\n    ast.lhs.visitExpression(this, context);\n    ast.rhs.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitReadPropExpr(ast, context) {\n    ast.receiver.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitReadKeyExpr(ast, context) {\n    ast.receiver.visitExpression(this, context);\n    ast.index.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralArrayExpr(ast, context) {\n    this.visitAllExpressions(ast.entries, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralMapExpr(ast, context) {\n    ast.entries.forEach(entry => entry.value.visitExpression(this, context));\n    return this.visitExpression(ast, context);\n  }\n  visitCommaExpr(ast, context) {\n    this.visitAllExpressions(ast.parts, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTemplateLiteralExpr(ast, context) {\n    this.visitAllExpressions(ast.elements, context);\n    this.visitAllExpressions(ast.expressions, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTemplateLiteralElementExpr(ast, context) {\n    return this.visitExpression(ast, context);\n  }\n  visitParenthesizedExpr(ast, context) {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitAllExpressions(exprs, context) {\n    exprs.forEach(expr => expr.visitExpression(this, context));\n  }\n  visitDeclareVarStmt(stmt, context) {\n    if (stmt.value) {\n      stmt.value.visitExpression(this, context);\n    }\n    if (stmt.type) {\n      stmt.type.visitType(this, context);\n    }\n    return stmt;\n  }\n  visitDeclareFunctionStmt(stmt, context) {\n    this.visitAllStatements(stmt.statements, context);\n    if (stmt.type) {\n      stmt.type.visitType(this, context);\n    }\n    return stmt;\n  }\n  visitExpressionStmt(stmt, context) {\n    stmt.expr.visitExpression(this, context);\n    return stmt;\n  }\n  visitReturnStmt(stmt, context) {\n    stmt.value.visitExpression(this, context);\n    return stmt;\n  }\n  visitIfStmt(stmt, context) {\n    stmt.condition.visitExpression(this, context);\n    this.visitAllStatements(stmt.trueCase, context);\n    this.visitAllStatements(stmt.falseCase, context);\n    return stmt;\n  }\n  visitAllStatements(stmts, context) {\n    stmts.forEach(stmt => stmt.visitStatement(this, context));\n  }\n};\nfunction leadingComment(text, multiline = false, trailingNewline = true) {\n  return new LeadingComment(text, multiline, trailingNewline);\n}\nfunction jsDocComment(tags = []) {\n  return new JSDocComment(tags);\n}\nfunction variable(name, type, sourceSpan) {\n  return new ReadVarExpr(name, type, sourceSpan);\n}\nfunction importExpr(id, typeParams = null, sourceSpan) {\n  return new ExternalExpr(id, null, typeParams, sourceSpan);\n}\nfunction importType(id, typeParams, typeModifiers) {\n  return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\n}\nfunction expressionType(expr, typeModifiers, typeParams) {\n  return new ExpressionType(expr, typeModifiers, typeParams);\n}\nfunction transplantedType(type, typeModifiers) {\n  return new TransplantedType(type, typeModifiers);\n}\nfunction typeofExpr(expr) {\n  return new TypeofExpr(expr);\n}\nfunction literalArr(values, type, sourceSpan) {\n  return new LiteralArrayExpr(values, type, sourceSpan);\n}\nfunction literalMap(values, type = null) {\n  return new LiteralMapExpr(values.map(e => new LiteralMapEntry(e.key, e.value, e.quoted)), type, null);\n}\nfunction unary(operator, expr, type, sourceSpan) {\n  return new UnaryOperatorExpr(operator, expr, type, sourceSpan);\n}\nfunction not(expr, sourceSpan) {\n  return new NotExpr(expr, sourceSpan);\n}\nfunction fn(params, body, type, sourceSpan, name) {\n  return new FunctionExpr(params, body, type, sourceSpan, name);\n}\nfunction arrowFn(params, body, type, sourceSpan) {\n  return new ArrowFunctionExpr(params, body, type, sourceSpan);\n}\nfunction ifStmt(condition, thenClause, elseClause, sourceSpan, leadingComments) {\n  return new IfStmt(condition, thenClause, elseClause, sourceSpan, leadingComments);\n}\nfunction taggedTemplate(tag, template, type, sourceSpan) {\n  return new TaggedTemplateLiteralExpr(tag, template, type, sourceSpan);\n}\nfunction literal(value, type, sourceSpan) {\n  return new LiteralExpr(value, type, sourceSpan);\n}\nfunction localizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan) {\n  return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);\n}\nfunction isNull(exp) {\n  return exp instanceof LiteralExpr && exp.value === null;\n}\nfunction tagToString(tag) {\n  let out = '';\n  if (tag.tagName) {\n    out += ` @${tag.tagName}`;\n  }\n  if (tag.text) {\n    if (tag.text.match(/\\/\\*|\\*\\//)) {\n      throw new Error('JSDoc text cannot contain \"/*\" and \"*/\"');\n    }\n    out += ' ' + tag.text.replace(/@/g, '\\\\@');\n  }\n  return out;\n}\nfunction serializeTags(tags) {\n  if (tags.length === 0) return '';\n  if (tags.length === 1 && tags[0].tagName && !tags[0].text) {\n    return `*${tagToString(tags[0])} `;\n  }\n  let out = '*\\n';\n  for (const tag of tags) {\n    out += ' *';\n    out += tagToString(tag).replace(/\\n/g, '\\n * ');\n    out += '\\n';\n  }\n  out += ' ';\n  return out;\n}\nvar output_ast = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ArrayType: ArrayType,\n  ArrowFunctionExpr: ArrowFunctionExpr,\n  BOOL_TYPE: BOOL_TYPE,\n  get BinaryOperator() {\n    return BinaryOperator;\n  },\n  BinaryOperatorExpr: BinaryOperatorExpr,\n  BuiltinType: BuiltinType,\n  get BuiltinTypeName() {\n    return BuiltinTypeName;\n  },\n  CommaExpr: CommaExpr,\n  ConditionalExpr: ConditionalExpr,\n  DYNAMIC_TYPE: DYNAMIC_TYPE,\n  DeclareFunctionStmt: DeclareFunctionStmt,\n  DeclareVarStmt: DeclareVarStmt,\n  DynamicImportExpr: DynamicImportExpr,\n  Expression: Expression,\n  ExpressionStatement: ExpressionStatement,\n  ExpressionType: ExpressionType,\n  ExternalExpr: ExternalExpr,\n  ExternalReference: ExternalReference,\n  FUNCTION_TYPE: FUNCTION_TYPE,\n  FnParam: FnParam,\n  FunctionExpr: FunctionExpr,\n  INFERRED_TYPE: INFERRED_TYPE,\n  INT_TYPE: INT_TYPE,\n  IfStmt: IfStmt,\n  InstantiateExpr: InstantiateExpr,\n  InvokeFunctionExpr: InvokeFunctionExpr,\n  JSDocComment: JSDocComment,\n  LeadingComment: LeadingComment,\n  LiteralArrayExpr: LiteralArrayExpr,\n  LiteralExpr: LiteralExpr,\n  LiteralMapEntry: LiteralMapEntry,\n  LiteralMapExpr: LiteralMapExpr,\n  LiteralPiece: LiteralPiece,\n  LocalizedString: LocalizedString,\n  MapType: MapType,\n  NONE_TYPE: NONE_TYPE,\n  NULL_EXPR: NULL_EXPR,\n  NUMBER_TYPE: NUMBER_TYPE,\n  NotExpr: NotExpr,\n  ParenthesizedExpr: ParenthesizedExpr,\n  PlaceholderPiece: PlaceholderPiece,\n  ReadKeyExpr: ReadKeyExpr,\n  ReadPropExpr: ReadPropExpr,\n  ReadVarExpr: ReadVarExpr,\n  RecursiveAstVisitor: RecursiveAstVisitor$1,\n  RegularExpressionLiteralExpr: RegularExpressionLiteralExpr,\n  ReturnStatement: ReturnStatement,\n  STRING_TYPE: STRING_TYPE,\n  Statement: Statement,\n  get StmtModifier() {\n    return StmtModifier;\n  },\n  TYPED_NULL_EXPR: TYPED_NULL_EXPR,\n  TaggedTemplateLiteralExpr: TaggedTemplateLiteralExpr,\n  TemplateLiteralElementExpr: TemplateLiteralElementExpr,\n  TemplateLiteralExpr: TemplateLiteralExpr,\n  TransplantedType: TransplantedType,\n  Type: Type,\n  get TypeModifier() {\n    return TypeModifier;\n  },\n  TypeofExpr: TypeofExpr,\n  get UnaryOperator() {\n    return UnaryOperator;\n  },\n  UnaryOperatorExpr: UnaryOperatorExpr,\n  VoidExpr: VoidExpr,\n  WrappedNodeExpr: WrappedNodeExpr,\n  areAllEquivalent: areAllEquivalent,\n  arrowFn: arrowFn,\n  expressionType: expressionType,\n  fn: fn,\n  ifStmt: ifStmt,\n  importExpr: importExpr,\n  importType: importType,\n  isNull: isNull,\n  jsDocComment: jsDocComment,\n  leadingComment: leadingComment,\n  literal: literal,\n  literalArr: literalArr,\n  literalMap: literalMap,\n  localizedString: localizedString,\n  not: not,\n  nullSafeIsEquivalent: nullSafeIsEquivalent,\n  taggedTemplate: taggedTemplate,\n  transplantedType: transplantedType,\n  typeofExpr: typeofExpr,\n  unary: unary,\n  variable: variable\n});\nconst CONSTANT_PREFIX = '_c';\nconst UNKNOWN_VALUE_KEY = variable('<unknown>');\nconst KEY_CONTEXT = {};\nconst POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS = 50;\nclass FixupExpression extends Expression {\n  resolved;\n  original;\n  shared = false;\n  constructor(resolved) {\n    super(resolved.type);\n    this.resolved = resolved;\n    this.original = resolved;\n  }\n  visitExpression(visitor, context) {\n    if (context === KEY_CONTEXT) {\n      return this.original.visitExpression(visitor, context);\n    } else {\n      return this.resolved.visitExpression(visitor, context);\n    }\n  }\n  isEquivalent(e) {\n    return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n  }\n  isConstant() {\n    return true;\n  }\n  clone() {\n    throw new Error(`Not supported.`);\n  }\n  fixup(expression) {\n    this.resolved = expression;\n    this.shared = true;\n  }\n}\nclass ConstantPool {\n  isClosureCompilerEnabled;\n  statements = [];\n  literals = new Map();\n  literalFactories = new Map();\n  sharedConstants = new Map();\n  _claimedNames = new Map();\n  nextNameIndex = 0;\n  constructor(isClosureCompilerEnabled = false) {\n    this.isClosureCompilerEnabled = isClosureCompilerEnabled;\n  }\n  getConstLiteral(literal, forceShared) {\n    if (literal instanceof LiteralExpr && !isLongStringLiteral(literal) || literal instanceof FixupExpression) {\n      return literal;\n    }\n    const key = GenericKeyFn.INSTANCE.keyOf(literal);\n    let fixup = this.literals.get(key);\n    let newValue = false;\n    if (!fixup) {\n      fixup = new FixupExpression(literal);\n      this.literals.set(key, fixup);\n      newValue = true;\n    }\n    if (!newValue && !fixup.shared || newValue && forceShared) {\n      const name = this.freshName();\n      let value;\n      let usage;\n      if (this.isClosureCompilerEnabled && isLongStringLiteral(literal)) {\n        value = new FunctionExpr([], [new ReturnStatement(literal)]);\n        usage = variable(name).callFn([]);\n      } else {\n        value = literal;\n        usage = variable(name);\n      }\n      this.statements.push(new DeclareVarStmt(name, value, INFERRED_TYPE, StmtModifier.Final));\n      fixup.fixup(usage);\n    }\n    return fixup;\n  }\n  getSharedConstant(def, expr) {\n    const key = def.keyOf(expr);\n    if (!this.sharedConstants.has(key)) {\n      const id = this.freshName();\n      this.sharedConstants.set(key, variable(id));\n      this.statements.push(def.toSharedConstantDeclaration(id, expr));\n    }\n    return this.sharedConstants.get(key);\n  }\n  getLiteralFactory(literal) {\n    if (literal instanceof LiteralArrayExpr) {\n      const argumentsForKey = literal.entries.map(e => e.isConstant() ? e : UNKNOWN_VALUE_KEY);\n      const key = GenericKeyFn.INSTANCE.keyOf(literalArr(argumentsForKey));\n      return this._getLiteralFactory(key, literal.entries, entries => literalArr(entries));\n    } else {\n      const expressionForKey = literalMap(literal.entries.map(e => ({\n        key: e.key,\n        value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,\n        quoted: e.quoted\n      })));\n      const key = GenericKeyFn.INSTANCE.keyOf(expressionForKey);\n      return this._getLiteralFactory(key, literal.entries.map(e => e.value), entries => literalMap(entries.map((value, index) => ({\n        key: literal.entries[index].key,\n        value,\n        quoted: literal.entries[index].quoted\n      }))));\n    }\n  }\n  getSharedFunctionReference(fn, prefix, useUniqueName = true) {\n    const isArrow = fn instanceof ArrowFunctionExpr;\n    for (const current of this.statements) {\n      if (isArrow && current instanceof DeclareVarStmt && current.value?.isEquivalent(fn)) {\n        return variable(current.name);\n      }\n      if (!isArrow && current instanceof DeclareFunctionStmt && fn instanceof FunctionExpr && fn.isEquivalent(current)) {\n        return variable(current.name);\n      }\n    }\n    const name = useUniqueName ? this.uniqueName(prefix) : prefix;\n    this.statements.push(fn instanceof FunctionExpr ? fn.toDeclStmt(name, StmtModifier.Final) : new DeclareVarStmt(name, fn, INFERRED_TYPE, StmtModifier.Final, fn.sourceSpan));\n    return variable(name);\n  }\n  _getLiteralFactory(key, values, resultMap) {\n    let literalFactory = this.literalFactories.get(key);\n    const literalFactoryArguments = values.filter(e => !e.isConstant());\n    if (!literalFactory) {\n      const resultExpressions = values.map((e, index) => e.isConstant() ? this.getConstLiteral(e, true) : variable(`a${index}`));\n      const parameters = resultExpressions.filter(isVariable).map(e => new FnParam(e.name, DYNAMIC_TYPE));\n      const pureFunctionDeclaration = arrowFn(parameters, resultMap(resultExpressions), INFERRED_TYPE);\n      const name = this.freshName();\n      this.statements.push(new DeclareVarStmt(name, pureFunctionDeclaration, INFERRED_TYPE, StmtModifier.Final));\n      literalFactory = variable(name);\n      this.literalFactories.set(key, literalFactory);\n    }\n    return {\n      literalFactory,\n      literalFactoryArguments\n    };\n  }\n  uniqueName(name, alwaysIncludeSuffix = true) {\n    const count = this._claimedNames.get(name) ?? 0;\n    const result = count === 0 && !alwaysIncludeSuffix ? `${name}` : `${name}${count}`;\n    this._claimedNames.set(name, count + 1);\n    return result;\n  }\n  freshName() {\n    return this.uniqueName(CONSTANT_PREFIX);\n  }\n}\nclass GenericKeyFn {\n  static INSTANCE = new GenericKeyFn();\n  keyOf(expr) {\n    if (expr instanceof LiteralExpr && typeof expr.value === 'string') {\n      return `\"${expr.value}\"`;\n    } else if (expr instanceof LiteralExpr) {\n      return String(expr.value);\n    } else if (expr instanceof RegularExpressionLiteralExpr) {\n      return `/${expr.body}/${expr.flags ?? ''}`;\n    } else if (expr instanceof LiteralArrayExpr) {\n      const entries = [];\n      for (const entry of expr.entries) {\n        entries.push(this.keyOf(entry));\n      }\n      return `[${entries.join(',')}]`;\n    } else if (expr instanceof LiteralMapExpr) {\n      const entries = [];\n      for (const entry of expr.entries) {\n        let key = entry.key;\n        if (entry.quoted) {\n          key = `\"${key}\"`;\n        }\n        entries.push(key + ':' + this.keyOf(entry.value));\n      }\n      return `{${entries.join(',')}}`;\n    } else if (expr instanceof ExternalExpr) {\n      return `import(\"${expr.value.moduleName}\", ${expr.value.name})`;\n    } else if (expr instanceof ReadVarExpr) {\n      return `read(${expr.name})`;\n    } else if (expr instanceof TypeofExpr) {\n      return `typeof(${this.keyOf(expr.expr)})`;\n    } else {\n      throw new Error(`${this.constructor.name} does not handle expressions of type ${expr.constructor.name}`);\n    }\n  }\n}\nfunction isVariable(e) {\n  return e instanceof ReadVarExpr;\n}\nfunction isLongStringLiteral(expr) {\n  return expr instanceof LiteralExpr && typeof expr.value === 'string' && expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS;\n}\nconst CORE = '@angular/core';\nclass Identifiers {\n  static NEW_METHOD = 'factory';\n  static TRANSFORM_METHOD = 'transform';\n  static PATCH_DEPS = 'patchedDeps';\n  static core = {\n    name: null,\n    moduleName: CORE\n  };\n  static namespaceHTML = {\n    name: 'ÉµÉµnamespaceHTML',\n    moduleName: CORE\n  };\n  static namespaceMathML = {\n    name: 'ÉµÉµnamespaceMathML',\n    moduleName: CORE\n  };\n  static namespaceSVG = {\n    name: 'ÉµÉµnamespaceSVG',\n    moduleName: CORE\n  };\n  static element = {\n    name: 'ÉµÉµelement',\n    moduleName: CORE\n  };\n  static elementStart = {\n    name: 'ÉµÉµelementStart',\n    moduleName: CORE\n  };\n  static elementEnd = {\n    name: 'ÉµÉµelementEnd',\n    moduleName: CORE\n  };\n  static domElement = {\n    name: 'ÉµÉµdomElement',\n    moduleName: CORE\n  };\n  static domElementStart = {\n    name: 'ÉµÉµdomElementStart',\n    moduleName: CORE\n  };\n  static domElementEnd = {\n    name: 'ÉµÉµdomElementEnd',\n    moduleName: CORE\n  };\n  static domElementContainer = {\n    name: 'ÉµÉµdomElementContainer',\n    moduleName: CORE\n  };\n  static domElementContainerStart = {\n    name: 'ÉµÉµdomElementContainerStart',\n    moduleName: CORE\n  };\n  static domElementContainerEnd = {\n    name: 'ÉµÉµdomElementContainerEnd',\n    moduleName: CORE\n  };\n  static domTemplate = {\n    name: 'ÉµÉµdomTemplate',\n    moduleName: CORE\n  };\n  static domListener = {\n    name: 'ÉµÉµdomListener',\n    moduleName: CORE\n  };\n  static advance = {\n    name: 'ÉµÉµadvance',\n    moduleName: CORE\n  };\n  static syntheticHostProperty = {\n    name: 'ÉµÉµsyntheticHostProperty',\n    moduleName: CORE\n  };\n  static syntheticHostListener = {\n    name: 'ÉµÉµsyntheticHostListener',\n    moduleName: CORE\n  };\n  static attribute = {\n    name: 'ÉµÉµattribute',\n    moduleName: CORE\n  };\n  static classProp = {\n    name: 'ÉµÉµclassProp',\n    moduleName: CORE\n  };\n  static elementContainerStart = {\n    name: 'ÉµÉµelementContainerStart',\n    moduleName: CORE\n  };\n  static elementContainerEnd = {\n    name: 'ÉµÉµelementContainerEnd',\n    moduleName: CORE\n  };\n  static elementContainer = {\n    name: 'ÉµÉµelementContainer',\n    moduleName: CORE\n  };\n  static styleMap = {\n    name: 'ÉµÉµstyleMap',\n    moduleName: CORE\n  };\n  static classMap = {\n    name: 'ÉµÉµclassMap',\n    moduleName: CORE\n  };\n  static styleProp = {\n    name: 'ÉµÉµstyleProp',\n    moduleName: CORE\n  };\n  static interpolate = {\n    name: 'ÉµÉµinterpolate',\n    moduleName: CORE\n  };\n  static interpolate1 = {\n    name: 'ÉµÉµinterpolate1',\n    moduleName: CORE\n  };\n  static interpolate2 = {\n    name: 'ÉµÉµinterpolate2',\n    moduleName: CORE\n  };\n  static interpolate3 = {\n    name: 'ÉµÉµinterpolate3',\n    moduleName: CORE\n  };\n  static interpolate4 = {\n    name: 'ÉµÉµinterpolate4',\n    moduleName: CORE\n  };\n  static interpolate5 = {\n    name: 'ÉµÉµinterpolate5',\n    moduleName: CORE\n  };\n  static interpolate6 = {\n    name: 'ÉµÉµinterpolate6',\n    moduleName: CORE\n  };\n  static interpolate7 = {\n    name: 'ÉµÉµinterpolate7',\n    moduleName: CORE\n  };\n  static interpolate8 = {\n    name: 'ÉµÉµinterpolate8',\n    moduleName: CORE\n  };\n  static interpolateV = {\n    name: 'ÉµÉµinterpolateV',\n    moduleName: CORE\n  };\n  static nextContext = {\n    name: 'ÉµÉµnextContext',\n    moduleName: CORE\n  };\n  static resetView = {\n    name: 'ÉµÉµresetView',\n    moduleName: CORE\n  };\n  static templateCreate = {\n    name: 'ÉµÉµtemplate',\n    moduleName: CORE\n  };\n  static defer = {\n    name: 'ÉµÉµdefer',\n    moduleName: CORE\n  };\n  static deferWhen = {\n    name: 'ÉµÉµdeferWhen',\n    moduleName: CORE\n  };\n  static deferOnIdle = {\n    name: 'ÉµÉµdeferOnIdle',\n    moduleName: CORE\n  };\n  static deferOnImmediate = {\n    name: 'ÉµÉµdeferOnImmediate',\n    moduleName: CORE\n  };\n  static deferOnTimer = {\n    name: 'ÉµÉµdeferOnTimer',\n    moduleName: CORE\n  };\n  static deferOnHover = {\n    name: 'ÉµÉµdeferOnHover',\n    moduleName: CORE\n  };\n  static deferOnInteraction = {\n    name: 'ÉµÉµdeferOnInteraction',\n    moduleName: CORE\n  };\n  static deferOnViewport = {\n    name: 'ÉµÉµdeferOnViewport',\n    moduleName: CORE\n  };\n  static deferPrefetchWhen = {\n    name: 'ÉµÉµdeferPrefetchWhen',\n    moduleName: CORE\n  };\n  static deferPrefetchOnIdle = {\n    name: 'ÉµÉµdeferPrefetchOnIdle',\n    moduleName: CORE\n  };\n  static deferPrefetchOnImmediate = {\n    name: 'ÉµÉµdeferPrefetchOnImmediate',\n    moduleName: CORE\n  };\n  static deferPrefetchOnTimer = {\n    name: 'ÉµÉµdeferPrefetchOnTimer',\n    moduleName: CORE\n  };\n  static deferPrefetchOnHover = {\n    name: 'ÉµÉµdeferPrefetchOnHover',\n    moduleName: CORE\n  };\n  static deferPrefetchOnInteraction = {\n    name: 'ÉµÉµdeferPrefetchOnInteraction',\n    moduleName: CORE\n  };\n  static deferPrefetchOnViewport = {\n    name: 'ÉµÉµdeferPrefetchOnViewport',\n    moduleName: CORE\n  };\n  static deferHydrateWhen = {\n    name: 'ÉµÉµdeferHydrateWhen',\n    moduleName: CORE\n  };\n  static deferHydrateNever = {\n    name: 'ÉµÉµdeferHydrateNever',\n    moduleName: CORE\n  };\n  static deferHydrateOnIdle = {\n    name: 'ÉµÉµdeferHydrateOnIdle',\n    moduleName: CORE\n  };\n  static deferHydrateOnImmediate = {\n    name: 'ÉµÉµdeferHydrateOnImmediate',\n    moduleName: CORE\n  };\n  static deferHydrateOnTimer = {\n    name: 'ÉµÉµdeferHydrateOnTimer',\n    moduleName: CORE\n  };\n  static deferHydrateOnHover = {\n    name: 'ÉµÉµdeferHydrateOnHover',\n    moduleName: CORE\n  };\n  static deferHydrateOnInteraction = {\n    name: 'ÉµÉµdeferHydrateOnInteraction',\n    moduleName: CORE\n  };\n  static deferHydrateOnViewport = {\n    name: 'ÉµÉµdeferHydrateOnViewport',\n    moduleName: CORE\n  };\n  static deferEnableTimerScheduling = {\n    name: 'ÉµÉµdeferEnableTimerScheduling',\n    moduleName: CORE\n  };\n  static conditionalCreate = {\n    name: 'ÉµÉµconditionalCreate',\n    moduleName: CORE\n  };\n  static conditionalBranchCreate = {\n    name: 'ÉµÉµconditionalBranchCreate',\n    moduleName: CORE\n  };\n  static conditional = {\n    name: 'ÉµÉµconditional',\n    moduleName: CORE\n  };\n  static repeater = {\n    name: 'ÉµÉµrepeater',\n    moduleName: CORE\n  };\n  static repeaterCreate = {\n    name: 'ÉµÉµrepeaterCreate',\n    moduleName: CORE\n  };\n  static repeaterTrackByIndex = {\n    name: 'ÉµÉµrepeaterTrackByIndex',\n    moduleName: CORE\n  };\n  static repeaterTrackByIdentity = {\n    name: 'ÉµÉµrepeaterTrackByIdentity',\n    moduleName: CORE\n  };\n  static componentInstance = {\n    name: 'ÉµÉµcomponentInstance',\n    moduleName: CORE\n  };\n  static text = {\n    name: 'ÉµÉµtext',\n    moduleName: CORE\n  };\n  static enableBindings = {\n    name: 'ÉµÉµenableBindings',\n    moduleName: CORE\n  };\n  static disableBindings = {\n    name: 'ÉµÉµdisableBindings',\n    moduleName: CORE\n  };\n  static getCurrentView = {\n    name: 'ÉµÉµgetCurrentView',\n    moduleName: CORE\n  };\n  static textInterpolate = {\n    name: 'ÉµÉµtextInterpolate',\n    moduleName: CORE\n  };\n  static textInterpolate1 = {\n    name: 'ÉµÉµtextInterpolate1',\n    moduleName: CORE\n  };\n  static textInterpolate2 = {\n    name: 'ÉµÉµtextInterpolate2',\n    moduleName: CORE\n  };\n  static textInterpolate3 = {\n    name: 'ÉµÉµtextInterpolate3',\n    moduleName: CORE\n  };\n  static textInterpolate4 = {\n    name: 'ÉµÉµtextInterpolate4',\n    moduleName: CORE\n  };\n  static textInterpolate5 = {\n    name: 'ÉµÉµtextInterpolate5',\n    moduleName: CORE\n  };\n  static textInterpolate6 = {\n    name: 'ÉµÉµtextInterpolate6',\n    moduleName: CORE\n  };\n  static textInterpolate7 = {\n    name: 'ÉµÉµtextInterpolate7',\n    moduleName: CORE\n  };\n  static textInterpolate8 = {\n    name: 'ÉµÉµtextInterpolate8',\n    moduleName: CORE\n  };\n  static textInterpolateV = {\n    name: 'ÉµÉµtextInterpolateV',\n    moduleName: CORE\n  };\n  static restoreView = {\n    name: 'ÉµÉµrestoreView',\n    moduleName: CORE\n  };\n  static pureFunction0 = {\n    name: 'ÉµÉµpureFunction0',\n    moduleName: CORE\n  };\n  static pureFunction1 = {\n    name: 'ÉµÉµpureFunction1',\n    moduleName: CORE\n  };\n  static pureFunction2 = {\n    name: 'ÉµÉµpureFunction2',\n    moduleName: CORE\n  };\n  static pureFunction3 = {\n    name: 'ÉµÉµpureFunction3',\n    moduleName: CORE\n  };\n  static pureFunction4 = {\n    name: 'ÉµÉµpureFunction4',\n    moduleName: CORE\n  };\n  static pureFunction5 = {\n    name: 'ÉµÉµpureFunction5',\n    moduleName: CORE\n  };\n  static pureFunction6 = {\n    name: 'ÉµÉµpureFunction6',\n    moduleName: CORE\n  };\n  static pureFunction7 = {\n    name: 'ÉµÉµpureFunction7',\n    moduleName: CORE\n  };\n  static pureFunction8 = {\n    name: 'ÉµÉµpureFunction8',\n    moduleName: CORE\n  };\n  static pureFunctionV = {\n    name: 'ÉµÉµpureFunctionV',\n    moduleName: CORE\n  };\n  static pipeBind1 = {\n    name: 'ÉµÉµpipeBind1',\n    moduleName: CORE\n  };\n  static pipeBind2 = {\n    name: 'ÉµÉµpipeBind2',\n    moduleName: CORE\n  };\n  static pipeBind3 = {\n    name: 'ÉµÉµpipeBind3',\n    moduleName: CORE\n  };\n  static pipeBind4 = {\n    name: 'ÉµÉµpipeBind4',\n    moduleName: CORE\n  };\n  static pipeBindV = {\n    name: 'ÉµÉµpipeBindV',\n    moduleName: CORE\n  };\n  static domProperty = {\n    name: 'ÉµÉµdomProperty',\n    moduleName: CORE\n  };\n  static ariaProperty = {\n    name: 'ÉµÉµariaProperty',\n    moduleName: CORE\n  };\n  static property = {\n    name: 'ÉµÉµproperty',\n    moduleName: CORE\n  };\n  static control = {\n    name: 'ÉµÉµcontrol',\n    moduleName: CORE\n  };\n  static controlCreate = {\n    name: 'ÉµÉµcontrolCreate',\n    moduleName: CORE\n  };\n  static animationEnterListener = {\n    name: 'ÉµÉµanimateEnterListener',\n    moduleName: CORE\n  };\n  static animationLeaveListener = {\n    name: 'ÉµÉµanimateLeaveListener',\n    moduleName: CORE\n  };\n  static animationEnter = {\n    name: 'ÉµÉµanimateEnter',\n    moduleName: CORE\n  };\n  static animationLeave = {\n    name: 'ÉµÉµanimateLeave',\n    moduleName: CORE\n  };\n  static i18n = {\n    name: 'ÉµÉµi18n',\n    moduleName: CORE\n  };\n  static i18nAttributes = {\n    name: 'ÉµÉµi18nAttributes',\n    moduleName: CORE\n  };\n  static i18nExp = {\n    name: 'ÉµÉµi18nExp',\n    moduleName: CORE\n  };\n  static i18nStart = {\n    name: 'ÉµÉµi18nStart',\n    moduleName: CORE\n  };\n  static i18nEnd = {\n    name: 'ÉµÉµi18nEnd',\n    moduleName: CORE\n  };\n  static i18nApply = {\n    name: 'ÉµÉµi18nApply',\n    moduleName: CORE\n  };\n  static i18nPostprocess = {\n    name: 'ÉµÉµi18nPostprocess',\n    moduleName: CORE\n  };\n  static pipe = {\n    name: 'ÉµÉµpipe',\n    moduleName: CORE\n  };\n  static projection = {\n    name: 'ÉµÉµprojection',\n    moduleName: CORE\n  };\n  static projectionDef = {\n    name: 'ÉµÉµprojectionDef',\n    moduleName: CORE\n  };\n  static reference = {\n    name: 'ÉµÉµreference',\n    moduleName: CORE\n  };\n  static inject = {\n    name: 'ÉµÉµinject',\n    moduleName: CORE\n  };\n  static injectAttribute = {\n    name: 'ÉµÉµinjectAttribute',\n    moduleName: CORE\n  };\n  static directiveInject = {\n    name: 'ÉµÉµdirectiveInject',\n    moduleName: CORE\n  };\n  static invalidFactory = {\n    name: 'ÉµÉµinvalidFactory',\n    moduleName: CORE\n  };\n  static invalidFactoryDep = {\n    name: 'ÉµÉµinvalidFactoryDep',\n    moduleName: CORE\n  };\n  static templateRefExtractor = {\n    name: 'ÉµÉµtemplateRefExtractor',\n    moduleName: CORE\n  };\n  static forwardRef = {\n    name: 'forwardRef',\n    moduleName: CORE\n  };\n  static resolveForwardRef = {\n    name: 'resolveForwardRef',\n    moduleName: CORE\n  };\n  static replaceMetadata = {\n    name: 'ÉµÉµreplaceMetadata',\n    moduleName: CORE\n  };\n  static getReplaceMetadataURL = {\n    name: 'ÉµÉµgetReplaceMetadataURL',\n    moduleName: CORE\n  };\n  static ÉµÉµdefineInjectable = {\n    name: 'ÉµÉµdefineInjectable',\n    moduleName: CORE\n  };\n  static declareInjectable = {\n    name: 'ÉµÉµngDeclareInjectable',\n    moduleName: CORE\n  };\n  static InjectableDeclaration = {\n    name: 'ÉµÉµInjectableDeclaration',\n    moduleName: CORE\n  };\n  static resolveWindow = {\n    name: 'ÉµÉµresolveWindow',\n    moduleName: CORE\n  };\n  static resolveDocument = {\n    name: 'ÉµÉµresolveDocument',\n    moduleName: CORE\n  };\n  static resolveBody = {\n    name: 'ÉµÉµresolveBody',\n    moduleName: CORE\n  };\n  static getComponentDepsFactory = {\n    name: 'ÉµÉµgetComponentDepsFactory',\n    moduleName: CORE\n  };\n  static defineComponent = {\n    name: 'ÉµÉµdefineComponent',\n    moduleName: CORE\n  };\n  static declareComponent = {\n    name: 'ÉµÉµngDeclareComponent',\n    moduleName: CORE\n  };\n  static setComponentScope = {\n    name: 'ÉµÉµsetComponentScope',\n    moduleName: CORE\n  };\n  static ChangeDetectionStrategy = {\n    name: 'ChangeDetectionStrategy',\n    moduleName: CORE\n  };\n  static ViewEncapsulation = {\n    name: 'ViewEncapsulation',\n    moduleName: CORE\n  };\n  static ComponentDeclaration = {\n    name: 'ÉµÉµComponentDeclaration',\n    moduleName: CORE\n  };\n  static FactoryDeclaration = {\n    name: 'ÉµÉµFactoryDeclaration',\n    moduleName: CORE\n  };\n  static declareFactory = {\n    name: 'ÉµÉµngDeclareFactory',\n    moduleName: CORE\n  };\n  static FactoryTarget = {\n    name: 'ÉµÉµFactoryTarget',\n    moduleName: CORE\n  };\n  static defineDirective = {\n    name: 'ÉµÉµdefineDirective',\n    moduleName: CORE\n  };\n  static declareDirective = {\n    name: 'ÉµÉµngDeclareDirective',\n    moduleName: CORE\n  };\n  static DirectiveDeclaration = {\n    name: 'ÉµÉµDirectiveDeclaration',\n    moduleName: CORE\n  };\n  static InjectorDef = {\n    name: 'ÉµÉµInjectorDef',\n    moduleName: CORE\n  };\n  static InjectorDeclaration = {\n    name: 'ÉµÉµInjectorDeclaration',\n    moduleName: CORE\n  };\n  static defineInjector = {\n    name: 'ÉµÉµdefineInjector',\n    moduleName: CORE\n  };\n  static declareInjector = {\n    name: 'ÉµÉµngDeclareInjector',\n    moduleName: CORE\n  };\n  static NgModuleDeclaration = {\n    name: 'ÉµÉµNgModuleDeclaration',\n    moduleName: CORE\n  };\n  static ModuleWithProviders = {\n    name: 'ModuleWithProviders',\n    moduleName: CORE\n  };\n  static defineNgModule = {\n    name: 'ÉµÉµdefineNgModule',\n    moduleName: CORE\n  };\n  static declareNgModule = {\n    name: 'ÉµÉµngDeclareNgModule',\n    moduleName: CORE\n  };\n  static setNgModuleScope = {\n    name: 'ÉµÉµsetNgModuleScope',\n    moduleName: CORE\n  };\n  static registerNgModuleType = {\n    name: 'ÉµÉµregisterNgModuleType',\n    moduleName: CORE\n  };\n  static PipeDeclaration = {\n    name: 'ÉµÉµPipeDeclaration',\n    moduleName: CORE\n  };\n  static definePipe = {\n    name: 'ÉµÉµdefinePipe',\n    moduleName: CORE\n  };\n  static declarePipe = {\n    name: 'ÉµÉµngDeclarePipe',\n    moduleName: CORE\n  };\n  static declareClassMetadata = {\n    name: 'ÉµÉµngDeclareClassMetadata',\n    moduleName: CORE\n  };\n  static declareClassMetadataAsync = {\n    name: 'ÉµÉµngDeclareClassMetadataAsync',\n    moduleName: CORE\n  };\n  static setClassMetadata = {\n    name: 'ÉµsetClassMetadata',\n    moduleName: CORE\n  };\n  static setClassMetadataAsync = {\n    name: 'ÉµsetClassMetadataAsync',\n    moduleName: CORE\n  };\n  static setClassDebugInfo = {\n    name: 'ÉµsetClassDebugInfo',\n    moduleName: CORE\n  };\n  static queryRefresh = {\n    name: 'ÉµÉµqueryRefresh',\n    moduleName: CORE\n  };\n  static viewQuery = {\n    name: 'ÉµÉµviewQuery',\n    moduleName: CORE\n  };\n  static loadQuery = {\n    name: 'ÉµÉµloadQuery',\n    moduleName: CORE\n  };\n  static contentQuery = {\n    name: 'ÉµÉµcontentQuery',\n    moduleName: CORE\n  };\n  static viewQuerySignal = {\n    name: 'ÉµÉµviewQuerySignal',\n    moduleName: CORE\n  };\n  static contentQuerySignal = {\n    name: 'ÉµÉµcontentQuerySignal',\n    moduleName: CORE\n  };\n  static queryAdvance = {\n    name: 'ÉµÉµqueryAdvance',\n    moduleName: CORE\n  };\n  static twoWayProperty = {\n    name: 'ÉµÉµtwoWayProperty',\n    moduleName: CORE\n  };\n  static twoWayBindingSet = {\n    name: 'ÉµÉµtwoWayBindingSet',\n    moduleName: CORE\n  };\n  static twoWayListener = {\n    name: 'ÉµÉµtwoWayListener',\n    moduleName: CORE\n  };\n  static declareLet = {\n    name: 'ÉµÉµdeclareLet',\n    moduleName: CORE\n  };\n  static storeLet = {\n    name: 'ÉµÉµstoreLet',\n    moduleName: CORE\n  };\n  static readContextLet = {\n    name: 'ÉµÉµreadContextLet',\n    moduleName: CORE\n  };\n  static attachSourceLocations = {\n    name: 'ÉµÉµattachSourceLocations',\n    moduleName: CORE\n  };\n  static NgOnChangesFeature = {\n    name: 'ÉµÉµNgOnChangesFeature',\n    moduleName: CORE\n  };\n  static InheritDefinitionFeature = {\n    name: 'ÉµÉµInheritDefinitionFeature',\n    moduleName: CORE\n  };\n  static ProvidersFeature = {\n    name: 'ÉµÉµProvidersFeature',\n    moduleName: CORE\n  };\n  static HostDirectivesFeature = {\n    name: 'ÉµÉµHostDirectivesFeature',\n    moduleName: CORE\n  };\n  static ExternalStylesFeature = {\n    name: 'ÉµÉµExternalStylesFeature',\n    moduleName: CORE\n  };\n  static listener = {\n    name: 'ÉµÉµlistener',\n    moduleName: CORE\n  };\n  static getInheritedFactory = {\n    name: 'ÉµÉµgetInheritedFactory',\n    moduleName: CORE\n  };\n  static sanitizeHtml = {\n    name: 'ÉµÉµsanitizeHtml',\n    moduleName: CORE\n  };\n  static sanitizeStyle = {\n    name: 'ÉµÉµsanitizeStyle',\n    moduleName: CORE\n  };\n  static sanitizeResourceUrl = {\n    name: 'ÉµÉµsanitizeResourceUrl',\n    moduleName: CORE\n  };\n  static sanitizeScript = {\n    name: 'ÉµÉµsanitizeScript',\n    moduleName: CORE\n  };\n  static sanitizeUrl = {\n    name: 'ÉµÉµsanitizeUrl',\n    moduleName: CORE\n  };\n  static sanitizeUrlOrResourceUrl = {\n    name: 'ÉµÉµsanitizeUrlOrResourceUrl',\n    moduleName: CORE\n  };\n  static trustConstantHtml = {\n    name: 'ÉµÉµtrustConstantHtml',\n    moduleName: CORE\n  };\n  static trustConstantResourceUrl = {\n    name: 'ÉµÉµtrustConstantResourceUrl',\n    moduleName: CORE\n  };\n  static validateIframeAttribute = {\n    name: 'ÉµÉµvalidateIframeAttribute',\n    moduleName: CORE\n  };\n  static inputDecorator = {\n    name: 'Input',\n    moduleName: CORE\n  };\n  static outputDecorator = {\n    name: 'Output',\n    moduleName: CORE\n  };\n  static viewChildDecorator = {\n    name: 'ViewChild',\n    moduleName: CORE\n  };\n  static viewChildrenDecorator = {\n    name: 'ViewChildren',\n    moduleName: CORE\n  };\n  static contentChildDecorator = {\n    name: 'ContentChild',\n    moduleName: CORE\n  };\n  static contentChildrenDecorator = {\n    name: 'ContentChildren',\n    moduleName: CORE\n  };\n  static InputSignalBrandWriteType = {\n    name: 'ÉµINPUT_SIGNAL_BRAND_WRITE_TYPE',\n    moduleName: CORE\n  };\n  static UnwrapDirectiveSignalInputs = {\n    name: 'ÉµUnwrapDirectiveSignalInputs',\n    moduleName: CORE\n  };\n  static unwrapWritableSignal = {\n    name: 'ÉµunwrapWritableSignal',\n    moduleName: CORE\n  };\n  static assertType = {\n    name: 'ÉµassertType',\n    moduleName: CORE\n  };\n}\nconst DASH_CASE_REGEXP = /-+([a-z0-9])/g;\nfunction dashCaseToCamelCase(input) {\n  return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());\n}\nfunction splitAtColon(input, defaultValues) {\n  return _splitAt(input, ':', defaultValues);\n}\nfunction splitAtPeriod(input, defaultValues) {\n  return _splitAt(input, '.', defaultValues);\n}\nfunction _splitAt(input, character, defaultValues) {\n  const characterIndex = input.indexOf(character);\n  if (characterIndex == -1) return defaultValues;\n  return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\nfunction noUndefined(val) {\n  return val === undefined ? null : val;\n}\nfunction escapeRegExp(s) {\n  return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}\nfunction utf8Encode(str) {\n  let encoded = [];\n  for (let index = 0; index < str.length; index++) {\n    let codePoint = str.charCodeAt(index);\n    if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > index + 1) {\n      const low = str.charCodeAt(index + 1);\n      if (low >= 0xdc00 && low <= 0xdfff) {\n        index++;\n        codePoint = (codePoint - 0xd800 << 10) + low - 0xdc00 + 0x10000;\n      }\n    }\n    if (codePoint <= 0x7f) {\n      encoded.push(codePoint);\n    } else if (codePoint <= 0x7ff) {\n      encoded.push(codePoint >> 6 & 0x1f | 0xc0, codePoint & 0x3f | 0x80);\n    } else if (codePoint <= 0xffff) {\n      encoded.push(codePoint >> 12 | 0xe0, codePoint >> 6 & 0x3f | 0x80, codePoint & 0x3f | 0x80);\n    } else if (codePoint <= 0x1fffff) {\n      encoded.push(codePoint >> 18 & 0x07 | 0xf0, codePoint >> 12 & 0x3f | 0x80, codePoint >> 6 & 0x3f | 0x80, codePoint & 0x3f | 0x80);\n    }\n  }\n  return encoded;\n}\nfunction stringify(token) {\n  if (typeof token === 'string') {\n    return token;\n  }\n  if (Array.isArray(token)) {\n    return `[${token.map(stringify).join(', ')}]`;\n  }\n  if (token == null) {\n    return '' + token;\n  }\n  const name = token.overriddenName || token.name;\n  if (name) {\n    return `${name}`;\n  }\n  if (!token.toString) {\n    return 'object';\n  }\n  const result = token.toString();\n  if (result == null) {\n    return '' + result;\n  }\n  const newLineIndex = result.indexOf('\\n');\n  return newLineIndex >= 0 ? result.slice(0, newLineIndex) : result;\n}\nclass Version {\n  full;\n  major;\n  minor;\n  patch;\n  constructor(full) {\n    this.full = full;\n    const splits = full.split('.');\n    this.major = splits[0];\n    this.minor = splits[1];\n    this.patch = splits.slice(2).join('.');\n  }\n}\nconst _global = globalThis;\nconst V1_TO_18 = /^([1-9]|1[0-8])\\./;\nfunction getJitStandaloneDefaultForVersion(version) {\n  if (version.startsWith('0.')) {\n    return true;\n  }\n  if (V1_TO_18.test(version)) {\n    return false;\n  }\n  return true;\n}\nconst VERSION$1 = 3;\nconst JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\nclass SourceMapGenerator {\n  file;\n  sourcesContent = new Map();\n  lines = [];\n  lastCol0 = 0;\n  hasMappings = false;\n  constructor(file = null) {\n    this.file = file;\n  }\n  addSource(url, content = null) {\n    if (!this.sourcesContent.has(url)) {\n      this.sourcesContent.set(url, content);\n    }\n    return this;\n  }\n  addLine() {\n    this.lines.push([]);\n    this.lastCol0 = 0;\n    return this;\n  }\n  addMapping(col0, sourceUrl, sourceLine0, sourceCol0) {\n    if (!this.currentLine) {\n      throw new Error(`A line must be added before mappings can be added`);\n    }\n    if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n      throw new Error(`Unknown source file \"${sourceUrl}\"`);\n    }\n    if (col0 == null) {\n      throw new Error(`The column in the generated code must be provided`);\n    }\n    if (col0 < this.lastCol0) {\n      throw new Error(`Mapping should be added in output order`);\n    }\n    if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n      throw new Error(`The source location must be provided when a source url is provided`);\n    }\n    this.hasMappings = true;\n    this.lastCol0 = col0;\n    this.currentLine.push({\n      col0,\n      sourceUrl,\n      sourceLine0,\n      sourceCol0\n    });\n    return this;\n  }\n  get currentLine() {\n    return this.lines.slice(-1)[0];\n  }\n  toJSON() {\n    if (!this.hasMappings) {\n      return null;\n    }\n    const sourcesIndex = new Map();\n    const sources = [];\n    const sourcesContent = [];\n    Array.from(this.sourcesContent.keys()).forEach((url, i) => {\n      sourcesIndex.set(url, i);\n      sources.push(url);\n      sourcesContent.push(this.sourcesContent.get(url) || null);\n    });\n    let mappings = '';\n    let lastCol0 = 0;\n    let lastSourceIndex = 0;\n    let lastSourceLine0 = 0;\n    let lastSourceCol0 = 0;\n    this.lines.forEach(segments => {\n      lastCol0 = 0;\n      mappings += segments.map(segment => {\n        let segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n        lastCol0 = segment.col0;\n        if (segment.sourceUrl != null) {\n          segAsStr += toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);\n          lastSourceIndex = sourcesIndex.get(segment.sourceUrl);\n          segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);\n          lastSourceLine0 = segment.sourceLine0;\n          segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);\n          lastSourceCol0 = segment.sourceCol0;\n        }\n        return segAsStr;\n      }).join(',');\n      mappings += ';';\n    });\n    mappings = mappings.slice(0, -1);\n    return {\n      'file': this.file || '',\n      'version': VERSION$1,\n      'sourceRoot': '',\n      'sources': sources,\n      'sourcesContent': sourcesContent,\n      'mappings': mappings\n    };\n  }\n  toJsComment() {\n    return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) : '';\n  }\n}\nfunction toBase64String(value) {\n  let b64 = '';\n  const encoded = utf8Encode(value);\n  for (let i = 0; i < encoded.length;) {\n    const i1 = encoded[i++];\n    const i2 = i < encoded.length ? encoded[i++] : null;\n    const i3 = i < encoded.length ? encoded[i++] : null;\n    b64 += toBase64Digit(i1 >> 2);\n    b64 += toBase64Digit((i1 & 3) << 4 | (i2 === null ? 0 : i2 >> 4));\n    b64 += i2 === null ? '=' : toBase64Digit((i2 & 15) << 2 | (i3 === null ? 0 : i3 >> 6));\n    b64 += i2 === null || i3 === null ? '=' : toBase64Digit(i3 & 63);\n  }\n  return b64;\n}\nfunction toBase64VLQ(value) {\n  value = value < 0 ? (-value << 1) + 1 : value << 1;\n  let out = '';\n  do {\n    let digit = value & 31;\n    value = value >> 5;\n    if (value > 0) {\n      digit = digit | 32;\n    }\n    out += toBase64Digit(digit);\n  } while (value > 0);\n  return out;\n}\nconst B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfunction toBase64Digit(value) {\n  if (value < 0 || value >= 64) {\n    throw new Error(`Can only encode value in the range [0, 63]`);\n  }\n  return B64_DIGITS[value];\n}\nconst _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nconst _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nconst _INDENT_WITH = '  ';\nclass _EmittedLine {\n  indent;\n  partsLength = 0;\n  parts = [];\n  srcSpans = [];\n  constructor(indent) {\n    this.indent = indent;\n  }\n}\nconst BINARY_OPERATORS$1 = new Map([[BinaryOperator.And, '&&'], [BinaryOperator.Bigger, '>'], [BinaryOperator.BiggerEquals, '>='], [BinaryOperator.BitwiseOr, '|'], [BinaryOperator.BitwiseAnd, '&'], [BinaryOperator.Divide, '/'], [BinaryOperator.Assign, '='], [BinaryOperator.Equals, '=='], [BinaryOperator.Identical, '==='], [BinaryOperator.Lower, '<'], [BinaryOperator.LowerEquals, '<='], [BinaryOperator.Minus, '-'], [BinaryOperator.Modulo, '%'], [BinaryOperator.Exponentiation, '**'], [BinaryOperator.Multiply, '*'], [BinaryOperator.NotEquals, '!='], [BinaryOperator.NotIdentical, '!=='], [BinaryOperator.NullishCoalesce, '??'], [BinaryOperator.Or, '||'], [BinaryOperator.Plus, '+'], [BinaryOperator.In, 'in'], [BinaryOperator.AdditionAssignment, '+='], [BinaryOperator.SubtractionAssignment, '-='], [BinaryOperator.MultiplicationAssignment, '*='], [BinaryOperator.DivisionAssignment, '/='], [BinaryOperator.RemainderAssignment, '%='], [BinaryOperator.ExponentiationAssignment, '**='], [BinaryOperator.AndAssignment, '&&='], [BinaryOperator.OrAssignment, '||='], [BinaryOperator.NullishCoalesceAssignment, '??=']]);\nclass EmitterVisitorContext {\n  _indent;\n  static createRoot() {\n    return new EmitterVisitorContext(0);\n  }\n  _lines;\n  constructor(_indent) {\n    this._indent = _indent;\n    this._lines = [new _EmittedLine(_indent)];\n  }\n  get _currentLine() {\n    return this._lines[this._lines.length - 1];\n  }\n  println(from, lastPart = '') {\n    this.print(from || null, lastPart, true);\n  }\n  lineIsEmpty() {\n    return this._currentLine.parts.length === 0;\n  }\n  lineLength() {\n    return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n  }\n  print(from, part, newLine = false) {\n    if (part.length > 0) {\n      this._currentLine.parts.push(part);\n      this._currentLine.partsLength += part.length;\n      this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n    }\n    if (newLine) {\n      this._lines.push(new _EmittedLine(this._indent));\n    }\n  }\n  removeEmptyLastLine() {\n    if (this.lineIsEmpty()) {\n      this._lines.pop();\n    }\n  }\n  incIndent() {\n    this._indent++;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n  decIndent() {\n    this._indent--;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n  toSource() {\n    return this.sourceLines.map(l => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '').join('\\n');\n  }\n  toSourceMapGenerator(genFilePath, startsAtLine = 0) {\n    const map = new SourceMapGenerator(genFilePath);\n    let firstOffsetMapped = false;\n    const mapFirstOffsetIfNeeded = () => {\n      if (!firstOffsetMapped) {\n        map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\n        firstOffsetMapped = true;\n      }\n    };\n    for (let i = 0; i < startsAtLine; i++) {\n      map.addLine();\n      mapFirstOffsetIfNeeded();\n    }\n    this.sourceLines.forEach((line, lineIdx) => {\n      map.addLine();\n      const spans = line.srcSpans;\n      const parts = line.parts;\n      let col0 = line.indent * _INDENT_WITH.length;\n      let spanIdx = 0;\n      while (spanIdx < spans.length && !spans[spanIdx]) {\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n      }\n      if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n        firstOffsetMapped = true;\n      } else {\n        mapFirstOffsetIfNeeded();\n      }\n      while (spanIdx < spans.length) {\n        const span = spans[spanIdx];\n        const source = span.start.file;\n        const sourceLine = span.start.line;\n        const sourceCol = span.start.col;\n        map.addSource(source.url, source.content).addMapping(col0, source.url, sourceLine, sourceCol);\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n        while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n          col0 += parts[spanIdx].length;\n          spanIdx++;\n        }\n      }\n    });\n    return map;\n  }\n  spanOf(line, column) {\n    const emittedLine = this._lines[line];\n    if (emittedLine) {\n      let columnsLeft = column - _createIndent(emittedLine.indent).length;\n      for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n        const part = emittedLine.parts[partIndex];\n        if (part.length > columnsLeft) {\n          return emittedLine.srcSpans[partIndex];\n        }\n        columnsLeft -= part.length;\n      }\n    }\n    return null;\n  }\n  get sourceLines() {\n    if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n      return this._lines.slice(0, -1);\n    }\n    return this._lines;\n  }\n}\nclass AbstractEmitterVisitor {\n  _escapeDollarInStrings;\n  lastIfCondition = null;\n  constructor(_escapeDollarInStrings) {\n    this._escapeDollarInStrings = _escapeDollarInStrings;\n  }\n  printLeadingComments(stmt, ctx) {\n    if (stmt.leadingComments === undefined) {\n      return;\n    }\n    for (const comment of stmt.leadingComments) {\n      if (comment instanceof JSDocComment) {\n        ctx.print(stmt, `/*${comment.toString()}*/`, comment.trailingNewline);\n      } else {\n        if (comment.multiline) {\n          ctx.print(stmt, `/* ${comment.text} */`, comment.trailingNewline);\n        } else {\n          comment.text.split('\\n').forEach(line => {\n            ctx.println(stmt, `// ${line}`);\n          });\n        }\n      }\n    }\n  }\n  visitExpressionStmt(stmt, ctx) {\n    this.printLeadingComments(stmt, ctx);\n    stmt.expr.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n  visitReturnStmt(stmt, ctx) {\n    this.printLeadingComments(stmt, ctx);\n    ctx.print(stmt, `return `);\n    stmt.value.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n  visitIfStmt(stmt, ctx) {\n    this.printLeadingComments(stmt, ctx);\n    ctx.print(stmt, `if (`);\n    this.lastIfCondition = stmt.condition;\n    stmt.condition.visitExpression(this, ctx);\n    this.lastIfCondition = null;\n    ctx.print(stmt, `) {`);\n    const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n    if (stmt.trueCase.length <= 1 && !hasElseCase) {\n      ctx.print(stmt, ` `);\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.removeEmptyLastLine();\n      ctx.print(stmt, ` `);\n    } else {\n      ctx.println();\n      ctx.incIndent();\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.decIndent();\n      if (hasElseCase) {\n        ctx.println(stmt, `} else {`);\n        ctx.incIndent();\n        this.visitAllStatements(stmt.falseCase, ctx);\n        ctx.decIndent();\n      }\n    }\n    ctx.println(stmt, `}`);\n    return null;\n  }\n  visitInvokeFunctionExpr(expr, ctx) {\n    const shouldParenthesize = expr.fn instanceof ArrowFunctionExpr;\n    if (shouldParenthesize) {\n      ctx.print(expr.fn, '(');\n    }\n    expr.fn.visitExpression(this, ctx);\n    if (shouldParenthesize) {\n      ctx.print(expr.fn, ')');\n    }\n    ctx.print(expr, `(`);\n    this.visitAllExpressions(expr.args, ctx, ',');\n    ctx.print(expr, `)`);\n    return null;\n  }\n  visitTaggedTemplateLiteralExpr(expr, ctx) {\n    expr.tag.visitExpression(this, ctx);\n    expr.template.visitExpression(this, ctx);\n    return null;\n  }\n  visitTemplateLiteralExpr(expr, ctx) {\n    ctx.print(expr, '`');\n    for (let i = 0; i < expr.elements.length; i++) {\n      expr.elements[i].visitExpression(this, ctx);\n      const expression = i < expr.expressions.length ? expr.expressions[i] : null;\n      if (expression !== null) {\n        ctx.print(expression, '${');\n        expression.visitExpression(this, ctx);\n        ctx.print(expression, '}');\n      }\n    }\n    ctx.print(expr, '`');\n  }\n  visitTemplateLiteralElementExpr(expr, ctx) {\n    ctx.print(expr, expr.rawText);\n  }\n  visitWrappedNodeExpr(ast, ctx) {\n    throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');\n  }\n  visitTypeofExpr(expr, ctx) {\n    ctx.print(expr, 'typeof ');\n    expr.expr.visitExpression(this, ctx);\n  }\n  visitVoidExpr(expr, ctx) {\n    ctx.print(expr, 'void ');\n    expr.expr.visitExpression(this, ctx);\n  }\n  visitReadVarExpr(ast, ctx) {\n    ctx.print(ast, ast.name);\n    return null;\n  }\n  visitInstantiateExpr(ast, ctx) {\n    ctx.print(ast, `new `);\n    ast.classExpr.visitExpression(this, ctx);\n    ctx.print(ast, `(`);\n    this.visitAllExpressions(ast.args, ctx, ',');\n    ctx.print(ast, `)`);\n    return null;\n  }\n  visitLiteralExpr(ast, ctx) {\n    const value = ast.value;\n    if (typeof value === 'string') {\n      ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n    } else {\n      ctx.print(ast, `${value}`);\n    }\n    return null;\n  }\n  visitRegularExpressionLiteral(ast, ctx) {\n    ctx.print(ast, `/${ast.body}/${ast.flags || ''}`);\n    return null;\n  }\n  visitLocalizedString(ast, ctx) {\n    const head = ast.serializeI18nHead();\n    ctx.print(ast, '$localize `' + head.raw);\n    for (let i = 1; i < ast.messageParts.length; i++) {\n      ctx.print(ast, '${');\n      ast.expressions[i - 1].visitExpression(this, ctx);\n      ctx.print(ast, `}${ast.serializeI18nTemplatePart(i).raw}`);\n    }\n    ctx.print(ast, '`');\n    return null;\n  }\n  visitConditionalExpr(ast, ctx) {\n    ctx.print(ast, `(`);\n    ast.condition.visitExpression(this, ctx);\n    ctx.print(ast, '? ');\n    ast.trueCase.visitExpression(this, ctx);\n    ctx.print(ast, ': ');\n    ast.falseCase.visitExpression(this, ctx);\n    ctx.print(ast, `)`);\n    return null;\n  }\n  visitDynamicImportExpr(ast, ctx) {\n    ctx.print(ast, `import(${ast.url})`);\n  }\n  visitNotExpr(ast, ctx) {\n    ctx.print(ast, '!');\n    ast.condition.visitExpression(this, ctx);\n    return null;\n  }\n  visitUnaryOperatorExpr(ast, ctx) {\n    let opStr;\n    switch (ast.operator) {\n      case UnaryOperator.Plus:\n        opStr = '+';\n        break;\n      case UnaryOperator.Minus:\n        opStr = '-';\n        break;\n      default:\n        throw new Error(`Unknown operator ${ast.operator}`);\n    }\n    const parens = ast !== this.lastIfCondition;\n    if (parens) ctx.print(ast, `(`);\n    ctx.print(ast, opStr);\n    ast.expr.visitExpression(this, ctx);\n    if (parens) ctx.print(ast, `)`);\n    return null;\n  }\n  visitBinaryOperatorExpr(ast, ctx) {\n    const operator = BINARY_OPERATORS$1.get(ast.operator);\n    if (!operator) {\n      throw new Error(`Unknown operator ${ast.operator}`);\n    }\n    const parens = ast !== this.lastIfCondition;\n    if (parens) ctx.print(ast, `(`);\n    ast.lhs.visitExpression(this, ctx);\n    ctx.print(ast, ` ${operator} `);\n    ast.rhs.visitExpression(this, ctx);\n    if (parens) ctx.print(ast, `)`);\n    return null;\n  }\n  visitReadPropExpr(ast, ctx) {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `.`);\n    ctx.print(ast, ast.name);\n    return null;\n  }\n  visitReadKeyExpr(ast, ctx) {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `[`);\n    ast.index.visitExpression(this, ctx);\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralArrayExpr(ast, ctx) {\n    ctx.print(ast, `[`);\n    this.visitAllExpressions(ast.entries, ctx, ',');\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralMapExpr(ast, ctx) {\n    ctx.print(ast, `{`);\n    this.visitAllObjects(entry => {\n      ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);\n      entry.value.visitExpression(this, ctx);\n    }, ast.entries, ctx, ',');\n    ctx.print(ast, `}`);\n    return null;\n  }\n  visitCommaExpr(ast, ctx) {\n    ctx.print(ast, '(');\n    this.visitAllExpressions(ast.parts, ctx, ',');\n    ctx.print(ast, ')');\n    return null;\n  }\n  visitParenthesizedExpr(ast, ctx) {\n    ast.expr.visitExpression(this, ctx);\n  }\n  visitAllExpressions(expressions, ctx, separator) {\n    this.visitAllObjects(expr => expr.visitExpression(this, ctx), expressions, ctx, separator);\n  }\n  visitAllObjects(handler, expressions, ctx, separator) {\n    let incrementedIndent = false;\n    for (let i = 0; i < expressions.length; i++) {\n      if (i > 0) {\n        if (ctx.lineLength() > 80) {\n          ctx.print(null, separator, true);\n          if (!incrementedIndent) {\n            ctx.incIndent();\n            ctx.incIndent();\n            incrementedIndent = true;\n          }\n        } else {\n          ctx.print(null, separator, false);\n        }\n      }\n      handler(expressions[i]);\n    }\n    if (incrementedIndent) {\n      ctx.decIndent();\n      ctx.decIndent();\n    }\n  }\n  visitAllStatements(statements, ctx) {\n    statements.forEach(stmt => stmt.visitStatement(this, ctx));\n  }\n}\nfunction escapeIdentifier(input, escapeDollar, alwaysQuote = true) {\n  if (input == null) {\n    return null;\n  }\n  const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match) => {\n    if (match[0] == '$') {\n      return escapeDollar ? '\\\\$' : '$';\n    } else if (match[0] == '\\n') {\n      return '\\\\n';\n    } else if (match[0] == '\\r') {\n      return '\\\\r';\n    } else {\n      return `\\\\${match[0]}`;\n    }\n  });\n  const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n  return requiresQuotes ? `'${body}'` : body;\n}\nfunction _createIndent(count) {\n  let res = '';\n  for (let i = 0; i < count; i++) {\n    res += _INDENT_WITH;\n  }\n  return res;\n}\nfunction typeWithParameters(type, numParams) {\n  if (numParams === 0) {\n    return expressionType(type);\n  }\n  const params = [];\n  for (let i = 0; i < numParams; i++) {\n    params.push(DYNAMIC_TYPE);\n  }\n  return expressionType(type, undefined, params);\n}\nfunction getSafePropertyAccessString(accessor, name) {\n  const escapedName = escapeIdentifier(name, false, false);\n  return escapedName !== name ? `${accessor}[${escapedName}]` : `${accessor}.${name}`;\n}\nfunction jitOnlyGuardedExpression(expr) {\n  return guardedExpression('ngJitMode', expr);\n}\nfunction devOnlyGuardedExpression(expr) {\n  return guardedExpression('ngDevMode', expr);\n}\nfunction guardedExpression(guard, expr) {\n  const guardExpr = new ExternalExpr({\n    name: guard,\n    moduleName: null\n  });\n  const guardNotDefined = new BinaryOperatorExpr(BinaryOperator.Identical, new TypeofExpr(guardExpr), literal('undefined'));\n  const guardUndefinedOrTrue = new BinaryOperatorExpr(BinaryOperator.Or, guardNotDefined, guardExpr, undefined, undefined);\n  return new BinaryOperatorExpr(BinaryOperator.And, guardUndefinedOrTrue, expr);\n}\nfunction wrapReference(value) {\n  const wrapped = new WrappedNodeExpr(value);\n  return {\n    value: wrapped,\n    type: wrapped\n  };\n}\nfunction refsToArray(refs, shouldForwardDeclare) {\n  const values = literalArr(refs.map(ref => ref.value));\n  return shouldForwardDeclare ? arrowFn([], values) : values;\n}\nfunction createMayBeForwardRefExpression(expression, forwardRef) {\n  return {\n    expression,\n    forwardRef\n  };\n}\nfunction convertFromMaybeForwardRefExpression({\n  expression,\n  forwardRef\n}) {\n  switch (forwardRef) {\n    case 0:\n    case 1:\n      return expression;\n    case 2:\n      return generateForwardRef(expression);\n  }\n}\nfunction generateForwardRef(expr) {\n  return importExpr(Identifiers.forwardRef).callFn([arrowFn([], expr)]);\n}\nvar R3FactoryDelegateType;\n(function (R3FactoryDelegateType) {\n  R3FactoryDelegateType[R3FactoryDelegateType[\"Class\"] = 0] = \"Class\";\n  R3FactoryDelegateType[R3FactoryDelegateType[\"Function\"] = 1] = \"Function\";\n})(R3FactoryDelegateType || (R3FactoryDelegateType = {}));\nfunction compileFactoryFunction(meta) {\n  const t = variable('__ngFactoryType__');\n  let baseFactoryVar = null;\n  const typeForCtor = !isDelegatedFactoryMetadata(meta) ? new BinaryOperatorExpr(BinaryOperator.Or, t, meta.type.value) : t;\n  let ctorExpr = null;\n  if (meta.deps !== null) {\n    if (meta.deps !== 'invalid') {\n      ctorExpr = new InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.target));\n    }\n  } else {\n    baseFactoryVar = variable(`Éµ${meta.name}_BaseFactory`);\n    ctorExpr = baseFactoryVar.callFn([typeForCtor]);\n  }\n  const body = [];\n  let retExpr = null;\n  function makeConditionalFactory(nonCtorExpr) {\n    const r = variable('__ngConditionalFactory__');\n    body.push(new DeclareVarStmt(r.name, NULL_EXPR, INFERRED_TYPE));\n    const ctorStmt = ctorExpr !== null ? r.set(ctorExpr).toStmt() : importExpr(Identifiers.invalidFactory).callFn([]).toStmt();\n    body.push(ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));\n    return r;\n  }\n  if (isDelegatedFactoryMetadata(meta)) {\n    const delegateArgs = injectDependencies(meta.delegateDeps, meta.target);\n    const factoryExpr = new (meta.delegateType === R3FactoryDelegateType.Class ? InstantiateExpr : InvokeFunctionExpr)(meta.delegate, delegateArgs);\n    retExpr = makeConditionalFactory(factoryExpr);\n  } else if (isExpressionFactoryMetadata(meta)) {\n    retExpr = makeConditionalFactory(meta.expression);\n  } else {\n    retExpr = ctorExpr;\n  }\n  if (retExpr === null) {\n    body.push(importExpr(Identifiers.invalidFactory).callFn([]).toStmt());\n  } else if (baseFactoryVar !== null) {\n    const getInheritedFactoryCall = importExpr(Identifiers.getInheritedFactory).callFn([meta.type.value]);\n    const baseFactory = new BinaryOperatorExpr(BinaryOperator.Or, baseFactoryVar, baseFactoryVar.set(getInheritedFactoryCall));\n    body.push(new ReturnStatement(baseFactory.callFn([typeForCtor])));\n  } else {\n    body.push(new ReturnStatement(retExpr));\n  }\n  let factoryFn = fn([new FnParam(t.name, DYNAMIC_TYPE)], body, INFERRED_TYPE, undefined, `${meta.name}_Factory`);\n  if (baseFactoryVar !== null) {\n    factoryFn = arrowFn([], [new DeclareVarStmt(baseFactoryVar.name), new ReturnStatement(factoryFn)]).callFn([], undefined, true);\n  }\n  return {\n    expression: factoryFn,\n    statements: [],\n    type: createFactoryType(meta)\n  };\n}\nfunction createFactoryType(meta) {\n  const ctorDepsType = meta.deps !== null && meta.deps !== 'invalid' ? createCtorDepsType(meta.deps) : NONE_TYPE;\n  return expressionType(importExpr(Identifiers.FactoryDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount), ctorDepsType]));\n}\nfunction injectDependencies(deps, target) {\n  return deps.map((dep, index) => compileInjectDependency(dep, target, index));\n}\nfunction compileInjectDependency(dep, target, index) {\n  if (dep.token === null) {\n    return importExpr(Identifiers.invalidFactoryDep).callFn([literal(index)]);\n  } else if (dep.attributeNameType === null) {\n    const flags = 0 | (dep.self ? 2 : 0) | (dep.skipSelf ? 4 : 0) | (dep.host ? 1 : 0) | (dep.optional ? 8 : 0) | (target === FactoryTarget.Pipe ? 16 : 0);\n    let flagsParam = flags !== 0 || dep.optional ? literal(flags) : null;\n    const injectArgs = [dep.token];\n    if (flagsParam) {\n      injectArgs.push(flagsParam);\n    }\n    const injectFn = getInjectFn(target);\n    return importExpr(injectFn).callFn(injectArgs);\n  } else {\n    return importExpr(Identifiers.injectAttribute).callFn([dep.token]);\n  }\n}\nfunction createCtorDepsType(deps) {\n  let hasTypes = false;\n  const attributeTypes = deps.map(dep => {\n    const type = createCtorDepType(dep);\n    if (type !== null) {\n      hasTypes = true;\n      return type;\n    } else {\n      return literal(null);\n    }\n  });\n  if (hasTypes) {\n    return expressionType(literalArr(attributeTypes));\n  } else {\n    return NONE_TYPE;\n  }\n}\nfunction createCtorDepType(dep) {\n  const entries = [];\n  if (dep.attributeNameType !== null) {\n    entries.push({\n      key: 'attribute',\n      value: dep.attributeNameType,\n      quoted: false\n    });\n  }\n  if (dep.optional) {\n    entries.push({\n      key: 'optional',\n      value: literal(true),\n      quoted: false\n    });\n  }\n  if (dep.host) {\n    entries.push({\n      key: 'host',\n      value: literal(true),\n      quoted: false\n    });\n  }\n  if (dep.self) {\n    entries.push({\n      key: 'self',\n      value: literal(true),\n      quoted: false\n    });\n  }\n  if (dep.skipSelf) {\n    entries.push({\n      key: 'skipSelf',\n      value: literal(true),\n      quoted: false\n    });\n  }\n  return entries.length > 0 ? literalMap(entries) : null;\n}\nfunction isDelegatedFactoryMetadata(meta) {\n  return meta.delegateType !== undefined;\n}\nfunction isExpressionFactoryMetadata(meta) {\n  return meta.expression !== undefined;\n}\nfunction getInjectFn(target) {\n  switch (target) {\n    case FactoryTarget.Component:\n    case FactoryTarget.Directive:\n    case FactoryTarget.Pipe:\n      return Identifiers.directiveInject;\n    case FactoryTarget.NgModule:\n    case FactoryTarget.Injectable:\n    default:\n      return Identifiers.inject;\n  }\n}\nclass ParseSpan {\n  start;\n  end;\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n  toAbsolute(absoluteOffset) {\n    return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);\n  }\n}\nclass AST {\n  span;\n  sourceSpan;\n  constructor(span, sourceSpan) {\n    this.span = span;\n    this.sourceSpan = sourceSpan;\n  }\n  toString() {\n    return 'AST';\n  }\n}\nclass ASTWithName extends AST {\n  nameSpan;\n  constructor(span, sourceSpan, nameSpan) {\n    super(span, sourceSpan);\n    this.nameSpan = nameSpan;\n  }\n}\nlet EmptyExpr$1 = class EmptyExpr extends AST {\n  visit(visitor, context = null) {}\n};\nclass ImplicitReceiver extends AST {\n  visit(visitor, context = null) {\n    return visitor.visitImplicitReceiver(this, context);\n  }\n}\nclass ThisReceiver extends ImplicitReceiver {\n  visit(visitor, context = null) {\n    return visitor.visitThisReceiver?.(this, context);\n  }\n}\nclass Chain extends AST {\n  expressions;\n  constructor(span, sourceSpan, expressions) {\n    super(span, sourceSpan);\n    this.expressions = expressions;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitChain(this, context);\n  }\n}\nclass Conditional extends AST {\n  condition;\n  trueExp;\n  falseExp;\n  constructor(span, sourceSpan, condition, trueExp, falseExp) {\n    super(span, sourceSpan);\n    this.condition = condition;\n    this.trueExp = trueExp;\n    this.falseExp = falseExp;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitConditional(this, context);\n  }\n}\nclass PropertyRead extends ASTWithName {\n  receiver;\n  name;\n  constructor(span, sourceSpan, nameSpan, receiver, name) {\n    super(span, sourceSpan, nameSpan);\n    this.receiver = receiver;\n    this.name = name;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitPropertyRead(this, context);\n  }\n}\nclass SafePropertyRead extends ASTWithName {\n  receiver;\n  name;\n  constructor(span, sourceSpan, nameSpan, receiver, name) {\n    super(span, sourceSpan, nameSpan);\n    this.receiver = receiver;\n    this.name = name;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitSafePropertyRead(this, context);\n  }\n}\nclass KeyedRead extends AST {\n  receiver;\n  key;\n  constructor(span, sourceSpan, receiver, key) {\n    super(span, sourceSpan);\n    this.receiver = receiver;\n    this.key = key;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitKeyedRead(this, context);\n  }\n}\nclass SafeKeyedRead extends AST {\n  receiver;\n  key;\n  constructor(span, sourceSpan, receiver, key) {\n    super(span, sourceSpan);\n    this.receiver = receiver;\n    this.key = key;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitSafeKeyedRead(this, context);\n  }\n}\nvar BindingPipeType;\n(function (BindingPipeType) {\n  BindingPipeType[BindingPipeType[\"ReferencedByName\"] = 0] = \"ReferencedByName\";\n  BindingPipeType[BindingPipeType[\"ReferencedDirectly\"] = 1] = \"ReferencedDirectly\";\n})(BindingPipeType || (BindingPipeType = {}));\nclass BindingPipe extends ASTWithName {\n  exp;\n  name;\n  args;\n  type;\n  constructor(span, sourceSpan, exp, name, args, type, nameSpan) {\n    super(span, sourceSpan, nameSpan);\n    this.exp = exp;\n    this.name = name;\n    this.args = args;\n    this.type = type;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitPipe(this, context);\n  }\n}\nclass LiteralPrimitive extends AST {\n  value;\n  constructor(span, sourceSpan, value) {\n    super(span, sourceSpan);\n    this.value = value;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitLiteralPrimitive(this, context);\n  }\n}\nclass LiteralArray extends AST {\n  expressions;\n  constructor(span, sourceSpan, expressions) {\n    super(span, sourceSpan);\n    this.expressions = expressions;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitLiteralArray(this, context);\n  }\n}\nclass LiteralMap extends AST {\n  keys;\n  values;\n  constructor(span, sourceSpan, keys, values) {\n    super(span, sourceSpan);\n    this.keys = keys;\n    this.values = values;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitLiteralMap(this, context);\n  }\n}\nlet Interpolation$1 = class Interpolation extends AST {\n  strings;\n  expressions;\n  constructor(span, sourceSpan, strings, expressions) {\n    super(span, sourceSpan);\n    this.strings = strings;\n    this.expressions = expressions;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitInterpolation(this, context);\n  }\n};\nclass Binary extends AST {\n  operation;\n  left;\n  right;\n  constructor(span, sourceSpan, operation, left, right) {\n    super(span, sourceSpan);\n    this.operation = operation;\n    this.left = left;\n    this.right = right;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitBinary(this, context);\n  }\n  static isAssignmentOperation(op) {\n    return op === '=' || op === '+=' || op === '-=' || op === '*=' || op === '/=' || op === '%=' || op === '**=' || op === '&&=' || op === '||=' || op === '??=';\n  }\n}\nclass Unary extends Binary {\n  operator;\n  expr;\n  left = null;\n  right = null;\n  operation = null;\n  static createMinus(span, sourceSpan, expr) {\n    return new Unary(span, sourceSpan, '-', expr, '-', new LiteralPrimitive(span, sourceSpan, 0), expr);\n  }\n  static createPlus(span, sourceSpan, expr) {\n    return new Unary(span, sourceSpan, '+', expr, '-', expr, new LiteralPrimitive(span, sourceSpan, 0));\n  }\n  constructor(span, sourceSpan, operator, expr, binaryOp, binaryLeft, binaryRight) {\n    super(span, sourceSpan, binaryOp, binaryLeft, binaryRight);\n    this.operator = operator;\n    this.expr = expr;\n  }\n  visit(visitor, context = null) {\n    if (visitor.visitUnary !== undefined) {\n      return visitor.visitUnary(this, context);\n    }\n    return visitor.visitBinary(this, context);\n  }\n}\nclass PrefixNot extends AST {\n  expression;\n  constructor(span, sourceSpan, expression) {\n    super(span, sourceSpan);\n    this.expression = expression;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitPrefixNot(this, context);\n  }\n}\nclass TypeofExpression extends AST {\n  expression;\n  constructor(span, sourceSpan, expression) {\n    super(span, sourceSpan);\n    this.expression = expression;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitTypeofExpression(this, context);\n  }\n}\nclass VoidExpression extends AST {\n  expression;\n  constructor(span, sourceSpan, expression) {\n    super(span, sourceSpan);\n    this.expression = expression;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitVoidExpression(this, context);\n  }\n}\nclass NonNullAssert extends AST {\n  expression;\n  constructor(span, sourceSpan, expression) {\n    super(span, sourceSpan);\n    this.expression = expression;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitNonNullAssert(this, context);\n  }\n}\nclass Call extends AST {\n  receiver;\n  args;\n  argumentSpan;\n  constructor(span, sourceSpan, receiver, args, argumentSpan) {\n    super(span, sourceSpan);\n    this.receiver = receiver;\n    this.args = args;\n    this.argumentSpan = argumentSpan;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitCall(this, context);\n  }\n}\nclass SafeCall extends AST {\n  receiver;\n  args;\n  argumentSpan;\n  constructor(span, sourceSpan, receiver, args, argumentSpan) {\n    super(span, sourceSpan);\n    this.receiver = receiver;\n    this.args = args;\n    this.argumentSpan = argumentSpan;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitSafeCall(this, context);\n  }\n}\nclass TaggedTemplateLiteral extends AST {\n  tag;\n  template;\n  constructor(span, sourceSpan, tag, template) {\n    super(span, sourceSpan);\n    this.tag = tag;\n    this.template = template;\n  }\n  visit(visitor, context) {\n    return visitor.visitTaggedTemplateLiteral(this, context);\n  }\n}\nclass TemplateLiteral extends AST {\n  elements;\n  expressions;\n  constructor(span, sourceSpan, elements, expressions) {\n    super(span, sourceSpan);\n    this.elements = elements;\n    this.expressions = expressions;\n  }\n  visit(visitor, context) {\n    return visitor.visitTemplateLiteral(this, context);\n  }\n}\nclass TemplateLiteralElement extends AST {\n  text;\n  constructor(span, sourceSpan, text) {\n    super(span, sourceSpan);\n    this.text = text;\n  }\n  visit(visitor, context) {\n    return visitor.visitTemplateLiteralElement(this, context);\n  }\n}\nclass ParenthesizedExpression extends AST {\n  expression;\n  constructor(span, sourceSpan, expression) {\n    super(span, sourceSpan);\n    this.expression = expression;\n  }\n  visit(visitor, context) {\n    return visitor.visitParenthesizedExpression(this, context);\n  }\n}\nclass RegularExpressionLiteral extends AST {\n  body;\n  flags;\n  constructor(span, sourceSpan, body, flags) {\n    super(span, sourceSpan);\n    this.body = body;\n    this.flags = flags;\n  }\n  visit(visitor, context) {\n    return visitor.visitRegularExpressionLiteral(this, context);\n  }\n}\nclass AbsoluteSourceSpan {\n  start;\n  end;\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n}\nclass ASTWithSource extends AST {\n  ast;\n  source;\n  location;\n  errors;\n  constructor(ast, source, location, absoluteOffset, errors) {\n    super(new ParseSpan(0, source === null ? 0 : source.length), new AbsoluteSourceSpan(absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length));\n    this.ast = ast;\n    this.source = source;\n    this.location = location;\n    this.errors = errors;\n  }\n  visit(visitor, context = null) {\n    if (visitor.visitASTWithSource) {\n      return visitor.visitASTWithSource(this, context);\n    }\n    return this.ast.visit(visitor, context);\n  }\n  toString() {\n    return `${this.source} in ${this.location}`;\n  }\n}\nclass VariableBinding {\n  sourceSpan;\n  key;\n  value;\n  constructor(sourceSpan, key, value) {\n    this.sourceSpan = sourceSpan;\n    this.key = key;\n    this.value = value;\n  }\n}\nclass ExpressionBinding {\n  sourceSpan;\n  key;\n  value;\n  constructor(sourceSpan, key, value) {\n    this.sourceSpan = sourceSpan;\n    this.key = key;\n    this.value = value;\n  }\n}\nclass RecursiveAstVisitor {\n  visit(ast, context) {\n    ast.visit(this, context);\n  }\n  visitUnary(ast, context) {\n    this.visit(ast.expr, context);\n  }\n  visitBinary(ast, context) {\n    this.visit(ast.left, context);\n    this.visit(ast.right, context);\n  }\n  visitChain(ast, context) {\n    this.visitAll(ast.expressions, context);\n  }\n  visitConditional(ast, context) {\n    this.visit(ast.condition, context);\n    this.visit(ast.trueExp, context);\n    this.visit(ast.falseExp, context);\n  }\n  visitPipe(ast, context) {\n    this.visit(ast.exp, context);\n    this.visitAll(ast.args, context);\n  }\n  visitImplicitReceiver(ast, context) {}\n  visitThisReceiver(ast, context) {}\n  visitInterpolation(ast, context) {\n    this.visitAll(ast.expressions, context);\n  }\n  visitKeyedRead(ast, context) {\n    this.visit(ast.receiver, context);\n    this.visit(ast.key, context);\n  }\n  visitLiteralArray(ast, context) {\n    this.visitAll(ast.expressions, context);\n  }\n  visitLiteralMap(ast, context) {\n    this.visitAll(ast.values, context);\n  }\n  visitLiteralPrimitive(ast, context) {}\n  visitPrefixNot(ast, context) {\n    this.visit(ast.expression, context);\n  }\n  visitTypeofExpression(ast, context) {\n    this.visit(ast.expression, context);\n  }\n  visitVoidExpression(ast, context) {\n    this.visit(ast.expression, context);\n  }\n  visitNonNullAssert(ast, context) {\n    this.visit(ast.expression, context);\n  }\n  visitPropertyRead(ast, context) {\n    this.visit(ast.receiver, context);\n  }\n  visitSafePropertyRead(ast, context) {\n    this.visit(ast.receiver, context);\n  }\n  visitSafeKeyedRead(ast, context) {\n    this.visit(ast.receiver, context);\n    this.visit(ast.key, context);\n  }\n  visitCall(ast, context) {\n    this.visit(ast.receiver, context);\n    this.visitAll(ast.args, context);\n  }\n  visitSafeCall(ast, context) {\n    this.visit(ast.receiver, context);\n    this.visitAll(ast.args, context);\n  }\n  visitTemplateLiteral(ast, context) {\n    for (let i = 0; i < ast.elements.length; i++) {\n      this.visit(ast.elements[i], context);\n      const expression = i < ast.expressions.length ? ast.expressions[i] : null;\n      if (expression !== null) {\n        this.visit(expression, context);\n      }\n    }\n  }\n  visitTemplateLiteralElement(ast, context) {}\n  visitTaggedTemplateLiteral(ast, context) {\n    this.visit(ast.tag, context);\n    this.visit(ast.template, context);\n  }\n  visitParenthesizedExpression(ast, context) {\n    this.visit(ast.expression, context);\n  }\n  visitRegularExpressionLiteral(ast, context) {}\n  visitAll(asts, context) {\n    for (const ast of asts) {\n      this.visit(ast, context);\n    }\n  }\n}\nclass ParsedProperty {\n  name;\n  expression;\n  type;\n  sourceSpan;\n  keySpan;\n  valueSpan;\n  isLiteral;\n  isLegacyAnimation;\n  isAnimation;\n  constructor(name, expression, type, sourceSpan, keySpan, valueSpan) {\n    this.name = name;\n    this.expression = expression;\n    this.type = type;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n    this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;\n    this.isLegacyAnimation = this.type === ParsedPropertyType.LEGACY_ANIMATION;\n    this.isAnimation = this.type === ParsedPropertyType.ANIMATION;\n  }\n}\nvar ParsedPropertyType;\n(function (ParsedPropertyType) {\n  ParsedPropertyType[ParsedPropertyType[\"DEFAULT\"] = 0] = \"DEFAULT\";\n  ParsedPropertyType[ParsedPropertyType[\"LITERAL_ATTR\"] = 1] = \"LITERAL_ATTR\";\n  ParsedPropertyType[ParsedPropertyType[\"LEGACY_ANIMATION\"] = 2] = \"LEGACY_ANIMATION\";\n  ParsedPropertyType[ParsedPropertyType[\"TWO_WAY\"] = 3] = \"TWO_WAY\";\n  ParsedPropertyType[ParsedPropertyType[\"ANIMATION\"] = 4] = \"ANIMATION\";\n})(ParsedPropertyType || (ParsedPropertyType = {}));\nvar ParsedEventType;\n(function (ParsedEventType) {\n  ParsedEventType[ParsedEventType[\"Regular\"] = 0] = \"Regular\";\n  ParsedEventType[ParsedEventType[\"LegacyAnimation\"] = 1] = \"LegacyAnimation\";\n  ParsedEventType[ParsedEventType[\"TwoWay\"] = 2] = \"TwoWay\";\n  ParsedEventType[ParsedEventType[\"Animation\"] = 3] = \"Animation\";\n})(ParsedEventType || (ParsedEventType = {}));\nclass ParsedEvent {\n  name;\n  targetOrPhase;\n  type;\n  handler;\n  sourceSpan;\n  handlerSpan;\n  keySpan;\n  constructor(name, targetOrPhase, type, handler, sourceSpan, handlerSpan, keySpan) {\n    this.name = name;\n    this.targetOrPhase = targetOrPhase;\n    this.type = type;\n    this.handler = handler;\n    this.sourceSpan = sourceSpan;\n    this.handlerSpan = handlerSpan;\n    this.keySpan = keySpan;\n  }\n}\nclass ParsedVariable {\n  name;\n  value;\n  sourceSpan;\n  keySpan;\n  valueSpan;\n  constructor(name, value, sourceSpan, keySpan, valueSpan) {\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n  }\n}\nvar BindingType;\n(function (BindingType) {\n  BindingType[BindingType[\"Property\"] = 0] = \"Property\";\n  BindingType[BindingType[\"Attribute\"] = 1] = \"Attribute\";\n  BindingType[BindingType[\"Class\"] = 2] = \"Class\";\n  BindingType[BindingType[\"Style\"] = 3] = \"Style\";\n  BindingType[BindingType[\"LegacyAnimation\"] = 4] = \"LegacyAnimation\";\n  BindingType[BindingType[\"TwoWay\"] = 5] = \"TwoWay\";\n  BindingType[BindingType[\"Animation\"] = 6] = \"Animation\";\n})(BindingType || (BindingType = {}));\nclass BoundElementProperty {\n  name;\n  type;\n  securityContext;\n  value;\n  unit;\n  sourceSpan;\n  keySpan;\n  valueSpan;\n  constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan) {\n    this.name = name;\n    this.type = type;\n    this.securityContext = securityContext;\n    this.value = value;\n    this.unit = unit;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n  }\n}\nvar TagContentType;\n(function (TagContentType) {\n  TagContentType[TagContentType[\"RAW_TEXT\"] = 0] = \"RAW_TEXT\";\n  TagContentType[TagContentType[\"ESCAPABLE_RAW_TEXT\"] = 1] = \"ESCAPABLE_RAW_TEXT\";\n  TagContentType[TagContentType[\"PARSABLE_DATA\"] = 2] = \"PARSABLE_DATA\";\n})(TagContentType || (TagContentType = {}));\nfunction splitNsName(elementName, fatal = true) {\n  if (elementName[0] != ':') {\n    return [null, elementName];\n  }\n  const colonIndex = elementName.indexOf(':', 1);\n  if (colonIndex === -1) {\n    if (fatal) {\n      throw new Error(`Unsupported format \"${elementName}\" expecting \":namespace:name\"`);\n    } else {\n      return [null, elementName];\n    }\n  }\n  return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n}\nfunction isNgContainer(tagName) {\n  return splitNsName(tagName)[1] === 'ng-container';\n}\nfunction isNgContent(tagName) {\n  return splitNsName(tagName)[1] === 'ng-content';\n}\nfunction isNgTemplate(tagName) {\n  return splitNsName(tagName)[1] === 'ng-template';\n}\nfunction getNsPrefix(fullName) {\n  return fullName === null ? null : splitNsName(fullName)[0];\n}\nfunction mergeNsAndName(prefix, localName) {\n  return prefix ? `:${prefix}:${localName}` : localName;\n}\nlet Comment$1 = class Comment {\n  value;\n  sourceSpan;\n  constructor(value, sourceSpan) {\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(_visitor) {\n    throw new Error('visit() not implemented for Comment');\n  }\n};\nlet Text$3 = class Text {\n  value;\n  sourceSpan;\n  constructor(value, sourceSpan) {\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(visitor) {\n    return visitor.visitText(this);\n  }\n};\nclass BoundText {\n  value;\n  sourceSpan;\n  i18n;\n  constructor(value, sourceSpan, i18n) {\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitBoundText(this);\n  }\n}\nclass TextAttribute {\n  name;\n  value;\n  sourceSpan;\n  keySpan;\n  valueSpan;\n  i18n;\n  constructor(name, value, sourceSpan, keySpan, valueSpan, i18n) {\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitTextAttribute(this);\n  }\n}\nclass BoundAttribute {\n  name;\n  type;\n  securityContext;\n  value;\n  unit;\n  sourceSpan;\n  keySpan;\n  valueSpan;\n  i18n;\n  constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan, i18n) {\n    this.name = name;\n    this.type = type;\n    this.securityContext = securityContext;\n    this.value = value;\n    this.unit = unit;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n    this.i18n = i18n;\n  }\n  static fromBoundElementProperty(prop, i18n) {\n    if (prop.keySpan === undefined) {\n      throw new Error(`Unexpected state: keySpan must be defined for bound attributes but was not for ${prop.name}: ${prop.sourceSpan}`);\n    }\n    return new BoundAttribute(prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n);\n  }\n  visit(visitor) {\n    return visitor.visitBoundAttribute(this);\n  }\n}\nclass BoundEvent {\n  name;\n  type;\n  handler;\n  target;\n  phase;\n  sourceSpan;\n  handlerSpan;\n  keySpan;\n  constructor(name, type, handler, target, phase, sourceSpan, handlerSpan, keySpan) {\n    this.name = name;\n    this.type = type;\n    this.handler = handler;\n    this.target = target;\n    this.phase = phase;\n    this.sourceSpan = sourceSpan;\n    this.handlerSpan = handlerSpan;\n    this.keySpan = keySpan;\n  }\n  static fromParsedEvent(event) {\n    const target = event.type === ParsedEventType.Regular ? event.targetOrPhase : null;\n    const phase = event.type === ParsedEventType.LegacyAnimation ? event.targetOrPhase : null;\n    if (event.keySpan === undefined) {\n      throw new Error(`Unexpected state: keySpan must be defined for bound event but was not for ${event.name}: ${event.sourceSpan}`);\n    }\n    return new BoundEvent(event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan, event.keySpan);\n  }\n  visit(visitor) {\n    return visitor.visitBoundEvent(this);\n  }\n}\nlet Element$1 = class Element {\n  name;\n  attributes;\n  inputs;\n  outputs;\n  directives;\n  children;\n  references;\n  isSelfClosing;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  isVoid;\n  i18n;\n  constructor(name, attributes, inputs, outputs, directives, children, references, isSelfClosing, sourceSpan, startSourceSpan, endSourceSpan, isVoid, i18n) {\n    this.name = name;\n    this.attributes = attributes;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.directives = directives;\n    this.children = children;\n    this.references = references;\n    this.isSelfClosing = isSelfClosing;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n    this.isVoid = isVoid;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitElement(this);\n  }\n};\nclass DeferredTrigger {\n  nameSpan;\n  sourceSpan;\n  prefetchSpan;\n  whenOrOnSourceSpan;\n  hydrateSpan;\n  constructor(nameSpan, sourceSpan, prefetchSpan, whenOrOnSourceSpan, hydrateSpan) {\n    this.nameSpan = nameSpan;\n    this.sourceSpan = sourceSpan;\n    this.prefetchSpan = prefetchSpan;\n    this.whenOrOnSourceSpan = whenOrOnSourceSpan;\n    this.hydrateSpan = hydrateSpan;\n  }\n  visit(visitor) {\n    return visitor.visitDeferredTrigger(this);\n  }\n}\nclass BoundDeferredTrigger extends DeferredTrigger {\n  value;\n  constructor(value, sourceSpan, prefetchSpan, whenSourceSpan, hydrateSpan) {\n    super(null, sourceSpan, prefetchSpan, whenSourceSpan, hydrateSpan);\n    this.value = value;\n  }\n}\nclass NeverDeferredTrigger extends DeferredTrigger {}\nclass IdleDeferredTrigger extends DeferredTrigger {}\nclass ImmediateDeferredTrigger extends DeferredTrigger {}\nclass HoverDeferredTrigger extends DeferredTrigger {\n  reference;\n  constructor(reference, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan) {\n    super(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n    this.reference = reference;\n  }\n}\nclass TimerDeferredTrigger extends DeferredTrigger {\n  delay;\n  constructor(delay, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan) {\n    super(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n    this.delay = delay;\n  }\n}\nclass InteractionDeferredTrigger extends DeferredTrigger {\n  reference;\n  constructor(reference, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan) {\n    super(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n    this.reference = reference;\n  }\n}\nclass ViewportDeferredTrigger extends DeferredTrigger {\n  reference;\n  options;\n  constructor(reference, options, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan) {\n    super(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n    this.reference = reference;\n    this.options = options;\n  }\n}\nclass BlockNode {\n  nameSpan;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  constructor(nameSpan, sourceSpan, startSourceSpan, endSourceSpan) {\n    this.nameSpan = nameSpan;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n  }\n}\nclass DeferredBlockPlaceholder extends BlockNode {\n  children;\n  minimumTime;\n  i18n;\n  constructor(children, minimumTime, nameSpan, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.children = children;\n    this.minimumTime = minimumTime;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitDeferredBlockPlaceholder(this);\n  }\n}\nclass DeferredBlockLoading extends BlockNode {\n  children;\n  afterTime;\n  minimumTime;\n  i18n;\n  constructor(children, afterTime, minimumTime, nameSpan, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.children = children;\n    this.afterTime = afterTime;\n    this.minimumTime = minimumTime;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitDeferredBlockLoading(this);\n  }\n}\nclass DeferredBlockError extends BlockNode {\n  children;\n  i18n;\n  constructor(children, nameSpan, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.children = children;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitDeferredBlockError(this);\n  }\n}\nclass DeferredBlock extends BlockNode {\n  children;\n  placeholder;\n  loading;\n  error;\n  mainBlockSpan;\n  i18n;\n  triggers;\n  prefetchTriggers;\n  hydrateTriggers;\n  definedTriggers;\n  definedPrefetchTriggers;\n  definedHydrateTriggers;\n  constructor(children, triggers, prefetchTriggers, hydrateTriggers, placeholder, loading, error, nameSpan, sourceSpan, mainBlockSpan, startSourceSpan, endSourceSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.children = children;\n    this.placeholder = placeholder;\n    this.loading = loading;\n    this.error = error;\n    this.mainBlockSpan = mainBlockSpan;\n    this.i18n = i18n;\n    this.triggers = triggers;\n    this.prefetchTriggers = prefetchTriggers;\n    this.hydrateTriggers = hydrateTriggers;\n    this.definedTriggers = Object.keys(triggers);\n    this.definedPrefetchTriggers = Object.keys(prefetchTriggers);\n    this.definedHydrateTriggers = Object.keys(hydrateTriggers);\n  }\n  visit(visitor) {\n    return visitor.visitDeferredBlock(this);\n  }\n  visitAll(visitor) {\n    this.visitTriggers(this.definedHydrateTriggers, this.hydrateTriggers, visitor);\n    this.visitTriggers(this.definedTriggers, this.triggers, visitor);\n    this.visitTriggers(this.definedPrefetchTriggers, this.prefetchTriggers, visitor);\n    visitAll$1(visitor, this.children);\n    const remainingBlocks = [this.placeholder, this.loading, this.error].filter(x => x !== null);\n    visitAll$1(visitor, remainingBlocks);\n  }\n  visitTriggers(keys, triggers, visitor) {\n    visitAll$1(visitor, keys.map(k => triggers[k]));\n  }\n}\nclass SwitchBlock extends BlockNode {\n  expression;\n  cases;\n  unknownBlocks;\n  constructor(expression, cases, unknownBlocks, sourceSpan, startSourceSpan, endSourceSpan, nameSpan) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.expression = expression;\n    this.cases = cases;\n    this.unknownBlocks = unknownBlocks;\n  }\n  visit(visitor) {\n    return visitor.visitSwitchBlock(this);\n  }\n}\nclass SwitchBlockCase extends BlockNode {\n  expression;\n  children;\n  i18n;\n  constructor(expression, children, sourceSpan, startSourceSpan, endSourceSpan, nameSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.expression = expression;\n    this.children = children;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitSwitchBlockCase(this);\n  }\n}\nclass ForLoopBlock extends BlockNode {\n  item;\n  expression;\n  trackBy;\n  trackKeywordSpan;\n  contextVariables;\n  children;\n  empty;\n  mainBlockSpan;\n  i18n;\n  constructor(item, expression, trackBy, trackKeywordSpan, contextVariables, children, empty, sourceSpan, mainBlockSpan, startSourceSpan, endSourceSpan, nameSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.item = item;\n    this.expression = expression;\n    this.trackBy = trackBy;\n    this.trackKeywordSpan = trackKeywordSpan;\n    this.contextVariables = contextVariables;\n    this.children = children;\n    this.empty = empty;\n    this.mainBlockSpan = mainBlockSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitForLoopBlock(this);\n  }\n}\nclass ForLoopBlockEmpty extends BlockNode {\n  children;\n  i18n;\n  constructor(children, sourceSpan, startSourceSpan, endSourceSpan, nameSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.children = children;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitForLoopBlockEmpty(this);\n  }\n}\nclass IfBlock extends BlockNode {\n  branches;\n  constructor(branches, sourceSpan, startSourceSpan, endSourceSpan, nameSpan) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.branches = branches;\n  }\n  visit(visitor) {\n    return visitor.visitIfBlock(this);\n  }\n}\nclass IfBlockBranch extends BlockNode {\n  expression;\n  children;\n  expressionAlias;\n  i18n;\n  constructor(expression, children, expressionAlias, sourceSpan, startSourceSpan, endSourceSpan, nameSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.expression = expression;\n    this.children = children;\n    this.expressionAlias = expressionAlias;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitIfBlockBranch(this);\n  }\n}\nclass UnknownBlock {\n  name;\n  sourceSpan;\n  nameSpan;\n  constructor(name, sourceSpan, nameSpan) {\n    this.name = name;\n    this.sourceSpan = sourceSpan;\n    this.nameSpan = nameSpan;\n  }\n  visit(visitor) {\n    return visitor.visitUnknownBlock(this);\n  }\n}\nlet LetDeclaration$1 = class LetDeclaration {\n  name;\n  value;\n  sourceSpan;\n  nameSpan;\n  valueSpan;\n  constructor(name, value, sourceSpan, nameSpan, valueSpan) {\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.nameSpan = nameSpan;\n    this.valueSpan = valueSpan;\n  }\n  visit(visitor) {\n    return visitor.visitLetDeclaration(this);\n  }\n};\nlet Component$1 = class Component {\n  componentName;\n  tagName;\n  fullName;\n  attributes;\n  inputs;\n  outputs;\n  directives;\n  children;\n  references;\n  isSelfClosing;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  i18n;\n  constructor(componentName, tagName, fullName, attributes, inputs, outputs, directives, children, references, isSelfClosing, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    this.componentName = componentName;\n    this.tagName = tagName;\n    this.fullName = fullName;\n    this.attributes = attributes;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.directives = directives;\n    this.children = children;\n    this.references = references;\n    this.isSelfClosing = isSelfClosing;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitComponent(this);\n  }\n};\nlet Directive$1 = class Directive {\n  name;\n  attributes;\n  inputs;\n  outputs;\n  references;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  i18n;\n  constructor(name, attributes, inputs, outputs, references, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    this.name = name;\n    this.attributes = attributes;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.references = references;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitDirective(this);\n  }\n};\nclass Template {\n  tagName;\n  attributes;\n  inputs;\n  outputs;\n  directives;\n  templateAttrs;\n  children;\n  references;\n  variables;\n  isSelfClosing;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  i18n;\n  constructor(tagName, attributes, inputs, outputs, directives, templateAttrs, children, references, variables, isSelfClosing, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    this.tagName = tagName;\n    this.attributes = attributes;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.directives = directives;\n    this.templateAttrs = templateAttrs;\n    this.children = children;\n    this.references = references;\n    this.variables = variables;\n    this.isSelfClosing = isSelfClosing;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitTemplate(this);\n  }\n}\nclass Content {\n  selector;\n  attributes;\n  children;\n  isSelfClosing;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  i18n;\n  name = 'ng-content';\n  constructor(selector, attributes, children, isSelfClosing, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    this.selector = selector;\n    this.attributes = attributes;\n    this.children = children;\n    this.isSelfClosing = isSelfClosing;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitContent(this);\n  }\n}\nclass Variable {\n  name;\n  value;\n  sourceSpan;\n  keySpan;\n  valueSpan;\n  constructor(name, value, sourceSpan, keySpan, valueSpan) {\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n  }\n  visit(visitor) {\n    return visitor.visitVariable(this);\n  }\n}\nclass Reference {\n  name;\n  value;\n  sourceSpan;\n  keySpan;\n  valueSpan;\n  constructor(name, value, sourceSpan, keySpan, valueSpan) {\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n  }\n  visit(visitor) {\n    return visitor.visitReference(this);\n  }\n}\nlet Icu$1 = class Icu {\n  vars;\n  placeholders;\n  sourceSpan;\n  i18n;\n  constructor(vars, placeholders, sourceSpan, i18n) {\n    this.vars = vars;\n    this.placeholders = placeholders;\n    this.sourceSpan = sourceSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitIcu(this);\n  }\n};\nclass HostElement {\n  tagNames;\n  bindings;\n  listeners;\n  sourceSpan;\n  constructor(tagNames, bindings, listeners, sourceSpan) {\n    this.tagNames = tagNames;\n    this.bindings = bindings;\n    this.listeners = listeners;\n    this.sourceSpan = sourceSpan;\n    if (tagNames.length === 0) {\n      throw new Error('HostElement must have at least one tag name.');\n    }\n  }\n  visit() {\n    throw new Error(`HostElement cannot be visited`);\n  }\n}\nlet RecursiveVisitor$1 = class RecursiveVisitor {\n  visitElement(element) {\n    visitAll$1(this, element.attributes);\n    visitAll$1(this, element.inputs);\n    visitAll$1(this, element.outputs);\n    visitAll$1(this, element.directives);\n    visitAll$1(this, element.children);\n    visitAll$1(this, element.references);\n  }\n  visitTemplate(template) {\n    visitAll$1(this, template.attributes);\n    visitAll$1(this, template.inputs);\n    visitAll$1(this, template.outputs);\n    visitAll$1(this, template.directives);\n    visitAll$1(this, template.children);\n    visitAll$1(this, template.references);\n    visitAll$1(this, template.variables);\n  }\n  visitDeferredBlock(deferred) {\n    deferred.visitAll(this);\n  }\n  visitDeferredBlockPlaceholder(block) {\n    visitAll$1(this, block.children);\n  }\n  visitDeferredBlockError(block) {\n    visitAll$1(this, block.children);\n  }\n  visitDeferredBlockLoading(block) {\n    visitAll$1(this, block.children);\n  }\n  visitSwitchBlock(block) {\n    visitAll$1(this, block.cases);\n  }\n  visitSwitchBlockCase(block) {\n    visitAll$1(this, block.children);\n  }\n  visitForLoopBlock(block) {\n    const blockItems = [block.item, ...block.contextVariables, ...block.children];\n    block.empty && blockItems.push(block.empty);\n    visitAll$1(this, blockItems);\n  }\n  visitForLoopBlockEmpty(block) {\n    visitAll$1(this, block.children);\n  }\n  visitIfBlock(block) {\n    visitAll$1(this, block.branches);\n  }\n  visitIfBlockBranch(block) {\n    const blockItems = block.children;\n    block.expressionAlias && blockItems.push(block.expressionAlias);\n    visitAll$1(this, blockItems);\n  }\n  visitContent(content) {\n    visitAll$1(this, content.children);\n  }\n  visitComponent(component) {\n    visitAll$1(this, component.attributes);\n    visitAll$1(this, component.inputs);\n    visitAll$1(this, component.outputs);\n    visitAll$1(this, component.directives);\n    visitAll$1(this, component.children);\n    visitAll$1(this, component.references);\n  }\n  visitDirective(directive) {\n    visitAll$1(this, directive.attributes);\n    visitAll$1(this, directive.inputs);\n    visitAll$1(this, directive.outputs);\n    visitAll$1(this, directive.references);\n  }\n  visitVariable(variable) {}\n  visitReference(reference) {}\n  visitTextAttribute(attribute) {}\n  visitBoundAttribute(attribute) {}\n  visitBoundEvent(attribute) {}\n  visitText(text) {}\n  visitBoundText(text) {}\n  visitIcu(icu) {}\n  visitDeferredTrigger(trigger) {}\n  visitUnknownBlock(block) {}\n  visitLetDeclaration(decl) {}\n};\nfunction visitAll$1(visitor, nodes) {\n  const result = [];\n  if (visitor.visit) {\n    for (const node of nodes) {\n      visitor.visit(node);\n    }\n  } else {\n    for (const node of nodes) {\n      const newNode = node.visit(visitor);\n      if (newNode) {\n        result.push(newNode);\n      }\n    }\n  }\n  return result;\n}\nclass Message {\n  nodes;\n  placeholders;\n  placeholderToMessage;\n  meaning;\n  description;\n  customId;\n  sources;\n  id;\n  legacyIds = [];\n  messageString;\n  constructor(nodes, placeholders, placeholderToMessage, meaning, description, customId) {\n    this.nodes = nodes;\n    this.placeholders = placeholders;\n    this.placeholderToMessage = placeholderToMessage;\n    this.meaning = meaning;\n    this.description = description;\n    this.customId = customId;\n    this.id = this.customId;\n    this.messageString = serializeMessage(this.nodes);\n    if (nodes.length) {\n      this.sources = [{\n        filePath: nodes[0].sourceSpan.start.file.url,\n        startLine: nodes[0].sourceSpan.start.line + 1,\n        startCol: nodes[0].sourceSpan.start.col + 1,\n        endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n        endCol: nodes[0].sourceSpan.start.col + 1\n      }];\n    } else {\n      this.sources = [];\n    }\n  }\n}\nlet Text$2 = class Text {\n  value;\n  sourceSpan;\n  constructor(value, sourceSpan) {\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitText(this, context);\n  }\n};\nclass Container {\n  children;\n  sourceSpan;\n  constructor(children, sourceSpan) {\n    this.children = children;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitContainer(this, context);\n  }\n}\nclass Icu {\n  expression;\n  type;\n  cases;\n  sourceSpan;\n  expressionPlaceholder;\n  constructor(expression, type, cases, sourceSpan, expressionPlaceholder) {\n    this.expression = expression;\n    this.type = type;\n    this.cases = cases;\n    this.sourceSpan = sourceSpan;\n    this.expressionPlaceholder = expressionPlaceholder;\n  }\n  visit(visitor, context) {\n    return visitor.visitIcu(this, context);\n  }\n}\nclass TagPlaceholder {\n  tag;\n  attrs;\n  startName;\n  closeName;\n  children;\n  isVoid;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  constructor(tag, attrs, startName, closeName, children, isVoid, sourceSpan, startSourceSpan, endSourceSpan) {\n    this.tag = tag;\n    this.attrs = attrs;\n    this.startName = startName;\n    this.closeName = closeName;\n    this.children = children;\n    this.isVoid = isVoid;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitTagPlaceholder(this, context);\n  }\n}\nclass Placeholder {\n  value;\n  name;\n  sourceSpan;\n  constructor(value, name, sourceSpan) {\n    this.value = value;\n    this.name = name;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitPlaceholder(this, context);\n  }\n}\nclass IcuPlaceholder {\n  value;\n  name;\n  sourceSpan;\n  previousMessage;\n  constructor(value, name, sourceSpan) {\n    this.value = value;\n    this.name = name;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitIcuPlaceholder(this, context);\n  }\n}\nclass BlockPlaceholder {\n  name;\n  parameters;\n  startName;\n  closeName;\n  children;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  constructor(name, parameters, startName, closeName, children, sourceSpan, startSourceSpan, endSourceSpan) {\n    this.name = name;\n    this.parameters = parameters;\n    this.startName = startName;\n    this.closeName = closeName;\n    this.children = children;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitBlockPlaceholder(this, context);\n  }\n}\nclass CloneVisitor {\n  visitText(text, context) {\n    return new Text$2(text.value, text.sourceSpan);\n  }\n  visitContainer(container, context) {\n    const children = container.children.map(n => n.visit(this, context));\n    return new Container(children, container.sourceSpan);\n  }\n  visitIcu(icu, context) {\n    const cases = {};\n    Object.keys(icu.cases).forEach(key => cases[key] = icu.cases[key].visit(this, context));\n    const msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan, icu.expressionPlaceholder);\n    return msg;\n  }\n  visitTagPlaceholder(ph, context) {\n    const children = ph.children.map(n => n.visit(this, context));\n    return new TagPlaceholder(ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);\n  }\n  visitPlaceholder(ph, context) {\n    return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n  }\n  visitIcuPlaceholder(ph, context) {\n    return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n  }\n  visitBlockPlaceholder(ph, context) {\n    const children = ph.children.map(n => n.visit(this, context));\n    return new BlockPlaceholder(ph.name, ph.parameters, ph.startName, ph.closeName, children, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);\n  }\n}\nclass RecurseVisitor {\n  visitText(text, context) {}\n  visitContainer(container, context) {\n    container.children.forEach(child => child.visit(this));\n  }\n  visitIcu(icu, context) {\n    Object.keys(icu.cases).forEach(k => {\n      icu.cases[k].visit(this);\n    });\n  }\n  visitTagPlaceholder(ph, context) {\n    ph.children.forEach(child => child.visit(this));\n  }\n  visitPlaceholder(ph, context) {}\n  visitIcuPlaceholder(ph, context) {}\n  visitBlockPlaceholder(ph, context) {\n    ph.children.forEach(child => child.visit(this));\n  }\n}\nfunction serializeMessage(messageNodes) {\n  const visitor = new LocalizeMessageStringVisitor();\n  const str = messageNodes.map(n => n.visit(visitor)).join('');\n  return str;\n}\nclass LocalizeMessageStringVisitor {\n  visitText(text) {\n    return text.value;\n  }\n  visitContainer(container) {\n    return container.children.map(child => child.visit(this)).join('');\n  }\n  visitIcu(icu) {\n    const strCases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n    return `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;\n  }\n  visitTagPlaceholder(ph) {\n    const children = ph.children.map(child => child.visit(this)).join('');\n    return `{$${ph.startName}}${children}{$${ph.closeName}}`;\n  }\n  visitPlaceholder(ph) {\n    return `{$${ph.name}}`;\n  }\n  visitIcuPlaceholder(ph) {\n    return `{$${ph.name}}`;\n  }\n  visitBlockPlaceholder(ph) {\n    const children = ph.children.map(child => child.visit(this)).join('');\n    return `{$${ph.startName}}${children}{$${ph.closeName}}`;\n  }\n}\nclass Serializer {\n  createNameMapper(message) {\n    return null;\n  }\n}\nclass SimplePlaceholderMapper extends RecurseVisitor {\n  mapName;\n  internalToPublic = {};\n  publicToNextId = {};\n  publicToInternal = {};\n  constructor(message, mapName) {\n    super();\n    this.mapName = mapName;\n    message.nodes.forEach(node => node.visit(this));\n  }\n  toPublicName(internalName) {\n    return this.internalToPublic.hasOwnProperty(internalName) ? this.internalToPublic[internalName] : null;\n  }\n  toInternalName(publicName) {\n    return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] : null;\n  }\n  visitText(text, context) {\n    return null;\n  }\n  visitTagPlaceholder(ph, context) {\n    this.visitPlaceholderName(ph.startName);\n    super.visitTagPlaceholder(ph, context);\n    this.visitPlaceholderName(ph.closeName);\n  }\n  visitPlaceholder(ph, context) {\n    this.visitPlaceholderName(ph.name);\n  }\n  visitBlockPlaceholder(ph, context) {\n    this.visitPlaceholderName(ph.startName);\n    super.visitBlockPlaceholder(ph, context);\n    this.visitPlaceholderName(ph.closeName);\n  }\n  visitIcuPlaceholder(ph, context) {\n    this.visitPlaceholderName(ph.name);\n  }\n  visitPlaceholderName(internalName) {\n    if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n      return;\n    }\n    let publicName = this.mapName(internalName);\n    if (this.publicToInternal.hasOwnProperty(publicName)) {\n      const nextId = this.publicToNextId[publicName];\n      this.publicToNextId[publicName] = nextId + 1;\n      publicName = `${publicName}_${nextId}`;\n    } else {\n      this.publicToNextId[publicName] = 1;\n    }\n    this.internalToPublic[internalName] = publicName;\n    this.publicToInternal[publicName] = internalName;\n  }\n}\nlet _Visitor$2 = class _Visitor {\n  visitTag(tag) {\n    const strAttrs = this._serializeAttributes(tag.attrs);\n    if (tag.children.length == 0) {\n      return `<${tag.name}${strAttrs}/>`;\n    }\n    const strChildren = tag.children.map(node => node.visit(this));\n    return `<${tag.name}${strAttrs}>${strChildren.join('')}</${tag.name}>`;\n  }\n  visitText(text) {\n    return text.value;\n  }\n  visitDeclaration(decl) {\n    return `<?xml${this._serializeAttributes(decl.attrs)} ?>`;\n  }\n  _serializeAttributes(attrs) {\n    const strAttrs = Object.keys(attrs).map(name => `${name}=\"${attrs[name]}\"`).join(' ');\n    return strAttrs.length > 0 ? ' ' + strAttrs : '';\n  }\n  visitDoctype(doctype) {\n    return `<!DOCTYPE ${doctype.rootTag} [\\n${doctype.dtd}\\n]>`;\n  }\n};\nconst _visitor = new _Visitor$2();\nfunction serialize$1(nodes) {\n  return nodes.map(node => node.visit(_visitor)).join('');\n}\nclass Declaration {\n  attrs = {};\n  constructor(unescapedAttrs) {\n    Object.keys(unescapedAttrs).forEach(k => {\n      this.attrs[k] = escapeXml(unescapedAttrs[k]);\n    });\n  }\n  visit(visitor) {\n    return visitor.visitDeclaration(this);\n  }\n}\nclass Doctype {\n  rootTag;\n  dtd;\n  constructor(rootTag, dtd) {\n    this.rootTag = rootTag;\n    this.dtd = dtd;\n  }\n  visit(visitor) {\n    return visitor.visitDoctype(this);\n  }\n}\nclass Tag {\n  name;\n  children;\n  attrs = {};\n  constructor(name, unescapedAttrs = {}, children = []) {\n    this.name = name;\n    this.children = children;\n    Object.keys(unescapedAttrs).forEach(k => {\n      this.attrs[k] = escapeXml(unescapedAttrs[k]);\n    });\n  }\n  visit(visitor) {\n    return visitor.visitTag(this);\n  }\n}\nlet Text$1 = class Text {\n  value;\n  constructor(unescapedValue) {\n    this.value = escapeXml(unescapedValue);\n  }\n  visit(visitor) {\n    return visitor.visitText(this);\n  }\n};\nclass CR extends Text$1 {\n  constructor(ws = 0) {\n    super(`\\n${new Array(ws + 1).join(' ')}`);\n  }\n}\nconst _ESCAPED_CHARS = [[/&/g, '&amp;'], [/\"/g, '&quot;'], [/'/g, '&apos;'], [/</g, '&lt;'], [/>/g, '&gt;']];\nfunction escapeXml(text) {\n  return _ESCAPED_CHARS.reduce((text, entry) => text.replace(entry[0], entry[1]), text);\n}\nconst _XMB_HANDLER = 'angular';\nconst _MESSAGES_TAG = 'messagebundle';\nconst _MESSAGE_TAG = 'msg';\nconst _PLACEHOLDER_TAG$3 = 'ph';\nconst _EXAMPLE_TAG = 'ex';\nconst _SOURCE_TAG$2 = 'source';\nconst _DOCTYPE = `<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>`;\nclass Xmb extends Serializer {\n  write(messages, locale) {\n    const exampleVisitor = new ExampleVisitor();\n    const visitor = new _Visitor$1();\n    const rootNode = new Tag(_MESSAGES_TAG);\n    rootNode.attrs['handler'] = _XMB_HANDLER;\n    messages.forEach(message => {\n      const attrs = {\n        id: message.id\n      };\n      if (message.description) {\n        attrs['desc'] = message.description;\n      }\n      if (message.meaning) {\n        attrs['meaning'] = message.meaning;\n      }\n      let sourceTags = [];\n      message.sources.forEach(source => {\n        sourceTags.push(new Tag(_SOURCE_TAG$2, {}, [new Text$1(`${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? ',' + source.endLine : ''}`)]));\n      });\n      rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, [...sourceTags, ...visitor.serialize(message.nodes)]));\n    });\n    rootNode.children.push(new CR());\n    return serialize$1([new Declaration({\n      version: '1.0',\n      encoding: 'UTF-8'\n    }), new CR(), new Doctype(_MESSAGES_TAG, _DOCTYPE), new CR(), exampleVisitor.addDefaultExamples(rootNode), new CR()]);\n  }\n  load(content, url) {\n    throw new Error('Unsupported');\n  }\n  digest(message) {\n    return digest(message);\n  }\n  createNameMapper(message) {\n    return new SimplePlaceholderMapper(message, toPublicName);\n  }\n}\nlet _Visitor$1 = class _Visitor {\n  visitText(text, context) {\n    return [new Text$1(text.value)];\n  }\n  visitContainer(container, context) {\n    const nodes = [];\n    container.children.forEach(node => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n  visitIcu(icu, context) {\n    const nodes = [new Text$1(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n    Object.keys(icu.cases).forEach(c => {\n      nodes.push(new Text$1(`${c} {`), ...icu.cases[c].visit(this), new Text$1(`} `));\n    });\n    nodes.push(new Text$1(`}`));\n    return nodes;\n  }\n  visitTagPlaceholder(ph, context) {\n    const startTagAsText = new Text$1(`<${ph.tag}>`);\n    const startEx = new Tag(_EXAMPLE_TAG, {}, [startTagAsText]);\n    const startTagPh = new Tag(_PLACEHOLDER_TAG$3, {\n      name: ph.startName\n    }, [startEx, startTagAsText]);\n    if (ph.isVoid) {\n      return [startTagPh];\n    }\n    const closeTagAsText = new Text$1(`</${ph.tag}>`);\n    const closeEx = new Tag(_EXAMPLE_TAG, {}, [closeTagAsText]);\n    const closeTagPh = new Tag(_PLACEHOLDER_TAG$3, {\n      name: ph.closeName\n    }, [closeEx, closeTagAsText]);\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n  visitPlaceholder(ph, context) {\n    const interpolationAsText = new Text$1(`{{${ph.value}}}`);\n    const exTag = new Tag(_EXAMPLE_TAG, {}, [interpolationAsText]);\n    return [new Tag(_PLACEHOLDER_TAG$3, {\n      name: ph.name\n    }, [exTag, interpolationAsText])];\n  }\n  visitBlockPlaceholder(ph, context) {\n    const startAsText = new Text$1(`@${ph.name}`);\n    const startEx = new Tag(_EXAMPLE_TAG, {}, [startAsText]);\n    const startTagPh = new Tag(_PLACEHOLDER_TAG$3, {\n      name: ph.startName\n    }, [startEx, startAsText]);\n    const closeAsText = new Text$1(`}`);\n    const closeEx = new Tag(_EXAMPLE_TAG, {}, [closeAsText]);\n    const closeTagPh = new Tag(_PLACEHOLDER_TAG$3, {\n      name: ph.closeName\n    }, [closeEx, closeAsText]);\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n  visitIcuPlaceholder(ph, context) {\n    const icuExpression = ph.value.expression;\n    const icuType = ph.value.type;\n    const icuCases = Object.keys(ph.value.cases).map(value => value + ' {...}').join(' ');\n    const icuAsText = new Text$1(`{${icuExpression}, ${icuType}, ${icuCases}}`);\n    const exTag = new Tag(_EXAMPLE_TAG, {}, [icuAsText]);\n    return [new Tag(_PLACEHOLDER_TAG$3, {\n      name: ph.name\n    }, [exTag, icuAsText])];\n  }\n  serialize(nodes) {\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n};\nfunction digest(message) {\n  return decimalDigest(message);\n}\nclass ExampleVisitor {\n  addDefaultExamples(node) {\n    node.visit(this);\n    return node;\n  }\n  visitTag(tag) {\n    if (tag.name === _PLACEHOLDER_TAG$3) {\n      if (!tag.children || tag.children.length == 0) {\n        const exText = new Text$1(tag.attrs['name'] || '...');\n        tag.children = [new Tag(_EXAMPLE_TAG, {}, [exText])];\n      }\n    } else if (tag.children) {\n      tag.children.forEach(node => node.visit(this));\n    }\n  }\n  visitText(text) {}\n  visitDeclaration(decl) {}\n  visitDoctype(doctype) {}\n}\nfunction toPublicName(internalName) {\n  return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');\n}\nconst I18N_ATTR = 'i18n';\nconst I18N_ATTR_PREFIX = 'i18n-';\nconst I18N_ICU_VAR_PREFIX = 'VAR_';\nfunction isI18nAttribute(name) {\n  return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);\n}\nfunction hasI18nAttrs(node) {\n  return node.attrs.some(attr => isI18nAttribute(attr.name));\n}\nfunction icuFromI18nMessage(message) {\n  return message.nodes[0];\n}\nfunction formatI18nPlaceholderNamesInMap(params = {}, useCamelCase) {\n  const _params = {};\n  if (params && Object.keys(params).length) {\n    Object.keys(params).forEach(key => _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key]);\n  }\n  return _params;\n}\nfunction formatI18nPlaceholderName(name, useCamelCase = true) {\n  const publicName = toPublicName(name);\n  if (!useCamelCase) {\n    return publicName;\n  }\n  const chunks = publicName.split('_');\n  if (chunks.length === 1) {\n    return name.toLowerCase();\n  }\n  let postfix;\n  if (/^\\d+$/.test(chunks[chunks.length - 1])) {\n    postfix = chunks.pop();\n  }\n  let raw = chunks.shift().toLowerCase();\n  if (chunks.length) {\n    raw += chunks.map(c => c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()).join('');\n  }\n  return postfix ? `${raw}_${postfix}` : raw;\n}\nconst UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;\nconst TEMPORARY_NAME = '_t';\nconst CONTEXT_NAME = 'ctx';\nconst RENDER_FLAGS = 'rf';\nfunction temporaryAllocator(pushStatement, name) {\n  let temp = null;\n  return () => {\n    if (!temp) {\n      pushStatement(new DeclareVarStmt(TEMPORARY_NAME, undefined, DYNAMIC_TYPE));\n      temp = variable(name);\n    }\n    return temp;\n  };\n}\nfunction asLiteral(value) {\n  if (Array.isArray(value)) {\n    return literalArr(value.map(asLiteral));\n  }\n  return literal(value, INFERRED_TYPE);\n}\nfunction conditionallyCreateDirectiveBindingLiteral(map, forInputs) {\n  const keys = Object.getOwnPropertyNames(map);\n  if (keys.length === 0) {\n    return null;\n  }\n  return literalMap(keys.map(key => {\n    const value = map[key];\n    let declaredName;\n    let publicName;\n    let minifiedName;\n    let expressionValue;\n    if (typeof value === 'string') {\n      declaredName = key;\n      minifiedName = key;\n      publicName = value;\n      expressionValue = asLiteral(publicName);\n    } else {\n      minifiedName = key;\n      declaredName = value.classPropertyName;\n      publicName = value.bindingPropertyName;\n      const differentDeclaringName = publicName !== declaredName;\n      const hasDecoratorInputTransform = value.transformFunction !== null;\n      let flags = InputFlags.None;\n      if (value.isSignal) {\n        flags |= InputFlags.SignalBased;\n      }\n      if (hasDecoratorInputTransform) {\n        flags |= InputFlags.HasDecoratorInputTransform;\n      }\n      if (forInputs && (differentDeclaringName || hasDecoratorInputTransform || flags !== InputFlags.None)) {\n        const result = [literal(flags), asLiteral(publicName)];\n        if (differentDeclaringName || hasDecoratorInputTransform) {\n          result.push(asLiteral(declaredName));\n          if (hasDecoratorInputTransform) {\n            result.push(value.transformFunction);\n          }\n        }\n        expressionValue = literalArr(result);\n      } else {\n        expressionValue = asLiteral(publicName);\n      }\n    }\n    return {\n      key: minifiedName,\n      quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),\n      value: expressionValue\n    };\n  }));\n}\nclass DefinitionMap {\n  values = [];\n  set(key, value) {\n    if (value) {\n      const existing = this.values.find(value => value.key === key);\n      if (existing) {\n        existing.value = value;\n      } else {\n        this.values.push({\n          key: key,\n          value,\n          quoted: false\n        });\n      }\n    }\n  }\n  toLiteralMap() {\n    return literalMap(this.values);\n  }\n}\nfunction createCssSelectorFromNode(node) {\n  const elementName = node instanceof Element$1 ? node.name : 'ng-template';\n  const attributes = getAttrsForDirectiveMatching(node);\n  const cssSelector = new CssSelector();\n  const elementNameNoNs = splitNsName(elementName)[1];\n  cssSelector.setElement(elementNameNoNs);\n  Object.getOwnPropertyNames(attributes).forEach(name => {\n    const nameNoNs = splitNsName(name)[1];\n    const value = attributes[name];\n    cssSelector.addAttribute(nameNoNs, value);\n    if (name.toLowerCase() === 'class') {\n      const classes = value.trim().split(/\\s+/);\n      classes.forEach(className => cssSelector.addClassName(className));\n    }\n  });\n  return cssSelector;\n}\nfunction getAttrsForDirectiveMatching(elOrTpl) {\n  const attributesMap = {};\n  if (elOrTpl instanceof Template && elOrTpl.tagName !== 'ng-template') {\n    elOrTpl.templateAttrs.forEach(a => attributesMap[a.name] = '');\n  } else {\n    elOrTpl.attributes.forEach(a => {\n      if (!isI18nAttribute(a.name)) {\n        attributesMap[a.name] = a.value;\n      }\n    });\n    elOrTpl.inputs.forEach(i => {\n      if (i.type === BindingType.Property || i.type === BindingType.TwoWay) {\n        attributesMap[i.name] = '';\n      }\n    });\n    elOrTpl.outputs.forEach(o => {\n      attributesMap[o.name] = '';\n    });\n  }\n  return attributesMap;\n}\nfunction compileInjectable(meta, resolveForwardRefs) {\n  let result = null;\n  const factoryMeta = {\n    name: meta.name,\n    type: meta.type,\n    typeArgumentCount: meta.typeArgumentCount,\n    deps: [],\n    target: FactoryTarget.Injectable\n  };\n  if (meta.useClass !== undefined) {\n    const useClassOnSelf = meta.useClass.expression.isEquivalent(meta.type.value);\n    let deps = undefined;\n    if (meta.deps !== undefined) {\n      deps = meta.deps;\n    }\n    if (deps !== undefined) {\n      result = compileFactoryFunction({\n        ...factoryMeta,\n        delegate: meta.useClass.expression,\n        delegateDeps: deps,\n        delegateType: R3FactoryDelegateType.Class\n      });\n    } else if (useClassOnSelf) {\n      result = compileFactoryFunction(factoryMeta);\n    } else {\n      result = {\n        statements: [],\n        expression: delegateToFactory(meta.type.value, meta.useClass.expression, resolveForwardRefs)\n      };\n    }\n  } else if (meta.useFactory !== undefined) {\n    if (meta.deps !== undefined) {\n      result = compileFactoryFunction({\n        ...factoryMeta,\n        delegate: meta.useFactory,\n        delegateDeps: meta.deps || [],\n        delegateType: R3FactoryDelegateType.Function\n      });\n    } else {\n      result = {\n        statements: [],\n        expression: arrowFn([], meta.useFactory.callFn([]))\n      };\n    }\n  } else if (meta.useValue !== undefined) {\n    result = compileFactoryFunction({\n      ...factoryMeta,\n      expression: meta.useValue.expression\n    });\n  } else if (meta.useExisting !== undefined) {\n    result = compileFactoryFunction({\n      ...factoryMeta,\n      expression: importExpr(Identifiers.inject).callFn([meta.useExisting.expression])\n    });\n  } else {\n    result = {\n      statements: [],\n      expression: delegateToFactory(meta.type.value, meta.type.value, resolveForwardRefs)\n    };\n  }\n  const token = meta.type.value;\n  const injectableProps = new DefinitionMap();\n  injectableProps.set('token', token);\n  injectableProps.set('factory', result.expression);\n  if (meta.providedIn.expression.value !== null) {\n    injectableProps.set('providedIn', convertFromMaybeForwardRefExpression(meta.providedIn));\n  }\n  const expression = importExpr(Identifiers.ÉµÉµdefineInjectable).callFn([injectableProps.toLiteralMap()], undefined, true);\n  return {\n    expression,\n    type: createInjectableType(meta),\n    statements: result.statements\n  };\n}\nfunction createInjectableType(meta) {\n  return new ExpressionType(importExpr(Identifiers.InjectableDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));\n}\nfunction delegateToFactory(type, useType, unwrapForwardRefs) {\n  if (type.node === useType.node) {\n    return useType.prop('Éµfac');\n  }\n  if (!unwrapForwardRefs) {\n    return createFactoryFunction(useType);\n  }\n  const unwrappedType = importExpr(Identifiers.resolveForwardRef).callFn([useType]);\n  return createFactoryFunction(unwrappedType);\n}\nfunction createFactoryFunction(type) {\n  const t = new FnParam('__ngFactoryType__', DYNAMIC_TYPE);\n  return arrowFn([t], type.prop('Éµfac').callFn([variable(t.name)]));\n}\nconst $EOF = 0;\nconst $BSPACE = 8;\nconst $TAB = 9;\nconst $LF = 10;\nconst $VTAB = 11;\nconst $FF = 12;\nconst $CR = 13;\nconst $SPACE = 32;\nconst $BANG = 33;\nconst $DQ = 34;\nconst $HASH = 35;\nconst $$ = 36;\nconst $PERCENT = 37;\nconst $AMPERSAND = 38;\nconst $SQ = 39;\nconst $LPAREN = 40;\nconst $RPAREN = 41;\nconst $STAR = 42;\nconst $PLUS = 43;\nconst $COMMA = 44;\nconst $MINUS = 45;\nconst $PERIOD = 46;\nconst $SLASH = 47;\nconst $COLON = 58;\nconst $SEMICOLON = 59;\nconst $LT = 60;\nconst $EQ = 61;\nconst $GT = 62;\nconst $QUESTION = 63;\nconst $0 = 48;\nconst $7 = 55;\nconst $9 = 57;\nconst $A = 65;\nconst $E = 69;\nconst $F = 70;\nconst $X = 88;\nconst $Z = 90;\nconst $LBRACKET = 91;\nconst $BACKSLASH = 92;\nconst $RBRACKET = 93;\nconst $CARET = 94;\nconst $_ = 95;\nconst $a = 97;\nconst $b = 98;\nconst $e = 101;\nconst $f = 102;\nconst $n = 110;\nconst $r = 114;\nconst $t = 116;\nconst $u = 117;\nconst $v = 118;\nconst $x = 120;\nconst $z = 122;\nconst $LBRACE = 123;\nconst $BAR = 124;\nconst $RBRACE = 125;\nconst $NBSP = 160;\nconst $AT = 64;\nconst $BT = 96;\nfunction isWhitespace(code) {\n  return code >= $TAB && code <= $SPACE || code == $NBSP;\n}\nfunction isDigit(code) {\n  return $0 <= code && code <= $9;\n}\nfunction isAsciiLetter(code) {\n  return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\nfunction isAsciiHexDigit(code) {\n  return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}\nfunction isNewLine(code) {\n  return code === $LF || code === $CR;\n}\nfunction isOctalDigit(code) {\n  return $0 <= code && code <= $7;\n}\nfunction isQuote(code) {\n  return code === $SQ || code === $DQ || code === $BT;\n}\nclass ParseLocation {\n  file;\n  offset;\n  line;\n  col;\n  constructor(file, offset, line, col) {\n    this.file = file;\n    this.offset = offset;\n    this.line = line;\n    this.col = col;\n  }\n  toString() {\n    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;\n  }\n  moveBy(delta) {\n    const source = this.file.content;\n    const len = source.length;\n    let offset = this.offset;\n    let line = this.line;\n    let col = this.col;\n    while (offset > 0 && delta < 0) {\n      offset--;\n      delta++;\n      const ch = source.charCodeAt(offset);\n      if (ch == $LF) {\n        line--;\n        const priorLine = source.substring(0, offset - 1).lastIndexOf(String.fromCharCode($LF));\n        col = priorLine > 0 ? offset - priorLine : offset;\n      } else {\n        col--;\n      }\n    }\n    while (offset < len && delta > 0) {\n      const ch = source.charCodeAt(offset);\n      offset++;\n      delta--;\n      if (ch == $LF) {\n        line++;\n        col = 0;\n      } else {\n        col++;\n      }\n    }\n    return new ParseLocation(this.file, offset, line, col);\n  }\n  getContext(maxChars, maxLines) {\n    const content = this.file.content;\n    let startOffset = this.offset;\n    if (startOffset != null) {\n      if (startOffset > content.length - 1) {\n        startOffset = content.length - 1;\n      }\n      let endOffset = startOffset;\n      let ctxChars = 0;\n      let ctxLines = 0;\n      while (ctxChars < maxChars && startOffset > 0) {\n        startOffset--;\n        ctxChars++;\n        if (content[startOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n      ctxChars = 0;\n      ctxLines = 0;\n      while (ctxChars < maxChars && endOffset < content.length - 1) {\n        endOffset++;\n        ctxChars++;\n        if (content[endOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n      return {\n        before: content.substring(startOffset, this.offset),\n        after: content.substring(this.offset, endOffset + 1)\n      };\n    }\n    return null;\n  }\n}\nclass ParseSourceFile {\n  content;\n  url;\n  constructor(content, url) {\n    this.content = content;\n    this.url = url;\n  }\n}\nclass ParseSourceSpan {\n  start;\n  end;\n  fullStart;\n  details;\n  constructor(start, end, fullStart = start, details = null) {\n    this.start = start;\n    this.end = end;\n    this.fullStart = fullStart;\n    this.details = details;\n  }\n  toString() {\n    return this.start.file.content.substring(this.start.offset, this.end.offset);\n  }\n}\nvar ParseErrorLevel;\n(function (ParseErrorLevel) {\n  ParseErrorLevel[ParseErrorLevel[\"WARNING\"] = 0] = \"WARNING\";\n  ParseErrorLevel[ParseErrorLevel[\"ERROR\"] = 1] = \"ERROR\";\n})(ParseErrorLevel || (ParseErrorLevel = {}));\nclass ParseError extends Error {\n  span;\n  msg;\n  level;\n  relatedError;\n  constructor(span, msg, level = ParseErrorLevel.ERROR, relatedError) {\n    super(msg);\n    this.span = span;\n    this.msg = msg;\n    this.level = level;\n    this.relatedError = relatedError;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n  contextualMessage() {\n    const ctx = this.span.start.getContext(100, 3);\n    return ctx ? `${this.msg} (\"${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}\")` : this.msg;\n  }\n  toString() {\n    const details = this.span.details ? `, ${this.span.details}` : '';\n    return `${this.contextualMessage()}: ${this.span.start}${details}`;\n  }\n}\nfunction r3JitTypeSourceSpan(kind, typeName, sourceUrl) {\n  const sourceFileName = `in ${kind} ${typeName} in ${sourceUrl}`;\n  const sourceFile = new ParseSourceFile('', sourceFileName);\n  return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\nlet _anonymousTypeIndex = 0;\nfunction identifierName(compileIdentifier) {\n  if (!compileIdentifier || !compileIdentifier.reference) {\n    return null;\n  }\n  const ref = compileIdentifier.reference;\n  if (ref['__anonymousType']) {\n    return ref['__anonymousType'];\n  }\n  if (ref['__forward_ref__']) {\n    return '__forward_ref__';\n  }\n  let identifier = stringify(ref);\n  if (identifier.indexOf('(') >= 0) {\n    identifier = `anonymous_${_anonymousTypeIndex++}`;\n    ref['__anonymousType'] = identifier;\n  } else {\n    identifier = sanitizeIdentifier(identifier);\n  }\n  return identifier;\n}\nfunction sanitizeIdentifier(name) {\n  return name.replace(/\\W/g, '_');\n}\nconst makeTemplateObjectPolyfill = '(this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,\"raw\",{value:t}):e.raw=t,e})';\nclass AbstractJsEmitterVisitor extends AbstractEmitterVisitor {\n  constructor() {\n    super(false);\n  }\n  visitWrappedNodeExpr(ast, ctx) {\n    throw new Error('Cannot emit a WrappedNodeExpr in Javascript.');\n  }\n  visitDeclareVarStmt(stmt, ctx) {\n    ctx.print(stmt, `var ${stmt.name}`);\n    if (stmt.value) {\n      ctx.print(stmt, ' = ');\n      stmt.value.visitExpression(this, ctx);\n    }\n    ctx.println(stmt, `;`);\n    return null;\n  }\n  visitTaggedTemplateLiteralExpr(ast, ctx) {\n    const elements = ast.template.elements;\n    ast.tag.visitExpression(this, ctx);\n    ctx.print(ast, `(${makeTemplateObjectPolyfill}(`);\n    ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.text, false)).join(', ')}], `);\n    ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.rawText, false)).join(', ')}])`);\n    ast.template.expressions.forEach(expression => {\n      ctx.print(ast, ', ');\n      expression.visitExpression(this, ctx);\n    });\n    ctx.print(ast, ')');\n    return null;\n  }\n  visitTemplateLiteralExpr(expr, ctx) {\n    ctx.print(expr, '`');\n    for (let i = 0; i < expr.elements.length; i++) {\n      expr.elements[i].visitExpression(this, ctx);\n      const expression = i < expr.expressions.length ? expr.expressions[i] : null;\n      if (expression !== null) {\n        ctx.print(expression, '${');\n        expression.visitExpression(this, ctx);\n        ctx.print(expression, '}');\n      }\n    }\n    ctx.print(expr, '`');\n  }\n  visitTemplateLiteralElementExpr(expr, ctx) {\n    ctx.print(expr, expr.rawText);\n    return null;\n  }\n  visitFunctionExpr(ast, ctx) {\n    ctx.print(ast, `function${ast.name ? ' ' + ast.name : ''}(`);\n    this._visitParams(ast.params, ctx);\n    ctx.println(ast, `) {`);\n    ctx.incIndent();\n    this.visitAllStatements(ast.statements, ctx);\n    ctx.decIndent();\n    ctx.print(ast, `}`);\n    return null;\n  }\n  visitArrowFunctionExpr(ast, ctx) {\n    ctx.print(ast, '(');\n    this._visitParams(ast.params, ctx);\n    ctx.print(ast, ') =>');\n    if (Array.isArray(ast.body)) {\n      ctx.println(ast, `{`);\n      ctx.incIndent();\n      this.visitAllStatements(ast.body, ctx);\n      ctx.decIndent();\n      ctx.print(ast, `}`);\n    } else {\n      const isObjectLiteral = ast.body instanceof LiteralMapExpr;\n      if (isObjectLiteral) {\n        ctx.print(ast, '(');\n      }\n      ast.body.visitExpression(this, ctx);\n      if (isObjectLiteral) {\n        ctx.print(ast, ')');\n      }\n    }\n    return null;\n  }\n  visitDeclareFunctionStmt(stmt, ctx) {\n    ctx.print(stmt, `function ${stmt.name}(`);\n    this._visitParams(stmt.params, ctx);\n    ctx.println(stmt, `) {`);\n    ctx.incIndent();\n    this.visitAllStatements(stmt.statements, ctx);\n    ctx.decIndent();\n    ctx.println(stmt, `}`);\n    return null;\n  }\n  visitLocalizedString(ast, ctx) {\n    ctx.print(ast, `$localize(${makeTemplateObjectPolyfill}(`);\n    const parts = [ast.serializeI18nHead()];\n    for (let i = 1; i < ast.messageParts.length; i++) {\n      parts.push(ast.serializeI18nTemplatePart(i));\n    }\n    ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.cooked, false)).join(', ')}], `);\n    ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.raw, false)).join(', ')}])`);\n    ast.expressions.forEach(expression => {\n      ctx.print(ast, ', ');\n      expression.visitExpression(this, ctx);\n    });\n    ctx.print(ast, ')');\n    return null;\n  }\n  _visitParams(params, ctx) {\n    this.visitAllObjects(param => ctx.print(null, param.name), params, ctx, ',');\n  }\n}\nlet policy;\nfunction getPolicy() {\n  if (policy === undefined) {\n    const trustedTypes = _global['trustedTypes'];\n    policy = null;\n    if (trustedTypes) {\n      try {\n        policy = trustedTypes.createPolicy('angular#unsafe-jit', {\n          createScript: s => s\n        });\n      } catch {}\n    }\n  }\n  return policy;\n}\nfunction trustedScriptFromString(script) {\n  return getPolicy()?.createScript(script) || script;\n}\nfunction newTrustedFunctionForJIT(...args) {\n  if (!_global['trustedTypes']) {\n    return new Function(...args);\n  }\n  const fnArgs = args.slice(0, -1).join(',');\n  const fnBody = args[args.length - 1];\n  const body = `(function anonymous(${fnArgs}\n) { ${fnBody}\n})`;\n  const fn = _global['eval'](trustedScriptFromString(body));\n  if (fn.bind === undefined) {\n    return new Function(...args);\n  }\n  fn.toString = () => body;\n  return fn.bind(_global);\n}\nclass JitEvaluator {\n  evaluateStatements(sourceUrl, statements, refResolver, createSourceMaps) {\n    const converter = new JitEmitterVisitor(refResolver);\n    const ctx = EmitterVisitorContext.createRoot();\n    if (statements.length > 0 && !isUseStrictStatement(statements[0])) {\n      statements = [literal('use strict').toStmt(), ...statements];\n    }\n    converter.visitAllStatements(statements, ctx);\n    converter.createReturnStmt(ctx);\n    return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);\n  }\n  evaluateCode(sourceUrl, ctx, vars, createSourceMap) {\n    let fnBody = `\"use strict\";${ctx.toSource()}\\n//# sourceURL=${sourceUrl}`;\n    const fnArgNames = [];\n    const fnArgValues = [];\n    for (const argName in vars) {\n      fnArgValues.push(vars[argName]);\n      fnArgNames.push(argName);\n    }\n    if (createSourceMap) {\n      const emptyFn = newTrustedFunctionForJIT(...fnArgNames.concat('return null;')).toString();\n      const headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\n      fnBody += `\\n${ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment()}`;\n    }\n    const fn = newTrustedFunctionForJIT(...fnArgNames.concat(fnBody));\n    return this.executeFunction(fn, fnArgValues);\n  }\n  executeFunction(fn, args) {\n    return fn(...args);\n  }\n}\nclass JitEmitterVisitor extends AbstractJsEmitterVisitor {\n  refResolver;\n  _evalArgNames = [];\n  _evalArgValues = [];\n  _evalExportedVars = [];\n  constructor(refResolver) {\n    super();\n    this.refResolver = refResolver;\n  }\n  createReturnStmt(ctx) {\n    const stmt = new ReturnStatement(new LiteralMapExpr(this._evalExportedVars.map(resultVar => new LiteralMapEntry(resultVar, variable(resultVar), false))));\n    stmt.visitStatement(this, ctx);\n  }\n  getArgs() {\n    const result = {};\n    for (let i = 0; i < this._evalArgNames.length; i++) {\n      result[this._evalArgNames[i]] = this._evalArgValues[i];\n    }\n    return result;\n  }\n  visitExternalExpr(ast, ctx) {\n    this._emitReferenceToExternal(ast, this.refResolver.resolveExternalReference(ast.value), ctx);\n    return null;\n  }\n  visitWrappedNodeExpr(ast, ctx) {\n    this._emitReferenceToExternal(ast, ast.node, ctx);\n    return null;\n  }\n  visitDeclareVarStmt(stmt, ctx) {\n    if (stmt.hasModifier(StmtModifier.Exported)) {\n      this._evalExportedVars.push(stmt.name);\n    }\n    return super.visitDeclareVarStmt(stmt, ctx);\n  }\n  visitDeclareFunctionStmt(stmt, ctx) {\n    if (stmt.hasModifier(StmtModifier.Exported)) {\n      this._evalExportedVars.push(stmt.name);\n    }\n    return super.visitDeclareFunctionStmt(stmt, ctx);\n  }\n  _emitReferenceToExternal(ast, value, ctx) {\n    let id = this._evalArgValues.indexOf(value);\n    if (id === -1) {\n      id = this._evalArgValues.length;\n      this._evalArgValues.push(value);\n      const name = identifierName({\n        reference: value\n      }) || 'val';\n      this._evalArgNames.push(`jit_${name}_${id}`);\n    }\n    ctx.print(ast, this._evalArgNames[id]);\n  }\n}\nfunction isUseStrictStatement(statement) {\n  return statement.isEquivalent(literal('use strict').toStmt());\n}\nfunction compileInjector(meta) {\n  const definitionMap = new DefinitionMap();\n  if (meta.providers !== null) {\n    definitionMap.set('providers', meta.providers);\n  }\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', literalArr(meta.imports));\n  }\n  const expression = importExpr(Identifiers.defineInjector).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createInjectorType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createInjectorType(meta) {\n  return new ExpressionType(importExpr(Identifiers.InjectorDeclaration, [new ExpressionType(meta.type.type)]));\n}\nclass R3JitReflector {\n  context;\n  constructor(context) {\n    this.context = context;\n  }\n  resolveExternalReference(ref) {\n    if (ref.moduleName !== '@angular/core') {\n      throw new Error(`Cannot resolve external reference to ${ref.moduleName}, only references to @angular/core are supported.`);\n    }\n    if (!this.context.hasOwnProperty(ref.name)) {\n      throw new Error(`No value provided for @angular/core symbol '${ref.name}'.`);\n    }\n    return this.context[ref.name];\n  }\n}\nvar R3SelectorScopeMode;\n(function (R3SelectorScopeMode) {\n  R3SelectorScopeMode[R3SelectorScopeMode[\"Inline\"] = 0] = \"Inline\";\n  R3SelectorScopeMode[R3SelectorScopeMode[\"SideEffect\"] = 1] = \"SideEffect\";\n  R3SelectorScopeMode[R3SelectorScopeMode[\"Omit\"] = 2] = \"Omit\";\n})(R3SelectorScopeMode || (R3SelectorScopeMode = {}));\nvar R3NgModuleMetadataKind;\n(function (R3NgModuleMetadataKind) {\n  R3NgModuleMetadataKind[R3NgModuleMetadataKind[\"Global\"] = 0] = \"Global\";\n  R3NgModuleMetadataKind[R3NgModuleMetadataKind[\"Local\"] = 1] = \"Local\";\n})(R3NgModuleMetadataKind || (R3NgModuleMetadataKind = {}));\nfunction compileNgModule(meta) {\n  const statements = [];\n  const definitionMap = new DefinitionMap();\n  definitionMap.set('type', meta.type.value);\n  if (meta.kind === R3NgModuleMetadataKind.Global && meta.bootstrap.length > 0) {\n    definitionMap.set('bootstrap', refsToArray(meta.bootstrap, meta.containsForwardDecls));\n  }\n  if (meta.selectorScopeMode === R3SelectorScopeMode.Inline) {\n    if (meta.declarations.length > 0) {\n      definitionMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\n    }\n    if (meta.imports.length > 0) {\n      definitionMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\n    }\n    if (meta.exports.length > 0) {\n      definitionMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\n    }\n  } else if (meta.selectorScopeMode === R3SelectorScopeMode.SideEffect) {\n    const setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);\n    if (setNgModuleScopeCall !== null) {\n      statements.push(setNgModuleScopeCall);\n    }\n  } else ;\n  if (meta.schemas !== null && meta.schemas.length > 0) {\n    definitionMap.set('schemas', literalArr(meta.schemas.map(ref => ref.value)));\n  }\n  if (meta.id !== null) {\n    definitionMap.set('id', meta.id);\n    statements.push(importExpr(Identifiers.registerNgModuleType).callFn([meta.type.value, meta.id]).toStmt());\n  }\n  const expression = importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createNgModuleType(meta);\n  return {\n    expression,\n    type,\n    statements\n  };\n}\nfunction compileNgModuleDeclarationExpression(meta) {\n  const definitionMap = new DefinitionMap();\n  definitionMap.set('type', new WrappedNodeExpr(meta.type));\n  if (meta.bootstrap !== undefined) {\n    definitionMap.set('bootstrap', new WrappedNodeExpr(meta.bootstrap));\n  }\n  if (meta.declarations !== undefined) {\n    definitionMap.set('declarations', new WrappedNodeExpr(meta.declarations));\n  }\n  if (meta.imports !== undefined) {\n    definitionMap.set('imports', new WrappedNodeExpr(meta.imports));\n  }\n  if (meta.exports !== undefined) {\n    definitionMap.set('exports', new WrappedNodeExpr(meta.exports));\n  }\n  if (meta.schemas !== undefined) {\n    definitionMap.set('schemas', new WrappedNodeExpr(meta.schemas));\n  }\n  if (meta.id !== undefined) {\n    definitionMap.set('id', new WrappedNodeExpr(meta.id));\n  }\n  return importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()]);\n}\nfunction createNgModuleType(meta) {\n  if (meta.kind === R3NgModuleMetadataKind.Local) {\n    return new ExpressionType(meta.type.value);\n  }\n  const {\n    type: moduleType,\n    declarations,\n    exports,\n    imports,\n    includeImportTypes,\n    publicDeclarationTypes\n  } = meta;\n  return new ExpressionType(importExpr(Identifiers.NgModuleDeclaration, [new ExpressionType(moduleType.type), publicDeclarationTypes === null ? tupleTypeOf(declarations) : tupleOfTypes(publicDeclarationTypes), includeImportTypes ? tupleTypeOf(imports) : NONE_TYPE, tupleTypeOf(exports)]));\n}\nfunction generateSetNgModuleScopeCall(meta) {\n  const scopeMap = new DefinitionMap();\n  if (meta.kind === R3NgModuleMetadataKind.Global) {\n    if (meta.declarations.length > 0) {\n      scopeMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\n    }\n  } else {\n    if (meta.declarationsExpression) {\n      scopeMap.set('declarations', meta.declarationsExpression);\n    }\n  }\n  if (meta.kind === R3NgModuleMetadataKind.Global) {\n    if (meta.imports.length > 0) {\n      scopeMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\n    }\n  } else {\n    if (meta.importsExpression) {\n      scopeMap.set('imports', meta.importsExpression);\n    }\n  }\n  if (meta.kind === R3NgModuleMetadataKind.Global) {\n    if (meta.exports.length > 0) {\n      scopeMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\n    }\n  } else {\n    if (meta.exportsExpression) {\n      scopeMap.set('exports', meta.exportsExpression);\n    }\n  }\n  if (meta.kind === R3NgModuleMetadataKind.Local && meta.bootstrapExpression) {\n    scopeMap.set('bootstrap', meta.bootstrapExpression);\n  }\n  if (Object.keys(scopeMap.values).length === 0) {\n    return null;\n  }\n  const fnCall = new InvokeFunctionExpr(importExpr(Identifiers.setNgModuleScope), [meta.type.value, scopeMap.toLiteralMap()]);\n  const guardedCall = jitOnlyGuardedExpression(fnCall);\n  const iife = new FunctionExpr([], [guardedCall.toStmt()]);\n  const iifeCall = new InvokeFunctionExpr(iife, []);\n  return iifeCall.toStmt();\n}\nfunction tupleTypeOf(exp) {\n  const types = exp.map(ref => typeofExpr(ref.type));\n  return exp.length > 0 ? expressionType(literalArr(types)) : NONE_TYPE;\n}\nfunction tupleOfTypes(types) {\n  const typeofTypes = types.map(type => typeofExpr(type));\n  return types.length > 0 ? expressionType(literalArr(typeofTypes)) : NONE_TYPE;\n}\nfunction compilePipeFromMetadata(metadata) {\n  const definitionMapValues = [];\n  definitionMapValues.push({\n    key: 'name',\n    value: literal(metadata.pipeName ?? metadata.name),\n    quoted: false\n  });\n  definitionMapValues.push({\n    key: 'type',\n    value: metadata.type.value,\n    quoted: false\n  });\n  definitionMapValues.push({\n    key: 'pure',\n    value: literal(metadata.pure),\n    quoted: false\n  });\n  if (metadata.isStandalone === false) {\n    definitionMapValues.push({\n      key: 'standalone',\n      value: literal(false),\n      quoted: false\n    });\n  }\n  const expression = importExpr(Identifiers.definePipe).callFn([literalMap(definitionMapValues)], undefined, true);\n  const type = createPipeType(metadata);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createPipeType(metadata) {\n  return new ExpressionType(importExpr(Identifiers.PipeDeclaration, [typeWithParameters(metadata.type.type, metadata.typeArgumentCount), new ExpressionType(new LiteralExpr(metadata.pipeName)), new ExpressionType(new LiteralExpr(metadata.isStandalone))]));\n}\nvar R3TemplateDependencyKind;\n(function (R3TemplateDependencyKind) {\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"Directive\"] = 0] = \"Directive\";\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"Pipe\"] = 1] = \"Pipe\";\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"NgModule\"] = 2] = \"NgModule\";\n})(R3TemplateDependencyKind || (R3TemplateDependencyKind = {}));\nconst animationKeywords = new Set(['inherit', 'initial', 'revert', 'unset', 'alternate', 'alternate-reverse', 'normal', 'reverse', 'backwards', 'both', 'forwards', 'none', 'paused', 'running', 'ease', 'ease-in', 'ease-in-out', 'ease-out', 'linear', 'step-start', 'step-end', 'end', 'jump-both', 'jump-end', 'jump-none', 'jump-start', 'start']);\nconst scopedAtRuleIdentifiers = ['@media', '@supports', '@document', '@layer', '@container', '@scope', '@starting-style'];\nclass ShadowCss {\n  shimCssText(cssText, selector, hostSelector = '') {\n    const comments = [];\n    cssText = cssText.replace(_commentRe, m => {\n      if (m.match(_commentWithHashRe)) {\n        comments.push(m);\n      } else {\n        const newLinesMatches = m.match(_newLinesRe);\n        comments.push((newLinesMatches?.join('') ?? '') + '\\n');\n      }\n      return COMMENT_PLACEHOLDER;\n    });\n    cssText = this._insertDirectives(cssText);\n    const scopedCssText = this._scopeCssText(cssText, selector, hostSelector);\n    let commentIdx = 0;\n    return scopedCssText.replace(_commentWithHashPlaceHolderRe, () => comments[commentIdx++]);\n  }\n  _insertDirectives(cssText) {\n    cssText = this._insertPolyfillDirectivesInCssText(cssText);\n    return this._insertPolyfillRulesInCssText(cssText);\n  }\n  _scopeKeyframesRelatedCss(cssText, scopeSelector) {\n    const unscopedKeyframesSet = new Set();\n    const scopedKeyframesCssText = processRules(cssText, rule => this._scopeLocalKeyframeDeclarations(rule, scopeSelector, unscopedKeyframesSet));\n    return processRules(scopedKeyframesCssText, rule => this._scopeAnimationRule(rule, scopeSelector, unscopedKeyframesSet));\n  }\n  _scopeLocalKeyframeDeclarations(rule, scopeSelector, unscopedKeyframesSet) {\n    return {\n      ...rule,\n      selector: rule.selector.replace(/(^@(?:-webkit-)?keyframes(?:\\s+))(['\"]?)(.+)\\2(\\s*)$/, (_, start, quote, keyframeName, endSpaces) => {\n        unscopedKeyframesSet.add(unescapeQuotes(keyframeName, quote));\n        return `${start}${quote}${scopeSelector}_${keyframeName}${quote}${endSpaces}`;\n      })\n    };\n  }\n  _scopeAnimationKeyframe(keyframe, scopeSelector, unscopedKeyframesSet) {\n    return keyframe.replace(/^(\\s*)(['\"]?)(.+?)\\2(\\s*)$/, (_, spaces1, quote, name, spaces2) => {\n      name = `${unscopedKeyframesSet.has(unescapeQuotes(name, quote)) ? scopeSelector + '_' : ''}${name}`;\n      return `${spaces1}${quote}${name}${quote}${spaces2}`;\n    });\n  }\n  _animationDeclarationKeyframesRe = /(^|\\s+|,)(?:(?:(['\"])((?:\\\\\\\\|\\\\\\2|(?!\\2).)+)\\2)|(-?[A-Za-z][\\w\\-]*))(?=[,\\s]|$)/g;\n  _scopeAnimationRule(rule, scopeSelector, unscopedKeyframesSet) {\n    let content = rule.content.replace(/((?:^|\\s+|;)(?:-webkit-)?animation\\s*:\\s*),*([^;]+)/g, (_, start, animationDeclarations) => start + animationDeclarations.replace(this._animationDeclarationKeyframesRe, (original, leadingSpaces, quote = '', quotedName, nonQuotedName) => {\n      if (quotedName) {\n        return `${leadingSpaces}${this._scopeAnimationKeyframe(`${quote}${quotedName}${quote}`, scopeSelector, unscopedKeyframesSet)}`;\n      } else {\n        return animationKeywords.has(nonQuotedName) ? original : `${leadingSpaces}${this._scopeAnimationKeyframe(nonQuotedName, scopeSelector, unscopedKeyframesSet)}`;\n      }\n    }));\n    content = content.replace(/((?:^|\\s+|;)(?:-webkit-)?animation-name(?:\\s*):(?:\\s*))([^;]+)/g, (_match, start, commaSeparatedKeyframes) => `${start}${commaSeparatedKeyframes.split(',').map(keyframe => this._scopeAnimationKeyframe(keyframe, scopeSelector, unscopedKeyframesSet)).join(',')}`);\n    return {\n      ...rule,\n      content\n    };\n  }\n  _insertPolyfillDirectivesInCssText(cssText) {\n    return cssText.replace(_cssContentNextSelectorRe, function (...m) {\n      return m[2] + '{';\n    });\n  }\n  _insertPolyfillRulesInCssText(cssText) {\n    return cssText.replace(_cssContentRuleRe, (...m) => {\n      const rule = m[0].replace(m[1], '').replace(m[2], '');\n      return m[4] + rule;\n    });\n  }\n  _scopeCssText(cssText, scopeSelector, hostSelector) {\n    const unscopedRules = this._extractUnscopedRulesFromCssText(cssText);\n    cssText = this._insertPolyfillHostInCssText(cssText);\n    cssText = this._convertColonHost(cssText);\n    cssText = this._convertColonHostContext(cssText);\n    cssText = this._convertShadowDOMSelectors(cssText);\n    if (scopeSelector) {\n      cssText = this._scopeKeyframesRelatedCss(cssText, scopeSelector);\n      cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\n    }\n    cssText = cssText + '\\n' + unscopedRules;\n    return cssText.trim();\n  }\n  _extractUnscopedRulesFromCssText(cssText) {\n    let r = '';\n    let m;\n    _cssContentUnscopedRuleRe.lastIndex = 0;\n    while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {\n      const rule = m[0].replace(m[2], '').replace(m[1], m[4]);\n      r += rule + '\\n\\n';\n    }\n    return r;\n  }\n  _convertColonHost(cssText) {\n    return cssText.replace(_cssColonHostRe, (_, hostSelectors, otherSelectors) => {\n      if (hostSelectors) {\n        const convertedSelectors = [];\n        for (const hostSelector of this._splitOnTopLevelCommas(hostSelectors, true)) {\n          const trimmedHostSelector = hostSelector.trim();\n          if (!trimmedHostSelector) break;\n          const convertedSelector = _polyfillHostNoCombinator + trimmedHostSelector.replace(_polyfillHost, '') + otherSelectors;\n          convertedSelectors.push(convertedSelector);\n        }\n        return convertedSelectors.join(',');\n      } else {\n        return _polyfillHostNoCombinator + otherSelectors;\n      }\n    });\n  }\n  *_splitOnTopLevelCommas(text, returnOnClosingParen) {\n    const length = text.length;\n    let parens = 0;\n    let prev = 0;\n    for (let i = 0; i < length; i++) {\n      const charCode = text.charCodeAt(i);\n      if (charCode === $LPAREN) {\n        parens++;\n      } else if (charCode === $RPAREN) {\n        parens--;\n        if (parens < 0 && returnOnClosingParen) {\n          yield text.slice(prev, i);\n          return;\n        }\n      } else if (charCode === $COMMA && parens === 0) {\n        yield text.slice(prev, i);\n        prev = i + 1;\n      }\n    }\n    yield text.slice(prev);\n  }\n  _convertColonHostContext(cssText) {\n    const results = [];\n    for (const part of this._splitOnTopLevelCommas(cssText, false)) {\n      results.push(this._convertColonHostContextInSelectorPart(part));\n    }\n    return results.join(',');\n  }\n  _convertColonHostContextInSelectorPart(cssText) {\n    return cssText.replace(_cssColonHostContextReGlobal, (selectorText, pseudoPrefix) => {\n      const contextSelectorGroups = [[]];\n      let startIndex = selectorText.indexOf(_polyfillHostContext);\n      while (startIndex !== -1) {\n        const afterPrefix = selectorText.substring(startIndex + _polyfillHostContext.length);\n        if (!afterPrefix || afterPrefix[0] !== '(') {\n          selectorText = afterPrefix;\n          startIndex = selectorText.indexOf(_polyfillHostContext);\n          continue;\n        }\n        const newContextSelectors = [];\n        let endIndex = 0;\n        for (const selector of this._splitOnTopLevelCommas(afterPrefix.substring(1), true)) {\n          endIndex = endIndex + selector.length + 1;\n          const trimmed = selector.trim();\n          if (trimmed) {\n            newContextSelectors.push(trimmed);\n          }\n        }\n        const contextSelectorGroupsLength = contextSelectorGroups.length;\n        repeatGroups(contextSelectorGroups, newContextSelectors.length);\n        for (let i = 0; i < newContextSelectors.length; i++) {\n          for (let j = 0; j < contextSelectorGroupsLength; j++) {\n            contextSelectorGroups[j + i * contextSelectorGroupsLength].push(newContextSelectors[i]);\n          }\n        }\n        selectorText = afterPrefix.substring(endIndex + 1);\n        startIndex = selectorText.indexOf(_polyfillHostContext);\n      }\n      return contextSelectorGroups.map(contextSelectors => _combineHostContextSelectors(contextSelectors, selectorText, pseudoPrefix)).join(', ');\n    });\n  }\n  _convertShadowDOMSelectors(cssText) {\n    return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);\n  }\n  _scopeSelectors(cssText, scopeSelector, hostSelector) {\n    return processRules(cssText, rule => {\n      let selector = rule.selector;\n      let content = rule.content;\n      if (rule.selector[0] !== '@') {\n        selector = this._scopeSelector({\n          selector,\n          scopeSelector,\n          hostSelector,\n          isParentSelector: true\n        });\n      } else if (scopedAtRuleIdentifiers.some(atRule => rule.selector.startsWith(atRule))) {\n        content = this._scopeSelectors(rule.content, scopeSelector, hostSelector);\n      } else if (rule.selector.startsWith('@font-face') || rule.selector.startsWith('@page')) {\n        content = this._stripScopingSelectors(rule.content);\n      }\n      return new CssRule(selector, content);\n    });\n  }\n  _stripScopingSelectors(cssText) {\n    return processRules(cssText, rule => {\n      const selector = rule.selector.replace(_shadowDeepSelectors, ' ').replace(_polyfillHostNoCombinatorRe, ' ');\n      return new CssRule(selector, rule.content);\n    });\n  }\n  _safeSelector;\n  _shouldScopeIndicator;\n  _scopeSelector({\n    selector,\n    scopeSelector,\n    hostSelector,\n    isParentSelector = false\n  }) {\n    const selectorSplitRe = / ?,(?!(?:[^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))) ?/;\n    return selector.split(selectorSplitRe).map(part => part.split(_shadowDeepSelectors)).map(deepParts => {\n      const [shallowPart, ...otherParts] = deepParts;\n      const applyScope = shallowPart => {\n        if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {\n          return this._applySelectorScope({\n            selector: shallowPart,\n            scopeSelector,\n            hostSelector,\n            isParentSelector\n          });\n        } else {\n          return shallowPart;\n        }\n      };\n      return [applyScope(shallowPart), ...otherParts].join(' ');\n    }).join(', ');\n  }\n  _selectorNeedsScoping(selector, scopeSelector) {\n    const re = this._makeScopeMatcher(scopeSelector);\n    return !re.test(selector);\n  }\n  _makeScopeMatcher(scopeSelector) {\n    const lre = /\\[/g;\n    const rre = /\\]/g;\n    scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n    return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n  }\n  _applySimpleSelectorScope(selector, scopeSelector, hostSelector) {\n    _polyfillHostRe.lastIndex = 0;\n    if (_polyfillHostRe.test(selector)) {\n      const replaceBy = `[${hostSelector}]`;\n      let result = selector;\n      while (result.match(_polyfillHostNoCombinatorRe)) {\n        result = result.replace(_polyfillHostNoCombinatorRe, (_hnc, selector) => {\n          return selector.replace(/([^:\\)]*)(:*)(.*)/, (_, before, colon, after) => {\n            return before + replaceBy + colon + after;\n          });\n        });\n      }\n      return result.replace(_polyfillHostRe, replaceBy);\n    }\n    return scopeSelector + ' ' + selector;\n  }\n  _applySelectorScope({\n    selector,\n    scopeSelector,\n    hostSelector,\n    isParentSelector\n  }) {\n    const isRe = /\\[is=([^\\]]*)\\]/g;\n    scopeSelector = scopeSelector.replace(isRe, (_, ...parts) => parts[0]);\n    const attrName = `[${scopeSelector}]`;\n    const _scopeSelectorPart = p => {\n      let scopedP = p.trim();\n      if (!scopedP) {\n        return p;\n      }\n      if (p.includes(_polyfillHostNoCombinator)) {\n        scopedP = this._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n        if (!p.match(_polyfillHostNoCombinatorOutsidePseudoFunction)) {\n          const [_, before, colon, after] = scopedP.match(/([^:]*)(:*)([\\s\\S]*)/);\n          scopedP = before + attrName + colon + after;\n        }\n      } else {\n        const t = p.replace(_polyfillHostRe, '');\n        if (t.length > 0) {\n          const matches = t.match(/([^:]*)(:*)([\\s\\S]*)/);\n          if (matches) {\n            scopedP = matches[1] + attrName + matches[2] + matches[3];\n          }\n        }\n      }\n      return scopedP;\n    };\n    const _pseudoFunctionAwareScopeSelectorPart = selectorPart => {\n      let scopedPart = '';\n      const pseudoSelectorParts = [];\n      let pseudoSelectorMatch;\n      while ((pseudoSelectorMatch = _cssPrefixWithPseudoSelectorFunction.exec(selectorPart)) !== null) {\n        let openedBrackets = 1;\n        let index = _cssPrefixWithPseudoSelectorFunction.lastIndex;\n        while (index < selectorPart.length) {\n          const currentSymbol = selectorPart[index];\n          index++;\n          if (currentSymbol === '(') {\n            openedBrackets++;\n            continue;\n          }\n          if (currentSymbol === ')') {\n            openedBrackets--;\n            if (openedBrackets === 0) {\n              break;\n            }\n            continue;\n          }\n        }\n        pseudoSelectorParts.push(`${pseudoSelectorMatch[0]}${selectorPart.slice(_cssPrefixWithPseudoSelectorFunction.lastIndex, index)}`);\n        _cssPrefixWithPseudoSelectorFunction.lastIndex = index;\n      }\n      if (pseudoSelectorParts.join('') === selectorPart) {\n        scopedPart = pseudoSelectorParts.map(selectorPart => {\n          const [cssPseudoSelectorFunction] = selectorPart.match(_cssPrefixWithPseudoSelectorFunction) ?? [];\n          const selectorToScope = selectorPart.slice(cssPseudoSelectorFunction?.length, -1);\n          if (selectorToScope.includes(_polyfillHostNoCombinator)) {\n            this._shouldScopeIndicator = true;\n          }\n          const scopedInnerPart = this._scopeSelector({\n            selector: selectorToScope,\n            scopeSelector,\n            hostSelector\n          });\n          return `${cssPseudoSelectorFunction}${scopedInnerPart})`;\n        }).join('');\n      } else {\n        this._shouldScopeIndicator = this._shouldScopeIndicator || selectorPart.includes(_polyfillHostNoCombinator);\n        scopedPart = this._shouldScopeIndicator ? _scopeSelectorPart(selectorPart) : selectorPart;\n      }\n      return scopedPart;\n    };\n    if (isParentSelector) {\n      this._safeSelector = new SafeSelector(selector);\n      selector = this._safeSelector.content();\n    }\n    let scopedSelector = '';\n    let startIndex = 0;\n    let res;\n    const sep = /( |>|\\+|~(?!=))(?!([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)))\\s*/g;\n    const hasHost = selector.includes(_polyfillHostNoCombinator);\n    if (isParentSelector || this._shouldScopeIndicator) {\n      this._shouldScopeIndicator = !hasHost;\n    }\n    while ((res = sep.exec(selector)) !== null) {\n      const separator = res[1];\n      const part = selector.slice(startIndex, res.index);\n      if (part.match(/__esc-ph-(\\d+)__/) && selector[res.index + 1]?.match(/[a-fA-F\\d]/)) {\n        continue;\n      }\n      const scopedPart = _pseudoFunctionAwareScopeSelectorPart(part);\n      scopedSelector += `${scopedPart} ${separator} `;\n      startIndex = sep.lastIndex;\n    }\n    const part = selector.substring(startIndex);\n    scopedSelector += _pseudoFunctionAwareScopeSelectorPart(part);\n    return this._safeSelector.restore(scopedSelector);\n  }\n  _insertPolyfillHostInCssText(selector) {\n    return selector.replace(_colonHostContextRe, _polyfillHostContext).replace(_colonHostRe, _polyfillHost);\n  }\n}\nclass SafeSelector {\n  placeholders = [];\n  index = 0;\n  _content;\n  constructor(selector) {\n    selector = this._escapeRegexMatches(selector, /(\\[[^\\]]*\\])/g);\n    selector = selector.replace(/(\\\\.)/g, (_, keep) => {\n      const replaceBy = `__esc-ph-${this.index}__`;\n      this.placeholders.push(keep);\n      this.index++;\n      return replaceBy;\n    });\n    this._content = selector.replace(nthRegex, (_, pseudo, exp) => {\n      const replaceBy = `__ph-${this.index}__`;\n      this.placeholders.push(`(${exp})`);\n      this.index++;\n      return pseudo + replaceBy;\n    });\n  }\n  restore(content) {\n    return content.replace(/__(?:ph|esc-ph)-(\\d+)__/g, (_ph, index) => this.placeholders[+index]);\n  }\n  content() {\n    return this._content;\n  }\n  _escapeRegexMatches(content, pattern) {\n    return content.replace(pattern, (_, keep) => {\n      const replaceBy = `__ph-${this.index}__`;\n      this.placeholders.push(keep);\n      this.index++;\n      return replaceBy;\n    });\n  }\n}\nconst _cssScopedPseudoFunctionPrefix = '(:(where|is)\\\\()?';\nconst _cssPrefixWithPseudoSelectorFunction = /:(where|is)\\(/gi;\nconst _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\\s]*?(['\"])(.*?)\\1[;\\s]*}([^{]*?){/gim;\nconst _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _polyfillHost = '-shadowcsshost';\nconst _polyfillHostContext = '-shadowcsscontext';\nconst _noParens = '[^)(]*';\nconst _level1Parens = String.raw`(?:\\(${_noParens}\\)|${_noParens})+?`;\nconst _level2Parens = String.raw`(?:\\(${_level1Parens}\\)|${_noParens})+?`;\nconst _parenSuffix = String.raw`(?:\\((${_level2Parens})\\))`;\nconst nthRegex = new RegExp(String.raw`(:nth-[-\\w]+)` + _parenSuffix, 'g');\nconst _cssColonHostRe = new RegExp(_polyfillHost + _parenSuffix + '?([^,{]*)', 'gim');\nconst _hostContextPattern = _polyfillHostContext + _parenSuffix + '?([^{]*)';\nconst _cssColonHostContextReGlobal = new RegExp(`${_cssScopedPseudoFunctionPrefix}(${_hostContextPattern})`, 'gim');\nconst _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\nconst _polyfillHostNoCombinatorOutsidePseudoFunction = new RegExp(`${_polyfillHostNoCombinator}(?![^(]*\\\\))`, 'g');\nconst _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s,]*)/;\nconst _shadowDOMSelectorsRe = [/::shadow/g, /::content/g, /\\/shadow-deep\\//g, /\\/shadow\\//g];\nconst _shadowDeepSelectors = /(?:>>>)|(?:\\/deep\\/)|(?:::ng-deep)/g;\nconst _selectorReSuffix = '([>\\\\s~+[.,{:][\\\\s\\\\S]*)?$';\nconst _polyfillHostRe = /-shadowcsshost/gim;\nconst _colonHostRe = /:host/gim;\nconst _colonHostContextRe = /:host-context/gim;\nconst _newLinesRe = /\\r?\\n/g;\nconst _commentRe = /\\/\\*[\\s\\S]*?\\*\\//g;\nconst _commentWithHashRe = /\\/\\*\\s*#\\s*source(Mapping)?URL=/g;\nconst COMMENT_PLACEHOLDER = '%COMMENT%';\nconst _commentWithHashPlaceHolderRe = new RegExp(COMMENT_PLACEHOLDER, 'g');\nconst BLOCK_PLACEHOLDER = '%BLOCK%';\nconst _ruleRe = new RegExp(`(\\\\s*(?:${COMMENT_PLACEHOLDER}\\\\s*)*)([^;\\\\{\\\\}]+?)(\\\\s*)((?:{%BLOCK%}?\\\\s*;?)|(?:\\\\s*;))`, 'g');\nconst CONTENT_PAIRS = new Map([['{', '}']]);\nconst COMMA_IN_PLACEHOLDER = '%COMMA_IN_PLACEHOLDER%';\nconst SEMI_IN_PLACEHOLDER = '%SEMI_IN_PLACEHOLDER%';\nconst COLON_IN_PLACEHOLDER = '%COLON_IN_PLACEHOLDER%';\nconst _cssCommaInPlaceholderReGlobal = new RegExp(COMMA_IN_PLACEHOLDER, 'g');\nconst _cssSemiInPlaceholderReGlobal = new RegExp(SEMI_IN_PLACEHOLDER, 'g');\nconst _cssColonInPlaceholderReGlobal = new RegExp(COLON_IN_PLACEHOLDER, 'g');\nclass CssRule {\n  selector;\n  content;\n  constructor(selector, content) {\n    this.selector = selector;\n    this.content = content;\n  }\n}\nfunction processRules(input, ruleCallback) {\n  const escaped = escapeInStrings(input);\n  const inputWithEscapedBlocks = escapeBlocks(escaped, CONTENT_PAIRS, BLOCK_PLACEHOLDER);\n  let nextBlockIndex = 0;\n  const escapedResult = inputWithEscapedBlocks.escapedString.replace(_ruleRe, (...m) => {\n    const selector = m[2];\n    let content = '';\n    let suffix = m[4];\n    let contentPrefix = '';\n    if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n      content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n      suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n      contentPrefix = '{';\n    }\n    const rule = ruleCallback(new CssRule(selector, content));\n    return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;\n  });\n  return unescapeInStrings(escapedResult);\n}\nclass StringWithEscapedBlocks {\n  escapedString;\n  blocks;\n  constructor(escapedString, blocks) {\n    this.escapedString = escapedString;\n    this.blocks = blocks;\n  }\n}\nfunction escapeBlocks(input, charPairs, placeholder) {\n  const resultParts = [];\n  const escapedBlocks = [];\n  let openCharCount = 0;\n  let nonBlockStartIndex = 0;\n  let blockStartIndex = -1;\n  let openChar;\n  let closeChar;\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    if (char === '\\\\') {\n      i++;\n    } else if (char === closeChar) {\n      openCharCount--;\n      if (openCharCount === 0) {\n        escapedBlocks.push(input.substring(blockStartIndex, i));\n        resultParts.push(placeholder);\n        nonBlockStartIndex = i;\n        blockStartIndex = -1;\n        openChar = closeChar = undefined;\n      }\n    } else if (char === openChar) {\n      openCharCount++;\n    } else if (openCharCount === 0 && charPairs.has(char)) {\n      openChar = char;\n      closeChar = charPairs.get(char);\n      openCharCount = 1;\n      blockStartIndex = i + 1;\n      resultParts.push(input.substring(nonBlockStartIndex, blockStartIndex));\n    }\n  }\n  if (blockStartIndex !== -1) {\n    escapedBlocks.push(input.substring(blockStartIndex));\n    resultParts.push(placeholder);\n  } else {\n    resultParts.push(input.substring(nonBlockStartIndex));\n  }\n  return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n}\nconst ESCAPE_IN_STRING_MAP = {\n  ';': SEMI_IN_PLACEHOLDER,\n  ',': COMMA_IN_PLACEHOLDER,\n  ':': COLON_IN_PLACEHOLDER\n};\nfunction escapeInStrings(input) {\n  let result = input;\n  let currentQuoteChar = null;\n  for (let i = 0; i < result.length; i++) {\n    const char = result[i];\n    if (char === '\\\\') {\n      i++;\n    } else {\n      if (currentQuoteChar !== null) {\n        if (char === currentQuoteChar) {\n          currentQuoteChar = null;\n        } else {\n          const placeholder = ESCAPE_IN_STRING_MAP[char];\n          if (placeholder) {\n            result = `${result.substr(0, i)}${placeholder}${result.substr(i + 1)}`;\n            i += placeholder.length - 1;\n          }\n        }\n      } else if (char === \"'\" || char === '\"') {\n        currentQuoteChar = char;\n      }\n    }\n  }\n  return result;\n}\nfunction unescapeInStrings(input) {\n  let result = input.replace(_cssCommaInPlaceholderReGlobal, ',');\n  result = result.replace(_cssSemiInPlaceholderReGlobal, ';');\n  result = result.replace(_cssColonInPlaceholderReGlobal, ':');\n  return result;\n}\nfunction unescapeQuotes(str, isQuoted) {\n  return !isQuoted ? str : str.replace(/((?:^|[^\\\\])(?:\\\\\\\\)*)\\\\(?=['\"])/g, '$1');\n}\nfunction _combineHostContextSelectors(contextSelectors, otherSelectors, pseudoPrefix = '') {\n  const hostMarker = _polyfillHostNoCombinator;\n  _polyfillHostRe.lastIndex = 0;\n  const otherSelectorsHasHost = _polyfillHostRe.test(otherSelectors);\n  if (contextSelectors.length === 0) {\n    return hostMarker + otherSelectors;\n  }\n  const combined = [contextSelectors.pop() || ''];\n  while (contextSelectors.length > 0) {\n    const length = combined.length;\n    const contextSelector = contextSelectors.pop();\n    for (let i = 0; i < length; i++) {\n      const previousSelectors = combined[i];\n      combined[length * 2 + i] = previousSelectors + ' ' + contextSelector;\n      combined[length + i] = contextSelector + ' ' + previousSelectors;\n      combined[i] = contextSelector + previousSelectors;\n    }\n  }\n  return combined.map(s => otherSelectorsHasHost ? `${pseudoPrefix}${s}${otherSelectors}` : `${pseudoPrefix}${s}${hostMarker}${otherSelectors}, ${pseudoPrefix}${s} ${hostMarker}${otherSelectors}`).join(',');\n}\nfunction repeatGroups(groups, multiples) {\n  const length = groups.length;\n  for (let i = 1; i < multiples; i++) {\n    for (let j = 0; j < length; j++) {\n      groups[j + i * length] = groups[j].slice(0);\n    }\n  }\n}\nvar OpKind;\n(function (OpKind) {\n  OpKind[OpKind[\"ListEnd\"] = 0] = \"ListEnd\";\n  OpKind[OpKind[\"Statement\"] = 1] = \"Statement\";\n  OpKind[OpKind[\"Variable\"] = 2] = \"Variable\";\n  OpKind[OpKind[\"ElementStart\"] = 3] = \"ElementStart\";\n  OpKind[OpKind[\"Element\"] = 4] = \"Element\";\n  OpKind[OpKind[\"Template\"] = 5] = \"Template\";\n  OpKind[OpKind[\"ElementEnd\"] = 6] = \"ElementEnd\";\n  OpKind[OpKind[\"ContainerStart\"] = 7] = \"ContainerStart\";\n  OpKind[OpKind[\"Container\"] = 8] = \"Container\";\n  OpKind[OpKind[\"ContainerEnd\"] = 9] = \"ContainerEnd\";\n  OpKind[OpKind[\"DisableBindings\"] = 10] = \"DisableBindings\";\n  OpKind[OpKind[\"ConditionalCreate\"] = 11] = \"ConditionalCreate\";\n  OpKind[OpKind[\"ConditionalBranchCreate\"] = 12] = \"ConditionalBranchCreate\";\n  OpKind[OpKind[\"Conditional\"] = 13] = \"Conditional\";\n  OpKind[OpKind[\"EnableBindings\"] = 14] = \"EnableBindings\";\n  OpKind[OpKind[\"Text\"] = 15] = \"Text\";\n  OpKind[OpKind[\"Listener\"] = 16] = \"Listener\";\n  OpKind[OpKind[\"InterpolateText\"] = 17] = \"InterpolateText\";\n  OpKind[OpKind[\"Binding\"] = 18] = \"Binding\";\n  OpKind[OpKind[\"Property\"] = 19] = \"Property\";\n  OpKind[OpKind[\"StyleProp\"] = 20] = \"StyleProp\";\n  OpKind[OpKind[\"ClassProp\"] = 21] = \"ClassProp\";\n  OpKind[OpKind[\"StyleMap\"] = 22] = \"StyleMap\";\n  OpKind[OpKind[\"ClassMap\"] = 23] = \"ClassMap\";\n  OpKind[OpKind[\"Advance\"] = 24] = \"Advance\";\n  OpKind[OpKind[\"Pipe\"] = 25] = \"Pipe\";\n  OpKind[OpKind[\"Attribute\"] = 26] = \"Attribute\";\n  OpKind[OpKind[\"ExtractedAttribute\"] = 27] = \"ExtractedAttribute\";\n  OpKind[OpKind[\"Defer\"] = 28] = \"Defer\";\n  OpKind[OpKind[\"DeferOn\"] = 29] = \"DeferOn\";\n  OpKind[OpKind[\"DeferWhen\"] = 30] = \"DeferWhen\";\n  OpKind[OpKind[\"I18nMessage\"] = 31] = \"I18nMessage\";\n  OpKind[OpKind[\"DomProperty\"] = 32] = \"DomProperty\";\n  OpKind[OpKind[\"Namespace\"] = 33] = \"Namespace\";\n  OpKind[OpKind[\"ProjectionDef\"] = 34] = \"ProjectionDef\";\n  OpKind[OpKind[\"Projection\"] = 35] = \"Projection\";\n  OpKind[OpKind[\"RepeaterCreate\"] = 36] = \"RepeaterCreate\";\n  OpKind[OpKind[\"Repeater\"] = 37] = \"Repeater\";\n  OpKind[OpKind[\"TwoWayProperty\"] = 38] = \"TwoWayProperty\";\n  OpKind[OpKind[\"TwoWayListener\"] = 39] = \"TwoWayListener\";\n  OpKind[OpKind[\"DeclareLet\"] = 40] = \"DeclareLet\";\n  OpKind[OpKind[\"StoreLet\"] = 41] = \"StoreLet\";\n  OpKind[OpKind[\"I18nStart\"] = 42] = \"I18nStart\";\n  OpKind[OpKind[\"I18n\"] = 43] = \"I18n\";\n  OpKind[OpKind[\"I18nEnd\"] = 44] = \"I18nEnd\";\n  OpKind[OpKind[\"I18nExpression\"] = 45] = \"I18nExpression\";\n  OpKind[OpKind[\"I18nApply\"] = 46] = \"I18nApply\";\n  OpKind[OpKind[\"IcuStart\"] = 47] = \"IcuStart\";\n  OpKind[OpKind[\"IcuEnd\"] = 48] = \"IcuEnd\";\n  OpKind[OpKind[\"IcuPlaceholder\"] = 49] = \"IcuPlaceholder\";\n  OpKind[OpKind[\"I18nContext\"] = 50] = \"I18nContext\";\n  OpKind[OpKind[\"I18nAttributes\"] = 51] = \"I18nAttributes\";\n  OpKind[OpKind[\"SourceLocation\"] = 52] = \"SourceLocation\";\n  OpKind[OpKind[\"Animation\"] = 53] = \"Animation\";\n  OpKind[OpKind[\"AnimationString\"] = 54] = \"AnimationString\";\n  OpKind[OpKind[\"AnimationBinding\"] = 55] = \"AnimationBinding\";\n  OpKind[OpKind[\"AnimationListener\"] = 56] = \"AnimationListener\";\n  OpKind[OpKind[\"Control\"] = 57] = \"Control\";\n  OpKind[OpKind[\"ControlCreate\"] = 58] = \"ControlCreate\";\n})(OpKind || (OpKind = {}));\nvar ExpressionKind;\n(function (ExpressionKind) {\n  ExpressionKind[ExpressionKind[\"LexicalRead\"] = 0] = \"LexicalRead\";\n  ExpressionKind[ExpressionKind[\"Context\"] = 1] = \"Context\";\n  ExpressionKind[ExpressionKind[\"TrackContext\"] = 2] = \"TrackContext\";\n  ExpressionKind[ExpressionKind[\"ReadVariable\"] = 3] = \"ReadVariable\";\n  ExpressionKind[ExpressionKind[\"NextContext\"] = 4] = \"NextContext\";\n  ExpressionKind[ExpressionKind[\"Reference\"] = 5] = \"Reference\";\n  ExpressionKind[ExpressionKind[\"StoreLet\"] = 6] = \"StoreLet\";\n  ExpressionKind[ExpressionKind[\"ContextLetReference\"] = 7] = \"ContextLetReference\";\n  ExpressionKind[ExpressionKind[\"GetCurrentView\"] = 8] = \"GetCurrentView\";\n  ExpressionKind[ExpressionKind[\"RestoreView\"] = 9] = \"RestoreView\";\n  ExpressionKind[ExpressionKind[\"ResetView\"] = 10] = \"ResetView\";\n  ExpressionKind[ExpressionKind[\"PureFunctionExpr\"] = 11] = \"PureFunctionExpr\";\n  ExpressionKind[ExpressionKind[\"PureFunctionParameterExpr\"] = 12] = \"PureFunctionParameterExpr\";\n  ExpressionKind[ExpressionKind[\"PipeBinding\"] = 13] = \"PipeBinding\";\n  ExpressionKind[ExpressionKind[\"PipeBindingVariadic\"] = 14] = \"PipeBindingVariadic\";\n  ExpressionKind[ExpressionKind[\"SafePropertyRead\"] = 15] = \"SafePropertyRead\";\n  ExpressionKind[ExpressionKind[\"SafeKeyedRead\"] = 16] = \"SafeKeyedRead\";\n  ExpressionKind[ExpressionKind[\"SafeInvokeFunction\"] = 17] = \"SafeInvokeFunction\";\n  ExpressionKind[ExpressionKind[\"SafeTernaryExpr\"] = 18] = \"SafeTernaryExpr\";\n  ExpressionKind[ExpressionKind[\"EmptyExpr\"] = 19] = \"EmptyExpr\";\n  ExpressionKind[ExpressionKind[\"AssignTemporaryExpr\"] = 20] = \"AssignTemporaryExpr\";\n  ExpressionKind[ExpressionKind[\"ReadTemporaryExpr\"] = 21] = \"ReadTemporaryExpr\";\n  ExpressionKind[ExpressionKind[\"SlotLiteralExpr\"] = 22] = \"SlotLiteralExpr\";\n  ExpressionKind[ExpressionKind[\"ConditionalCase\"] = 23] = \"ConditionalCase\";\n  ExpressionKind[ExpressionKind[\"ConstCollected\"] = 24] = \"ConstCollected\";\n  ExpressionKind[ExpressionKind[\"TwoWayBindingSet\"] = 25] = \"TwoWayBindingSet\";\n})(ExpressionKind || (ExpressionKind = {}));\nvar VariableFlags;\n(function (VariableFlags) {\n  VariableFlags[VariableFlags[\"None\"] = 0] = \"None\";\n  VariableFlags[VariableFlags[\"AlwaysInline\"] = 1] = \"AlwaysInline\";\n})(VariableFlags || (VariableFlags = {}));\nvar SemanticVariableKind;\n(function (SemanticVariableKind) {\n  SemanticVariableKind[SemanticVariableKind[\"Context\"] = 0] = \"Context\";\n  SemanticVariableKind[SemanticVariableKind[\"Identifier\"] = 1] = \"Identifier\";\n  SemanticVariableKind[SemanticVariableKind[\"SavedView\"] = 2] = \"SavedView\";\n  SemanticVariableKind[SemanticVariableKind[\"Alias\"] = 3] = \"Alias\";\n})(SemanticVariableKind || (SemanticVariableKind = {}));\nvar CompatibilityMode;\n(function (CompatibilityMode) {\n  CompatibilityMode[CompatibilityMode[\"Normal\"] = 0] = \"Normal\";\n  CompatibilityMode[CompatibilityMode[\"TemplateDefinitionBuilder\"] = 1] = \"TemplateDefinitionBuilder\";\n})(CompatibilityMode || (CompatibilityMode = {}));\nvar BindingKind;\n(function (BindingKind) {\n  BindingKind[BindingKind[\"Attribute\"] = 0] = \"Attribute\";\n  BindingKind[BindingKind[\"ClassName\"] = 1] = \"ClassName\";\n  BindingKind[BindingKind[\"StyleProperty\"] = 2] = \"StyleProperty\";\n  BindingKind[BindingKind[\"Property\"] = 3] = \"Property\";\n  BindingKind[BindingKind[\"Template\"] = 4] = \"Template\";\n  BindingKind[BindingKind[\"I18n\"] = 5] = \"I18n\";\n  BindingKind[BindingKind[\"LegacyAnimation\"] = 6] = \"LegacyAnimation\";\n  BindingKind[BindingKind[\"TwoWayProperty\"] = 7] = \"TwoWayProperty\";\n  BindingKind[BindingKind[\"Animation\"] = 8] = \"Animation\";\n})(BindingKind || (BindingKind = {}));\nvar I18nParamResolutionTime;\n(function (I18nParamResolutionTime) {\n  I18nParamResolutionTime[I18nParamResolutionTime[\"Creation\"] = 0] = \"Creation\";\n  I18nParamResolutionTime[I18nParamResolutionTime[\"Postproccessing\"] = 1] = \"Postproccessing\";\n})(I18nParamResolutionTime || (I18nParamResolutionTime = {}));\nvar I18nExpressionFor;\n(function (I18nExpressionFor) {\n  I18nExpressionFor[I18nExpressionFor[\"I18nText\"] = 0] = \"I18nText\";\n  I18nExpressionFor[I18nExpressionFor[\"I18nAttribute\"] = 1] = \"I18nAttribute\";\n})(I18nExpressionFor || (I18nExpressionFor = {}));\nvar I18nParamValueFlags;\n(function (I18nParamValueFlags) {\n  I18nParamValueFlags[I18nParamValueFlags[\"None\"] = 0] = \"None\";\n  I18nParamValueFlags[I18nParamValueFlags[\"ElementTag\"] = 1] = \"ElementTag\";\n  I18nParamValueFlags[I18nParamValueFlags[\"TemplateTag\"] = 2] = \"TemplateTag\";\n  I18nParamValueFlags[I18nParamValueFlags[\"OpenTag\"] = 4] = \"OpenTag\";\n  I18nParamValueFlags[I18nParamValueFlags[\"CloseTag\"] = 8] = \"CloseTag\";\n  I18nParamValueFlags[I18nParamValueFlags[\"ExpressionIndex\"] = 16] = \"ExpressionIndex\";\n})(I18nParamValueFlags || (I18nParamValueFlags = {}));\nvar Namespace;\n(function (Namespace) {\n  Namespace[Namespace[\"HTML\"] = 0] = \"HTML\";\n  Namespace[Namespace[\"SVG\"] = 1] = \"SVG\";\n  Namespace[Namespace[\"Math\"] = 2] = \"Math\";\n})(Namespace || (Namespace = {}));\nvar DeferTriggerKind;\n(function (DeferTriggerKind) {\n  DeferTriggerKind[DeferTriggerKind[\"Idle\"] = 0] = \"Idle\";\n  DeferTriggerKind[DeferTriggerKind[\"Immediate\"] = 1] = \"Immediate\";\n  DeferTriggerKind[DeferTriggerKind[\"Timer\"] = 2] = \"Timer\";\n  DeferTriggerKind[DeferTriggerKind[\"Hover\"] = 3] = \"Hover\";\n  DeferTriggerKind[DeferTriggerKind[\"Interaction\"] = 4] = \"Interaction\";\n  DeferTriggerKind[DeferTriggerKind[\"Viewport\"] = 5] = \"Viewport\";\n  DeferTriggerKind[DeferTriggerKind[\"Never\"] = 6] = \"Never\";\n})(DeferTriggerKind || (DeferTriggerKind = {}));\nvar I18nContextKind;\n(function (I18nContextKind) {\n  I18nContextKind[I18nContextKind[\"RootI18n\"] = 0] = \"RootI18n\";\n  I18nContextKind[I18nContextKind[\"Icu\"] = 1] = \"Icu\";\n  I18nContextKind[I18nContextKind[\"Attr\"] = 2] = \"Attr\";\n})(I18nContextKind || (I18nContextKind = {}));\nvar TemplateKind;\n(function (TemplateKind) {\n  TemplateKind[TemplateKind[\"NgTemplate\"] = 0] = \"NgTemplate\";\n  TemplateKind[TemplateKind[\"Structural\"] = 1] = \"Structural\";\n  TemplateKind[TemplateKind[\"Block\"] = 2] = \"Block\";\n})(TemplateKind || (TemplateKind = {}));\nconst ConsumesSlot = Symbol('ConsumesSlot');\nconst DependsOnSlotContext = Symbol('DependsOnSlotContext');\nconst ConsumesVarsTrait = Symbol('ConsumesVars');\nconst UsesVarOffset = Symbol('UsesVarOffset');\nconst TRAIT_CONSUMES_SLOT = {\n  [ConsumesSlot]: true,\n  numSlotsUsed: 1\n};\nconst TRAIT_DEPENDS_ON_SLOT_CONTEXT = {\n  [DependsOnSlotContext]: true\n};\nconst TRAIT_CONSUMES_VARS = {\n  [ConsumesVarsTrait]: true\n};\nfunction hasConsumesSlotTrait(op) {\n  return op[ConsumesSlot] === true;\n}\nfunction hasDependsOnSlotContextTrait(value) {\n  return value[DependsOnSlotContext] === true;\n}\nfunction hasConsumesVarsTrait(value) {\n  return value[ConsumesVarsTrait] === true;\n}\nfunction hasUsesVarOffsetTrait(expr) {\n  return expr[UsesVarOffset] === true;\n}\nfunction createStatementOp(statement) {\n  return {\n    kind: OpKind.Statement,\n    statement,\n    ...NEW_OP\n  };\n}\nfunction createVariableOp(xref, variable, initializer, flags) {\n  return {\n    kind: OpKind.Variable,\n    xref,\n    variable,\n    initializer,\n    flags,\n    ...NEW_OP\n  };\n}\nconst NEW_OP = {\n  debugListId: null,\n  prev: null,\n  next: null\n};\nfunction createInterpolateTextOp(xref, interpolation, sourceSpan) {\n  return {\n    kind: OpKind.InterpolateText,\n    target: xref,\n    interpolation,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nclass Interpolation {\n  strings;\n  expressions;\n  i18nPlaceholders;\n  constructor(strings, expressions, i18nPlaceholders) {\n    this.strings = strings;\n    this.expressions = expressions;\n    this.i18nPlaceholders = i18nPlaceholders;\n    if (i18nPlaceholders.length !== 0 && i18nPlaceholders.length !== expressions.length) {\n      throw new Error(`Expected ${expressions.length} placeholders to match interpolation expression count, but got ${i18nPlaceholders.length}`);\n    }\n  }\n}\nfunction createBindingOp(target, kind, name, expression, unit, securityContext, isTextAttribute, isStructuralTemplateAttribute, templateKind, i18nMessage, sourceSpan) {\n  return {\n    kind: OpKind.Binding,\n    bindingKind: kind,\n    target,\n    name,\n    expression,\n    unit,\n    securityContext,\n    isTextAttribute,\n    isStructuralTemplateAttribute,\n    templateKind,\n    i18nContext: null,\n    i18nMessage,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createPropertyOp(target, name, expression, bindingKind, securityContext, isStructuralTemplateAttribute, templateKind, i18nContext, i18nMessage, sourceSpan) {\n  return {\n    kind: OpKind.Property,\n    target,\n    name,\n    expression,\n    bindingKind,\n    securityContext,\n    sanitizer: null,\n    isStructuralTemplateAttribute,\n    templateKind,\n    i18nContext,\n    i18nMessage,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createTwoWayPropertyOp(target, name, expression, securityContext, isStructuralTemplateAttribute, templateKind, i18nContext, i18nMessage, sourceSpan) {\n  return {\n    kind: OpKind.TwoWayProperty,\n    target,\n    name,\n    expression,\n    securityContext,\n    sanitizer: null,\n    isStructuralTemplateAttribute,\n    templateKind,\n    i18nContext,\n    i18nMessage,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createStylePropOp(xref, name, expression, unit, sourceSpan) {\n  return {\n    kind: OpKind.StyleProp,\n    target: xref,\n    name,\n    expression,\n    unit,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createClassPropOp(xref, name, expression, sourceSpan) {\n  return {\n    kind: OpKind.ClassProp,\n    target: xref,\n    name,\n    expression,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createStyleMapOp(xref, expression, sourceSpan) {\n  return {\n    kind: OpKind.StyleMap,\n    target: xref,\n    expression,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createClassMapOp(xref, expression, sourceSpan) {\n  return {\n    kind: OpKind.ClassMap,\n    target: xref,\n    expression,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createAttributeOp(target, namespace, name, expression, securityContext, isTextAttribute, isStructuralTemplateAttribute, templateKind, i18nMessage, sourceSpan) {\n  return {\n    kind: OpKind.Attribute,\n    target,\n    namespace,\n    name,\n    expression,\n    securityContext,\n    sanitizer: null,\n    isTextAttribute,\n    isStructuralTemplateAttribute,\n    templateKind,\n    i18nContext: null,\n    i18nMessage,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createAdvanceOp(delta, sourceSpan) {\n  return {\n    kind: OpKind.Advance,\n    delta,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createConditionalOp(target, test, conditions, sourceSpan) {\n  return {\n    kind: OpKind.Conditional,\n    target,\n    test,\n    conditions,\n    processed: null,\n    sourceSpan,\n    contextValue: null,\n    ...NEW_OP,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS\n  };\n}\nfunction createRepeaterOp(repeaterCreate, targetSlot, collection, sourceSpan) {\n  return {\n    kind: OpKind.Repeater,\n    target: repeaterCreate,\n    targetSlot,\n    collection,\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT\n  };\n}\nfunction createAnimationBindingOp(name, target, animationKind, expression, securityContext, sourceSpan, animationBindingKind) {\n  return {\n    kind: OpKind.AnimationBinding,\n    name,\n    target,\n    animationKind,\n    expression,\n    i18nMessage: null,\n    securityContext,\n    sanitizer: null,\n    sourceSpan,\n    animationBindingKind,\n    ...NEW_OP\n  };\n}\nfunction createDeferWhenOp(target, expr, modifier, sourceSpan) {\n  return {\n    kind: OpKind.DeferWhen,\n    target,\n    expr,\n    modifier,\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS\n  };\n}\nfunction createI18nExpressionOp(context, target, i18nOwner, handle, expression, icuPlaceholder, i18nPlaceholder, resolutionTime, usage, name, sourceSpan) {\n  return {\n    kind: OpKind.I18nExpression,\n    context,\n    target,\n    i18nOwner,\n    handle,\n    expression,\n    icuPlaceholder,\n    i18nPlaceholder,\n    resolutionTime,\n    usage,\n    name,\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_VARS,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT\n  };\n}\nfunction createI18nApplyOp(owner, handle, sourceSpan) {\n  return {\n    kind: OpKind.I18nApply,\n    owner,\n    handle,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createStoreLetOp(target, declaredName, value, sourceSpan) {\n  return {\n    kind: OpKind.StoreLet,\n    target,\n    declaredName,\n    value,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createControlOp(op) {\n  return {\n    kind: OpKind.Control,\n    target: op.target,\n    expression: op.expression,\n    bindingKind: op.bindingKind,\n    securityContext: op.securityContext,\n    sanitizer: null,\n    isStructuralTemplateAttribute: op.isStructuralTemplateAttribute,\n    templateKind: op.templateKind,\n    i18nContext: op.i18nContext,\n    i18nMessage: op.i18nMessage,\n    sourceSpan: op.sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction isIrExpression(expr) {\n  return expr instanceof ExpressionBase;\n}\nclass ExpressionBase extends Expression {\n  constructor(sourceSpan = null) {\n    super(null, sourceSpan);\n  }\n}\nclass LexicalReadExpr extends ExpressionBase {\n  name;\n  kind = ExpressionKind.LexicalRead;\n  constructor(name) {\n    super();\n    this.name = name;\n  }\n  visitExpression(visitor, context) {}\n  isEquivalent(other) {\n    return this.name === other.name;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    return new LexicalReadExpr(this.name);\n  }\n}\nclass ReferenceExpr extends ExpressionBase {\n  target;\n  targetSlot;\n  offset;\n  kind = ExpressionKind.Reference;\n  constructor(target, targetSlot, offset) {\n    super();\n    this.target = target;\n    this.targetSlot = targetSlot;\n    this.offset = offset;\n  }\n  visitExpression() {}\n  isEquivalent(e) {\n    return e instanceof ReferenceExpr && e.target === this.target;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    return new ReferenceExpr(this.target, this.targetSlot, this.offset);\n  }\n}\nclass StoreLetExpr extends ExpressionBase {\n  target;\n  value;\n  sourceSpan;\n  kind = ExpressionKind.StoreLet;\n  [ConsumesVarsTrait] = true;\n  [DependsOnSlotContext] = true;\n  constructor(target, value, sourceSpan) {\n    super();\n    this.target = target;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n  visitExpression() {}\n  isEquivalent(e) {\n    return e instanceof StoreLetExpr && e.target === this.target && e.value.isEquivalent(this.value);\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.value = transformExpressionsInExpression(this.value, transform, flags);\n  }\n  clone() {\n    return new StoreLetExpr(this.target, this.value, this.sourceSpan);\n  }\n}\nclass ContextLetReferenceExpr extends ExpressionBase {\n  target;\n  targetSlot;\n  kind = ExpressionKind.ContextLetReference;\n  constructor(target, targetSlot) {\n    super();\n    this.target = target;\n    this.targetSlot = targetSlot;\n  }\n  visitExpression() {}\n  isEquivalent(e) {\n    return e instanceof ContextLetReferenceExpr && e.target === this.target;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    return new ContextLetReferenceExpr(this.target, this.targetSlot);\n  }\n}\nclass ContextExpr extends ExpressionBase {\n  view;\n  kind = ExpressionKind.Context;\n  constructor(view) {\n    super();\n    this.view = view;\n  }\n  visitExpression() {}\n  isEquivalent(e) {\n    return e instanceof ContextExpr && e.view === this.view;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    return new ContextExpr(this.view);\n  }\n}\nclass TrackContextExpr extends ExpressionBase {\n  view;\n  kind = ExpressionKind.TrackContext;\n  constructor(view) {\n    super();\n    this.view = view;\n  }\n  visitExpression() {}\n  isEquivalent(e) {\n    return e instanceof TrackContextExpr && e.view === this.view;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    return new TrackContextExpr(this.view);\n  }\n}\nclass NextContextExpr extends ExpressionBase {\n  kind = ExpressionKind.NextContext;\n  steps = 1;\n  constructor() {\n    super();\n  }\n  visitExpression() {}\n  isEquivalent(e) {\n    return e instanceof NextContextExpr && e.steps === this.steps;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    const expr = new NextContextExpr();\n    expr.steps = this.steps;\n    return expr;\n  }\n}\nclass GetCurrentViewExpr extends ExpressionBase {\n  kind = ExpressionKind.GetCurrentView;\n  constructor() {\n    super();\n  }\n  visitExpression() {}\n  isEquivalent(e) {\n    return e instanceof GetCurrentViewExpr;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    return new GetCurrentViewExpr();\n  }\n}\nclass RestoreViewExpr extends ExpressionBase {\n  view;\n  kind = ExpressionKind.RestoreView;\n  constructor(view) {\n    super();\n    this.view = view;\n  }\n  visitExpression(visitor, context) {\n    if (typeof this.view !== 'number') {\n      this.view.visitExpression(visitor, context);\n    }\n  }\n  isEquivalent(e) {\n    if (!(e instanceof RestoreViewExpr) || typeof e.view !== typeof this.view) {\n      return false;\n    }\n    if (typeof this.view === 'number') {\n      return this.view === e.view;\n    } else {\n      return this.view.isEquivalent(e.view);\n    }\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    if (typeof this.view !== 'number') {\n      this.view = transformExpressionsInExpression(this.view, transform, flags);\n    }\n  }\n  clone() {\n    return new RestoreViewExpr(this.view instanceof Expression ? this.view.clone() : this.view);\n  }\n}\nclass ResetViewExpr extends ExpressionBase {\n  expr;\n  kind = ExpressionKind.ResetView;\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n  visitExpression(visitor, context) {\n    this.expr.visitExpression(visitor, context);\n  }\n  isEquivalent(e) {\n    return e instanceof ResetViewExpr && this.expr.isEquivalent(e.expr);\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n  }\n  clone() {\n    return new ResetViewExpr(this.expr.clone());\n  }\n}\nclass TwoWayBindingSetExpr extends ExpressionBase {\n  target;\n  value;\n  kind = ExpressionKind.TwoWayBindingSet;\n  constructor(target, value) {\n    super();\n    this.target = target;\n    this.value = value;\n  }\n  visitExpression(visitor, context) {\n    this.target.visitExpression(visitor, context);\n    this.value.visitExpression(visitor, context);\n  }\n  isEquivalent(other) {\n    return this.target.isEquivalent(other.target) && this.value.isEquivalent(other.value);\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.target = transformExpressionsInExpression(this.target, transform, flags);\n    this.value = transformExpressionsInExpression(this.value, transform, flags);\n  }\n  clone() {\n    return new TwoWayBindingSetExpr(this.target, this.value);\n  }\n}\nclass ReadVariableExpr extends ExpressionBase {\n  xref;\n  kind = ExpressionKind.ReadVariable;\n  name = null;\n  constructor(xref) {\n    super();\n    this.xref = xref;\n  }\n  visitExpression() {}\n  isEquivalent(other) {\n    return other instanceof ReadVariableExpr && other.xref === this.xref;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    const expr = new ReadVariableExpr(this.xref);\n    expr.name = this.name;\n    return expr;\n  }\n}\nclass PureFunctionExpr extends ExpressionBase {\n  kind = ExpressionKind.PureFunctionExpr;\n  [ConsumesVarsTrait] = true;\n  [UsesVarOffset] = true;\n  varOffset = null;\n  body;\n  args;\n  fn = null;\n  constructor(expression, args) {\n    super();\n    this.body = expression;\n    this.args = args;\n  }\n  visitExpression(visitor, context) {\n    this.body?.visitExpression(visitor, context);\n    for (const arg of this.args) {\n      arg.visitExpression(visitor, context);\n    }\n  }\n  isEquivalent(other) {\n    if (!(other instanceof PureFunctionExpr) || other.args.length !== this.args.length) {\n      return false;\n    }\n    return other.body !== null && this.body !== null && other.body.isEquivalent(this.body) && other.args.every((arg, idx) => arg.isEquivalent(this.args[idx]));\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    if (this.body !== null) {\n      this.body = transformExpressionsInExpression(this.body, transform, flags | VisitorContextFlag.InChildOperation);\n    } else if (this.fn !== null) {\n      this.fn = transformExpressionsInExpression(this.fn, transform, flags);\n    }\n    for (let i = 0; i < this.args.length; i++) {\n      this.args[i] = transformExpressionsInExpression(this.args[i], transform, flags);\n    }\n  }\n  clone() {\n    const expr = new PureFunctionExpr(this.body?.clone() ?? null, this.args.map(arg => arg.clone()));\n    expr.fn = this.fn?.clone() ?? null;\n    expr.varOffset = this.varOffset;\n    return expr;\n  }\n}\nclass PureFunctionParameterExpr extends ExpressionBase {\n  index;\n  kind = ExpressionKind.PureFunctionParameterExpr;\n  constructor(index) {\n    super();\n    this.index = index;\n  }\n  visitExpression() {}\n  isEquivalent(other) {\n    return other instanceof PureFunctionParameterExpr && other.index === this.index;\n  }\n  isConstant() {\n    return true;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    return new PureFunctionParameterExpr(this.index);\n  }\n}\nclass PipeBindingExpr extends ExpressionBase {\n  target;\n  targetSlot;\n  name;\n  args;\n  kind = ExpressionKind.PipeBinding;\n  [ConsumesVarsTrait] = true;\n  [UsesVarOffset] = true;\n  varOffset = null;\n  constructor(target, targetSlot, name, args) {\n    super();\n    this.target = target;\n    this.targetSlot = targetSlot;\n    this.name = name;\n    this.args = args;\n  }\n  visitExpression(visitor, context) {\n    for (const arg of this.args) {\n      arg.visitExpression(visitor, context);\n    }\n  }\n  isEquivalent() {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    for (let idx = 0; idx < this.args.length; idx++) {\n      this.args[idx] = transformExpressionsInExpression(this.args[idx], transform, flags);\n    }\n  }\n  clone() {\n    const r = new PipeBindingExpr(this.target, this.targetSlot, this.name, this.args.map(a => a.clone()));\n    r.varOffset = this.varOffset;\n    return r;\n  }\n}\nclass PipeBindingVariadicExpr extends ExpressionBase {\n  target;\n  targetSlot;\n  name;\n  args;\n  numArgs;\n  kind = ExpressionKind.PipeBindingVariadic;\n  [ConsumesVarsTrait] = true;\n  [UsesVarOffset] = true;\n  varOffset = null;\n  constructor(target, targetSlot, name, args, numArgs) {\n    super();\n    this.target = target;\n    this.targetSlot = targetSlot;\n    this.name = name;\n    this.args = args;\n    this.numArgs = numArgs;\n  }\n  visitExpression(visitor, context) {\n    this.args.visitExpression(visitor, context);\n  }\n  isEquivalent() {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.args = transformExpressionsInExpression(this.args, transform, flags);\n  }\n  clone() {\n    const r = new PipeBindingVariadicExpr(this.target, this.targetSlot, this.name, this.args.clone(), this.numArgs);\n    r.varOffset = this.varOffset;\n    return r;\n  }\n}\nclass SafePropertyReadExpr extends ExpressionBase {\n  receiver;\n  name;\n  kind = ExpressionKind.SafePropertyRead;\n  constructor(receiver, name) {\n    super();\n    this.receiver = receiver;\n    this.name = name;\n  }\n  get index() {\n    return this.name;\n  }\n  visitExpression(visitor, context) {\n    this.receiver.visitExpression(visitor, context);\n  }\n  isEquivalent() {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.receiver = transformExpressionsInExpression(this.receiver, transform, flags);\n  }\n  clone() {\n    return new SafePropertyReadExpr(this.receiver.clone(), this.name);\n  }\n}\nclass SafeKeyedReadExpr extends ExpressionBase {\n  receiver;\n  index;\n  kind = ExpressionKind.SafeKeyedRead;\n  constructor(receiver, index, sourceSpan) {\n    super(sourceSpan);\n    this.receiver = receiver;\n    this.index = index;\n  }\n  visitExpression(visitor, context) {\n    this.receiver.visitExpression(visitor, context);\n    this.index.visitExpression(visitor, context);\n  }\n  isEquivalent() {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.receiver = transformExpressionsInExpression(this.receiver, transform, flags);\n    this.index = transformExpressionsInExpression(this.index, transform, flags);\n  }\n  clone() {\n    return new SafeKeyedReadExpr(this.receiver.clone(), this.index.clone(), this.sourceSpan);\n  }\n}\nclass SafeInvokeFunctionExpr extends ExpressionBase {\n  receiver;\n  args;\n  kind = ExpressionKind.SafeInvokeFunction;\n  constructor(receiver, args) {\n    super();\n    this.receiver = receiver;\n    this.args = args;\n  }\n  visitExpression(visitor, context) {\n    this.receiver.visitExpression(visitor, context);\n    for (const a of this.args) {\n      a.visitExpression(visitor, context);\n    }\n  }\n  isEquivalent() {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.receiver = transformExpressionsInExpression(this.receiver, transform, flags);\n    for (let i = 0; i < this.args.length; i++) {\n      this.args[i] = transformExpressionsInExpression(this.args[i], transform, flags);\n    }\n  }\n  clone() {\n    return new SafeInvokeFunctionExpr(this.receiver.clone(), this.args.map(a => a.clone()));\n  }\n}\nclass SafeTernaryExpr extends ExpressionBase {\n  guard;\n  expr;\n  kind = ExpressionKind.SafeTernaryExpr;\n  constructor(guard, expr) {\n    super();\n    this.guard = guard;\n    this.expr = expr;\n  }\n  visitExpression(visitor, context) {\n    this.guard.visitExpression(visitor, context);\n    this.expr.visitExpression(visitor, context);\n  }\n  isEquivalent() {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.guard = transformExpressionsInExpression(this.guard, transform, flags);\n    this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n  }\n  clone() {\n    return new SafeTernaryExpr(this.guard.clone(), this.expr.clone());\n  }\n}\nclass EmptyExpr extends ExpressionBase {\n  kind = ExpressionKind.EmptyExpr;\n  visitExpression(visitor, context) {}\n  isEquivalent(e) {\n    return e instanceof EmptyExpr;\n  }\n  isConstant() {\n    return true;\n  }\n  clone() {\n    return new EmptyExpr();\n  }\n  transformInternalExpressions() {}\n}\nclass AssignTemporaryExpr extends ExpressionBase {\n  expr;\n  xref;\n  kind = ExpressionKind.AssignTemporaryExpr;\n  name = null;\n  constructor(expr, xref) {\n    super();\n    this.expr = expr;\n    this.xref = xref;\n  }\n  visitExpression(visitor, context) {\n    this.expr.visitExpression(visitor, context);\n  }\n  isEquivalent() {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n  }\n  clone() {\n    const a = new AssignTemporaryExpr(this.expr.clone(), this.xref);\n    a.name = this.name;\n    return a;\n  }\n}\nclass ReadTemporaryExpr extends ExpressionBase {\n  xref;\n  kind = ExpressionKind.ReadTemporaryExpr;\n  name = null;\n  constructor(xref) {\n    super();\n    this.xref = xref;\n  }\n  visitExpression(visitor, context) {}\n  isEquivalent() {\n    return this.xref === this.xref;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {}\n  clone() {\n    const r = new ReadTemporaryExpr(this.xref);\n    r.name = this.name;\n    return r;\n  }\n}\nclass SlotLiteralExpr extends ExpressionBase {\n  slot;\n  kind = ExpressionKind.SlotLiteralExpr;\n  constructor(slot) {\n    super();\n    this.slot = slot;\n  }\n  visitExpression(visitor, context) {}\n  isEquivalent(e) {\n    return e instanceof SlotLiteralExpr && e.slot === this.slot;\n  }\n  isConstant() {\n    return true;\n  }\n  clone() {\n    return new SlotLiteralExpr(this.slot);\n  }\n  transformInternalExpressions() {}\n}\nclass ConditionalCaseExpr extends ExpressionBase {\n  expr;\n  target;\n  targetSlot;\n  alias;\n  kind = ExpressionKind.ConditionalCase;\n  constructor(expr, target, targetSlot, alias = null) {\n    super();\n    this.expr = expr;\n    this.target = target;\n    this.targetSlot = targetSlot;\n    this.alias = alias;\n  }\n  visitExpression(visitor, context) {\n    if (this.expr !== null) {\n      this.expr.visitExpression(visitor, context);\n    }\n  }\n  isEquivalent(e) {\n    return e instanceof ConditionalCaseExpr && e.expr === this.expr;\n  }\n  isConstant() {\n    return true;\n  }\n  clone() {\n    return new ConditionalCaseExpr(this.expr, this.target, this.targetSlot);\n  }\n  transformInternalExpressions(transform, flags) {\n    if (this.expr !== null) {\n      this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n    }\n  }\n}\nclass ConstCollectedExpr extends ExpressionBase {\n  expr;\n  kind = ExpressionKind.ConstCollected;\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.expr = transform(this.expr, flags);\n  }\n  visitExpression(visitor, context) {\n    this.expr.visitExpression(visitor, context);\n  }\n  isEquivalent(e) {\n    if (!(e instanceof ConstCollectedExpr)) {\n      return false;\n    }\n    return this.expr.isEquivalent(e.expr);\n  }\n  isConstant() {\n    return this.expr.isConstant();\n  }\n  clone() {\n    return new ConstCollectedExpr(this.expr);\n  }\n}\nfunction visitExpressionsInOp(op, visitor) {\n  transformExpressionsInOp(op, (expr, flags) => {\n    visitor(expr, flags);\n    return expr;\n  }, VisitorContextFlag.None);\n}\nvar VisitorContextFlag;\n(function (VisitorContextFlag) {\n  VisitorContextFlag[VisitorContextFlag[\"None\"] = 0] = \"None\";\n  VisitorContextFlag[VisitorContextFlag[\"InChildOperation\"] = 1] = \"InChildOperation\";\n})(VisitorContextFlag || (VisitorContextFlag = {}));\nfunction transformExpressionsInInterpolation(interpolation, transform, flags) {\n  for (let i = 0; i < interpolation.expressions.length; i++) {\n    interpolation.expressions[i] = transformExpressionsInExpression(interpolation.expressions[i], transform, flags);\n  }\n}\nfunction transformExpressionsInOp(op, transform, flags) {\n  switch (op.kind) {\n    case OpKind.StyleProp:\n    case OpKind.StyleMap:\n    case OpKind.ClassProp:\n    case OpKind.ClassMap:\n    case OpKind.AnimationString:\n    case OpKind.AnimationBinding:\n    case OpKind.Binding:\n      if (op.expression instanceof Interpolation) {\n        transformExpressionsInInterpolation(op.expression, transform, flags);\n      } else {\n        op.expression = transformExpressionsInExpression(op.expression, transform, flags);\n      }\n      break;\n    case OpKind.Property:\n    case OpKind.DomProperty:\n    case OpKind.Attribute:\n    case OpKind.Control:\n      if (op.expression instanceof Interpolation) {\n        transformExpressionsInInterpolation(op.expression, transform, flags);\n      } else {\n        op.expression = transformExpressionsInExpression(op.expression, transform, flags);\n      }\n      op.sanitizer = op.sanitizer && transformExpressionsInExpression(op.sanitizer, transform, flags);\n      break;\n    case OpKind.TwoWayProperty:\n      op.expression = transformExpressionsInExpression(op.expression, transform, flags);\n      op.sanitizer = op.sanitizer && transformExpressionsInExpression(op.sanitizer, transform, flags);\n      break;\n    case OpKind.I18nExpression:\n      op.expression = transformExpressionsInExpression(op.expression, transform, flags);\n      break;\n    case OpKind.InterpolateText:\n      transformExpressionsInInterpolation(op.interpolation, transform, flags);\n      break;\n    case OpKind.Statement:\n      transformExpressionsInStatement(op.statement, transform, flags);\n      break;\n    case OpKind.Variable:\n      op.initializer = transformExpressionsInExpression(op.initializer, transform, flags);\n      break;\n    case OpKind.Conditional:\n      for (const condition of op.conditions) {\n        if (condition.expr === null) {\n          continue;\n        }\n        condition.expr = transformExpressionsInExpression(condition.expr, transform, flags);\n      }\n      if (op.processed !== null) {\n        op.processed = transformExpressionsInExpression(op.processed, transform, flags);\n      }\n      if (op.contextValue !== null) {\n        op.contextValue = transformExpressionsInExpression(op.contextValue, transform, flags);\n      }\n      break;\n    case OpKind.Animation:\n    case OpKind.AnimationListener:\n    case OpKind.Listener:\n    case OpKind.TwoWayListener:\n      for (const innerOp of op.handlerOps) {\n        transformExpressionsInOp(innerOp, transform, flags | VisitorContextFlag.InChildOperation);\n      }\n      break;\n    case OpKind.ExtractedAttribute:\n      op.expression = op.expression && transformExpressionsInExpression(op.expression, transform, flags);\n      op.trustedValueFn = op.trustedValueFn && transformExpressionsInExpression(op.trustedValueFn, transform, flags);\n      break;\n    case OpKind.RepeaterCreate:\n      if (op.trackByOps === null) {\n        op.track = transformExpressionsInExpression(op.track, transform, flags);\n      } else {\n        for (const innerOp of op.trackByOps) {\n          transformExpressionsInOp(innerOp, transform, flags | VisitorContextFlag.InChildOperation);\n        }\n      }\n      if (op.trackByFn !== null) {\n        op.trackByFn = transformExpressionsInExpression(op.trackByFn, transform, flags);\n      }\n      break;\n    case OpKind.Repeater:\n      op.collection = transformExpressionsInExpression(op.collection, transform, flags);\n      break;\n    case OpKind.Defer:\n      if (op.loadingConfig !== null) {\n        op.loadingConfig = transformExpressionsInExpression(op.loadingConfig, transform, flags);\n      }\n      if (op.placeholderConfig !== null) {\n        op.placeholderConfig = transformExpressionsInExpression(op.placeholderConfig, transform, flags);\n      }\n      if (op.resolverFn !== null) {\n        op.resolverFn = transformExpressionsInExpression(op.resolverFn, transform, flags);\n      }\n      break;\n    case OpKind.I18nMessage:\n      for (const [placeholder, expr] of op.params) {\n        op.params.set(placeholder, transformExpressionsInExpression(expr, transform, flags));\n      }\n      for (const [placeholder, expr] of op.postprocessingParams) {\n        op.postprocessingParams.set(placeholder, transformExpressionsInExpression(expr, transform, flags));\n      }\n      break;\n    case OpKind.DeferWhen:\n      op.expr = transformExpressionsInExpression(op.expr, transform, flags);\n      break;\n    case OpKind.StoreLet:\n      op.value = transformExpressionsInExpression(op.value, transform, flags);\n      break;\n    case OpKind.Advance:\n    case OpKind.Container:\n    case OpKind.ContainerEnd:\n    case OpKind.ContainerStart:\n    case OpKind.DeferOn:\n    case OpKind.DisableBindings:\n    case OpKind.Element:\n    case OpKind.ElementEnd:\n    case OpKind.ElementStart:\n    case OpKind.EnableBindings:\n    case OpKind.I18n:\n    case OpKind.I18nApply:\n    case OpKind.I18nContext:\n    case OpKind.I18nEnd:\n    case OpKind.I18nStart:\n    case OpKind.IcuEnd:\n    case OpKind.IcuStart:\n    case OpKind.Namespace:\n    case OpKind.Pipe:\n    case OpKind.Projection:\n    case OpKind.ProjectionDef:\n    case OpKind.Template:\n    case OpKind.Text:\n    case OpKind.I18nAttributes:\n    case OpKind.IcuPlaceholder:\n    case OpKind.DeclareLet:\n    case OpKind.SourceLocation:\n    case OpKind.ConditionalCreate:\n    case OpKind.ConditionalBranchCreate:\n    case OpKind.ControlCreate:\n      break;\n    default:\n      throw new Error(`AssertionError: transformExpressionsInOp doesn't handle ${OpKind[op.kind]}`);\n  }\n}\nfunction transformExpressionsInExpression(expr, transform, flags) {\n  if (expr instanceof ExpressionBase) {\n    expr.transformInternalExpressions(transform, flags);\n  } else if (expr instanceof BinaryOperatorExpr) {\n    expr.lhs = transformExpressionsInExpression(expr.lhs, transform, flags);\n    expr.rhs = transformExpressionsInExpression(expr.rhs, transform, flags);\n  } else if (expr instanceof UnaryOperatorExpr) {\n    expr.expr = transformExpressionsInExpression(expr.expr, transform, flags);\n  } else if (expr instanceof ReadPropExpr) {\n    expr.receiver = transformExpressionsInExpression(expr.receiver, transform, flags);\n  } else if (expr instanceof ReadKeyExpr) {\n    expr.receiver = transformExpressionsInExpression(expr.receiver, transform, flags);\n    expr.index = transformExpressionsInExpression(expr.index, transform, flags);\n  } else if (expr instanceof InvokeFunctionExpr) {\n    expr.fn = transformExpressionsInExpression(expr.fn, transform, flags);\n    for (let i = 0; i < expr.args.length; i++) {\n      expr.args[i] = transformExpressionsInExpression(expr.args[i], transform, flags);\n    }\n  } else if (expr instanceof LiteralArrayExpr) {\n    for (let i = 0; i < expr.entries.length; i++) {\n      expr.entries[i] = transformExpressionsInExpression(expr.entries[i], transform, flags);\n    }\n  } else if (expr instanceof LiteralMapExpr) {\n    for (let i = 0; i < expr.entries.length; i++) {\n      expr.entries[i].value = transformExpressionsInExpression(expr.entries[i].value, transform, flags);\n    }\n  } else if (expr instanceof ConditionalExpr) {\n    expr.condition = transformExpressionsInExpression(expr.condition, transform, flags);\n    expr.trueCase = transformExpressionsInExpression(expr.trueCase, transform, flags);\n    if (expr.falseCase !== null) {\n      expr.falseCase = transformExpressionsInExpression(expr.falseCase, transform, flags);\n    }\n  } else if (expr instanceof TypeofExpr) {\n    expr.expr = transformExpressionsInExpression(expr.expr, transform, flags);\n  } else if (expr instanceof VoidExpr) {\n    expr.expr = transformExpressionsInExpression(expr.expr, transform, flags);\n  } else if (expr instanceof LocalizedString) {\n    for (let i = 0; i < expr.expressions.length; i++) {\n      expr.expressions[i] = transformExpressionsInExpression(expr.expressions[i], transform, flags);\n    }\n  } else if (expr instanceof NotExpr) {\n    expr.condition = transformExpressionsInExpression(expr.condition, transform, flags);\n  } else if (expr instanceof TaggedTemplateLiteralExpr) {\n    expr.tag = transformExpressionsInExpression(expr.tag, transform, flags);\n    expr.template.expressions = expr.template.expressions.map(e => transformExpressionsInExpression(e, transform, flags));\n  } else if (expr instanceof ArrowFunctionExpr) {\n    if (Array.isArray(expr.body)) {\n      for (let i = 0; i < expr.body.length; i++) {\n        transformExpressionsInStatement(expr.body[i], transform, flags);\n      }\n    } else {\n      expr.body = transformExpressionsInExpression(expr.body, transform, flags);\n    }\n  } else if (expr instanceof WrappedNodeExpr) ;else if (expr instanceof TemplateLiteralExpr) {\n    for (let i = 0; i < expr.expressions.length; i++) {\n      expr.expressions[i] = transformExpressionsInExpression(expr.expressions[i], transform, flags);\n    }\n  } else if (expr instanceof ParenthesizedExpr) {\n    expr.expr = transformExpressionsInExpression(expr.expr, transform, flags);\n  } else if (expr instanceof ReadVarExpr || expr instanceof ExternalExpr || expr instanceof LiteralExpr || expr instanceof RegularExpressionLiteralExpr) ;else {\n    throw new Error(`Unhandled expression kind: ${expr.constructor.name}`);\n  }\n  return transform(expr, flags);\n}\nfunction transformExpressionsInStatement(stmt, transform, flags) {\n  if (stmt instanceof ExpressionStatement) {\n    stmt.expr = transformExpressionsInExpression(stmt.expr, transform, flags);\n  } else if (stmt instanceof ReturnStatement) {\n    stmt.value = transformExpressionsInExpression(stmt.value, transform, flags);\n  } else if (stmt instanceof DeclareVarStmt) {\n    if (stmt.value !== undefined) {\n      stmt.value = transformExpressionsInExpression(stmt.value, transform, flags);\n    }\n  } else if (stmt instanceof IfStmt) {\n    stmt.condition = transformExpressionsInExpression(stmt.condition, transform, flags);\n    for (const caseStatement of stmt.trueCase) {\n      transformExpressionsInStatement(caseStatement, transform, flags);\n    }\n    for (const caseStatement of stmt.falseCase) {\n      transformExpressionsInStatement(caseStatement, transform, flags);\n    }\n  } else {\n    throw new Error(`Unhandled statement kind: ${stmt.constructor.name}`);\n  }\n}\nfunction isStringLiteral(expr) {\n  return expr instanceof LiteralExpr && typeof expr.value === 'string';\n}\nclass OpList {\n  static nextListId = 0;\n  debugListId = OpList.nextListId++;\n  head = {\n    kind: OpKind.ListEnd,\n    next: null,\n    prev: null,\n    debugListId: this.debugListId\n  };\n  tail = {\n    kind: OpKind.ListEnd,\n    next: null,\n    prev: null,\n    debugListId: this.debugListId\n  };\n  constructor() {\n    this.head.next = this.tail;\n    this.tail.prev = this.head;\n  }\n  push(op) {\n    if (Array.isArray(op)) {\n      for (const o of op) {\n        this.push(o);\n      }\n      return;\n    }\n    OpList.assertIsNotEnd(op);\n    OpList.assertIsUnowned(op);\n    op.debugListId = this.debugListId;\n    const oldLast = this.tail.prev;\n    op.prev = oldLast;\n    oldLast.next = op;\n    op.next = this.tail;\n    this.tail.prev = op;\n  }\n  prepend(ops) {\n    if (ops.length === 0) {\n      return;\n    }\n    for (const op of ops) {\n      OpList.assertIsNotEnd(op);\n      OpList.assertIsUnowned(op);\n      op.debugListId = this.debugListId;\n    }\n    const first = this.head.next;\n    let prev = this.head;\n    for (const op of ops) {\n      prev.next = op;\n      op.prev = prev;\n      prev = op;\n    }\n    prev.next = first;\n    first.prev = prev;\n  }\n  *[Symbol.iterator]() {\n    let current = this.head.next;\n    while (current !== this.tail) {\n      OpList.assertIsOwned(current, this.debugListId);\n      const next = current.next;\n      yield current;\n      current = next;\n    }\n  }\n  *reversed() {\n    let current = this.tail.prev;\n    while (current !== this.head) {\n      OpList.assertIsOwned(current, this.debugListId);\n      const prev = current.prev;\n      yield current;\n      current = prev;\n    }\n  }\n  static replace(oldOp, newOp) {\n    OpList.assertIsNotEnd(oldOp);\n    OpList.assertIsNotEnd(newOp);\n    OpList.assertIsOwned(oldOp);\n    OpList.assertIsUnowned(newOp);\n    newOp.debugListId = oldOp.debugListId;\n    if (oldOp.prev !== null) {\n      oldOp.prev.next = newOp;\n      newOp.prev = oldOp.prev;\n    }\n    if (oldOp.next !== null) {\n      oldOp.next.prev = newOp;\n      newOp.next = oldOp.next;\n    }\n    oldOp.debugListId = null;\n    oldOp.prev = null;\n    oldOp.next = null;\n  }\n  static replaceWithMany(oldOp, newOps) {\n    if (newOps.length === 0) {\n      OpList.remove(oldOp);\n      return;\n    }\n    OpList.assertIsNotEnd(oldOp);\n    OpList.assertIsOwned(oldOp);\n    const listId = oldOp.debugListId;\n    oldOp.debugListId = null;\n    for (const newOp of newOps) {\n      OpList.assertIsNotEnd(newOp);\n      OpList.assertIsUnowned(newOp);\n    }\n    const {\n      prev: oldPrev,\n      next: oldNext\n    } = oldOp;\n    oldOp.prev = null;\n    oldOp.next = null;\n    let prev = oldPrev;\n    for (const newOp of newOps) {\n      OpList.assertIsUnowned(newOp);\n      newOp.debugListId = listId;\n      prev.next = newOp;\n      newOp.prev = prev;\n      newOp.next = null;\n      prev = newOp;\n    }\n    const first = newOps[0];\n    const last = prev;\n    if (oldPrev !== null) {\n      oldPrev.next = first;\n      first.prev = oldPrev;\n    }\n    if (oldNext !== null) {\n      oldNext.prev = last;\n      last.next = oldNext;\n    }\n  }\n  static remove(op) {\n    OpList.assertIsNotEnd(op);\n    OpList.assertIsOwned(op);\n    op.prev.next = op.next;\n    op.next.prev = op.prev;\n    op.debugListId = null;\n    op.prev = null;\n    op.next = null;\n  }\n  static insertBefore(op, target) {\n    if (Array.isArray(op)) {\n      for (const o of op) {\n        OpList.insertBefore(o, target);\n      }\n      return;\n    }\n    OpList.assertIsOwned(target);\n    if (target.prev === null) {\n      throw new Error(`AssertionError: illegal operation on list start`);\n    }\n    OpList.assertIsNotEnd(op);\n    OpList.assertIsUnowned(op);\n    op.debugListId = target.debugListId;\n    op.prev = null;\n    target.prev.next = op;\n    op.prev = target.prev;\n    op.next = target;\n    target.prev = op;\n  }\n  static insertAfter(op, target) {\n    OpList.assertIsOwned(target);\n    if (target.next === null) {\n      throw new Error(`AssertionError: illegal operation on list end`);\n    }\n    OpList.assertIsNotEnd(op);\n    OpList.assertIsUnowned(op);\n    op.debugListId = target.debugListId;\n    target.next.prev = op;\n    op.next = target.next;\n    op.prev = target;\n    target.next = op;\n  }\n  static assertIsUnowned(op) {\n    if (op.debugListId !== null) {\n      throw new Error(`AssertionError: illegal operation on owned node: ${OpKind[op.kind]}`);\n    }\n  }\n  static assertIsOwned(op, byList) {\n    if (op.debugListId === null) {\n      throw new Error(`AssertionError: illegal operation on unowned node: ${OpKind[op.kind]}`);\n    } else if (byList !== undefined && op.debugListId !== byList) {\n      throw new Error(`AssertionError: node belongs to the wrong list (expected ${byList}, actual ${op.debugListId})`);\n    }\n  }\n  static assertIsNotEnd(op) {\n    if (op.kind === OpKind.ListEnd) {\n      throw new Error(`AssertionError: illegal operation on list head or tail`);\n    }\n  }\n}\nclass SlotHandle {\n  slot = null;\n}\nconst elementContainerOpKinds = new Set([OpKind.Element, OpKind.ElementStart, OpKind.Container, OpKind.ContainerStart, OpKind.Template, OpKind.RepeaterCreate, OpKind.ConditionalCreate, OpKind.ConditionalBranchCreate]);\nfunction isElementOrContainerOp(op) {\n  return elementContainerOpKinds.has(op.kind);\n}\nfunction createElementStartOp(tag, xref, namespace, i18nPlaceholder, startSourceSpan, wholeSourceSpan) {\n  return {\n    kind: OpKind.ElementStart,\n    xref,\n    tag,\n    handle: new SlotHandle(),\n    attributes: null,\n    localRefs: [],\n    nonBindable: false,\n    namespace,\n    i18nPlaceholder,\n    startSourceSpan,\n    wholeSourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP\n  };\n}\nfunction createTemplateOp(xref, templateKind, tag, functionNameSuffix, namespace, i18nPlaceholder, startSourceSpan, wholeSourceSpan) {\n  return {\n    kind: OpKind.Template,\n    xref,\n    templateKind,\n    attributes: null,\n    tag,\n    handle: new SlotHandle(),\n    functionNameSuffix,\n    decls: null,\n    vars: null,\n    localRefs: [],\n    nonBindable: false,\n    namespace,\n    i18nPlaceholder,\n    startSourceSpan,\n    wholeSourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP\n  };\n}\nfunction createConditionalCreateOp(xref, templateKind, tag, functionNameSuffix, namespace, i18nPlaceholder, startSourceSpan, wholeSourceSpan) {\n  return {\n    kind: OpKind.ConditionalCreate,\n    xref,\n    templateKind,\n    attributes: null,\n    tag,\n    handle: new SlotHandle(),\n    functionNameSuffix,\n    decls: null,\n    vars: null,\n    localRefs: [],\n    nonBindable: false,\n    namespace,\n    i18nPlaceholder,\n    startSourceSpan,\n    wholeSourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP\n  };\n}\nfunction createConditionalBranchCreateOp(xref, templateKind, tag, functionNameSuffix, namespace, i18nPlaceholder, startSourceSpan, wholeSourceSpan) {\n  return {\n    kind: OpKind.ConditionalBranchCreate,\n    xref,\n    templateKind,\n    attributes: null,\n    tag,\n    handle: new SlotHandle(),\n    functionNameSuffix,\n    decls: null,\n    vars: null,\n    localRefs: [],\n    nonBindable: false,\n    namespace,\n    i18nPlaceholder,\n    startSourceSpan,\n    wholeSourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP\n  };\n}\nfunction createRepeaterCreateOp(primaryView, emptyView, tag, track, varNames, emptyTag, i18nPlaceholder, emptyI18nPlaceholder, startSourceSpan, wholeSourceSpan) {\n  return {\n    kind: OpKind.RepeaterCreate,\n    attributes: null,\n    xref: primaryView,\n    handle: new SlotHandle(),\n    emptyView,\n    track,\n    trackByFn: null,\n    trackByOps: null,\n    tag,\n    emptyTag,\n    emptyAttributes: null,\n    functionNameSuffix: 'For',\n    namespace: Namespace.HTML,\n    nonBindable: false,\n    localRefs: [],\n    decls: null,\n    vars: null,\n    varNames,\n    usesComponentInstance: false,\n    i18nPlaceholder,\n    emptyI18nPlaceholder,\n    startSourceSpan,\n    wholeSourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_VARS,\n    numSlotsUsed: emptyView === null ? 2 : 3\n  };\n}\nfunction createElementEndOp(xref, sourceSpan) {\n  return {\n    kind: OpKind.ElementEnd,\n    xref,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createDisableBindingsOp(xref) {\n  return {\n    kind: OpKind.DisableBindings,\n    xref,\n    ...NEW_OP\n  };\n}\nfunction createEnableBindingsOp(xref) {\n  return {\n    kind: OpKind.EnableBindings,\n    xref,\n    ...NEW_OP\n  };\n}\nfunction createTextOp(xref, initialValue, icuPlaceholder, sourceSpan) {\n  return {\n    kind: OpKind.Text,\n    xref,\n    handle: new SlotHandle(),\n    initialValue,\n    icuPlaceholder,\n    sourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP\n  };\n}\nfunction createAnimationStringOp(name, target, animationKind, expression, securityContext, sourceSpan) {\n  return {\n    kind: OpKind.AnimationString,\n    name,\n    target,\n    animationKind,\n    expression,\n    i18nMessage: null,\n    securityContext,\n    sanitizer: null,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createAnimationOp(name, target, animationKind, callbackOps, securityContext, sourceSpan) {\n  const handlerOps = new OpList();\n  handlerOps.push(callbackOps);\n  return {\n    kind: OpKind.Animation,\n    name,\n    target,\n    animationKind,\n    handlerOps,\n    handlerFnName: null,\n    i18nMessage: null,\n    securityContext,\n    sanitizer: null,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createListenerOp(target, targetSlot, name, tag, handlerOps, legacyAnimationPhase, eventTarget, hostListener, sourceSpan) {\n  const handlerList = new OpList();\n  handlerList.push(handlerOps);\n  return {\n    kind: OpKind.Listener,\n    target,\n    targetSlot,\n    tag,\n    hostListener,\n    name,\n    handlerOps: handlerList,\n    handlerFnName: null,\n    consumesDollarEvent: false,\n    isLegacyAnimationListener: legacyAnimationPhase !== null,\n    legacyAnimationPhase: legacyAnimationPhase,\n    eventTarget,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createAnimationListenerOp(target, targetSlot, name, tag, handlerOps, animationKind, eventTarget, hostListener, sourceSpan) {\n  const handlerList = new OpList();\n  handlerList.push(handlerOps);\n  return {\n    kind: OpKind.AnimationListener,\n    target,\n    targetSlot,\n    tag,\n    hostListener,\n    name,\n    animationKind,\n    handlerOps: handlerList,\n    handlerFnName: null,\n    consumesDollarEvent: false,\n    eventTarget,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createTwoWayListenerOp(target, targetSlot, name, tag, handlerOps, sourceSpan) {\n  const handlerList = new OpList();\n  handlerList.push(handlerOps);\n  return {\n    kind: OpKind.TwoWayListener,\n    target,\n    targetSlot,\n    tag,\n    name,\n    handlerOps: handlerList,\n    handlerFnName: null,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createPipeOp(xref, slot, name) {\n  return {\n    kind: OpKind.Pipe,\n    xref,\n    handle: slot,\n    name,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_SLOT\n  };\n}\nfunction createNamespaceOp(namespace) {\n  return {\n    kind: OpKind.Namespace,\n    active: namespace,\n    ...NEW_OP\n  };\n}\nfunction createProjectionDefOp(def) {\n  return {\n    kind: OpKind.ProjectionDef,\n    def,\n    ...NEW_OP\n  };\n}\nfunction createProjectionOp(xref, selector, i18nPlaceholder, fallbackView, sourceSpan) {\n  return {\n    kind: OpKind.Projection,\n    xref,\n    handle: new SlotHandle(),\n    selector,\n    i18nPlaceholder,\n    fallbackView,\n    projectionSlotIndex: 0,\n    attributes: null,\n    localRefs: [],\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_SLOT,\n    numSlotsUsed: fallbackView === null ? 1 : 2\n  };\n}\nfunction createExtractedAttributeOp(target, bindingKind, namespace, name, expression, i18nContext, i18nMessage, securityContext) {\n  return {\n    kind: OpKind.ExtractedAttribute,\n    target,\n    bindingKind,\n    namespace,\n    name,\n    expression,\n    i18nContext,\n    i18nMessage,\n    securityContext,\n    trustedValueFn: null,\n    ...NEW_OP\n  };\n}\nfunction createDeferOp(xref, main, mainSlot, ownResolverFn, resolverFn, sourceSpan) {\n  return {\n    kind: OpKind.Defer,\n    xref,\n    handle: new SlotHandle(),\n    mainView: main,\n    mainSlot,\n    loadingView: null,\n    loadingSlot: null,\n    loadingConfig: null,\n    loadingMinimumTime: null,\n    loadingAfterTime: null,\n    placeholderView: null,\n    placeholderSlot: null,\n    placeholderConfig: null,\n    placeholderMinimumTime: null,\n    errorView: null,\n    errorSlot: null,\n    ownResolverFn,\n    resolverFn,\n    flags: null,\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_SLOT,\n    numSlotsUsed: 2\n  };\n}\nfunction createDeferOnOp(defer, trigger, modifier, sourceSpan) {\n  return {\n    kind: OpKind.DeferOn,\n    defer,\n    trigger,\n    modifier,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createDeclareLetOp(xref, declaredName, sourceSpan) {\n  return {\n    kind: OpKind.DeclareLet,\n    xref,\n    declaredName,\n    sourceSpan,\n    handle: new SlotHandle(),\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP\n  };\n}\nfunction createI18nMessageOp(xref, i18nContext, i18nBlock, message, messagePlaceholder, params, postprocessingParams, needsPostprocessing) {\n  return {\n    kind: OpKind.I18nMessage,\n    xref,\n    i18nContext,\n    i18nBlock,\n    message,\n    messagePlaceholder,\n    params,\n    postprocessingParams,\n    needsPostprocessing,\n    subMessages: [],\n    ...NEW_OP\n  };\n}\nfunction createI18nStartOp(xref, message, root, sourceSpan) {\n  return {\n    kind: OpKind.I18nStart,\n    xref,\n    handle: new SlotHandle(),\n    root: root ?? xref,\n    message,\n    messageIndex: null,\n    subTemplateIndex: null,\n    context: null,\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_SLOT\n  };\n}\nfunction createI18nEndOp(xref, sourceSpan) {\n  return {\n    kind: OpKind.I18nEnd,\n    xref,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createIcuStartOp(xref, message, messagePlaceholder, sourceSpan) {\n  return {\n    kind: OpKind.IcuStart,\n    xref,\n    message,\n    messagePlaceholder,\n    context: null,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createIcuEndOp(xref) {\n  return {\n    kind: OpKind.IcuEnd,\n    xref,\n    ...NEW_OP\n  };\n}\nfunction createIcuPlaceholderOp(xref, name, strings) {\n  return {\n    kind: OpKind.IcuPlaceholder,\n    xref,\n    name,\n    strings,\n    expressionPlaceholders: [],\n    ...NEW_OP\n  };\n}\nfunction createI18nContextOp(contextKind, xref, i18nBlock, message, sourceSpan) {\n  if (i18nBlock === null && contextKind !== I18nContextKind.Attr) {\n    throw new Error('AssertionError: i18nBlock must be provided for non-attribute contexts.');\n  }\n  return {\n    kind: OpKind.I18nContext,\n    contextKind,\n    xref,\n    i18nBlock,\n    message,\n    sourceSpan,\n    params: new Map(),\n    postprocessingParams: new Map(),\n    ...NEW_OP\n  };\n}\nfunction createI18nAttributesOp(xref, handle, target) {\n  return {\n    kind: OpKind.I18nAttributes,\n    xref,\n    handle,\n    target,\n    i18nAttributesConfig: null,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_SLOT\n  };\n}\nfunction createSourceLocationOp(templatePath, locations) {\n  return {\n    kind: OpKind.SourceLocation,\n    templatePath,\n    locations,\n    ...NEW_OP\n  };\n}\nfunction createControlCreateOp(sourceSpan) {\n  return {\n    kind: OpKind.ControlCreate,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createDomPropertyOp(name, expression, bindingKind, i18nContext, securityContext, sourceSpan) {\n  return {\n    kind: OpKind.DomProperty,\n    name,\n    expression,\n    bindingKind,\n    i18nContext,\n    securityContext,\n    sanitizer: null,\n    sourceSpan,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nconst CTX_REF = 'CTX_REF_MARKER';\nvar CompilationJobKind;\n(function (CompilationJobKind) {\n  CompilationJobKind[CompilationJobKind[\"Tmpl\"] = 0] = \"Tmpl\";\n  CompilationJobKind[CompilationJobKind[\"Host\"] = 1] = \"Host\";\n  CompilationJobKind[CompilationJobKind[\"Both\"] = 2] = \"Both\";\n})(CompilationJobKind || (CompilationJobKind = {}));\nvar TemplateCompilationMode;\n(function (TemplateCompilationMode) {\n  TemplateCompilationMode[TemplateCompilationMode[\"Full\"] = 0] = \"Full\";\n  TemplateCompilationMode[TemplateCompilationMode[\"DomOnly\"] = 1] = \"DomOnly\";\n})(TemplateCompilationMode || (TemplateCompilationMode = {}));\nclass CompilationJob {\n  componentName;\n  pool;\n  compatibility;\n  mode;\n  constructor(componentName, pool, compatibility, mode) {\n    this.componentName = componentName;\n    this.pool = pool;\n    this.compatibility = compatibility;\n    this.mode = mode;\n  }\n  kind = CompilationJobKind.Both;\n  allocateXrefId() {\n    return this.nextXrefId++;\n  }\n  nextXrefId = 0;\n}\nclass ComponentCompilationJob extends CompilationJob {\n  relativeContextFilePath;\n  i18nUseExternalIds;\n  deferMeta;\n  allDeferrableDepsFn;\n  relativeTemplatePath;\n  enableDebugLocations;\n  constructor(componentName, pool, compatibility, mode, relativeContextFilePath, i18nUseExternalIds, deferMeta, allDeferrableDepsFn, relativeTemplatePath, enableDebugLocations) {\n    super(componentName, pool, compatibility, mode);\n    this.relativeContextFilePath = relativeContextFilePath;\n    this.i18nUseExternalIds = i18nUseExternalIds;\n    this.deferMeta = deferMeta;\n    this.allDeferrableDepsFn = allDeferrableDepsFn;\n    this.relativeTemplatePath = relativeTemplatePath;\n    this.enableDebugLocations = enableDebugLocations;\n    this.root = new ViewCompilationUnit(this, this.allocateXrefId(), null);\n    this.views.set(this.root.xref, this.root);\n  }\n  kind = CompilationJobKind.Tmpl;\n  fnSuffix = 'Template';\n  root;\n  views = new Map();\n  contentSelectors = null;\n  allocateView(parent) {\n    const view = new ViewCompilationUnit(this, this.allocateXrefId(), parent);\n    this.views.set(view.xref, view);\n    return view;\n  }\n  get units() {\n    return this.views.values();\n  }\n  addConst(newConst, initializers) {\n    for (let idx = 0; idx < this.consts.length; idx++) {\n      if (this.consts[idx].isEquivalent(newConst)) {\n        return idx;\n      }\n    }\n    const idx = this.consts.length;\n    this.consts.push(newConst);\n    if (initializers) {\n      this.constsInitializers.push(...initializers);\n    }\n    return idx;\n  }\n  consts = [];\n  constsInitializers = [];\n}\nclass CompilationUnit {\n  xref;\n  constructor(xref) {\n    this.xref = xref;\n  }\n  create = new OpList();\n  update = new OpList();\n  fnName = null;\n  vars = null;\n  *ops() {\n    for (const op of this.create) {\n      yield op;\n      if (op.kind === OpKind.Listener || op.kind === OpKind.Animation || op.kind === OpKind.AnimationListener || op.kind === OpKind.TwoWayListener) {\n        for (const listenerOp of op.handlerOps) {\n          yield listenerOp;\n        }\n      } else if (op.kind === OpKind.RepeaterCreate && op.trackByOps !== null) {\n        for (const trackOp of op.trackByOps) {\n          yield trackOp;\n        }\n      }\n    }\n    for (const op of this.update) {\n      yield op;\n    }\n  }\n}\nclass ViewCompilationUnit extends CompilationUnit {\n  job;\n  parent;\n  constructor(job, xref, parent) {\n    super(xref);\n    this.job = job;\n    this.parent = parent;\n  }\n  contextVariables = new Map();\n  aliases = new Set();\n  decls = null;\n}\nclass HostBindingCompilationJob extends CompilationJob {\n  constructor(componentName, pool, compatibility, mode) {\n    super(componentName, pool, compatibility, mode);\n    this.root = new HostBindingCompilationUnit(this);\n  }\n  kind = CompilationJobKind.Host;\n  fnSuffix = 'HostBindings';\n  root;\n  get units() {\n    return [this.root];\n  }\n}\nclass HostBindingCompilationUnit extends CompilationUnit {\n  job;\n  constructor(job) {\n    super(0);\n    this.job = job;\n  }\n  attributes = null;\n}\nfunction deleteAnyCasts(job) {\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      transformExpressionsInOp(op, removeAnys, VisitorContextFlag.None);\n    }\n  }\n}\nfunction removeAnys(e) {\n  if (e instanceof InvokeFunctionExpr && e.fn instanceof LexicalReadExpr && e.fn.name === '$any') {\n    if (e.args.length !== 1) {\n      throw new Error('The $any builtin function expects exactly one argument.');\n    }\n    return e.args[0];\n  }\n  return e;\n}\nfunction applyI18nExpressions(job) {\n  const i18nContexts = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.I18nContext) {\n        i18nContexts.set(op.xref, op);\n      }\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      if (op.kind === OpKind.I18nExpression && needsApplication(i18nContexts, op)) {\n        OpList.insertAfter(createI18nApplyOp(op.i18nOwner, op.handle, null), op);\n      }\n    }\n  }\n}\nfunction needsApplication(i18nContexts, op) {\n  if (op.next?.kind !== OpKind.I18nExpression) {\n    return true;\n  }\n  const context = i18nContexts.get(op.context);\n  const nextContext = i18nContexts.get(op.next.context);\n  if (context === undefined) {\n    throw new Error(\"AssertionError: expected an I18nContextOp to exist for the I18nExpressionOp's context\");\n  }\n  if (nextContext === undefined) {\n    throw new Error(\"AssertionError: expected an I18nContextOp to exist for the next I18nExpressionOp's context\");\n  }\n  if (context.i18nBlock !== null) {\n    if (context.i18nBlock !== nextContext.i18nBlock) {\n      return true;\n    }\n    return false;\n  }\n  if (op.i18nOwner !== op.next.i18nOwner) {\n    return true;\n  }\n  return false;\n}\nfunction assignI18nSlotDependencies(job) {\n  for (const unit of job.units) {\n    let updateOp = unit.update.head;\n    let i18nExpressionsInProgress = [];\n    let state = null;\n    for (const createOp of unit.create) {\n      if (createOp.kind === OpKind.I18nStart) {\n        state = {\n          blockXref: createOp.xref,\n          lastSlotConsumer: createOp.xref\n        };\n      } else if (createOp.kind === OpKind.I18nEnd) {\n        for (const op of i18nExpressionsInProgress) {\n          op.target = state.lastSlotConsumer;\n          OpList.insertBefore(op, updateOp);\n        }\n        i18nExpressionsInProgress.length = 0;\n        state = null;\n      }\n      if (hasConsumesSlotTrait(createOp)) {\n        if (state !== null) {\n          state.lastSlotConsumer = createOp.xref;\n        }\n        while (true) {\n          if (updateOp.next === null) {\n            break;\n          }\n          if (state !== null && updateOp.kind === OpKind.I18nExpression && updateOp.usage === I18nExpressionFor.I18nText && updateOp.i18nOwner === state.blockXref) {\n            const opToRemove = updateOp;\n            updateOp = updateOp.next;\n            OpList.remove(opToRemove);\n            i18nExpressionsInProgress.push(opToRemove);\n            continue;\n          }\n          let hasDifferentTarget = false;\n          if (hasDependsOnSlotContextTrait(updateOp) && updateOp.target !== createOp.xref) {\n            hasDifferentTarget = true;\n          } else if (updateOp.kind === OpKind.Statement || updateOp.kind === OpKind.Variable) {\n            visitExpressionsInOp(updateOp, expr => {\n              if (!hasDifferentTarget && hasDependsOnSlotContextTrait(expr) && expr.target !== createOp.xref) {\n                hasDifferentTarget = true;\n              }\n            });\n          }\n          if (hasDifferentTarget) {\n            break;\n          }\n          updateOp = updateOp.next;\n        }\n      }\n    }\n  }\n}\nfunction attachSourceLocations(job) {\n  if (!job.enableDebugLocations || job.relativeTemplatePath === null) {\n    return;\n  }\n  for (const unit of job.units) {\n    const locations = [];\n    for (const op of unit.create) {\n      if (op.kind === OpKind.ElementStart || op.kind === OpKind.Element) {\n        const start = op.startSourceSpan.start;\n        locations.push({\n          targetSlot: op.handle,\n          offset: start.offset,\n          line: start.line,\n          column: start.col\n        });\n      }\n    }\n    if (locations.length > 0) {\n      unit.create.push(createSourceLocationOp(job.relativeTemplatePath, locations));\n    }\n  }\n}\nfunction createOpXrefMap(unit) {\n  const map = new Map();\n  for (const op of unit.create) {\n    if (!hasConsumesSlotTrait(op)) {\n      continue;\n    }\n    map.set(op.xref, op);\n    if (op.kind === OpKind.RepeaterCreate && op.emptyView !== null) {\n      map.set(op.emptyView, op);\n    }\n  }\n  return map;\n}\nfunction extractAttributes(job) {\n  for (const unit of job.units) {\n    const elements = createOpXrefMap(unit);\n    for (const op of unit.ops()) {\n      switch (op.kind) {\n        case OpKind.Attribute:\n          extractAttributeOp(unit, op, elements);\n          break;\n        case OpKind.Property:\n          if (op.bindingKind !== BindingKind.LegacyAnimation && op.bindingKind !== BindingKind.Animation) {\n            let bindingKind;\n            if (op.i18nMessage !== null && op.templateKind === null) {\n              bindingKind = BindingKind.I18n;\n            } else if (op.isStructuralTemplateAttribute) {\n              bindingKind = BindingKind.Template;\n            } else {\n              bindingKind = BindingKind.Property;\n            }\n            OpList.insertBefore(createExtractedAttributeOp(op.target, bindingKind, null, op.name, null, null, null, op.securityContext), lookupElement$3(elements, op.target));\n          }\n          break;\n        case OpKind.Control:\n          OpList.insertBefore(createExtractedAttributeOp(op.target, BindingKind.Property, null, 'field', null, null, null, op.securityContext), lookupElement$3(elements, op.target));\n          break;\n        case OpKind.TwoWayProperty:\n          OpList.insertBefore(createExtractedAttributeOp(op.target, BindingKind.TwoWayProperty, null, op.name, null, null, null, op.securityContext), lookupElement$3(elements, op.target));\n          break;\n        case OpKind.StyleProp:\n        case OpKind.ClassProp:\n          if (unit.job.compatibility === CompatibilityMode.TemplateDefinitionBuilder && op.expression instanceof EmptyExpr) {\n            OpList.insertBefore(createExtractedAttributeOp(op.target, BindingKind.Property, null, op.name, null, null, null, SecurityContext.STYLE), lookupElement$3(elements, op.target));\n          }\n          break;\n        case OpKind.Listener:\n          if (!op.isLegacyAnimationListener) {\n            const extractedAttributeOp = createExtractedAttributeOp(op.target, BindingKind.Property, null, op.name, null, null, null, SecurityContext.NONE);\n            if (job.kind === CompilationJobKind.Host) {\n              if (job.compatibility) {\n                break;\n              }\n              unit.create.push(extractedAttributeOp);\n            } else {\n              OpList.insertBefore(extractedAttributeOp, lookupElement$3(elements, op.target));\n            }\n          }\n          break;\n        case OpKind.TwoWayListener:\n          if (job.kind !== CompilationJobKind.Host) {\n            const extractedAttributeOp = createExtractedAttributeOp(op.target, BindingKind.Property, null, op.name, null, null, null, SecurityContext.NONE);\n            OpList.insertBefore(extractedAttributeOp, lookupElement$3(elements, op.target));\n          }\n          break;\n      }\n    }\n  }\n}\nfunction lookupElement$3(elements, xref) {\n  const el = elements.get(xref);\n  if (el === undefined) {\n    throw new Error('All attributes should have an element-like target.');\n  }\n  return el;\n}\nfunction extractAttributeOp(unit, op, elements) {\n  if (op.expression instanceof Interpolation) {\n    return;\n  }\n  let extractable = op.isTextAttribute || op.expression.isConstant();\n  if (unit.job.compatibility === CompatibilityMode.TemplateDefinitionBuilder) {\n    extractable &&= op.isTextAttribute;\n  }\n  if (extractable) {\n    const extractedAttributeOp = createExtractedAttributeOp(op.target, op.isStructuralTemplateAttribute ? BindingKind.Template : BindingKind.Attribute, op.namespace, op.name, op.expression, op.i18nContext, op.i18nMessage, op.securityContext);\n    if (unit.job.kind === CompilationJobKind.Host) {\n      unit.create.push(extractedAttributeOp);\n    } else {\n      const ownerOp = lookupElement$3(elements, op.target);\n      OpList.insertBefore(extractedAttributeOp, ownerOp);\n    }\n    OpList.remove(op);\n  }\n}\nconst ARIA_PREFIX = 'aria-';\nfunction isAriaAttribute(name) {\n  return name.startsWith(ARIA_PREFIX) && name.length > ARIA_PREFIX.length;\n}\nfunction lookupElement$2(elements, xref) {\n  const el = elements.get(xref);\n  if (el === undefined) {\n    throw new Error('All attributes should have an element-like target.');\n  }\n  return el;\n}\nfunction specializeBindings(job) {\n  const elements = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (!isElementOrContainerOp(op)) {\n        continue;\n      }\n      elements.set(op.xref, op);\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind !== OpKind.Binding) {\n        continue;\n      }\n      switch (op.bindingKind) {\n        case BindingKind.Attribute:\n          if (op.name === 'ngNonBindable') {\n            OpList.remove(op);\n            const target = lookupElement$2(elements, op.target);\n            target.nonBindable = true;\n          } else if (op.name.startsWith('animate.')) {\n            OpList.replace(op, createAnimationBindingOp(op.name, op.target, op.name === 'animate.enter' ? \"enter\" : \"leave\", op.expression, op.securityContext, op.sourceSpan, 0));\n          } else {\n            const [namespace, name] = splitNsName(op.name);\n            OpList.replace(op, createAttributeOp(op.target, namespace, name, op.expression, op.securityContext, op.isTextAttribute, op.isStructuralTemplateAttribute, op.templateKind, op.i18nMessage, op.sourceSpan));\n          }\n          break;\n        case BindingKind.Animation:\n          OpList.replace(op, createAnimationBindingOp(op.name, op.target, op.name === 'animate.enter' ? \"enter\" : \"leave\", op.expression, op.securityContext, op.sourceSpan, 1));\n          break;\n        case BindingKind.Property:\n        case BindingKind.LegacyAnimation:\n          if (job.mode === TemplateCompilationMode.DomOnly && isAriaAttribute(op.name)) {\n            OpList.replace(op, createAttributeOp(op.target, null, op.name, op.expression, op.securityContext, false, op.isStructuralTemplateAttribute, op.templateKind, op.i18nMessage, op.sourceSpan));\n          } else if (job.kind === CompilationJobKind.Host) {\n            OpList.replace(op, createDomPropertyOp(op.name, op.expression, op.bindingKind, op.i18nContext, op.securityContext, op.sourceSpan));\n          } else if (op.name === 'field') {\n            OpList.replace(op, createControlOp(op));\n          } else {\n            OpList.replace(op, createPropertyOp(op.target, op.name, op.expression, op.bindingKind, op.securityContext, op.isStructuralTemplateAttribute, op.templateKind, op.i18nContext, op.i18nMessage, op.sourceSpan));\n          }\n          break;\n        case BindingKind.TwoWayProperty:\n          if (!(op.expression instanceof Expression)) {\n            throw new Error(`Expected value of two-way property binding \"${op.name}\" to be an expression`);\n          }\n          OpList.replace(op, createTwoWayPropertyOp(op.target, op.name, op.expression, op.securityContext, op.isStructuralTemplateAttribute, op.templateKind, op.i18nContext, op.i18nMessage, op.sourceSpan));\n          break;\n        case BindingKind.I18n:\n        case BindingKind.ClassName:\n        case BindingKind.StyleProperty:\n          throw new Error(`Unhandled binding of kind ${BindingKind[op.bindingKind]}`);\n      }\n    }\n  }\n}\nconst CHAIN_COMPATIBILITY = new Map([[Identifiers.ariaProperty, Identifiers.ariaProperty], [Identifiers.attribute, Identifiers.attribute], [Identifiers.classProp, Identifiers.classProp], [Identifiers.element, Identifiers.element], [Identifiers.elementContainer, Identifiers.elementContainer], [Identifiers.elementContainerEnd, Identifiers.elementContainerEnd], [Identifiers.elementContainerStart, Identifiers.elementContainerStart], [Identifiers.elementEnd, Identifiers.elementEnd], [Identifiers.elementStart, Identifiers.elementStart], [Identifiers.domProperty, Identifiers.domProperty], [Identifiers.i18nExp, Identifiers.i18nExp], [Identifiers.listener, Identifiers.listener], [Identifiers.listener, Identifiers.listener], [Identifiers.property, Identifiers.property], [Identifiers.styleProp, Identifiers.styleProp], [Identifiers.syntheticHostListener, Identifiers.syntheticHostListener], [Identifiers.syntheticHostProperty, Identifiers.syntheticHostProperty], [Identifiers.templateCreate, Identifiers.templateCreate], [Identifiers.twoWayProperty, Identifiers.twoWayProperty], [Identifiers.twoWayListener, Identifiers.twoWayListener], [Identifiers.declareLet, Identifiers.declareLet], [Identifiers.conditionalCreate, Identifiers.conditionalBranchCreate], [Identifiers.conditionalBranchCreate, Identifiers.conditionalBranchCreate], [Identifiers.domElement, Identifiers.domElement], [Identifiers.domElementStart, Identifiers.domElementStart], [Identifiers.domElementEnd, Identifiers.domElementEnd], [Identifiers.domElementContainer, Identifiers.domElementContainer], [Identifiers.domElementContainerStart, Identifiers.domElementContainerStart], [Identifiers.domElementContainerEnd, Identifiers.domElementContainerEnd], [Identifiers.domListener, Identifiers.domListener], [Identifiers.domTemplate, Identifiers.domTemplate], [Identifiers.animationEnter, Identifiers.animationEnter], [Identifiers.animationLeave, Identifiers.animationLeave], [Identifiers.animationEnterListener, Identifiers.animationEnterListener], [Identifiers.animationLeaveListener, Identifiers.animationLeaveListener]]);\nconst MAX_CHAIN_LENGTH = 256;\nfunction chain(job) {\n  for (const unit of job.units) {\n    chainOperationsInList(unit.create);\n    chainOperationsInList(unit.update);\n  }\n}\nfunction chainOperationsInList(opList) {\n  let chain = null;\n  for (const op of opList) {\n    if (op.kind !== OpKind.Statement || !(op.statement instanceof ExpressionStatement)) {\n      chain = null;\n      continue;\n    }\n    if (!(op.statement.expr instanceof InvokeFunctionExpr) || !(op.statement.expr.fn instanceof ExternalExpr)) {\n      chain = null;\n      continue;\n    }\n    const instruction = op.statement.expr.fn.value;\n    if (!CHAIN_COMPATIBILITY.has(instruction)) {\n      chain = null;\n      continue;\n    }\n    if (chain !== null && CHAIN_COMPATIBILITY.get(chain.instruction) === instruction && chain.length < MAX_CHAIN_LENGTH) {\n      const expression = chain.expression.callFn(op.statement.expr.args, op.statement.expr.sourceSpan, op.statement.expr.pure);\n      chain.expression = expression;\n      chain.op.statement = expression.toStmt();\n      chain.length++;\n      OpList.remove(op);\n    } else {\n      chain = {\n        op,\n        instruction,\n        expression: op.statement.expr,\n        length: 1\n      };\n    }\n  }\n}\nfunction collapseSingletonInterpolations(job) {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      const eligibleOpKind = op.kind === OpKind.Attribute || op.kind === OpKind.StyleProp || op.kind == OpKind.StyleMap || op.kind === OpKind.ClassMap;\n      if (eligibleOpKind && op.expression instanceof Interpolation && op.expression.strings.length === 2 && op.expression.strings.every(s => s === '')) {\n        op.expression = op.expression.expressions[0];\n      }\n    }\n  }\n}\nfunction generateConditionalExpressions(job) {\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind !== OpKind.Conditional) {\n        continue;\n      }\n      let test;\n      const defaultCase = op.conditions.findIndex(cond => cond.expr === null);\n      if (defaultCase >= 0) {\n        const slot = op.conditions.splice(defaultCase, 1)[0].targetSlot;\n        test = new SlotLiteralExpr(slot);\n      } else {\n        test = literal(-1);\n      }\n      let tmp = op.test == null ? null : new AssignTemporaryExpr(op.test, job.allocateXrefId());\n      let caseExpressionTemporaryXref = null;\n      for (let i = op.conditions.length - 1; i >= 0; i--) {\n        let conditionalCase = op.conditions[i];\n        if (conditionalCase.expr === null) {\n          continue;\n        }\n        if (tmp !== null) {\n          const useTmp = i === 0 ? tmp : new ReadTemporaryExpr(tmp.xref);\n          conditionalCase.expr = new BinaryOperatorExpr(BinaryOperator.Identical, useTmp, conditionalCase.expr);\n        } else if (conditionalCase.alias !== null) {\n          caseExpressionTemporaryXref ??= job.allocateXrefId();\n          conditionalCase.expr = new AssignTemporaryExpr(conditionalCase.expr, caseExpressionTemporaryXref);\n          op.contextValue = new ReadTemporaryExpr(caseExpressionTemporaryXref);\n        }\n        test = new ConditionalExpr(conditionalCase.expr, new SlotLiteralExpr(conditionalCase.targetSlot), test);\n      }\n      op.processed = test;\n      op.conditions = [];\n    }\n  }\n}\nconst BINARY_OPERATORS = new Map([['&&', BinaryOperator.And], ['>', BinaryOperator.Bigger], ['>=', BinaryOperator.BiggerEquals], ['|', BinaryOperator.BitwiseOr], ['&', BinaryOperator.BitwiseAnd], ['/', BinaryOperator.Divide], ['=', BinaryOperator.Assign], ['==', BinaryOperator.Equals], ['===', BinaryOperator.Identical], ['<', BinaryOperator.Lower], ['<=', BinaryOperator.LowerEquals], ['-', BinaryOperator.Minus], ['%', BinaryOperator.Modulo], ['**', BinaryOperator.Exponentiation], ['*', BinaryOperator.Multiply], ['!=', BinaryOperator.NotEquals], ['!==', BinaryOperator.NotIdentical], ['??', BinaryOperator.NullishCoalesce], ['||', BinaryOperator.Or], ['+', BinaryOperator.Plus], ['in', BinaryOperator.In], ['+=', BinaryOperator.AdditionAssignment], ['-=', BinaryOperator.SubtractionAssignment], ['*=', BinaryOperator.MultiplicationAssignment], ['/=', BinaryOperator.DivisionAssignment], ['%=', BinaryOperator.RemainderAssignment], ['**=', BinaryOperator.ExponentiationAssignment], ['&&=', BinaryOperator.AndAssignment], ['||=', BinaryOperator.OrAssignment], ['??=', BinaryOperator.NullishCoalesceAssignment]]);\nfunction namespaceForKey(namespacePrefixKey) {\n  const NAMESPACES = new Map([['svg', Namespace.SVG], ['math', Namespace.Math]]);\n  if (namespacePrefixKey === null) {\n    return Namespace.HTML;\n  }\n  return NAMESPACES.get(namespacePrefixKey) ?? Namespace.HTML;\n}\nfunction keyForNamespace(namespace) {\n  const NAMESPACES = new Map([['svg', Namespace.SVG], ['math', Namespace.Math]]);\n  for (const [k, n] of NAMESPACES.entries()) {\n    if (n === namespace) {\n      return k;\n    }\n  }\n  return null;\n}\nfunction prefixWithNamespace(strippedTag, namespace) {\n  if (namespace === Namespace.HTML) {\n    return strippedTag;\n  }\n  return `:${keyForNamespace(namespace)}:${strippedTag}`;\n}\nfunction literalOrArrayLiteral(value) {\n  if (Array.isArray(value)) {\n    return literalArr(value.map(literalOrArrayLiteral));\n  }\n  return literal(value);\n}\nfunction collectElementConsts(job) {\n  const allElementAttributes = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.ExtractedAttribute) {\n        const attributes = allElementAttributes.get(op.target) || new ElementAttributes(job.compatibility);\n        allElementAttributes.set(op.target, attributes);\n        attributes.add(op.bindingKind, op.name, op.expression, op.namespace, op.trustedValueFn);\n        OpList.remove(op);\n      }\n    }\n  }\n  if (job instanceof ComponentCompilationJob) {\n    for (const unit of job.units) {\n      for (const op of unit.create) {\n        if (op.kind == OpKind.Projection) {\n          const attributes = allElementAttributes.get(op.xref);\n          if (attributes !== undefined) {\n            const attrArray = serializeAttributes(attributes);\n            if (attrArray.entries.length > 0) {\n              op.attributes = attrArray;\n            }\n          }\n        } else if (isElementOrContainerOp(op)) {\n          op.attributes = getConstIndex(job, allElementAttributes, op.xref);\n          if (op.kind === OpKind.RepeaterCreate && op.emptyView !== null) {\n            op.emptyAttributes = getConstIndex(job, allElementAttributes, op.emptyView);\n          }\n        }\n      }\n    }\n  } else if (job instanceof HostBindingCompilationJob) {\n    for (const [xref, attributes] of allElementAttributes.entries()) {\n      if (xref !== job.root.xref) {\n        throw new Error(`An attribute would be const collected into the host binding's template function, but is not associated with the root xref.`);\n      }\n      const attrArray = serializeAttributes(attributes);\n      if (attrArray.entries.length > 0) {\n        job.root.attributes = attrArray;\n      }\n    }\n  }\n}\nfunction getConstIndex(job, allElementAttributes, xref) {\n  const attributes = allElementAttributes.get(xref);\n  if (attributes !== undefined) {\n    const attrArray = serializeAttributes(attributes);\n    if (attrArray.entries.length > 0) {\n      return job.addConst(attrArray);\n    }\n  }\n  return null;\n}\nconst FLYWEIGHT_ARRAY = Object.freeze([]);\nclass ElementAttributes {\n  compatibility;\n  known = new Map();\n  byKind = new Map();\n  propertyBindings = null;\n  projectAs = null;\n  get attributes() {\n    return this.byKind.get(BindingKind.Attribute) ?? FLYWEIGHT_ARRAY;\n  }\n  get classes() {\n    return this.byKind.get(BindingKind.ClassName) ?? FLYWEIGHT_ARRAY;\n  }\n  get styles() {\n    return this.byKind.get(BindingKind.StyleProperty) ?? FLYWEIGHT_ARRAY;\n  }\n  get bindings() {\n    return this.propertyBindings ?? FLYWEIGHT_ARRAY;\n  }\n  get template() {\n    return this.byKind.get(BindingKind.Template) ?? FLYWEIGHT_ARRAY;\n  }\n  get i18n() {\n    return this.byKind.get(BindingKind.I18n) ?? FLYWEIGHT_ARRAY;\n  }\n  constructor(compatibility) {\n    this.compatibility = compatibility;\n  }\n  isKnown(kind, name) {\n    const nameToValue = this.known.get(kind) ?? new Set();\n    this.known.set(kind, nameToValue);\n    if (nameToValue.has(name)) {\n      return true;\n    }\n    nameToValue.add(name);\n    return false;\n  }\n  add(kind, name, value, namespace, trustedValueFn) {\n    const allowDuplicates = this.compatibility === CompatibilityMode.TemplateDefinitionBuilder && (kind === BindingKind.Attribute || kind === BindingKind.ClassName || kind === BindingKind.StyleProperty);\n    if (!allowDuplicates && this.isKnown(kind, name)) {\n      return;\n    }\n    if (name === 'ngProjectAs') {\n      if (value === null || !(value instanceof LiteralExpr) || value.value == null || typeof value.value?.toString() !== 'string') {\n        throw Error('ngProjectAs must have a string literal value');\n      }\n      this.projectAs = value.value.toString();\n    }\n    const array = this.arrayFor(kind);\n    array.push(...getAttributeNameLiterals(namespace, name));\n    if (kind === BindingKind.Attribute || kind === BindingKind.StyleProperty) {\n      if (value === null) {\n        throw Error('Attribute, i18n attribute, & style element attributes must have a value');\n      }\n      if (trustedValueFn !== null) {\n        if (!isStringLiteral(value)) {\n          throw Error('AssertionError: extracted attribute value should be string literal');\n        }\n        array.push(taggedTemplate(trustedValueFn, new TemplateLiteralExpr([new TemplateLiteralElementExpr(value.value)], []), undefined, value.sourceSpan));\n      } else {\n        array.push(value);\n      }\n    }\n  }\n  arrayFor(kind) {\n    if (kind === BindingKind.Property || kind === BindingKind.TwoWayProperty) {\n      this.propertyBindings ??= [];\n      return this.propertyBindings;\n    } else {\n      if (!this.byKind.has(kind)) {\n        this.byKind.set(kind, []);\n      }\n      return this.byKind.get(kind);\n    }\n  }\n}\nfunction getAttributeNameLiterals(namespace, name) {\n  const nameLiteral = literal(name);\n  if (namespace) {\n    return [literal(0), literal(namespace), nameLiteral];\n  }\n  return [nameLiteral];\n}\nfunction serializeAttributes({\n  attributes,\n  bindings,\n  classes,\n  i18n,\n  projectAs,\n  styles,\n  template\n}) {\n  const attrArray = [...attributes];\n  if (projectAs !== null) {\n    const parsedR3Selector = parseSelectorToR3Selector(projectAs)[0];\n    attrArray.push(literal(5), literalOrArrayLiteral(parsedR3Selector));\n  }\n  if (classes.length > 0) {\n    attrArray.push(literal(1), ...classes);\n  }\n  if (styles.length > 0) {\n    attrArray.push(literal(2), ...styles);\n  }\n  if (bindings.length > 0) {\n    attrArray.push(literal(3), ...bindings);\n  }\n  if (template.length > 0) {\n    attrArray.push(literal(4), ...template);\n  }\n  if (i18n.length > 0) {\n    attrArray.push(literal(6), ...i18n);\n  }\n  return literalArr(attrArray);\n}\nfunction lookupElement$1(elements, xref) {\n  const el = elements.get(xref);\n  if (el === undefined) {\n    throw new Error('All attributes should have an element-like target.');\n  }\n  return el;\n}\nfunction convertAnimations(job) {\n  const elements = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (!isElementOrContainerOp(op)) {\n        continue;\n      }\n      elements.set(op.xref, op);\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind === OpKind.AnimationBinding) {\n        const createAnimationOp = getAnimationOp(op);\n        if (job.kind === CompilationJobKind.Host) {\n          unit.create.push(createAnimationOp);\n        } else {\n          OpList.insertAfter(createAnimationOp, lookupElement$1(elements, op.target));\n        }\n        OpList.remove(op);\n      }\n    }\n  }\n}\nfunction getAnimationOp(op) {\n  if (op.animationBindingKind === 0) {\n    return createAnimationStringOp(op.name, op.target, op.name === 'animate.enter' ? \"enter\" : \"leave\", op.expression, op.securityContext, op.sourceSpan);\n  } else {\n    const expression = op.expression;\n    return createAnimationOp(op.name, op.target, op.name === 'animate.enter' ? \"enter\" : \"leave\", [createStatementOp(new ReturnStatement(expression, expression.sourceSpan))], op.securityContext, op.sourceSpan);\n  }\n}\nfunction convertI18nBindings(job) {\n  const i18nAttributesByElem = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.I18nAttributes) {\n        i18nAttributesByElem.set(op.target, op);\n      }\n    }\n    for (const op of unit.update) {\n      switch (op.kind) {\n        case OpKind.Property:\n        case OpKind.Attribute:\n          if (op.i18nContext === null) {\n            continue;\n          }\n          if (!(op.expression instanceof Interpolation)) {\n            continue;\n          }\n          const i18nAttributesForElem = i18nAttributesByElem.get(op.target);\n          if (i18nAttributesForElem === undefined) {\n            throw new Error('AssertionError: An i18n attribute binding instruction requires the owning element to have an I18nAttributes create instruction');\n          }\n          if (i18nAttributesForElem.target !== op.target) {\n            throw new Error('AssertionError: Expected i18nAttributes target element to match binding target element');\n          }\n          const ops = [];\n          for (let i = 0; i < op.expression.expressions.length; i++) {\n            const expr = op.expression.expressions[i];\n            if (op.expression.i18nPlaceholders.length !== op.expression.expressions.length) {\n              throw new Error(`AssertionError: An i18n attribute binding instruction requires the same number of expressions and placeholders, but found ${op.expression.i18nPlaceholders.length} placeholders and ${op.expression.expressions.length} expressions`);\n            }\n            ops.push(createI18nExpressionOp(op.i18nContext, i18nAttributesForElem.target, i18nAttributesForElem.xref, i18nAttributesForElem.handle, expr, null, op.expression.i18nPlaceholders[i], I18nParamResolutionTime.Creation, I18nExpressionFor.I18nAttribute, op.name, op.sourceSpan));\n          }\n          OpList.replaceWithMany(op, ops);\n          break;\n      }\n    }\n  }\n}\nfunction createI18nContexts(job) {\n  const attrContextByMessage = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      switch (op.kind) {\n        case OpKind.Binding:\n        case OpKind.Property:\n        case OpKind.Attribute:\n        case OpKind.ExtractedAttribute:\n          if (op.i18nMessage === null) {\n            continue;\n          }\n          if (!attrContextByMessage.has(op.i18nMessage)) {\n            const i18nContext = createI18nContextOp(I18nContextKind.Attr, job.allocateXrefId(), null, op.i18nMessage, null);\n            unit.create.push(i18nContext);\n            attrContextByMessage.set(op.i18nMessage, i18nContext.xref);\n          }\n          op.i18nContext = attrContextByMessage.get(op.i18nMessage);\n          break;\n      }\n    }\n  }\n  const blockContextByI18nBlock = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nStart:\n          if (op.xref === op.root) {\n            const contextOp = createI18nContextOp(I18nContextKind.RootI18n, job.allocateXrefId(), op.xref, op.message, null);\n            unit.create.push(contextOp);\n            op.context = contextOp.xref;\n            blockContextByI18nBlock.set(op.xref, contextOp);\n          }\n          break;\n      }\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.I18nStart && op.xref !== op.root) {\n        const rootContext = blockContextByI18nBlock.get(op.root);\n        if (rootContext === undefined) {\n          throw Error('AssertionError: Root i18n block i18n context should have been created.');\n        }\n        op.context = rootContext.xref;\n        blockContextByI18nBlock.set(op.xref, rootContext);\n      }\n    }\n  }\n  let currentI18nOp = null;\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nStart:\n          currentI18nOp = op;\n          break;\n        case OpKind.I18nEnd:\n          currentI18nOp = null;\n          break;\n        case OpKind.IcuStart:\n          if (currentI18nOp === null) {\n            throw Error('AssertionError: Unexpected ICU outside of an i18n block.');\n          }\n          if (op.message.id !== currentI18nOp.message.id) {\n            const contextOp = createI18nContextOp(I18nContextKind.Icu, job.allocateXrefId(), currentI18nOp.root, op.message, null);\n            unit.create.push(contextOp);\n            op.context = contextOp.xref;\n          } else {\n            op.context = currentI18nOp.context;\n            blockContextByI18nBlock.get(currentI18nOp.xref).contextKind = I18nContextKind.Icu;\n          }\n          break;\n      }\n    }\n  }\n}\nfunction deduplicateTextBindings(job) {\n  const seen = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.update.reversed()) {\n      if (op.kind === OpKind.Binding && op.isTextAttribute) {\n        const seenForElement = seen.get(op.target) || new Set();\n        if (seenForElement.has(op.name)) {\n          if (job.compatibility === CompatibilityMode.TemplateDefinitionBuilder) {\n            if (op.name === 'style' || op.name === 'class') {\n              OpList.remove(op);\n            }\n          }\n        }\n        seenForElement.add(op.name);\n        seen.set(op.target, seenForElement);\n      }\n    }\n  }\n}\nfunction configureDeferInstructions(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind !== OpKind.Defer) {\n        continue;\n      }\n      if (op.placeholderMinimumTime !== null) {\n        op.placeholderConfig = new ConstCollectedExpr(literalOrArrayLiteral([op.placeholderMinimumTime]));\n      }\n      if (op.loadingMinimumTime !== null || op.loadingAfterTime !== null) {\n        op.loadingConfig = new ConstCollectedExpr(literalOrArrayLiteral([op.loadingMinimumTime, op.loadingAfterTime]));\n      }\n    }\n  }\n}\nfunction resolveDeferTargetNames(job) {\n  const scopes = new Map();\n  function getScopeForView(view) {\n    if (scopes.has(view.xref)) {\n      return scopes.get(view.xref);\n    }\n    const scope = new Scope$1();\n    for (const op of view.create) {\n      if (!isElementOrContainerOp(op) || op.localRefs === null) {\n        continue;\n      }\n      if (!Array.isArray(op.localRefs)) {\n        throw new Error('LocalRefs were already processed, but were needed to resolve defer targets.');\n      }\n      for (const ref of op.localRefs) {\n        if (ref.target !== '') {\n          continue;\n        }\n        scope.targets.set(ref.name, {\n          xref: op.xref,\n          slot: op.handle\n        });\n      }\n    }\n    scopes.set(view.xref, scope);\n    return scope;\n  }\n  function resolveTrigger(deferOwnerView, op, placeholderView) {\n    switch (op.trigger.kind) {\n      case DeferTriggerKind.Idle:\n      case DeferTriggerKind.Never:\n      case DeferTriggerKind.Immediate:\n      case DeferTriggerKind.Timer:\n        return;\n      case DeferTriggerKind.Hover:\n      case DeferTriggerKind.Interaction:\n      case DeferTriggerKind.Viewport:\n        if (op.trigger.targetName === null) {\n          if (placeholderView === null) {\n            throw new Error('defer on trigger with no target name must have a placeholder block');\n          }\n          const placeholder = job.views.get(placeholderView);\n          if (placeholder == undefined) {\n            throw new Error('AssertionError: could not find placeholder view for defer on trigger');\n          }\n          for (const placeholderOp of placeholder.create) {\n            if (hasConsumesSlotTrait(placeholderOp) && (isElementOrContainerOp(placeholderOp) || placeholderOp.kind === OpKind.Projection)) {\n              op.trigger.targetXref = placeholderOp.xref;\n              op.trigger.targetView = placeholderView;\n              op.trigger.targetSlotViewSteps = -1;\n              op.trigger.targetSlot = placeholderOp.handle;\n              return;\n            }\n          }\n          return;\n        }\n        let view = placeholderView !== null ? job.views.get(placeholderView) : deferOwnerView;\n        let step = placeholderView !== null ? -1 : 0;\n        while (view !== null) {\n          const scope = getScopeForView(view);\n          if (scope.targets.has(op.trigger.targetName)) {\n            const {\n              xref,\n              slot\n            } = scope.targets.get(op.trigger.targetName);\n            op.trigger.targetXref = xref;\n            op.trigger.targetView = view.xref;\n            op.trigger.targetSlotViewSteps = step;\n            op.trigger.targetSlot = slot;\n            return;\n          }\n          view = view.parent !== null ? job.views.get(view.parent) : null;\n          step++;\n        }\n        break;\n      default:\n        throw new Error(`Trigger kind ${op.trigger.kind} not handled`);\n    }\n  }\n  for (const unit of job.units) {\n    const defers = new Map();\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.Defer:\n          defers.set(op.xref, op);\n          break;\n        case OpKind.DeferOn:\n          const deferOp = defers.get(op.defer);\n          resolveTrigger(unit, op, op.modifier === \"hydrate\" ? deferOp.mainView : deferOp.placeholderView);\n          break;\n      }\n    }\n  }\n}\nlet Scope$1 = class Scope {\n  targets = new Map();\n};\nconst REPLACEMENTS = new Map([[OpKind.ElementEnd, [OpKind.ElementStart, OpKind.Element]], [OpKind.ContainerEnd, [OpKind.ContainerStart, OpKind.Container]], [OpKind.I18nEnd, [OpKind.I18nStart, OpKind.I18n]]]);\nconst IGNORED_OP_KINDS = new Set([OpKind.Pipe]);\nfunction collapseEmptyInstructions(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      const opReplacements = REPLACEMENTS.get(op.kind);\n      if (opReplacements === undefined) {\n        continue;\n      }\n      const [startKind, mergedKind] = opReplacements;\n      let prevOp = op.prev;\n      while (prevOp !== null && IGNORED_OP_KINDS.has(prevOp.kind)) {\n        prevOp = prevOp.prev;\n      }\n      if (prevOp !== null && prevOp.kind === startKind) {\n        prevOp.kind = mergedKind;\n        OpList.remove(op);\n      }\n    }\n  }\n}\nfunction expandSafeReads(job) {\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      transformExpressionsInOp(op, e => safeTransform(e, {\n        job\n      }), VisitorContextFlag.None);\n      transformExpressionsInOp(op, ternaryTransform, VisitorContextFlag.None);\n    }\n  }\n}\nfunction needsTemporaryInSafeAccess(e) {\n  if (e instanceof UnaryOperatorExpr) {\n    return needsTemporaryInSafeAccess(e.expr);\n  } else if (e instanceof BinaryOperatorExpr) {\n    return needsTemporaryInSafeAccess(e.lhs) || needsTemporaryInSafeAccess(e.rhs);\n  } else if (e instanceof ConditionalExpr) {\n    if (e.falseCase && needsTemporaryInSafeAccess(e.falseCase)) return true;\n    return needsTemporaryInSafeAccess(e.condition) || needsTemporaryInSafeAccess(e.trueCase);\n  } else if (e instanceof NotExpr) {\n    return needsTemporaryInSafeAccess(e.condition);\n  } else if (e instanceof AssignTemporaryExpr) {\n    return needsTemporaryInSafeAccess(e.expr);\n  } else if (e instanceof ReadPropExpr) {\n    return needsTemporaryInSafeAccess(e.receiver);\n  } else if (e instanceof ReadKeyExpr) {\n    return needsTemporaryInSafeAccess(e.receiver) || needsTemporaryInSafeAccess(e.index);\n  } else if (e instanceof ParenthesizedExpr) {\n    return needsTemporaryInSafeAccess(e.expr);\n  }\n  return e instanceof InvokeFunctionExpr || e instanceof LiteralArrayExpr || e instanceof LiteralMapExpr || e instanceof SafeInvokeFunctionExpr || e instanceof PipeBindingExpr;\n}\nfunction temporariesIn(e) {\n  const temporaries = new Set();\n  transformExpressionsInExpression(e, e => {\n    if (e instanceof AssignTemporaryExpr) {\n      temporaries.add(e.xref);\n    }\n    return e;\n  }, VisitorContextFlag.None);\n  return temporaries;\n}\nfunction eliminateTemporaryAssignments(e, tmps, ctx) {\n  transformExpressionsInExpression(e, e => {\n    if (e instanceof AssignTemporaryExpr && tmps.has(e.xref)) {\n      const read = new ReadTemporaryExpr(e.xref);\n      return ctx.job.compatibility === CompatibilityMode.TemplateDefinitionBuilder ? new AssignTemporaryExpr(read, read.xref) : read;\n    }\n    return e;\n  }, VisitorContextFlag.None);\n  return e;\n}\nfunction safeTernaryWithTemporary(guard, body, ctx) {\n  let result;\n  if (needsTemporaryInSafeAccess(guard)) {\n    const xref = ctx.job.allocateXrefId();\n    result = [new AssignTemporaryExpr(guard, xref), new ReadTemporaryExpr(xref)];\n  } else {\n    result = [guard, guard.clone()];\n    eliminateTemporaryAssignments(result[1], temporariesIn(result[0]), ctx);\n  }\n  return new SafeTernaryExpr(result[0], body(result[1]));\n}\nfunction isSafeAccessExpression(e) {\n  return e instanceof SafePropertyReadExpr || e instanceof SafeKeyedReadExpr || e instanceof SafeInvokeFunctionExpr;\n}\nfunction isUnsafeAccessExpression(e) {\n  return e instanceof ReadPropExpr || e instanceof ReadKeyExpr || e instanceof InvokeFunctionExpr;\n}\nfunction isAccessExpression(e) {\n  return isSafeAccessExpression(e) || isUnsafeAccessExpression(e);\n}\nfunction deepestSafeTernary(e) {\n  if (isAccessExpression(e) && e.receiver instanceof SafeTernaryExpr) {\n    let st = e.receiver;\n    while (st.expr instanceof SafeTernaryExpr) {\n      st = st.expr;\n    }\n    return st;\n  }\n  return null;\n}\nfunction safeTransform(e, ctx) {\n  if (!isAccessExpression(e)) {\n    return e;\n  }\n  const dst = deepestSafeTernary(e);\n  if (dst) {\n    if (e instanceof InvokeFunctionExpr) {\n      dst.expr = dst.expr.callFn(e.args);\n      return e.receiver;\n    }\n    if (e instanceof ReadPropExpr) {\n      dst.expr = dst.expr.prop(e.name);\n      return e.receiver;\n    }\n    if (e instanceof ReadKeyExpr) {\n      dst.expr = dst.expr.key(e.index);\n      return e.receiver;\n    }\n    if (e instanceof SafeInvokeFunctionExpr) {\n      dst.expr = safeTernaryWithTemporary(dst.expr, r => r.callFn(e.args), ctx);\n      return e.receiver;\n    }\n    if (e instanceof SafePropertyReadExpr) {\n      dst.expr = safeTernaryWithTemporary(dst.expr, r => r.prop(e.name), ctx);\n      return e.receiver;\n    }\n    if (e instanceof SafeKeyedReadExpr) {\n      dst.expr = safeTernaryWithTemporary(dst.expr, r => r.key(e.index), ctx);\n      return e.receiver;\n    }\n  } else {\n    if (e instanceof SafeInvokeFunctionExpr) {\n      return safeTernaryWithTemporary(e.receiver, r => r.callFn(e.args), ctx);\n    }\n    if (e instanceof SafePropertyReadExpr) {\n      return safeTernaryWithTemporary(e.receiver, r => r.prop(e.name), ctx);\n    }\n    if (e instanceof SafeKeyedReadExpr) {\n      return safeTernaryWithTemporary(e.receiver, r => r.key(e.index), ctx);\n    }\n  }\n  return e;\n}\nfunction ternaryTransform(e) {\n  if (!(e instanceof SafeTernaryExpr)) {\n    return e;\n  }\n  return new ParenthesizedExpr(new ConditionalExpr(new BinaryOperatorExpr(BinaryOperator.Equals, e.guard, NULL_EXPR), NULL_EXPR, e.expr));\n}\nconst ESCAPE$1 = '\\uFFFD';\nconst ELEMENT_MARKER = '#';\nconst TEMPLATE_MARKER = '*';\nconst TAG_CLOSE_MARKER = '/';\nconst CONTEXT_MARKER = ':';\nconst LIST_START_MARKER = '[';\nconst LIST_END_MARKER = ']';\nconst LIST_DELIMITER = '|';\nfunction extractI18nMessages(job) {\n  const i18nMessagesByContext = new Map();\n  const i18nBlocks = new Map();\n  const i18nContexts = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nContext:\n          const i18nMessageOp = createI18nMessage(job, op);\n          unit.create.push(i18nMessageOp);\n          i18nMessagesByContext.set(op.xref, i18nMessageOp);\n          i18nContexts.set(op.xref, op);\n          break;\n        case OpKind.I18nStart:\n          i18nBlocks.set(op.xref, op);\n          break;\n      }\n    }\n  }\n  let currentIcu = null;\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.IcuStart:\n          currentIcu = op;\n          OpList.remove(op);\n          const icuContext = i18nContexts.get(op.context);\n          if (icuContext.contextKind !== I18nContextKind.Icu) {\n            continue;\n          }\n          const i18nBlock = i18nBlocks.get(icuContext.i18nBlock);\n          if (i18nBlock.context === icuContext.xref) {\n            continue;\n          }\n          const rootI18nBlock = i18nBlocks.get(i18nBlock.root);\n          const rootMessage = i18nMessagesByContext.get(rootI18nBlock.context);\n          if (rootMessage === undefined) {\n            throw Error('AssertionError: ICU sub-message should belong to a root message.');\n          }\n          const subMessage = i18nMessagesByContext.get(icuContext.xref);\n          subMessage.messagePlaceholder = op.messagePlaceholder;\n          rootMessage.subMessages.push(subMessage.xref);\n          break;\n        case OpKind.IcuEnd:\n          currentIcu = null;\n          OpList.remove(op);\n          break;\n        case OpKind.IcuPlaceholder:\n          if (currentIcu === null || currentIcu.context == null) {\n            throw Error('AssertionError: Unexpected ICU placeholder outside of i18n context');\n          }\n          const msg = i18nMessagesByContext.get(currentIcu.context);\n          msg.postprocessingParams.set(op.name, literal(formatIcuPlaceholder(op)));\n          OpList.remove(op);\n          break;\n      }\n    }\n  }\n}\nfunction createI18nMessage(job, context, messagePlaceholder) {\n  let formattedParams = formatParams(context.params);\n  const formattedPostprocessingParams = formatParams(context.postprocessingParams);\n  let needsPostprocessing = [...context.params.values()].some(v => v.length > 1);\n  return createI18nMessageOp(job.allocateXrefId(), context.xref, context.i18nBlock, context.message, null, formattedParams, formattedPostprocessingParams, needsPostprocessing);\n}\nfunction formatIcuPlaceholder(op) {\n  if (op.strings.length !== op.expressionPlaceholders.length + 1) {\n    throw Error(`AssertionError: Invalid ICU placeholder with ${op.strings.length} strings and ${op.expressionPlaceholders.length} expressions`);\n  }\n  const values = op.expressionPlaceholders.map(formatValue);\n  return op.strings.flatMap((str, i) => [str, values[i] || '']).join('');\n}\nfunction formatParams(params) {\n  const formattedParams = new Map();\n  for (const [placeholder, placeholderValues] of params) {\n    const serializedValues = formatParamValues(placeholderValues);\n    if (serializedValues !== null) {\n      formattedParams.set(placeholder, literal(serializedValues));\n    }\n  }\n  return formattedParams;\n}\nfunction formatParamValues(values) {\n  if (values.length === 0) {\n    return null;\n  }\n  const serializedValues = values.map(value => formatValue(value));\n  return serializedValues.length === 1 ? serializedValues[0] : `${LIST_START_MARKER}${serializedValues.join(LIST_DELIMITER)}${LIST_END_MARKER}`;\n}\nfunction formatValue(value) {\n  if (value.flags & I18nParamValueFlags.ElementTag && value.flags & I18nParamValueFlags.TemplateTag) {\n    if (typeof value.value !== 'object') {\n      throw Error('AssertionError: Expected i18n param value to have an element and template slot');\n    }\n    const elementValue = formatValue({\n      ...value,\n      value: value.value.element,\n      flags: value.flags & ~I18nParamValueFlags.TemplateTag\n    });\n    const templateValue = formatValue({\n      ...value,\n      value: value.value.template,\n      flags: value.flags & ~I18nParamValueFlags.ElementTag\n    });\n    if (value.flags & I18nParamValueFlags.OpenTag && value.flags & I18nParamValueFlags.CloseTag) {\n      return `${templateValue}${elementValue}${templateValue}`;\n    }\n    return value.flags & I18nParamValueFlags.CloseTag ? `${elementValue}${templateValue}` : `${templateValue}${elementValue}`;\n  }\n  if (value.flags & I18nParamValueFlags.OpenTag && value.flags & I18nParamValueFlags.CloseTag) {\n    return `${formatValue({\n      ...value,\n      flags: value.flags & ~I18nParamValueFlags.CloseTag\n    })}${formatValue({\n      ...value,\n      flags: value.flags & ~I18nParamValueFlags.OpenTag\n    })}`;\n  }\n  if (value.flags === I18nParamValueFlags.None) {\n    return `${value.value}`;\n  }\n  let tagMarker = '';\n  let closeMarker = '';\n  if (value.flags & I18nParamValueFlags.ElementTag) {\n    tagMarker = ELEMENT_MARKER;\n  } else if (value.flags & I18nParamValueFlags.TemplateTag) {\n    tagMarker = TEMPLATE_MARKER;\n  }\n  if (tagMarker !== '') {\n    closeMarker = value.flags & I18nParamValueFlags.CloseTag ? TAG_CLOSE_MARKER : '';\n  }\n  const context = value.subTemplateIndex === null ? '' : `${CONTEXT_MARKER}${value.subTemplateIndex}`;\n  return `${ESCAPE$1}${closeMarker}${tagMarker}${value.value}${context}${ESCAPE$1}`;\n}\nfunction generateAdvance(job) {\n  for (const unit of job.units) {\n    const slotMap = new Map();\n    for (const op of unit.create) {\n      if (!hasConsumesSlotTrait(op)) {\n        continue;\n      } else if (op.handle.slot === null) {\n        throw new Error(`AssertionError: expected slots to have been allocated before generating advance() calls`);\n      }\n      slotMap.set(op.xref, op.handle.slot);\n    }\n    let slotContext = 0;\n    for (const op of unit.update) {\n      let consumer = null;\n      if (hasDependsOnSlotContextTrait(op)) {\n        consumer = op;\n      } else {\n        visitExpressionsInOp(op, expr => {\n          if (consumer === null && hasDependsOnSlotContextTrait(expr)) {\n            consumer = expr;\n          }\n        });\n      }\n      if (consumer === null) {\n        continue;\n      }\n      if (!slotMap.has(consumer.target)) {\n        throw new Error(`AssertionError: reference to unknown slot for target ${consumer.target}`);\n      }\n      const slot = slotMap.get(consumer.target);\n      if (slotContext !== slot) {\n        const delta = slot - slotContext;\n        if (delta < 0) {\n          throw new Error(`AssertionError: slot counter should never need to move backwards`);\n        }\n        OpList.insertBefore(createAdvanceOp(delta, consumer.sourceSpan), op);\n        slotContext = slot;\n      }\n    }\n  }\n}\nfunction generateLocalLetReferences(job) {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      if (op.kind !== OpKind.StoreLet) {\n        continue;\n      }\n      const variable = {\n        kind: SemanticVariableKind.Identifier,\n        name: null,\n        identifier: op.declaredName,\n        local: true\n      };\n      OpList.replace(op, createVariableOp(job.allocateXrefId(), variable, new StoreLetExpr(op.target, op.value, op.sourceSpan), VariableFlags.None));\n    }\n  }\n}\nfunction generateProjectionDefs(job) {\n  const share = job.compatibility === CompatibilityMode.TemplateDefinitionBuilder;\n  const selectors = [];\n  let projectionSlotIndex = 0;\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.Projection) {\n        selectors.push(op.selector);\n        op.projectionSlotIndex = projectionSlotIndex++;\n      }\n    }\n  }\n  if (selectors.length > 0) {\n    let defExpr = null;\n    if (selectors.length > 1 || selectors[0] !== '*') {\n      const def = selectors.map(s => s === '*' ? s : parseSelectorToR3Selector(s));\n      defExpr = job.pool.getConstLiteral(literalOrArrayLiteral(def), share);\n    }\n    job.contentSelectors = job.pool.getConstLiteral(literalOrArrayLiteral(selectors), share);\n    job.root.create.prepend([createProjectionDefOp(defExpr)]);\n  }\n}\nfunction generateVariables(job) {\n  recursivelyProcessView(job.root, null);\n}\nfunction recursivelyProcessView(view, parentScope) {\n  const scope = getScopeForView(view, parentScope);\n  for (const op of view.create) {\n    switch (op.kind) {\n      case OpKind.ConditionalCreate:\n      case OpKind.ConditionalBranchCreate:\n      case OpKind.Template:\n        recursivelyProcessView(view.job.views.get(op.xref), scope);\n        break;\n      case OpKind.Projection:\n        if (op.fallbackView !== null) {\n          recursivelyProcessView(view.job.views.get(op.fallbackView), scope);\n        }\n        break;\n      case OpKind.RepeaterCreate:\n        recursivelyProcessView(view.job.views.get(op.xref), scope);\n        if (op.emptyView) {\n          recursivelyProcessView(view.job.views.get(op.emptyView), scope);\n        }\n        if (op.trackByOps !== null) {\n          op.trackByOps.prepend(generateVariablesInScopeForView(view, scope, false));\n        }\n        break;\n      case OpKind.Animation:\n      case OpKind.AnimationListener:\n      case OpKind.Listener:\n      case OpKind.TwoWayListener:\n        op.handlerOps.prepend(generateVariablesInScopeForView(view, scope, true));\n        break;\n    }\n  }\n  view.update.prepend(generateVariablesInScopeForView(view, scope, false));\n}\nfunction getScopeForView(view, parent) {\n  const scope = {\n    view: view.xref,\n    viewContextVariable: {\n      kind: SemanticVariableKind.Context,\n      name: null,\n      view: view.xref\n    },\n    contextVariables: new Map(),\n    aliases: view.aliases,\n    references: [],\n    letDeclarations: [],\n    parent\n  };\n  for (const identifier of view.contextVariables.keys()) {\n    scope.contextVariables.set(identifier, {\n      kind: SemanticVariableKind.Identifier,\n      name: null,\n      identifier,\n      local: false\n    });\n  }\n  for (const op of view.create) {\n    switch (op.kind) {\n      case OpKind.ElementStart:\n      case OpKind.ConditionalCreate:\n      case OpKind.ConditionalBranchCreate:\n      case OpKind.Template:\n        if (!Array.isArray(op.localRefs)) {\n          throw new Error(`AssertionError: expected localRefs to be an array`);\n        }\n        for (let offset = 0; offset < op.localRefs.length; offset++) {\n          scope.references.push({\n            name: op.localRefs[offset].name,\n            targetId: op.xref,\n            targetSlot: op.handle,\n            offset,\n            variable: {\n              kind: SemanticVariableKind.Identifier,\n              name: null,\n              identifier: op.localRefs[offset].name,\n              local: false\n            }\n          });\n        }\n        break;\n      case OpKind.DeclareLet:\n        scope.letDeclarations.push({\n          targetId: op.xref,\n          targetSlot: op.handle,\n          variable: {\n            kind: SemanticVariableKind.Identifier,\n            name: null,\n            identifier: op.declaredName,\n            local: false\n          }\n        });\n        break;\n    }\n  }\n  return scope;\n}\nfunction generateVariablesInScopeForView(view, scope, isCallback) {\n  const newOps = [];\n  if (scope.view !== view.xref) {\n    newOps.push(createVariableOp(view.job.allocateXrefId(), scope.viewContextVariable, new NextContextExpr(), VariableFlags.None));\n  }\n  const scopeView = view.job.views.get(scope.view);\n  for (const [name, value] of scopeView.contextVariables) {\n    const context = new ContextExpr(scope.view);\n    const variable = value === CTX_REF ? context : new ReadPropExpr(context, value);\n    newOps.push(createVariableOp(view.job.allocateXrefId(), scope.contextVariables.get(name), variable, VariableFlags.None));\n  }\n  for (const alias of scopeView.aliases) {\n    newOps.push(createVariableOp(view.job.allocateXrefId(), alias, alias.expression.clone(), VariableFlags.AlwaysInline));\n  }\n  for (const ref of scope.references) {\n    newOps.push(createVariableOp(view.job.allocateXrefId(), ref.variable, new ReferenceExpr(ref.targetId, ref.targetSlot, ref.offset), VariableFlags.None));\n  }\n  if (scope.view !== view.xref || isCallback) {\n    for (const decl of scope.letDeclarations) {\n      newOps.push(createVariableOp(view.job.allocateXrefId(), decl.variable, new ContextLetReferenceExpr(decl.targetId, decl.targetSlot), VariableFlags.None));\n    }\n  }\n  if (scope.parent !== null) {\n    newOps.push(...generateVariablesInScopeForView(view, scope.parent, false));\n  }\n  return newOps;\n}\nfunction collectConstExpressions(job) {\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      transformExpressionsInOp(op, expr => {\n        if (!(expr instanceof ConstCollectedExpr)) {\n          return expr;\n        }\n        return literal(job.addConst(expr.expr));\n      }, VisitorContextFlag.None);\n    }\n  }\n}\nconst STYLE_DOT = 'style.';\nconst CLASS_DOT = 'class.';\nconst STYLE_BANG = 'style!';\nconst CLASS_BANG = 'class!';\nconst BANG_IMPORTANT = '!important';\nfunction parseHostStyleProperties(job) {\n  for (const op of job.root.update) {\n    if (!(op.kind === OpKind.Binding && op.bindingKind === BindingKind.Property)) {\n      continue;\n    }\n    if (op.name.endsWith(BANG_IMPORTANT)) {\n      op.name = op.name.substring(0, op.name.length - BANG_IMPORTANT.length);\n    }\n    if (op.name.startsWith(STYLE_DOT)) {\n      op.bindingKind = BindingKind.StyleProperty;\n      op.name = op.name.substring(STYLE_DOT.length);\n      if (!isCssCustomProperty(op.name)) {\n        op.name = hyphenate$1(op.name);\n      }\n      const {\n        property,\n        suffix\n      } = parseProperty(op.name);\n      op.name = property;\n      op.unit = suffix;\n    } else if (op.name.startsWith(STYLE_BANG)) {\n      op.bindingKind = BindingKind.StyleProperty;\n      op.name = 'style';\n    } else if (op.name.startsWith(CLASS_DOT)) {\n      op.bindingKind = BindingKind.ClassName;\n      op.name = parseProperty(op.name.substring(CLASS_DOT.length)).property;\n    } else if (op.name.startsWith(CLASS_BANG)) {\n      op.bindingKind = BindingKind.ClassName;\n      op.name = parseProperty(op.name.substring(CLASS_BANG.length)).property;\n    }\n  }\n}\nfunction isCssCustomProperty(name) {\n  return name.startsWith('--');\n}\nfunction hyphenate$1(value) {\n  return value.replace(/[a-z][A-Z]/g, v => {\n    return v.charAt(0) + '-' + v.charAt(1);\n  }).toLowerCase();\n}\nfunction parseProperty(name) {\n  const overrideIndex = name.indexOf('!important');\n  if (overrideIndex !== -1) {\n    name = overrideIndex > 0 ? name.substring(0, overrideIndex) : '';\n  }\n  let suffix = null;\n  let property = name;\n  const unitIndex = name.lastIndexOf('.');\n  if (unitIndex > 0) {\n    suffix = name.slice(unitIndex + 1);\n    property = name.substring(0, unitIndex);\n  }\n  return {\n    property,\n    suffix\n  };\n}\nfunction mapLiteral(obj, quoted = false) {\n  return literalMap(Object.keys(obj).map(key => ({\n    key,\n    quoted,\n    value: obj[key]\n  })));\n}\nclass IcuSerializerVisitor {\n  visitText(text) {\n    return text.value;\n  }\n  visitContainer(container) {\n    return container.children.map(child => child.visit(this)).join('');\n  }\n  visitIcu(icu) {\n    const strCases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n    const result = `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;\n    return result;\n  }\n  visitTagPlaceholder(ph) {\n    return ph.isVoid ? this.formatPh(ph.startName) : `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;\n  }\n  visitPlaceholder(ph) {\n    return this.formatPh(ph.name);\n  }\n  visitBlockPlaceholder(ph) {\n    return `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;\n  }\n  visitIcuPlaceholder(ph, context) {\n    return this.formatPh(ph.name);\n  }\n  formatPh(value) {\n    return `{${formatI18nPlaceholderName(value, false)}}`;\n  }\n}\nconst serializer = new IcuSerializerVisitor();\nfunction serializeIcuNode(icu) {\n  return icu.visit(serializer);\n}\nclass NodeWithI18n {\n  sourceSpan;\n  i18n;\n  constructor(sourceSpan, i18n) {\n    this.sourceSpan = sourceSpan;\n    this.i18n = i18n;\n  }\n}\nclass Text extends NodeWithI18n {\n  value;\n  tokens;\n  constructor(value, sourceSpan, tokens, i18n) {\n    super(sourceSpan, i18n);\n    this.value = value;\n    this.tokens = tokens;\n  }\n  visit(visitor, context) {\n    return visitor.visitText(this, context);\n  }\n}\nclass Expansion extends NodeWithI18n {\n  switchValue;\n  type;\n  cases;\n  switchValueSourceSpan;\n  constructor(switchValue, type, cases, sourceSpan, switchValueSourceSpan, i18n) {\n    super(sourceSpan, i18n);\n    this.switchValue = switchValue;\n    this.type = type;\n    this.cases = cases;\n    this.switchValueSourceSpan = switchValueSourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitExpansion(this, context);\n  }\n}\nclass ExpansionCase {\n  value;\n  expression;\n  sourceSpan;\n  valueSourceSpan;\n  expSourceSpan;\n  constructor(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {\n    this.value = value;\n    this.expression = expression;\n    this.sourceSpan = sourceSpan;\n    this.valueSourceSpan = valueSourceSpan;\n    this.expSourceSpan = expSourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitExpansionCase(this, context);\n  }\n}\nclass Attribute extends NodeWithI18n {\n  name;\n  value;\n  keySpan;\n  valueSpan;\n  valueTokens;\n  constructor(name, value, sourceSpan, keySpan, valueSpan, valueTokens, i18n) {\n    super(sourceSpan, i18n);\n    this.name = name;\n    this.value = value;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n    this.valueTokens = valueTokens;\n  }\n  visit(visitor, context) {\n    return visitor.visitAttribute(this, context);\n  }\n}\nclass Element extends NodeWithI18n {\n  name;\n  attrs;\n  directives;\n  children;\n  isSelfClosing;\n  startSourceSpan;\n  endSourceSpan;\n  isVoid;\n  constructor(name, attrs, directives, children, isSelfClosing, sourceSpan, startSourceSpan, endSourceSpan = null, isVoid, i18n) {\n    super(sourceSpan, i18n);\n    this.name = name;\n    this.attrs = attrs;\n    this.directives = directives;\n    this.children = children;\n    this.isSelfClosing = isSelfClosing;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n    this.isVoid = isVoid;\n  }\n  visit(visitor, context) {\n    return visitor.visitElement(this, context);\n  }\n}\nclass Comment {\n  value;\n  sourceSpan;\n  constructor(value, sourceSpan) {\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitComment(this, context);\n  }\n}\nclass Block extends NodeWithI18n {\n  name;\n  parameters;\n  children;\n  nameSpan;\n  startSourceSpan;\n  endSourceSpan;\n  constructor(name, parameters, children, sourceSpan, nameSpan, startSourceSpan, endSourceSpan = null, i18n) {\n    super(sourceSpan, i18n);\n    this.name = name;\n    this.parameters = parameters;\n    this.children = children;\n    this.nameSpan = nameSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitBlock(this, context);\n  }\n}\nclass Component extends NodeWithI18n {\n  componentName;\n  tagName;\n  fullName;\n  attrs;\n  directives;\n  children;\n  isSelfClosing;\n  startSourceSpan;\n  endSourceSpan;\n  constructor(componentName, tagName, fullName, attrs, directives, children, isSelfClosing, sourceSpan, startSourceSpan, endSourceSpan = null, i18n) {\n    super(sourceSpan, i18n);\n    this.componentName = componentName;\n    this.tagName = tagName;\n    this.fullName = fullName;\n    this.attrs = attrs;\n    this.directives = directives;\n    this.children = children;\n    this.isSelfClosing = isSelfClosing;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitComponent(this, context);\n  }\n}\nclass Directive {\n  name;\n  attrs;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  constructor(name, attrs, sourceSpan, startSourceSpan, endSourceSpan = null) {\n    this.name = name;\n    this.attrs = attrs;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitDirective(this, context);\n  }\n}\nclass BlockParameter {\n  expression;\n  sourceSpan;\n  constructor(expression, sourceSpan) {\n    this.expression = expression;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitBlockParameter(this, context);\n  }\n}\nclass LetDeclaration {\n  name;\n  value;\n  sourceSpan;\n  nameSpan;\n  valueSpan;\n  constructor(name, value, sourceSpan, nameSpan, valueSpan) {\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.nameSpan = nameSpan;\n    this.valueSpan = valueSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitLetDeclaration(this, context);\n  }\n}\nfunction visitAll(visitor, nodes, context = null) {\n  const result = [];\n  const visit = visitor.visit ? ast => visitor.visit(ast, context) || ast.visit(visitor, context) : ast => ast.visit(visitor, context);\n  nodes.forEach(ast => {\n    const astResult = visit(ast);\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\nclass RecursiveVisitor {\n  constructor() {}\n  visitElement(ast, context) {\n    this.visitChildren(context, visit => {\n      visit(ast.attrs);\n      visit(ast.directives);\n      visit(ast.children);\n    });\n  }\n  visitAttribute(ast, context) {}\n  visitText(ast, context) {}\n  visitComment(ast, context) {}\n  visitExpansion(ast, context) {\n    return this.visitChildren(context, visit => {\n      visit(ast.cases);\n    });\n  }\n  visitExpansionCase(ast, context) {}\n  visitBlock(block, context) {\n    this.visitChildren(context, visit => {\n      visit(block.parameters);\n      visit(block.children);\n    });\n  }\n  visitBlockParameter(ast, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {\n    this.visitChildren(context, visit => {\n      visit(component.attrs);\n      visit(component.children);\n    });\n  }\n  visitDirective(directive, context) {\n    this.visitChildren(context, visit => {\n      visit(directive.attrs);\n    });\n  }\n  visitChildren(context, cb) {\n    let results = [];\n    let t = this;\n    function visit(children) {\n      if (children) results.push(visitAll(t, children, context));\n    }\n    cb(visit);\n    return Array.prototype.concat.apply([], results);\n  }\n}\nconst NAMED_ENTITIES = {\n  'AElig': '\\u00C6',\n  'AMP': '\\u0026',\n  'amp': '\\u0026',\n  'Aacute': '\\u00C1',\n  'Abreve': '\\u0102',\n  'Acirc': '\\u00C2',\n  'Acy': '\\u0410',\n  'Afr': '\\uD835\\uDD04',\n  'Agrave': '\\u00C0',\n  'Alpha': '\\u0391',\n  'Amacr': '\\u0100',\n  'And': '\\u2A53',\n  'Aogon': '\\u0104',\n  'Aopf': '\\uD835\\uDD38',\n  'ApplyFunction': '\\u2061',\n  'af': '\\u2061',\n  'Aring': '\\u00C5',\n  'angst': '\\u00C5',\n  'Ascr': '\\uD835\\uDC9C',\n  'Assign': '\\u2254',\n  'colone': '\\u2254',\n  'coloneq': '\\u2254',\n  'Atilde': '\\u00C3',\n  'Auml': '\\u00C4',\n  'Backslash': '\\u2216',\n  'setminus': '\\u2216',\n  'setmn': '\\u2216',\n  'smallsetminus': '\\u2216',\n  'ssetmn': '\\u2216',\n  'Barv': '\\u2AE7',\n  'Barwed': '\\u2306',\n  'doublebarwedge': '\\u2306',\n  'Bcy': '\\u0411',\n  'Because': '\\u2235',\n  'becaus': '\\u2235',\n  'because': '\\u2235',\n  'Bernoullis': '\\u212C',\n  'Bscr': '\\u212C',\n  'bernou': '\\u212C',\n  'Beta': '\\u0392',\n  'Bfr': '\\uD835\\uDD05',\n  'Bopf': '\\uD835\\uDD39',\n  'Breve': '\\u02D8',\n  'breve': '\\u02D8',\n  'Bumpeq': '\\u224E',\n  'HumpDownHump': '\\u224E',\n  'bump': '\\u224E',\n  'CHcy': '\\u0427',\n  'COPY': '\\u00A9',\n  'copy': '\\u00A9',\n  'Cacute': '\\u0106',\n  'Cap': '\\u22D2',\n  'CapitalDifferentialD': '\\u2145',\n  'DD': '\\u2145',\n  'Cayleys': '\\u212D',\n  'Cfr': '\\u212D',\n  'Ccaron': '\\u010C',\n  'Ccedil': '\\u00C7',\n  'Ccirc': '\\u0108',\n  'Cconint': '\\u2230',\n  'Cdot': '\\u010A',\n  'Cedilla': '\\u00B8',\n  'cedil': '\\u00B8',\n  'CenterDot': '\\u00B7',\n  'centerdot': '\\u00B7',\n  'middot': '\\u00B7',\n  'Chi': '\\u03A7',\n  'CircleDot': '\\u2299',\n  'odot': '\\u2299',\n  'CircleMinus': '\\u2296',\n  'ominus': '\\u2296',\n  'CirclePlus': '\\u2295',\n  'oplus': '\\u2295',\n  'CircleTimes': '\\u2297',\n  'otimes': '\\u2297',\n  'ClockwiseContourIntegral': '\\u2232',\n  'cwconint': '\\u2232',\n  'CloseCurlyDoubleQuote': '\\u201D',\n  'rdquo': '\\u201D',\n  'rdquor': '\\u201D',\n  'CloseCurlyQuote': '\\u2019',\n  'rsquo': '\\u2019',\n  'rsquor': '\\u2019',\n  'Colon': '\\u2237',\n  'Proportion': '\\u2237',\n  'Colone': '\\u2A74',\n  'Congruent': '\\u2261',\n  'equiv': '\\u2261',\n  'Conint': '\\u222F',\n  'DoubleContourIntegral': '\\u222F',\n  'ContourIntegral': '\\u222E',\n  'conint': '\\u222E',\n  'oint': '\\u222E',\n  'Copf': '\\u2102',\n  'complexes': '\\u2102',\n  'Coproduct': '\\u2210',\n  'coprod': '\\u2210',\n  'CounterClockwiseContourIntegral': '\\u2233',\n  'awconint': '\\u2233',\n  'Cross': '\\u2A2F',\n  'Cscr': '\\uD835\\uDC9E',\n  'Cup': '\\u22D3',\n  'CupCap': '\\u224D',\n  'asympeq': '\\u224D',\n  'DDotrahd': '\\u2911',\n  'DJcy': '\\u0402',\n  'DScy': '\\u0405',\n  'DZcy': '\\u040F',\n  'Dagger': '\\u2021',\n  'ddagger': '\\u2021',\n  'Darr': '\\u21A1',\n  'Dashv': '\\u2AE4',\n  'DoubleLeftTee': '\\u2AE4',\n  'Dcaron': '\\u010E',\n  'Dcy': '\\u0414',\n  'Del': '\\u2207',\n  'nabla': '\\u2207',\n  'Delta': '\\u0394',\n  'Dfr': '\\uD835\\uDD07',\n  'DiacriticalAcute': '\\u00B4',\n  'acute': '\\u00B4',\n  'DiacriticalDot': '\\u02D9',\n  'dot': '\\u02D9',\n  'DiacriticalDoubleAcute': '\\u02DD',\n  'dblac': '\\u02DD',\n  'DiacriticalGrave': '\\u0060',\n  'grave': '\\u0060',\n  'DiacriticalTilde': '\\u02DC',\n  'tilde': '\\u02DC',\n  'Diamond': '\\u22C4',\n  'diam': '\\u22C4',\n  'diamond': '\\u22C4',\n  'DifferentialD': '\\u2146',\n  'dd': '\\u2146',\n  'Dopf': '\\uD835\\uDD3B',\n  'Dot': '\\u00A8',\n  'DoubleDot': '\\u00A8',\n  'die': '\\u00A8',\n  'uml': '\\u00A8',\n  'DotDot': '\\u20DC',\n  'DotEqual': '\\u2250',\n  'doteq': '\\u2250',\n  'esdot': '\\u2250',\n  'DoubleDownArrow': '\\u21D3',\n  'Downarrow': '\\u21D3',\n  'dArr': '\\u21D3',\n  'DoubleLeftArrow': '\\u21D0',\n  'Leftarrow': '\\u21D0',\n  'lArr': '\\u21D0',\n  'DoubleLeftRightArrow': '\\u21D4',\n  'Leftrightarrow': '\\u21D4',\n  'hArr': '\\u21D4',\n  'iff': '\\u21D4',\n  'DoubleLongLeftArrow': '\\u27F8',\n  'Longleftarrow': '\\u27F8',\n  'xlArr': '\\u27F8',\n  'DoubleLongLeftRightArrow': '\\u27FA',\n  'Longleftrightarrow': '\\u27FA',\n  'xhArr': '\\u27FA',\n  'DoubleLongRightArrow': '\\u27F9',\n  'Longrightarrow': '\\u27F9',\n  'xrArr': '\\u27F9',\n  'DoubleRightArrow': '\\u21D2',\n  'Implies': '\\u21D2',\n  'Rightarrow': '\\u21D2',\n  'rArr': '\\u21D2',\n  'DoubleRightTee': '\\u22A8',\n  'vDash': '\\u22A8',\n  'DoubleUpArrow': '\\u21D1',\n  'Uparrow': '\\u21D1',\n  'uArr': '\\u21D1',\n  'DoubleUpDownArrow': '\\u21D5',\n  'Updownarrow': '\\u21D5',\n  'vArr': '\\u21D5',\n  'DoubleVerticalBar': '\\u2225',\n  'par': '\\u2225',\n  'parallel': '\\u2225',\n  'shortparallel': '\\u2225',\n  'spar': '\\u2225',\n  'DownArrow': '\\u2193',\n  'ShortDownArrow': '\\u2193',\n  'darr': '\\u2193',\n  'downarrow': '\\u2193',\n  'DownArrowBar': '\\u2913',\n  'DownArrowUpArrow': '\\u21F5',\n  'duarr': '\\u21F5',\n  'DownBreve': '\\u0311',\n  'DownLeftRightVector': '\\u2950',\n  'DownLeftTeeVector': '\\u295E',\n  'DownLeftVector': '\\u21BD',\n  'leftharpoondown': '\\u21BD',\n  'lhard': '\\u21BD',\n  'DownLeftVectorBar': '\\u2956',\n  'DownRightTeeVector': '\\u295F',\n  'DownRightVector': '\\u21C1',\n  'rhard': '\\u21C1',\n  'rightharpoondown': '\\u21C1',\n  'DownRightVectorBar': '\\u2957',\n  'DownTee': '\\u22A4',\n  'top': '\\u22A4',\n  'DownTeeArrow': '\\u21A7',\n  'mapstodown': '\\u21A7',\n  'Dscr': '\\uD835\\uDC9F',\n  'Dstrok': '\\u0110',\n  'ENG': '\\u014A',\n  'ETH': '\\u00D0',\n  'Eacute': '\\u00C9',\n  'Ecaron': '\\u011A',\n  'Ecirc': '\\u00CA',\n  'Ecy': '\\u042D',\n  'Edot': '\\u0116',\n  'Efr': '\\uD835\\uDD08',\n  'Egrave': '\\u00C8',\n  'Element': '\\u2208',\n  'in': '\\u2208',\n  'isin': '\\u2208',\n  'isinv': '\\u2208',\n  'Emacr': '\\u0112',\n  'EmptySmallSquare': '\\u25FB',\n  'EmptyVerySmallSquare': '\\u25AB',\n  'Eogon': '\\u0118',\n  'Eopf': '\\uD835\\uDD3C',\n  'Epsilon': '\\u0395',\n  'Equal': '\\u2A75',\n  'EqualTilde': '\\u2242',\n  'eqsim': '\\u2242',\n  'esim': '\\u2242',\n  'Equilibrium': '\\u21CC',\n  'rightleftharpoons': '\\u21CC',\n  'rlhar': '\\u21CC',\n  'Escr': '\\u2130',\n  'expectation': '\\u2130',\n  'Esim': '\\u2A73',\n  'Eta': '\\u0397',\n  'Euml': '\\u00CB',\n  'Exists': '\\u2203',\n  'exist': '\\u2203',\n  'ExponentialE': '\\u2147',\n  'ee': '\\u2147',\n  'exponentiale': '\\u2147',\n  'Fcy': '\\u0424',\n  'Ffr': '\\uD835\\uDD09',\n  'FilledSmallSquare': '\\u25FC',\n  'FilledVerySmallSquare': '\\u25AA',\n  'blacksquare': '\\u25AA',\n  'squarf': '\\u25AA',\n  'squf': '\\u25AA',\n  'Fopf': '\\uD835\\uDD3D',\n  'ForAll': '\\u2200',\n  'forall': '\\u2200',\n  'Fouriertrf': '\\u2131',\n  'Fscr': '\\u2131',\n  'GJcy': '\\u0403',\n  'GT': '\\u003E',\n  'gt': '\\u003E',\n  'Gamma': '\\u0393',\n  'Gammad': '\\u03DC',\n  'Gbreve': '\\u011E',\n  'Gcedil': '\\u0122',\n  'Gcirc': '\\u011C',\n  'Gcy': '\\u0413',\n  'Gdot': '\\u0120',\n  'Gfr': '\\uD835\\uDD0A',\n  'Gg': '\\u22D9',\n  'ggg': '\\u22D9',\n  'Gopf': '\\uD835\\uDD3E',\n  'GreaterEqual': '\\u2265',\n  'ge': '\\u2265',\n  'geq': '\\u2265',\n  'GreaterEqualLess': '\\u22DB',\n  'gel': '\\u22DB',\n  'gtreqless': '\\u22DB',\n  'GreaterFullEqual': '\\u2267',\n  'gE': '\\u2267',\n  'geqq': '\\u2267',\n  'GreaterGreater': '\\u2AA2',\n  'GreaterLess': '\\u2277',\n  'gl': '\\u2277',\n  'gtrless': '\\u2277',\n  'GreaterSlantEqual': '\\u2A7E',\n  'geqslant': '\\u2A7E',\n  'ges': '\\u2A7E',\n  'GreaterTilde': '\\u2273',\n  'gsim': '\\u2273',\n  'gtrsim': '\\u2273',\n  'Gscr': '\\uD835\\uDCA2',\n  'Gt': '\\u226B',\n  'NestedGreaterGreater': '\\u226B',\n  'gg': '\\u226B',\n  'HARDcy': '\\u042A',\n  'Hacek': '\\u02C7',\n  'caron': '\\u02C7',\n  'Hat': '\\u005E',\n  'Hcirc': '\\u0124',\n  'Hfr': '\\u210C',\n  'Poincareplane': '\\u210C',\n  'HilbertSpace': '\\u210B',\n  'Hscr': '\\u210B',\n  'hamilt': '\\u210B',\n  'Hopf': '\\u210D',\n  'quaternions': '\\u210D',\n  'HorizontalLine': '\\u2500',\n  'boxh': '\\u2500',\n  'Hstrok': '\\u0126',\n  'HumpEqual': '\\u224F',\n  'bumpe': '\\u224F',\n  'bumpeq': '\\u224F',\n  'IEcy': '\\u0415',\n  'IJlig': '\\u0132',\n  'IOcy': '\\u0401',\n  'Iacute': '\\u00CD',\n  'Icirc': '\\u00CE',\n  'Icy': '\\u0418',\n  'Idot': '\\u0130',\n  'Ifr': '\\u2111',\n  'Im': '\\u2111',\n  'image': '\\u2111',\n  'imagpart': '\\u2111',\n  'Igrave': '\\u00CC',\n  'Imacr': '\\u012A',\n  'ImaginaryI': '\\u2148',\n  'ii': '\\u2148',\n  'Int': '\\u222C',\n  'Integral': '\\u222B',\n  'int': '\\u222B',\n  'Intersection': '\\u22C2',\n  'bigcap': '\\u22C2',\n  'xcap': '\\u22C2',\n  'InvisibleComma': '\\u2063',\n  'ic': '\\u2063',\n  'InvisibleTimes': '\\u2062',\n  'it': '\\u2062',\n  'Iogon': '\\u012E',\n  'Iopf': '\\uD835\\uDD40',\n  'Iota': '\\u0399',\n  'Iscr': '\\u2110',\n  'imagline': '\\u2110',\n  'Itilde': '\\u0128',\n  'Iukcy': '\\u0406',\n  'Iuml': '\\u00CF',\n  'Jcirc': '\\u0134',\n  'Jcy': '\\u0419',\n  'Jfr': '\\uD835\\uDD0D',\n  'Jopf': '\\uD835\\uDD41',\n  'Jscr': '\\uD835\\uDCA5',\n  'Jsercy': '\\u0408',\n  'Jukcy': '\\u0404',\n  'KHcy': '\\u0425',\n  'KJcy': '\\u040C',\n  'Kappa': '\\u039A',\n  'Kcedil': '\\u0136',\n  'Kcy': '\\u041A',\n  'Kfr': '\\uD835\\uDD0E',\n  'Kopf': '\\uD835\\uDD42',\n  'Kscr': '\\uD835\\uDCA6',\n  'LJcy': '\\u0409',\n  'LT': '\\u003C',\n  'lt': '\\u003C',\n  'Lacute': '\\u0139',\n  'Lambda': '\\u039B',\n  'Lang': '\\u27EA',\n  'Laplacetrf': '\\u2112',\n  'Lscr': '\\u2112',\n  'lagran': '\\u2112',\n  'Larr': '\\u219E',\n  'twoheadleftarrow': '\\u219E',\n  'Lcaron': '\\u013D',\n  'Lcedil': '\\u013B',\n  'Lcy': '\\u041B',\n  'LeftAngleBracket': '\\u27E8',\n  'lang': '\\u27E8',\n  'langle': '\\u27E8',\n  'LeftArrow': '\\u2190',\n  'ShortLeftArrow': '\\u2190',\n  'larr': '\\u2190',\n  'leftarrow': '\\u2190',\n  'slarr': '\\u2190',\n  'LeftArrowBar': '\\u21E4',\n  'larrb': '\\u21E4',\n  'LeftArrowRightArrow': '\\u21C6',\n  'leftrightarrows': '\\u21C6',\n  'lrarr': '\\u21C6',\n  'LeftCeiling': '\\u2308',\n  'lceil': '\\u2308',\n  'LeftDoubleBracket': '\\u27E6',\n  'lobrk': '\\u27E6',\n  'LeftDownTeeVector': '\\u2961',\n  'LeftDownVector': '\\u21C3',\n  'dharl': '\\u21C3',\n  'downharpoonleft': '\\u21C3',\n  'LeftDownVectorBar': '\\u2959',\n  'LeftFloor': '\\u230A',\n  'lfloor': '\\u230A',\n  'LeftRightArrow': '\\u2194',\n  'harr': '\\u2194',\n  'leftrightarrow': '\\u2194',\n  'LeftRightVector': '\\u294E',\n  'LeftTee': '\\u22A3',\n  'dashv': '\\u22A3',\n  'LeftTeeArrow': '\\u21A4',\n  'mapstoleft': '\\u21A4',\n  'LeftTeeVector': '\\u295A',\n  'LeftTriangle': '\\u22B2',\n  'vartriangleleft': '\\u22B2',\n  'vltri': '\\u22B2',\n  'LeftTriangleBar': '\\u29CF',\n  'LeftTriangleEqual': '\\u22B4',\n  'ltrie': '\\u22B4',\n  'trianglelefteq': '\\u22B4',\n  'LeftUpDownVector': '\\u2951',\n  'LeftUpTeeVector': '\\u2960',\n  'LeftUpVector': '\\u21BF',\n  'uharl': '\\u21BF',\n  'upharpoonleft': '\\u21BF',\n  'LeftUpVectorBar': '\\u2958',\n  'LeftVector': '\\u21BC',\n  'leftharpoonup': '\\u21BC',\n  'lharu': '\\u21BC',\n  'LeftVectorBar': '\\u2952',\n  'LessEqualGreater': '\\u22DA',\n  'leg': '\\u22DA',\n  'lesseqgtr': '\\u22DA',\n  'LessFullEqual': '\\u2266',\n  'lE': '\\u2266',\n  'leqq': '\\u2266',\n  'LessGreater': '\\u2276',\n  'lessgtr': '\\u2276',\n  'lg': '\\u2276',\n  'LessLess': '\\u2AA1',\n  'LessSlantEqual': '\\u2A7D',\n  'leqslant': '\\u2A7D',\n  'les': '\\u2A7D',\n  'LessTilde': '\\u2272',\n  'lesssim': '\\u2272',\n  'lsim': '\\u2272',\n  'Lfr': '\\uD835\\uDD0F',\n  'Ll': '\\u22D8',\n  'Lleftarrow': '\\u21DA',\n  'lAarr': '\\u21DA',\n  'Lmidot': '\\u013F',\n  'LongLeftArrow': '\\u27F5',\n  'longleftarrow': '\\u27F5',\n  'xlarr': '\\u27F5',\n  'LongLeftRightArrow': '\\u27F7',\n  'longleftrightarrow': '\\u27F7',\n  'xharr': '\\u27F7',\n  'LongRightArrow': '\\u27F6',\n  'longrightarrow': '\\u27F6',\n  'xrarr': '\\u27F6',\n  'Lopf': '\\uD835\\uDD43',\n  'LowerLeftArrow': '\\u2199',\n  'swarr': '\\u2199',\n  'swarrow': '\\u2199',\n  'LowerRightArrow': '\\u2198',\n  'searr': '\\u2198',\n  'searrow': '\\u2198',\n  'Lsh': '\\u21B0',\n  'lsh': '\\u21B0',\n  'Lstrok': '\\u0141',\n  'Lt': '\\u226A',\n  'NestedLessLess': '\\u226A',\n  'll': '\\u226A',\n  'Map': '\\u2905',\n  'Mcy': '\\u041C',\n  'MediumSpace': '\\u205F',\n  'Mellintrf': '\\u2133',\n  'Mscr': '\\u2133',\n  'phmmat': '\\u2133',\n  'Mfr': '\\uD835\\uDD10',\n  'MinusPlus': '\\u2213',\n  'mnplus': '\\u2213',\n  'mp': '\\u2213',\n  'Mopf': '\\uD835\\uDD44',\n  'Mu': '\\u039C',\n  'NJcy': '\\u040A',\n  'Nacute': '\\u0143',\n  'Ncaron': '\\u0147',\n  'Ncedil': '\\u0145',\n  'Ncy': '\\u041D',\n  'NegativeMediumSpace': '\\u200B',\n  'NegativeThickSpace': '\\u200B',\n  'NegativeThinSpace': '\\u200B',\n  'NegativeVeryThinSpace': '\\u200B',\n  'ZeroWidthSpace': '\\u200B',\n  'NewLine': '\\u000A',\n  'Nfr': '\\uD835\\uDD11',\n  'NoBreak': '\\u2060',\n  'NonBreakingSpace': '\\u00A0',\n  'nbsp': '\\u00A0',\n  'Nopf': '\\u2115',\n  'naturals': '\\u2115',\n  'Not': '\\u2AEC',\n  'NotCongruent': '\\u2262',\n  'nequiv': '\\u2262',\n  'NotCupCap': '\\u226D',\n  'NotDoubleVerticalBar': '\\u2226',\n  'npar': '\\u2226',\n  'nparallel': '\\u2226',\n  'nshortparallel': '\\u2226',\n  'nspar': '\\u2226',\n  'NotElement': '\\u2209',\n  'notin': '\\u2209',\n  'notinva': '\\u2209',\n  'NotEqual': '\\u2260',\n  'ne': '\\u2260',\n  'NotEqualTilde': '\\u2242\\u0338',\n  'nesim': '\\u2242\\u0338',\n  'NotExists': '\\u2204',\n  'nexist': '\\u2204',\n  'nexists': '\\u2204',\n  'NotGreater': '\\u226F',\n  'ngt': '\\u226F',\n  'ngtr': '\\u226F',\n  'NotGreaterEqual': '\\u2271',\n  'nge': '\\u2271',\n  'ngeq': '\\u2271',\n  'NotGreaterFullEqual': '\\u2267\\u0338',\n  'ngE': '\\u2267\\u0338',\n  'ngeqq': '\\u2267\\u0338',\n  'NotGreaterGreater': '\\u226B\\u0338',\n  'nGtv': '\\u226B\\u0338',\n  'NotGreaterLess': '\\u2279',\n  'ntgl': '\\u2279',\n  'NotGreaterSlantEqual': '\\u2A7E\\u0338',\n  'ngeqslant': '\\u2A7E\\u0338',\n  'nges': '\\u2A7E\\u0338',\n  'NotGreaterTilde': '\\u2275',\n  'ngsim': '\\u2275',\n  'NotHumpDownHump': '\\u224E\\u0338',\n  'nbump': '\\u224E\\u0338',\n  'NotHumpEqual': '\\u224F\\u0338',\n  'nbumpe': '\\u224F\\u0338',\n  'NotLeftTriangle': '\\u22EA',\n  'nltri': '\\u22EA',\n  'ntriangleleft': '\\u22EA',\n  'NotLeftTriangleBar': '\\u29CF\\u0338',\n  'NotLeftTriangleEqual': '\\u22EC',\n  'nltrie': '\\u22EC',\n  'ntrianglelefteq': '\\u22EC',\n  'NotLess': '\\u226E',\n  'nless': '\\u226E',\n  'nlt': '\\u226E',\n  'NotLessEqual': '\\u2270',\n  'nle': '\\u2270',\n  'nleq': '\\u2270',\n  'NotLessGreater': '\\u2278',\n  'ntlg': '\\u2278',\n  'NotLessLess': '\\u226A\\u0338',\n  'nLtv': '\\u226A\\u0338',\n  'NotLessSlantEqual': '\\u2A7D\\u0338',\n  'nleqslant': '\\u2A7D\\u0338',\n  'nles': '\\u2A7D\\u0338',\n  'NotLessTilde': '\\u2274',\n  'nlsim': '\\u2274',\n  'NotNestedGreaterGreater': '\\u2AA2\\u0338',\n  'NotNestedLessLess': '\\u2AA1\\u0338',\n  'NotPrecedes': '\\u2280',\n  'npr': '\\u2280',\n  'nprec': '\\u2280',\n  'NotPrecedesEqual': '\\u2AAF\\u0338',\n  'npre': '\\u2AAF\\u0338',\n  'npreceq': '\\u2AAF\\u0338',\n  'NotPrecedesSlantEqual': '\\u22E0',\n  'nprcue': '\\u22E0',\n  'NotReverseElement': '\\u220C',\n  'notni': '\\u220C',\n  'notniva': '\\u220C',\n  'NotRightTriangle': '\\u22EB',\n  'nrtri': '\\u22EB',\n  'ntriangleright': '\\u22EB',\n  'NotRightTriangleBar': '\\u29D0\\u0338',\n  'NotRightTriangleEqual': '\\u22ED',\n  'nrtrie': '\\u22ED',\n  'ntrianglerighteq': '\\u22ED',\n  'NotSquareSubset': '\\u228F\\u0338',\n  'NotSquareSubsetEqual': '\\u22E2',\n  'nsqsube': '\\u22E2',\n  'NotSquareSuperset': '\\u2290\\u0338',\n  'NotSquareSupersetEqual': '\\u22E3',\n  'nsqsupe': '\\u22E3',\n  'NotSubset': '\\u2282\\u20D2',\n  'nsubset': '\\u2282\\u20D2',\n  'vnsub': '\\u2282\\u20D2',\n  'NotSubsetEqual': '\\u2288',\n  'nsube': '\\u2288',\n  'nsubseteq': '\\u2288',\n  'NotSucceeds': '\\u2281',\n  'nsc': '\\u2281',\n  'nsucc': '\\u2281',\n  'NotSucceedsEqual': '\\u2AB0\\u0338',\n  'nsce': '\\u2AB0\\u0338',\n  'nsucceq': '\\u2AB0\\u0338',\n  'NotSucceedsSlantEqual': '\\u22E1',\n  'nsccue': '\\u22E1',\n  'NotSucceedsTilde': '\\u227F\\u0338',\n  'NotSuperset': '\\u2283\\u20D2',\n  'nsupset': '\\u2283\\u20D2',\n  'vnsup': '\\u2283\\u20D2',\n  'NotSupersetEqual': '\\u2289',\n  'nsupe': '\\u2289',\n  'nsupseteq': '\\u2289',\n  'NotTilde': '\\u2241',\n  'nsim': '\\u2241',\n  'NotTildeEqual': '\\u2244',\n  'nsime': '\\u2244',\n  'nsimeq': '\\u2244',\n  'NotTildeFullEqual': '\\u2247',\n  'ncong': '\\u2247',\n  'NotTildeTilde': '\\u2249',\n  'nap': '\\u2249',\n  'napprox': '\\u2249',\n  'NotVerticalBar': '\\u2224',\n  'nmid': '\\u2224',\n  'nshortmid': '\\u2224',\n  'nsmid': '\\u2224',\n  'Nscr': '\\uD835\\uDCA9',\n  'Ntilde': '\\u00D1',\n  'Nu': '\\u039D',\n  'OElig': '\\u0152',\n  'Oacute': '\\u00D3',\n  'Ocirc': '\\u00D4',\n  'Ocy': '\\u041E',\n  'Odblac': '\\u0150',\n  'Ofr': '\\uD835\\uDD12',\n  'Ograve': '\\u00D2',\n  'Omacr': '\\u014C',\n  'Omega': '\\u03A9',\n  'ohm': '\\u03A9',\n  'Omicron': '\\u039F',\n  'Oopf': '\\uD835\\uDD46',\n  'OpenCurlyDoubleQuote': '\\u201C',\n  'ldquo': '\\u201C',\n  'OpenCurlyQuote': '\\u2018',\n  'lsquo': '\\u2018',\n  'Or': '\\u2A54',\n  'Oscr': '\\uD835\\uDCAA',\n  'Oslash': '\\u00D8',\n  'Otilde': '\\u00D5',\n  'Otimes': '\\u2A37',\n  'Ouml': '\\u00D6',\n  'OverBar': '\\u203E',\n  'oline': '\\u203E',\n  'OverBrace': '\\u23DE',\n  'OverBracket': '\\u23B4',\n  'tbrk': '\\u23B4',\n  'OverParenthesis': '\\u23DC',\n  'PartialD': '\\u2202',\n  'part': '\\u2202',\n  'Pcy': '\\u041F',\n  'Pfr': '\\uD835\\uDD13',\n  'Phi': '\\u03A6',\n  'Pi': '\\u03A0',\n  'PlusMinus': '\\u00B1',\n  'plusmn': '\\u00B1',\n  'pm': '\\u00B1',\n  'Popf': '\\u2119',\n  'primes': '\\u2119',\n  'Pr': '\\u2ABB',\n  'Precedes': '\\u227A',\n  'pr': '\\u227A',\n  'prec': '\\u227A',\n  'PrecedesEqual': '\\u2AAF',\n  'pre': '\\u2AAF',\n  'preceq': '\\u2AAF',\n  'PrecedesSlantEqual': '\\u227C',\n  'prcue': '\\u227C',\n  'preccurlyeq': '\\u227C',\n  'PrecedesTilde': '\\u227E',\n  'precsim': '\\u227E',\n  'prsim': '\\u227E',\n  'Prime': '\\u2033',\n  'Product': '\\u220F',\n  'prod': '\\u220F',\n  'Proportional': '\\u221D',\n  'prop': '\\u221D',\n  'propto': '\\u221D',\n  'varpropto': '\\u221D',\n  'vprop': '\\u221D',\n  'Pscr': '\\uD835\\uDCAB',\n  'Psi': '\\u03A8',\n  'QUOT': '\\u0022',\n  'quot': '\\u0022',\n  'Qfr': '\\uD835\\uDD14',\n  'Qopf': '\\u211A',\n  'rationals': '\\u211A',\n  'Qscr': '\\uD835\\uDCAC',\n  'RBarr': '\\u2910',\n  'drbkarow': '\\u2910',\n  'REG': '\\u00AE',\n  'circledR': '\\u00AE',\n  'reg': '\\u00AE',\n  'Racute': '\\u0154',\n  'Rang': '\\u27EB',\n  'Rarr': '\\u21A0',\n  'twoheadrightarrow': '\\u21A0',\n  'Rarrtl': '\\u2916',\n  'Rcaron': '\\u0158',\n  'Rcedil': '\\u0156',\n  'Rcy': '\\u0420',\n  'Re': '\\u211C',\n  'Rfr': '\\u211C',\n  'real': '\\u211C',\n  'realpart': '\\u211C',\n  'ReverseElement': '\\u220B',\n  'SuchThat': '\\u220B',\n  'ni': '\\u220B',\n  'niv': '\\u220B',\n  'ReverseEquilibrium': '\\u21CB',\n  'leftrightharpoons': '\\u21CB',\n  'lrhar': '\\u21CB',\n  'ReverseUpEquilibrium': '\\u296F',\n  'duhar': '\\u296F',\n  'Rho': '\\u03A1',\n  'RightAngleBracket': '\\u27E9',\n  'rang': '\\u27E9',\n  'rangle': '\\u27E9',\n  'RightArrow': '\\u2192',\n  'ShortRightArrow': '\\u2192',\n  'rarr': '\\u2192',\n  'rightarrow': '\\u2192',\n  'srarr': '\\u2192',\n  'RightArrowBar': '\\u21E5',\n  'rarrb': '\\u21E5',\n  'RightArrowLeftArrow': '\\u21C4',\n  'rightleftarrows': '\\u21C4',\n  'rlarr': '\\u21C4',\n  'RightCeiling': '\\u2309',\n  'rceil': '\\u2309',\n  'RightDoubleBracket': '\\u27E7',\n  'robrk': '\\u27E7',\n  'RightDownTeeVector': '\\u295D',\n  'RightDownVector': '\\u21C2',\n  'dharr': '\\u21C2',\n  'downharpoonright': '\\u21C2',\n  'RightDownVectorBar': '\\u2955',\n  'RightFloor': '\\u230B',\n  'rfloor': '\\u230B',\n  'RightTee': '\\u22A2',\n  'vdash': '\\u22A2',\n  'RightTeeArrow': '\\u21A6',\n  'map': '\\u21A6',\n  'mapsto': '\\u21A6',\n  'RightTeeVector': '\\u295B',\n  'RightTriangle': '\\u22B3',\n  'vartriangleright': '\\u22B3',\n  'vrtri': '\\u22B3',\n  'RightTriangleBar': '\\u29D0',\n  'RightTriangleEqual': '\\u22B5',\n  'rtrie': '\\u22B5',\n  'trianglerighteq': '\\u22B5',\n  'RightUpDownVector': '\\u294F',\n  'RightUpTeeVector': '\\u295C',\n  'RightUpVector': '\\u21BE',\n  'uharr': '\\u21BE',\n  'upharpoonright': '\\u21BE',\n  'RightUpVectorBar': '\\u2954',\n  'RightVector': '\\u21C0',\n  'rharu': '\\u21C0',\n  'rightharpoonup': '\\u21C0',\n  'RightVectorBar': '\\u2953',\n  'Ropf': '\\u211D',\n  'reals': '\\u211D',\n  'RoundImplies': '\\u2970',\n  'Rrightarrow': '\\u21DB',\n  'rAarr': '\\u21DB',\n  'Rscr': '\\u211B',\n  'realine': '\\u211B',\n  'Rsh': '\\u21B1',\n  'rsh': '\\u21B1',\n  'RuleDelayed': '\\u29F4',\n  'SHCHcy': '\\u0429',\n  'SHcy': '\\u0428',\n  'SOFTcy': '\\u042C',\n  'Sacute': '\\u015A',\n  'Sc': '\\u2ABC',\n  'Scaron': '\\u0160',\n  'Scedil': '\\u015E',\n  'Scirc': '\\u015C',\n  'Scy': '\\u0421',\n  'Sfr': '\\uD835\\uDD16',\n  'ShortUpArrow': '\\u2191',\n  'UpArrow': '\\u2191',\n  'uarr': '\\u2191',\n  'uparrow': '\\u2191',\n  'Sigma': '\\u03A3',\n  'SmallCircle': '\\u2218',\n  'compfn': '\\u2218',\n  'Sopf': '\\uD835\\uDD4A',\n  'Sqrt': '\\u221A',\n  'radic': '\\u221A',\n  'Square': '\\u25A1',\n  'squ': '\\u25A1',\n  'square': '\\u25A1',\n  'SquareIntersection': '\\u2293',\n  'sqcap': '\\u2293',\n  'SquareSubset': '\\u228F',\n  'sqsub': '\\u228F',\n  'sqsubset': '\\u228F',\n  'SquareSubsetEqual': '\\u2291',\n  'sqsube': '\\u2291',\n  'sqsubseteq': '\\u2291',\n  'SquareSuperset': '\\u2290',\n  'sqsup': '\\u2290',\n  'sqsupset': '\\u2290',\n  'SquareSupersetEqual': '\\u2292',\n  'sqsupe': '\\u2292',\n  'sqsupseteq': '\\u2292',\n  'SquareUnion': '\\u2294',\n  'sqcup': '\\u2294',\n  'Sscr': '\\uD835\\uDCAE',\n  'Star': '\\u22C6',\n  'sstarf': '\\u22C6',\n  'Sub': '\\u22D0',\n  'Subset': '\\u22D0',\n  'SubsetEqual': '\\u2286',\n  'sube': '\\u2286',\n  'subseteq': '\\u2286',\n  'Succeeds': '\\u227B',\n  'sc': '\\u227B',\n  'succ': '\\u227B',\n  'SucceedsEqual': '\\u2AB0',\n  'sce': '\\u2AB0',\n  'succeq': '\\u2AB0',\n  'SucceedsSlantEqual': '\\u227D',\n  'sccue': '\\u227D',\n  'succcurlyeq': '\\u227D',\n  'SucceedsTilde': '\\u227F',\n  'scsim': '\\u227F',\n  'succsim': '\\u227F',\n  'Sum': '\\u2211',\n  'sum': '\\u2211',\n  'Sup': '\\u22D1',\n  'Supset': '\\u22D1',\n  'Superset': '\\u2283',\n  'sup': '\\u2283',\n  'supset': '\\u2283',\n  'SupersetEqual': '\\u2287',\n  'supe': '\\u2287',\n  'supseteq': '\\u2287',\n  'THORN': '\\u00DE',\n  'TRADE': '\\u2122',\n  'trade': '\\u2122',\n  'TSHcy': '\\u040B',\n  'TScy': '\\u0426',\n  'Tab': '\\u0009',\n  'Tau': '\\u03A4',\n  'Tcaron': '\\u0164',\n  'Tcedil': '\\u0162',\n  'Tcy': '\\u0422',\n  'Tfr': '\\uD835\\uDD17',\n  'Therefore': '\\u2234',\n  'there4': '\\u2234',\n  'therefore': '\\u2234',\n  'Theta': '\\u0398',\n  'ThickSpace': '\\u205F\\u200A',\n  'ThinSpace': '\\u2009',\n  'thinsp': '\\u2009',\n  'Tilde': '\\u223C',\n  'sim': '\\u223C',\n  'thicksim': '\\u223C',\n  'thksim': '\\u223C',\n  'TildeEqual': '\\u2243',\n  'sime': '\\u2243',\n  'simeq': '\\u2243',\n  'TildeFullEqual': '\\u2245',\n  'cong': '\\u2245',\n  'TildeTilde': '\\u2248',\n  'ap': '\\u2248',\n  'approx': '\\u2248',\n  'asymp': '\\u2248',\n  'thickapprox': '\\u2248',\n  'thkap': '\\u2248',\n  'Topf': '\\uD835\\uDD4B',\n  'TripleDot': '\\u20DB',\n  'tdot': '\\u20DB',\n  'Tscr': '\\uD835\\uDCAF',\n  'Tstrok': '\\u0166',\n  'Uacute': '\\u00DA',\n  'Uarr': '\\u219F',\n  'Uarrocir': '\\u2949',\n  'Ubrcy': '\\u040E',\n  'Ubreve': '\\u016C',\n  'Ucirc': '\\u00DB',\n  'Ucy': '\\u0423',\n  'Udblac': '\\u0170',\n  'Ufr': '\\uD835\\uDD18',\n  'Ugrave': '\\u00D9',\n  'Umacr': '\\u016A',\n  'UnderBar': '\\u005F',\n  'lowbar': '\\u005F',\n  'UnderBrace': '\\u23DF',\n  'UnderBracket': '\\u23B5',\n  'bbrk': '\\u23B5',\n  'UnderParenthesis': '\\u23DD',\n  'Union': '\\u22C3',\n  'bigcup': '\\u22C3',\n  'xcup': '\\u22C3',\n  'UnionPlus': '\\u228E',\n  'uplus': '\\u228E',\n  'Uogon': '\\u0172',\n  'Uopf': '\\uD835\\uDD4C',\n  'UpArrowBar': '\\u2912',\n  'UpArrowDownArrow': '\\u21C5',\n  'udarr': '\\u21C5',\n  'UpDownArrow': '\\u2195',\n  'updownarrow': '\\u2195',\n  'varr': '\\u2195',\n  'UpEquilibrium': '\\u296E',\n  'udhar': '\\u296E',\n  'UpTee': '\\u22A5',\n  'bot': '\\u22A5',\n  'bottom': '\\u22A5',\n  'perp': '\\u22A5',\n  'UpTeeArrow': '\\u21A5',\n  'mapstoup': '\\u21A5',\n  'UpperLeftArrow': '\\u2196',\n  'nwarr': '\\u2196',\n  'nwarrow': '\\u2196',\n  'UpperRightArrow': '\\u2197',\n  'nearr': '\\u2197',\n  'nearrow': '\\u2197',\n  'Upsi': '\\u03D2',\n  'upsih': '\\u03D2',\n  'Upsilon': '\\u03A5',\n  'Uring': '\\u016E',\n  'Uscr': '\\uD835\\uDCB0',\n  'Utilde': '\\u0168',\n  'Uuml': '\\u00DC',\n  'VDash': '\\u22AB',\n  'Vbar': '\\u2AEB',\n  'Vcy': '\\u0412',\n  'Vdash': '\\u22A9',\n  'Vdashl': '\\u2AE6',\n  'Vee': '\\u22C1',\n  'bigvee': '\\u22C1',\n  'xvee': '\\u22C1',\n  'Verbar': '\\u2016',\n  'Vert': '\\u2016',\n  'VerticalBar': '\\u2223',\n  'mid': '\\u2223',\n  'shortmid': '\\u2223',\n  'smid': '\\u2223',\n  'VerticalLine': '\\u007C',\n  'verbar': '\\u007C',\n  'vert': '\\u007C',\n  'VerticalSeparator': '\\u2758',\n  'VerticalTilde': '\\u2240',\n  'wr': '\\u2240',\n  'wreath': '\\u2240',\n  'VeryThinSpace': '\\u200A',\n  'hairsp': '\\u200A',\n  'Vfr': '\\uD835\\uDD19',\n  'Vopf': '\\uD835\\uDD4D',\n  'Vscr': '\\uD835\\uDCB1',\n  'Vvdash': '\\u22AA',\n  'Wcirc': '\\u0174',\n  'Wedge': '\\u22C0',\n  'bigwedge': '\\u22C0',\n  'xwedge': '\\u22C0',\n  'Wfr': '\\uD835\\uDD1A',\n  'Wopf': '\\uD835\\uDD4E',\n  'Wscr': '\\uD835\\uDCB2',\n  'Xfr': '\\uD835\\uDD1B',\n  'Xi': '\\u039E',\n  'Xopf': '\\uD835\\uDD4F',\n  'Xscr': '\\uD835\\uDCB3',\n  'YAcy': '\\u042F',\n  'YIcy': '\\u0407',\n  'YUcy': '\\u042E',\n  'Yacute': '\\u00DD',\n  'Ycirc': '\\u0176',\n  'Ycy': '\\u042B',\n  'Yfr': '\\uD835\\uDD1C',\n  'Yopf': '\\uD835\\uDD50',\n  'Yscr': '\\uD835\\uDCB4',\n  'Yuml': '\\u0178',\n  'ZHcy': '\\u0416',\n  'Zacute': '\\u0179',\n  'Zcaron': '\\u017D',\n  'Zcy': '\\u0417',\n  'Zdot': '\\u017B',\n  'Zeta': '\\u0396',\n  'Zfr': '\\u2128',\n  'zeetrf': '\\u2128',\n  'Zopf': '\\u2124',\n  'integers': '\\u2124',\n  'Zscr': '\\uD835\\uDCB5',\n  'aacute': '\\u00E1',\n  'abreve': '\\u0103',\n  'ac': '\\u223E',\n  'mstpos': '\\u223E',\n  'acE': '\\u223E\\u0333',\n  'acd': '\\u223F',\n  'acirc': '\\u00E2',\n  'acy': '\\u0430',\n  'aelig': '\\u00E6',\n  'afr': '\\uD835\\uDD1E',\n  'agrave': '\\u00E0',\n  'alefsym': '\\u2135',\n  'aleph': '\\u2135',\n  'alpha': '\\u03B1',\n  'amacr': '\\u0101',\n  'amalg': '\\u2A3F',\n  'and': '\\u2227',\n  'wedge': '\\u2227',\n  'andand': '\\u2A55',\n  'andd': '\\u2A5C',\n  'andslope': '\\u2A58',\n  'andv': '\\u2A5A',\n  'ang': '\\u2220',\n  'angle': '\\u2220',\n  'ange': '\\u29A4',\n  'angmsd': '\\u2221',\n  'measuredangle': '\\u2221',\n  'angmsdaa': '\\u29A8',\n  'angmsdab': '\\u29A9',\n  'angmsdac': '\\u29AA',\n  'angmsdad': '\\u29AB',\n  'angmsdae': '\\u29AC',\n  'angmsdaf': '\\u29AD',\n  'angmsdag': '\\u29AE',\n  'angmsdah': '\\u29AF',\n  'angrt': '\\u221F',\n  'angrtvb': '\\u22BE',\n  'angrtvbd': '\\u299D',\n  'angsph': '\\u2222',\n  'angzarr': '\\u237C',\n  'aogon': '\\u0105',\n  'aopf': '\\uD835\\uDD52',\n  'apE': '\\u2A70',\n  'apacir': '\\u2A6F',\n  'ape': '\\u224A',\n  'approxeq': '\\u224A',\n  'apid': '\\u224B',\n  'apos': '\\u0027',\n  'aring': '\\u00E5',\n  'ascr': '\\uD835\\uDCB6',\n  'ast': '\\u002A',\n  'midast': '\\u002A',\n  'atilde': '\\u00E3',\n  'auml': '\\u00E4',\n  'awint': '\\u2A11',\n  'bNot': '\\u2AED',\n  'backcong': '\\u224C',\n  'bcong': '\\u224C',\n  'backepsilon': '\\u03F6',\n  'bepsi': '\\u03F6',\n  'backprime': '\\u2035',\n  'bprime': '\\u2035',\n  'backsim': '\\u223D',\n  'bsim': '\\u223D',\n  'backsimeq': '\\u22CD',\n  'bsime': '\\u22CD',\n  'barvee': '\\u22BD',\n  'barwed': '\\u2305',\n  'barwedge': '\\u2305',\n  'bbrktbrk': '\\u23B6',\n  'bcy': '\\u0431',\n  'bdquo': '\\u201E',\n  'ldquor': '\\u201E',\n  'bemptyv': '\\u29B0',\n  'beta': '\\u03B2',\n  'beth': '\\u2136',\n  'between': '\\u226C',\n  'twixt': '\\u226C',\n  'bfr': '\\uD835\\uDD1F',\n  'bigcirc': '\\u25EF',\n  'xcirc': '\\u25EF',\n  'bigodot': '\\u2A00',\n  'xodot': '\\u2A00',\n  'bigoplus': '\\u2A01',\n  'xoplus': '\\u2A01',\n  'bigotimes': '\\u2A02',\n  'xotime': '\\u2A02',\n  'bigsqcup': '\\u2A06',\n  'xsqcup': '\\u2A06',\n  'bigstar': '\\u2605',\n  'starf': '\\u2605',\n  'bigtriangledown': '\\u25BD',\n  'xdtri': '\\u25BD',\n  'bigtriangleup': '\\u25B3',\n  'xutri': '\\u25B3',\n  'biguplus': '\\u2A04',\n  'xuplus': '\\u2A04',\n  'bkarow': '\\u290D',\n  'rbarr': '\\u290D',\n  'blacklozenge': '\\u29EB',\n  'lozf': '\\u29EB',\n  'blacktriangle': '\\u25B4',\n  'utrif': '\\u25B4',\n  'blacktriangledown': '\\u25BE',\n  'dtrif': '\\u25BE',\n  'blacktriangleleft': '\\u25C2',\n  'ltrif': '\\u25C2',\n  'blacktriangleright': '\\u25B8',\n  'rtrif': '\\u25B8',\n  'blank': '\\u2423',\n  'blk12': '\\u2592',\n  'blk14': '\\u2591',\n  'blk34': '\\u2593',\n  'block': '\\u2588',\n  'bne': '\\u003D\\u20E5',\n  'bnequiv': '\\u2261\\u20E5',\n  'bnot': '\\u2310',\n  'bopf': '\\uD835\\uDD53',\n  'bowtie': '\\u22C8',\n  'boxDL': '\\u2557',\n  'boxDR': '\\u2554',\n  'boxDl': '\\u2556',\n  'boxDr': '\\u2553',\n  'boxH': '\\u2550',\n  'boxHD': '\\u2566',\n  'boxHU': '\\u2569',\n  'boxHd': '\\u2564',\n  'boxHu': '\\u2567',\n  'boxUL': '\\u255D',\n  'boxUR': '\\u255A',\n  'boxUl': '\\u255C',\n  'boxUr': '\\u2559',\n  'boxV': '\\u2551',\n  'boxVH': '\\u256C',\n  'boxVL': '\\u2563',\n  'boxVR': '\\u2560',\n  'boxVh': '\\u256B',\n  'boxVl': '\\u2562',\n  'boxVr': '\\u255F',\n  'boxbox': '\\u29C9',\n  'boxdL': '\\u2555',\n  'boxdR': '\\u2552',\n  'boxdl': '\\u2510',\n  'boxdr': '\\u250C',\n  'boxhD': '\\u2565',\n  'boxhU': '\\u2568',\n  'boxhd': '\\u252C',\n  'boxhu': '\\u2534',\n  'boxminus': '\\u229F',\n  'minusb': '\\u229F',\n  'boxplus': '\\u229E',\n  'plusb': '\\u229E',\n  'boxtimes': '\\u22A0',\n  'timesb': '\\u22A0',\n  'boxuL': '\\u255B',\n  'boxuR': '\\u2558',\n  'boxul': '\\u2518',\n  'boxur': '\\u2514',\n  'boxv': '\\u2502',\n  'boxvH': '\\u256A',\n  'boxvL': '\\u2561',\n  'boxvR': '\\u255E',\n  'boxvh': '\\u253C',\n  'boxvl': '\\u2524',\n  'boxvr': '\\u251C',\n  'brvbar': '\\u00A6',\n  'bscr': '\\uD835\\uDCB7',\n  'bsemi': '\\u204F',\n  'bsol': '\\u005C',\n  'bsolb': '\\u29C5',\n  'bsolhsub': '\\u27C8',\n  'bull': '\\u2022',\n  'bullet': '\\u2022',\n  'bumpE': '\\u2AAE',\n  'cacute': '\\u0107',\n  'cap': '\\u2229',\n  'capand': '\\u2A44',\n  'capbrcup': '\\u2A49',\n  'capcap': '\\u2A4B',\n  'capcup': '\\u2A47',\n  'capdot': '\\u2A40',\n  'caps': '\\u2229\\uFE00',\n  'caret': '\\u2041',\n  'ccaps': '\\u2A4D',\n  'ccaron': '\\u010D',\n  'ccedil': '\\u00E7',\n  'ccirc': '\\u0109',\n  'ccups': '\\u2A4C',\n  'ccupssm': '\\u2A50',\n  'cdot': '\\u010B',\n  'cemptyv': '\\u29B2',\n  'cent': '\\u00A2',\n  'cfr': '\\uD835\\uDD20',\n  'chcy': '\\u0447',\n  'check': '\\u2713',\n  'checkmark': '\\u2713',\n  'chi': '\\u03C7',\n  'cir': '\\u25CB',\n  'cirE': '\\u29C3',\n  'circ': '\\u02C6',\n  'circeq': '\\u2257',\n  'cire': '\\u2257',\n  'circlearrowleft': '\\u21BA',\n  'olarr': '\\u21BA',\n  'circlearrowright': '\\u21BB',\n  'orarr': '\\u21BB',\n  'circledS': '\\u24C8',\n  'oS': '\\u24C8',\n  'circledast': '\\u229B',\n  'oast': '\\u229B',\n  'circledcirc': '\\u229A',\n  'ocir': '\\u229A',\n  'circleddash': '\\u229D',\n  'odash': '\\u229D',\n  'cirfnint': '\\u2A10',\n  'cirmid': '\\u2AEF',\n  'cirscir': '\\u29C2',\n  'clubs': '\\u2663',\n  'clubsuit': '\\u2663',\n  'colon': '\\u003A',\n  'comma': '\\u002C',\n  'commat': '\\u0040',\n  'comp': '\\u2201',\n  'complement': '\\u2201',\n  'congdot': '\\u2A6D',\n  'copf': '\\uD835\\uDD54',\n  'copysr': '\\u2117',\n  'crarr': '\\u21B5',\n  'cross': '\\u2717',\n  'cscr': '\\uD835\\uDCB8',\n  'csub': '\\u2ACF',\n  'csube': '\\u2AD1',\n  'csup': '\\u2AD0',\n  'csupe': '\\u2AD2',\n  'ctdot': '\\u22EF',\n  'cudarrl': '\\u2938',\n  'cudarrr': '\\u2935',\n  'cuepr': '\\u22DE',\n  'curlyeqprec': '\\u22DE',\n  'cuesc': '\\u22DF',\n  'curlyeqsucc': '\\u22DF',\n  'cularr': '\\u21B6',\n  'curvearrowleft': '\\u21B6',\n  'cularrp': '\\u293D',\n  'cup': '\\u222A',\n  'cupbrcap': '\\u2A48',\n  'cupcap': '\\u2A46',\n  'cupcup': '\\u2A4A',\n  'cupdot': '\\u228D',\n  'cupor': '\\u2A45',\n  'cups': '\\u222A\\uFE00',\n  'curarr': '\\u21B7',\n  'curvearrowright': '\\u21B7',\n  'curarrm': '\\u293C',\n  'curlyvee': '\\u22CE',\n  'cuvee': '\\u22CE',\n  'curlywedge': '\\u22CF',\n  'cuwed': '\\u22CF',\n  'curren': '\\u00A4',\n  'cwint': '\\u2231',\n  'cylcty': '\\u232D',\n  'dHar': '\\u2965',\n  'dagger': '\\u2020',\n  'daleth': '\\u2138',\n  'dash': '\\u2010',\n  'hyphen': '\\u2010',\n  'dbkarow': '\\u290F',\n  'rBarr': '\\u290F',\n  'dcaron': '\\u010F',\n  'dcy': '\\u0434',\n  'ddarr': '\\u21CA',\n  'downdownarrows': '\\u21CA',\n  'ddotseq': '\\u2A77',\n  'eDDot': '\\u2A77',\n  'deg': '\\u00B0',\n  'delta': '\\u03B4',\n  'demptyv': '\\u29B1',\n  'dfisht': '\\u297F',\n  'dfr': '\\uD835\\uDD21',\n  'diamondsuit': '\\u2666',\n  'diams': '\\u2666',\n  'digamma': '\\u03DD',\n  'gammad': '\\u03DD',\n  'disin': '\\u22F2',\n  'div': '\\u00F7',\n  'divide': '\\u00F7',\n  'divideontimes': '\\u22C7',\n  'divonx': '\\u22C7',\n  'djcy': '\\u0452',\n  'dlcorn': '\\u231E',\n  'llcorner': '\\u231E',\n  'dlcrop': '\\u230D',\n  'dollar': '\\u0024',\n  'dopf': '\\uD835\\uDD55',\n  'doteqdot': '\\u2251',\n  'eDot': '\\u2251',\n  'dotminus': '\\u2238',\n  'minusd': '\\u2238',\n  'dotplus': '\\u2214',\n  'plusdo': '\\u2214',\n  'dotsquare': '\\u22A1',\n  'sdotb': '\\u22A1',\n  'drcorn': '\\u231F',\n  'lrcorner': '\\u231F',\n  'drcrop': '\\u230C',\n  'dscr': '\\uD835\\uDCB9',\n  'dscy': '\\u0455',\n  'dsol': '\\u29F6',\n  'dstrok': '\\u0111',\n  'dtdot': '\\u22F1',\n  'dtri': '\\u25BF',\n  'triangledown': '\\u25BF',\n  'dwangle': '\\u29A6',\n  'dzcy': '\\u045F',\n  'dzigrarr': '\\u27FF',\n  'eacute': '\\u00E9',\n  'easter': '\\u2A6E',\n  'ecaron': '\\u011B',\n  'ecir': '\\u2256',\n  'eqcirc': '\\u2256',\n  'ecirc': '\\u00EA',\n  'ecolon': '\\u2255',\n  'eqcolon': '\\u2255',\n  'ecy': '\\u044D',\n  'edot': '\\u0117',\n  'efDot': '\\u2252',\n  'fallingdotseq': '\\u2252',\n  'efr': '\\uD835\\uDD22',\n  'eg': '\\u2A9A',\n  'egrave': '\\u00E8',\n  'egs': '\\u2A96',\n  'eqslantgtr': '\\u2A96',\n  'egsdot': '\\u2A98',\n  'el': '\\u2A99',\n  'elinters': '\\u23E7',\n  'ell': '\\u2113',\n  'els': '\\u2A95',\n  'eqslantless': '\\u2A95',\n  'elsdot': '\\u2A97',\n  'emacr': '\\u0113',\n  'empty': '\\u2205',\n  'emptyset': '\\u2205',\n  'emptyv': '\\u2205',\n  'varnothing': '\\u2205',\n  'emsp13': '\\u2004',\n  'emsp14': '\\u2005',\n  'emsp': '\\u2003',\n  'eng': '\\u014B',\n  'ensp': '\\u2002',\n  'eogon': '\\u0119',\n  'eopf': '\\uD835\\uDD56',\n  'epar': '\\u22D5',\n  'eparsl': '\\u29E3',\n  'eplus': '\\u2A71',\n  'epsi': '\\u03B5',\n  'epsilon': '\\u03B5',\n  'epsiv': '\\u03F5',\n  'straightepsilon': '\\u03F5',\n  'varepsilon': '\\u03F5',\n  'equals': '\\u003D',\n  'equest': '\\u225F',\n  'questeq': '\\u225F',\n  'equivDD': '\\u2A78',\n  'eqvparsl': '\\u29E5',\n  'erDot': '\\u2253',\n  'risingdotseq': '\\u2253',\n  'erarr': '\\u2971',\n  'escr': '\\u212F',\n  'eta': '\\u03B7',\n  'eth': '\\u00F0',\n  'euml': '\\u00EB',\n  'euro': '\\u20AC',\n  'excl': '\\u0021',\n  'fcy': '\\u0444',\n  'female': '\\u2640',\n  'ffilig': '\\uFB03',\n  'fflig': '\\uFB00',\n  'ffllig': '\\uFB04',\n  'ffr': '\\uD835\\uDD23',\n  'filig': '\\uFB01',\n  'fjlig': '\\u0066\\u006A',\n  'flat': '\\u266D',\n  'fllig': '\\uFB02',\n  'fltns': '\\u25B1',\n  'fnof': '\\u0192',\n  'fopf': '\\uD835\\uDD57',\n  'fork': '\\u22D4',\n  'pitchfork': '\\u22D4',\n  'forkv': '\\u2AD9',\n  'fpartint': '\\u2A0D',\n  'frac12': '\\u00BD',\n  'half': '\\u00BD',\n  'frac13': '\\u2153',\n  'frac14': '\\u00BC',\n  'frac15': '\\u2155',\n  'frac16': '\\u2159',\n  'frac18': '\\u215B',\n  'frac23': '\\u2154',\n  'frac25': '\\u2156',\n  'frac34': '\\u00BE',\n  'frac35': '\\u2157',\n  'frac38': '\\u215C',\n  'frac45': '\\u2158',\n  'frac56': '\\u215A',\n  'frac58': '\\u215D',\n  'frac78': '\\u215E',\n  'frasl': '\\u2044',\n  'frown': '\\u2322',\n  'sfrown': '\\u2322',\n  'fscr': '\\uD835\\uDCBB',\n  'gEl': '\\u2A8C',\n  'gtreqqless': '\\u2A8C',\n  'gacute': '\\u01F5',\n  'gamma': '\\u03B3',\n  'gap': '\\u2A86',\n  'gtrapprox': '\\u2A86',\n  'gbreve': '\\u011F',\n  'gcirc': '\\u011D',\n  'gcy': '\\u0433',\n  'gdot': '\\u0121',\n  'gescc': '\\u2AA9',\n  'gesdot': '\\u2A80',\n  'gesdoto': '\\u2A82',\n  'gesdotol': '\\u2A84',\n  'gesl': '\\u22DB\\uFE00',\n  'gesles': '\\u2A94',\n  'gfr': '\\uD835\\uDD24',\n  'gimel': '\\u2137',\n  'gjcy': '\\u0453',\n  'glE': '\\u2A92',\n  'gla': '\\u2AA5',\n  'glj': '\\u2AA4',\n  'gnE': '\\u2269',\n  'gneqq': '\\u2269',\n  'gnap': '\\u2A8A',\n  'gnapprox': '\\u2A8A',\n  'gne': '\\u2A88',\n  'gneq': '\\u2A88',\n  'gnsim': '\\u22E7',\n  'gopf': '\\uD835\\uDD58',\n  'gscr': '\\u210A',\n  'gsime': '\\u2A8E',\n  'gsiml': '\\u2A90',\n  'gtcc': '\\u2AA7',\n  'gtcir': '\\u2A7A',\n  'gtdot': '\\u22D7',\n  'gtrdot': '\\u22D7',\n  'gtlPar': '\\u2995',\n  'gtquest': '\\u2A7C',\n  'gtrarr': '\\u2978',\n  'gvertneqq': '\\u2269\\uFE00',\n  'gvnE': '\\u2269\\uFE00',\n  'hardcy': '\\u044A',\n  'harrcir': '\\u2948',\n  'harrw': '\\u21AD',\n  'leftrightsquigarrow': '\\u21AD',\n  'hbar': '\\u210F',\n  'hslash': '\\u210F',\n  'planck': '\\u210F',\n  'plankv': '\\u210F',\n  'hcirc': '\\u0125',\n  'hearts': '\\u2665',\n  'heartsuit': '\\u2665',\n  'hellip': '\\u2026',\n  'mldr': '\\u2026',\n  'hercon': '\\u22B9',\n  'hfr': '\\uD835\\uDD25',\n  'hksearow': '\\u2925',\n  'searhk': '\\u2925',\n  'hkswarow': '\\u2926',\n  'swarhk': '\\u2926',\n  'hoarr': '\\u21FF',\n  'homtht': '\\u223B',\n  'hookleftarrow': '\\u21A9',\n  'larrhk': '\\u21A9',\n  'hookrightarrow': '\\u21AA',\n  'rarrhk': '\\u21AA',\n  'hopf': '\\uD835\\uDD59',\n  'horbar': '\\u2015',\n  'hscr': '\\uD835\\uDCBD',\n  'hstrok': '\\u0127',\n  'hybull': '\\u2043',\n  'iacute': '\\u00ED',\n  'icirc': '\\u00EE',\n  'icy': '\\u0438',\n  'iecy': '\\u0435',\n  'iexcl': '\\u00A1',\n  'ifr': '\\uD835\\uDD26',\n  'igrave': '\\u00EC',\n  'iiiint': '\\u2A0C',\n  'qint': '\\u2A0C',\n  'iiint': '\\u222D',\n  'tint': '\\u222D',\n  'iinfin': '\\u29DC',\n  'iiota': '\\u2129',\n  'ijlig': '\\u0133',\n  'imacr': '\\u012B',\n  'imath': '\\u0131',\n  'inodot': '\\u0131',\n  'imof': '\\u22B7',\n  'imped': '\\u01B5',\n  'incare': '\\u2105',\n  'infin': '\\u221E',\n  'infintie': '\\u29DD',\n  'intcal': '\\u22BA',\n  'intercal': '\\u22BA',\n  'intlarhk': '\\u2A17',\n  'intprod': '\\u2A3C',\n  'iprod': '\\u2A3C',\n  'iocy': '\\u0451',\n  'iogon': '\\u012F',\n  'iopf': '\\uD835\\uDD5A',\n  'iota': '\\u03B9',\n  'iquest': '\\u00BF',\n  'iscr': '\\uD835\\uDCBE',\n  'isinE': '\\u22F9',\n  'isindot': '\\u22F5',\n  'isins': '\\u22F4',\n  'isinsv': '\\u22F3',\n  'itilde': '\\u0129',\n  'iukcy': '\\u0456',\n  'iuml': '\\u00EF',\n  'jcirc': '\\u0135',\n  'jcy': '\\u0439',\n  'jfr': '\\uD835\\uDD27',\n  'jmath': '\\u0237',\n  'jopf': '\\uD835\\uDD5B',\n  'jscr': '\\uD835\\uDCBF',\n  'jsercy': '\\u0458',\n  'jukcy': '\\u0454',\n  'kappa': '\\u03BA',\n  'kappav': '\\u03F0',\n  'varkappa': '\\u03F0',\n  'kcedil': '\\u0137',\n  'kcy': '\\u043A',\n  'kfr': '\\uD835\\uDD28',\n  'kgreen': '\\u0138',\n  'khcy': '\\u0445',\n  'kjcy': '\\u045C',\n  'kopf': '\\uD835\\uDD5C',\n  'kscr': '\\uD835\\uDCC0',\n  'lAtail': '\\u291B',\n  'lBarr': '\\u290E',\n  'lEg': '\\u2A8B',\n  'lesseqqgtr': '\\u2A8B',\n  'lHar': '\\u2962',\n  'lacute': '\\u013A',\n  'laemptyv': '\\u29B4',\n  'lambda': '\\u03BB',\n  'langd': '\\u2991',\n  'lap': '\\u2A85',\n  'lessapprox': '\\u2A85',\n  'laquo': '\\u00AB',\n  'larrbfs': '\\u291F',\n  'larrfs': '\\u291D',\n  'larrlp': '\\u21AB',\n  'looparrowleft': '\\u21AB',\n  'larrpl': '\\u2939',\n  'larrsim': '\\u2973',\n  'larrtl': '\\u21A2',\n  'leftarrowtail': '\\u21A2',\n  'lat': '\\u2AAB',\n  'latail': '\\u2919',\n  'late': '\\u2AAD',\n  'lates': '\\u2AAD\\uFE00',\n  'lbarr': '\\u290C',\n  'lbbrk': '\\u2772',\n  'lbrace': '\\u007B',\n  'lcub': '\\u007B',\n  'lbrack': '\\u005B',\n  'lsqb': '\\u005B',\n  'lbrke': '\\u298B',\n  'lbrksld': '\\u298F',\n  'lbrkslu': '\\u298D',\n  'lcaron': '\\u013E',\n  'lcedil': '\\u013C',\n  'lcy': '\\u043B',\n  'ldca': '\\u2936',\n  'ldrdhar': '\\u2967',\n  'ldrushar': '\\u294B',\n  'ldsh': '\\u21B2',\n  'le': '\\u2264',\n  'leq': '\\u2264',\n  'leftleftarrows': '\\u21C7',\n  'llarr': '\\u21C7',\n  'leftthreetimes': '\\u22CB',\n  'lthree': '\\u22CB',\n  'lescc': '\\u2AA8',\n  'lesdot': '\\u2A7F',\n  'lesdoto': '\\u2A81',\n  'lesdotor': '\\u2A83',\n  'lesg': '\\u22DA\\uFE00',\n  'lesges': '\\u2A93',\n  'lessdot': '\\u22D6',\n  'ltdot': '\\u22D6',\n  'lfisht': '\\u297C',\n  'lfr': '\\uD835\\uDD29',\n  'lgE': '\\u2A91',\n  'lharul': '\\u296A',\n  'lhblk': '\\u2584',\n  'ljcy': '\\u0459',\n  'llhard': '\\u296B',\n  'lltri': '\\u25FA',\n  'lmidot': '\\u0140',\n  'lmoust': '\\u23B0',\n  'lmoustache': '\\u23B0',\n  'lnE': '\\u2268',\n  'lneqq': '\\u2268',\n  'lnap': '\\u2A89',\n  'lnapprox': '\\u2A89',\n  'lne': '\\u2A87',\n  'lneq': '\\u2A87',\n  'lnsim': '\\u22E6',\n  'loang': '\\u27EC',\n  'loarr': '\\u21FD',\n  'longmapsto': '\\u27FC',\n  'xmap': '\\u27FC',\n  'looparrowright': '\\u21AC',\n  'rarrlp': '\\u21AC',\n  'lopar': '\\u2985',\n  'lopf': '\\uD835\\uDD5D',\n  'loplus': '\\u2A2D',\n  'lotimes': '\\u2A34',\n  'lowast': '\\u2217',\n  'loz': '\\u25CA',\n  'lozenge': '\\u25CA',\n  'lpar': '\\u0028',\n  'lparlt': '\\u2993',\n  'lrhard': '\\u296D',\n  'lrm': '\\u200E',\n  'lrtri': '\\u22BF',\n  'lsaquo': '\\u2039',\n  'lscr': '\\uD835\\uDCC1',\n  'lsime': '\\u2A8D',\n  'lsimg': '\\u2A8F',\n  'lsquor': '\\u201A',\n  'sbquo': '\\u201A',\n  'lstrok': '\\u0142',\n  'ltcc': '\\u2AA6',\n  'ltcir': '\\u2A79',\n  'ltimes': '\\u22C9',\n  'ltlarr': '\\u2976',\n  'ltquest': '\\u2A7B',\n  'ltrPar': '\\u2996',\n  'ltri': '\\u25C3',\n  'triangleleft': '\\u25C3',\n  'lurdshar': '\\u294A',\n  'luruhar': '\\u2966',\n  'lvertneqq': '\\u2268\\uFE00',\n  'lvnE': '\\u2268\\uFE00',\n  'mDDot': '\\u223A',\n  'macr': '\\u00AF',\n  'strns': '\\u00AF',\n  'male': '\\u2642',\n  'malt': '\\u2720',\n  'maltese': '\\u2720',\n  'marker': '\\u25AE',\n  'mcomma': '\\u2A29',\n  'mcy': '\\u043C',\n  'mdash': '\\u2014',\n  'mfr': '\\uD835\\uDD2A',\n  'mho': '\\u2127',\n  'micro': '\\u00B5',\n  'midcir': '\\u2AF0',\n  'minus': '\\u2212',\n  'minusdu': '\\u2A2A',\n  'mlcp': '\\u2ADB',\n  'models': '\\u22A7',\n  'mopf': '\\uD835\\uDD5E',\n  'mscr': '\\uD835\\uDCC2',\n  'mu': '\\u03BC',\n  'multimap': '\\u22B8',\n  'mumap': '\\u22B8',\n  'nGg': '\\u22D9\\u0338',\n  'nGt': '\\u226B\\u20D2',\n  'nLeftarrow': '\\u21CD',\n  'nlArr': '\\u21CD',\n  'nLeftrightarrow': '\\u21CE',\n  'nhArr': '\\u21CE',\n  'nLl': '\\u22D8\\u0338',\n  'nLt': '\\u226A\\u20D2',\n  'nRightarrow': '\\u21CF',\n  'nrArr': '\\u21CF',\n  'nVDash': '\\u22AF',\n  'nVdash': '\\u22AE',\n  'nacute': '\\u0144',\n  'nang': '\\u2220\\u20D2',\n  'napE': '\\u2A70\\u0338',\n  'napid': '\\u224B\\u0338',\n  'napos': '\\u0149',\n  'natur': '\\u266E',\n  'natural': '\\u266E',\n  'ncap': '\\u2A43',\n  'ncaron': '\\u0148',\n  'ncedil': '\\u0146',\n  'ncongdot': '\\u2A6D\\u0338',\n  'ncup': '\\u2A42',\n  'ncy': '\\u043D',\n  'ndash': '\\u2013',\n  'neArr': '\\u21D7',\n  'nearhk': '\\u2924',\n  'nedot': '\\u2250\\u0338',\n  'nesear': '\\u2928',\n  'toea': '\\u2928',\n  'nfr': '\\uD835\\uDD2B',\n  'nharr': '\\u21AE',\n  'nleftrightarrow': '\\u21AE',\n  'nhpar': '\\u2AF2',\n  'nis': '\\u22FC',\n  'nisd': '\\u22FA',\n  'njcy': '\\u045A',\n  'nlE': '\\u2266\\u0338',\n  'nleqq': '\\u2266\\u0338',\n  'nlarr': '\\u219A',\n  'nleftarrow': '\\u219A',\n  'nldr': '\\u2025',\n  'nopf': '\\uD835\\uDD5F',\n  'not': '\\u00AC',\n  'notinE': '\\u22F9\\u0338',\n  'notindot': '\\u22F5\\u0338',\n  'notinvb': '\\u22F7',\n  'notinvc': '\\u22F6',\n  'notnivb': '\\u22FE',\n  'notnivc': '\\u22FD',\n  'nparsl': '\\u2AFD\\u20E5',\n  'npart': '\\u2202\\u0338',\n  'npolint': '\\u2A14',\n  'nrarr': '\\u219B',\n  'nrightarrow': '\\u219B',\n  'nrarrc': '\\u2933\\u0338',\n  'nrarrw': '\\u219D\\u0338',\n  'nscr': '\\uD835\\uDCC3',\n  'nsub': '\\u2284',\n  'nsubE': '\\u2AC5\\u0338',\n  'nsubseteqq': '\\u2AC5\\u0338',\n  'nsup': '\\u2285',\n  'nsupE': '\\u2AC6\\u0338',\n  'nsupseteqq': '\\u2AC6\\u0338',\n  'ntilde': '\\u00F1',\n  'nu': '\\u03BD',\n  'num': '\\u0023',\n  'numero': '\\u2116',\n  'numsp': '\\u2007',\n  'nvDash': '\\u22AD',\n  'nvHarr': '\\u2904',\n  'nvap': '\\u224D\\u20D2',\n  'nvdash': '\\u22AC',\n  'nvge': '\\u2265\\u20D2',\n  'nvgt': '\\u003E\\u20D2',\n  'nvinfin': '\\u29DE',\n  'nvlArr': '\\u2902',\n  'nvle': '\\u2264\\u20D2',\n  'nvlt': '\\u003C\\u20D2',\n  'nvltrie': '\\u22B4\\u20D2',\n  'nvrArr': '\\u2903',\n  'nvrtrie': '\\u22B5\\u20D2',\n  'nvsim': '\\u223C\\u20D2',\n  'nwArr': '\\u21D6',\n  'nwarhk': '\\u2923',\n  'nwnear': '\\u2927',\n  'oacute': '\\u00F3',\n  'ocirc': '\\u00F4',\n  'ocy': '\\u043E',\n  'odblac': '\\u0151',\n  'odiv': '\\u2A38',\n  'odsold': '\\u29BC',\n  'oelig': '\\u0153',\n  'ofcir': '\\u29BF',\n  'ofr': '\\uD835\\uDD2C',\n  'ogon': '\\u02DB',\n  'ograve': '\\u00F2',\n  'ogt': '\\u29C1',\n  'ohbar': '\\u29B5',\n  'olcir': '\\u29BE',\n  'olcross': '\\u29BB',\n  'olt': '\\u29C0',\n  'omacr': '\\u014D',\n  'omega': '\\u03C9',\n  'omicron': '\\u03BF',\n  'omid': '\\u29B6',\n  'oopf': '\\uD835\\uDD60',\n  'opar': '\\u29B7',\n  'operp': '\\u29B9',\n  'or': '\\u2228',\n  'vee': '\\u2228',\n  'ord': '\\u2A5D',\n  'order': '\\u2134',\n  'orderof': '\\u2134',\n  'oscr': '\\u2134',\n  'ordf': '\\u00AA',\n  'ordm': '\\u00BA',\n  'origof': '\\u22B6',\n  'oror': '\\u2A56',\n  'orslope': '\\u2A57',\n  'orv': '\\u2A5B',\n  'oslash': '\\u00F8',\n  'osol': '\\u2298',\n  'otilde': '\\u00F5',\n  'otimesas': '\\u2A36',\n  'ouml': '\\u00F6',\n  'ovbar': '\\u233D',\n  'para': '\\u00B6',\n  'parsim': '\\u2AF3',\n  'parsl': '\\u2AFD',\n  'pcy': '\\u043F',\n  'percnt': '\\u0025',\n  'period': '\\u002E',\n  'permil': '\\u2030',\n  'pertenk': '\\u2031',\n  'pfr': '\\uD835\\uDD2D',\n  'phi': '\\u03C6',\n  'phiv': '\\u03D5',\n  'straightphi': '\\u03D5',\n  'varphi': '\\u03D5',\n  'phone': '\\u260E',\n  'pi': '\\u03C0',\n  'piv': '\\u03D6',\n  'varpi': '\\u03D6',\n  'planckh': '\\u210E',\n  'plus': '\\u002B',\n  'plusacir': '\\u2A23',\n  'pluscir': '\\u2A22',\n  'plusdu': '\\u2A25',\n  'pluse': '\\u2A72',\n  'plussim': '\\u2A26',\n  'plustwo': '\\u2A27',\n  'pointint': '\\u2A15',\n  'popf': '\\uD835\\uDD61',\n  'pound': '\\u00A3',\n  'prE': '\\u2AB3',\n  'prap': '\\u2AB7',\n  'precapprox': '\\u2AB7',\n  'precnapprox': '\\u2AB9',\n  'prnap': '\\u2AB9',\n  'precneqq': '\\u2AB5',\n  'prnE': '\\u2AB5',\n  'precnsim': '\\u22E8',\n  'prnsim': '\\u22E8',\n  'prime': '\\u2032',\n  'profalar': '\\u232E',\n  'profline': '\\u2312',\n  'profsurf': '\\u2313',\n  'prurel': '\\u22B0',\n  'pscr': '\\uD835\\uDCC5',\n  'psi': '\\u03C8',\n  'puncsp': '\\u2008',\n  'qfr': '\\uD835\\uDD2E',\n  'qopf': '\\uD835\\uDD62',\n  'qprime': '\\u2057',\n  'qscr': '\\uD835\\uDCC6',\n  'quatint': '\\u2A16',\n  'quest': '\\u003F',\n  'rAtail': '\\u291C',\n  'rHar': '\\u2964',\n  'race': '\\u223D\\u0331',\n  'racute': '\\u0155',\n  'raemptyv': '\\u29B3',\n  'rangd': '\\u2992',\n  'range': '\\u29A5',\n  'raquo': '\\u00BB',\n  'rarrap': '\\u2975',\n  'rarrbfs': '\\u2920',\n  'rarrc': '\\u2933',\n  'rarrfs': '\\u291E',\n  'rarrpl': '\\u2945',\n  'rarrsim': '\\u2974',\n  'rarrtl': '\\u21A3',\n  'rightarrowtail': '\\u21A3',\n  'rarrw': '\\u219D',\n  'rightsquigarrow': '\\u219D',\n  'ratail': '\\u291A',\n  'ratio': '\\u2236',\n  'rbbrk': '\\u2773',\n  'rbrace': '\\u007D',\n  'rcub': '\\u007D',\n  'rbrack': '\\u005D',\n  'rsqb': '\\u005D',\n  'rbrke': '\\u298C',\n  'rbrksld': '\\u298E',\n  'rbrkslu': '\\u2990',\n  'rcaron': '\\u0159',\n  'rcedil': '\\u0157',\n  'rcy': '\\u0440',\n  'rdca': '\\u2937',\n  'rdldhar': '\\u2969',\n  'rdsh': '\\u21B3',\n  'rect': '\\u25AD',\n  'rfisht': '\\u297D',\n  'rfr': '\\uD835\\uDD2F',\n  'rharul': '\\u296C',\n  'rho': '\\u03C1',\n  'rhov': '\\u03F1',\n  'varrho': '\\u03F1',\n  'rightrightarrows': '\\u21C9',\n  'rrarr': '\\u21C9',\n  'rightthreetimes': '\\u22CC',\n  'rthree': '\\u22CC',\n  'ring': '\\u02DA',\n  'rlm': '\\u200F',\n  'rmoust': '\\u23B1',\n  'rmoustache': '\\u23B1',\n  'rnmid': '\\u2AEE',\n  'roang': '\\u27ED',\n  'roarr': '\\u21FE',\n  'ropar': '\\u2986',\n  'ropf': '\\uD835\\uDD63',\n  'roplus': '\\u2A2E',\n  'rotimes': '\\u2A35',\n  'rpar': '\\u0029',\n  'rpargt': '\\u2994',\n  'rppolint': '\\u2A12',\n  'rsaquo': '\\u203A',\n  'rscr': '\\uD835\\uDCC7',\n  'rtimes': '\\u22CA',\n  'rtri': '\\u25B9',\n  'triangleright': '\\u25B9',\n  'rtriltri': '\\u29CE',\n  'ruluhar': '\\u2968',\n  'rx': '\\u211E',\n  'sacute': '\\u015B',\n  'scE': '\\u2AB4',\n  'scap': '\\u2AB8',\n  'succapprox': '\\u2AB8',\n  'scaron': '\\u0161',\n  'scedil': '\\u015F',\n  'scirc': '\\u015D',\n  'scnE': '\\u2AB6',\n  'succneqq': '\\u2AB6',\n  'scnap': '\\u2ABA',\n  'succnapprox': '\\u2ABA',\n  'scnsim': '\\u22E9',\n  'succnsim': '\\u22E9',\n  'scpolint': '\\u2A13',\n  'scy': '\\u0441',\n  'sdot': '\\u22C5',\n  'sdote': '\\u2A66',\n  'seArr': '\\u21D8',\n  'sect': '\\u00A7',\n  'semi': '\\u003B',\n  'seswar': '\\u2929',\n  'tosa': '\\u2929',\n  'sext': '\\u2736',\n  'sfr': '\\uD835\\uDD30',\n  'sharp': '\\u266F',\n  'shchcy': '\\u0449',\n  'shcy': '\\u0448',\n  'shy': '\\u00AD',\n  'sigma': '\\u03C3',\n  'sigmaf': '\\u03C2',\n  'sigmav': '\\u03C2',\n  'varsigma': '\\u03C2',\n  'simdot': '\\u2A6A',\n  'simg': '\\u2A9E',\n  'simgE': '\\u2AA0',\n  'siml': '\\u2A9D',\n  'simlE': '\\u2A9F',\n  'simne': '\\u2246',\n  'simplus': '\\u2A24',\n  'simrarr': '\\u2972',\n  'smashp': '\\u2A33',\n  'smeparsl': '\\u29E4',\n  'smile': '\\u2323',\n  'ssmile': '\\u2323',\n  'smt': '\\u2AAA',\n  'smte': '\\u2AAC',\n  'smtes': '\\u2AAC\\uFE00',\n  'softcy': '\\u044C',\n  'sol': '\\u002F',\n  'solb': '\\u29C4',\n  'solbar': '\\u233F',\n  'sopf': '\\uD835\\uDD64',\n  'spades': '\\u2660',\n  'spadesuit': '\\u2660',\n  'sqcaps': '\\u2293\\uFE00',\n  'sqcups': '\\u2294\\uFE00',\n  'sscr': '\\uD835\\uDCC8',\n  'star': '\\u2606',\n  'sub': '\\u2282',\n  'subset': '\\u2282',\n  'subE': '\\u2AC5',\n  'subseteqq': '\\u2AC5',\n  'subdot': '\\u2ABD',\n  'subedot': '\\u2AC3',\n  'submult': '\\u2AC1',\n  'subnE': '\\u2ACB',\n  'subsetneqq': '\\u2ACB',\n  'subne': '\\u228A',\n  'subsetneq': '\\u228A',\n  'subplus': '\\u2ABF',\n  'subrarr': '\\u2979',\n  'subsim': '\\u2AC7',\n  'subsub': '\\u2AD5',\n  'subsup': '\\u2AD3',\n  'sung': '\\u266A',\n  'sup1': '\\u00B9',\n  'sup2': '\\u00B2',\n  'sup3': '\\u00B3',\n  'supE': '\\u2AC6',\n  'supseteqq': '\\u2AC6',\n  'supdot': '\\u2ABE',\n  'supdsub': '\\u2AD8',\n  'supedot': '\\u2AC4',\n  'suphsol': '\\u27C9',\n  'suphsub': '\\u2AD7',\n  'suplarr': '\\u297B',\n  'supmult': '\\u2AC2',\n  'supnE': '\\u2ACC',\n  'supsetneqq': '\\u2ACC',\n  'supne': '\\u228B',\n  'supsetneq': '\\u228B',\n  'supplus': '\\u2AC0',\n  'supsim': '\\u2AC8',\n  'supsub': '\\u2AD4',\n  'supsup': '\\u2AD6',\n  'swArr': '\\u21D9',\n  'swnwar': '\\u292A',\n  'szlig': '\\u00DF',\n  'target': '\\u2316',\n  'tau': '\\u03C4',\n  'tcaron': '\\u0165',\n  'tcedil': '\\u0163',\n  'tcy': '\\u0442',\n  'telrec': '\\u2315',\n  'tfr': '\\uD835\\uDD31',\n  'theta': '\\u03B8',\n  'thetasym': '\\u03D1',\n  'thetav': '\\u03D1',\n  'vartheta': '\\u03D1',\n  'thorn': '\\u00FE',\n  'times': '\\u00D7',\n  'timesbar': '\\u2A31',\n  'timesd': '\\u2A30',\n  'topbot': '\\u2336',\n  'topcir': '\\u2AF1',\n  'topf': '\\uD835\\uDD65',\n  'topfork': '\\u2ADA',\n  'tprime': '\\u2034',\n  'triangle': '\\u25B5',\n  'utri': '\\u25B5',\n  'triangleq': '\\u225C',\n  'trie': '\\u225C',\n  'tridot': '\\u25EC',\n  'triminus': '\\u2A3A',\n  'triplus': '\\u2A39',\n  'trisb': '\\u29CD',\n  'tritime': '\\u2A3B',\n  'trpezium': '\\u23E2',\n  'tscr': '\\uD835\\uDCC9',\n  'tscy': '\\u0446',\n  'tshcy': '\\u045B',\n  'tstrok': '\\u0167',\n  'uHar': '\\u2963',\n  'uacute': '\\u00FA',\n  'ubrcy': '\\u045E',\n  'ubreve': '\\u016D',\n  'ucirc': '\\u00FB',\n  'ucy': '\\u0443',\n  'udblac': '\\u0171',\n  'ufisht': '\\u297E',\n  'ufr': '\\uD835\\uDD32',\n  'ugrave': '\\u00F9',\n  'uhblk': '\\u2580',\n  'ulcorn': '\\u231C',\n  'ulcorner': '\\u231C',\n  'ulcrop': '\\u230F',\n  'ultri': '\\u25F8',\n  'umacr': '\\u016B',\n  'uogon': '\\u0173',\n  'uopf': '\\uD835\\uDD66',\n  'upsi': '\\u03C5',\n  'upsilon': '\\u03C5',\n  'upuparrows': '\\u21C8',\n  'uuarr': '\\u21C8',\n  'urcorn': '\\u231D',\n  'urcorner': '\\u231D',\n  'urcrop': '\\u230E',\n  'uring': '\\u016F',\n  'urtri': '\\u25F9',\n  'uscr': '\\uD835\\uDCCA',\n  'utdot': '\\u22F0',\n  'utilde': '\\u0169',\n  'uuml': '\\u00FC',\n  'uwangle': '\\u29A7',\n  'vBar': '\\u2AE8',\n  'vBarv': '\\u2AE9',\n  'vangrt': '\\u299C',\n  'varsubsetneq': '\\u228A\\uFE00',\n  'vsubne': '\\u228A\\uFE00',\n  'varsubsetneqq': '\\u2ACB\\uFE00',\n  'vsubnE': '\\u2ACB\\uFE00',\n  'varsupsetneq': '\\u228B\\uFE00',\n  'vsupne': '\\u228B\\uFE00',\n  'varsupsetneqq': '\\u2ACC\\uFE00',\n  'vsupnE': '\\u2ACC\\uFE00',\n  'vcy': '\\u0432',\n  'veebar': '\\u22BB',\n  'veeeq': '\\u225A',\n  'vellip': '\\u22EE',\n  'vfr': '\\uD835\\uDD33',\n  'vopf': '\\uD835\\uDD67',\n  'vscr': '\\uD835\\uDCCB',\n  'vzigzag': '\\u299A',\n  'wcirc': '\\u0175',\n  'wedbar': '\\u2A5F',\n  'wedgeq': '\\u2259',\n  'weierp': '\\u2118',\n  'wp': '\\u2118',\n  'wfr': '\\uD835\\uDD34',\n  'wopf': '\\uD835\\uDD68',\n  'wscr': '\\uD835\\uDCCC',\n  'xfr': '\\uD835\\uDD35',\n  'xi': '\\u03BE',\n  'xnis': '\\u22FB',\n  'xopf': '\\uD835\\uDD69',\n  'xscr': '\\uD835\\uDCCD',\n  'yacute': '\\u00FD',\n  'yacy': '\\u044F',\n  'ycirc': '\\u0177',\n  'ycy': '\\u044B',\n  'yen': '\\u00A5',\n  'yfr': '\\uD835\\uDD36',\n  'yicy': '\\u0457',\n  'yopf': '\\uD835\\uDD6A',\n  'yscr': '\\uD835\\uDCCE',\n  'yucy': '\\u044E',\n  'yuml': '\\u00FF',\n  'zacute': '\\u017A',\n  'zcaron': '\\u017E',\n  'zcy': '\\u0437',\n  'zdot': '\\u017C',\n  'zeta': '\\u03B6',\n  'zfr': '\\uD835\\uDD37',\n  'zhcy': '\\u0436',\n  'zigrarr': '\\u21DD',\n  'zopf': '\\uD835\\uDD6B',\n  'zscr': '\\uD835\\uDCCF',\n  'zwj': '\\u200D',\n  'zwnj': '\\u200C'\n};\nconst NGSP_UNICODE = '\\uE500';\nNAMED_ENTITIES['ngsp'] = NGSP_UNICODE;\nclass TokenizeResult {\n  tokens;\n  errors;\n  nonNormalizedIcuExpressions;\n  constructor(tokens, errors, nonNormalizedIcuExpressions) {\n    this.tokens = tokens;\n    this.errors = errors;\n    this.nonNormalizedIcuExpressions = nonNormalizedIcuExpressions;\n  }\n}\nfunction tokenize(source, url, getTagDefinition, options = {}) {\n  const tokenizer = new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options);\n  tokenizer.tokenize();\n  return new TokenizeResult(mergeTextTokens(tokenizer.tokens), tokenizer.errors, tokenizer.nonNormalizedIcuExpressions);\n}\nconst _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\nfunction _unexpectedCharacterErrorMsg(charCode) {\n  const char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);\n  return `Unexpected character \"${char}\"`;\n}\nfunction _unknownEntityErrorMsg(entitySrc) {\n  return `Unknown entity \"${entitySrc}\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax`;\n}\nfunction _unparsableEntityErrorMsg(type, entityStr) {\n  return `Unable to parse entity \"${entityStr}\" - ${type} character reference entities must end with \";\"`;\n}\nvar CharacterReferenceType;\n(function (CharacterReferenceType) {\n  CharacterReferenceType[\"HEX\"] = \"hexadecimal\";\n  CharacterReferenceType[\"DEC\"] = \"decimal\";\n})(CharacterReferenceType || (CharacterReferenceType = {}));\nconst SUPPORTED_BLOCKS = ['@if', '@else', '@for', '@switch', '@case', '@default', '@empty', '@defer', '@placeholder', '@loading', '@error'];\nconst INTERPOLATION = {\n  start: '{{',\n  end: '}}'\n};\nclass _Tokenizer {\n  _getTagDefinition;\n  _cursor;\n  _tokenizeIcu;\n  _leadingTriviaCodePoints;\n  _currentTokenStart = null;\n  _currentTokenType = null;\n  _expansionCaseStack = [];\n  _openDirectiveCount = 0;\n  _inInterpolation = false;\n  _preserveLineEndings;\n  _i18nNormalizeLineEndingsInICUs;\n  _tokenizeBlocks;\n  _tokenizeLet;\n  _selectorlessEnabled;\n  tokens = [];\n  errors = [];\n  nonNormalizedIcuExpressions = [];\n  constructor(_file, _getTagDefinition, options) {\n    this._getTagDefinition = _getTagDefinition;\n    this._tokenizeIcu = options.tokenizeExpansionForms || false;\n    this._leadingTriviaCodePoints = options.leadingTriviaChars && options.leadingTriviaChars.map(c => c.codePointAt(0) || 0);\n    const range = options.range || {\n      endPos: _file.content.length,\n      startPos: 0,\n      startLine: 0,\n      startCol: 0\n    };\n    this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) : new PlainCharacterCursor(_file, range);\n    this._preserveLineEndings = options.preserveLineEndings || false;\n    this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;\n    this._tokenizeBlocks = options.tokenizeBlocks ?? true;\n    this._tokenizeLet = options.tokenizeLet ?? true;\n    this._selectorlessEnabled = options.selectorlessEnabled ?? false;\n    try {\n      this._cursor.init();\n    } catch (e) {\n      this.handleError(e);\n    }\n  }\n  _processCarriageReturns(content) {\n    if (this._preserveLineEndings) {\n      return content;\n    }\n    return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n  }\n  tokenize() {\n    while (this._cursor.peek() !== $EOF) {\n      const start = this._cursor.clone();\n      try {\n        if (this._attemptCharCode($LT)) {\n          if (this._attemptCharCode($BANG)) {\n            if (this._attemptCharCode($LBRACKET)) {\n              this._consumeCdata(start);\n            } else if (this._attemptCharCode($MINUS)) {\n              this._consumeComment(start);\n            } else {\n              this._consumeDocType(start);\n            }\n          } else if (this._attemptCharCode($SLASH)) {\n            this._consumeTagClose(start);\n          } else {\n            this._consumeTagOpen(start);\n          }\n        } else if (this._tokenizeLet && this._cursor.peek() === $AT && !this._inInterpolation && this._isLetStart()) {\n          this._consumeLetDeclaration(start);\n        } else if (this._tokenizeBlocks && this._isBlockStart()) {\n          this._consumeBlockStart(start);\n        } else if (this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansionCase() && !this._isInExpansionForm() && this._attemptCharCode($RBRACE)) {\n          this._consumeBlockEnd(start);\n        } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n          this._consumeWithInterpolation(5, 8, () => this._isTextEnd(), () => this._isTagStart());\n        }\n      } catch (e) {\n        this.handleError(e);\n      }\n    }\n    this._beginToken(41);\n    this._endToken([]);\n  }\n  _getBlockName() {\n    let spacesInNameAllowed = false;\n    const nameCursor = this._cursor.clone();\n    this._attemptCharCodeUntilFn(code => {\n      if (isWhitespace(code)) {\n        return !spacesInNameAllowed;\n      }\n      if (isBlockNameChar(code)) {\n        spacesInNameAllowed = true;\n        return false;\n      }\n      return true;\n    });\n    return this._cursor.getChars(nameCursor).trim();\n  }\n  _consumeBlockStart(start) {\n    this._requireCharCode($AT);\n    this._beginToken(24, start);\n    const startToken = this._endToken([this._getBlockName()]);\n    if (this._cursor.peek() === $LPAREN) {\n      this._cursor.advance();\n      this._consumeBlockParameters();\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      if (this._attemptCharCode($RPAREN)) {\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      } else {\n        startToken.type = 28;\n        return;\n      }\n    }\n    if (this._attemptCharCode($LBRACE)) {\n      this._beginToken(25);\n      this._endToken([]);\n    } else {\n      startToken.type = 28;\n    }\n  }\n  _consumeBlockEnd(start) {\n    this._beginToken(26, start);\n    this._endToken([]);\n  }\n  _consumeBlockParameters() {\n    this._attemptCharCodeUntilFn(isBlockParameterChar);\n    while (this._cursor.peek() !== $RPAREN && this._cursor.peek() !== $EOF) {\n      this._beginToken(27);\n      const start = this._cursor.clone();\n      let inQuote = null;\n      let openParens = 0;\n      while (this._cursor.peek() !== $SEMICOLON && this._cursor.peek() !== $EOF || inQuote !== null) {\n        const char = this._cursor.peek();\n        if (char === $BACKSLASH) {\n          this._cursor.advance();\n        } else if (char === inQuote) {\n          inQuote = null;\n        } else if (inQuote === null && isQuote(char)) {\n          inQuote = char;\n        } else if (char === $LPAREN && inQuote === null) {\n          openParens++;\n        } else if (char === $RPAREN && inQuote === null) {\n          if (openParens === 0) {\n            break;\n          } else if (openParens > 0) {\n            openParens--;\n          }\n        }\n        this._cursor.advance();\n      }\n      this._endToken([this._cursor.getChars(start)]);\n      this._attemptCharCodeUntilFn(isBlockParameterChar);\n    }\n  }\n  _consumeLetDeclaration(start) {\n    this._requireStr('@let');\n    this._beginToken(29, start);\n    if (isWhitespace(this._cursor.peek())) {\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n    } else {\n      const token = this._endToken([this._cursor.getChars(start)]);\n      token.type = 32;\n      return;\n    }\n    const startToken = this._endToken([this._getLetDeclarationName()]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    if (!this._attemptCharCode($EQ)) {\n      startToken.type = 32;\n      return;\n    }\n    this._attemptCharCodeUntilFn(code => isNotWhitespace(code) && !isNewLine(code));\n    this._consumeLetDeclarationValue();\n    const endChar = this._cursor.peek();\n    if (endChar === $SEMICOLON) {\n      this._beginToken(31);\n      this._endToken([]);\n      this._cursor.advance();\n    } else {\n      startToken.type = 32;\n      startToken.sourceSpan = this._cursor.getSpan(start);\n    }\n  }\n  _getLetDeclarationName() {\n    const nameCursor = this._cursor.clone();\n    let allowDigit = false;\n    this._attemptCharCodeUntilFn(code => {\n      if (isAsciiLetter(code) || code === $$ || code === $_ || allowDigit && isDigit(code)) {\n        allowDigit = true;\n        return false;\n      }\n      return true;\n    });\n    return this._cursor.getChars(nameCursor).trim();\n  }\n  _consumeLetDeclarationValue() {\n    const start = this._cursor.clone();\n    this._beginToken(30, start);\n    while (this._cursor.peek() !== $EOF) {\n      const char = this._cursor.peek();\n      if (char === $SEMICOLON) {\n        break;\n      }\n      if (isQuote(char)) {\n        this._cursor.advance();\n        this._attemptCharCodeUntilFn(inner => {\n          if (inner === $BACKSLASH) {\n            this._cursor.advance();\n            return false;\n          }\n          return inner === char;\n        });\n      }\n      this._cursor.advance();\n    }\n    this._endToken([this._cursor.getChars(start)]);\n  }\n  _tokenizeExpansionForm() {\n    if (this.isExpansionFormStart()) {\n      this._consumeExpansionFormStart();\n      return true;\n    }\n    if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {\n      this._consumeExpansionCaseStart();\n      return true;\n    }\n    if (this._cursor.peek() === $RBRACE) {\n      if (this._isInExpansionCase()) {\n        this._consumeExpansionCaseEnd();\n        return true;\n      }\n      if (this._isInExpansionForm()) {\n        this._consumeExpansionFormEnd();\n        return true;\n      }\n    }\n    return false;\n  }\n  _beginToken(type, start = this._cursor.clone()) {\n    this._currentTokenStart = start;\n    this._currentTokenType = type;\n  }\n  _endToken(parts, end) {\n    if (this._currentTokenStart === null) {\n      throw new ParseError(this._cursor.getSpan(end), 'Programming error - attempted to end a token when there was no start to the token');\n    }\n    if (this._currentTokenType === null) {\n      throw new ParseError(this._cursor.getSpan(this._currentTokenStart), 'Programming error - attempted to end a token which has no token type');\n    }\n    const token = {\n      type: this._currentTokenType,\n      parts,\n      sourceSpan: (end ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints)\n    };\n    this.tokens.push(token);\n    this._currentTokenStart = null;\n    this._currentTokenType = null;\n    return token;\n  }\n  _createError(msg, span) {\n    if (this._isInExpansionForm()) {\n      msg += ` (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)`;\n    }\n    const error = new ParseError(span, msg);\n    this._currentTokenStart = null;\n    this._currentTokenType = null;\n    return error;\n  }\n  handleError(e) {\n    if (e instanceof CursorError) {\n      e = this._createError(e.msg, this._cursor.getSpan(e.cursor));\n    }\n    if (e instanceof ParseError) {\n      this.errors.push(e);\n    } else {\n      throw e;\n    }\n  }\n  _attemptCharCode(charCode) {\n    if (this._cursor.peek() === charCode) {\n      this._cursor.advance();\n      return true;\n    }\n    return false;\n  }\n  _attemptCharCodeCaseInsensitive(charCode) {\n    if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {\n      this._cursor.advance();\n      return true;\n    }\n    return false;\n  }\n  _requireCharCode(charCode) {\n    const location = this._cursor.clone();\n    if (!this._attemptCharCode(charCode)) {\n      throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n    }\n  }\n  _attemptStr(chars) {\n    const len = chars.length;\n    if (this._cursor.charsLeft() < len) {\n      return false;\n    }\n    const initialPosition = this._cursor.clone();\n    for (let i = 0; i < len; i++) {\n      if (!this._attemptCharCode(chars.charCodeAt(i))) {\n        this._cursor = initialPosition;\n        return false;\n      }\n    }\n    return true;\n  }\n  _attemptStrCaseInsensitive(chars) {\n    for (let i = 0; i < chars.length; i++) {\n      if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _requireStr(chars) {\n    const location = this._cursor.clone();\n    if (!this._attemptStr(chars)) {\n      throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n    }\n  }\n  _attemptCharCodeUntilFn(predicate) {\n    while (!predicate(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n  }\n  _requireCharCodeUntilFn(predicate, len) {\n    const start = this._cursor.clone();\n    this._attemptCharCodeUntilFn(predicate);\n    if (this._cursor.diff(start) < len) {\n      throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n    }\n  }\n  _attemptUntilChar(char) {\n    while (this._cursor.peek() !== char) {\n      this._cursor.advance();\n    }\n  }\n  _readChar() {\n    const char = String.fromCodePoint(this._cursor.peek());\n    this._cursor.advance();\n    return char;\n  }\n  _peekStr(chars) {\n    const len = chars.length;\n    if (this._cursor.charsLeft() < len) {\n      return false;\n    }\n    const cursor = this._cursor.clone();\n    for (let i = 0; i < len; i++) {\n      if (cursor.peek() !== chars.charCodeAt(i)) {\n        return false;\n      }\n      cursor.advance();\n    }\n    return true;\n  }\n  _isBlockStart() {\n    return this._cursor.peek() === $AT && SUPPORTED_BLOCKS.some(blockName => this._peekStr(blockName));\n  }\n  _isLetStart() {\n    return this._cursor.peek() === $AT && this._peekStr('@let');\n  }\n  _consumeEntity(textTokenType) {\n    this._beginToken(9);\n    const start = this._cursor.clone();\n    this._cursor.advance();\n    if (this._attemptCharCode($HASH)) {\n      const isHex = this._attemptCharCode($x) || this._attemptCharCode($X);\n      const codeStart = this._cursor.clone();\n      this._attemptCharCodeUntilFn(isDigitEntityEnd);\n      if (this._cursor.peek() != $SEMICOLON) {\n        this._cursor.advance();\n        const entityType = isHex ? CharacterReferenceType.HEX : CharacterReferenceType.DEC;\n        throw this._createError(_unparsableEntityErrorMsg(entityType, this._cursor.getChars(start)), this._cursor.getSpan());\n      }\n      const strNum = this._cursor.getChars(codeStart);\n      this._cursor.advance();\n      try {\n        const charCode = parseInt(strNum, isHex ? 16 : 10);\n        this._endToken([String.fromCodePoint(charCode), this._cursor.getChars(start)]);\n      } catch {\n        throw this._createError(_unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());\n      }\n    } else {\n      const nameStart = this._cursor.clone();\n      this._attemptCharCodeUntilFn(isNamedEntityEnd);\n      if (this._cursor.peek() != $SEMICOLON) {\n        this._beginToken(textTokenType, start);\n        this._cursor = nameStart;\n        this._endToken(['&']);\n      } else {\n        const name = this._cursor.getChars(nameStart);\n        this._cursor.advance();\n        const char = NAMED_ENTITIES.hasOwnProperty(name) && NAMED_ENTITIES[name];\n        if (!char) {\n          throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));\n        }\n        this._endToken([char, `&${name};`]);\n      }\n    }\n  }\n  _consumeRawText(consumeEntities, endMarkerPredicate) {\n    this._beginToken(consumeEntities ? 6 : 7);\n    const parts = [];\n    while (true) {\n      const tagCloseStart = this._cursor.clone();\n      const foundEndMarker = endMarkerPredicate();\n      this._cursor = tagCloseStart;\n      if (foundEndMarker) {\n        break;\n      }\n      if (consumeEntities && this._cursor.peek() === $AMPERSAND) {\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n        parts.length = 0;\n        this._consumeEntity(6);\n        this._beginToken(6);\n      } else {\n        parts.push(this._readChar());\n      }\n    }\n    this._endToken([this._processCarriageReturns(parts.join(''))]);\n  }\n  _consumeComment(start) {\n    this._beginToken(10, start);\n    this._requireCharCode($MINUS);\n    this._endToken([]);\n    this._consumeRawText(false, () => this._attemptStr('-->'));\n    this._beginToken(11);\n    this._requireStr('-->');\n    this._endToken([]);\n  }\n  _consumeCdata(start) {\n    this._beginToken(12, start);\n    this._requireStr('CDATA[');\n    this._endToken([]);\n    this._consumeRawText(false, () => this._attemptStr(']]>'));\n    this._beginToken(13);\n    this._requireStr(']]>');\n    this._endToken([]);\n  }\n  _consumeDocType(start) {\n    this._beginToken(18, start);\n    const contentStart = this._cursor.clone();\n    this._attemptUntilChar($GT);\n    const content = this._cursor.getChars(contentStart);\n    this._cursor.advance();\n    this._endToken([content]);\n  }\n  _consumePrefixAndName(endPredicate) {\n    const nameOrPrefixStart = this._cursor.clone();\n    let prefix = '';\n    while (this._cursor.peek() !== $COLON && !isPrefixEnd(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n    let nameStart;\n    if (this._cursor.peek() === $COLON) {\n      prefix = this._cursor.getChars(nameOrPrefixStart);\n      this._cursor.advance();\n      nameStart = this._cursor.clone();\n    } else {\n      nameStart = nameOrPrefixStart;\n    }\n    this._requireCharCodeUntilFn(endPredicate, prefix === '' ? 0 : 1);\n    const name = this._cursor.getChars(nameStart);\n    return [prefix, name];\n  }\n  _consumeTagOpen(start) {\n    let tagName;\n    let prefix;\n    let closingTagName;\n    let openToken;\n    try {\n      if (this._selectorlessEnabled && isSelectorlessNameStart(this._cursor.peek())) {\n        openToken = this._consumeComponentOpenStart(start);\n        [closingTagName, prefix, tagName] = openToken.parts;\n        if (prefix) {\n          closingTagName += `:${prefix}`;\n        }\n        if (tagName) {\n          closingTagName += `:${tagName}`;\n        }\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      } else {\n        if (!isAsciiLetter(this._cursor.peek())) {\n          throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n        }\n        openToken = this._consumeTagOpenStart(start);\n        prefix = openToken.parts[0];\n        tagName = closingTagName = openToken.parts[1];\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      }\n      while (!isAttributeTerminator(this._cursor.peek())) {\n        if (this._selectorlessEnabled && this._cursor.peek() === $AT) {\n          const start = this._cursor.clone();\n          const nameStart = start.clone();\n          nameStart.advance();\n          if (isSelectorlessNameStart(nameStart.peek())) {\n            this._consumeDirective(start, nameStart);\n          }\n        } else {\n          this._consumeAttribute();\n        }\n      }\n      if (openToken.type === 33) {\n        this._consumeComponentOpenEnd();\n      } else {\n        this._consumeTagOpenEnd();\n      }\n    } catch (e) {\n      if (e instanceof ParseError) {\n        if (openToken) {\n          openToken.type = openToken.type === 33 ? 37 : 4;\n        } else {\n          this._beginToken(5, start);\n          this._endToken(['<']);\n        }\n        return;\n      }\n      throw e;\n    }\n    const contentTokenType = this._getTagDefinition(tagName).getContentType(prefix);\n    if (contentTokenType === TagContentType.RAW_TEXT) {\n      this._consumeRawTextWithTagClose(openToken, closingTagName, false);\n    } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n      this._consumeRawTextWithTagClose(openToken, closingTagName, true);\n    }\n  }\n  _consumeRawTextWithTagClose(openToken, tagName, consumeEntities) {\n    this._consumeRawText(consumeEntities, () => {\n      if (!this._attemptCharCode($LT)) return false;\n      if (!this._attemptCharCode($SLASH)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      if (!this._attemptStrCaseInsensitive(tagName)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      return this._attemptCharCode($GT);\n    });\n    this._beginToken(openToken.type === 33 ? 36 : 3);\n    this._requireCharCodeUntilFn(code => code === $GT, 3);\n    this._cursor.advance();\n    this._endToken(openToken.parts);\n  }\n  _consumeTagOpenStart(start) {\n    this._beginToken(0, start);\n    const parts = this._consumePrefixAndName(isNameEnd);\n    return this._endToken(parts);\n  }\n  _consumeComponentOpenStart(start) {\n    this._beginToken(33, start);\n    const parts = this._consumeComponentName();\n    return this._endToken(parts);\n  }\n  _consumeComponentName() {\n    const nameStart = this._cursor.clone();\n    while (isSelectorlessNameChar(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n    const name = this._cursor.getChars(nameStart);\n    let prefix = '';\n    let tagName = '';\n    if (this._cursor.peek() === $COLON) {\n      this._cursor.advance();\n      [prefix, tagName] = this._consumePrefixAndName(isNameEnd);\n    }\n    return [name, prefix, tagName];\n  }\n  _consumeAttribute() {\n    this._consumeAttributeName();\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    if (this._attemptCharCode($EQ)) {\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      this._consumeAttributeValue();\n    }\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n  _consumeAttributeName() {\n    const attrNameStart = this._cursor.peek();\n    if (attrNameStart === $SQ || attrNameStart === $DQ) {\n      throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());\n    }\n    this._beginToken(14);\n    let nameEndPredicate;\n    if (this._openDirectiveCount > 0) {\n      let openParens = 0;\n      nameEndPredicate = code => {\n        if (this._openDirectiveCount > 0) {\n          if (code === $LPAREN) {\n            openParens++;\n          } else if (code === $RPAREN) {\n            if (openParens === 0) {\n              return true;\n            }\n            openParens--;\n          }\n        }\n        return isNameEnd(code);\n      };\n    } else if (attrNameStart === $LBRACKET) {\n      let openBrackets = 0;\n      nameEndPredicate = code => {\n        if (code === $LBRACKET) {\n          openBrackets++;\n        } else if (code === $RBRACKET) {\n          openBrackets--;\n        }\n        return openBrackets <= 0 ? isNameEnd(code) : isNewLine(code);\n      };\n    } else {\n      nameEndPredicate = isNameEnd;\n    }\n    const prefixAndName = this._consumePrefixAndName(nameEndPredicate);\n    this._endToken(prefixAndName);\n  }\n  _consumeAttributeValue() {\n    if (this._cursor.peek() === $SQ || this._cursor.peek() === $DQ) {\n      const quoteChar = this._cursor.peek();\n      this._consumeQuote(quoteChar);\n      const endPredicate = () => this._cursor.peek() === quoteChar;\n      this._consumeWithInterpolation(16, 17, endPredicate, endPredicate);\n      this._consumeQuote(quoteChar);\n    } else {\n      const endPredicate = () => isNameEnd(this._cursor.peek());\n      this._consumeWithInterpolation(16, 17, endPredicate, endPredicate);\n    }\n  }\n  _consumeQuote(quoteChar) {\n    this._beginToken(15);\n    this._requireCharCode(quoteChar);\n    this._endToken([String.fromCodePoint(quoteChar)]);\n  }\n  _consumeTagOpenEnd() {\n    const tokenType = this._attemptCharCode($SLASH) ? 2 : 1;\n    this._beginToken(tokenType);\n    this._requireCharCode($GT);\n    this._endToken([]);\n  }\n  _consumeComponentOpenEnd() {\n    const tokenType = this._attemptCharCode($SLASH) ? 35 : 34;\n    this._beginToken(tokenType);\n    this._requireCharCode($GT);\n    this._endToken([]);\n  }\n  _consumeTagClose(start) {\n    if (this._selectorlessEnabled) {\n      const clone = start.clone();\n      while (clone.peek() !== $GT && !isSelectorlessNameStart(clone.peek())) {\n        clone.advance();\n      }\n      if (isSelectorlessNameStart(clone.peek())) {\n        this._beginToken(36, start);\n        const parts = this._consumeComponentName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._requireCharCode($GT);\n        this._endToken(parts);\n        return;\n      }\n    }\n    this._beginToken(3, start);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    const prefixAndName = this._consumePrefixAndName(isNameEnd);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._requireCharCode($GT);\n    this._endToken(prefixAndName);\n  }\n  _consumeExpansionFormStart() {\n    this._beginToken(19);\n    this._requireCharCode($LBRACE);\n    this._endToken([]);\n    this._expansionCaseStack.push(19);\n    this._beginToken(7);\n    const condition = this._readUntil($COMMA);\n    const normalizedCondition = this._processCarriageReturns(condition);\n    if (this._i18nNormalizeLineEndingsInICUs) {\n      this._endToken([normalizedCondition]);\n    } else {\n      const conditionToken = this._endToken([condition]);\n      if (normalizedCondition !== condition) {\n        this.nonNormalizedIcuExpressions.push(conditionToken);\n      }\n    }\n    this._requireCharCode($COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._beginToken(7);\n    const type = this._readUntil($COMMA);\n    this._endToken([type]);\n    this._requireCharCode($COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n  _consumeExpansionCaseStart() {\n    this._beginToken(20);\n    const value = this._readUntil($LBRACE).trim();\n    this._endToken([value]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._beginToken(21);\n    this._requireCharCode($LBRACE);\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._expansionCaseStack.push(21);\n  }\n  _consumeExpansionCaseEnd() {\n    this._beginToken(22);\n    this._requireCharCode($RBRACE);\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._expansionCaseStack.pop();\n  }\n  _consumeExpansionFormEnd() {\n    this._beginToken(23);\n    this._requireCharCode($RBRACE);\n    this._endToken([]);\n    this._expansionCaseStack.pop();\n  }\n  _consumeWithInterpolation(textTokenType, interpolationTokenType, endPredicate, endInterpolation) {\n    this._beginToken(textTokenType);\n    const parts = [];\n    while (!endPredicate()) {\n      const current = this._cursor.clone();\n      if (this._attemptStr(INTERPOLATION.start)) {\n        this._endToken([this._processCarriageReturns(parts.join(''))], current);\n        parts.length = 0;\n        this._consumeInterpolation(interpolationTokenType, current, endInterpolation);\n        this._beginToken(textTokenType);\n      } else if (this._cursor.peek() === $AMPERSAND) {\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n        parts.length = 0;\n        this._consumeEntity(textTokenType);\n        this._beginToken(textTokenType);\n      } else {\n        parts.push(this._readChar());\n      }\n    }\n    this._inInterpolation = false;\n    this._endToken([this._processCarriageReturns(parts.join(''))]);\n  }\n  _consumeInterpolation(interpolationTokenType, interpolationStart, prematureEndPredicate) {\n    const parts = [];\n    this._beginToken(interpolationTokenType, interpolationStart);\n    parts.push(INTERPOLATION.start);\n    const expressionStart = this._cursor.clone();\n    let inQuote = null;\n    let inComment = false;\n    while (this._cursor.peek() !== $EOF && (prematureEndPredicate === null || !prematureEndPredicate())) {\n      const current = this._cursor.clone();\n      if (this._isTagStart()) {\n        this._cursor = current;\n        parts.push(this._getProcessedChars(expressionStart, current));\n        this._endToken(parts);\n        return;\n      }\n      if (inQuote === null) {\n        if (this._attemptStr(INTERPOLATION.end)) {\n          parts.push(this._getProcessedChars(expressionStart, current));\n          parts.push(INTERPOLATION.end);\n          this._endToken(parts);\n          return;\n        } else if (this._attemptStr('//')) {\n          inComment = true;\n        }\n      }\n      const char = this._cursor.peek();\n      this._cursor.advance();\n      if (char === $BACKSLASH) {\n        this._cursor.advance();\n      } else if (char === inQuote) {\n        inQuote = null;\n      } else if (!inComment && inQuote === null && isQuote(char)) {\n        inQuote = char;\n      }\n    }\n    parts.push(this._getProcessedChars(expressionStart, this._cursor));\n    this._endToken(parts);\n  }\n  _consumeDirective(start, nameStart) {\n    this._requireCharCode($AT);\n    this._cursor.advance();\n    while (isSelectorlessNameChar(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n    this._beginToken(38, start);\n    const name = this._cursor.getChars(nameStart);\n    this._endToken([name]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    if (this._cursor.peek() !== $LPAREN) {\n      return;\n    }\n    this._openDirectiveCount++;\n    this._beginToken(39);\n    this._cursor.advance();\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    while (!isAttributeTerminator(this._cursor.peek()) && this._cursor.peek() !== $RPAREN) {\n      this._consumeAttribute();\n    }\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._openDirectiveCount--;\n    if (this._cursor.peek() !== $RPAREN) {\n      if (this._cursor.peek() === $GT || this._cursor.peek() === $SLASH) {\n        return;\n      }\n      throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n    }\n    this._beginToken(40);\n    this._cursor.advance();\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n  _getProcessedChars(start, end) {\n    return this._processCarriageReturns(end.getChars(start));\n  }\n  _isTextEnd() {\n    if (this._isTagStart() || this._cursor.peek() === $EOF) {\n      return true;\n    }\n    if (this._tokenizeIcu && !this._inInterpolation) {\n      if (this.isExpansionFormStart()) {\n        return true;\n      }\n      if (this._cursor.peek() === $RBRACE && this._isInExpansionCase()) {\n        return true;\n      }\n    }\n    if (this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansion() && (this._isBlockStart() || this._isLetStart() || this._cursor.peek() === $RBRACE)) {\n      return true;\n    }\n    return false;\n  }\n  _isTagStart() {\n    if (this._cursor.peek() === $LT) {\n      const tmp = this._cursor.clone();\n      tmp.advance();\n      const code = tmp.peek();\n      if ($a <= code && code <= $z || $A <= code && code <= $Z || code === $SLASH || code === $BANG) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _readUntil(char) {\n    const start = this._cursor.clone();\n    this._attemptUntilChar(char);\n    return this._cursor.getChars(start);\n  }\n  _isInExpansion() {\n    return this._isInExpansionCase() || this._isInExpansionForm();\n  }\n  _isInExpansionCase() {\n    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 21;\n  }\n  _isInExpansionForm() {\n    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 19;\n  }\n  isExpansionFormStart() {\n    if (this._cursor.peek() !== $LBRACE) {\n      return false;\n    }\n    const start = this._cursor.clone();\n    const isInterpolation = this._attemptStr(INTERPOLATION.start);\n    this._cursor = start;\n    return !isInterpolation;\n  }\n}\nfunction isNotWhitespace(code) {\n  return !isWhitespace(code) || code === $EOF;\n}\nfunction isNameEnd(code) {\n  return isWhitespace(code) || code === $GT || code === $LT || code === $SLASH || code === $SQ || code === $DQ || code === $EQ || code === $EOF;\n}\nfunction isPrefixEnd(code) {\n  return (code < $a || $z < code) && (code < $A || $Z < code) && (code < $0 || code > $9);\n}\nfunction isDigitEntityEnd(code) {\n  return code === $SEMICOLON || code === $EOF || !isAsciiHexDigit(code);\n}\nfunction isNamedEntityEnd(code) {\n  return code === $SEMICOLON || code === $EOF || !isAsciiLetter(code);\n}\nfunction isExpansionCaseStart(peek) {\n  return peek !== $RBRACE;\n}\nfunction compareCharCodeCaseInsensitive(code1, code2) {\n  return toUpperCaseCharCode(code1) === toUpperCaseCharCode(code2);\n}\nfunction toUpperCaseCharCode(code) {\n  return code >= $a && code <= $z ? code - $a + $A : code;\n}\nfunction isBlockNameChar(code) {\n  return isAsciiLetter(code) || isDigit(code) || code === $_;\n}\nfunction isBlockParameterChar(code) {\n  return code !== $SEMICOLON && isNotWhitespace(code);\n}\nfunction isSelectorlessNameStart(code) {\n  return code === $_ || code >= $A && code <= $Z;\n}\nfunction isSelectorlessNameChar(code) {\n  return isAsciiLetter(code) || isDigit(code) || code === $_;\n}\nfunction isAttributeTerminator(code) {\n  return code === $SLASH || code === $GT || code === $LT || code === $EOF;\n}\nfunction mergeTextTokens(srcTokens) {\n  const dstTokens = [];\n  let lastDstToken = undefined;\n  for (let i = 0; i < srcTokens.length; i++) {\n    const token = srcTokens[i];\n    if (lastDstToken && lastDstToken.type === 5 && token.type === 5 || lastDstToken && lastDstToken.type === 16 && token.type === 16) {\n      lastDstToken.parts[0] += token.parts[0];\n      lastDstToken.sourceSpan.end = token.sourceSpan.end;\n    } else {\n      lastDstToken = token;\n      dstTokens.push(lastDstToken);\n    }\n  }\n  return dstTokens;\n}\nclass PlainCharacterCursor {\n  state;\n  file;\n  input;\n  end;\n  constructor(fileOrCursor, range) {\n    if (fileOrCursor instanceof PlainCharacterCursor) {\n      this.file = fileOrCursor.file;\n      this.input = fileOrCursor.input;\n      this.end = fileOrCursor.end;\n      const state = fileOrCursor.state;\n      this.state = {\n        peek: state.peek,\n        offset: state.offset,\n        line: state.line,\n        column: state.column\n      };\n    } else {\n      if (!range) {\n        throw new Error('Programming error: the range argument must be provided with a file argument.');\n      }\n      this.file = fileOrCursor;\n      this.input = fileOrCursor.content;\n      this.end = range.endPos;\n      this.state = {\n        peek: -1,\n        offset: range.startPos,\n        line: range.startLine,\n        column: range.startCol\n      };\n    }\n  }\n  clone() {\n    return new PlainCharacterCursor(this);\n  }\n  peek() {\n    return this.state.peek;\n  }\n  charsLeft() {\n    return this.end - this.state.offset;\n  }\n  diff(other) {\n    return this.state.offset - other.state.offset;\n  }\n  advance() {\n    this.advanceState(this.state);\n  }\n  init() {\n    this.updatePeek(this.state);\n  }\n  getSpan(start, leadingTriviaCodePoints) {\n    start = start || this;\n    let fullStart = start;\n    if (leadingTriviaCodePoints) {\n      while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {\n        if (fullStart === start) {\n          start = start.clone();\n        }\n        start.advance();\n      }\n    }\n    const startLocation = this.locationFromCursor(start);\n    const endLocation = this.locationFromCursor(this);\n    const fullStartLocation = fullStart !== start ? this.locationFromCursor(fullStart) : startLocation;\n    return new ParseSourceSpan(startLocation, endLocation, fullStartLocation);\n  }\n  getChars(start) {\n    return this.input.substring(start.state.offset, this.state.offset);\n  }\n  charAt(pos) {\n    return this.input.charCodeAt(pos);\n  }\n  advanceState(state) {\n    if (state.offset >= this.end) {\n      this.state = state;\n      throw new CursorError('Unexpected character \"EOF\"', this);\n    }\n    const currentChar = this.charAt(state.offset);\n    if (currentChar === $LF) {\n      state.line++;\n      state.column = 0;\n    } else if (!isNewLine(currentChar)) {\n      state.column++;\n    }\n    state.offset++;\n    this.updatePeek(state);\n  }\n  updatePeek(state) {\n    state.peek = state.offset >= this.end ? $EOF : this.charAt(state.offset);\n  }\n  locationFromCursor(cursor) {\n    return new ParseLocation(cursor.file, cursor.state.offset, cursor.state.line, cursor.state.column);\n  }\n}\nclass EscapedCharacterCursor extends PlainCharacterCursor {\n  internalState;\n  constructor(fileOrCursor, range) {\n    if (fileOrCursor instanceof EscapedCharacterCursor) {\n      super(fileOrCursor);\n      this.internalState = {\n        ...fileOrCursor.internalState\n      };\n    } else {\n      super(fileOrCursor, range);\n      this.internalState = this.state;\n    }\n  }\n  advance() {\n    this.state = this.internalState;\n    super.advance();\n    this.processEscapeSequence();\n  }\n  init() {\n    super.init();\n    this.processEscapeSequence();\n  }\n  clone() {\n    return new EscapedCharacterCursor(this);\n  }\n  getChars(start) {\n    const cursor = start.clone();\n    let chars = '';\n    while (cursor.internalState.offset < this.internalState.offset) {\n      chars += String.fromCodePoint(cursor.peek());\n      cursor.advance();\n    }\n    return chars;\n  }\n  processEscapeSequence() {\n    const peek = () => this.internalState.peek;\n    if (peek() === $BACKSLASH) {\n      this.internalState = {\n        ...this.state\n      };\n      this.advanceState(this.internalState);\n      if (peek() === $n) {\n        this.state.peek = $LF;\n      } else if (peek() === $r) {\n        this.state.peek = $CR;\n      } else if (peek() === $v) {\n        this.state.peek = $VTAB;\n      } else if (peek() === $t) {\n        this.state.peek = $TAB;\n      } else if (peek() === $b) {\n        this.state.peek = $BSPACE;\n      } else if (peek() === $f) {\n        this.state.peek = $FF;\n      } else if (peek() === $u) {\n        this.advanceState(this.internalState);\n        if (peek() === $LBRACE) {\n          this.advanceState(this.internalState);\n          const digitStart = this.clone();\n          let length = 0;\n          while (peek() !== $RBRACE) {\n            this.advanceState(this.internalState);\n            length++;\n          }\n          this.state.peek = this.decodeHexDigits(digitStart, length);\n        } else {\n          const digitStart = this.clone();\n          this.advanceState(this.internalState);\n          this.advanceState(this.internalState);\n          this.advanceState(this.internalState);\n          this.state.peek = this.decodeHexDigits(digitStart, 4);\n        }\n      } else if (peek() === $x) {\n        this.advanceState(this.internalState);\n        const digitStart = this.clone();\n        this.advanceState(this.internalState);\n        this.state.peek = this.decodeHexDigits(digitStart, 2);\n      } else if (isOctalDigit(peek())) {\n        let octal = '';\n        let length = 0;\n        let previous = this.clone();\n        while (isOctalDigit(peek()) && length < 3) {\n          previous = this.clone();\n          octal += String.fromCodePoint(peek());\n          this.advanceState(this.internalState);\n          length++;\n        }\n        this.state.peek = parseInt(octal, 8);\n        this.internalState = previous.internalState;\n      } else if (isNewLine(this.internalState.peek)) {\n        this.advanceState(this.internalState);\n        this.state = this.internalState;\n      } else {\n        this.state.peek = this.internalState.peek;\n      }\n    }\n  }\n  decodeHexDigits(start, length) {\n    const hex = this.input.slice(start.internalState.offset, start.internalState.offset + length);\n    const charCode = parseInt(hex, 16);\n    if (!isNaN(charCode)) {\n      return charCode;\n    } else {\n      start.state = start.internalState;\n      throw new CursorError('Invalid hexadecimal escape sequence', start);\n    }\n  }\n}\nclass CursorError extends Error {\n  msg;\n  cursor;\n  constructor(msg, cursor) {\n    super(msg);\n    this.msg = msg;\n    this.cursor = cursor;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\nclass TreeError extends ParseError {\n  elementName;\n  static create(elementName, span, msg) {\n    return new TreeError(elementName, span, msg);\n  }\n  constructor(elementName, span, msg) {\n    super(span, msg);\n    this.elementName = elementName;\n  }\n}\nclass ParseTreeResult {\n  rootNodes;\n  errors;\n  constructor(rootNodes, errors) {\n    this.rootNodes = rootNodes;\n    this.errors = errors;\n  }\n}\nlet Parser$1 = class Parser {\n  getTagDefinition;\n  constructor(getTagDefinition) {\n    this.getTagDefinition = getTagDefinition;\n  }\n  parse(source, url, options) {\n    const tokenizeResult = tokenize(source, url, this.getTagDefinition, options);\n    const parser = new _TreeBuilder(tokenizeResult.tokens, this.getTagDefinition);\n    parser.build();\n    return new ParseTreeResult(parser.rootNodes, [...tokenizeResult.errors, ...parser.errors]);\n  }\n};\nclass _TreeBuilder {\n  tokens;\n  tagDefinitionResolver;\n  _index = -1;\n  _peek;\n  _containerStack = [];\n  rootNodes = [];\n  errors = [];\n  constructor(tokens, tagDefinitionResolver) {\n    this.tokens = tokens;\n    this.tagDefinitionResolver = tagDefinitionResolver;\n    this._advance();\n  }\n  build() {\n    while (this._peek.type !== 41) {\n      if (this._peek.type === 0 || this._peek.type === 4) {\n        this._consumeElementStartTag(this._advance());\n      } else if (this._peek.type === 3) {\n        this._consumeElementEndTag(this._advance());\n      } else if (this._peek.type === 12) {\n        this._closeVoidElement();\n        this._consumeCdata(this._advance());\n      } else if (this._peek.type === 10) {\n        this._closeVoidElement();\n        this._consumeComment(this._advance());\n      } else if (this._peek.type === 5 || this._peek.type === 7 || this._peek.type === 6) {\n        this._closeVoidElement();\n        this._consumeText(this._advance());\n      } else if (this._peek.type === 19) {\n        this._consumeExpansion(this._advance());\n      } else if (this._peek.type === 24) {\n        this._closeVoidElement();\n        this._consumeBlockOpen(this._advance());\n      } else if (this._peek.type === 26) {\n        this._closeVoidElement();\n        this._consumeBlockClose(this._advance());\n      } else if (this._peek.type === 28) {\n        this._closeVoidElement();\n        this._consumeIncompleteBlock(this._advance());\n      } else if (this._peek.type === 29) {\n        this._closeVoidElement();\n        this._consumeLet(this._advance());\n      } else if (this._peek.type === 32) {\n        this._closeVoidElement();\n        this._consumeIncompleteLet(this._advance());\n      } else if (this._peek.type === 33 || this._peek.type === 37) {\n        this._consumeComponentStartTag(this._advance());\n      } else if (this._peek.type === 36) {\n        this._consumeComponentEndTag(this._advance());\n      } else {\n        this._advance();\n      }\n    }\n    for (const leftoverContainer of this._containerStack) {\n      if (leftoverContainer instanceof Block) {\n        this.errors.push(TreeError.create(leftoverContainer.name, leftoverContainer.sourceSpan, `Unclosed block \"${leftoverContainer.name}\"`));\n      }\n    }\n  }\n  _advance() {\n    const prev = this._peek;\n    if (this._index < this.tokens.length - 1) {\n      this._index++;\n    }\n    this._peek = this.tokens[this._index];\n    return prev;\n  }\n  _advanceIf(type) {\n    if (this._peek.type === type) {\n      return this._advance();\n    }\n    return null;\n  }\n  _consumeCdata(_startToken) {\n    this._consumeText(this._advance());\n    this._advanceIf(13);\n  }\n  _consumeComment(token) {\n    const text = this._advanceIf(7);\n    const endToken = this._advanceIf(11);\n    const value = text != null ? text.parts[0].trim() : null;\n    const sourceSpan = endToken == null ? token.sourceSpan : new ParseSourceSpan(token.sourceSpan.start, endToken.sourceSpan.end, token.sourceSpan.fullStart);\n    this._addToParent(new Comment(value, sourceSpan));\n  }\n  _consumeExpansion(token) {\n    const switchValue = this._advance();\n    const type = this._advance();\n    const cases = [];\n    while (this._peek.type === 20) {\n      const expCase = this._parseExpansionCase();\n      if (!expCase) return;\n      cases.push(expCase);\n    }\n    if (this._peek.type !== 23) {\n      this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '}'.`));\n      return;\n    }\n    const sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end, token.sourceSpan.fullStart);\n    this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));\n    this._advance();\n  }\n  _parseExpansionCase() {\n    const value = this._advance();\n    if (this._peek.type !== 21) {\n      this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '{'.`));\n      return null;\n    }\n    const start = this._advance();\n    const exp = this._collectExpansionExpTokens(start);\n    if (!exp) return null;\n    const end = this._advance();\n    exp.push({\n      type: 41,\n      parts: [],\n      sourceSpan: end.sourceSpan\n    });\n    const expansionCaseParser = new _TreeBuilder(exp, this.tagDefinitionResolver);\n    expansionCaseParser.build();\n    if (expansionCaseParser.errors.length > 0) {\n      this.errors = this.errors.concat(expansionCaseParser.errors);\n      return null;\n    }\n    const sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end, value.sourceSpan.fullStart);\n    const expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end, start.sourceSpan.fullStart);\n    return new ExpansionCase(value.parts[0], expansionCaseParser.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);\n  }\n  _collectExpansionExpTokens(start) {\n    const exp = [];\n    const expansionFormStack = [21];\n    while (true) {\n      if (this._peek.type === 19 || this._peek.type === 21) {\n        expansionFormStack.push(this._peek.type);\n      }\n      if (this._peek.type === 22) {\n        if (lastOnStack(expansionFormStack, 21)) {\n          expansionFormStack.pop();\n          if (expansionFormStack.length === 0) return exp;\n        } else {\n          this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n          return null;\n        }\n      }\n      if (this._peek.type === 23) {\n        if (lastOnStack(expansionFormStack, 19)) {\n          expansionFormStack.pop();\n        } else {\n          this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n          return null;\n        }\n      }\n      if (this._peek.type === 41) {\n        this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n        return null;\n      }\n      exp.push(this._advance());\n    }\n  }\n  _consumeText(token) {\n    const tokens = [token];\n    const startSpan = token.sourceSpan;\n    let text = token.parts[0];\n    if (text.length > 0 && text[0] === '\\n') {\n      const parent = this._getContainer();\n      if (parent != null && parent.children.length === 0 && this._getTagDefinition(parent)?.ignoreFirstLf) {\n        text = text.substring(1);\n        tokens[0] = {\n          type: token.type,\n          sourceSpan: token.sourceSpan,\n          parts: [text]\n        };\n      }\n    }\n    while (this._peek.type === 8 || this._peek.type === 5 || this._peek.type === 9) {\n      token = this._advance();\n      tokens.push(token);\n      if (token.type === 8) {\n        text += token.parts.join('').replace(/&([^;]+);/g, decodeEntity);\n      } else if (token.type === 9) {\n        text += token.parts[0];\n      } else {\n        text += token.parts.join('');\n      }\n    }\n    if (text.length > 0) {\n      const endSpan = token.sourceSpan;\n      this._addToParent(new Text(text, new ParseSourceSpan(startSpan.start, endSpan.end, startSpan.fullStart, startSpan.details), tokens));\n    }\n  }\n  _closeVoidElement() {\n    const el = this._getContainer();\n    if (el !== null && this._getTagDefinition(el)?.isVoid) {\n      this._containerStack.pop();\n    }\n  }\n  _consumeElementStartTag(startTagToken) {\n    const attrs = [];\n    const directives = [];\n    this._consumeAttributesAndDirectives(attrs, directives);\n    const fullName = this._getElementFullName(startTagToken, this._getClosestElementLikeParent());\n    const tagDef = this._getTagDefinition(fullName);\n    let selfClosing = false;\n    if (this._peek.type === 2) {\n      this._advance();\n      selfClosing = true;\n      if (!(tagDef?.canSelfClose || getNsPrefix(fullName) !== null || tagDef?.isVoid)) {\n        this.errors.push(TreeError.create(fullName, startTagToken.sourceSpan, `Only void, custom and foreign elements can be self closed \"${startTagToken.parts[1]}\"`));\n      }\n    } else if (this._peek.type === 1) {\n      this._advance();\n      selfClosing = false;\n    }\n    const end = this._peek.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);\n    const startSpan = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);\n    const el = new Element(fullName, attrs, directives, [], selfClosing, span, startSpan, undefined, tagDef?.isVoid ?? false);\n    const parent = this._getContainer();\n    const isClosedByChild = parent !== null && !!this._getTagDefinition(parent)?.isClosedByChild(el.name);\n    this._pushContainer(el, isClosedByChild);\n    if (selfClosing) {\n      this._popContainer(fullName, Element, span);\n    } else if (startTagToken.type === 4) {\n      this._popContainer(fullName, Element, null);\n      this.errors.push(TreeError.create(fullName, span, `Opening tag \"${fullName}\" not terminated.`));\n    }\n  }\n  _consumeComponentStartTag(startToken) {\n    const componentName = startToken.parts[0];\n    const attrs = [];\n    const directives = [];\n    this._consumeAttributesAndDirectives(attrs, directives);\n    const closestElement = this._getClosestElementLikeParent();\n    const tagName = this._getComponentTagName(startToken, closestElement);\n    const fullName = this._getComponentFullName(startToken, closestElement);\n    const selfClosing = this._peek.type === 35;\n    this._advance();\n    const end = this._peek.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(startToken.sourceSpan.start, end, startToken.sourceSpan.fullStart);\n    const startSpan = new ParseSourceSpan(startToken.sourceSpan.start, end, startToken.sourceSpan.fullStart);\n    const node = new Component(componentName, tagName, fullName, attrs, directives, [], selfClosing, span, startSpan, undefined);\n    const parent = this._getContainer();\n    const isClosedByChild = parent !== null && node.tagName !== null && !!this._getTagDefinition(parent)?.isClosedByChild(node.tagName);\n    this._pushContainer(node, isClosedByChild);\n    if (selfClosing) {\n      this._popContainer(fullName, Component, span);\n    } else if (startToken.type === 37) {\n      this._popContainer(fullName, Component, null);\n      this.errors.push(TreeError.create(fullName, span, `Opening tag \"${fullName}\" not terminated.`));\n    }\n  }\n  _consumeAttributesAndDirectives(attributesResult, directivesResult) {\n    while (this._peek.type === 14 || this._peek.type === 38) {\n      if (this._peek.type === 38) {\n        directivesResult.push(this._consumeDirective(this._peek));\n      } else {\n        attributesResult.push(this._consumeAttr(this._advance()));\n      }\n    }\n  }\n  _consumeComponentEndTag(endToken) {\n    const fullName = this._getComponentFullName(endToken, this._getClosestElementLikeParent());\n    if (!this._popContainer(fullName, Component, endToken.sourceSpan)) {\n      const container = this._containerStack[this._containerStack.length - 1];\n      let suffix;\n      if (container instanceof Component && container.componentName === endToken.parts[0]) {\n        suffix = `, did you mean \"${container.fullName}\"?`;\n      } else {\n        suffix = '. It may happen when the tag has already been closed by another tag.';\n      }\n      const errMsg = `Unexpected closing tag \"${fullName}\"${suffix}`;\n      this.errors.push(TreeError.create(fullName, endToken.sourceSpan, errMsg));\n    }\n  }\n  _getTagDefinition(nodeOrName) {\n    if (typeof nodeOrName === 'string') {\n      return this.tagDefinitionResolver(nodeOrName);\n    } else if (nodeOrName instanceof Element) {\n      return this.tagDefinitionResolver(nodeOrName.name);\n    } else if (nodeOrName instanceof Component && nodeOrName.tagName !== null) {\n      return this.tagDefinitionResolver(nodeOrName.tagName);\n    } else {\n      return null;\n    }\n  }\n  _pushContainer(node, isClosedByChild) {\n    if (isClosedByChild) {\n      this._containerStack.pop();\n    }\n    this._addToParent(node);\n    this._containerStack.push(node);\n  }\n  _consumeElementEndTag(endTagToken) {\n    const fullName = this._getElementFullName(endTagToken, this._getClosestElementLikeParent());\n    if (this._getTagDefinition(fullName)?.isVoid) {\n      this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, `Void elements do not have end tags \"${endTagToken.parts[1]}\"`));\n    } else if (!this._popContainer(fullName, Element, endTagToken.sourceSpan)) {\n      const errMsg = `Unexpected closing tag \"${fullName}\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;\n      this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n    }\n  }\n  _popContainer(expectedName, expectedType, endSourceSpan) {\n    let unexpectedCloseTagDetected = false;\n    for (let stackIndex = this._containerStack.length - 1; stackIndex >= 0; stackIndex--) {\n      const node = this._containerStack[stackIndex];\n      const nodeName = node instanceof Component ? node.fullName : node.name;\n      if ((nodeName === expectedName || expectedName === null) && node instanceof expectedType) {\n        node.endSourceSpan = endSourceSpan;\n        node.sourceSpan.end = endSourceSpan !== null ? endSourceSpan.end : node.sourceSpan.end;\n        this._containerStack.splice(stackIndex, this._containerStack.length - stackIndex);\n        return !unexpectedCloseTagDetected;\n      }\n      if (node instanceof Block || !this._getTagDefinition(node)?.closedByParent) {\n        unexpectedCloseTagDetected = true;\n      }\n    }\n    return false;\n  }\n  _consumeAttr(attrName) {\n    const fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n    let attrEnd = attrName.sourceSpan.end;\n    if (this._peek.type === 15) {\n      this._advance();\n    }\n    let value = '';\n    const valueTokens = [];\n    let valueStartSpan = undefined;\n    let valueEnd = undefined;\n    const nextTokenType = this._peek.type;\n    if (nextTokenType === 16) {\n      valueStartSpan = this._peek.sourceSpan;\n      valueEnd = this._peek.sourceSpan.end;\n      while (this._peek.type === 16 || this._peek.type === 17 || this._peek.type === 9) {\n        const valueToken = this._advance();\n        valueTokens.push(valueToken);\n        if (valueToken.type === 17) {\n          value += valueToken.parts.join('').replace(/&([^;]+);/g, decodeEntity);\n        } else if (valueToken.type === 9) {\n          value += valueToken.parts[0];\n        } else {\n          value += valueToken.parts.join('');\n        }\n        valueEnd = attrEnd = valueToken.sourceSpan.end;\n      }\n    }\n    if (this._peek.type === 15) {\n      const quoteToken = this._advance();\n      attrEnd = quoteToken.sourceSpan.end;\n    }\n    const valueSpan = valueStartSpan && valueEnd && new ParseSourceSpan(valueStartSpan.start, valueEnd, valueStartSpan.fullStart);\n    return new Attribute(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, attrEnd, attrName.sourceSpan.fullStart), attrName.sourceSpan, valueSpan, valueTokens.length > 0 ? valueTokens : undefined, undefined);\n  }\n  _consumeDirective(nameToken) {\n    const attributes = [];\n    let startSourceSpanEnd = nameToken.sourceSpan.end;\n    let endSourceSpan = null;\n    this._advance();\n    if (this._peek.type === 39) {\n      startSourceSpanEnd = this._peek.sourceSpan.end;\n      this._advance();\n      while (this._peek.type === 14) {\n        attributes.push(this._consumeAttr(this._advance()));\n      }\n      if (this._peek.type === 40) {\n        endSourceSpan = this._peek.sourceSpan;\n        this._advance();\n      } else {\n        this.errors.push(TreeError.create(null, nameToken.sourceSpan, 'Unterminated directive definition'));\n      }\n    }\n    const startSourceSpan = new ParseSourceSpan(nameToken.sourceSpan.start, startSourceSpanEnd, nameToken.sourceSpan.fullStart);\n    const sourceSpan = new ParseSourceSpan(startSourceSpan.start, endSourceSpan === null ? nameToken.sourceSpan.end : endSourceSpan.end, startSourceSpan.fullStart);\n    return new Directive(nameToken.parts[0], attributes, sourceSpan, startSourceSpan, endSourceSpan);\n  }\n  _consumeBlockOpen(token) {\n    const parameters = [];\n    while (this._peek.type === 27) {\n      const paramToken = this._advance();\n      parameters.push(new BlockParameter(paramToken.parts[0], paramToken.sourceSpan));\n    }\n    if (this._peek.type === 25) {\n      this._advance();\n    }\n    const end = this._peek.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);\n    const startSpan = new ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);\n    const block = new Block(token.parts[0], parameters, [], span, token.sourceSpan, startSpan);\n    this._pushContainer(block, false);\n  }\n  _consumeBlockClose(token) {\n    if (!this._popContainer(null, Block, token.sourceSpan)) {\n      this.errors.push(TreeError.create(null, token.sourceSpan, `Unexpected closing block. The block may have been closed earlier. ` + `If you meant to write the } character, you should use the \"&#125;\" ` + `HTML entity instead.`));\n    }\n  }\n  _consumeIncompleteBlock(token) {\n    const parameters = [];\n    while (this._peek.type === 27) {\n      const paramToken = this._advance();\n      parameters.push(new BlockParameter(paramToken.parts[0], paramToken.sourceSpan));\n    }\n    const end = this._peek.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);\n    const startSpan = new ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);\n    const block = new Block(token.parts[0], parameters, [], span, token.sourceSpan, startSpan);\n    this._pushContainer(block, false);\n    this._popContainer(null, Block, null);\n    this.errors.push(TreeError.create(token.parts[0], span, `Incomplete block \"${token.parts[0]}\". If you meant to write the @ character, ` + `you should use the \"&#64;\" HTML entity instead.`));\n  }\n  _consumeLet(startToken) {\n    const name = startToken.parts[0];\n    let valueToken;\n    let endToken;\n    if (this._peek.type !== 30) {\n      this.errors.push(TreeError.create(startToken.parts[0], startToken.sourceSpan, `Invalid @let declaration \"${name}\". Declaration must have a value.`));\n      return;\n    } else {\n      valueToken = this._advance();\n    }\n    if (this._peek.type !== 31) {\n      this.errors.push(TreeError.create(startToken.parts[0], startToken.sourceSpan, `Unterminated @let declaration \"${name}\". Declaration must be terminated with a semicolon.`));\n      return;\n    } else {\n      endToken = this._advance();\n    }\n    const end = endToken.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(startToken.sourceSpan.start, end, startToken.sourceSpan.fullStart);\n    const startOffset = startToken.sourceSpan.toString().lastIndexOf(name);\n    const nameStart = startToken.sourceSpan.start.moveBy(startOffset);\n    const nameSpan = new ParseSourceSpan(nameStart, startToken.sourceSpan.end);\n    const node = new LetDeclaration(name, valueToken.parts[0], span, nameSpan, valueToken.sourceSpan);\n    this._addToParent(node);\n  }\n  _consumeIncompleteLet(token) {\n    const name = token.parts[0] ?? '';\n    const nameString = name ? ` \"${name}\"` : '';\n    if (name.length > 0) {\n      const startOffset = token.sourceSpan.toString().lastIndexOf(name);\n      const nameStart = token.sourceSpan.start.moveBy(startOffset);\n      const nameSpan = new ParseSourceSpan(nameStart, token.sourceSpan.end);\n      const valueSpan = new ParseSourceSpan(token.sourceSpan.start, token.sourceSpan.start.moveBy(0));\n      const node = new LetDeclaration(name, '', token.sourceSpan, nameSpan, valueSpan);\n      this._addToParent(node);\n    }\n    this.errors.push(TreeError.create(token.parts[0], token.sourceSpan, `Incomplete @let declaration${nameString}. ` + `@let declarations must be written as \\`@let <name> = <value>;\\``));\n  }\n  _getContainer() {\n    return this._containerStack.length > 0 ? this._containerStack[this._containerStack.length - 1] : null;\n  }\n  _getClosestElementLikeParent() {\n    for (let i = this._containerStack.length - 1; i > -1; i--) {\n      const current = this._containerStack[i];\n      if (current instanceof Element || current instanceof Component) {\n        return current;\n      }\n    }\n    return null;\n  }\n  _addToParent(node) {\n    const parent = this._getContainer();\n    if (parent === null) {\n      this.rootNodes.push(node);\n    } else {\n      parent.children.push(node);\n    }\n  }\n  _getElementFullName(token, parent) {\n    const prefix = this._getPrefix(token, parent);\n    return mergeNsAndName(prefix, token.parts[1]);\n  }\n  _getComponentFullName(token, parent) {\n    const componentName = token.parts[0];\n    const tagName = this._getComponentTagName(token, parent);\n    if (tagName === null) {\n      return componentName;\n    }\n    return tagName.startsWith(':') ? componentName + tagName : `${componentName}:${tagName}`;\n  }\n  _getComponentTagName(token, parent) {\n    const prefix = this._getPrefix(token, parent);\n    const tagName = token.parts[2];\n    if (!prefix && !tagName) {\n      return null;\n    } else if (!prefix && tagName) {\n      return tagName;\n    } else {\n      return mergeNsAndName(prefix, tagName || 'ng-component');\n    }\n  }\n  _getPrefix(token, parent) {\n    let prefix;\n    let tagName;\n    if (token.type === 33 || token.type === 37 || token.type === 36) {\n      prefix = token.parts[1];\n      tagName = token.parts[2];\n    } else {\n      prefix = token.parts[0];\n      tagName = token.parts[1];\n    }\n    prefix = prefix || this._getTagDefinition(tagName)?.implicitNamespacePrefix || '';\n    if (!prefix && parent) {\n      const parentName = parent instanceof Element ? parent.name : parent.tagName;\n      if (parentName !== null) {\n        const parentTagName = splitNsName(parentName)[1];\n        const parentTagDefinition = this._getTagDefinition(parentTagName);\n        if (parentTagDefinition !== null && !parentTagDefinition.preventNamespaceInheritance) {\n          prefix = getNsPrefix(parentName);\n        }\n      }\n    }\n    return prefix;\n  }\n}\nfunction lastOnStack(stack, element) {\n  return stack.length > 0 && stack[stack.length - 1] === element;\n}\nfunction decodeEntity(match, entity) {\n  if (NAMED_ENTITIES[entity] !== undefined) {\n    return NAMED_ENTITIES[entity] || match;\n  }\n  if (/^#x[a-f0-9]+$/i.test(entity)) {\n    return String.fromCodePoint(parseInt(entity.slice(2), 16));\n  }\n  if (/^#\\d+$/.test(entity)) {\n    return String.fromCodePoint(parseInt(entity.slice(1), 10));\n  }\n  return match;\n}\nconst PRESERVE_WS_ATTR_NAME = 'ngPreserveWhitespaces';\nconst SKIP_WS_TRIM_TAGS = new Set(['pre', 'template', 'textarea', 'script', 'style']);\nconst WS_CHARS = ' \\f\\n\\r\\t\\v\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff';\nconst NO_WS_REGEXP = new RegExp(`[^${WS_CHARS}]`);\nconst WS_REPLACE_REGEXP = new RegExp(`[${WS_CHARS}]{2,}`, 'g');\nfunction hasPreserveWhitespacesAttr(attrs) {\n  return attrs.some(attr => attr.name === PRESERVE_WS_ATTR_NAME);\n}\nfunction replaceNgsp(value) {\n  return value.replace(new RegExp(NGSP_UNICODE, 'g'), ' ');\n}\nclass WhitespaceVisitor {\n  preserveSignificantWhitespace;\n  originalNodeMap;\n  requireContext;\n  icuExpansionDepth = 0;\n  constructor(preserveSignificantWhitespace, originalNodeMap, requireContext = true) {\n    this.preserveSignificantWhitespace = preserveSignificantWhitespace;\n    this.originalNodeMap = originalNodeMap;\n    this.requireContext = requireContext;\n  }\n  visitElement(element, context) {\n    if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {\n      const newElement = new Element(element.name, visitAllWithSiblings(this, element.attrs), visitAllWithSiblings(this, element.directives), element.children, element.isSelfClosing, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.isVoid, element.i18n);\n      this.originalNodeMap?.set(newElement, element);\n      return newElement;\n    }\n    const newElement = new Element(element.name, element.attrs, element.directives, visitAllWithSiblings(this, element.children), element.isSelfClosing, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.isVoid, element.i18n);\n    this.originalNodeMap?.set(newElement, element);\n    return newElement;\n  }\n  visitAttribute(attribute, context) {\n    return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;\n  }\n  visitText(text, context) {\n    const isNotBlank = text.value.match(NO_WS_REGEXP);\n    const hasExpansionSibling = context && (context.prev instanceof Expansion || context.next instanceof Expansion);\n    const inIcuExpansion = this.icuExpansionDepth > 0;\n    if (inIcuExpansion && this.preserveSignificantWhitespace) return text;\n    if (isNotBlank || hasExpansionSibling) {\n      const tokens = text.tokens.map(token => token.type === 5 ? createWhitespaceProcessedTextToken(token) : token);\n      if (!this.preserveSignificantWhitespace && tokens.length > 0) {\n        const firstToken = tokens[0];\n        tokens.splice(0, 1, trimLeadingWhitespace(firstToken, context));\n        const lastToken = tokens[tokens.length - 1];\n        tokens.splice(tokens.length - 1, 1, trimTrailingWhitespace(lastToken, context));\n      }\n      const processed = processWhitespace(text.value);\n      const value = this.preserveSignificantWhitespace ? processed : trimLeadingAndTrailingWhitespace(processed, context);\n      const result = new Text(value, text.sourceSpan, tokens, text.i18n);\n      this.originalNodeMap?.set(result, text);\n      return result;\n    }\n    return null;\n  }\n  visitComment(comment, context) {\n    return comment;\n  }\n  visitExpansion(expansion, context) {\n    this.icuExpansionDepth++;\n    let newExpansion;\n    try {\n      newExpansion = new Expansion(expansion.switchValue, expansion.type, visitAllWithSiblings(this, expansion.cases), expansion.sourceSpan, expansion.switchValueSourceSpan, expansion.i18n);\n    } finally {\n      this.icuExpansionDepth--;\n    }\n    this.originalNodeMap?.set(newExpansion, expansion);\n    return newExpansion;\n  }\n  visitExpansionCase(expansionCase, context) {\n    const newExpansionCase = new ExpansionCase(expansionCase.value, visitAllWithSiblings(this, expansionCase.expression), expansionCase.sourceSpan, expansionCase.valueSourceSpan, expansionCase.expSourceSpan);\n    this.originalNodeMap?.set(newExpansionCase, expansionCase);\n    return newExpansionCase;\n  }\n  visitBlock(block, context) {\n    const newBlock = new Block(block.name, block.parameters, visitAllWithSiblings(this, block.children), block.sourceSpan, block.nameSpan, block.startSourceSpan, block.endSourceSpan);\n    this.originalNodeMap?.set(newBlock, block);\n    return newBlock;\n  }\n  visitBlockParameter(parameter, context) {\n    return parameter;\n  }\n  visitLetDeclaration(decl, context) {\n    return decl;\n  }\n  visitComponent(node, context) {\n    if (node.tagName && SKIP_WS_TRIM_TAGS.has(node.tagName) || hasPreserveWhitespacesAttr(node.attrs)) {\n      const newElement = new Component(node.componentName, node.tagName, node.fullName, visitAllWithSiblings(this, node.attrs), visitAllWithSiblings(this, node.directives), node.children, node.isSelfClosing, node.sourceSpan, node.startSourceSpan, node.endSourceSpan, node.i18n);\n      this.originalNodeMap?.set(newElement, node);\n      return newElement;\n    }\n    const newElement = new Component(node.componentName, node.tagName, node.fullName, node.attrs, node.directives, visitAllWithSiblings(this, node.children), node.isSelfClosing, node.sourceSpan, node.startSourceSpan, node.endSourceSpan, node.i18n);\n    this.originalNodeMap?.set(newElement, node);\n    return newElement;\n  }\n  visitDirective(directive, context) {\n    return directive;\n  }\n  visit(_node, context) {\n    if (this.requireContext && !context) {\n      throw new Error(`WhitespaceVisitor requires context. Visit via \\`visitAllWithSiblings\\` to get this context.`);\n    }\n    return false;\n  }\n}\nfunction trimLeadingWhitespace(token, context) {\n  if (token.type !== 5) return token;\n  const isFirstTokenInTag = !context?.prev;\n  if (!isFirstTokenInTag) return token;\n  return transformTextToken(token, text => text.trimStart());\n}\nfunction trimTrailingWhitespace(token, context) {\n  if (token.type !== 5) return token;\n  const isLastTokenInTag = !context?.next;\n  if (!isLastTokenInTag) return token;\n  return transformTextToken(token, text => text.trimEnd());\n}\nfunction trimLeadingAndTrailingWhitespace(text, context) {\n  const isFirstTokenInTag = !context?.prev;\n  const isLastTokenInTag = !context?.next;\n  const maybeTrimmedStart = isFirstTokenInTag ? text.trimStart() : text;\n  const maybeTrimmed = isLastTokenInTag ? maybeTrimmedStart.trimEnd() : maybeTrimmedStart;\n  return maybeTrimmed;\n}\nfunction createWhitespaceProcessedTextToken({\n  type,\n  parts,\n  sourceSpan\n}) {\n  return {\n    type,\n    parts: [processWhitespace(parts[0])],\n    sourceSpan\n  };\n}\nfunction transformTextToken({\n  type,\n  parts,\n  sourceSpan\n}, transform) {\n  return {\n    type,\n    parts: [transform(parts[0])],\n    sourceSpan\n  };\n}\nfunction processWhitespace(text) {\n  return replaceNgsp(text).replace(WS_REPLACE_REGEXP, ' ');\n}\nfunction visitAllWithSiblings(visitor, nodes) {\n  const result = [];\n  nodes.forEach((ast, i) => {\n    const context = {\n      prev: nodes[i - 1],\n      next: nodes[i + 1]\n    };\n    const astResult = ast.visit(visitor, context);\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\nvar TokenType;\n(function (TokenType) {\n  TokenType[TokenType[\"Character\"] = 0] = \"Character\";\n  TokenType[TokenType[\"Identifier\"] = 1] = \"Identifier\";\n  TokenType[TokenType[\"PrivateIdentifier\"] = 2] = \"PrivateIdentifier\";\n  TokenType[TokenType[\"Keyword\"] = 3] = \"Keyword\";\n  TokenType[TokenType[\"String\"] = 4] = \"String\";\n  TokenType[TokenType[\"Operator\"] = 5] = \"Operator\";\n  TokenType[TokenType[\"Number\"] = 6] = \"Number\";\n  TokenType[TokenType[\"RegExpBody\"] = 7] = \"RegExpBody\";\n  TokenType[TokenType[\"RegExpFlags\"] = 8] = \"RegExpFlags\";\n  TokenType[TokenType[\"Error\"] = 9] = \"Error\";\n})(TokenType || (TokenType = {}));\nvar StringTokenKind;\n(function (StringTokenKind) {\n  StringTokenKind[StringTokenKind[\"Plain\"] = 0] = \"Plain\";\n  StringTokenKind[StringTokenKind[\"TemplateLiteralPart\"] = 1] = \"TemplateLiteralPart\";\n  StringTokenKind[StringTokenKind[\"TemplateLiteralEnd\"] = 2] = \"TemplateLiteralEnd\";\n})(StringTokenKind || (StringTokenKind = {}));\nconst KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this', 'typeof', 'void', 'in'];\nclass Lexer {\n  tokenize(text) {\n    return new _Scanner(text).scan();\n  }\n}\nclass Token {\n  index;\n  end;\n  type;\n  numValue;\n  strValue;\n  constructor(index, end, type, numValue, strValue) {\n    this.index = index;\n    this.end = end;\n    this.type = type;\n    this.numValue = numValue;\n    this.strValue = strValue;\n  }\n  isCharacter(code) {\n    return this.type === TokenType.Character && this.numValue === code;\n  }\n  isNumber() {\n    return this.type === TokenType.Number;\n  }\n  isString() {\n    return this.type === TokenType.String;\n  }\n  isOperator(operator) {\n    return this.type === TokenType.Operator && this.strValue === operator;\n  }\n  isIdentifier() {\n    return this.type === TokenType.Identifier;\n  }\n  isPrivateIdentifier() {\n    return this.type === TokenType.PrivateIdentifier;\n  }\n  isKeyword() {\n    return this.type === TokenType.Keyword;\n  }\n  isKeywordLet() {\n    return this.type === TokenType.Keyword && this.strValue === 'let';\n  }\n  isKeywordAs() {\n    return this.type === TokenType.Keyword && this.strValue === 'as';\n  }\n  isKeywordNull() {\n    return this.type === TokenType.Keyword && this.strValue === 'null';\n  }\n  isKeywordUndefined() {\n    return this.type === TokenType.Keyword && this.strValue === 'undefined';\n  }\n  isKeywordTrue() {\n    return this.type === TokenType.Keyword && this.strValue === 'true';\n  }\n  isKeywordFalse() {\n    return this.type === TokenType.Keyword && this.strValue === 'false';\n  }\n  isKeywordThis() {\n    return this.type === TokenType.Keyword && this.strValue === 'this';\n  }\n  isKeywordTypeof() {\n    return this.type === TokenType.Keyword && this.strValue === 'typeof';\n  }\n  isKeywordVoid() {\n    return this.type === TokenType.Keyword && this.strValue === 'void';\n  }\n  isKeywordIn() {\n    return this.type === TokenType.Keyword && this.strValue === 'in';\n  }\n  isError() {\n    return this.type === TokenType.Error;\n  }\n  isRegExpBody() {\n    return this.type === TokenType.RegExpBody;\n  }\n  isRegExpFlags() {\n    return this.type === TokenType.RegExpFlags;\n  }\n  toNumber() {\n    return this.type === TokenType.Number ? this.numValue : -1;\n  }\n  isTemplateLiteralPart() {\n    return this.isString() && this.kind === StringTokenKind.TemplateLiteralPart;\n  }\n  isTemplateLiteralEnd() {\n    return this.isString() && this.kind === StringTokenKind.TemplateLiteralEnd;\n  }\n  isTemplateLiteralInterpolationStart() {\n    return this.isOperator('${');\n  }\n  toString() {\n    switch (this.type) {\n      case TokenType.Character:\n      case TokenType.Identifier:\n      case TokenType.Keyword:\n      case TokenType.Operator:\n      case TokenType.PrivateIdentifier:\n      case TokenType.String:\n      case TokenType.Error:\n      case TokenType.RegExpBody:\n      case TokenType.RegExpFlags:\n        return this.strValue;\n      case TokenType.Number:\n        return this.numValue.toString();\n      default:\n        return null;\n    }\n  }\n}\nclass StringToken extends Token {\n  kind;\n  constructor(index, end, strValue, kind) {\n    super(index, end, TokenType.String, 0, strValue);\n    this.kind = kind;\n  }\n}\nfunction newCharacterToken(index, end, code) {\n  return new Token(index, end, TokenType.Character, code, String.fromCharCode(code));\n}\nfunction newIdentifierToken(index, end, text) {\n  return new Token(index, end, TokenType.Identifier, 0, text);\n}\nfunction newPrivateIdentifierToken(index, end, text) {\n  return new Token(index, end, TokenType.PrivateIdentifier, 0, text);\n}\nfunction newKeywordToken(index, end, text) {\n  return new Token(index, end, TokenType.Keyword, 0, text);\n}\nfunction newOperatorToken(index, end, text) {\n  return new Token(index, end, TokenType.Operator, 0, text);\n}\nfunction newNumberToken(index, end, n) {\n  return new Token(index, end, TokenType.Number, n, '');\n}\nfunction newErrorToken(index, end, message) {\n  return new Token(index, end, TokenType.Error, 0, message);\n}\nfunction newRegExpBodyToken(index, end, text) {\n  return new Token(index, end, TokenType.RegExpBody, 0, text);\n}\nfunction newRegExpFlagsToken(index, end, text) {\n  return new Token(index, end, TokenType.RegExpFlags, 0, text);\n}\nconst EOF = new Token(-1, -1, TokenType.Character, 0, '');\nclass _Scanner {\n  input;\n  tokens = [];\n  length;\n  peek = 0;\n  index = -1;\n  braceStack = [];\n  constructor(input) {\n    this.input = input;\n    this.length = input.length;\n    this.advance();\n  }\n  scan() {\n    let token = this.scanToken();\n    while (token !== null) {\n      this.tokens.push(token);\n      token = this.scanToken();\n    }\n    return this.tokens;\n  }\n  advance() {\n    this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);\n  }\n  scanToken() {\n    const input = this.input;\n    const length = this.length;\n    let peek = this.peek;\n    let index = this.index;\n    while (peek <= $SPACE) {\n      if (++index >= length) {\n        peek = $EOF;\n        break;\n      } else {\n        peek = input.charCodeAt(index);\n      }\n    }\n    this.peek = peek;\n    this.index = index;\n    if (index >= length) {\n      return null;\n    }\n    if (isIdentifierStart(peek)) {\n      return this.scanIdentifier();\n    }\n    if (isDigit(peek)) {\n      return this.scanNumber(index);\n    }\n    const start = index;\n    switch (peek) {\n      case $PERIOD:\n        this.advance();\n        return isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, this.index, $PERIOD);\n      case $LPAREN:\n      case $RPAREN:\n      case $LBRACKET:\n      case $RBRACKET:\n      case $COMMA:\n      case $COLON:\n      case $SEMICOLON:\n        return this.scanCharacter(start, peek);\n      case $LBRACE:\n        return this.scanOpenBrace(start, peek);\n      case $RBRACE:\n        return this.scanCloseBrace(start, peek);\n      case $SQ:\n      case $DQ:\n        return this.scanString();\n      case $BT:\n        this.advance();\n        return this.scanTemplateLiteralPart(start);\n      case $HASH:\n        return this.scanPrivateIdentifier();\n      case $PLUS:\n        return this.scanComplexOperator(start, '+', $EQ, '=');\n      case $MINUS:\n        return this.scanComplexOperator(start, '-', $EQ, '=');\n      case $SLASH:\n        return this.isStartOfRegex() ? this.scanRegex(index) : this.scanComplexOperator(start, '/', $EQ, '=');\n      case $PERCENT:\n        return this.scanComplexOperator(start, '%', $EQ, '=');\n      case $CARET:\n        return this.scanOperator(start, '^');\n      case $STAR:\n        return this.scanStar(start);\n      case $QUESTION:\n        return this.scanQuestion(start);\n      case $LT:\n      case $GT:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');\n      case $BANG:\n      case $EQ:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');\n      case $AMPERSAND:\n        return this.scanComplexOperator(start, '&', $AMPERSAND, '&', $EQ, '=');\n      case $BAR:\n        return this.scanComplexOperator(start, '|', $BAR, '|', $EQ, '=');\n      case $NBSP:\n        while (isWhitespace(this.peek)) this.advance();\n        return this.scanToken();\n    }\n    this.advance();\n    return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n  }\n  scanCharacter(start, code) {\n    this.advance();\n    return newCharacterToken(start, this.index, code);\n  }\n  scanOperator(start, str) {\n    this.advance();\n    return newOperatorToken(start, this.index, str);\n  }\n  scanOpenBrace(start, code) {\n    this.braceStack.push('expression');\n    this.advance();\n    return newCharacterToken(start, this.index, code);\n  }\n  scanCloseBrace(start, code) {\n    this.advance();\n    const currentBrace = this.braceStack.pop();\n    if (currentBrace === 'interpolation') {\n      this.tokens.push(newCharacterToken(start, this.index, $RBRACE));\n      return this.scanTemplateLiteralPart(this.index);\n    }\n    return newCharacterToken(start, this.index, code);\n  }\n  scanComplexOperator(start, one, twoCode, two, threeCode, three) {\n    this.advance();\n    let str = one;\n    if (this.peek == twoCode) {\n      this.advance();\n      str += two;\n    }\n    if (threeCode != null && this.peek == threeCode) {\n      this.advance();\n      str += three;\n    }\n    return newOperatorToken(start, this.index, str);\n  }\n  scanIdentifier() {\n    const start = this.index;\n    this.advance();\n    while (isIdentifierPart(this.peek)) this.advance();\n    const str = this.input.substring(start, this.index);\n    return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, this.index, str) : newIdentifierToken(start, this.index, str);\n  }\n  scanPrivateIdentifier() {\n    const start = this.index;\n    this.advance();\n    if (!isIdentifierStart(this.peek)) {\n      return this.error('Invalid character [#]', -1);\n    }\n    while (isIdentifierPart(this.peek)) this.advance();\n    const identifierName = this.input.substring(start, this.index);\n    return newPrivateIdentifierToken(start, this.index, identifierName);\n  }\n  scanNumber(start) {\n    let simple = this.index === start;\n    let hasSeparators = false;\n    this.advance();\n    while (true) {\n      if (isDigit(this.peek)) ;else if (this.peek === $_) {\n        if (!isDigit(this.input.charCodeAt(this.index - 1)) || !isDigit(this.input.charCodeAt(this.index + 1))) {\n          return this.error('Invalid numeric separator', 0);\n        }\n        hasSeparators = true;\n      } else if (this.peek === $PERIOD) {\n        simple = false;\n      } else if (isExponentStart(this.peek)) {\n        this.advance();\n        if (isExponentSign(this.peek)) this.advance();\n        if (!isDigit(this.peek)) return this.error('Invalid exponent', -1);\n        simple = false;\n      } else {\n        break;\n      }\n      this.advance();\n    }\n    let str = this.input.substring(start, this.index);\n    if (hasSeparators) {\n      str = str.replace(/_/g, '');\n    }\n    const value = simple ? parseIntAutoRadix(str) : parseFloat(str);\n    return newNumberToken(start, this.index, value);\n  }\n  scanString() {\n    const start = this.index;\n    const quote = this.peek;\n    this.advance();\n    let buffer = '';\n    let marker = this.index;\n    const input = this.input;\n    while (this.peek != quote) {\n      if (this.peek == $BACKSLASH) {\n        const result = this.scanStringBackslash(buffer, marker);\n        if (typeof result !== 'string') {\n          return result;\n        }\n        buffer = result;\n        marker = this.index;\n      } else if (this.peek == $EOF) {\n        return this.error('Unterminated quote', 0);\n      } else {\n        this.advance();\n      }\n    }\n    const last = input.substring(marker, this.index);\n    this.advance();\n    return new StringToken(start, this.index, buffer + last, StringTokenKind.Plain);\n  }\n  scanQuestion(start) {\n    this.advance();\n    let operator = '?';\n    if (this.peek === $QUESTION) {\n      operator += '?';\n      this.advance();\n      if (this.peek === $EQ) {\n        operator += '=';\n        this.advance();\n      }\n    } else if (this.peek === $PERIOD) {\n      operator += '.';\n      this.advance();\n    }\n    return newOperatorToken(start, this.index, operator);\n  }\n  scanTemplateLiteralPart(start) {\n    let buffer = '';\n    let marker = this.index;\n    while (this.peek !== $BT) {\n      if (this.peek === $BACKSLASH) {\n        const result = this.scanStringBackslash(buffer, marker);\n        if (typeof result !== 'string') {\n          return result;\n        }\n        buffer = result;\n        marker = this.index;\n      } else if (this.peek === $$) {\n        const dollar = this.index;\n        this.advance();\n        if (this.peek === $LBRACE) {\n          this.braceStack.push('interpolation');\n          this.tokens.push(new StringToken(start, dollar, buffer + this.input.substring(marker, dollar), StringTokenKind.TemplateLiteralPart));\n          this.advance();\n          return newOperatorToken(dollar, this.index, this.input.substring(dollar, this.index));\n        }\n      } else if (this.peek === $EOF) {\n        return this.error('Unterminated template literal', 0);\n      } else {\n        this.advance();\n      }\n    }\n    const last = this.input.substring(marker, this.index);\n    this.advance();\n    return new StringToken(start, this.index, buffer + last, StringTokenKind.TemplateLiteralEnd);\n  }\n  error(message, offset) {\n    const position = this.index + offset;\n    return newErrorToken(position, this.index, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n  }\n  scanStringBackslash(buffer, marker) {\n    buffer += this.input.substring(marker, this.index);\n    let unescapedCode;\n    this.advance();\n    if (this.peek === $u) {\n      const hex = this.input.substring(this.index + 1, this.index + 5);\n      if (/^[0-9a-f]+$/i.test(hex)) {\n        unescapedCode = parseInt(hex, 16);\n      } else {\n        return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n      }\n      for (let i = 0; i < 5; i++) {\n        this.advance();\n      }\n    } else {\n      unescapedCode = unescape(this.peek);\n      this.advance();\n    }\n    buffer += String.fromCharCode(unescapedCode);\n    return buffer;\n  }\n  scanStar(start) {\n    this.advance();\n    let operator = '*';\n    if (this.peek === $STAR) {\n      operator += '*';\n      this.advance();\n      if (this.peek === $EQ) {\n        operator += '=';\n        this.advance();\n      }\n    } else if (this.peek === $EQ) {\n      operator += '=';\n      this.advance();\n    }\n    return newOperatorToken(start, this.index, operator);\n  }\n  isStartOfRegex() {\n    if (this.tokens.length === 0) {\n      return true;\n    }\n    const prevToken = this.tokens[this.tokens.length - 1];\n    if (prevToken.isOperator('!')) {\n      const beforePrevToken = this.tokens.length > 1 ? this.tokens[this.tokens.length - 2] : null;\n      const isNegation = beforePrevToken === null || beforePrevToken.type !== TokenType.Identifier && !beforePrevToken.isCharacter($RPAREN) && !beforePrevToken.isCharacter($RBRACKET);\n      return isNegation;\n    }\n    return prevToken.type === TokenType.Operator || prevToken.isCharacter($LPAREN) || prevToken.isCharacter($LBRACKET) || prevToken.isCharacter($COMMA) || prevToken.isCharacter($COLON);\n  }\n  scanRegex(tokenStart) {\n    this.advance();\n    const textStart = this.index;\n    let inEscape = false;\n    let inCharacterClass = false;\n    while (true) {\n      const peek = this.peek;\n      if (peek === $EOF) {\n        return this.error('Unterminated regular expression', 0);\n      }\n      if (inEscape) {\n        inEscape = false;\n      } else if (peek === $BACKSLASH) {\n        inEscape = true;\n      } else if (peek === $LBRACKET) {\n        inCharacterClass = true;\n      } else if (peek === $RBRACKET) {\n        inCharacterClass = false;\n      } else if (peek === $SLASH && !inCharacterClass) {\n        break;\n      }\n      this.advance();\n    }\n    const value = this.input.substring(textStart, this.index);\n    this.advance();\n    const bodyToken = newRegExpBodyToken(tokenStart, this.index, value);\n    const flagsToken = this.scanRegexFlags(this.index);\n    if (flagsToken !== null) {\n      this.tokens.push(bodyToken);\n      return flagsToken;\n    }\n    return bodyToken;\n  }\n  scanRegexFlags(start) {\n    if (!isAsciiLetter(this.peek)) {\n      return null;\n    }\n    while (isAsciiLetter(this.peek)) {\n      this.advance();\n    }\n    return newRegExpFlagsToken(start, this.index, this.input.substring(start, this.index));\n  }\n}\nfunction isIdentifierStart(code) {\n  return $a <= code && code <= $z || $A <= code && code <= $Z || code == $_ || code == $$;\n}\nfunction isIdentifierPart(code) {\n  return isAsciiLetter(code) || isDigit(code) || code == $_ || code == $$;\n}\nfunction isExponentStart(code) {\n  return code == $e || code == $E;\n}\nfunction isExponentSign(code) {\n  return code == $MINUS || code == $PLUS;\n}\nfunction unescape(code) {\n  switch (code) {\n    case $n:\n      return $LF;\n    case $f:\n      return $FF;\n    case $r:\n      return $CR;\n    case $t:\n      return $TAB;\n    case $v:\n      return $VTAB;\n    default:\n      return code;\n  }\n}\nfunction parseIntAutoRadix(text) {\n  const result = parseInt(text);\n  if (isNaN(result)) {\n    throw new Error('Invalid integer literal when parsing ' + text);\n  }\n  return result;\n}\nclass SplitInterpolation {\n  strings;\n  expressions;\n  offsets;\n  constructor(strings, expressions, offsets) {\n    this.strings = strings;\n    this.expressions = expressions;\n    this.offsets = offsets;\n  }\n}\nclass TemplateBindingParseResult {\n  templateBindings;\n  warnings;\n  errors;\n  constructor(templateBindings, warnings, errors) {\n    this.templateBindings = templateBindings;\n    this.warnings = warnings;\n    this.errors = errors;\n  }\n}\nfunction getLocation(span) {\n  return span.start.toString() || '(unknown)';\n}\nclass Parser {\n  _lexer;\n  _supportsDirectPipeReferences;\n  constructor(_lexer, _supportsDirectPipeReferences = false) {\n    this._lexer = _lexer;\n    this._supportsDirectPipeReferences = _supportsDirectPipeReferences;\n  }\n  parseAction(input, parseSourceSpan, absoluteOffset) {\n    const errors = [];\n    this._checkNoInterpolation(errors, input, parseSourceSpan);\n    const {\n      stripped: sourceToLex\n    } = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    const ast = new _ParseAST(input, parseSourceSpan, absoluteOffset, tokens, 1, errors, 0, this._supportsDirectPipeReferences).parseChain();\n    return new ASTWithSource(ast, input, getLocation(parseSourceSpan), absoluteOffset, errors);\n  }\n  parseBinding(input, parseSourceSpan, absoluteOffset) {\n    const errors = [];\n    const ast = this._parseBindingAst(input, parseSourceSpan, absoluteOffset, errors);\n    return new ASTWithSource(ast, input, getLocation(parseSourceSpan), absoluteOffset, errors);\n  }\n  checkSimpleExpression(ast) {\n    const checker = new SimpleExpressionChecker();\n    ast.visit(checker);\n    return checker.errors;\n  }\n  parseSimpleBinding(input, parseSourceSpan, absoluteOffset) {\n    const errors = [];\n    const ast = this._parseBindingAst(input, parseSourceSpan, absoluteOffset, errors);\n    const simplExpressionErrors = this.checkSimpleExpression(ast);\n    if (simplExpressionErrors.length > 0) {\n      errors.push(getParseError(`Host binding expression cannot contain ${simplExpressionErrors.join(' ')}`, input, '', parseSourceSpan));\n    }\n    return new ASTWithSource(ast, input, getLocation(parseSourceSpan), absoluteOffset, errors);\n  }\n  _parseBindingAst(input, parseSourceSpan, absoluteOffset, errors) {\n    this._checkNoInterpolation(errors, input, parseSourceSpan);\n    const {\n      stripped: sourceToLex\n    } = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    return new _ParseAST(input, parseSourceSpan, absoluteOffset, tokens, 0, errors, 0, this._supportsDirectPipeReferences).parseChain();\n  }\n  parseTemplateBindings(templateKey, templateValue, parseSourceSpan, absoluteKeyOffset, absoluteValueOffset) {\n    const tokens = this._lexer.tokenize(templateValue);\n    const errors = [];\n    const parser = new _ParseAST(templateValue, parseSourceSpan, absoluteValueOffset, tokens, 0, errors, 0, this._supportsDirectPipeReferences);\n    return parser.parseTemplateBindings({\n      source: templateKey,\n      span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length)\n    });\n  }\n  parseInterpolation(input, parseSourceSpan, absoluteOffset, interpolatedTokens) {\n    const errors = [];\n    const {\n      strings,\n      expressions,\n      offsets\n    } = this.splitInterpolation(input, parseSourceSpan, errors, interpolatedTokens);\n    if (expressions.length === 0) return null;\n    const expressionNodes = [];\n    for (let i = 0; i < expressions.length; ++i) {\n      const expressionSpan = interpolatedTokens?.[i * 2 + 1]?.sourceSpan;\n      const expressionText = expressions[i].text;\n      const {\n        stripped: sourceToLex,\n        hasComments\n      } = this._stripComments(expressionText);\n      const tokens = this._lexer.tokenize(sourceToLex);\n      if (hasComments && sourceToLex.trim().length === 0 && tokens.length === 0) {\n        errors.push(getParseError('Interpolation expression cannot only contain a comment', input, `at column ${expressions[i].start} in`, parseSourceSpan));\n        continue;\n      }\n      const ast = new _ParseAST(expressionSpan ? expressionText : input, expressionSpan || parseSourceSpan, absoluteOffset, tokens, 0, errors, offsets[i], this._supportsDirectPipeReferences).parseChain();\n      expressionNodes.push(ast);\n    }\n    return this.createInterpolationAst(strings.map(s => s.text), expressionNodes, input, getLocation(parseSourceSpan), absoluteOffset, errors);\n  }\n  parseInterpolationExpression(expression, parseSourceSpan, absoluteOffset) {\n    const {\n      stripped: sourceToLex\n    } = this._stripComments(expression);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    const errors = [];\n    const ast = new _ParseAST(expression, parseSourceSpan, absoluteOffset, tokens, 0, errors, 0, this._supportsDirectPipeReferences).parseChain();\n    const strings = ['', ''];\n    return this.createInterpolationAst(strings, [ast], expression, getLocation(parseSourceSpan), absoluteOffset, errors);\n  }\n  createInterpolationAst(strings, expressions, input, location, absoluteOffset, errors) {\n    const span = new ParseSpan(0, input.length);\n    const interpolation = new Interpolation$1(span, span.toAbsolute(absoluteOffset), strings, expressions);\n    return new ASTWithSource(interpolation, input, location, absoluteOffset, errors);\n  }\n  splitInterpolation(input, parseSourceSpan, errors, interpolatedTokens) {\n    const strings = [];\n    const expressions = [];\n    const offsets = [];\n    const inputToTemplateIndexMap = interpolatedTokens ? getIndexMapForOriginalTemplate(interpolatedTokens) : null;\n    let i = 0;\n    let atInterpolation = false;\n    let extendLastString = false;\n    const interpStart = '{{';\n    const interpEnd = '}}';\n    while (i < input.length) {\n      if (!atInterpolation) {\n        const start = i;\n        i = input.indexOf(interpStart, i);\n        if (i === -1) {\n          i = input.length;\n        }\n        const text = input.substring(start, i);\n        strings.push({\n          text,\n          start,\n          end: i\n        });\n        atInterpolation = true;\n      } else {\n        const fullStart = i;\n        const exprStart = fullStart + interpStart.length;\n        const exprEnd = this._getInterpolationEndIndex(input, interpEnd, exprStart);\n        if (exprEnd === -1) {\n          atInterpolation = false;\n          extendLastString = true;\n          break;\n        }\n        const fullEnd = exprEnd + interpEnd.length;\n        const text = input.substring(exprStart, exprEnd);\n        if (text.trim().length === 0) {\n          errors.push(getParseError('Blank expressions are not allowed in interpolated strings', input, `at column ${i} in`, parseSourceSpan));\n        }\n        expressions.push({\n          text,\n          start: fullStart,\n          end: fullEnd\n        });\n        const startInOriginalTemplate = inputToTemplateIndexMap?.get(fullStart) ?? fullStart;\n        const offset = startInOriginalTemplate + interpStart.length;\n        offsets.push(offset);\n        i = fullEnd;\n        atInterpolation = false;\n      }\n    }\n    if (!atInterpolation) {\n      if (extendLastString) {\n        const piece = strings[strings.length - 1];\n        piece.text += input.substring(i);\n        piece.end = input.length;\n      } else {\n        strings.push({\n          text: input.substring(i),\n          start: i,\n          end: input.length\n        });\n      }\n    }\n    return new SplitInterpolation(strings, expressions, offsets);\n  }\n  wrapLiteralPrimitive(input, sourceSpanOrLocation, absoluteOffset) {\n    const span = new ParseSpan(0, input == null ? 0 : input.length);\n    return new ASTWithSource(new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, typeof sourceSpanOrLocation === 'string' ? sourceSpanOrLocation : getLocation(sourceSpanOrLocation), absoluteOffset, []);\n  }\n  _stripComments(input) {\n    const i = this._commentStart(input);\n    return i != null ? {\n      stripped: input.substring(0, i),\n      hasComments: true\n    } : {\n      stripped: input,\n      hasComments: false\n    };\n  }\n  _commentStart(input) {\n    let outerQuote = null;\n    for (let i = 0; i < input.length - 1; i++) {\n      const char = input.charCodeAt(i);\n      const nextChar = input.charCodeAt(i + 1);\n      if (char === $SLASH && nextChar == $SLASH && outerQuote == null) return i;\n      if (outerQuote === char) {\n        outerQuote = null;\n      } else if (outerQuote == null && isQuote(char)) {\n        outerQuote = char;\n      }\n    }\n    return null;\n  }\n  _checkNoInterpolation(errors, input, parseSourceSpan) {\n    let startIndex = -1;\n    let endIndex = -1;\n    for (const charIndex of this._forEachUnquotedChar(input, 0)) {\n      if (startIndex === -1) {\n        if (input.startsWith('{{')) {\n          startIndex = charIndex;\n        }\n      } else {\n        endIndex = this._getInterpolationEndIndex(input, '}}', charIndex);\n        if (endIndex > -1) {\n          break;\n        }\n      }\n    }\n    if (startIndex > -1 && endIndex > -1) {\n      errors.push(getParseError(`Got interpolation ({{}}) where expression was expected`, input, `at column ${startIndex} in`, parseSourceSpan));\n    }\n  }\n  _getInterpolationEndIndex(input, expressionEnd, start) {\n    for (const charIndex of this._forEachUnquotedChar(input, start)) {\n      if (input.startsWith(expressionEnd, charIndex)) {\n        return charIndex;\n      }\n      if (input.startsWith('//', charIndex)) {\n        return input.indexOf(expressionEnd, charIndex);\n      }\n    }\n    return -1;\n  }\n  *_forEachUnquotedChar(input, start) {\n    let currentQuote = null;\n    let escapeCount = 0;\n    for (let i = start; i < input.length; i++) {\n      const char = input[i];\n      if (isQuote(input.charCodeAt(i)) && (currentQuote === null || currentQuote === char) && escapeCount % 2 === 0) {\n        currentQuote = currentQuote === null ? char : null;\n      } else if (currentQuote === null) {\n        yield i;\n      }\n      escapeCount = char === '\\\\' ? escapeCount + 1 : 0;\n    }\n  }\n}\nvar ParseContextFlags;\n(function (ParseContextFlags) {\n  ParseContextFlags[ParseContextFlags[\"None\"] = 0] = \"None\";\n  ParseContextFlags[ParseContextFlags[\"Writable\"] = 1] = \"Writable\";\n})(ParseContextFlags || (ParseContextFlags = {}));\nconst SUPPORTED_REGEX_FLAGS = new Set(['d', 'g', 'i', 'm', 's', 'u', 'v', 'y']);\nclass _ParseAST {\n  input;\n  parseSourceSpan;\n  absoluteOffset;\n  tokens;\n  parseFlags;\n  errors;\n  offset;\n  supportsDirectPipeReferences;\n  rparensExpected = 0;\n  rbracketsExpected = 0;\n  rbracesExpected = 0;\n  context = ParseContextFlags.None;\n  sourceSpanCache = new Map();\n  index = 0;\n  constructor(input, parseSourceSpan, absoluteOffset, tokens, parseFlags, errors, offset, supportsDirectPipeReferences) {\n    this.input = input;\n    this.parseSourceSpan = parseSourceSpan;\n    this.absoluteOffset = absoluteOffset;\n    this.tokens = tokens;\n    this.parseFlags = parseFlags;\n    this.errors = errors;\n    this.offset = offset;\n    this.supportsDirectPipeReferences = supportsDirectPipeReferences;\n  }\n  peek(offset) {\n    const i = this.index + offset;\n    return i < this.tokens.length ? this.tokens[i] : EOF;\n  }\n  get next() {\n    return this.peek(0);\n  }\n  get atEOF() {\n    return this.index >= this.tokens.length;\n  }\n  get inputIndex() {\n    return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;\n  }\n  get currentEndIndex() {\n    if (this.index > 0) {\n      const curToken = this.peek(-1);\n      return curToken.end + this.offset;\n    }\n    if (this.tokens.length === 0) {\n      return this.input.length + this.offset;\n    }\n    return this.next.index + this.offset;\n  }\n  get currentAbsoluteOffset() {\n    return this.absoluteOffset + this.inputIndex;\n  }\n  span(start, artificialEndIndex) {\n    let endIndex = this.currentEndIndex;\n    if (artificialEndIndex !== undefined && artificialEndIndex > this.currentEndIndex) {\n      endIndex = artificialEndIndex;\n    }\n    if (start > endIndex) {\n      const tmp = endIndex;\n      endIndex = start;\n      start = tmp;\n    }\n    return new ParseSpan(start, endIndex);\n  }\n  sourceSpan(start, artificialEndIndex) {\n    const serial = `${start}@${this.inputIndex}:${artificialEndIndex}`;\n    if (!this.sourceSpanCache.has(serial)) {\n      this.sourceSpanCache.set(serial, this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset));\n    }\n    return this.sourceSpanCache.get(serial);\n  }\n  advance() {\n    this.index++;\n  }\n  withContext(context, cb) {\n    this.context |= context;\n    const ret = cb();\n    this.context ^= context;\n    return ret;\n  }\n  consumeOptionalCharacter(code) {\n    if (this.next.isCharacter(code)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n  peekKeywordLet() {\n    return this.next.isKeywordLet();\n  }\n  peekKeywordAs() {\n    return this.next.isKeywordAs();\n  }\n  expectCharacter(code) {\n    if (this.consumeOptionalCharacter(code)) return;\n    this.error(`Missing expected ${String.fromCharCode(code)}`);\n  }\n  consumeOptionalOperator(op) {\n    if (this.next.isOperator(op)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n  isAssignmentOperator(token) {\n    return token.type === TokenType.Operator && Binary.isAssignmentOperation(token.strValue);\n  }\n  expectOperator(operator) {\n    if (this.consumeOptionalOperator(operator)) return;\n    this.error(`Missing expected operator ${operator}`);\n  }\n  prettyPrintToken(tok) {\n    return tok === EOF ? 'end of input' : `token ${tok}`;\n  }\n  expectIdentifierOrKeyword() {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword()) {\n      if (n.isPrivateIdentifier()) {\n        this._reportErrorForPrivateIdentifier(n, 'expected identifier or keyword');\n      } else {\n        this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier or keyword`);\n      }\n      return null;\n    }\n    this.advance();\n    return n.toString();\n  }\n  expectIdentifierOrKeywordOrString() {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n      if (n.isPrivateIdentifier()) {\n        this._reportErrorForPrivateIdentifier(n, 'expected identifier, keyword or string');\n      } else {\n        this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier, keyword, or string`);\n      }\n      return '';\n    }\n    this.advance();\n    return n.toString();\n  }\n  parseChain() {\n    const exprs = [];\n    const start = this.inputIndex;\n    while (this.index < this.tokens.length) {\n      const expr = this.parsePipe();\n      exprs.push(expr);\n      if (this.consumeOptionalCharacter($SEMICOLON)) {\n        if (!(this.parseFlags & 1)) {\n          this.error('Binding expression cannot contain chained expression');\n        }\n        while (this.consumeOptionalCharacter($SEMICOLON)) {}\n      } else if (this.index < this.tokens.length) {\n        const errorIndex = this.index;\n        this.error(`Unexpected token '${this.next}'`);\n        if (this.index === errorIndex) {\n          break;\n        }\n      }\n    }\n    if (exprs.length === 0) {\n      const artificialStart = this.offset;\n      const artificialEnd = this.offset + this.input.length;\n      return new EmptyExpr$1(this.span(artificialStart, artificialEnd), this.sourceSpan(artificialStart, artificialEnd));\n    }\n    if (exprs.length == 1) return exprs[0];\n    return new Chain(this.span(start), this.sourceSpan(start), exprs);\n  }\n  parsePipe() {\n    const start = this.inputIndex;\n    let result = this.parseExpression();\n    if (this.consumeOptionalOperator('|')) {\n      if (this.parseFlags & 1) {\n        this.error(`Cannot have a pipe in an action expression`);\n      }\n      do {\n        const nameStart = this.inputIndex;\n        let nameId = this.expectIdentifierOrKeyword();\n        let nameSpan;\n        let fullSpanEnd = undefined;\n        if (nameId !== null) {\n          nameSpan = this.sourceSpan(nameStart);\n        } else {\n          nameId = '';\n          fullSpanEnd = this.next.index !== -1 ? this.next.index : this.input.length + this.offset;\n          nameSpan = new ParseSpan(fullSpanEnd, fullSpanEnd).toAbsolute(this.absoluteOffset);\n        }\n        const args = [];\n        while (this.consumeOptionalCharacter($COLON)) {\n          args.push(this.parseExpression());\n        }\n        let type;\n        if (this.supportsDirectPipeReferences) {\n          const charCode = nameId.charCodeAt(0);\n          type = charCode === $_ || charCode >= $A && charCode <= $Z ? BindingPipeType.ReferencedDirectly : BindingPipeType.ReferencedByName;\n        } else {\n          type = BindingPipeType.ReferencedByName;\n        }\n        result = new BindingPipe(this.span(start), this.sourceSpan(start, fullSpanEnd), result, nameId, args, type, nameSpan);\n      } while (this.consumeOptionalOperator('|'));\n    }\n    return result;\n  }\n  parseExpression() {\n    return this.parseConditional();\n  }\n  parseConditional() {\n    const start = this.inputIndex;\n    const result = this.parseLogicalOr();\n    if (this.consumeOptionalOperator('?')) {\n      const yes = this.parsePipe();\n      let no;\n      if (!this.consumeOptionalCharacter($COLON)) {\n        const end = this.inputIndex;\n        const expression = this.input.substring(start, end);\n        this.error(`Conditional expression ${expression} requires all 3 expressions`);\n        no = new EmptyExpr$1(this.span(start), this.sourceSpan(start));\n      } else {\n        no = this.parsePipe();\n      }\n      return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);\n    } else {\n      return result;\n    }\n  }\n  parseLogicalOr() {\n    const start = this.inputIndex;\n    let result = this.parseLogicalAnd();\n    while (this.consumeOptionalOperator('||')) {\n      const right = this.parseLogicalAnd();\n      result = new Binary(this.span(start), this.sourceSpan(start), '||', result, right);\n    }\n    return result;\n  }\n  parseLogicalAnd() {\n    const start = this.inputIndex;\n    let result = this.parseNullishCoalescing();\n    while (this.consumeOptionalOperator('&&')) {\n      const right = this.parseNullishCoalescing();\n      result = new Binary(this.span(start), this.sourceSpan(start), '&&', result, right);\n    }\n    return result;\n  }\n  parseNullishCoalescing() {\n    const start = this.inputIndex;\n    let result = this.parseEquality();\n    while (this.consumeOptionalOperator('??')) {\n      const right = this.parseEquality();\n      result = new Binary(this.span(start), this.sourceSpan(start), '??', result, right);\n    }\n    return result;\n  }\n  parseEquality() {\n    const start = this.inputIndex;\n    let result = this.parseRelational();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '==':\n        case '===':\n        case '!=':\n        case '!==':\n          this.advance();\n          const right = this.parseRelational();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n  parseRelational() {\n    const start = this.inputIndex;\n    let result = this.parseAdditive();\n    while (this.next.type == TokenType.Operator || this.next.isKeywordIn) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n        case 'in':\n          this.advance();\n          const right = this.parseAdditive();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n  parseAdditive() {\n    const start = this.inputIndex;\n    let result = this.parseMultiplicative();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '+':\n        case '-':\n          this.advance();\n          let right = this.parseMultiplicative();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n  parseMultiplicative() {\n    const start = this.inputIndex;\n    let result = this.parseExponentiation();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '*':\n        case '%':\n        case '/':\n          this.advance();\n          const right = this.parseExponentiation();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n  parseExponentiation() {\n    const start = this.inputIndex;\n    let result = this.parsePrefix();\n    while (this.next.type == TokenType.Operator && this.next.strValue === '**') {\n      if (result instanceof Unary || result instanceof PrefixNot || result instanceof TypeofExpression || result instanceof VoidExpression) {\n        this.error('Unary operator used immediately before exponentiation expression. Parenthesis must be used to disambiguate operator precedence');\n      }\n      this.advance();\n      const right = this.parseExponentiation();\n      result = new Binary(this.span(start), this.sourceSpan(start), '**', result, right);\n    }\n    return result;\n  }\n  parsePrefix() {\n    if (this.next.type == TokenType.Operator) {\n      const start = this.inputIndex;\n      const operator = this.next.strValue;\n      let result;\n      switch (operator) {\n        case '+':\n          this.advance();\n          result = this.parsePrefix();\n          return Unary.createPlus(this.span(start), this.sourceSpan(start), result);\n        case '-':\n          this.advance();\n          result = this.parsePrefix();\n          return Unary.createMinus(this.span(start), this.sourceSpan(start), result);\n        case '!':\n          this.advance();\n          result = this.parsePrefix();\n          return new PrefixNot(this.span(start), this.sourceSpan(start), result);\n      }\n    } else if (this.next.isKeywordTypeof()) {\n      this.advance();\n      const start = this.inputIndex;\n      let result = this.parsePrefix();\n      return new TypeofExpression(this.span(start), this.sourceSpan(start), result);\n    } else if (this.next.isKeywordVoid()) {\n      this.advance();\n      const start = this.inputIndex;\n      let result = this.parsePrefix();\n      return new VoidExpression(this.span(start), this.sourceSpan(start), result);\n    }\n    return this.parseCallChain();\n  }\n  parseCallChain() {\n    const start = this.inputIndex;\n    let result = this.parsePrimary();\n    while (true) {\n      if (this.consumeOptionalCharacter($PERIOD)) {\n        result = this.parseAccessMember(result, start, false);\n      } else if (this.consumeOptionalOperator('?.')) {\n        if (this.consumeOptionalCharacter($LPAREN)) {\n          result = this.parseCall(result, start, true);\n        } else {\n          result = this.consumeOptionalCharacter($LBRACKET) ? this.parseKeyedReadOrWrite(result, start, true) : this.parseAccessMember(result, start, true);\n        }\n      } else if (this.consumeOptionalCharacter($LBRACKET)) {\n        result = this.parseKeyedReadOrWrite(result, start, false);\n      } else if (this.consumeOptionalCharacter($LPAREN)) {\n        result = this.parseCall(result, start, false);\n      } else if (this.consumeOptionalOperator('!')) {\n        result = new NonNullAssert(this.span(start), this.sourceSpan(start), result);\n      } else if (this.next.isTemplateLiteralEnd()) {\n        result = this.parseNoInterpolationTaggedTemplateLiteral(result, start);\n      } else if (this.next.isTemplateLiteralPart()) {\n        result = this.parseTaggedTemplateLiteral(result, start);\n      } else {\n        return result;\n      }\n    }\n  }\n  parsePrimary() {\n    const start = this.inputIndex;\n    if (this.consumeOptionalCharacter($LPAREN)) {\n      this.rparensExpected++;\n      const result = this.parsePipe();\n      if (!this.consumeOptionalCharacter($RPAREN)) {\n        this.error('Missing closing parentheses');\n        this.consumeOptionalCharacter($RPAREN);\n      }\n      this.rparensExpected--;\n      return new ParenthesizedExpression(this.span(start), this.sourceSpan(start), result);\n    } else if (this.next.isKeywordNull()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);\n    } else if (this.next.isKeywordUndefined()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);\n    } else if (this.next.isKeywordTrue()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);\n    } else if (this.next.isKeywordFalse()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);\n    } else if (this.next.isKeywordIn()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), 'in');\n    } else if (this.next.isKeywordThis()) {\n      this.advance();\n      return new ThisReceiver(this.span(start), this.sourceSpan(start));\n    } else if (this.consumeOptionalCharacter($LBRACKET)) {\n      this.rbracketsExpected++;\n      const elements = this.parseExpressionList($RBRACKET);\n      this.rbracketsExpected--;\n      this.expectCharacter($RBRACKET);\n      return new LiteralArray(this.span(start), this.sourceSpan(start), elements);\n    } else if (this.next.isCharacter($LBRACE)) {\n      return this.parseLiteralMap();\n    } else if (this.next.isIdentifier()) {\n      return this.parseAccessMember(new ImplicitReceiver(this.span(start), this.sourceSpan(start)), start, false);\n    } else if (this.next.isNumber()) {\n      const value = this.next.toNumber();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);\n    } else if (this.next.isTemplateLiteralEnd()) {\n      return this.parseNoInterpolationTemplateLiteral();\n    } else if (this.next.isTemplateLiteralPart()) {\n      return this.parseTemplateLiteral();\n    } else if (this.next.isString() && this.next.kind === StringTokenKind.Plain) {\n      const literalValue = this.next.toString();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);\n    } else if (this.next.isPrivateIdentifier()) {\n      this._reportErrorForPrivateIdentifier(this.next, null);\n      return new EmptyExpr$1(this.span(start), this.sourceSpan(start));\n    } else if (this.next.isRegExpBody()) {\n      return this.parseRegularExpressionLiteral();\n    } else if (this.index >= this.tokens.length) {\n      this.error(`Unexpected end of expression: ${this.input}`);\n      return new EmptyExpr$1(this.span(start), this.sourceSpan(start));\n    } else {\n      this.error(`Unexpected token ${this.next}`);\n      return new EmptyExpr$1(this.span(start), this.sourceSpan(start));\n    }\n  }\n  parseExpressionList(terminator) {\n    const result = [];\n    do {\n      if (!this.next.isCharacter(terminator)) {\n        result.push(this.parsePipe());\n      } else {\n        break;\n      }\n    } while (this.consumeOptionalCharacter($COMMA));\n    return result;\n  }\n  parseLiteralMap() {\n    const keys = [];\n    const values = [];\n    const start = this.inputIndex;\n    this.expectCharacter($LBRACE);\n    if (!this.consumeOptionalCharacter($RBRACE)) {\n      this.rbracesExpected++;\n      do {\n        const keyStart = this.inputIndex;\n        const quoted = this.next.isString();\n        const key = this.expectIdentifierOrKeywordOrString();\n        const literalMapKey = {\n          key,\n          quoted\n        };\n        keys.push(literalMapKey);\n        if (quoted) {\n          this.expectCharacter($COLON);\n          values.push(this.parsePipe());\n        } else if (this.consumeOptionalCharacter($COLON)) {\n          values.push(this.parsePipe());\n        } else {\n          literalMapKey.isShorthandInitialized = true;\n          const span = this.span(keyStart);\n          const sourceSpan = this.sourceSpan(keyStart);\n          values.push(new PropertyRead(span, sourceSpan, sourceSpan, new ImplicitReceiver(span, sourceSpan), key));\n        }\n      } while (this.consumeOptionalCharacter($COMMA) && !this.next.isCharacter($RBRACE));\n      this.rbracesExpected--;\n      this.expectCharacter($RBRACE);\n    }\n    return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);\n  }\n  parseAccessMember(readReceiver, start, isSafe) {\n    const nameStart = this.inputIndex;\n    const id = this.withContext(ParseContextFlags.Writable, () => {\n      const id = this.expectIdentifierOrKeyword() ?? '';\n      if (id.length === 0) {\n        this.error(`Expected identifier for property access`, readReceiver.span.end);\n      }\n      return id;\n    });\n    const nameSpan = this.sourceSpan(nameStart);\n    if (isSafe) {\n      if (this.isAssignmentOperator(this.next)) {\n        this.advance();\n        this.error(\"The '?.' operator cannot be used in the assignment\");\n        return new EmptyExpr$1(this.span(start), this.sourceSpan(start));\n      } else {\n        return new SafePropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);\n      }\n    } else {\n      if (this.isAssignmentOperator(this.next)) {\n        const operation = this.next.strValue;\n        if (!(this.parseFlags & 1)) {\n          this.advance();\n          this.error('Bindings cannot contain assignments');\n          return new EmptyExpr$1(this.span(start), this.sourceSpan(start));\n        }\n        const receiver = new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);\n        this.advance();\n        const value = this.parseConditional();\n        return new Binary(this.span(start), this.sourceSpan(start), operation, receiver, value);\n      } else {\n        return new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);\n      }\n    }\n  }\n  parseCall(receiver, start, isSafe) {\n    const argumentStart = this.inputIndex;\n    this.rparensExpected++;\n    const args = this.parseCallArguments();\n    const argumentSpan = this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);\n    this.expectCharacter($RPAREN);\n    this.rparensExpected--;\n    const span = this.span(start);\n    const sourceSpan = this.sourceSpan(start);\n    return isSafe ? new SafeCall(span, sourceSpan, receiver, args, argumentSpan) : new Call(span, sourceSpan, receiver, args, argumentSpan);\n  }\n  parseCallArguments() {\n    if (this.next.isCharacter($RPAREN)) return [];\n    const positionals = [];\n    do {\n      positionals.push(this.parsePipe());\n    } while (this.consumeOptionalCharacter($COMMA));\n    return positionals;\n  }\n  expectTemplateBindingKey() {\n    let result = '';\n    let operatorFound = false;\n    const start = this.currentAbsoluteOffset;\n    do {\n      result += this.expectIdentifierOrKeywordOrString();\n      operatorFound = this.consumeOptionalOperator('-');\n      if (operatorFound) {\n        result += '-';\n      }\n    } while (operatorFound);\n    return {\n      source: result,\n      span: new AbsoluteSourceSpan(start, start + result.length)\n    };\n  }\n  parseTemplateBindings(templateKey) {\n    const bindings = [];\n    bindings.push(...this.parseDirectiveKeywordBindings(templateKey));\n    while (this.index < this.tokens.length) {\n      const letBinding = this.parseLetBinding();\n      if (letBinding) {\n        bindings.push(letBinding);\n      } else {\n        const key = this.expectTemplateBindingKey();\n        const binding = this.parseAsBinding(key);\n        if (binding) {\n          bindings.push(binding);\n        } else {\n          key.source = templateKey.source + key.source.charAt(0).toUpperCase() + key.source.substring(1);\n          bindings.push(...this.parseDirectiveKeywordBindings(key));\n        }\n      }\n      this.consumeStatementTerminator();\n    }\n    return new TemplateBindingParseResult(bindings, [], this.errors);\n  }\n  parseKeyedReadOrWrite(receiver, start, isSafe) {\n    return this.withContext(ParseContextFlags.Writable, () => {\n      this.rbracketsExpected++;\n      const key = this.parsePipe();\n      if (key instanceof EmptyExpr$1) {\n        this.error(`Key access cannot be empty`);\n      }\n      this.rbracketsExpected--;\n      this.expectCharacter($RBRACKET);\n      if (this.isAssignmentOperator(this.next)) {\n        const operation = this.next.strValue;\n        if (isSafe) {\n          this.advance();\n          this.error(\"The '?.' operator cannot be used in the assignment\");\n        } else {\n          const binaryReceiver = new KeyedRead(this.span(start), this.sourceSpan(start), receiver, key);\n          this.advance();\n          const value = this.parseConditional();\n          return new Binary(this.span(start), this.sourceSpan(start), operation, binaryReceiver, value);\n        }\n      } else {\n        return isSafe ? new SafeKeyedRead(this.span(start), this.sourceSpan(start), receiver, key) : new KeyedRead(this.span(start), this.sourceSpan(start), receiver, key);\n      }\n      return new EmptyExpr$1(this.span(start), this.sourceSpan(start));\n    });\n  }\n  parseDirectiveKeywordBindings(key) {\n    const bindings = [];\n    this.consumeOptionalCharacter($COLON);\n    const value = this.getDirectiveBoundTarget();\n    let spanEnd = this.currentAbsoluteOffset;\n    const asBinding = this.parseAsBinding(key);\n    if (!asBinding) {\n      this.consumeStatementTerminator();\n      spanEnd = this.currentAbsoluteOffset;\n    }\n    const sourceSpan = new AbsoluteSourceSpan(key.span.start, spanEnd);\n    bindings.push(new ExpressionBinding(sourceSpan, key, value));\n    if (asBinding) {\n      bindings.push(asBinding);\n    }\n    return bindings;\n  }\n  getDirectiveBoundTarget() {\n    if (this.next === EOF || this.peekKeywordAs() || this.peekKeywordLet()) {\n      return null;\n    }\n    const ast = this.parsePipe();\n    const {\n      start,\n      end\n    } = ast.span;\n    const value = this.input.substring(start, end);\n    return new ASTWithSource(ast, value, getLocation(this.parseSourceSpan), this.absoluteOffset + start, this.errors);\n  }\n  parseAsBinding(value) {\n    if (!this.peekKeywordAs()) {\n      return null;\n    }\n    this.advance();\n    const key = this.expectTemplateBindingKey();\n    this.consumeStatementTerminator();\n    const sourceSpan = new AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);\n    return new VariableBinding(sourceSpan, key, value);\n  }\n  parseLetBinding() {\n    if (!this.peekKeywordLet()) {\n      return null;\n    }\n    const spanStart = this.currentAbsoluteOffset;\n    this.advance();\n    const key = this.expectTemplateBindingKey();\n    let value = null;\n    if (this.consumeOptionalOperator('=')) {\n      value = this.expectTemplateBindingKey();\n    }\n    this.consumeStatementTerminator();\n    const sourceSpan = new AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);\n    return new VariableBinding(sourceSpan, key, value);\n  }\n  parseNoInterpolationTaggedTemplateLiteral(tag, start) {\n    const template = this.parseNoInterpolationTemplateLiteral();\n    return new TaggedTemplateLiteral(this.span(start), this.sourceSpan(start), tag, template);\n  }\n  parseNoInterpolationTemplateLiteral() {\n    const text = this.next.strValue;\n    const start = this.inputIndex;\n    this.advance();\n    const span = this.span(start);\n    const sourceSpan = this.sourceSpan(start);\n    return new TemplateLiteral(span, sourceSpan, [new TemplateLiteralElement(span, sourceSpan, text)], []);\n  }\n  parseTaggedTemplateLiteral(tag, start) {\n    const template = this.parseTemplateLiteral();\n    return new TaggedTemplateLiteral(this.span(start), this.sourceSpan(start), tag, template);\n  }\n  parseTemplateLiteral() {\n    const elements = [];\n    const expressions = [];\n    const start = this.inputIndex;\n    while (this.next !== EOF) {\n      const token = this.next;\n      if (token.isTemplateLiteralPart() || token.isTemplateLiteralEnd()) {\n        const partStart = this.inputIndex;\n        this.advance();\n        elements.push(new TemplateLiteralElement(this.span(partStart), this.sourceSpan(partStart), token.strValue));\n        if (token.isTemplateLiteralEnd()) {\n          break;\n        }\n      } else if (token.isTemplateLiteralInterpolationStart()) {\n        this.advance();\n        this.rbracesExpected++;\n        const expression = this.parsePipe();\n        if (expression instanceof EmptyExpr$1) {\n          this.error('Template literal interpolation cannot be empty');\n        } else {\n          expressions.push(expression);\n        }\n        this.rbracesExpected--;\n      } else {\n        this.advance();\n      }\n    }\n    return new TemplateLiteral(this.span(start), this.sourceSpan(start), elements, expressions);\n  }\n  parseRegularExpressionLiteral() {\n    const bodyToken = this.next;\n    this.advance();\n    if (!bodyToken.isRegExpBody()) {\n      return new EmptyExpr$1(this.span(this.inputIndex), this.sourceSpan(this.inputIndex));\n    }\n    let flagsToken = null;\n    if (this.next.isRegExpFlags()) {\n      flagsToken = this.next;\n      this.advance();\n      const seenFlags = new Set();\n      for (let i = 0; i < flagsToken.strValue.length; i++) {\n        const char = flagsToken.strValue[i];\n        if (!SUPPORTED_REGEX_FLAGS.has(char)) {\n          this.error(`Unsupported regular expression flag \"${char}\". The supported flags are: ` + Array.from(SUPPORTED_REGEX_FLAGS, f => `\"${f}\"`).join(', '), flagsToken.index + i);\n        } else if (seenFlags.has(char)) {\n          this.error(`Duplicate regular expression flag \"${char}\"`, flagsToken.index + i);\n        } else {\n          seenFlags.add(char);\n        }\n      }\n    }\n    const start = bodyToken.index;\n    const end = flagsToken ? flagsToken.end : bodyToken.end;\n    return new RegularExpressionLiteral(this.span(start, end), this.sourceSpan(start, end), bodyToken.strValue, flagsToken ? flagsToken.strValue : null);\n  }\n  consumeStatementTerminator() {\n    this.consumeOptionalCharacter($SEMICOLON) || this.consumeOptionalCharacter($COMMA);\n  }\n  error(message, index = this.index) {\n    this.errors.push(getParseError(message, this.input, this.getErrorLocationText(index), this.parseSourceSpan));\n    this.skip();\n  }\n  getErrorLocationText(index) {\n    return index < this.tokens.length ? `at column ${this.tokens[index].index + 1} in` : `at the end of the expression`;\n  }\n  _reportErrorForPrivateIdentifier(token, extraMessage) {\n    let errorMessage = `Private identifiers are not supported. Unexpected private identifier: ${token}`;\n    if (extraMessage !== null) {\n      errorMessage += `, ${extraMessage}`;\n    }\n    this.error(errorMessage);\n  }\n  skip() {\n    let n = this.next;\n    while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) && !n.isOperator('|') && (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) && (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) && (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET)) && (!(this.context & ParseContextFlags.Writable) || !this.isAssignmentOperator(n))) {\n      if (this.next.isError()) {\n        this.errors.push(getParseError(this.next.toString(), this.input, this.getErrorLocationText(this.next.index), this.parseSourceSpan));\n      }\n      this.advance();\n      n = this.next;\n    }\n  }\n}\nfunction getParseError(message, input, locationText, parseSourceSpan) {\n  if (locationText.length > 0) {\n    locationText = ` ${locationText} `;\n  }\n  const location = getLocation(parseSourceSpan);\n  const error = `Parser Error: ${message}${locationText}[${input}] in ${location}`;\n  return new ParseError(parseSourceSpan, error);\n}\nclass SimpleExpressionChecker extends RecursiveAstVisitor {\n  errors = [];\n  visitPipe() {\n    this.errors.push('pipes');\n  }\n}\nfunction getIndexMapForOriginalTemplate(interpolatedTokens) {\n  let offsetMap = new Map();\n  let consumedInOriginalTemplate = 0;\n  let consumedInInput = 0;\n  let tokenIndex = 0;\n  while (tokenIndex < interpolatedTokens.length) {\n    const currentToken = interpolatedTokens[tokenIndex];\n    if (currentToken.type === 9) {\n      const [decoded, encoded] = currentToken.parts;\n      consumedInOriginalTemplate += encoded.length;\n      consumedInInput += decoded.length;\n    } else {\n      const lengthOfParts = currentToken.parts.reduce((sum, current) => sum + current.length, 0);\n      consumedInInput += lengthOfParts;\n      consumedInOriginalTemplate += lengthOfParts;\n    }\n    offsetMap.set(consumedInInput, consumedInOriginalTemplate);\n    tokenIndex++;\n  }\n  return offsetMap;\n}\nfunction serialize(expression) {\n  return expression.visit(new SerializeExpressionVisitor());\n}\nclass SerializeExpressionVisitor {\n  visitUnary(ast, context) {\n    return `${ast.operator}${ast.expr.visit(this, context)}`;\n  }\n  visitBinary(ast, context) {\n    return `${ast.left.visit(this, context)} ${ast.operation} ${ast.right.visit(this, context)}`;\n  }\n  visitChain(ast, context) {\n    return ast.expressions.map(e => e.visit(this, context)).join('; ');\n  }\n  visitConditional(ast, context) {\n    return `${ast.condition.visit(this, context)} ? ${ast.trueExp.visit(this, context)} : ${ast.falseExp.visit(this, context)}`;\n  }\n  visitThisReceiver() {\n    return 'this';\n  }\n  visitImplicitReceiver() {\n    return '';\n  }\n  visitInterpolation(ast, context) {\n    return interleave(ast.strings, ast.expressions.map(e => e.visit(this, context))).join('');\n  }\n  visitKeyedRead(ast, context) {\n    return `${ast.receiver.visit(this, context)}[${ast.key.visit(this, context)}]`;\n  }\n  visitLiteralArray(ast, context) {\n    return `[${ast.expressions.map(e => e.visit(this, context)).join(', ')}]`;\n  }\n  visitLiteralMap(ast, context) {\n    return `{${zip(ast.keys.map(literal => literal.quoted ? `'${literal.key}'` : literal.key), ast.values.map(value => value.visit(this, context))).map(([key, value]) => `${key}: ${value}`).join(', ')}}`;\n  }\n  visitLiteralPrimitive(ast) {\n    if (ast.value === null) return 'null';\n    switch (typeof ast.value) {\n      case 'number':\n      case 'boolean':\n        return ast.value.toString();\n      case 'undefined':\n        return 'undefined';\n      case 'string':\n        return `'${ast.value.replace(/'/g, `\\\\'`)}'`;\n      default:\n        throw new Error(`Unsupported primitive type: ${ast.value}`);\n    }\n  }\n  visitPipe(ast, context) {\n    return `${ast.exp.visit(this, context)} | ${ast.name}`;\n  }\n  visitPrefixNot(ast, context) {\n    return `!${ast.expression.visit(this, context)}`;\n  }\n  visitNonNullAssert(ast, context) {\n    return `${ast.expression.visit(this, context)}!`;\n  }\n  visitPropertyRead(ast, context) {\n    if (ast.receiver instanceof ImplicitReceiver) {\n      return ast.name;\n    } else {\n      return `${ast.receiver.visit(this, context)}.${ast.name}`;\n    }\n  }\n  visitSafePropertyRead(ast, context) {\n    return `${ast.receiver.visit(this, context)}?.${ast.name}`;\n  }\n  visitSafeKeyedRead(ast, context) {\n    return `${ast.receiver.visit(this, context)}?.[${ast.key.visit(this, context)}]`;\n  }\n  visitCall(ast, context) {\n    return `${ast.receiver.visit(this, context)}(${ast.args.map(e => e.visit(this, context)).join(', ')})`;\n  }\n  visitSafeCall(ast, context) {\n    return `${ast.receiver.visit(this, context)}?.(${ast.args.map(e => e.visit(this, context)).join(', ')})`;\n  }\n  visitTypeofExpression(ast, context) {\n    return `typeof ${ast.expression.visit(this, context)}`;\n  }\n  visitVoidExpression(ast, context) {\n    return `void ${ast.expression.visit(this, context)}`;\n  }\n  visitRegularExpressionLiteral(ast, context) {\n    return `/${ast.body}/${ast.flags || ''}`;\n  }\n  visitASTWithSource(ast, context) {\n    return ast.ast.visit(this, context);\n  }\n  visitTemplateLiteral(ast, context) {\n    let result = '';\n    for (let i = 0; i < ast.elements.length; i++) {\n      result += ast.elements[i].visit(this, context);\n      const expression = i < ast.expressions.length ? ast.expressions[i] : null;\n      if (expression !== null) {\n        result += '${' + expression.visit(this, context) + '}';\n      }\n    }\n    return '`' + result + '`';\n  }\n  visitTemplateLiteralElement(ast, context) {\n    return ast.text;\n  }\n  visitTaggedTemplateLiteral(ast, context) {\n    return ast.tag.visit(this, context) + ast.template.visit(this, context);\n  }\n  visitParenthesizedExpression(ast, context) {\n    return '(' + ast.expression.visit(this, context) + ')';\n  }\n}\nfunction zip(left, right) {\n  if (left.length !== right.length) throw new Error('Array lengths must match');\n  return left.map((l, i) => [l, right[i]]);\n}\nfunction interleave(left, right) {\n  const result = [];\n  for (let index = 0; index < Math.max(left.length, right.length); index++) {\n    if (index < left.length) result.push(left[index]);\n    if (index < right.length) result.push(right[index]);\n  }\n  return result;\n}\nlet _SECURITY_SCHEMA;\nfunction SECURITY_SCHEMA() {\n  if (!_SECURITY_SCHEMA) {\n    _SECURITY_SCHEMA = {};\n    registerContext(SecurityContext.HTML, ['iframe|srcdoc', '*|innerHTML', '*|outerHTML']);\n    registerContext(SecurityContext.STYLE, ['*|style']);\n    registerContext(SecurityContext.URL, ['*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href', 'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action', 'img|src', 'input|src', 'ins|cite', 'q|cite', 'source|src', 'track|src', 'video|poster', 'video|src']);\n    registerContext(SecurityContext.RESOURCE_URL, ['applet|code', 'applet|codebase', 'base|href', 'embed|src', 'frame|src', 'head|profile', 'html|manifest', 'iframe|src', 'link|href', 'media|src', 'object|codebase', 'object|data', 'script|src']);\n  }\n  return _SECURITY_SCHEMA;\n}\nfunction registerContext(ctx, specs) {\n  for (const spec of specs) _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;\n}\nconst IFRAME_SECURITY_SENSITIVE_ATTRS = new Set(['sandbox', 'allow', 'allowfullscreen', 'referrerpolicy', 'csp', 'fetchpriority']);\nfunction isIframeSecuritySensitiveAttr(attrName) {\n  return IFRAME_SECURITY_SENSITIVE_ATTRS.has(attrName.toLowerCase());\n}\nclass ElementSchemaRegistry {}\nconst BOOLEAN = 'boolean';\nconst NUMBER = 'number';\nconst STRING = 'string';\nconst OBJECT = 'object';\nconst SCHEMA = ['[Element]|textContent,%ariaActiveDescendantElement,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColIndexText,%ariaColSpan,%ariaControlsElements,%ariaCurrent,%ariaDescribedByElements,%ariaDescription,%ariaDetailsElements,%ariaDisabled,%ariaErrorMessageElements,%ariaExpanded,%ariaFlowToElements,%ariaHasPopup,%ariaHidden,%ariaInvalid,%ariaKeyShortcuts,%ariaLabel,%ariaLabelledByElements,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaOwnsElements,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowIndexText,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot' + ',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored', '[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,!inert,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy', 'abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,search,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy', 'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume', ':svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex', ':svg:graphics^:svg:|', ':svg:animation^:svg:|*begin,*end,*repeat', ':svg:geometry^:svg:|', ':svg:componentTransferFunction^:svg:|', ':svg:gradient^:svg:|', ':svg:textContent^:svg:graphics|', ':svg:textPositioning^:svg:textContent|', 'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username', 'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username', 'audio^media|', 'br^[HTMLElement]|clear', 'base^[HTMLElement]|href,target', 'body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink', 'button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value', 'canvas^[HTMLElement]|#height,#width', 'content^[HTMLElement]|select', 'dl^[HTMLElement]|!compact', 'data^[HTMLElement]|value', 'datalist^[HTMLElement]|', 'details^[HTMLElement]|!open', 'dialog^[HTMLElement]|!open,returnValue', 'dir^[HTMLElement]|!compact', 'div^[HTMLElement]|align', 'embed^[HTMLElement]|align,height,name,src,type,width', 'fieldset^[HTMLElement]|!disabled,name', 'font^[HTMLElement]|color,face,size', 'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target', 'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src', 'frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows', 'hr^[HTMLElement]|align,color,!noShade,size,width', 'head^[HTMLElement]|', 'h1,h2,h3,h4,h5,h6^[HTMLElement]|align', 'html^[HTMLElement]|version', 'iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width', 'img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width', 'input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width', 'li^[HTMLElement]|type,#value', 'label^[HTMLElement]|htmlFor', 'legend^[HTMLElement]|align', 'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type', 'map^[HTMLElement]|name', 'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width', 'menu^[HTMLElement]|!compact', 'meta^[HTMLElement]|content,httpEquiv,media,name,scheme', 'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value', 'ins,del^[HTMLElement]|cite,dateTime', 'ol^[HTMLElement]|!compact,!reversed,#start,type', 'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width', 'optgroup^[HTMLElement]|!disabled,label', 'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value', 'output^[HTMLElement]|defaultValue,%htmlFor,name,value', 'p^[HTMLElement]|align', 'param^[HTMLElement]|name,type,value,valueType', 'picture^[HTMLElement]|', 'pre^[HTMLElement]|#width', 'progress^[HTMLElement]|#max,#value', 'q,blockquote,cite^[HTMLElement]|', 'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type', 'select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value', 'selectedcontent^[HTMLElement]|', 'slot^[HTMLElement]|name', 'source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width', 'span^[HTMLElement]|', 'style^[HTMLElement]|!disabled,media,type', 'search^[HTMLELement]|', 'caption^[HTMLElement]|align', 'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width', 'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width', 'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width', 'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign', 'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign', 'template^[HTMLElement]|', 'textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap', 'time^[HTMLElement]|dateTime', 'title^[HTMLElement]|text', 'track^[HTMLElement]|!default,kind,label,src,srclang', 'ul^[HTMLElement]|!compact,type', 'unknown^[HTMLElement]|', 'video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width', ':svg:a^:svg:graphics|', ':svg:animate^:svg:animation|', ':svg:animateMotion^:svg:animation|', ':svg:animateTransform^:svg:animation|', ':svg:circle^:svg:geometry|', ':svg:clipPath^:svg:graphics|', ':svg:defs^:svg:graphics|', ':svg:desc^:svg:|', ':svg:discard^:svg:|', ':svg:ellipse^:svg:geometry|', ':svg:feBlend^:svg:|', ':svg:feColorMatrix^:svg:|', ':svg:feComponentTransfer^:svg:|', ':svg:feComposite^:svg:|', ':svg:feConvolveMatrix^:svg:|', ':svg:feDiffuseLighting^:svg:|', ':svg:feDisplacementMap^:svg:|', ':svg:feDistantLight^:svg:|', ':svg:feDropShadow^:svg:|', ':svg:feFlood^:svg:|', ':svg:feFuncA^:svg:componentTransferFunction|', ':svg:feFuncB^:svg:componentTransferFunction|', ':svg:feFuncG^:svg:componentTransferFunction|', ':svg:feFuncR^:svg:componentTransferFunction|', ':svg:feGaussianBlur^:svg:|', ':svg:feImage^:svg:|', ':svg:feMerge^:svg:|', ':svg:feMergeNode^:svg:|', ':svg:feMorphology^:svg:|', ':svg:feOffset^:svg:|', ':svg:fePointLight^:svg:|', ':svg:feSpecularLighting^:svg:|', ':svg:feSpotLight^:svg:|', ':svg:feTile^:svg:|', ':svg:feTurbulence^:svg:|', ':svg:filter^:svg:|', ':svg:foreignObject^:svg:graphics|', ':svg:g^:svg:graphics|', ':svg:image^:svg:graphics|decoding', ':svg:line^:svg:geometry|', ':svg:linearGradient^:svg:gradient|', ':svg:mpath^:svg:|', ':svg:marker^:svg:|', ':svg:mask^:svg:|', ':svg:metadata^:svg:|', ':svg:path^:svg:geometry|', ':svg:pattern^:svg:|', ':svg:polygon^:svg:geometry|', ':svg:polyline^:svg:geometry|', ':svg:radialGradient^:svg:gradient|', ':svg:rect^:svg:geometry|', ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan', ':svg:script^:svg:|type', ':svg:set^:svg:animation|', ':svg:stop^:svg:|', ':svg:style^:svg:|!disabled,media,title,type', ':svg:switch^:svg:graphics|', ':svg:symbol^:svg:|', ':svg:tspan^:svg:textPositioning|', ':svg:text^:svg:textPositioning|', ':svg:textPath^:svg:textContent|', ':svg:title^:svg:|', ':svg:use^:svg:graphics|', ':svg:view^:svg:|#zoomAndPan', 'data^[HTMLElement]|value', 'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name', 'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default', 'summary^[HTMLElement]|', 'time^[HTMLElement]|dateTime', ':svg:cursor^:svg:|', ':math:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforeinput,*beforematch,*beforetoggle,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contentvisibilityautostatechange,*contextlost,*contextmenu,*contextrestored,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*scrollend,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex', ':math:math^:math:|', ':math:maction^:math:|', ':math:menclose^:math:|', ':math:merror^:math:|', ':math:mfenced^:math:|', ':math:mfrac^:math:|', ':math:mi^:math:|', ':math:mmultiscripts^:math:|', ':math:mn^:math:|', ':math:mo^:math:|', ':math:mover^:math:|', ':math:mpadded^:math:|', ':math:mphantom^:math:|', ':math:mroot^:math:|', ':math:mrow^:math:|', ':math:ms^:math:|', ':math:mspace^:math:|', ':math:msqrt^:math:|', ':math:mstyle^:math:|', ':math:msub^:math:|', ':math:msubsup^:math:|', ':math:msup^:math:|', ':math:mtable^:math:|', ':math:mtd^:math:|', ':math:mtext^:math:|', ':math:mtr^:math:|', ':math:munder^:math:|', ':math:munderover^:math:|', ':math:semantics^:math:|'];\nconst _ATTR_TO_PROP = new Map(Object.entries({\n  'class': 'className',\n  'for': 'htmlFor',\n  'formaction': 'formAction',\n  'innerHtml': 'innerHTML',\n  'readonly': 'readOnly',\n  'tabindex': 'tabIndex',\n  'aria-activedescendant': 'ariaActiveDescendantElement',\n  'aria-atomic': 'ariaAtomic',\n  'aria-autocomplete': 'ariaAutoComplete',\n  'aria-busy': 'ariaBusy',\n  'aria-checked': 'ariaChecked',\n  'aria-colcount': 'ariaColCount',\n  'aria-colindex': 'ariaColIndex',\n  'aria-colindextext': 'ariaColIndexText',\n  'aria-colspan': 'ariaColSpan',\n  'aria-controls': 'ariaControlsElements',\n  'aria-current': 'ariaCurrent',\n  'aria-describedby': 'ariaDescribedByElements',\n  'aria-description': 'ariaDescription',\n  'aria-details': 'ariaDetailsElements',\n  'aria-disabled': 'ariaDisabled',\n  'aria-errormessage': 'ariaErrorMessageElements',\n  'aria-expanded': 'ariaExpanded',\n  'aria-flowto': 'ariaFlowToElements',\n  'aria-haspopup': 'ariaHasPopup',\n  'aria-hidden': 'ariaHidden',\n  'aria-invalid': 'ariaInvalid',\n  'aria-keyshortcuts': 'ariaKeyShortcuts',\n  'aria-label': 'ariaLabel',\n  'aria-labelledby': 'ariaLabelledByElements',\n  'aria-level': 'ariaLevel',\n  'aria-live': 'ariaLive',\n  'aria-modal': 'ariaModal',\n  'aria-multiline': 'ariaMultiLine',\n  'aria-multiselectable': 'ariaMultiSelectable',\n  'aria-orientation': 'ariaOrientation',\n  'aria-owns': 'ariaOwnsElements',\n  'aria-placeholder': 'ariaPlaceholder',\n  'aria-posinset': 'ariaPosInSet',\n  'aria-pressed': 'ariaPressed',\n  'aria-readonly': 'ariaReadOnly',\n  'aria-required': 'ariaRequired',\n  'aria-roledescription': 'ariaRoleDescription',\n  'aria-rowcount': 'ariaRowCount',\n  'aria-rowindex': 'ariaRowIndex',\n  'aria-rowindextext': 'ariaRowIndexText',\n  'aria-rowspan': 'ariaRowSpan',\n  'aria-selected': 'ariaSelected',\n  'aria-setsize': 'ariaSetSize',\n  'aria-sort': 'ariaSort',\n  'aria-valuemax': 'ariaValueMax',\n  'aria-valuemin': 'ariaValueMin',\n  'aria-valuenow': 'ariaValueNow',\n  'aria-valuetext': 'ariaValueText'\n}));\nconst _PROP_TO_ATTR = Array.from(_ATTR_TO_PROP).reduce((inverted, [propertyName, attributeName]) => {\n  inverted.set(propertyName, attributeName);\n  return inverted;\n}, new Map());\nclass DomElementSchemaRegistry extends ElementSchemaRegistry {\n  _schema = new Map();\n  _eventSchema = new Map();\n  constructor() {\n    super();\n    SCHEMA.forEach(encodedType => {\n      const type = new Map();\n      const events = new Set();\n      const [strType, strProperties] = encodedType.split('|');\n      const properties = strProperties.split(',');\n      const [typeNames, superName] = strType.split('^');\n      typeNames.split(',').forEach(tag => {\n        this._schema.set(tag.toLowerCase(), type);\n        this._eventSchema.set(tag.toLowerCase(), events);\n      });\n      const superType = superName && this._schema.get(superName.toLowerCase());\n      if (superType) {\n        for (const [prop, value] of superType) {\n          type.set(prop, value);\n        }\n        for (const superEvent of this._eventSchema.get(superName.toLowerCase())) {\n          events.add(superEvent);\n        }\n      }\n      properties.forEach(property => {\n        if (property.length > 0) {\n          switch (property[0]) {\n            case '*':\n              events.add(property.substring(1));\n              break;\n            case '!':\n              type.set(property.substring(1), BOOLEAN);\n              break;\n            case '#':\n              type.set(property.substring(1), NUMBER);\n              break;\n            case '%':\n              type.set(property.substring(1), OBJECT);\n              break;\n            default:\n              type.set(property, STRING);\n          }\n        }\n      });\n    });\n  }\n  hasProperty(tagName, propName, schemaMetas) {\n    if (schemaMetas.some(schema => schema.name === NO_ERRORS_SCHEMA.name)) {\n      return true;\n    }\n    if (tagName.indexOf('-') > -1) {\n      if (isNgContainer(tagName) || isNgContent(tagName)) {\n        return false;\n      }\n      if (schemaMetas.some(schema => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {\n        return true;\n      }\n    }\n    const elementProperties = this._schema.get(tagName.toLowerCase()) || this._schema.get('unknown');\n    return elementProperties.has(propName);\n  }\n  hasElement(tagName, schemaMetas) {\n    if (schemaMetas.some(schema => schema.name === NO_ERRORS_SCHEMA.name)) {\n      return true;\n    }\n    if (tagName.indexOf('-') > -1) {\n      if (isNgContainer(tagName) || isNgContent(tagName)) {\n        return true;\n      }\n      if (schemaMetas.some(schema => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {\n        return true;\n      }\n    }\n    return this._schema.has(tagName.toLowerCase());\n  }\n  securityContext(tagName, propName, isAttribute) {\n    if (isAttribute) {\n      propName = this.getMappedPropName(propName);\n    }\n    tagName = tagName.toLowerCase();\n    propName = propName.toLowerCase();\n    let ctx = SECURITY_SCHEMA()[tagName + '|' + propName];\n    if (ctx) {\n      return ctx;\n    }\n    ctx = SECURITY_SCHEMA()['*|' + propName];\n    return ctx ? ctx : SecurityContext.NONE;\n  }\n  getMappedPropName(propName) {\n    return _ATTR_TO_PROP.get(propName) ?? propName;\n  }\n  getDefaultComponentElementName() {\n    return 'ng-component';\n  }\n  validateProperty(name) {\n    if (name.toLowerCase().startsWith('on')) {\n      const msg = `Binding to event property '${name}' is disallowed for security reasons, ` + `please use (${name.slice(2)})=...` + `\\nIf '${name}' is a directive input, make sure the directive is imported by the` + ` current module.`;\n      return {\n        error: true,\n        msg: msg\n      };\n    } else {\n      return {\n        error: false\n      };\n    }\n  }\n  validateAttribute(name) {\n    if (name.toLowerCase().startsWith('on')) {\n      const msg = `Binding to event attribute '${name}' is disallowed for security reasons, ` + `please use (${name.slice(2)})=...`;\n      return {\n        error: true,\n        msg: msg\n      };\n    } else {\n      return {\n        error: false\n      };\n    }\n  }\n  allKnownElementNames() {\n    return Array.from(this._schema.keys());\n  }\n  allKnownAttributesOfElement(tagName) {\n    const elementProperties = this._schema.get(tagName.toLowerCase()) || this._schema.get('unknown');\n    return Array.from(elementProperties.keys()).map(prop => _PROP_TO_ATTR.get(prop) ?? prop);\n  }\n  allKnownEventsOfElement(tagName) {\n    return Array.from(this._eventSchema.get(tagName.toLowerCase()) ?? []);\n  }\n  normalizeAnimationStyleProperty(propName) {\n    return dashCaseToCamelCase(propName);\n  }\n  normalizeAnimationStyleValue(camelCaseProp, userProvidedProp, val) {\n    let unit = '';\n    const strVal = val.toString().trim();\n    let errorMsg = null;\n    if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {\n      if (typeof val === 'number') {\n        unit = 'px';\n      } else {\n        const valAndSuffixMatch = val.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n        if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n          errorMsg = `Please provide a CSS unit value for ${userProvidedProp}:${val}`;\n        }\n      }\n    }\n    return {\n      error: errorMsg,\n      value: strVal + unit\n    };\n  }\n}\nfunction _isPixelDimensionStyle(prop) {\n  switch (prop) {\n    case 'width':\n    case 'height':\n    case 'minWidth':\n    case 'minHeight':\n    case 'maxWidth':\n    case 'maxHeight':\n    case 'left':\n    case 'top':\n    case 'bottom':\n    case 'right':\n    case 'fontSize':\n    case 'outlineWidth':\n    case 'outlineOffset':\n    case 'paddingTop':\n    case 'paddingLeft':\n    case 'paddingBottom':\n    case 'paddingRight':\n    case 'marginTop':\n    case 'marginLeft':\n    case 'marginBottom':\n    case 'marginRight':\n    case 'borderRadius':\n    case 'borderWidth':\n    case 'borderTopWidth':\n    case 'borderLeftWidth':\n    case 'borderRightWidth':\n    case 'borderBottomWidth':\n    case 'textIndent':\n      return true;\n    default:\n      return false;\n  }\n}\nclass HtmlTagDefinition {\n  closedByChildren = {};\n  contentType;\n  closedByParent = false;\n  implicitNamespacePrefix;\n  isVoid;\n  ignoreFirstLf;\n  canSelfClose;\n  preventNamespaceInheritance;\n  constructor({\n    closedByChildren,\n    implicitNamespacePrefix,\n    contentType = TagContentType.PARSABLE_DATA,\n    closedByParent = false,\n    isVoid = false,\n    ignoreFirstLf = false,\n    preventNamespaceInheritance = false,\n    canSelfClose = false\n  } = {}) {\n    if (closedByChildren && closedByChildren.length > 0) {\n      closedByChildren.forEach(tagName => this.closedByChildren[tagName] = true);\n    }\n    this.isVoid = isVoid;\n    this.closedByParent = closedByParent || isVoid;\n    this.implicitNamespacePrefix = implicitNamespacePrefix || null;\n    this.contentType = contentType;\n    this.ignoreFirstLf = ignoreFirstLf;\n    this.preventNamespaceInheritance = preventNamespaceInheritance;\n    this.canSelfClose = canSelfClose ?? isVoid;\n  }\n  isClosedByChild(name) {\n    return this.isVoid || name.toLowerCase() in this.closedByChildren;\n  }\n  getContentType(prefix) {\n    if (typeof this.contentType === 'object') {\n      const overrideType = prefix === undefined ? undefined : this.contentType[prefix];\n      return overrideType ?? this.contentType.default;\n    }\n    return this.contentType;\n  }\n}\nlet DEFAULT_TAG_DEFINITION;\nlet TAG_DEFINITIONS;\nfunction getHtmlTagDefinition(tagName) {\n  if (!TAG_DEFINITIONS) {\n    DEFAULT_TAG_DEFINITION = new HtmlTagDefinition({\n      canSelfClose: true\n    });\n    TAG_DEFINITIONS = Object.assign(Object.create(null), {\n      'base': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'meta': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'area': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'embed': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'link': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'img': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'input': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'param': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'hr': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'br': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'source': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'track': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'wbr': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'p': new HtmlTagDefinition({\n        closedByChildren: ['address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'],\n        closedByParent: true\n      }),\n      'thead': new HtmlTagDefinition({\n        closedByChildren: ['tbody', 'tfoot']\n      }),\n      'tbody': new HtmlTagDefinition({\n        closedByChildren: ['tbody', 'tfoot'],\n        closedByParent: true\n      }),\n      'tfoot': new HtmlTagDefinition({\n        closedByChildren: ['tbody'],\n        closedByParent: true\n      }),\n      'tr': new HtmlTagDefinition({\n        closedByChildren: ['tr'],\n        closedByParent: true\n      }),\n      'td': new HtmlTagDefinition({\n        closedByChildren: ['td', 'th'],\n        closedByParent: true\n      }),\n      'th': new HtmlTagDefinition({\n        closedByChildren: ['td', 'th'],\n        closedByParent: true\n      }),\n      'col': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'svg': new HtmlTagDefinition({\n        implicitNamespacePrefix: 'svg'\n      }),\n      'foreignObject': new HtmlTagDefinition({\n        implicitNamespacePrefix: 'svg',\n        preventNamespaceInheritance: true\n      }),\n      'math': new HtmlTagDefinition({\n        implicitNamespacePrefix: 'math'\n      }),\n      'li': new HtmlTagDefinition({\n        closedByChildren: ['li'],\n        closedByParent: true\n      }),\n      'dt': new HtmlTagDefinition({\n        closedByChildren: ['dt', 'dd']\n      }),\n      'dd': new HtmlTagDefinition({\n        closedByChildren: ['dt', 'dd'],\n        closedByParent: true\n      }),\n      'rb': new HtmlTagDefinition({\n        closedByChildren: ['rb', 'rt', 'rtc', 'rp'],\n        closedByParent: true\n      }),\n      'rt': new HtmlTagDefinition({\n        closedByChildren: ['rb', 'rt', 'rtc', 'rp'],\n        closedByParent: true\n      }),\n      'rtc': new HtmlTagDefinition({\n        closedByChildren: ['rb', 'rtc', 'rp'],\n        closedByParent: true\n      }),\n      'rp': new HtmlTagDefinition({\n        closedByChildren: ['rb', 'rt', 'rtc', 'rp'],\n        closedByParent: true\n      }),\n      'optgroup': new HtmlTagDefinition({\n        closedByChildren: ['optgroup'],\n        closedByParent: true\n      }),\n      'option': new HtmlTagDefinition({\n        closedByChildren: ['option', 'optgroup'],\n        closedByParent: true\n      }),\n      'pre': new HtmlTagDefinition({\n        ignoreFirstLf: true\n      }),\n      'listing': new HtmlTagDefinition({\n        ignoreFirstLf: true\n      }),\n      'style': new HtmlTagDefinition({\n        contentType: TagContentType.RAW_TEXT\n      }),\n      'script': new HtmlTagDefinition({\n        contentType: TagContentType.RAW_TEXT\n      }),\n      'title': new HtmlTagDefinition({\n        contentType: {\n          default: TagContentType.ESCAPABLE_RAW_TEXT,\n          svg: TagContentType.PARSABLE_DATA\n        }\n      }),\n      'textarea': new HtmlTagDefinition({\n        contentType: TagContentType.ESCAPABLE_RAW_TEXT,\n        ignoreFirstLf: true\n      })\n    });\n    new DomElementSchemaRegistry().allKnownElementNames().forEach(knownTagName => {\n      if (!TAG_DEFINITIONS[knownTagName] && getNsPrefix(knownTagName) === null) {\n        TAG_DEFINITIONS[knownTagName] = new HtmlTagDefinition({\n          canSelfClose: false\n        });\n      }\n    });\n  }\n  return TAG_DEFINITIONS[tagName] ?? TAG_DEFINITIONS[tagName.toLowerCase()] ?? DEFAULT_TAG_DEFINITION;\n}\nconst TAG_TO_PLACEHOLDER_NAMES = {\n  'A': 'LINK',\n  'B': 'BOLD_TEXT',\n  'BR': 'LINE_BREAK',\n  'EM': 'EMPHASISED_TEXT',\n  'H1': 'HEADING_LEVEL1',\n  'H2': 'HEADING_LEVEL2',\n  'H3': 'HEADING_LEVEL3',\n  'H4': 'HEADING_LEVEL4',\n  'H5': 'HEADING_LEVEL5',\n  'H6': 'HEADING_LEVEL6',\n  'HR': 'HORIZONTAL_RULE',\n  'I': 'ITALIC_TEXT',\n  'LI': 'LIST_ITEM',\n  'LINK': 'MEDIA_LINK',\n  'OL': 'ORDERED_LIST',\n  'P': 'PARAGRAPH',\n  'Q': 'QUOTATION',\n  'S': 'STRIKETHROUGH_TEXT',\n  'SMALL': 'SMALL_TEXT',\n  'SUB': 'SUBSTRIPT',\n  'SUP': 'SUPERSCRIPT',\n  'TBODY': 'TABLE_BODY',\n  'TD': 'TABLE_CELL',\n  'TFOOT': 'TABLE_FOOTER',\n  'TH': 'TABLE_HEADER_CELL',\n  'THEAD': 'TABLE_HEADER',\n  'TR': 'TABLE_ROW',\n  'TT': 'MONOSPACED_TEXT',\n  'U': 'UNDERLINED_TEXT',\n  'UL': 'UNORDERED_LIST'\n};\nclass PlaceholderRegistry {\n  _placeHolderNameCounts = {};\n  _signatureToName = {};\n  getStartTagPlaceholderName(tag, attrs, isVoid) {\n    const signature = this._hashTag(tag, attrs, isVoid);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n    const upperTag = tag.toUpperCase();\n    const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n    const name = this._generateUniqueName(isVoid ? baseName : `START_${baseName}`);\n    this._signatureToName[signature] = name;\n    return name;\n  }\n  getCloseTagPlaceholderName(tag) {\n    const signature = this._hashClosingTag(tag);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n    const upperTag = tag.toUpperCase();\n    const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n    const name = this._generateUniqueName(`CLOSE_${baseName}`);\n    this._signatureToName[signature] = name;\n    return name;\n  }\n  getPlaceholderName(name, content) {\n    const upperName = name.toUpperCase();\n    const signature = `PH: ${upperName}=${content}`;\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n    const uniqueName = this._generateUniqueName(upperName);\n    this._signatureToName[signature] = uniqueName;\n    return uniqueName;\n  }\n  getUniquePlaceholder(name) {\n    return this._generateUniqueName(name.toUpperCase());\n  }\n  getStartBlockPlaceholderName(name, parameters) {\n    const signature = this._hashBlock(name, parameters);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n    const placeholder = this._generateUniqueName(`START_BLOCK_${this._toSnakeCase(name)}`);\n    this._signatureToName[signature] = placeholder;\n    return placeholder;\n  }\n  getCloseBlockPlaceholderName(name) {\n    const signature = this._hashClosingBlock(name);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n    const placeholder = this._generateUniqueName(`CLOSE_BLOCK_${this._toSnakeCase(name)}`);\n    this._signatureToName[signature] = placeholder;\n    return placeholder;\n  }\n  _hashTag(tag, attrs, isVoid) {\n    const start = `<${tag}`;\n    const strAttrs = Object.keys(attrs).sort().map(name => ` ${name}=${attrs[name]}`).join('');\n    const end = isVoid ? '/>' : `></${tag}>`;\n    return start + strAttrs + end;\n  }\n  _hashClosingTag(tag) {\n    return this._hashTag(`/${tag}`, {}, false);\n  }\n  _hashBlock(name, parameters) {\n    const params = parameters.length === 0 ? '' : ` (${parameters.sort().join('; ')})`;\n    return `@${name}${params} {}`;\n  }\n  _hashClosingBlock(name) {\n    return this._hashBlock(`close_${name}`, []);\n  }\n  _toSnakeCase(name) {\n    return name.toUpperCase().replace(/[^A-Z0-9]/g, '_');\n  }\n  _generateUniqueName(base) {\n    const seen = this._placeHolderNameCounts.hasOwnProperty(base);\n    if (!seen) {\n      this._placeHolderNameCounts[base] = 1;\n      return base;\n    }\n    const id = this._placeHolderNameCounts[base];\n    this._placeHolderNameCounts[base] = id + 1;\n    return `${base}_${id}`;\n  }\n}\nconst _expParser = new Parser(new Lexer());\nfunction createI18nMessageFactory(containerBlocks, retainEmptyTokens, preserveExpressionWhitespace) {\n  const visitor = new _I18nVisitor(_expParser, containerBlocks, retainEmptyTokens, preserveExpressionWhitespace);\n  return (nodes, meaning, description, customId, visitNodeFn) => visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n}\nfunction noopVisitNodeFn(_html, i18n) {\n  return i18n;\n}\nclass _I18nVisitor {\n  _expressionParser;\n  _containerBlocks;\n  _retainEmptyTokens;\n  _preserveExpressionWhitespace;\n  constructor(_expressionParser, _containerBlocks, _retainEmptyTokens, _preserveExpressionWhitespace) {\n    this._expressionParser = _expressionParser;\n    this._containerBlocks = _containerBlocks;\n    this._retainEmptyTokens = _retainEmptyTokens;\n    this._preserveExpressionWhitespace = _preserveExpressionWhitespace;\n  }\n  toI18nMessage(nodes, meaning = '', description = '', customId = '', visitNodeFn) {\n    const context = {\n      isIcu: nodes.length == 1 && nodes[0] instanceof Expansion,\n      icuDepth: 0,\n      placeholderRegistry: new PlaceholderRegistry(),\n      placeholderToContent: {},\n      placeholderToMessage: {},\n      visitNodeFn: visitNodeFn || noopVisitNodeFn\n    };\n    const i18nodes = visitAll(this, nodes, context);\n    return new Message(i18nodes, context.placeholderToContent, context.placeholderToMessage, meaning, description, customId);\n  }\n  visitElement(el, context) {\n    return this._visitElementLike(el, context);\n  }\n  visitComponent(component, context) {\n    return this._visitElementLike(component, context);\n  }\n  visitDirective(directive, context) {\n    throw new Error('Unreachable code');\n  }\n  visitAttribute(attribute, context) {\n    const node = attribute.valueTokens === undefined || attribute.valueTokens.length === 1 ? new Text$2(attribute.value, attribute.valueSpan || attribute.sourceSpan) : this._visitTextWithInterpolation(attribute.valueTokens, attribute.valueSpan || attribute.sourceSpan, context, attribute.i18n);\n    return context.visitNodeFn(attribute, node);\n  }\n  visitText(text, context) {\n    const node = text.tokens.length === 1 ? new Text$2(text.value, text.sourceSpan) : this._visitTextWithInterpolation(text.tokens, text.sourceSpan, context, text.i18n);\n    return context.visitNodeFn(text, node);\n  }\n  visitComment(comment, context) {\n    return null;\n  }\n  visitExpansion(icu, context) {\n    context.icuDepth++;\n    const i18nIcuCases = {};\n    const i18nIcu = new Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n    icu.cases.forEach(caze => {\n      i18nIcuCases[caze.value] = new Container(caze.expression.map(node => node.visit(this, context)), caze.expSourceSpan);\n    });\n    context.icuDepth--;\n    if (context.isIcu || context.icuDepth > 0) {\n      const expPh = context.placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);\n      i18nIcu.expressionPlaceholder = expPh;\n      context.placeholderToContent[expPh] = {\n        text: icu.switchValue,\n        sourceSpan: icu.switchValueSourceSpan\n      };\n      return context.visitNodeFn(icu, i18nIcu);\n    }\n    const phName = context.placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\n    context.placeholderToMessage[phName] = this.toI18nMessage([icu], '', '', '', undefined);\n    const node = new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n    return context.visitNodeFn(icu, node);\n  }\n  visitExpansionCase(_icuCase, _context) {\n    throw new Error('Unreachable code');\n  }\n  visitBlock(block, context) {\n    const children = visitAll(this, block.children, context);\n    if (this._containerBlocks.has(block.name)) {\n      return new Container(children, block.sourceSpan);\n    }\n    const parameters = block.parameters.map(param => param.expression);\n    const startPhName = context.placeholderRegistry.getStartBlockPlaceholderName(block.name, parameters);\n    const closePhName = context.placeholderRegistry.getCloseBlockPlaceholderName(block.name);\n    context.placeholderToContent[startPhName] = {\n      text: block.startSourceSpan.toString(),\n      sourceSpan: block.startSourceSpan\n    };\n    context.placeholderToContent[closePhName] = {\n      text: block.endSourceSpan ? block.endSourceSpan.toString() : '}',\n      sourceSpan: block.endSourceSpan ?? block.sourceSpan\n    };\n    const node = new BlockPlaceholder(block.name, parameters, startPhName, closePhName, children, block.sourceSpan, block.startSourceSpan, block.endSourceSpan);\n    return context.visitNodeFn(block, node);\n  }\n  visitBlockParameter(_parameter, _context) {\n    throw new Error('Unreachable code');\n  }\n  visitLetDeclaration(decl, context) {\n    return null;\n  }\n  _visitElementLike(node, context) {\n    const children = visitAll(this, node.children, context);\n    const attrs = {};\n    const visitAttribute = attr => {\n      attrs[attr.name] = attr.value;\n    };\n    let nodeName;\n    let isVoid;\n    if (node instanceof Element) {\n      nodeName = node.name;\n      isVoid = getHtmlTagDefinition(node.name).isVoid;\n    } else {\n      nodeName = node.fullName;\n      isVoid = node.tagName ? getHtmlTagDefinition(node.tagName).isVoid : false;\n    }\n    node.attrs.forEach(visitAttribute);\n    node.directives.forEach(dir => dir.attrs.forEach(visitAttribute));\n    const startPhName = context.placeholderRegistry.getStartTagPlaceholderName(nodeName, attrs, isVoid);\n    context.placeholderToContent[startPhName] = {\n      text: node.startSourceSpan.toString(),\n      sourceSpan: node.startSourceSpan\n    };\n    let closePhName = '';\n    if (!isVoid) {\n      closePhName = context.placeholderRegistry.getCloseTagPlaceholderName(nodeName);\n      context.placeholderToContent[closePhName] = {\n        text: `</${nodeName}>`,\n        sourceSpan: node.endSourceSpan ?? node.sourceSpan\n      };\n    }\n    const i18nNode = new TagPlaceholder(nodeName, attrs, startPhName, closePhName, children, isVoid, node.sourceSpan, node.startSourceSpan, node.endSourceSpan);\n    return context.visitNodeFn(node, i18nNode);\n  }\n  _visitTextWithInterpolation(tokens, sourceSpan, context, previousI18n) {\n    const nodes = [];\n    let hasInterpolation = false;\n    for (const token of tokens) {\n      switch (token.type) {\n        case 8:\n        case 17:\n          hasInterpolation = true;\n          const [startMarker, expression, endMarker] = token.parts;\n          const baseName = extractPlaceholderName(expression) || 'INTERPOLATION';\n          const phName = context.placeholderRegistry.getPlaceholderName(baseName, expression);\n          if (this._preserveExpressionWhitespace) {\n            context.placeholderToContent[phName] = {\n              text: token.parts.join(''),\n              sourceSpan: token.sourceSpan\n            };\n            nodes.push(new Placeholder(expression, phName, token.sourceSpan));\n          } else {\n            const normalized = this.normalizeExpression(token);\n            context.placeholderToContent[phName] = {\n              text: `${startMarker}${normalized}${endMarker}`,\n              sourceSpan: token.sourceSpan\n            };\n            nodes.push(new Placeholder(normalized, phName, token.sourceSpan));\n          }\n          break;\n        default:\n          if (token.parts[0].length > 0 || this._retainEmptyTokens) {\n            const previous = nodes[nodes.length - 1];\n            if (previous instanceof Text$2) {\n              previous.value += token.parts[0];\n              previous.sourceSpan = new ParseSourceSpan(previous.sourceSpan.start, token.sourceSpan.end, previous.sourceSpan.fullStart, previous.sourceSpan.details);\n            } else {\n              nodes.push(new Text$2(token.parts[0], token.sourceSpan));\n            }\n          } else {\n            if (this._retainEmptyTokens) {\n              nodes.push(new Text$2(token.parts[0], token.sourceSpan));\n            }\n          }\n          break;\n      }\n    }\n    if (hasInterpolation) {\n      reusePreviousSourceSpans(nodes, previousI18n);\n      return new Container(nodes, sourceSpan);\n    } else {\n      return nodes[0];\n    }\n  }\n  normalizeExpression(token) {\n    const expression = token.parts[1];\n    const expr = this._expressionParser.parseBinding(expression, token.sourceSpan, token.sourceSpan.start.offset);\n    return serialize(expr);\n  }\n}\nfunction reusePreviousSourceSpans(nodes, previousI18n) {\n  if (previousI18n instanceof Message) {\n    assertSingleContainerMessage(previousI18n);\n    previousI18n = previousI18n.nodes[0];\n  }\n  if (previousI18n instanceof Container) {\n    assertEquivalentNodes(previousI18n.children, nodes);\n    for (let i = 0; i < nodes.length; i++) {\n      nodes[i].sourceSpan = previousI18n.children[i].sourceSpan;\n    }\n  }\n}\nfunction assertSingleContainerMessage(message) {\n  const nodes = message.nodes;\n  if (nodes.length !== 1 || !(nodes[0] instanceof Container)) {\n    throw new Error('Unexpected previous i18n message - expected it to consist of only a single `Container` node.');\n  }\n}\nfunction assertEquivalentNodes(previousNodes, nodes) {\n  if (previousNodes.length !== nodes.length) {\n    throw new Error(`\nThe number of i18n message children changed between first and second pass.\n\nFirst pass (${previousNodes.length} tokens):\n${previousNodes.map(node => `\"${node.sourceSpan.toString()}\"`).join('\\n')}\n\nSecond pass (${nodes.length} tokens):\n${nodes.map(node => `\"${node.sourceSpan.toString()}\"`).join('\\n')}\n    `.trim());\n  }\n  if (previousNodes.some((node, i) => nodes[i].constructor !== node.constructor)) {\n    throw new Error('The types of the i18n message children changed between first and second pass.');\n  }\n}\nconst _CUSTOM_PH_EXP = /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\nfunction extractPlaceholderName(input) {\n  return input.split(_CUSTOM_PH_EXP)[2];\n}\nconst UNUSABLE_INTERPOLATION_REGEXPS = [/@/, /^\\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\\/\\//];\nfunction assertInterpolationSymbols(identifier, value) {\n  if (value != null && !(Array.isArray(value) && value.length == 2)) {\n    throw new Error(`Expected '${identifier}' to be an array, [start, end].`);\n  } else if (value != null) {\n    const start = value[0];\n    const end = value[1];\n    UNUSABLE_INTERPOLATION_REGEXPS.forEach(regexp => {\n      if (regexp.test(start) || regexp.test(end)) {\n        throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);\n      }\n    });\n  }\n}\nclass InterpolationConfig {\n  start;\n  end;\n  static fromArray(markers) {\n    if (!markers) {\n      return DEFAULT_INTERPOLATION_CONFIG;\n    }\n    assertInterpolationSymbols('interpolation', markers);\n    return new InterpolationConfig(markers[0], markers[1]);\n  }\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n}\nconst DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');\nconst DEFAULT_CONTAINER_BLOCKS = new Set(['switch']);\nconst TRUSTED_TYPES_SINKS = new Set(['iframe|srcdoc', '*|innerhtml', '*|outerhtml', 'embed|src', 'object|codebase', 'object|data']);\nfunction isTrustedTypesSink(tagName, propName) {\n  tagName = tagName.toLowerCase();\n  propName = propName.toLowerCase();\n  return TRUSTED_TYPES_SINKS.has(tagName + '|' + propName) || TRUSTED_TYPES_SINKS.has('*|' + propName);\n}\nconst setI18nRefs = originalNodeMap => {\n  return (trimmedNode, i18nNode) => {\n    const originalNode = originalNodeMap.get(trimmedNode) ?? trimmedNode;\n    if (originalNode instanceof NodeWithI18n) {\n      if (i18nNode instanceof IcuPlaceholder && originalNode.i18n instanceof Message) {\n        i18nNode.previousMessage = originalNode.i18n;\n      }\n      originalNode.i18n = i18nNode;\n    }\n    return i18nNode;\n  };\n};\nclass I18nMetaVisitor {\n  keepI18nAttrs;\n  enableI18nLegacyMessageIdFormat;\n  containerBlocks;\n  preserveSignificantWhitespace;\n  retainEmptyTokens;\n  hasI18nMeta = false;\n  _errors = [];\n  constructor(keepI18nAttrs = false, enableI18nLegacyMessageIdFormat = false, containerBlocks = DEFAULT_CONTAINER_BLOCKS, preserveSignificantWhitespace = true, retainEmptyTokens = !preserveSignificantWhitespace) {\n    this.keepI18nAttrs = keepI18nAttrs;\n    this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat;\n    this.containerBlocks = containerBlocks;\n    this.preserveSignificantWhitespace = preserveSignificantWhitespace;\n    this.retainEmptyTokens = retainEmptyTokens;\n  }\n  _generateI18nMessage(nodes, meta = '', visitNodeFn) {\n    const {\n      meaning,\n      description,\n      customId\n    } = this._parseMetadata(meta);\n    const createI18nMessage = createI18nMessageFactory(this.containerBlocks, this.retainEmptyTokens, this.preserveSignificantWhitespace);\n    const message = createI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n    this._setMessageId(message, meta);\n    this._setLegacyIds(message, meta);\n    return message;\n  }\n  visitAllWithErrors(nodes) {\n    const result = nodes.map(node => node.visit(this, null));\n    return new ParseTreeResult(result, this._errors);\n  }\n  visitElement(element) {\n    this._visitElementLike(element);\n    return element;\n  }\n  visitComponent(component, context) {\n    this._visitElementLike(component);\n    return component;\n  }\n  visitExpansion(expansion, currentMessage) {\n    let message;\n    const meta = expansion.i18n;\n    this.hasI18nMeta = true;\n    if (meta instanceof IcuPlaceholder) {\n      const name = meta.name;\n      message = this._generateI18nMessage([expansion], meta);\n      const icu = icuFromI18nMessage(message);\n      icu.name = name;\n      if (currentMessage !== null) {\n        currentMessage.placeholderToMessage[name] = message;\n      }\n    } else {\n      message = this._generateI18nMessage([expansion], currentMessage || meta);\n    }\n    expansion.i18n = message;\n    return expansion;\n  }\n  visitText(text) {\n    return text;\n  }\n  visitAttribute(attribute) {\n    return attribute;\n  }\n  visitComment(comment) {\n    return comment;\n  }\n  visitExpansionCase(expansionCase) {\n    return expansionCase;\n  }\n  visitBlock(block, context) {\n    visitAll(this, block.children, context);\n    return block;\n  }\n  visitBlockParameter(parameter, context) {\n    return parameter;\n  }\n  visitLetDeclaration(decl, context) {\n    return decl;\n  }\n  visitDirective(directive, context) {\n    return directive;\n  }\n  _visitElementLike(node) {\n    let message = undefined;\n    if (hasI18nAttrs(node)) {\n      this.hasI18nMeta = true;\n      const attrs = [];\n      const attrsMeta = {};\n      for (const attr of node.attrs) {\n        if (attr.name === I18N_ATTR) {\n          const i18n = node.i18n || attr.value;\n          const originalNodeMap = new Map();\n          const trimmedNodes = this.preserveSignificantWhitespace ? node.children : visitAllWithSiblings(new WhitespaceVisitor(false, originalNodeMap), node.children);\n          message = this._generateI18nMessage(trimmedNodes, i18n, setI18nRefs(originalNodeMap));\n          if (message.nodes.length === 0) {\n            message = undefined;\n          }\n          node.i18n = message;\n        } else if (attr.name.startsWith(I18N_ATTR_PREFIX)) {\n          const name = attr.name.slice(I18N_ATTR_PREFIX.length);\n          let isTrustedType;\n          if (node instanceof Component) {\n            isTrustedType = node.tagName === null ? false : isTrustedTypesSink(node.tagName, name);\n          } else {\n            isTrustedType = isTrustedTypesSink(node.name, name);\n          }\n          if (isTrustedType) {\n            this._reportError(attr, `Translating attribute '${name}' is disallowed for security reasons.`);\n          } else {\n            attrsMeta[name] = attr.value;\n          }\n        } else {\n          attrs.push(attr);\n        }\n      }\n      if (Object.keys(attrsMeta).length) {\n        for (const attr of attrs) {\n          const meta = attrsMeta[attr.name];\n          if (meta !== undefined && attr.value) {\n            attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);\n          }\n        }\n      }\n      if (!this.keepI18nAttrs) {\n        node.attrs = attrs;\n      }\n    }\n    visitAll(this, node.children, message);\n  }\n  _parseMetadata(meta) {\n    return typeof meta === 'string' ? parseI18nMeta(meta) : meta instanceof Message ? meta : {};\n  }\n  _setMessageId(message, meta) {\n    if (!message.id) {\n      message.id = meta instanceof Message && meta.id || decimalDigest(message);\n    }\n  }\n  _setLegacyIds(message, meta) {\n    if (this.enableI18nLegacyMessageIdFormat) {\n      message.legacyIds = [computeDigest(message), computeDecimalDigest(message)];\n    } else if (typeof meta !== 'string') {\n      const previousMessage = meta instanceof Message ? meta : meta instanceof IcuPlaceholder ? meta.previousMessage : undefined;\n      message.legacyIds = previousMessage ? previousMessage.legacyIds : [];\n    }\n  }\n  _reportError(node, msg) {\n    this._errors.push(new ParseError(node.sourceSpan, msg));\n  }\n}\nconst I18N_MEANING_SEPARATOR = '|';\nconst I18N_ID_SEPARATOR = '@@';\nfunction parseI18nMeta(meta = '') {\n  let customId;\n  let meaning;\n  let description;\n  meta = meta.trim();\n  if (meta) {\n    const idIndex = meta.indexOf(I18N_ID_SEPARATOR);\n    const descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);\n    let meaningAndDesc;\n    [meaningAndDesc, customId] = idIndex > -1 ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ''];\n    [meaning, description] = descIndex > -1 ? [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] : ['', meaningAndDesc];\n  }\n  return {\n    customId,\n    meaning,\n    description\n  };\n}\nfunction i18nMetaToJSDoc(meta) {\n  const tags = [];\n  if (meta.description) {\n    tags.push({\n      tagName: \"desc\",\n      text: meta.description\n    });\n  } else {\n    tags.push({\n      tagName: \"suppress\",\n      text: '{msgDescriptions}'\n    });\n  }\n  if (meta.meaning) {\n    tags.push({\n      tagName: \"meaning\",\n      text: meta.meaning\n    });\n  }\n  return jsDocComment(tags);\n}\nconst GOOG_GET_MSG = 'goog.getMsg';\nfunction createGoogleGetMsgStatements(variable$1, message, closureVar, placeholderValues) {\n  const messageString = serializeI18nMessageForGetMsg(message);\n  const args = [literal(messageString)];\n  if (Object.keys(placeholderValues).length) {\n    args.push(mapLiteral(formatI18nPlaceholderNamesInMap(placeholderValues, true), true));\n    args.push(mapLiteral({\n      original_code: literalMap(Object.keys(placeholderValues).map(param => ({\n        key: formatI18nPlaceholderName(param),\n        quoted: true,\n        value: message.placeholders[param] ? literal(message.placeholders[param].sourceSpan.toString()) : literal(message.placeholderToMessage[param].nodes.map(node => node.sourceSpan.toString()).join(''))\n      })))\n    }));\n  }\n  const googGetMsgStmt = new DeclareVarStmt(closureVar.name, variable(GOOG_GET_MSG).callFn(args), INFERRED_TYPE, StmtModifier.Final);\n  googGetMsgStmt.addLeadingComment(i18nMetaToJSDoc(message));\n  const i18nAssignmentStmt = new ExpressionStatement(variable$1.set(closureVar));\n  return [googGetMsgStmt, i18nAssignmentStmt];\n}\nclass GetMsgSerializerVisitor {\n  formatPh(value) {\n    return `{$${formatI18nPlaceholderName(value)}}`;\n  }\n  visitText(text) {\n    return text.value;\n  }\n  visitContainer(container) {\n    return container.children.map(child => child.visit(this)).join('');\n  }\n  visitIcu(icu) {\n    return serializeIcuNode(icu);\n  }\n  visitTagPlaceholder(ph) {\n    return ph.isVoid ? this.formatPh(ph.startName) : `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;\n  }\n  visitPlaceholder(ph) {\n    return this.formatPh(ph.name);\n  }\n  visitBlockPlaceholder(ph) {\n    return `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;\n  }\n  visitIcuPlaceholder(ph, context) {\n    return this.formatPh(ph.name);\n  }\n}\nconst serializerVisitor = new GetMsgSerializerVisitor();\nfunction serializeI18nMessageForGetMsg(message) {\n  return message.nodes.map(node => node.visit(serializerVisitor, null)).join('');\n}\nfunction createLocalizeStatements(variable, message, params) {\n  const {\n    messageParts,\n    placeHolders\n  } = serializeI18nMessageForLocalize(message);\n  const sourceSpan = getSourceSpan(message);\n  const expressions = placeHolders.map(ph => params[ph.text]);\n  const localizedString$1 = localizedString(message, messageParts, placeHolders, expressions, sourceSpan);\n  const variableInitialization = variable.set(localizedString$1);\n  return [new ExpressionStatement(variableInitialization)];\n}\nclass LocalizeSerializerVisitor {\n  placeholderToMessage;\n  pieces;\n  constructor(placeholderToMessage, pieces) {\n    this.placeholderToMessage = placeholderToMessage;\n    this.pieces = pieces;\n  }\n  visitText(text) {\n    if (this.pieces[this.pieces.length - 1] instanceof LiteralPiece) {\n      this.pieces[this.pieces.length - 1].text += text.value;\n    } else {\n      const sourceSpan = new ParseSourceSpan(text.sourceSpan.fullStart, text.sourceSpan.end, text.sourceSpan.fullStart, text.sourceSpan.details);\n      this.pieces.push(new LiteralPiece(text.value, sourceSpan));\n    }\n  }\n  visitContainer(container) {\n    container.children.forEach(child => child.visit(this));\n  }\n  visitIcu(icu) {\n    this.pieces.push(new LiteralPiece(serializeIcuNode(icu), icu.sourceSpan));\n  }\n  visitTagPlaceholder(ph) {\n    this.pieces.push(this.createPlaceholderPiece(ph.startName, ph.startSourceSpan ?? ph.sourceSpan));\n    if (!ph.isVoid) {\n      ph.children.forEach(child => child.visit(this));\n      this.pieces.push(this.createPlaceholderPiece(ph.closeName, ph.endSourceSpan ?? ph.sourceSpan));\n    }\n  }\n  visitPlaceholder(ph) {\n    this.pieces.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));\n  }\n  visitBlockPlaceholder(ph) {\n    this.pieces.push(this.createPlaceholderPiece(ph.startName, ph.startSourceSpan ?? ph.sourceSpan));\n    ph.children.forEach(child => child.visit(this));\n    this.pieces.push(this.createPlaceholderPiece(ph.closeName, ph.endSourceSpan ?? ph.sourceSpan));\n  }\n  visitIcuPlaceholder(ph) {\n    this.pieces.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan, this.placeholderToMessage[ph.name]));\n  }\n  createPlaceholderPiece(name, sourceSpan, associatedMessage) {\n    return new PlaceholderPiece(formatI18nPlaceholderName(name, false), sourceSpan, associatedMessage);\n  }\n}\nfunction serializeI18nMessageForLocalize(message) {\n  const pieces = [];\n  const serializerVisitor = new LocalizeSerializerVisitor(message.placeholderToMessage, pieces);\n  message.nodes.forEach(node => node.visit(serializerVisitor));\n  return processMessagePieces(pieces);\n}\nfunction getSourceSpan(message) {\n  const startNode = message.nodes[0];\n  const endNode = message.nodes[message.nodes.length - 1];\n  return new ParseSourceSpan(startNode.sourceSpan.fullStart, endNode.sourceSpan.end, startNode.sourceSpan.fullStart, startNode.sourceSpan.details);\n}\nfunction processMessagePieces(pieces) {\n  const messageParts = [];\n  const placeHolders = [];\n  if (pieces[0] instanceof PlaceholderPiece) {\n    messageParts.push(createEmptyMessagePart(pieces[0].sourceSpan.start));\n  }\n  for (let i = 0; i < pieces.length; i++) {\n    const part = pieces[i];\n    if (part instanceof LiteralPiece) {\n      messageParts.push(part);\n    } else {\n      placeHolders.push(part);\n      if (pieces[i - 1] instanceof PlaceholderPiece) {\n        messageParts.push(createEmptyMessagePart(pieces[i - 1].sourceSpan.end));\n      }\n    }\n  }\n  if (pieces[pieces.length - 1] instanceof PlaceholderPiece) {\n    messageParts.push(createEmptyMessagePart(pieces[pieces.length - 1].sourceSpan.end));\n  }\n  return {\n    messageParts,\n    placeHolders\n  };\n}\nfunction createEmptyMessagePart(location) {\n  return new LiteralPiece('', new ParseSourceSpan(location, location));\n}\nconst NG_I18N_CLOSURE_MODE = 'ngI18nClosureMode';\nconst TRANSLATION_VAR_PREFIX = 'i18n_';\nconst I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';\nconst ESCAPE = '\\uFFFD';\nconst CLOSURE_TRANSLATION_VAR_PREFIX = 'MSG_';\nfunction getTranslationConstPrefix(extra) {\n  return `${CLOSURE_TRANSLATION_VAR_PREFIX}${extra}`.toUpperCase();\n}\nfunction declareI18nVariable(variable) {\n  return new DeclareVarStmt(variable.name, undefined, INFERRED_TYPE, undefined, variable.sourceSpan);\n}\nfunction collectI18nConsts(job) {\n  const fileBasedI18nSuffix = job.relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_').toUpperCase() + '_';\n  const extractedAttributesByI18nContext = new Map();\n  const i18nAttributesByElement = new Map();\n  const i18nExpressionsByElement = new Map();\n  const messages = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind === OpKind.ExtractedAttribute && op.i18nContext !== null) {\n        const attributes = extractedAttributesByI18nContext.get(op.i18nContext) ?? [];\n        attributes.push(op);\n        extractedAttributesByI18nContext.set(op.i18nContext, attributes);\n      } else if (op.kind === OpKind.I18nAttributes) {\n        i18nAttributesByElement.set(op.target, op);\n      } else if (op.kind === OpKind.I18nExpression && op.usage === I18nExpressionFor.I18nAttribute) {\n        const expressions = i18nExpressionsByElement.get(op.target) ?? [];\n        expressions.push(op);\n        i18nExpressionsByElement.set(op.target, expressions);\n      } else if (op.kind === OpKind.I18nMessage) {\n        messages.set(op.xref, op);\n      }\n    }\n  }\n  const i18nValuesByContext = new Map();\n  const messageConstIndices = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.I18nMessage) {\n        if (op.messagePlaceholder === null) {\n          const {\n            mainVar,\n            statements\n          } = collectMessage(job, fileBasedI18nSuffix, messages, op);\n          if (op.i18nBlock !== null) {\n            const i18nConst = job.addConst(mainVar, statements);\n            messageConstIndices.set(op.i18nBlock, i18nConst);\n          } else {\n            job.constsInitializers.push(...statements);\n            i18nValuesByContext.set(op.i18nContext, mainVar);\n            const attributesForMessage = extractedAttributesByI18nContext.get(op.i18nContext);\n            if (attributesForMessage !== undefined) {\n              for (const attr of attributesForMessage) {\n                attr.expression = mainVar.clone();\n              }\n            }\n          }\n        }\n        OpList.remove(op);\n      }\n    }\n  }\n  for (const unit of job.units) {\n    for (const elem of unit.create) {\n      if (isElementOrContainerOp(elem)) {\n        const i18nAttributes = i18nAttributesByElement.get(elem.xref);\n        if (i18nAttributes === undefined) {\n          continue;\n        }\n        let i18nExpressions = i18nExpressionsByElement.get(elem.xref);\n        if (i18nExpressions === undefined) {\n          throw new Error('AssertionError: Could not find any i18n expressions associated with an I18nAttributes instruction');\n        }\n        const seenPropertyNames = new Set();\n        i18nExpressions = i18nExpressions.filter(i18nExpr => {\n          const seen = seenPropertyNames.has(i18nExpr.name);\n          seenPropertyNames.add(i18nExpr.name);\n          return !seen;\n        });\n        const i18nAttributeConfig = i18nExpressions.flatMap(i18nExpr => {\n          const i18nExprValue = i18nValuesByContext.get(i18nExpr.context);\n          if (i18nExprValue === undefined) {\n            throw new Error(\"AssertionError: Could not find i18n expression's value\");\n          }\n          return [literal(i18nExpr.name), i18nExprValue];\n        });\n        i18nAttributes.i18nAttributesConfig = job.addConst(new LiteralArrayExpr(i18nAttributeConfig));\n      }\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.I18nStart) {\n        const msgIndex = messageConstIndices.get(op.root);\n        if (msgIndex === undefined) {\n          throw new Error('AssertionError: Could not find corresponding i18n block index for an i18n message op; was an i18n message incorrectly assumed to correspond to an attribute?');\n        }\n        op.messageIndex = msgIndex;\n      }\n    }\n  }\n}\nfunction collectMessage(job, fileBasedI18nSuffix, messages, messageOp) {\n  const statements = [];\n  const subMessagePlaceholders = new Map();\n  for (const subMessageId of messageOp.subMessages) {\n    const subMessage = messages.get(subMessageId);\n    const {\n      mainVar: subMessageVar,\n      statements: subMessageStatements\n    } = collectMessage(job, fileBasedI18nSuffix, messages, subMessage);\n    statements.push(...subMessageStatements);\n    const subMessages = subMessagePlaceholders.get(subMessage.messagePlaceholder) ?? [];\n    subMessages.push(subMessageVar);\n    subMessagePlaceholders.set(subMessage.messagePlaceholder, subMessages);\n  }\n  addSubMessageParams(messageOp, subMessagePlaceholders);\n  messageOp.params = new Map([...messageOp.params.entries()].sort());\n  const mainVar = variable(job.pool.uniqueName(TRANSLATION_VAR_PREFIX));\n  const closureVar = i18nGenerateClosureVar(job.pool, messageOp.message.id, fileBasedI18nSuffix, job.i18nUseExternalIds);\n  let transformFn = undefined;\n  if (messageOp.needsPostprocessing || messageOp.postprocessingParams.size > 0) {\n    const postprocessingParams = Object.fromEntries([...messageOp.postprocessingParams.entries()].sort());\n    const formattedPostprocessingParams = formatI18nPlaceholderNamesInMap(postprocessingParams, false);\n    const extraTransformFnParams = [];\n    if (messageOp.postprocessingParams.size > 0) {\n      extraTransformFnParams.push(mapLiteral(formattedPostprocessingParams, true));\n    }\n    transformFn = expr => importExpr(Identifiers.i18nPostprocess).callFn([expr, ...extraTransformFnParams]);\n  }\n  statements.push(...getTranslationDeclStmts(messageOp.message, mainVar, closureVar, messageOp.params, transformFn));\n  return {\n    mainVar,\n    statements\n  };\n}\nfunction addSubMessageParams(messageOp, subMessagePlaceholders) {\n  for (const [placeholder, subMessages] of subMessagePlaceholders) {\n    if (subMessages.length === 1) {\n      messageOp.params.set(placeholder, subMessages[0]);\n    } else {\n      messageOp.params.set(placeholder, literal(`${ESCAPE}${I18N_ICU_MAPPING_PREFIX}${placeholder}${ESCAPE}`));\n      messageOp.postprocessingParams.set(placeholder, literalArr(subMessages));\n    }\n  }\n}\nfunction getTranslationDeclStmts(message, variable, closureVar, params, transformFn) {\n  const paramsObject = Object.fromEntries(params);\n  const statements = [declareI18nVariable(variable), ifStmt(createClosureModeGuard(), createGoogleGetMsgStatements(variable, message, closureVar, paramsObject), createLocalizeStatements(variable, message, formatI18nPlaceholderNamesInMap(paramsObject, false)))];\n  if (transformFn) {\n    statements.push(new ExpressionStatement(variable.set(transformFn(variable))));\n  }\n  return statements;\n}\nfunction createClosureModeGuard() {\n  return typeofExpr(variable(NG_I18N_CLOSURE_MODE)).notIdentical(literal('undefined', STRING_TYPE)).and(variable(NG_I18N_CLOSURE_MODE));\n}\nfunction i18nGenerateClosureVar(pool, messageId, fileBasedI18nSuffix, useExternalIds) {\n  let name;\n  const suffix = fileBasedI18nSuffix;\n  if (useExternalIds) {\n    const prefix = getTranslationConstPrefix(`EXTERNAL_`);\n    const uniqueSuffix = pool.uniqueName(suffix);\n    name = `${prefix}${sanitizeIdentifier(messageId)}$$${uniqueSuffix}`;\n  } else {\n    const prefix = getTranslationConstPrefix(suffix);\n    name = pool.uniqueName(prefix);\n  }\n  return variable(name);\n}\nfunction convertI18nText(job) {\n  for (const unit of job.units) {\n    let currentI18n = null;\n    let currentIcu = null;\n    const textNodeI18nBlocks = new Map();\n    const textNodeIcus = new Map();\n    const icuPlaceholderByText = new Map();\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nStart:\n          if (op.context === null) {\n            throw Error('I18n op should have its context set.');\n          }\n          currentI18n = op;\n          break;\n        case OpKind.I18nEnd:\n          currentI18n = null;\n          break;\n        case OpKind.IcuStart:\n          if (op.context === null) {\n            throw Error('Icu op should have its context set.');\n          }\n          currentIcu = op;\n          break;\n        case OpKind.IcuEnd:\n          currentIcu = null;\n          break;\n        case OpKind.Text:\n          if (currentI18n !== null) {\n            textNodeI18nBlocks.set(op.xref, currentI18n);\n            textNodeIcus.set(op.xref, currentIcu);\n            if (op.icuPlaceholder !== null) {\n              const icuPlaceholderOp = createIcuPlaceholderOp(job.allocateXrefId(), op.icuPlaceholder, [op.initialValue]);\n              OpList.replace(op, icuPlaceholderOp);\n              icuPlaceholderByText.set(op.xref, icuPlaceholderOp);\n            } else {\n              OpList.remove(op);\n            }\n          }\n          break;\n      }\n    }\n    for (const op of unit.update) {\n      switch (op.kind) {\n        case OpKind.InterpolateText:\n          if (!textNodeI18nBlocks.has(op.target)) {\n            continue;\n          }\n          const i18nOp = textNodeI18nBlocks.get(op.target);\n          const icuOp = textNodeIcus.get(op.target);\n          const icuPlaceholder = icuPlaceholderByText.get(op.target);\n          const contextId = icuOp ? icuOp.context : i18nOp.context;\n          const resolutionTime = icuOp ? I18nParamResolutionTime.Postproccessing : I18nParamResolutionTime.Creation;\n          const ops = [];\n          for (let i = 0; i < op.interpolation.expressions.length; i++) {\n            const expr = op.interpolation.expressions[i];\n            ops.push(createI18nExpressionOp(contextId, i18nOp.xref, i18nOp.xref, i18nOp.handle, expr, icuPlaceholder?.xref ?? null, op.interpolation.i18nPlaceholders[i] ?? null, resolutionTime, I18nExpressionFor.I18nText, '', expr.sourceSpan ?? op.sourceSpan));\n          }\n          OpList.replaceWithMany(op, ops);\n          if (icuPlaceholder !== undefined) {\n            icuPlaceholder.strings = op.interpolation.strings;\n          }\n          break;\n      }\n    }\n  }\n}\nfunction liftLocalRefs(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.ElementStart:\n        case OpKind.ConditionalCreate:\n        case OpKind.ConditionalBranchCreate:\n        case OpKind.Template:\n          if (!Array.isArray(op.localRefs)) {\n            throw new Error(`AssertionError: expected localRefs to be an array still`);\n          }\n          op.numSlotsUsed += op.localRefs.length;\n          if (op.localRefs.length > 0) {\n            const localRefs = serializeLocalRefs(op.localRefs);\n            op.localRefs = job.addConst(localRefs);\n          } else {\n            op.localRefs = null;\n          }\n          break;\n      }\n    }\n  }\n}\nfunction serializeLocalRefs(refs) {\n  const constRefs = [];\n  for (const ref of refs) {\n    constRefs.push(literal(ref.name), literal(ref.target));\n  }\n  return literalArr(constRefs);\n}\nfunction emitNamespaceChanges(job) {\n  for (const unit of job.units) {\n    let activeNamespace = Namespace.HTML;\n    for (const op of unit.create) {\n      if (op.kind !== OpKind.ElementStart) {\n        continue;\n      }\n      if (op.namespace !== activeNamespace) {\n        OpList.insertBefore(createNamespaceOp(op.namespace), op);\n        activeNamespace = op.namespace;\n      }\n    }\n  }\n}\nfunction parse(value) {\n  const styles = [];\n  let i = 0;\n  let parenDepth = 0;\n  let quote = 0;\n  let valueStart = 0;\n  let propStart = 0;\n  let currentProp = null;\n  while (i < value.length) {\n    const token = value.charCodeAt(i++);\n    switch (token) {\n      case 40:\n        parenDepth++;\n        break;\n      case 41:\n        parenDepth--;\n        break;\n      case 39:\n        if (quote === 0) {\n          quote = 39;\n        } else if (quote === 39 && value.charCodeAt(i - 1) !== 92) {\n          quote = 0;\n        }\n        break;\n      case 34:\n        if (quote === 0) {\n          quote = 34;\n        } else if (quote === 34 && value.charCodeAt(i - 1) !== 92) {\n          quote = 0;\n        }\n        break;\n      case 58:\n        if (!currentProp && parenDepth === 0 && quote === 0) {\n          currentProp = hyphenate(value.substring(propStart, i - 1).trim());\n          valueStart = i;\n        }\n        break;\n      case 59:\n        if (currentProp && valueStart > 0 && parenDepth === 0 && quote === 0) {\n          const styleVal = value.substring(valueStart, i - 1).trim();\n          styles.push(currentProp, styleVal);\n          propStart = i;\n          valueStart = 0;\n          currentProp = null;\n        }\n        break;\n    }\n  }\n  if (currentProp && valueStart) {\n    const styleVal = value.slice(valueStart).trim();\n    styles.push(currentProp, styleVal);\n  }\n  return styles;\n}\nfunction hyphenate(value) {\n  return value.replace(/[a-z][A-Z]/g, v => {\n    return v.charAt(0) + '-' + v.charAt(1);\n  }).toLowerCase();\n}\nfunction parseExtractedStyles(job) {\n  const elements = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (isElementOrContainerOp(op)) {\n        elements.set(op.xref, op);\n      }\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.ExtractedAttribute && op.bindingKind === BindingKind.Attribute && isStringLiteral(op.expression)) {\n        const target = elements.get(op.target);\n        if (target !== undefined && (target.kind === OpKind.Template || target.kind === OpKind.ConditionalCreate || target.kind === OpKind.ConditionalBranchCreate) && target.templateKind === TemplateKind.Structural) {\n          continue;\n        }\n        if (op.name === 'style') {\n          const parsedStyles = parse(op.expression.value);\n          for (let i = 0; i < parsedStyles.length - 1; i += 2) {\n            OpList.insertBefore(createExtractedAttributeOp(op.target, BindingKind.StyleProperty, null, parsedStyles[i], literal(parsedStyles[i + 1]), null, null, SecurityContext.STYLE), op);\n          }\n          OpList.remove(op);\n        } else if (op.name === 'class') {\n          const parsedClasses = op.expression.value.trim().split(/\\s+/g);\n          for (const parsedClass of parsedClasses) {\n            OpList.insertBefore(createExtractedAttributeOp(op.target, BindingKind.ClassName, null, parsedClass, null, null, null, SecurityContext.NONE), op);\n          }\n          OpList.remove(op);\n        }\n      }\n    }\n  }\n}\nfunction nameFunctionsAndVariables(job) {\n  addNamesToView(job.root, job.componentName, {\n    index: 0\n  }, job.compatibility === CompatibilityMode.TemplateDefinitionBuilder);\n}\nfunction addNamesToView(unit, baseName, state, compatibility) {\n  if (unit.fnName === null) {\n    unit.fnName = unit.job.pool.uniqueName(sanitizeIdentifier(`${baseName}_${unit.job.fnSuffix}`), false);\n  }\n  const varNames = new Map();\n  for (const op of unit.ops()) {\n    switch (op.kind) {\n      case OpKind.Property:\n      case OpKind.DomProperty:\n        if (op.bindingKind === BindingKind.LegacyAnimation) {\n          op.name = '@' + op.name;\n        }\n        break;\n      case OpKind.Animation:\n        if (op.handlerFnName === null) {\n          const animationKind = op.name.replace('.', '');\n          op.handlerFnName = `${unit.fnName}_${animationKind}_cb`;\n          op.handlerFnName = sanitizeIdentifier(op.handlerFnName);\n        }\n        break;\n      case OpKind.AnimationListener:\n        if (op.handlerFnName !== null) {\n          break;\n        }\n        if (!op.hostListener && op.targetSlot.slot === null) {\n          throw new Error(`Expected a slot to be assigned`);\n        }\n        const animationKind = op.name.replace('.', '');\n        if (op.hostListener) {\n          op.handlerFnName = `${baseName}_${animationKind}_HostBindingHandler`;\n        } else {\n          op.handlerFnName = `${unit.fnName}_${op.tag.replace('-', '_')}_${animationKind}_${op.targetSlot.slot}_listener`;\n        }\n        op.handlerFnName = sanitizeIdentifier(op.handlerFnName);\n        break;\n      case OpKind.Listener:\n        if (op.handlerFnName !== null) {\n          break;\n        }\n        if (!op.hostListener && op.targetSlot.slot === null) {\n          throw new Error(`Expected a slot to be assigned`);\n        }\n        let animation = '';\n        if (op.isLegacyAnimationListener) {\n          op.name = `@${op.name}.${op.legacyAnimationPhase}`;\n          animation = 'animation';\n        }\n        if (op.hostListener) {\n          op.handlerFnName = `${baseName}_${animation}${op.name}_HostBindingHandler`;\n        } else {\n          op.handlerFnName = `${unit.fnName}_${op.tag.replace('-', '_')}_${animation}${op.name}_${op.targetSlot.slot}_listener`;\n        }\n        op.handlerFnName = sanitizeIdentifier(op.handlerFnName);\n        break;\n      case OpKind.TwoWayListener:\n        if (op.handlerFnName !== null) {\n          break;\n        }\n        if (op.targetSlot.slot === null) {\n          throw new Error(`Expected a slot to be assigned`);\n        }\n        op.handlerFnName = sanitizeIdentifier(`${unit.fnName}_${op.tag.replace('-', '_')}_${op.name}_${op.targetSlot.slot}_listener`);\n        break;\n      case OpKind.Variable:\n        varNames.set(op.xref, getVariableName(unit, op.variable, state));\n        break;\n      case OpKind.RepeaterCreate:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        if (op.handle.slot === null) {\n          throw new Error(`Expected slot to be assigned`);\n        }\n        if (op.emptyView !== null) {\n          const emptyView = unit.job.views.get(op.emptyView);\n          addNamesToView(emptyView, `${baseName}_${op.functionNameSuffix}Empty_${op.handle.slot + 2}`, state, compatibility);\n        }\n        addNamesToView(unit.job.views.get(op.xref), `${baseName}_${op.functionNameSuffix}_${op.handle.slot + 1}`, state, compatibility);\n        break;\n      case OpKind.Projection:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        if (op.handle.slot === null) {\n          throw new Error(`Expected slot to be assigned`);\n        }\n        if (op.fallbackView !== null) {\n          const fallbackView = unit.job.views.get(op.fallbackView);\n          addNamesToView(fallbackView, `${baseName}_ProjectionFallback_${op.handle.slot}`, state, compatibility);\n        }\n        break;\n      case OpKind.ConditionalCreate:\n      case OpKind.ConditionalBranchCreate:\n      case OpKind.Template:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        const childView = unit.job.views.get(op.xref);\n        if (op.handle.slot === null) {\n          throw new Error(`Expected slot to be assigned`);\n        }\n        const suffix = op.functionNameSuffix.length === 0 ? '' : `_${op.functionNameSuffix}`;\n        addNamesToView(childView, `${baseName}${suffix}_${op.handle.slot}`, state, compatibility);\n        break;\n      case OpKind.StyleProp:\n        op.name = normalizeStylePropName(op.name);\n        if (compatibility) {\n          op.name = stripImportant(op.name);\n        }\n        break;\n      case OpKind.ClassProp:\n        if (compatibility) {\n          op.name = stripImportant(op.name);\n        }\n        break;\n    }\n  }\n  for (const op of unit.ops()) {\n    visitExpressionsInOp(op, expr => {\n      if (!(expr instanceof ReadVariableExpr) || expr.name !== null) {\n        return;\n      }\n      if (!varNames.has(expr.xref)) {\n        throw new Error(`Variable ${expr.xref} not yet named`);\n      }\n      expr.name = varNames.get(expr.xref);\n    });\n  }\n}\nfunction getVariableName(unit, variable, state) {\n  if (variable.name === null) {\n    switch (variable.kind) {\n      case SemanticVariableKind.Context:\n        variable.name = `ctx_r${state.index++}`;\n        break;\n      case SemanticVariableKind.Identifier:\n        if (unit.job.compatibility === CompatibilityMode.TemplateDefinitionBuilder) {\n          const compatPrefix = variable.identifier === 'ctx' ? 'i' : '';\n          variable.name = `${variable.identifier}_${compatPrefix}r${++state.index}`;\n        } else {\n          variable.name = `${variable.identifier}_i${state.index++}`;\n        }\n        break;\n      default:\n        variable.name = `_r${++state.index}`;\n        break;\n    }\n  }\n  return variable.name;\n}\nfunction normalizeStylePropName(name) {\n  return name.startsWith('--') ? name : hyphenate(name);\n}\nfunction stripImportant(name) {\n  const importantIndex = name.indexOf('!important');\n  if (importantIndex > -1) {\n    return name.substring(0, importantIndex);\n  }\n  return name;\n}\nfunction mergeNextContextExpressions(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.Listener || op.kind === OpKind.Animation || op.kind === OpKind.AnimationListener || op.kind === OpKind.TwoWayListener) {\n        mergeNextContextsInOps(op.handlerOps);\n      }\n    }\n    mergeNextContextsInOps(unit.update);\n  }\n}\nfunction mergeNextContextsInOps(ops) {\n  for (const op of ops) {\n    if (op.kind !== OpKind.Statement || !(op.statement instanceof ExpressionStatement) || !(op.statement.expr instanceof NextContextExpr)) {\n      continue;\n    }\n    const mergeSteps = op.statement.expr.steps;\n    let tryToMerge = true;\n    for (let candidate = op.next; candidate.kind !== OpKind.ListEnd && tryToMerge; candidate = candidate.next) {\n      visitExpressionsInOp(candidate, (expr, flags) => {\n        if (!isIrExpression(expr)) {\n          return expr;\n        }\n        if (!tryToMerge) {\n          return;\n        }\n        if (flags & VisitorContextFlag.InChildOperation) {\n          return;\n        }\n        switch (expr.kind) {\n          case ExpressionKind.NextContext:\n            expr.steps += mergeSteps;\n            OpList.remove(op);\n            tryToMerge = false;\n            break;\n          case ExpressionKind.GetCurrentView:\n          case ExpressionKind.Reference:\n          case ExpressionKind.ContextLetReference:\n            tryToMerge = false;\n            break;\n        }\n        return;\n      });\n    }\n  }\n}\nconst CONTAINER_TAG = 'ng-container';\nfunction generateNgContainerOps(job) {\n  for (const unit of job.units) {\n    const updatedElementXrefs = new Set();\n    for (const op of unit.create) {\n      if (op.kind === OpKind.ElementStart && op.tag === CONTAINER_TAG) {\n        op.kind = OpKind.ContainerStart;\n        updatedElementXrefs.add(op.xref);\n      }\n      if (op.kind === OpKind.ElementEnd && updatedElementXrefs.has(op.xref)) {\n        op.kind = OpKind.ContainerEnd;\n      }\n    }\n  }\n}\nfunction lookupElement(elements, xref) {\n  const el = elements.get(xref);\n  if (el === undefined) {\n    throw new Error('All attributes should have an element-like target.');\n  }\n  return el;\n}\nfunction disableBindings$1(job) {\n  const elements = new Map();\n  for (const view of job.units) {\n    for (const op of view.create) {\n      if (!isElementOrContainerOp(op)) {\n        continue;\n      }\n      elements.set(op.xref, op);\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if ((op.kind === OpKind.ElementStart || op.kind === OpKind.ContainerStart) && op.nonBindable) {\n        OpList.insertAfter(createDisableBindingsOp(op.xref), op);\n      }\n      if ((op.kind === OpKind.ElementEnd || op.kind === OpKind.ContainerEnd) && lookupElement(elements, op.xref).nonBindable) {\n        OpList.insertBefore(createEnableBindingsOp(op.xref), op);\n      }\n    }\n  }\n}\nfunction kindTest(kind) {\n  return op => op.kind === kind;\n}\nfunction kindWithInterpolationTest(kind, interpolation) {\n  return op => {\n    return op.kind === kind && interpolation === op.expression instanceof Interpolation;\n  };\n}\nfunction basicListenerKindTest(op) {\n  return op.kind === OpKind.Listener && !(op.hostListener && op.isLegacyAnimationListener) || op.kind === OpKind.TwoWayListener || op.kind === OpKind.Animation || op.kind === OpKind.AnimationListener;\n}\nfunction nonInterpolationPropertyKindTest(op) {\n  return (op.kind === OpKind.Property || op.kind === OpKind.TwoWayProperty) && !(op.expression instanceof Interpolation);\n}\nconst CREATE_ORDERING = [{\n  test: op => op.kind === OpKind.Listener && op.hostListener && op.isLegacyAnimationListener\n}, {\n  test: basicListenerKindTest\n}];\nconst UPDATE_ORDERING = [{\n  test: kindTest(OpKind.StyleMap),\n  transform: keepLast\n}, {\n  test: kindTest(OpKind.ClassMap),\n  transform: keepLast\n}, {\n  test: kindTest(OpKind.StyleProp)\n}, {\n  test: kindTest(OpKind.ClassProp)\n}, {\n  test: kindWithInterpolationTest(OpKind.Attribute, true)\n}, {\n  test: kindWithInterpolationTest(OpKind.Property, true)\n}, {\n  test: nonInterpolationPropertyKindTest\n}, {\n  test: kindWithInterpolationTest(OpKind.Attribute, false)\n}];\nconst UPDATE_HOST_ORDERING = [{\n  test: kindWithInterpolationTest(OpKind.DomProperty, true)\n}, {\n  test: kindWithInterpolationTest(OpKind.DomProperty, false)\n}, {\n  test: kindTest(OpKind.Attribute)\n}, {\n  test: kindTest(OpKind.StyleMap),\n  transform: keepLast\n}, {\n  test: kindTest(OpKind.ClassMap),\n  transform: keepLast\n}, {\n  test: kindTest(OpKind.StyleProp)\n}, {\n  test: kindTest(OpKind.ClassProp)\n}];\nconst handledOpKinds = new Set([OpKind.Listener, OpKind.TwoWayListener, OpKind.AnimationListener, OpKind.StyleMap, OpKind.ClassMap, OpKind.StyleProp, OpKind.ClassProp, OpKind.Property, OpKind.TwoWayProperty, OpKind.DomProperty, OpKind.Attribute, OpKind.Animation]);\nfunction orderOps(job) {\n  for (const unit of job.units) {\n    orderWithin(unit.create, CREATE_ORDERING);\n    const ordering = unit.job.kind === CompilationJobKind.Host ? UPDATE_HOST_ORDERING : UPDATE_ORDERING;\n    orderWithin(unit.update, ordering);\n  }\n}\nfunction orderWithin(opList, ordering) {\n  let opsToOrder = [];\n  let firstTargetInGroup = null;\n  for (const op of opList) {\n    const currentTarget = hasDependsOnSlotContextTrait(op) ? op.target : null;\n    if (!handledOpKinds.has(op.kind) || currentTarget !== firstTargetInGroup && firstTargetInGroup !== null && currentTarget !== null) {\n      OpList.insertBefore(reorder(opsToOrder, ordering), op);\n      opsToOrder = [];\n      firstTargetInGroup = null;\n    }\n    if (handledOpKinds.has(op.kind)) {\n      opsToOrder.push(op);\n      OpList.remove(op);\n      firstTargetInGroup = currentTarget ?? firstTargetInGroup;\n    }\n  }\n  opList.push(reorder(opsToOrder, ordering));\n}\nfunction reorder(ops, ordering) {\n  const groups = Array.from(ordering, () => new Array());\n  for (const op of ops) {\n    const groupIndex = ordering.findIndex(o => o.test(op));\n    groups[groupIndex].push(op);\n  }\n  return groups.flatMap((group, i) => {\n    const transform = ordering[i].transform;\n    return transform ? transform(group) : group;\n  });\n}\nfunction keepLast(ops) {\n  return ops.slice(ops.length - 1);\n}\nfunction removeContentSelectors(job) {\n  for (const unit of job.units) {\n    const elements = createOpXrefMap(unit);\n    for (const op of unit.ops()) {\n      switch (op.kind) {\n        case OpKind.Binding:\n          const target = lookupInXrefMap(elements, op.target);\n          if (isSelectAttribute(op.name) && target.kind === OpKind.Projection) {\n            OpList.remove(op);\n          }\n          break;\n      }\n    }\n  }\n}\nfunction isSelectAttribute(name) {\n  return name.toLowerCase() === 'select';\n}\nfunction lookupInXrefMap(map, xref) {\n  const el = map.get(xref);\n  if (el === undefined) {\n    throw new Error('All attributes should have an slottable target.');\n  }\n  return el;\n}\nfunction createPipes(job) {\n  for (const unit of job.units) {\n    processPipeBindingsInView(unit);\n  }\n}\nfunction processPipeBindingsInView(unit) {\n  for (const updateOp of unit.update) {\n    visitExpressionsInOp(updateOp, (expr, flags) => {\n      if (!isIrExpression(expr)) {\n        return;\n      }\n      if (expr.kind !== ExpressionKind.PipeBinding) {\n        return;\n      }\n      if (flags & VisitorContextFlag.InChildOperation) {\n        throw new Error(`AssertionError: pipe bindings should not appear in child expressions`);\n      }\n      if (unit.job.compatibility) {\n        const slotHandle = updateOp.target;\n        if (slotHandle == undefined) {\n          throw new Error(`AssertionError: expected slot handle to be assigned for pipe creation`);\n        }\n        addPipeToCreationBlock(unit, updateOp.target, expr);\n      } else {\n        unit.create.push(createPipeOp(expr.target, expr.targetSlot, expr.name));\n      }\n    });\n  }\n}\nfunction addPipeToCreationBlock(unit, afterTargetXref, binding) {\n  for (let op = unit.create.head.next; op.kind !== OpKind.ListEnd; op = op.next) {\n    if (!hasConsumesSlotTrait(op)) {\n      continue;\n    }\n    if (op.xref !== afterTargetXref) {\n      continue;\n    }\n    while (op.next.kind === OpKind.Pipe) {\n      op = op.next;\n    }\n    const pipe = createPipeOp(binding.target, binding.targetSlot, binding.name);\n    OpList.insertBefore(pipe, op.next);\n    return;\n  }\n  throw new Error(`AssertionError: unable to find insertion point for pipe ${binding.name}`);\n}\nfunction createVariadicPipes(job) {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      transformExpressionsInOp(op, expr => {\n        if (!(expr instanceof PipeBindingExpr)) {\n          return expr;\n        }\n        if (expr.args.length <= 4) {\n          return expr;\n        }\n        return new PipeBindingVariadicExpr(expr.target, expr.targetSlot, expr.name, literalArr(expr.args), expr.args.length);\n      }, VisitorContextFlag.None);\n    }\n  }\n}\nfunction propagateI18nBlocks(job) {\n  propagateI18nBlocksToTemplates(job.root, 0);\n}\nfunction propagateI18nBlocksToTemplates(unit, subTemplateIndex) {\n  let i18nBlock = null;\n  for (const op of unit.create) {\n    switch (op.kind) {\n      case OpKind.I18nStart:\n        op.subTemplateIndex = subTemplateIndex === 0 ? null : subTemplateIndex;\n        i18nBlock = op;\n        break;\n      case OpKind.I18nEnd:\n        if (i18nBlock.subTemplateIndex === null) {\n          subTemplateIndex = 0;\n        }\n        i18nBlock = null;\n        break;\n      case OpKind.ConditionalCreate:\n      case OpKind.ConditionalBranchCreate:\n      case OpKind.Template:\n        subTemplateIndex = propagateI18nBlocksForView(unit.job.views.get(op.xref), i18nBlock, op.i18nPlaceholder, subTemplateIndex);\n        break;\n      case OpKind.RepeaterCreate:\n        const forView = unit.job.views.get(op.xref);\n        subTemplateIndex = propagateI18nBlocksForView(forView, i18nBlock, op.i18nPlaceholder, subTemplateIndex);\n        if (op.emptyView !== null) {\n          subTemplateIndex = propagateI18nBlocksForView(unit.job.views.get(op.emptyView), i18nBlock, op.emptyI18nPlaceholder, subTemplateIndex);\n        }\n        break;\n      case OpKind.Projection:\n        if (op.fallbackView !== null) {\n          subTemplateIndex = propagateI18nBlocksForView(unit.job.views.get(op.fallbackView), i18nBlock, op.fallbackViewI18nPlaceholder, subTemplateIndex);\n        }\n        break;\n    }\n  }\n  return subTemplateIndex;\n}\nfunction propagateI18nBlocksForView(view, i18nBlock, i18nPlaceholder, subTemplateIndex) {\n  if (i18nPlaceholder !== undefined) {\n    if (i18nBlock === null) {\n      throw Error('Expected template with i18n placeholder to be in an i18n block.');\n    }\n    subTemplateIndex++;\n    wrapTemplateWithI18n(view, i18nBlock);\n  }\n  return propagateI18nBlocksToTemplates(view, subTemplateIndex);\n}\nfunction wrapTemplateWithI18n(unit, parentI18n) {\n  if (unit.create.head.next?.kind !== OpKind.I18nStart) {\n    const id = unit.job.allocateXrefId();\n    OpList.insertAfter(createI18nStartOp(id, parentI18n.message, parentI18n.root, null), unit.create.head);\n    OpList.insertBefore(createI18nEndOp(id, null), unit.create.tail);\n  }\n}\nfunction extractPureFunctions(job) {\n  for (const view of job.units) {\n    for (const op of view.ops()) {\n      visitExpressionsInOp(op, expr => {\n        if (!(expr instanceof PureFunctionExpr) || expr.body === null) {\n          return;\n        }\n        const constantDef = new PureFunctionConstant(expr.args.length);\n        expr.fn = job.pool.getSharedConstant(constantDef, expr.body);\n        expr.body = null;\n      });\n    }\n  }\n}\nclass PureFunctionConstant extends GenericKeyFn {\n  numArgs;\n  constructor(numArgs) {\n    super();\n    this.numArgs = numArgs;\n  }\n  keyOf(expr) {\n    if (expr instanceof PureFunctionParameterExpr) {\n      return `param(${expr.index})`;\n    } else {\n      return super.keyOf(expr);\n    }\n  }\n  toSharedConstantDeclaration(declName, keyExpr) {\n    const fnParams = [];\n    for (let idx = 0; idx < this.numArgs; idx++) {\n      fnParams.push(new FnParam('a' + idx));\n    }\n    const returnExpr = transformExpressionsInExpression(keyExpr, expr => {\n      if (!(expr instanceof PureFunctionParameterExpr)) {\n        return expr;\n      }\n      return variable('a' + expr.index);\n    }, VisitorContextFlag.None);\n    return new DeclareVarStmt(declName, new ArrowFunctionExpr(fnParams, returnExpr), undefined, StmtModifier.Final);\n  }\n}\nfunction generatePureLiteralStructures(job) {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      transformExpressionsInOp(op, (expr, flags) => {\n        if (flags & VisitorContextFlag.InChildOperation) {\n          return expr;\n        }\n        if (expr instanceof LiteralArrayExpr) {\n          return transformLiteralArray(expr);\n        } else if (expr instanceof LiteralMapExpr) {\n          return transformLiteralMap(expr);\n        }\n        return expr;\n      }, VisitorContextFlag.None);\n    }\n  }\n}\nfunction transformLiteralArray(expr) {\n  const derivedEntries = [];\n  const nonConstantArgs = [];\n  for (const entry of expr.entries) {\n    if (entry.isConstant()) {\n      derivedEntries.push(entry);\n    } else {\n      const idx = nonConstantArgs.length;\n      nonConstantArgs.push(entry);\n      derivedEntries.push(new PureFunctionParameterExpr(idx));\n    }\n  }\n  return new PureFunctionExpr(literalArr(derivedEntries), nonConstantArgs);\n}\nfunction transformLiteralMap(expr) {\n  let derivedEntries = [];\n  const nonConstantArgs = [];\n  for (const entry of expr.entries) {\n    if (entry.value.isConstant()) {\n      derivedEntries.push(entry);\n    } else {\n      const idx = nonConstantArgs.length;\n      nonConstantArgs.push(entry.value);\n      derivedEntries.push(new LiteralMapEntry(entry.key, new PureFunctionParameterExpr(idx), entry.quoted));\n    }\n  }\n  return new PureFunctionExpr(literalMap(derivedEntries), nonConstantArgs);\n}\nfunction optimizeRegularExpressions(job) {\n  for (const view of job.units) {\n    for (const op of view.ops()) {\n      transformExpressionsInOp(op, expr => {\n        if (expr instanceof RegularExpressionLiteralExpr && (expr.flags === null || !expr.flags.includes('g'))) {\n          return job.pool.getSharedConstant(new RegularExpressionConstant(), expr);\n        }\n        return expr;\n      }, VisitorContextFlag.None);\n    }\n  }\n}\nclass RegularExpressionConstant extends GenericKeyFn {\n  toSharedConstantDeclaration(declName, keyExpr) {\n    return new DeclareVarStmt(declName, keyExpr, undefined, StmtModifier.Final);\n  }\n}\nfunction element(slot, tag, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.element, slot, tag, constIndex, localRefIndex, sourceSpan);\n}\nfunction elementStart(slot, tag, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.elementStart, slot, tag, constIndex, localRefIndex, sourceSpan);\n}\nfunction elementOrContainerBase(instruction, slot, tag, constIndex, localRefIndex, sourceSpan) {\n  const args = [literal(slot)];\n  if (tag !== null) {\n    args.push(literal(tag));\n  }\n  if (localRefIndex !== null) {\n    args.push(literal(constIndex), literal(localRefIndex));\n  } else if (constIndex !== null) {\n    args.push(literal(constIndex));\n  }\n  return call(instruction, args, sourceSpan);\n}\nfunction templateBase(instruction, slot, templateFnRef, decls, vars, tag, constIndex, localRefs, sourceSpan) {\n  const args = [literal(slot), templateFnRef, literal(decls), literal(vars), literal(tag), literal(constIndex)];\n  if (localRefs !== null) {\n    args.push(literal(localRefs));\n    args.push(importExpr(Identifiers.templateRefExtractor));\n  }\n  while (args[args.length - 1].isEquivalent(NULL_EXPR)) {\n    args.pop();\n  }\n  return call(instruction, args, sourceSpan);\n}\nfunction propertyBase(instruction, name, expression, sanitizer, sourceSpan) {\n  const args = [literal(name)];\n  if (expression instanceof Interpolation) {\n    args.push(interpolationToExpression(expression, sourceSpan));\n  } else {\n    args.push(expression);\n  }\n  if (sanitizer !== null) {\n    args.push(sanitizer);\n  }\n  return call(instruction, args, sourceSpan);\n}\nfunction elementEnd(sourceSpan) {\n  return call(Identifiers.elementEnd, [], sourceSpan);\n}\nfunction elementContainerStart(slot, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.elementContainerStart, slot, null, constIndex, localRefIndex, sourceSpan);\n}\nfunction elementContainer(slot, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.elementContainer, slot, null, constIndex, localRefIndex, sourceSpan);\n}\nfunction elementContainerEnd() {\n  return call(Identifiers.elementContainerEnd, [], null);\n}\nfunction template(slot, templateFnRef, decls, vars, tag, constIndex, localRefs, sourceSpan) {\n  return templateBase(Identifiers.templateCreate, slot, templateFnRef, decls, vars, tag, constIndex, localRefs, sourceSpan);\n}\nfunction disableBindings() {\n  return call(Identifiers.disableBindings, [], null);\n}\nfunction enableBindings() {\n  return call(Identifiers.enableBindings, [], null);\n}\nfunction listener(name, handlerFn, eventTargetResolver, syntheticHost, sourceSpan) {\n  const args = [literal(name), handlerFn];\n  if (eventTargetResolver !== null) {\n    args.push(importExpr(eventTargetResolver));\n  }\n  return call(syntheticHost ? Identifiers.syntheticHostListener : Identifiers.listener, args, sourceSpan);\n}\nfunction twoWayBindingSet(target, value) {\n  return importExpr(Identifiers.twoWayBindingSet).callFn([target, value]);\n}\nfunction twoWayListener(name, handlerFn, sourceSpan) {\n  return call(Identifiers.twoWayListener, [literal(name), handlerFn], sourceSpan);\n}\nfunction pipe(slot, name) {\n  return call(Identifiers.pipe, [literal(slot), literal(name)], null);\n}\nfunction namespaceHTML() {\n  return call(Identifiers.namespaceHTML, [], null);\n}\nfunction namespaceSVG() {\n  return call(Identifiers.namespaceSVG, [], null);\n}\nfunction namespaceMath() {\n  return call(Identifiers.namespaceMathML, [], null);\n}\nfunction advance(delta, sourceSpan) {\n  return call(Identifiers.advance, delta > 1 ? [literal(delta)] : [], sourceSpan);\n}\nfunction reference(slot) {\n  return importExpr(Identifiers.reference).callFn([literal(slot)]);\n}\nfunction nextContext(steps) {\n  return importExpr(Identifiers.nextContext).callFn(steps === 1 ? [] : [literal(steps)]);\n}\nfunction getCurrentView() {\n  return importExpr(Identifiers.getCurrentView).callFn([]);\n}\nfunction restoreView(savedView) {\n  return importExpr(Identifiers.restoreView).callFn([savedView]);\n}\nfunction resetView(returnValue) {\n  return importExpr(Identifiers.resetView).callFn([returnValue]);\n}\nfunction text(slot, initialValue, sourceSpan) {\n  const args = [literal(slot, null)];\n  if (initialValue !== '') {\n    args.push(literal(initialValue));\n  }\n  return call(Identifiers.text, args, sourceSpan);\n}\nfunction defer(selfSlot, primarySlot, dependencyResolverFn, loadingSlot, placeholderSlot, errorSlot, loadingConfig, placeholderConfig, enableTimerScheduling, sourceSpan, flags) {\n  const args = [literal(selfSlot), literal(primarySlot), dependencyResolverFn ?? literal(null), literal(loadingSlot), literal(placeholderSlot), literal(errorSlot), loadingConfig ?? literal(null), placeholderConfig ?? literal(null), enableTimerScheduling ? importExpr(Identifiers.deferEnableTimerScheduling) : literal(null), literal(flags)];\n  let expr;\n  while ((expr = args[args.length - 1]) !== null && expr instanceof LiteralExpr && expr.value === null) {\n    args.pop();\n  }\n  return call(Identifiers.defer, args, sourceSpan);\n}\nconst deferTriggerToR3TriggerInstructionsMap = new Map([[DeferTriggerKind.Idle, {\n  [\"none\"]: Identifiers.deferOnIdle,\n  [\"prefetch\"]: Identifiers.deferPrefetchOnIdle,\n  [\"hydrate\"]: Identifiers.deferHydrateOnIdle\n}], [DeferTriggerKind.Immediate, {\n  [\"none\"]: Identifiers.deferOnImmediate,\n  [\"prefetch\"]: Identifiers.deferPrefetchOnImmediate,\n  [\"hydrate\"]: Identifiers.deferHydrateOnImmediate\n}], [DeferTriggerKind.Timer, {\n  [\"none\"]: Identifiers.deferOnTimer,\n  [\"prefetch\"]: Identifiers.deferPrefetchOnTimer,\n  [\"hydrate\"]: Identifiers.deferHydrateOnTimer\n}], [DeferTriggerKind.Hover, {\n  [\"none\"]: Identifiers.deferOnHover,\n  [\"prefetch\"]: Identifiers.deferPrefetchOnHover,\n  [\"hydrate\"]: Identifiers.deferHydrateOnHover\n}], [DeferTriggerKind.Interaction, {\n  [\"none\"]: Identifiers.deferOnInteraction,\n  [\"prefetch\"]: Identifiers.deferPrefetchOnInteraction,\n  [\"hydrate\"]: Identifiers.deferHydrateOnInteraction\n}], [DeferTriggerKind.Viewport, {\n  [\"none\"]: Identifiers.deferOnViewport,\n  [\"prefetch\"]: Identifiers.deferPrefetchOnViewport,\n  [\"hydrate\"]: Identifiers.deferHydrateOnViewport\n}], [DeferTriggerKind.Never, {\n  [\"none\"]: Identifiers.deferHydrateNever,\n  [\"prefetch\"]: Identifiers.deferHydrateNever,\n  [\"hydrate\"]: Identifiers.deferHydrateNever\n}]]);\nfunction deferOn(trigger, args, modifier, sourceSpan) {\n  const instructionToCall = deferTriggerToR3TriggerInstructionsMap.get(trigger)?.[modifier];\n  if (instructionToCall === undefined) {\n    throw new Error(`Unable to determine instruction for trigger ${trigger}`);\n  }\n  return call(instructionToCall, args, sourceSpan);\n}\nfunction projectionDef(def) {\n  return call(Identifiers.projectionDef, def ? [def] : [], null);\n}\nfunction projection(slot, projectionSlotIndex, attributes, fallbackFnName, fallbackDecls, fallbackVars, sourceSpan) {\n  const args = [literal(slot)];\n  if (projectionSlotIndex !== 0 || attributes !== null || fallbackFnName !== null) {\n    args.push(literal(projectionSlotIndex));\n    if (attributes !== null) {\n      args.push(attributes);\n    }\n    if (fallbackFnName !== null) {\n      if (attributes === null) {\n        args.push(literal(null));\n      }\n      args.push(variable(fallbackFnName), literal(fallbackDecls), literal(fallbackVars));\n    }\n  }\n  return call(Identifiers.projection, args, sourceSpan);\n}\nfunction i18nStart(slot, constIndex, subTemplateIndex, sourceSpan) {\n  const args = [literal(slot), literal(constIndex)];\n  if (subTemplateIndex !== null) {\n    args.push(literal(subTemplateIndex));\n  }\n  return call(Identifiers.i18nStart, args, sourceSpan);\n}\nfunction conditionalCreate(slot, templateFnRef, decls, vars, tag, constIndex, localRefs, sourceSpan) {\n  const args = [literal(slot), templateFnRef, literal(decls), literal(vars), literal(tag), literal(constIndex)];\n  if (localRefs !== null) {\n    args.push(literal(localRefs));\n    args.push(importExpr(Identifiers.templateRefExtractor));\n  }\n  while (args[args.length - 1].isEquivalent(NULL_EXPR)) {\n    args.pop();\n  }\n  return call(Identifiers.conditionalCreate, args, sourceSpan);\n}\nfunction conditionalBranchCreate(slot, templateFnRef, decls, vars, tag, constIndex, localRefs, sourceSpan) {\n  const args = [literal(slot), templateFnRef, literal(decls), literal(vars), literal(tag), literal(constIndex)];\n  if (localRefs !== null) {\n    args.push(literal(localRefs));\n    args.push(importExpr(Identifiers.templateRefExtractor));\n  }\n  while (args[args.length - 1].isEquivalent(NULL_EXPR)) {\n    args.pop();\n  }\n  return call(Identifiers.conditionalBranchCreate, args, sourceSpan);\n}\nfunction repeaterCreate(slot, viewFnName, decls, vars, tag, constIndex, trackByFn, trackByUsesComponentInstance, emptyViewFnName, emptyDecls, emptyVars, emptyTag, emptyConstIndex, sourceSpan) {\n  const args = [literal(slot), variable(viewFnName), literal(decls), literal(vars), literal(tag), literal(constIndex), trackByFn];\n  if (trackByUsesComponentInstance || emptyViewFnName !== null) {\n    args.push(literal(trackByUsesComponentInstance));\n    if (emptyViewFnName !== null) {\n      args.push(variable(emptyViewFnName), literal(emptyDecls), literal(emptyVars));\n      if (emptyTag !== null || emptyConstIndex !== null) {\n        args.push(literal(emptyTag));\n      }\n      if (emptyConstIndex !== null) {\n        args.push(literal(emptyConstIndex));\n      }\n    }\n  }\n  return call(Identifiers.repeaterCreate, args, sourceSpan);\n}\nfunction repeater(collection, sourceSpan) {\n  return call(Identifiers.repeater, [collection], sourceSpan);\n}\nfunction deferWhen(modifier, expr, sourceSpan) {\n  if (modifier === \"prefetch\") {\n    return call(Identifiers.deferPrefetchWhen, [expr], sourceSpan);\n  } else if (modifier === \"hydrate\") {\n    return call(Identifiers.deferHydrateWhen, [expr], sourceSpan);\n  }\n  return call(Identifiers.deferWhen, [expr], sourceSpan);\n}\nfunction declareLet(slot, sourceSpan) {\n  return call(Identifiers.declareLet, [literal(slot)], sourceSpan);\n}\nfunction storeLet(value, sourceSpan) {\n  return importExpr(Identifiers.storeLet).callFn([value], sourceSpan);\n}\nfunction readContextLet(slot) {\n  return importExpr(Identifiers.readContextLet).callFn([literal(slot)]);\n}\nfunction i18n(slot, constIndex, subTemplateIndex, sourceSpan) {\n  const args = [literal(slot), literal(constIndex)];\n  if (subTemplateIndex) {\n    args.push(literal(subTemplateIndex));\n  }\n  return call(Identifiers.i18n, args, sourceSpan);\n}\nfunction i18nEnd(endSourceSpan) {\n  return call(Identifiers.i18nEnd, [], endSourceSpan);\n}\nfunction i18nAttributes(slot, i18nAttributesConfig) {\n  const args = [literal(slot), literal(i18nAttributesConfig)];\n  return call(Identifiers.i18nAttributes, args, null);\n}\nfunction ariaProperty(name, expression, sourceSpan) {\n  return propertyBase(Identifiers.ariaProperty, name, expression, null, sourceSpan);\n}\nfunction property(name, expression, sanitizer, sourceSpan) {\n  return propertyBase(Identifiers.property, name, expression, sanitizer, sourceSpan);\n}\nfunction control(expression, sanitizer, sourceSpan) {\n  const args = [];\n  if (expression instanceof Interpolation) {\n    args.push(interpolationToExpression(expression, sourceSpan));\n  } else {\n    args.push(expression);\n  }\n  if (sanitizer !== null) {\n    args.push(sanitizer);\n  }\n  return call(Identifiers.control, args, sourceSpan);\n}\nfunction controlCreate(sourceSpan) {\n  return call(Identifiers.controlCreate, [], sourceSpan);\n}\nfunction twoWayProperty(name, expression, sanitizer, sourceSpan) {\n  const args = [literal(name), expression];\n  if (sanitizer !== null) {\n    args.push(sanitizer);\n  }\n  return call(Identifiers.twoWayProperty, args, sourceSpan);\n}\nfunction attribute(name, expression, sanitizer, namespace, sourceSpan) {\n  const args = [literal(name)];\n  if (expression instanceof Interpolation) {\n    args.push(interpolationToExpression(expression, sourceSpan));\n  } else {\n    args.push(expression);\n  }\n  if (sanitizer !== null || namespace !== null) {\n    args.push(sanitizer ?? literal(null));\n  }\n  if (namespace !== null) {\n    args.push(literal(namespace));\n  }\n  return call(Identifiers.attribute, args, null);\n}\nfunction styleProp(name, expression, unit, sourceSpan) {\n  const args = [literal(name)];\n  if (expression instanceof Interpolation) {\n    args.push(interpolationToExpression(expression, sourceSpan));\n  } else {\n    args.push(expression);\n  }\n  if (unit !== null) {\n    args.push(literal(unit));\n  }\n  return call(Identifiers.styleProp, args, sourceSpan);\n}\nfunction classProp(name, expression, sourceSpan) {\n  return call(Identifiers.classProp, [literal(name), expression], sourceSpan);\n}\nfunction styleMap(expression, sourceSpan) {\n  const value = expression instanceof Interpolation ? interpolationToExpression(expression, sourceSpan) : expression;\n  return call(Identifiers.styleMap, [value], sourceSpan);\n}\nfunction classMap(expression, sourceSpan) {\n  const value = expression instanceof Interpolation ? interpolationToExpression(expression, sourceSpan) : expression;\n  return call(Identifiers.classMap, [value], sourceSpan);\n}\nfunction domElement(slot, tag, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.domElement, slot, tag, constIndex, localRefIndex, sourceSpan);\n}\nfunction domElementStart(slot, tag, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.domElementStart, slot, tag, constIndex, localRefIndex, sourceSpan);\n}\nfunction domElementEnd(sourceSpan) {\n  return call(Identifiers.domElementEnd, [], sourceSpan);\n}\nfunction domElementContainerStart(slot, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.domElementContainerStart, slot, null, constIndex, localRefIndex, sourceSpan);\n}\nfunction domElementContainer(slot, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.domElementContainer, slot, null, constIndex, localRefIndex, sourceSpan);\n}\nfunction domElementContainerEnd() {\n  return call(Identifiers.domElementContainerEnd, [], null);\n}\nfunction domListener(name, handlerFn, eventTargetResolver, sourceSpan) {\n  const args = [literal(name), handlerFn];\n  if (eventTargetResolver !== null) {\n    args.push(importExpr(eventTargetResolver));\n  }\n  return call(Identifiers.domListener, args, sourceSpan);\n}\nfunction domTemplate(slot, templateFnRef, decls, vars, tag, constIndex, localRefs, sourceSpan) {\n  return templateBase(Identifiers.domTemplate, slot, templateFnRef, decls, vars, tag, constIndex, localRefs, sourceSpan);\n}\nconst PIPE_BINDINGS = [Identifiers.pipeBind1, Identifiers.pipeBind2, Identifiers.pipeBind3, Identifiers.pipeBind4];\nfunction pipeBind(slot, varOffset, args) {\n  if (args.length < 1 || args.length > PIPE_BINDINGS.length) {\n    throw new Error(`pipeBind() argument count out of bounds`);\n  }\n  const instruction = PIPE_BINDINGS[args.length - 1];\n  return importExpr(instruction).callFn([literal(slot), literal(varOffset), ...args]);\n}\nfunction pipeBindV(slot, varOffset, args) {\n  return importExpr(Identifiers.pipeBindV).callFn([literal(slot), literal(varOffset), args]);\n}\nfunction textInterpolate(strings, expressions, sourceSpan) {\n  const interpolationArgs = collateInterpolationArgs(strings, expressions);\n  return callVariadicInstruction(TEXT_INTERPOLATE_CONFIG, [], interpolationArgs, [], sourceSpan);\n}\nfunction i18nExp(expr, sourceSpan) {\n  return call(Identifiers.i18nExp, [expr], sourceSpan);\n}\nfunction i18nApply(slot, sourceSpan) {\n  return call(Identifiers.i18nApply, [literal(slot)], sourceSpan);\n}\nfunction domProperty(name, expression, sanitizer, sourceSpan) {\n  return propertyBase(Identifiers.domProperty, name, expression, sanitizer, sourceSpan);\n}\nfunction animation(animationKind, handlerFn, sanitizer, sourceSpan) {\n  const args = [handlerFn];\n  if (sanitizer !== null) {\n    args.push(sanitizer);\n  }\n  const identifier = animationKind === \"enter\" ? Identifiers.animationEnter : Identifiers.animationLeave;\n  return call(identifier, args, sourceSpan);\n}\nfunction animationString(animationKind, expression, sanitizer, sourceSpan) {\n  const value = expression instanceof Interpolation ? interpolationToExpression(expression, sourceSpan) : expression;\n  const args = [value];\n  if (sanitizer !== null) {\n    args.push(sanitizer);\n  }\n  const identifier = animationKind === \"enter\" ? Identifiers.animationEnter : Identifiers.animationLeave;\n  return call(identifier, args, sourceSpan);\n}\nfunction animationListener(animationKind, handlerFn, eventTargetResolver, sourceSpan) {\n  const args = [handlerFn];\n  const identifier = animationKind === \"enter\" ? Identifiers.animationEnterListener : Identifiers.animationLeaveListener;\n  return call(identifier, args, sourceSpan);\n}\nfunction syntheticHostProperty(name, expression, sourceSpan) {\n  return call(Identifiers.syntheticHostProperty, [literal(name), expression], sourceSpan);\n}\nfunction pureFunction(varOffset, fn, args) {\n  return callVariadicInstructionExpr(PURE_FUNCTION_CONFIG, [literal(varOffset), fn], args, [], null);\n}\nfunction attachSourceLocation(templatePath, locations) {\n  return call(Identifiers.attachSourceLocations, [literal(templatePath), locations], null);\n}\nfunction collateInterpolationArgs(strings, expressions) {\n  if (strings.length < 1 || expressions.length !== strings.length - 1) {\n    throw new Error(`AssertionError: expected specific shape of args for strings/expressions in interpolation`);\n  }\n  const interpolationArgs = [];\n  if (expressions.length === 1 && strings[0] === '' && strings[1] === '') {\n    interpolationArgs.push(expressions[0]);\n  } else {\n    let idx;\n    for (idx = 0; idx < expressions.length; idx++) {\n      interpolationArgs.push(literal(strings[idx]), expressions[idx]);\n    }\n    interpolationArgs.push(literal(strings[idx]));\n  }\n  return interpolationArgs;\n}\nfunction interpolationToExpression(interpolation, sourceSpan) {\n  const interpolationArgs = collateInterpolationArgs(interpolation.strings, interpolation.expressions);\n  return callVariadicInstructionExpr(VALUE_INTERPOLATE_CONFIG, [], interpolationArgs, [], sourceSpan);\n}\nfunction call(instruction, args, sourceSpan) {\n  const expr = importExpr(instruction).callFn(args, sourceSpan);\n  return createStatementOp(new ExpressionStatement(expr, sourceSpan));\n}\nfunction conditional(condition, contextValue, sourceSpan) {\n  const args = [condition];\n  if (contextValue !== null) {\n    args.push(contextValue);\n  }\n  return call(Identifiers.conditional, args, sourceSpan);\n}\nconst TEXT_INTERPOLATE_CONFIG = {\n  constant: [Identifiers.textInterpolate, Identifiers.textInterpolate1, Identifiers.textInterpolate2, Identifiers.textInterpolate3, Identifiers.textInterpolate4, Identifiers.textInterpolate5, Identifiers.textInterpolate6, Identifiers.textInterpolate7, Identifiers.textInterpolate8],\n  variable: Identifiers.textInterpolateV,\n  mapping: n => {\n    if (n % 2 === 0) {\n      throw new Error(`Expected odd number of arguments`);\n    }\n    return (n - 1) / 2;\n  }\n};\nconst VALUE_INTERPOLATE_CONFIG = {\n  constant: [Identifiers.interpolate, Identifiers.interpolate1, Identifiers.interpolate2, Identifiers.interpolate3, Identifiers.interpolate4, Identifiers.interpolate5, Identifiers.interpolate6, Identifiers.interpolate7, Identifiers.interpolate8],\n  variable: Identifiers.interpolateV,\n  mapping: n => {\n    if (n % 2 === 0) {\n      throw new Error(`Expected odd number of arguments`);\n    }\n    return (n - 1) / 2;\n  }\n};\nconst PURE_FUNCTION_CONFIG = {\n  constant: [Identifiers.pureFunction0, Identifiers.pureFunction1, Identifiers.pureFunction2, Identifiers.pureFunction3, Identifiers.pureFunction4, Identifiers.pureFunction5, Identifiers.pureFunction6, Identifiers.pureFunction7, Identifiers.pureFunction8],\n  variable: Identifiers.pureFunctionV,\n  mapping: n => n\n};\nfunction callVariadicInstructionExpr(config, baseArgs, interpolationArgs, extraArgs, sourceSpan) {\n  const n = config.mapping(interpolationArgs.length);\n  const lastInterpolationArg = interpolationArgs.at(-1);\n  if (extraArgs.length === 0 && interpolationArgs.length > 1 && lastInterpolationArg instanceof LiteralExpr && lastInterpolationArg.value === '') {\n    interpolationArgs.pop();\n  }\n  if (n < config.constant.length) {\n    return importExpr(config.constant[n]).callFn([...baseArgs, ...interpolationArgs, ...extraArgs], sourceSpan);\n  } else if (config.variable !== null) {\n    return importExpr(config.variable).callFn([...baseArgs, literalArr(interpolationArgs), ...extraArgs], sourceSpan);\n  } else {\n    throw new Error(`AssertionError: unable to call variadic function`);\n  }\n}\nfunction callVariadicInstruction(config, baseArgs, interpolationArgs, extraArgs, sourceSpan) {\n  return createStatementOp(callVariadicInstructionExpr(config, baseArgs, interpolationArgs, extraArgs, sourceSpan).toStmt());\n}\nconst GLOBAL_TARGET_RESOLVERS = new Map([['window', Identifiers.resolveWindow], ['document', Identifiers.resolveDocument], ['body', Identifiers.resolveBody]]);\nconst DOM_PROPERTY_REMAPPING = new Map([['class', 'className'], ['for', 'htmlFor'], ['formaction', 'formAction'], ['innerHtml', 'innerHTML'], ['readonly', 'readOnly'], ['tabindex', 'tabIndex']]);\nfunction reify(job) {\n  for (const unit of job.units) {\n    reifyCreateOperations(unit, unit.create);\n    reifyUpdateOperations(unit, unit.update);\n  }\n}\nfunction reifyCreateOperations(unit, ops) {\n  for (const op of ops) {\n    transformExpressionsInOp(op, reifyIrExpression, VisitorContextFlag.None);\n    switch (op.kind) {\n      case OpKind.Text:\n        OpList.replace(op, text(op.handle.slot, op.initialValue, op.sourceSpan));\n        break;\n      case OpKind.ElementStart:\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly ? domElementStart(op.handle.slot, op.tag, op.attributes, op.localRefs, op.startSourceSpan) : elementStart(op.handle.slot, op.tag, op.attributes, op.localRefs, op.startSourceSpan));\n        break;\n      case OpKind.Element:\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly ? domElement(op.handle.slot, op.tag, op.attributes, op.localRefs, op.wholeSourceSpan) : element(op.handle.slot, op.tag, op.attributes, op.localRefs, op.wholeSourceSpan));\n        break;\n      case OpKind.ElementEnd:\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly ? domElementEnd(op.sourceSpan) : elementEnd(op.sourceSpan));\n        break;\n      case OpKind.ContainerStart:\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly ? domElementContainerStart(op.handle.slot, op.attributes, op.localRefs, op.startSourceSpan) : elementContainerStart(op.handle.slot, op.attributes, op.localRefs, op.startSourceSpan));\n        break;\n      case OpKind.Container:\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly ? domElementContainer(op.handle.slot, op.attributes, op.localRefs, op.wholeSourceSpan) : elementContainer(op.handle.slot, op.attributes, op.localRefs, op.wholeSourceSpan));\n        break;\n      case OpKind.ContainerEnd:\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly ? domElementContainerEnd() : elementContainerEnd());\n        break;\n      case OpKind.I18nStart:\n        OpList.replace(op, i18nStart(op.handle.slot, op.messageIndex, op.subTemplateIndex, op.sourceSpan));\n        break;\n      case OpKind.I18nEnd:\n        OpList.replace(op, i18nEnd(op.sourceSpan));\n        break;\n      case OpKind.I18n:\n        OpList.replace(op, i18n(op.handle.slot, op.messageIndex, op.subTemplateIndex, op.sourceSpan));\n        break;\n      case OpKind.I18nAttributes:\n        if (op.i18nAttributesConfig === null) {\n          throw new Error(`AssertionError: i18nAttributesConfig was not set`);\n        }\n        OpList.replace(op, i18nAttributes(op.handle.slot, op.i18nAttributesConfig));\n        break;\n      case OpKind.Template:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        if (Array.isArray(op.localRefs)) {\n          throw new Error(`AssertionError: local refs array should have been extracted into a constant`);\n        }\n        const childView = unit.job.views.get(op.xref);\n        OpList.replace(op, op.templateKind === TemplateKind.Block || unit.job.mode === TemplateCompilationMode.DomOnly ? domTemplate(op.handle.slot, variable(childView.fnName), childView.decls, childView.vars, op.tag, op.attributes, op.localRefs, op.startSourceSpan) : template(op.handle.slot, variable(childView.fnName), childView.decls, childView.vars, op.tag, op.attributes, op.localRefs, op.startSourceSpan));\n        break;\n      case OpKind.DisableBindings:\n        OpList.replace(op, disableBindings());\n        break;\n      case OpKind.EnableBindings:\n        OpList.replace(op, enableBindings());\n        break;\n      case OpKind.Pipe:\n        OpList.replace(op, pipe(op.handle.slot, op.name));\n        break;\n      case OpKind.DeclareLet:\n        OpList.replace(op, declareLet(op.handle.slot, op.sourceSpan));\n        break;\n      case OpKind.AnimationString:\n        OpList.replace(op, animationString(op.animationKind, op.expression, op.sanitizer, op.sourceSpan));\n        break;\n      case OpKind.Animation:\n        const animationCallbackFn = reifyListenerHandler(unit, op.handlerFnName, op.handlerOps, false);\n        OpList.replace(op, animation(op.animationKind, animationCallbackFn, op.sanitizer, op.sourceSpan));\n        break;\n      case OpKind.AnimationListener:\n        const animationListenerFn = reifyListenerHandler(unit, op.handlerFnName, op.handlerOps, op.consumesDollarEvent);\n        OpList.replace(op, animationListener(op.animationKind, animationListenerFn, null, op.sourceSpan));\n        break;\n      case OpKind.Listener:\n        const listenerFn = reifyListenerHandler(unit, op.handlerFnName, op.handlerOps, op.consumesDollarEvent);\n        const eventTargetResolver = op.eventTarget ? GLOBAL_TARGET_RESOLVERS.get(op.eventTarget) : null;\n        if (eventTargetResolver === undefined) {\n          throw new Error(`Unexpected global target '${op.eventTarget}' defined for '${op.name}' event. Supported list of global targets: window,document,body.`);\n        }\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly && !op.hostListener && !op.isLegacyAnimationListener ? domListener(op.name, listenerFn, eventTargetResolver, op.sourceSpan) : listener(op.name, listenerFn, eventTargetResolver, op.hostListener && op.isLegacyAnimationListener, op.sourceSpan));\n        break;\n      case OpKind.TwoWayListener:\n        OpList.replace(op, twoWayListener(op.name, reifyListenerHandler(unit, op.handlerFnName, op.handlerOps, true), op.sourceSpan));\n        break;\n      case OpKind.Variable:\n        if (op.variable.name === null) {\n          throw new Error(`AssertionError: unnamed variable ${op.xref}`);\n        }\n        OpList.replace(op, createStatementOp(new DeclareVarStmt(op.variable.name, op.initializer, undefined, StmtModifier.Final)));\n        break;\n      case OpKind.Namespace:\n        switch (op.active) {\n          case Namespace.HTML:\n            OpList.replace(op, namespaceHTML());\n            break;\n          case Namespace.SVG:\n            OpList.replace(op, namespaceSVG());\n            break;\n          case Namespace.Math:\n            OpList.replace(op, namespaceMath());\n            break;\n        }\n        break;\n      case OpKind.Defer:\n        const timerScheduling = !!op.loadingMinimumTime || !!op.loadingAfterTime || !!op.placeholderMinimumTime;\n        OpList.replace(op, defer(op.handle.slot, op.mainSlot.slot, op.resolverFn, op.loadingSlot?.slot ?? null, op.placeholderSlot?.slot ?? null, op.errorSlot?.slot ?? null, op.loadingConfig, op.placeholderConfig, timerScheduling, op.sourceSpan, op.flags));\n        break;\n      case OpKind.DeferOn:\n        let args = [];\n        switch (op.trigger.kind) {\n          case DeferTriggerKind.Never:\n          case DeferTriggerKind.Idle:\n          case DeferTriggerKind.Immediate:\n            break;\n          case DeferTriggerKind.Timer:\n            args = [literal(op.trigger.delay)];\n            break;\n          case DeferTriggerKind.Viewport:\n            if (op.modifier === \"hydrate\") {\n              args = op.trigger.options ? [op.trigger.options] : [];\n            } else {\n              args = [literal(op.trigger.targetSlot?.slot ?? null)];\n              if (op.trigger.targetSlotViewSteps !== 0) {\n                args.push(literal(op.trigger.targetSlotViewSteps));\n              } else if (op.trigger.options) {\n                args.push(literal(null));\n              }\n              if (op.trigger.options) {\n                args.push(op.trigger.options);\n              }\n            }\n            break;\n          case DeferTriggerKind.Interaction:\n          case DeferTriggerKind.Hover:\n            if (op.modifier === \"hydrate\") {\n              args = [];\n            } else {\n              args = [literal(op.trigger.targetSlot?.slot ?? null)];\n              if (op.trigger.targetSlotViewSteps !== 0) {\n                args.push(literal(op.trigger.targetSlotViewSteps));\n              }\n            }\n            break;\n          default:\n            throw new Error(`AssertionError: Unsupported reification of defer trigger kind ${op.trigger.kind}`);\n        }\n        OpList.replace(op, deferOn(op.trigger.kind, args, op.modifier, op.sourceSpan));\n        break;\n      case OpKind.ProjectionDef:\n        OpList.replace(op, projectionDef(op.def));\n        break;\n      case OpKind.Projection:\n        if (op.handle.slot === null) {\n          throw new Error('No slot was assigned for project instruction');\n        }\n        let fallbackViewFnName = null;\n        let fallbackDecls = null;\n        let fallbackVars = null;\n        if (op.fallbackView !== null) {\n          if (!(unit instanceof ViewCompilationUnit)) {\n            throw new Error(`AssertionError: must be compiling a component`);\n          }\n          const fallbackView = unit.job.views.get(op.fallbackView);\n          if (fallbackView === undefined) {\n            throw new Error('AssertionError: projection had fallback view xref, but fallback view was not found');\n          }\n          if (fallbackView.fnName === null || fallbackView.decls === null || fallbackView.vars === null) {\n            throw new Error(`AssertionError: expected projection fallback view to have been named and counted`);\n          }\n          fallbackViewFnName = fallbackView.fnName;\n          fallbackDecls = fallbackView.decls;\n          fallbackVars = fallbackView.vars;\n        }\n        OpList.replace(op, projection(op.handle.slot, op.projectionSlotIndex, op.attributes, fallbackViewFnName, fallbackDecls, fallbackVars, op.sourceSpan));\n        break;\n      case OpKind.ConditionalCreate:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        if (Array.isArray(op.localRefs)) {\n          throw new Error(`AssertionError: local refs array should have been extracted into a constant`);\n        }\n        const conditionalCreateChildView = unit.job.views.get(op.xref);\n        OpList.replace(op, conditionalCreate(op.handle.slot, variable(conditionalCreateChildView.fnName), conditionalCreateChildView.decls, conditionalCreateChildView.vars, op.tag, op.attributes, op.localRefs, op.startSourceSpan));\n        break;\n      case OpKind.ConditionalBranchCreate:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        if (Array.isArray(op.localRefs)) {\n          throw new Error(`AssertionError: local refs array should have been extracted into a constant`);\n        }\n        const conditionalBranchCreateChildView = unit.job.views.get(op.xref);\n        OpList.replace(op, conditionalBranchCreate(op.handle.slot, variable(conditionalBranchCreateChildView.fnName), conditionalBranchCreateChildView.decls, conditionalBranchCreateChildView.vars, op.tag, op.attributes, op.localRefs, op.startSourceSpan));\n        break;\n      case OpKind.RepeaterCreate:\n        if (op.handle.slot === null) {\n          throw new Error('No slot was assigned for repeater instruction');\n        }\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        const repeaterView = unit.job.views.get(op.xref);\n        if (repeaterView.fnName === null) {\n          throw new Error(`AssertionError: expected repeater primary view to have been named`);\n        }\n        let emptyViewFnName = null;\n        let emptyDecls = null;\n        let emptyVars = null;\n        if (op.emptyView !== null) {\n          const emptyView = unit.job.views.get(op.emptyView);\n          if (emptyView === undefined) {\n            throw new Error('AssertionError: repeater had empty view xref, but empty view was not found');\n          }\n          if (emptyView.fnName === null || emptyView.decls === null || emptyView.vars === null) {\n            throw new Error(`AssertionError: expected repeater empty view to have been named and counted`);\n          }\n          emptyViewFnName = emptyView.fnName;\n          emptyDecls = emptyView.decls;\n          emptyVars = emptyView.vars;\n        }\n        OpList.replace(op, repeaterCreate(op.handle.slot, repeaterView.fnName, op.decls, op.vars, op.tag, op.attributes, reifyTrackBy(unit, op), op.usesComponentInstance, emptyViewFnName, emptyDecls, emptyVars, op.emptyTag, op.emptyAttributes, op.wholeSourceSpan));\n        break;\n      case OpKind.SourceLocation:\n        const locationsLiteral = literalArr(op.locations.map(({\n          targetSlot,\n          offset,\n          line,\n          column\n        }) => {\n          if (targetSlot.slot === null) {\n            throw new Error('No slot was assigned for source location');\n          }\n          return literalArr([literal(targetSlot.slot), literal(offset), literal(line), literal(column)]);\n        }));\n        OpList.replace(op, attachSourceLocation(op.templatePath, locationsLiteral));\n        break;\n      case OpKind.ControlCreate:\n        OpList.replace(op, controlCreate(op.sourceSpan));\n        break;\n      case OpKind.Statement:\n        break;\n      default:\n        throw new Error(`AssertionError: Unsupported reification of create op ${OpKind[op.kind]}`);\n    }\n  }\n}\nfunction reifyUpdateOperations(unit, ops) {\n  for (const op of ops) {\n    transformExpressionsInOp(op, reifyIrExpression, VisitorContextFlag.None);\n    switch (op.kind) {\n      case OpKind.Advance:\n        OpList.replace(op, advance(op.delta, op.sourceSpan));\n        break;\n      case OpKind.Property:\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly && op.bindingKind !== BindingKind.LegacyAnimation && op.bindingKind !== BindingKind.Animation ? reifyDomProperty(op) : reifyProperty(op));\n        break;\n      case OpKind.Control:\n        OpList.replace(op, reifyControl(op));\n        break;\n      case OpKind.TwoWayProperty:\n        OpList.replace(op, twoWayProperty(op.name, op.expression, op.sanitizer, op.sourceSpan));\n        break;\n      case OpKind.StyleProp:\n        OpList.replace(op, styleProp(op.name, op.expression, op.unit, op.sourceSpan));\n        break;\n      case OpKind.ClassProp:\n        OpList.replace(op, classProp(op.name, op.expression, op.sourceSpan));\n        break;\n      case OpKind.StyleMap:\n        OpList.replace(op, styleMap(op.expression, op.sourceSpan));\n        break;\n      case OpKind.ClassMap:\n        OpList.replace(op, classMap(op.expression, op.sourceSpan));\n        break;\n      case OpKind.I18nExpression:\n        OpList.replace(op, i18nExp(op.expression, op.sourceSpan));\n        break;\n      case OpKind.I18nApply:\n        OpList.replace(op, i18nApply(op.handle.slot, op.sourceSpan));\n        break;\n      case OpKind.InterpolateText:\n        OpList.replace(op, textInterpolate(op.interpolation.strings, op.interpolation.expressions, op.sourceSpan));\n        break;\n      case OpKind.Attribute:\n        OpList.replace(op, attribute(op.name, op.expression, op.sanitizer, op.namespace, op.sourceSpan));\n        break;\n      case OpKind.DomProperty:\n        if (op.expression instanceof Interpolation) {\n          throw new Error('not yet handled');\n        } else {\n          if (op.bindingKind === BindingKind.LegacyAnimation || op.bindingKind === BindingKind.Animation) {\n            OpList.replace(op, syntheticHostProperty(op.name, op.expression, op.sourceSpan));\n          } else {\n            OpList.replace(op, reifyDomProperty(op));\n          }\n        }\n        break;\n      case OpKind.Variable:\n        if (op.variable.name === null) {\n          throw new Error(`AssertionError: unnamed variable ${op.xref}`);\n        }\n        OpList.replace(op, createStatementOp(new DeclareVarStmt(op.variable.name, op.initializer, undefined, StmtModifier.Final)));\n        break;\n      case OpKind.Conditional:\n        if (op.processed === null) {\n          throw new Error(`Conditional test was not set.`);\n        }\n        OpList.replace(op, conditional(op.processed, op.contextValue, op.sourceSpan));\n        break;\n      case OpKind.Repeater:\n        OpList.replace(op, repeater(op.collection, op.sourceSpan));\n        break;\n      case OpKind.DeferWhen:\n        OpList.replace(op, deferWhen(op.modifier, op.expr, op.sourceSpan));\n        break;\n      case OpKind.StoreLet:\n        throw new Error(`AssertionError: unexpected storeLet ${op.declaredName}`);\n      case OpKind.Statement:\n        break;\n      default:\n        throw new Error(`AssertionError: Unsupported reification of update op ${OpKind[op.kind]}`);\n    }\n  }\n}\nfunction reifyDomProperty(op) {\n  return domProperty(DOM_PROPERTY_REMAPPING.get(op.name) ?? op.name, op.expression, op.sanitizer, op.sourceSpan);\n}\nfunction reifyProperty(op) {\n  return isAriaAttribute(op.name) ? ariaProperty(op.name, op.expression, op.sourceSpan) : property(op.name, op.expression, op.sanitizer, op.sourceSpan);\n}\nfunction reifyControl(op) {\n  return control(op.expression, op.sanitizer, op.sourceSpan);\n}\nfunction reifyIrExpression(expr) {\n  if (!isIrExpression(expr)) {\n    return expr;\n  }\n  switch (expr.kind) {\n    case ExpressionKind.NextContext:\n      return nextContext(expr.steps);\n    case ExpressionKind.Reference:\n      return reference(expr.targetSlot.slot + 1 + expr.offset);\n    case ExpressionKind.LexicalRead:\n      throw new Error(`AssertionError: unresolved LexicalRead of ${expr.name}`);\n    case ExpressionKind.TwoWayBindingSet:\n      throw new Error(`AssertionError: unresolved TwoWayBindingSet`);\n    case ExpressionKind.RestoreView:\n      if (typeof expr.view === 'number') {\n        throw new Error(`AssertionError: unresolved RestoreView`);\n      }\n      return restoreView(expr.view);\n    case ExpressionKind.ResetView:\n      return resetView(expr.expr);\n    case ExpressionKind.GetCurrentView:\n      return getCurrentView();\n    case ExpressionKind.ReadVariable:\n      if (expr.name === null) {\n        throw new Error(`Read of unnamed variable ${expr.xref}`);\n      }\n      return variable(expr.name);\n    case ExpressionKind.ReadTemporaryExpr:\n      if (expr.name === null) {\n        throw new Error(`Read of unnamed temporary ${expr.xref}`);\n      }\n      return variable(expr.name);\n    case ExpressionKind.AssignTemporaryExpr:\n      if (expr.name === null) {\n        throw new Error(`Assign of unnamed temporary ${expr.xref}`);\n      }\n      return variable(expr.name).set(expr.expr);\n    case ExpressionKind.PureFunctionExpr:\n      if (expr.fn === null) {\n        throw new Error(`AssertionError: expected PureFunctions to have been extracted`);\n      }\n      return pureFunction(expr.varOffset, expr.fn, expr.args);\n    case ExpressionKind.PureFunctionParameterExpr:\n      throw new Error(`AssertionError: expected PureFunctionParameterExpr to have been extracted`);\n    case ExpressionKind.PipeBinding:\n      return pipeBind(expr.targetSlot.slot, expr.varOffset, expr.args);\n    case ExpressionKind.PipeBindingVariadic:\n      return pipeBindV(expr.targetSlot.slot, expr.varOffset, expr.args);\n    case ExpressionKind.SlotLiteralExpr:\n      return literal(expr.slot.slot);\n    case ExpressionKind.ContextLetReference:\n      return readContextLet(expr.targetSlot.slot);\n    case ExpressionKind.StoreLet:\n      return storeLet(expr.value, expr.sourceSpan);\n    case ExpressionKind.TrackContext:\n      return variable('this');\n    default:\n      throw new Error(`AssertionError: Unsupported reification of ir.Expression kind: ${ExpressionKind[expr.kind]}`);\n  }\n}\nfunction reifyListenerHandler(unit, name, handlerOps, consumesDollarEvent) {\n  reifyUpdateOperations(unit, handlerOps);\n  const handlerStmts = [];\n  for (const op of handlerOps) {\n    if (op.kind !== OpKind.Statement) {\n      throw new Error(`AssertionError: expected reified statements, but found op ${OpKind[op.kind]}`);\n    }\n    handlerStmts.push(op.statement);\n  }\n  const params = [];\n  if (consumesDollarEvent) {\n    params.push(new FnParam('$event'));\n  }\n  return fn(params, handlerStmts, undefined, undefined, name);\n}\nfunction reifyTrackBy(unit, op) {\n  if (op.trackByFn !== null) {\n    return op.trackByFn;\n  }\n  const params = [new FnParam('$index'), new FnParam('$item')];\n  let fn$1;\n  if (op.trackByOps === null) {\n    fn$1 = op.usesComponentInstance ? fn(params, [new ReturnStatement(op.track)]) : arrowFn(params, op.track);\n  } else {\n    reifyUpdateOperations(unit, op.trackByOps);\n    const statements = [];\n    for (const trackOp of op.trackByOps) {\n      if (trackOp.kind !== OpKind.Statement) {\n        throw new Error(`AssertionError: expected reified statements, but found op ${OpKind[trackOp.kind]}`);\n      }\n      statements.push(trackOp.statement);\n    }\n    fn$1 = op.usesComponentInstance || statements.length !== 1 || !(statements[0] instanceof ReturnStatement) ? fn(params, statements) : arrowFn(params, statements[0].value);\n  }\n  op.trackByFn = unit.job.pool.getSharedFunctionReference(fn$1, '_forTrack');\n  return op.trackByFn;\n}\nfunction removeEmptyBindings(job) {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      switch (op.kind) {\n        case OpKind.Attribute:\n        case OpKind.Binding:\n        case OpKind.ClassProp:\n        case OpKind.ClassMap:\n        case OpKind.Property:\n        case OpKind.StyleProp:\n        case OpKind.StyleMap:\n          if (op.expression instanceof EmptyExpr) {\n            OpList.remove(op);\n          }\n          break;\n      }\n    }\n  }\n}\nfunction removeI18nContexts(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nContext:\n          OpList.remove(op);\n          break;\n        case OpKind.I18nStart:\n          op.context = null;\n          break;\n      }\n    }\n  }\n}\nfunction removeIllegalLetReferences(job) {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      if (op.kind !== OpKind.Variable || op.variable.kind !== SemanticVariableKind.Identifier || !(op.initializer instanceof StoreLetExpr)) {\n        continue;\n      }\n      const name = op.variable.identifier;\n      let current = op;\n      while (current && current.kind !== OpKind.ListEnd) {\n        transformExpressionsInOp(current, expr => expr instanceof LexicalReadExpr && expr.name === name ? literal(undefined) : expr, VisitorContextFlag.None);\n        current = current.prev;\n      }\n    }\n  }\n}\nfunction removeUnusedI18nAttributesOps(job) {\n  for (const unit of job.units) {\n    const ownersWithI18nExpressions = new Set();\n    for (const op of unit.update) {\n      switch (op.kind) {\n        case OpKind.I18nExpression:\n          ownersWithI18nExpressions.add(op.i18nOwner);\n      }\n    }\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nAttributes:\n          if (ownersWithI18nExpressions.has(op.xref)) {\n            continue;\n          }\n          OpList.remove(op);\n      }\n    }\n  }\n}\nfunction resolveContexts(job) {\n  for (const unit of job.units) {\n    processLexicalScope$1(unit, unit.create);\n    processLexicalScope$1(unit, unit.update);\n  }\n}\nfunction processLexicalScope$1(view, ops) {\n  const scope = new Map();\n  scope.set(view.xref, variable('ctx'));\n  for (const op of ops) {\n    switch (op.kind) {\n      case OpKind.Variable:\n        switch (op.variable.kind) {\n          case SemanticVariableKind.Context:\n            scope.set(op.variable.view, new ReadVariableExpr(op.xref));\n            break;\n        }\n        break;\n      case OpKind.Animation:\n      case OpKind.AnimationListener:\n      case OpKind.Listener:\n      case OpKind.TwoWayListener:\n        processLexicalScope$1(view, op.handlerOps);\n        break;\n      case OpKind.RepeaterCreate:\n        if (op.trackByOps !== null) {\n          processLexicalScope$1(view, op.trackByOps);\n        }\n        break;\n    }\n  }\n  if (view === view.job.root) {\n    scope.set(view.xref, variable('ctx'));\n  }\n  for (const op of ops) {\n    transformExpressionsInOp(op, expr => {\n      if (expr instanceof ContextExpr) {\n        if (!scope.has(expr.view)) {\n          throw new Error(`No context found for reference to view ${expr.view} from view ${view.xref}`);\n        }\n        return scope.get(expr.view);\n      } else {\n        return expr;\n      }\n    }, VisitorContextFlag.None);\n  }\n}\nfunction resolveDeferDepsFns(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.Defer) {\n        if (op.resolverFn !== null) {\n          continue;\n        }\n        if (op.ownResolverFn !== null) {\n          if (op.handle.slot === null) {\n            throw new Error('AssertionError: slot must be assigned before extracting defer deps functions');\n          }\n          const fullPathName = unit.fnName?.replace('_Template', '');\n          op.resolverFn = job.pool.getSharedFunctionReference(op.ownResolverFn, `${fullPathName}_Defer_${op.handle.slot}_DepsFn`, false);\n        }\n      }\n    }\n  }\n}\nfunction resolveDollarEvent(job) {\n  for (const unit of job.units) {\n    transformDollarEvent(unit.create);\n    transformDollarEvent(unit.update);\n  }\n}\nfunction transformDollarEvent(ops) {\n  for (const op of ops) {\n    if (op.kind === OpKind.Listener || op.kind === OpKind.TwoWayListener || op.kind === OpKind.AnimationListener) {\n      transformExpressionsInOp(op, expr => {\n        if (expr instanceof LexicalReadExpr && expr.name === '$event') {\n          if (op.kind === OpKind.Listener || op.kind === OpKind.AnimationListener) {\n            op.consumesDollarEvent = true;\n          }\n          return new ReadVarExpr(expr.name);\n        }\n        return expr;\n      }, VisitorContextFlag.InChildOperation);\n    }\n  }\n}\nfunction resolveI18nElementPlaceholders(job) {\n  const i18nContexts = new Map();\n  const elements = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nContext:\n          i18nContexts.set(op.xref, op);\n          break;\n        case OpKind.ElementStart:\n          elements.set(op.xref, op);\n          break;\n      }\n    }\n  }\n  resolvePlaceholdersForView(job, job.root, i18nContexts, elements);\n}\nfunction resolvePlaceholdersForView(job, unit, i18nContexts, elements, pendingStructuralDirective) {\n  let currentOps = null;\n  let pendingStructuralDirectiveCloses = new Map();\n  for (const op of unit.create) {\n    switch (op.kind) {\n      case OpKind.I18nStart:\n        if (!op.context) {\n          throw Error('Could not find i18n context for i18n op');\n        }\n        currentOps = {\n          i18nBlock: op,\n          i18nContext: i18nContexts.get(op.context)\n        };\n        break;\n      case OpKind.I18nEnd:\n        currentOps = null;\n        break;\n      case OpKind.ElementStart:\n        if (op.i18nPlaceholder !== undefined) {\n          if (currentOps === null) {\n            throw Error('i18n tag placeholder should only occur inside an i18n block');\n          }\n          recordElementStart(op, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n          if (pendingStructuralDirective && op.i18nPlaceholder.closeName) {\n            pendingStructuralDirectiveCloses.set(op.xref, pendingStructuralDirective);\n          }\n          pendingStructuralDirective = undefined;\n        }\n        break;\n      case OpKind.ElementEnd:\n        const startOp = elements.get(op.xref);\n        if (startOp && startOp.i18nPlaceholder !== undefined) {\n          if (currentOps === null) {\n            throw Error('AssertionError: i18n tag placeholder should only occur inside an i18n block');\n          }\n          recordElementClose(startOp, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirectiveCloses.get(op.xref));\n          pendingStructuralDirectiveCloses.delete(op.xref);\n        }\n        break;\n      case OpKind.Projection:\n        if (op.i18nPlaceholder !== undefined) {\n          if (currentOps === null) {\n            throw Error('i18n tag placeholder should only occur inside an i18n block');\n          }\n          recordElementStart(op, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n          recordElementClose(op, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n          pendingStructuralDirective = undefined;\n        }\n        if (op.fallbackView !== null) {\n          const view = job.views.get(op.fallbackView);\n          if (op.fallbackViewI18nPlaceholder === undefined) {\n            resolvePlaceholdersForView(job, view, i18nContexts, elements);\n          } else {\n            if (currentOps === null) {\n              throw Error('i18n tag placeholder should only occur inside an i18n block');\n            }\n            recordTemplateStart(job, view, op.handle.slot, op.fallbackViewI18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n            resolvePlaceholdersForView(job, view, i18nContexts, elements);\n            recordTemplateClose(job, view, op.handle.slot, op.fallbackViewI18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n            pendingStructuralDirective = undefined;\n          }\n        }\n        break;\n      case OpKind.ConditionalCreate:\n      case OpKind.ConditionalBranchCreate:\n      case OpKind.Template:\n        const view = job.views.get(op.xref);\n        if (op.i18nPlaceholder === undefined) {\n          resolvePlaceholdersForView(job, view, i18nContexts, elements);\n        } else {\n          if (currentOps === null) {\n            throw Error('i18n tag placeholder should only occur inside an i18n block');\n          }\n          if (op.templateKind === TemplateKind.Structural) {\n            resolvePlaceholdersForView(job, view, i18nContexts, elements, op);\n          } else {\n            recordTemplateStart(job, view, op.handle.slot, op.i18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n            resolvePlaceholdersForView(job, view, i18nContexts, elements);\n            recordTemplateClose(job, view, op.handle.slot, op.i18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n            pendingStructuralDirective = undefined;\n          }\n        }\n        break;\n      case OpKind.RepeaterCreate:\n        if (pendingStructuralDirective !== undefined) {\n          throw Error('AssertionError: Unexpected structural directive associated with @for block');\n        }\n        const forSlot = op.handle.slot + 1;\n        const forView = job.views.get(op.xref);\n        if (op.i18nPlaceholder === undefined) {\n          resolvePlaceholdersForView(job, forView, i18nContexts, elements);\n        } else {\n          if (currentOps === null) {\n            throw Error('i18n tag placeholder should only occur inside an i18n block');\n          }\n          recordTemplateStart(job, forView, forSlot, op.i18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n          resolvePlaceholdersForView(job, forView, i18nContexts, elements);\n          recordTemplateClose(job, forView, forSlot, op.i18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n          pendingStructuralDirective = undefined;\n        }\n        if (op.emptyView !== null) {\n          const emptySlot = op.handle.slot + 2;\n          const emptyView = job.views.get(op.emptyView);\n          if (op.emptyI18nPlaceholder === undefined) {\n            resolvePlaceholdersForView(job, emptyView, i18nContexts, elements);\n          } else {\n            if (currentOps === null) {\n              throw Error('i18n tag placeholder should only occur inside an i18n block');\n            }\n            recordTemplateStart(job, emptyView, emptySlot, op.emptyI18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n            resolvePlaceholdersForView(job, emptyView, i18nContexts, elements);\n            recordTemplateClose(job, emptyView, emptySlot, op.emptyI18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n            pendingStructuralDirective = undefined;\n          }\n        }\n        break;\n    }\n  }\n}\nfunction recordElementStart(op, i18nContext, i18nBlock, structuralDirective) {\n  const {\n    startName,\n    closeName\n  } = op.i18nPlaceholder;\n  let flags = I18nParamValueFlags.ElementTag | I18nParamValueFlags.OpenTag;\n  let value = op.handle.slot;\n  if (structuralDirective !== undefined) {\n    flags |= I18nParamValueFlags.TemplateTag;\n    value = {\n      element: value,\n      template: structuralDirective.handle.slot\n    };\n  }\n  if (!closeName) {\n    flags |= I18nParamValueFlags.CloseTag;\n  }\n  addParam(i18nContext.params, startName, value, i18nBlock.subTemplateIndex, flags);\n}\nfunction recordElementClose(op, i18nContext, i18nBlock, structuralDirective) {\n  const {\n    closeName\n  } = op.i18nPlaceholder;\n  if (closeName) {\n    let flags = I18nParamValueFlags.ElementTag | I18nParamValueFlags.CloseTag;\n    let value = op.handle.slot;\n    if (structuralDirective !== undefined) {\n      flags |= I18nParamValueFlags.TemplateTag;\n      value = {\n        element: value,\n        template: structuralDirective.handle.slot\n      };\n    }\n    addParam(i18nContext.params, closeName, value, i18nBlock.subTemplateIndex, flags);\n  }\n}\nfunction recordTemplateStart(job, view, slot, i18nPlaceholder, i18nContext, i18nBlock, structuralDirective) {\n  let {\n    startName,\n    closeName\n  } = i18nPlaceholder;\n  let flags = I18nParamValueFlags.TemplateTag | I18nParamValueFlags.OpenTag;\n  if (!closeName) {\n    flags |= I18nParamValueFlags.CloseTag;\n  }\n  if (structuralDirective !== undefined) {\n    addParam(i18nContext.params, startName, structuralDirective.handle.slot, i18nBlock.subTemplateIndex, flags);\n  }\n  addParam(i18nContext.params, startName, slot, getSubTemplateIndexForTemplateTag(job, i18nBlock, view), flags);\n}\nfunction recordTemplateClose(job, view, slot, i18nPlaceholder, i18nContext, i18nBlock, structuralDirective) {\n  const {\n    closeName\n  } = i18nPlaceholder;\n  const flags = I18nParamValueFlags.TemplateTag | I18nParamValueFlags.CloseTag;\n  if (closeName) {\n    addParam(i18nContext.params, closeName, slot, getSubTemplateIndexForTemplateTag(job, i18nBlock, view), flags);\n    if (structuralDirective !== undefined) {\n      addParam(i18nContext.params, closeName, structuralDirective.handle.slot, i18nBlock.subTemplateIndex, flags);\n    }\n  }\n}\nfunction getSubTemplateIndexForTemplateTag(job, i18nOp, view) {\n  for (const childOp of view.create) {\n    if (childOp.kind === OpKind.I18nStart) {\n      return childOp.subTemplateIndex;\n    }\n  }\n  return i18nOp.subTemplateIndex;\n}\nfunction addParam(params, placeholder, value, subTemplateIndex, flags) {\n  const values = params.get(placeholder) ?? [];\n  values.push({\n    value,\n    subTemplateIndex,\n    flags\n  });\n  params.set(placeholder, values);\n}\nfunction resolveI18nExpressionPlaceholders(job) {\n  const subTemplateIndices = new Map();\n  const i18nContexts = new Map();\n  const icuPlaceholders = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nStart:\n          subTemplateIndices.set(op.xref, op.subTemplateIndex);\n          break;\n        case OpKind.I18nContext:\n          i18nContexts.set(op.xref, op);\n          break;\n        case OpKind.IcuPlaceholder:\n          icuPlaceholders.set(op.xref, op);\n          break;\n      }\n    }\n  }\n  const expressionIndices = new Map();\n  const referenceIndex = op => op.usage === I18nExpressionFor.I18nText ? op.i18nOwner : op.context;\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      if (op.kind === OpKind.I18nExpression) {\n        const index = expressionIndices.get(referenceIndex(op)) || 0;\n        const subTemplateIndex = subTemplateIndices.get(op.i18nOwner) ?? null;\n        const value = {\n          value: index,\n          subTemplateIndex: subTemplateIndex,\n          flags: I18nParamValueFlags.ExpressionIndex\n        };\n        updatePlaceholder(op, value, i18nContexts, icuPlaceholders);\n        expressionIndices.set(referenceIndex(op), index + 1);\n      }\n    }\n  }\n}\nfunction updatePlaceholder(op, value, i18nContexts, icuPlaceholders) {\n  if (op.i18nPlaceholder !== null) {\n    const i18nContext = i18nContexts.get(op.context);\n    const params = op.resolutionTime === I18nParamResolutionTime.Creation ? i18nContext.params : i18nContext.postprocessingParams;\n    const values = params.get(op.i18nPlaceholder) || [];\n    values.push(value);\n    params.set(op.i18nPlaceholder, values);\n  }\n  if (op.icuPlaceholder !== null) {\n    const icuPlaceholderOp = icuPlaceholders.get(op.icuPlaceholder);\n    icuPlaceholderOp?.expressionPlaceholders.push(value);\n  }\n}\nfunction resolveNames(job) {\n  for (const unit of job.units) {\n    processLexicalScope(unit, unit.create, null);\n    processLexicalScope(unit, unit.update, null);\n  }\n}\nfunction processLexicalScope(unit, ops, savedView) {\n  const scope = new Map();\n  const localDefinitions = new Map();\n  for (const op of ops) {\n    switch (op.kind) {\n      case OpKind.Variable:\n        switch (op.variable.kind) {\n          case SemanticVariableKind.Identifier:\n            if (op.variable.local) {\n              if (localDefinitions.has(op.variable.identifier)) {\n                continue;\n              }\n              localDefinitions.set(op.variable.identifier, op.xref);\n            } else if (scope.has(op.variable.identifier)) {\n              continue;\n            }\n            scope.set(op.variable.identifier, op.xref);\n            break;\n          case SemanticVariableKind.Alias:\n            if (scope.has(op.variable.identifier)) {\n              continue;\n            }\n            scope.set(op.variable.identifier, op.xref);\n            break;\n          case SemanticVariableKind.SavedView:\n            savedView = {\n              view: op.variable.view,\n              variable: op.xref\n            };\n            break;\n        }\n        break;\n      case OpKind.Animation:\n      case OpKind.AnimationListener:\n      case OpKind.Listener:\n      case OpKind.TwoWayListener:\n        processLexicalScope(unit, op.handlerOps, savedView);\n        break;\n      case OpKind.RepeaterCreate:\n        if (op.trackByOps !== null) {\n          processLexicalScope(unit, op.trackByOps, savedView);\n        }\n        break;\n    }\n  }\n  for (const op of ops) {\n    if (op.kind == OpKind.Listener || op.kind === OpKind.TwoWayListener || op.kind === OpKind.Animation || op.kind === OpKind.AnimationListener) {\n      continue;\n    }\n    transformExpressionsInOp(op, expr => {\n      if (expr instanceof LexicalReadExpr) {\n        if (localDefinitions.has(expr.name)) {\n          return new ReadVariableExpr(localDefinitions.get(expr.name));\n        } else if (scope.has(expr.name)) {\n          return new ReadVariableExpr(scope.get(expr.name));\n        } else {\n          return new ReadPropExpr(new ContextExpr(unit.job.root.xref), expr.name);\n        }\n      } else if (expr instanceof RestoreViewExpr && typeof expr.view === 'number') {\n        if (savedView === null || savedView.view !== expr.view) {\n          throw new Error(`AssertionError: no saved view ${expr.view} from view ${unit.xref}`);\n        }\n        expr.view = new ReadVariableExpr(savedView.variable);\n        return expr;\n      } else {\n        return expr;\n      }\n    }, VisitorContextFlag.None);\n  }\n  for (const op of ops) {\n    visitExpressionsInOp(op, expr => {\n      if (expr instanceof LexicalReadExpr) {\n        throw new Error(`AssertionError: no lexical reads should remain, but found read of ${expr.name}`);\n      }\n    });\n  }\n}\nconst sanitizerFns = new Map([[SecurityContext.HTML, Identifiers.sanitizeHtml], [SecurityContext.RESOURCE_URL, Identifiers.sanitizeResourceUrl], [SecurityContext.SCRIPT, Identifiers.sanitizeScript], [SecurityContext.STYLE, Identifiers.sanitizeStyle], [SecurityContext.URL, Identifiers.sanitizeUrl]]);\nconst trustedValueFns = new Map([[SecurityContext.HTML, Identifiers.trustConstantHtml], [SecurityContext.RESOURCE_URL, Identifiers.trustConstantResourceUrl]]);\nfunction resolveSanitizers(job) {\n  for (const unit of job.units) {\n    const elements = createOpXrefMap(unit);\n    if (job.kind !== CompilationJobKind.Host) {\n      for (const op of unit.create) {\n        if (op.kind === OpKind.ExtractedAttribute) {\n          const trustedValueFn = trustedValueFns.get(getOnlySecurityContext(op.securityContext)) ?? null;\n          op.trustedValueFn = trustedValueFn !== null ? importExpr(trustedValueFn) : null;\n        }\n      }\n    }\n    for (const op of unit.update) {\n      switch (op.kind) {\n        case OpKind.Property:\n        case OpKind.Attribute:\n        case OpKind.DomProperty:\n          let sanitizerFn = null;\n          if (Array.isArray(op.securityContext) && op.securityContext.length === 2 && op.securityContext.indexOf(SecurityContext.URL) > -1 && op.securityContext.indexOf(SecurityContext.RESOURCE_URL) > -1) {\n            sanitizerFn = Identifiers.sanitizeUrlOrResourceUrl;\n          } else {\n            sanitizerFn = sanitizerFns.get(getOnlySecurityContext(op.securityContext)) ?? null;\n          }\n          op.sanitizer = sanitizerFn !== null ? importExpr(sanitizerFn) : null;\n          if (op.sanitizer === null) {\n            let isIframe = false;\n            if (job.kind === CompilationJobKind.Host || op.kind === OpKind.DomProperty) {\n              isIframe = true;\n            } else {\n              const ownerOp = elements.get(op.target);\n              if (ownerOp === undefined || !isElementOrContainerOp(ownerOp)) {\n                throw Error('Property should have an element-like owner');\n              }\n              isIframe = isIframeElement(ownerOp);\n            }\n            if (isIframe && isIframeSecuritySensitiveAttr(op.name)) {\n              op.sanitizer = importExpr(Identifiers.validateIframeAttribute);\n            }\n          }\n          break;\n      }\n    }\n  }\n}\nfunction isIframeElement(op) {\n  return op.kind === OpKind.ElementStart && op.tag?.toLowerCase() === 'iframe';\n}\nfunction getOnlySecurityContext(securityContext) {\n  if (Array.isArray(securityContext)) {\n    if (securityContext.length > 1) {\n      throw Error(`AssertionError: Ambiguous security context`);\n    }\n    return securityContext[0] || SecurityContext.NONE;\n  }\n  return securityContext;\n}\nfunction saveAndRestoreView(job) {\n  for (const unit of job.units) {\n    unit.create.prepend([createVariableOp(unit.job.allocateXrefId(), {\n      kind: SemanticVariableKind.SavedView,\n      name: null,\n      view: unit.xref\n    }, new GetCurrentViewExpr(), VariableFlags.None)]);\n    for (const op of unit.create) {\n      if (op.kind !== OpKind.Listener && op.kind !== OpKind.TwoWayListener && op.kind !== OpKind.Animation && op.kind !== OpKind.AnimationListener) {\n        continue;\n      }\n      let needsRestoreView = unit !== job.root;\n      if (!needsRestoreView) {\n        for (const handlerOp of op.handlerOps) {\n          visitExpressionsInOp(handlerOp, expr => {\n            if (expr instanceof ReferenceExpr || expr instanceof ContextLetReferenceExpr) {\n              needsRestoreView = true;\n            }\n          });\n        }\n      }\n      if (needsRestoreView) {\n        addSaveRestoreViewOperationToListener(unit, op);\n      }\n    }\n  }\n}\nfunction addSaveRestoreViewOperationToListener(unit, op) {\n  op.handlerOps.prepend([createVariableOp(unit.job.allocateXrefId(), {\n    kind: SemanticVariableKind.Context,\n    name: null,\n    view: unit.xref\n  }, new RestoreViewExpr(unit.xref), VariableFlags.None)]);\n  for (const handlerOp of op.handlerOps) {\n    if (handlerOp.kind === OpKind.Statement && handlerOp.statement instanceof ReturnStatement) {\n      handlerOp.statement.value = new ResetViewExpr(handlerOp.statement.value);\n    }\n  }\n}\nfunction allocateSlots(job) {\n  const slotMap = new Map();\n  for (const unit of job.units) {\n    let slotCount = 0;\n    for (const op of unit.create) {\n      if (!hasConsumesSlotTrait(op)) {\n        continue;\n      }\n      op.handle.slot = slotCount;\n      slotMap.set(op.xref, op.handle.slot);\n      slotCount += op.numSlotsUsed;\n    }\n    unit.decls = slotCount;\n  }\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind === OpKind.Template || op.kind === OpKind.ConditionalCreate || op.kind === OpKind.ConditionalBranchCreate || op.kind === OpKind.RepeaterCreate) {\n        const childView = job.views.get(op.xref);\n        op.decls = childView.decls;\n      }\n    }\n  }\n}\nfunction optimizeStoreLet(job) {\n  const letUsedExternally = new Set();\n  const declareLetOps = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind === OpKind.DeclareLet) {\n        declareLetOps.set(op.xref, op);\n      }\n      visitExpressionsInOp(op, expr => {\n        if (expr instanceof ContextLetReferenceExpr) {\n          letUsedExternally.add(expr.target);\n        }\n      });\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      transformExpressionsInOp(op, expr => {\n        if (expr instanceof StoreLetExpr && !letUsedExternally.has(expr.target)) {\n          if (!hasPipe(expr)) {\n            OpList.remove(declareLetOps.get(expr.target));\n          }\n          return expr.value;\n        }\n        return expr;\n      }, VisitorContextFlag.None);\n    }\n  }\n}\nfunction hasPipe(root) {\n  let result = false;\n  transformExpressionsInExpression(root, expr => {\n    if (expr instanceof PipeBindingExpr || expr instanceof PipeBindingVariadicExpr) {\n      result = true;\n    }\n    return expr;\n  }, VisitorContextFlag.None);\n  return result;\n}\nfunction stripNonrequiredParentheses(job) {\n  const requiredParens = new Set();\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      visitExpressionsInOp(op, expr => {\n        if (expr instanceof BinaryOperatorExpr) {\n          switch (expr.operator) {\n            case BinaryOperator.Exponentiation:\n              checkExponentiationParens(expr, requiredParens);\n              break;\n            case BinaryOperator.NullishCoalesce:\n              checkNullishCoalescingParens(expr, requiredParens);\n              break;\n            case BinaryOperator.And:\n            case BinaryOperator.Or:\n              checkAndOrParens(expr, requiredParens);\n          }\n        }\n      });\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      transformExpressionsInOp(op, expr => {\n        if (expr instanceof ParenthesizedExpr) {\n          return requiredParens.has(expr) ? expr : expr.expr;\n        }\n        return expr;\n      }, VisitorContextFlag.None);\n    }\n  }\n}\nfunction checkExponentiationParens(expr, requiredParens) {\n  if (expr.lhs instanceof ParenthesizedExpr && expr.lhs.expr instanceof UnaryOperatorExpr) {\n    requiredParens.add(expr.lhs);\n  }\n}\nfunction checkNullishCoalescingParens(expr, requiredParens) {\n  if (expr.lhs instanceof ParenthesizedExpr && (isLogicalAndOr(expr.lhs.expr) || expr.lhs.expr instanceof ConditionalExpr)) {\n    requiredParens.add(expr.lhs);\n  }\n  if (expr.rhs instanceof ParenthesizedExpr && (isLogicalAndOr(expr.rhs.expr) || expr.rhs.expr instanceof ConditionalExpr)) {\n    requiredParens.add(expr.rhs);\n  }\n}\nfunction checkAndOrParens(expr, requiredParens) {\n  if (expr.lhs instanceof ParenthesizedExpr && expr.lhs.expr instanceof BinaryOperatorExpr && expr.lhs.expr.operator === BinaryOperator.NullishCoalesce) {\n    requiredParens.add(expr.lhs);\n  }\n}\nfunction isLogicalAndOr(expr) {\n  return expr instanceof BinaryOperatorExpr && (expr.operator === BinaryOperator.And || expr.operator === BinaryOperator.Or);\n}\nfunction specializeStyleBindings(job) {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      if (op.kind !== OpKind.Binding) {\n        continue;\n      }\n      switch (op.bindingKind) {\n        case BindingKind.ClassName:\n          if (op.expression instanceof Interpolation) {\n            throw new Error(`Unexpected interpolation in ClassName binding`);\n          }\n          OpList.replace(op, createClassPropOp(op.target, op.name, op.expression, op.sourceSpan));\n          break;\n        case BindingKind.StyleProperty:\n          OpList.replace(op, createStylePropOp(op.target, op.name, op.expression, op.unit, op.sourceSpan));\n          break;\n        case BindingKind.Property:\n        case BindingKind.Template:\n          if (op.name === 'style') {\n            OpList.replace(op, createStyleMapOp(op.target, op.expression, op.sourceSpan));\n          } else if (op.name === 'class') {\n            OpList.replace(op, createClassMapOp(op.target, op.expression, op.sourceSpan));\n          }\n          break;\n      }\n    }\n  }\n}\nfunction generateTemporaryVariables(job) {\n  for (const unit of job.units) {\n    unit.create.prepend(generateTemporaries(unit.create));\n    unit.update.prepend(generateTemporaries(unit.update));\n  }\n}\nfunction generateTemporaries(ops) {\n  let opCount = 0;\n  let generatedStatements = [];\n  for (const op of ops) {\n    const finalReads = new Map();\n    visitExpressionsInOp(op, (expr, flag) => {\n      if (flag & VisitorContextFlag.InChildOperation) {\n        return;\n      }\n      if (expr instanceof ReadTemporaryExpr) {\n        finalReads.set(expr.xref, expr);\n      }\n    });\n    let count = 0;\n    const assigned = new Set();\n    const released = new Set();\n    const defs = new Map();\n    visitExpressionsInOp(op, (expr, flag) => {\n      if (flag & VisitorContextFlag.InChildOperation) {\n        return;\n      }\n      if (expr instanceof AssignTemporaryExpr) {\n        if (!assigned.has(expr.xref)) {\n          assigned.add(expr.xref);\n          defs.set(expr.xref, `tmp_${opCount}_${count++}`);\n        }\n        assignName(defs, expr);\n      } else if (expr instanceof ReadTemporaryExpr) {\n        if (finalReads.get(expr.xref) === expr) {\n          released.add(expr.xref);\n          count--;\n        }\n        assignName(defs, expr);\n      }\n    });\n    generatedStatements.push(...Array.from(new Set(defs.values())).map(name => createStatementOp(new DeclareVarStmt(name))));\n    opCount++;\n    if (op.kind === OpKind.Listener || op.kind === OpKind.Animation || op.kind === OpKind.AnimationListener || op.kind === OpKind.TwoWayListener) {\n      op.handlerOps.prepend(generateTemporaries(op.handlerOps));\n    } else if (op.kind === OpKind.RepeaterCreate && op.trackByOps !== null) {\n      op.trackByOps.prepend(generateTemporaries(op.trackByOps));\n    }\n  }\n  return generatedStatements;\n}\nfunction assignName(names, expr) {\n  const name = names.get(expr.xref);\n  if (name === undefined) {\n    throw new Error(`Found xref with unassigned name: ${expr.xref}`);\n  }\n  expr.name = name;\n}\nfunction optimizeTrackFns(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind !== OpKind.RepeaterCreate) {\n        continue;\n      }\n      if (op.track instanceof ReadVarExpr && op.track.name === '$index') {\n        op.trackByFn = importExpr(Identifiers.repeaterTrackByIndex);\n      } else if (op.track instanceof ReadVarExpr && op.track.name === '$item') {\n        op.trackByFn = importExpr(Identifiers.repeaterTrackByIdentity);\n      } else if (isTrackByFunctionCall(job.root.xref, op.track)) {\n        op.usesComponentInstance = true;\n        if (op.track.receiver.receiver.view === unit.xref) {\n          op.trackByFn = op.track.receiver;\n        } else {\n          op.trackByFn = importExpr(Identifiers.componentInstance).callFn([]).prop(op.track.receiver.name);\n          op.track = op.trackByFn;\n        }\n      } else {\n        op.track = transformExpressionsInExpression(op.track, expr => {\n          if (expr instanceof PipeBindingExpr || expr instanceof PipeBindingVariadicExpr) {\n            throw new Error(`Illegal State: Pipes are not allowed in this context`);\n          } else if (expr instanceof ContextExpr) {\n            op.usesComponentInstance = true;\n            return new TrackContextExpr(expr.view);\n          }\n          return expr;\n        }, VisitorContextFlag.None);\n        const trackOpList = new OpList();\n        trackOpList.push(createStatementOp(new ReturnStatement(op.track, op.track.sourceSpan)));\n        op.trackByOps = trackOpList;\n      }\n    }\n  }\n}\nfunction isTrackByFunctionCall(rootView, expr) {\n  if (!(expr instanceof InvokeFunctionExpr) || expr.args.length === 0 || expr.args.length > 2) {\n    return false;\n  }\n  if (!(expr.receiver instanceof ReadPropExpr && expr.receiver.receiver instanceof ContextExpr) || expr.receiver.receiver.view !== rootView) {\n    return false;\n  }\n  const [arg0, arg1] = expr.args;\n  if (!(arg0 instanceof ReadVarExpr) || arg0.name !== '$index') {\n    return false;\n  } else if (expr.args.length === 1) {\n    return true;\n  }\n  if (!(arg1 instanceof ReadVarExpr) || arg1.name !== '$item') {\n    return false;\n  }\n  return true;\n}\nfunction generateTrackVariables(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind !== OpKind.RepeaterCreate) {\n        continue;\n      }\n      op.track = transformExpressionsInExpression(op.track, expr => {\n        if (expr instanceof LexicalReadExpr) {\n          if (op.varNames.$index.has(expr.name)) {\n            return variable('$index');\n          } else if (expr.name === op.varNames.$implicit) {\n            return variable('$item');\n          }\n        }\n        return expr;\n      }, VisitorContextFlag.None);\n    }\n  }\n}\nfunction transformTwoWayBindingSet(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.TwoWayListener) {\n        transformExpressionsInOp(op, expr => {\n          if (!(expr instanceof TwoWayBindingSetExpr)) {\n            return expr;\n          }\n          const {\n            target,\n            value\n          } = expr;\n          if (target instanceof ReadPropExpr || target instanceof ReadKeyExpr) {\n            return twoWayBindingSet(target, value).or(target.set(value));\n          }\n          if (target instanceof ReadVariableExpr) {\n            return twoWayBindingSet(target, value);\n          }\n          throw new Error(`Unsupported expression in two-way action binding.`);\n        }, VisitorContextFlag.InChildOperation);\n      }\n    }\n  }\n}\nfunction countVariables(job) {\n  for (const unit of job.units) {\n    let varCount = 0;\n    for (const op of unit.ops()) {\n      if (hasConsumesVarsTrait(op)) {\n        varCount += varsUsedByOp(op);\n      }\n    }\n    for (const op of unit.ops()) {\n      visitExpressionsInOp(op, expr => {\n        if (!isIrExpression(expr)) {\n          return;\n        }\n        if (job.compatibility === CompatibilityMode.TemplateDefinitionBuilder && expr instanceof PureFunctionExpr) {\n          return;\n        }\n        if (hasUsesVarOffsetTrait(expr)) {\n          expr.varOffset = varCount;\n        }\n        if (hasConsumesVarsTrait(expr)) {\n          varCount += varsUsedByIrExpression(expr);\n        }\n      });\n    }\n    if (job.compatibility === CompatibilityMode.TemplateDefinitionBuilder) {\n      for (const op of unit.ops()) {\n        visitExpressionsInOp(op, expr => {\n          if (!isIrExpression(expr) || !(expr instanceof PureFunctionExpr)) {\n            return;\n          }\n          if (hasUsesVarOffsetTrait(expr)) {\n            expr.varOffset = varCount;\n          }\n          if (hasConsumesVarsTrait(expr)) {\n            varCount += varsUsedByIrExpression(expr);\n          }\n        });\n      }\n    }\n    unit.vars = varCount;\n  }\n  if (job instanceof ComponentCompilationJob) {\n    for (const unit of job.units) {\n      for (const op of unit.create) {\n        if (op.kind !== OpKind.Template && op.kind !== OpKind.RepeaterCreate && op.kind !== OpKind.ConditionalCreate && op.kind !== OpKind.ConditionalBranchCreate) {\n          continue;\n        }\n        const childView = job.views.get(op.xref);\n        op.vars = childView.vars;\n      }\n    }\n  }\n}\nfunction varsUsedByOp(op) {\n  let slots;\n  switch (op.kind) {\n    case OpKind.Attribute:\n      slots = 1;\n      if (op.expression instanceof Interpolation && !isSingletonInterpolation(op.expression)) {\n        slots += op.expression.expressions.length;\n      }\n      return slots;\n    case OpKind.Property:\n    case OpKind.DomProperty:\n      slots = 1;\n      if (op.expression instanceof Interpolation) {\n        slots += op.expression.expressions.length;\n      }\n      return slots;\n    case OpKind.Control:\n      return 2;\n    case OpKind.TwoWayProperty:\n      return 1;\n    case OpKind.StyleProp:\n    case OpKind.ClassProp:\n    case OpKind.StyleMap:\n    case OpKind.ClassMap:\n      slots = 2;\n      if (op.expression instanceof Interpolation) {\n        slots += op.expression.expressions.length;\n      }\n      return slots;\n    case OpKind.InterpolateText:\n      return op.interpolation.expressions.length;\n    case OpKind.I18nExpression:\n    case OpKind.Conditional:\n    case OpKind.DeferWhen:\n    case OpKind.StoreLet:\n      return 1;\n    case OpKind.RepeaterCreate:\n      return op.emptyView ? 1 : 0;\n    default:\n      throw new Error(`Unhandled op: ${OpKind[op.kind]}`);\n  }\n}\nfunction varsUsedByIrExpression(expr) {\n  switch (expr.kind) {\n    case ExpressionKind.PureFunctionExpr:\n      return 1 + expr.args.length;\n    case ExpressionKind.PipeBinding:\n      return 1 + expr.args.length;\n    case ExpressionKind.PipeBindingVariadic:\n      return 1 + expr.numArgs;\n    case ExpressionKind.StoreLet:\n      return 1;\n    default:\n      throw new Error(`AssertionError: unhandled ConsumesVarsTrait expression ${expr.constructor.name}`);\n  }\n}\nfunction isSingletonInterpolation(expr) {\n  if (expr.expressions.length !== 1 || expr.strings.length !== 2) {\n    return false;\n  }\n  if (expr.strings[0] !== '' || expr.strings[1] !== '') {\n    return false;\n  }\n  return true;\n}\nfunction optimizeVariables(job) {\n  for (const unit of job.units) {\n    inlineAlwaysInlineVariables(unit.create);\n    inlineAlwaysInlineVariables(unit.update);\n    for (const op of unit.create) {\n      if (op.kind === OpKind.Listener || op.kind === OpKind.Animation || op.kind === OpKind.AnimationListener || op.kind === OpKind.TwoWayListener) {\n        inlineAlwaysInlineVariables(op.handlerOps);\n      } else if (op.kind === OpKind.RepeaterCreate && op.trackByOps !== null) {\n        inlineAlwaysInlineVariables(op.trackByOps);\n      }\n    }\n    optimizeVariablesInOpList(unit.create, job.compatibility);\n    optimizeVariablesInOpList(unit.update, job.compatibility);\n    for (const op of unit.create) {\n      if (op.kind === OpKind.Listener || op.kind === OpKind.Animation || op.kind === OpKind.AnimationListener || op.kind === OpKind.TwoWayListener) {\n        optimizeVariablesInOpList(op.handlerOps, job.compatibility);\n      } else if (op.kind === OpKind.RepeaterCreate && op.trackByOps !== null) {\n        optimizeVariablesInOpList(op.trackByOps, job.compatibility);\n      }\n    }\n  }\n}\nvar Fence;\n(function (Fence) {\n  Fence[Fence[\"None\"] = 0] = \"None\";\n  Fence[Fence[\"ViewContextRead\"] = 1] = \"ViewContextRead\";\n  Fence[Fence[\"ViewContextWrite\"] = 2] = \"ViewContextWrite\";\n  Fence[Fence[\"SideEffectful\"] = 4] = \"SideEffectful\";\n})(Fence || (Fence = {}));\nfunction inlineAlwaysInlineVariables(ops) {\n  const vars = new Map();\n  for (const op of ops) {\n    if (op.kind === OpKind.Variable && op.flags & VariableFlags.AlwaysInline) {\n      visitExpressionsInOp(op, expr => {\n        if (isIrExpression(expr) && fencesForIrExpression(expr) !== Fence.None) {\n          throw new Error(`AssertionError: A context-sensitive variable was marked AlwaysInline`);\n        }\n      });\n      vars.set(op.xref, op);\n    }\n    transformExpressionsInOp(op, expr => {\n      if (expr instanceof ReadVariableExpr && vars.has(expr.xref)) {\n        const varOp = vars.get(expr.xref);\n        return varOp.initializer.clone();\n      }\n      return expr;\n    }, VisitorContextFlag.None);\n  }\n  for (const op of vars.values()) {\n    OpList.remove(op);\n  }\n}\nfunction optimizeVariablesInOpList(ops, compatibility) {\n  const varDecls = new Map();\n  const varUsages = new Map();\n  const varRemoteUsages = new Set();\n  const opMap = new Map();\n  for (const op of ops) {\n    if (op.kind === OpKind.Variable) {\n      if (varDecls.has(op.xref) || varUsages.has(op.xref)) {\n        throw new Error(`Should not see two declarations of the same variable: ${op.xref}`);\n      }\n      varDecls.set(op.xref, op);\n      varUsages.set(op.xref, 0);\n    }\n    opMap.set(op, collectOpInfo(op));\n    countVariableUsages(op, varUsages, varRemoteUsages);\n  }\n  let contextIsUsed = false;\n  for (const op of ops.reversed()) {\n    const opInfo = opMap.get(op);\n    if (op.kind === OpKind.Variable && varUsages.get(op.xref) === 0) {\n      if (contextIsUsed && opInfo.fences & Fence.ViewContextWrite || opInfo.fences & Fence.SideEffectful) {\n        const stmtOp = createStatementOp(op.initializer.toStmt());\n        opMap.set(stmtOp, opInfo);\n        OpList.replace(op, stmtOp);\n      } else {\n        uncountVariableUsages(op, varUsages);\n        OpList.remove(op);\n      }\n      opMap.delete(op);\n      varDecls.delete(op.xref);\n      varUsages.delete(op.xref);\n      continue;\n    }\n    if (opInfo.fences & Fence.ViewContextRead) {\n      contextIsUsed = true;\n    }\n  }\n  const toInline = [];\n  for (const [id, count] of varUsages) {\n    const decl = varDecls.get(id);\n    const isAlwaysInline = !!(decl.flags & VariableFlags.AlwaysInline);\n    if (count !== 1 || isAlwaysInline) {\n      continue;\n    }\n    if (varRemoteUsages.has(id)) {\n      continue;\n    }\n    toInline.push(id);\n  }\n  let candidate;\n  while (candidate = toInline.pop()) {\n    const decl = varDecls.get(candidate);\n    const varInfo = opMap.get(decl);\n    const isAlwaysInline = !!(decl.flags & VariableFlags.AlwaysInline);\n    if (isAlwaysInline) {\n      throw new Error(`AssertionError: Found an 'AlwaysInline' variable after the always inlining pass.`);\n    }\n    for (let targetOp = decl.next; targetOp.kind !== OpKind.ListEnd; targetOp = targetOp.next) {\n      const opInfo = opMap.get(targetOp);\n      if (opInfo.variablesUsed.has(candidate)) {\n        if (compatibility === CompatibilityMode.TemplateDefinitionBuilder && !allowConservativeInlining(decl, targetOp)) {\n          break;\n        }\n        if (tryInlineVariableInitializer(candidate, decl.initializer, targetOp, varInfo.fences)) {\n          opInfo.variablesUsed.delete(candidate);\n          for (const id of varInfo.variablesUsed) {\n            opInfo.variablesUsed.add(id);\n          }\n          opInfo.fences |= varInfo.fences;\n          varDecls.delete(candidate);\n          varUsages.delete(candidate);\n          opMap.delete(decl);\n          OpList.remove(decl);\n        }\n        break;\n      }\n      if (!safeToInlinePastFences(opInfo.fences, varInfo.fences)) {\n        break;\n      }\n    }\n  }\n}\nfunction fencesForIrExpression(expr) {\n  switch (expr.kind) {\n    case ExpressionKind.NextContext:\n      return Fence.ViewContextRead | Fence.ViewContextWrite;\n    case ExpressionKind.RestoreView:\n      return Fence.ViewContextRead | Fence.ViewContextWrite | Fence.SideEffectful;\n    case ExpressionKind.StoreLet:\n      return Fence.SideEffectful;\n    case ExpressionKind.Reference:\n    case ExpressionKind.ContextLetReference:\n      return Fence.ViewContextRead;\n    default:\n      return Fence.None;\n  }\n}\nfunction collectOpInfo(op) {\n  let fences = Fence.None;\n  const variablesUsed = new Set();\n  visitExpressionsInOp(op, expr => {\n    if (!isIrExpression(expr)) {\n      return;\n    }\n    switch (expr.kind) {\n      case ExpressionKind.ReadVariable:\n        variablesUsed.add(expr.xref);\n        break;\n      default:\n        fences |= fencesForIrExpression(expr);\n    }\n  });\n  return {\n    fences,\n    variablesUsed\n  };\n}\nfunction countVariableUsages(op, varUsages, varRemoteUsage) {\n  visitExpressionsInOp(op, (expr, flags) => {\n    if (!isIrExpression(expr)) {\n      return;\n    }\n    if (expr.kind !== ExpressionKind.ReadVariable) {\n      return;\n    }\n    const count = varUsages.get(expr.xref);\n    if (count === undefined) {\n      return;\n    }\n    varUsages.set(expr.xref, count + 1);\n    if (flags & VisitorContextFlag.InChildOperation) {\n      varRemoteUsage.add(expr.xref);\n    }\n  });\n}\nfunction uncountVariableUsages(op, varUsages) {\n  visitExpressionsInOp(op, expr => {\n    if (!isIrExpression(expr)) {\n      return;\n    }\n    if (expr.kind !== ExpressionKind.ReadVariable) {\n      return;\n    }\n    const count = varUsages.get(expr.xref);\n    if (count === undefined) {\n      return;\n    } else if (count === 0) {\n      throw new Error(`Inaccurate variable count: ${expr.xref} - found another read but count is already 0`);\n    }\n    varUsages.set(expr.xref, count - 1);\n  });\n}\nfunction safeToInlinePastFences(fences, declFences) {\n  if (fences & Fence.ViewContextWrite) {\n    if (declFences & Fence.ViewContextRead) {\n      return false;\n    }\n  } else if (fences & Fence.ViewContextRead) {\n    if (declFences & Fence.ViewContextWrite) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction tryInlineVariableInitializer(id, initializer, target, declFences) {\n  let inlined = false;\n  let inliningAllowed = true;\n  transformExpressionsInOp(target, (expr, flags) => {\n    if (!isIrExpression(expr)) {\n      return expr;\n    }\n    if (inlined || !inliningAllowed) {\n      return expr;\n    } else if (flags & VisitorContextFlag.InChildOperation && declFences & Fence.ViewContextRead) {\n      return expr;\n    }\n    switch (expr.kind) {\n      case ExpressionKind.ReadVariable:\n        if (expr.xref === id) {\n          inlined = true;\n          return initializer;\n        }\n        break;\n      default:\n        const exprFences = fencesForIrExpression(expr);\n        inliningAllowed = inliningAllowed && safeToInlinePastFences(exprFences, declFences);\n        break;\n    }\n    return expr;\n  }, VisitorContextFlag.None);\n  return inlined;\n}\nfunction allowConservativeInlining(decl, target) {\n  switch (decl.variable.kind) {\n    case SemanticVariableKind.Identifier:\n      if (decl.initializer instanceof ReadVarExpr && decl.initializer.name === 'ctx') {\n        return true;\n      }\n      return false;\n    case SemanticVariableKind.Context:\n      return target.kind === OpKind.Variable;\n    default:\n      return true;\n  }\n}\nfunction wrapI18nIcus(job) {\n  for (const unit of job.units) {\n    let currentI18nOp = null;\n    let addedI18nId = null;\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nStart:\n          currentI18nOp = op;\n          break;\n        case OpKind.I18nEnd:\n          currentI18nOp = null;\n          break;\n        case OpKind.IcuStart:\n          if (currentI18nOp === null) {\n            addedI18nId = job.allocateXrefId();\n            OpList.insertBefore(createI18nStartOp(addedI18nId, op.message, undefined, null), op);\n          }\n          break;\n        case OpKind.IcuEnd:\n          if (addedI18nId !== null) {\n            OpList.insertAfter(createI18nEndOp(addedI18nId, null), op);\n            addedI18nId = null;\n          }\n          break;\n      }\n    }\n  }\n}\n\n/**\n *\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nconst phases = [{\n  kind: CompilationJobKind.Tmpl,\n  fn: removeContentSelectors\n}, {\n  kind: CompilationJobKind.Both,\n  fn: optimizeRegularExpressions\n}, {\n  kind: CompilationJobKind.Host,\n  fn: parseHostStyleProperties\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: emitNamespaceChanges\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: propagateI18nBlocks\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: wrapI18nIcus\n}, {\n  kind: CompilationJobKind.Both,\n  fn: deduplicateTextBindings\n}, {\n  kind: CompilationJobKind.Both,\n  fn: specializeStyleBindings\n}, {\n  kind: CompilationJobKind.Both,\n  fn: specializeBindings\n}, {\n  kind: CompilationJobKind.Both,\n  fn: convertAnimations\n}, {\n  kind: CompilationJobKind.Both,\n  fn: extractAttributes\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: createI18nContexts\n}, {\n  kind: CompilationJobKind.Both,\n  fn: parseExtractedStyles\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: removeEmptyBindings\n}, {\n  kind: CompilationJobKind.Both,\n  fn: collapseSingletonInterpolations\n}, {\n  kind: CompilationJobKind.Both,\n  fn: orderOps\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: generateConditionalExpressions\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: createPipes\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: configureDeferInstructions\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: createVariadicPipes\n}, {\n  kind: CompilationJobKind.Both,\n  fn: generatePureLiteralStructures\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: generateProjectionDefs\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: generateLocalLetReferences\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: generateVariables\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: saveAndRestoreView\n}, {\n  kind: CompilationJobKind.Both,\n  fn: deleteAnyCasts\n}, {\n  kind: CompilationJobKind.Both,\n  fn: resolveDollarEvent\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: generateTrackVariables\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: removeIllegalLetReferences\n}, {\n  kind: CompilationJobKind.Both,\n  fn: resolveNames\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: resolveDeferTargetNames\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: transformTwoWayBindingSet\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: optimizeTrackFns\n}, {\n  kind: CompilationJobKind.Both,\n  fn: resolveContexts\n}, {\n  kind: CompilationJobKind.Both,\n  fn: resolveSanitizers\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: liftLocalRefs\n}, {\n  kind: CompilationJobKind.Both,\n  fn: expandSafeReads\n}, {\n  kind: CompilationJobKind.Both,\n  fn: stripNonrequiredParentheses\n}, {\n  kind: CompilationJobKind.Both,\n  fn: generateTemporaryVariables\n}, {\n  kind: CompilationJobKind.Both,\n  fn: optimizeVariables\n}, {\n  kind: CompilationJobKind.Both,\n  fn: optimizeStoreLet\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: convertI18nText\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: convertI18nBindings\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: removeUnusedI18nAttributesOps\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: assignI18nSlotDependencies\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: applyI18nExpressions\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: allocateSlots\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: resolveI18nElementPlaceholders\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: resolveI18nExpressionPlaceholders\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: extractI18nMessages\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: collectI18nConsts\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: collectConstExpressions\n}, {\n  kind: CompilationJobKind.Both,\n  fn: collectElementConsts\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: removeI18nContexts\n}, {\n  kind: CompilationJobKind.Both,\n  fn: countVariables\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: generateAdvance\n}, {\n  kind: CompilationJobKind.Both,\n  fn: nameFunctionsAndVariables\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: resolveDeferDepsFns\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: mergeNextContextExpressions\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: generateNgContainerOps\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: collapseEmptyInstructions\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: attachSourceLocations\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: disableBindings$1\n}, {\n  kind: CompilationJobKind.Both,\n  fn: extractPureFunctions\n}, {\n  kind: CompilationJobKind.Both,\n  fn: reify\n}, {\n  kind: CompilationJobKind.Both,\n  fn: chain\n}];\nfunction transform(job, kind) {\n  for (const phase of phases) {\n    if (phase.kind === kind || phase.kind === CompilationJobKind.Both) {\n      phase.fn(job);\n    }\n  }\n}\nfunction emitTemplateFn(tpl, pool) {\n  const rootFn = emitView(tpl.root);\n  emitChildViews(tpl.root, pool);\n  return rootFn;\n}\nfunction emitChildViews(parent, pool) {\n  for (const unit of parent.job.units) {\n    if (unit.parent !== parent.xref) {\n      continue;\n    }\n    emitChildViews(unit, pool);\n    const viewFn = emitView(unit);\n    pool.statements.push(viewFn.toDeclStmt(viewFn.name));\n  }\n}\nfunction emitView(view) {\n  if (view.fnName === null) {\n    throw new Error(`AssertionError: view ${view.xref} is unnamed`);\n  }\n  const createStatements = [];\n  for (const op of view.create) {\n    if (op.kind !== OpKind.Statement) {\n      throw new Error(`AssertionError: expected all create ops to have been compiled, but got ${OpKind[op.kind]}`);\n    }\n    createStatements.push(op.statement);\n  }\n  const updateStatements = [];\n  for (const op of view.update) {\n    if (op.kind !== OpKind.Statement) {\n      throw new Error(`AssertionError: expected all update ops to have been compiled, but got ${OpKind[op.kind]}`);\n    }\n    updateStatements.push(op.statement);\n  }\n  const createCond = maybeGenerateRfBlock(1, createStatements);\n  const updateCond = maybeGenerateRfBlock(2, updateStatements);\n  return fn([new FnParam('rf'), new FnParam('ctx')], [...createCond, ...updateCond], undefined, undefined, view.fnName);\n}\nfunction maybeGenerateRfBlock(flag, statements) {\n  if (statements.length === 0) {\n    return [];\n  }\n  return [ifStmt(new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, variable('rf'), literal(flag)), statements)];\n}\nfunction emitHostBindingFunction(job) {\n  if (job.root.fnName === null) {\n    throw new Error(`AssertionError: host binding function is unnamed`);\n  }\n  const createStatements = [];\n  for (const op of job.root.create) {\n    if (op.kind !== OpKind.Statement) {\n      throw new Error(`AssertionError: expected all create ops to have been compiled, but got ${OpKind[op.kind]}`);\n    }\n    createStatements.push(op.statement);\n  }\n  const updateStatements = [];\n  for (const op of job.root.update) {\n    if (op.kind !== OpKind.Statement) {\n      throw new Error(`AssertionError: expected all update ops to have been compiled, but got ${OpKind[op.kind]}`);\n    }\n    updateStatements.push(op.statement);\n  }\n  if (createStatements.length === 0 && updateStatements.length === 0) {\n    return null;\n  }\n  const createCond = maybeGenerateRfBlock(1, createStatements);\n  const updateCond = maybeGenerateRfBlock(2, updateStatements);\n  return fn([new FnParam('rf'), new FnParam('ctx')], [...createCond, ...updateCond], undefined, undefined, job.root.fnName);\n}\nconst compatibilityMode = CompatibilityMode.TemplateDefinitionBuilder;\nconst domSchema = new DomElementSchemaRegistry();\nconst NG_TEMPLATE_TAG_NAME = 'ng-template';\nconst ANIMATE_PREFIX$1 = 'animate.';\nfunction isI18nRootNode(meta) {\n  return meta instanceof Message;\n}\nfunction isSingleI18nIcu(meta) {\n  return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof Icu;\n}\nfunction ingestComponent(componentName, template, constantPool, compilationMode, relativeContextFilePath, i18nUseExternalIds, deferMeta, allDeferrableDepsFn, relativeTemplatePath, enableDebugLocations) {\n  const job = new ComponentCompilationJob(componentName, constantPool, compatibilityMode, compilationMode, relativeContextFilePath, i18nUseExternalIds, deferMeta, allDeferrableDepsFn, relativeTemplatePath, enableDebugLocations);\n  ingestNodes(job.root, template);\n  return job;\n}\nfunction ingestHostBinding(input, bindingParser, constantPool) {\n  const job = new HostBindingCompilationJob(input.componentName, constantPool, compatibilityMode, TemplateCompilationMode.DomOnly);\n  for (const property of input.properties ?? []) {\n    let bindingKind = BindingKind.Property;\n    if (property.name.startsWith('attr.')) {\n      property.name = property.name.substring('attr.'.length);\n      bindingKind = BindingKind.Attribute;\n    }\n    if (property.isLegacyAnimation) {\n      bindingKind = BindingKind.LegacyAnimation;\n    }\n    if (property.isAnimation) {\n      bindingKind = BindingKind.Animation;\n    }\n    const securityContexts = bindingParser.calcPossibleSecurityContexts(input.componentSelector, property.name, bindingKind === BindingKind.Attribute).filter(context => context !== SecurityContext.NONE);\n    ingestDomProperty(job, property, bindingKind, securityContexts);\n  }\n  for (const [name, expr] of Object.entries(input.attributes) ?? []) {\n    const securityContexts = bindingParser.calcPossibleSecurityContexts(input.componentSelector, name, true).filter(context => context !== SecurityContext.NONE);\n    ingestHostAttribute(job, name, expr, securityContexts);\n  }\n  for (const event of input.events ?? []) {\n    ingestHostEvent(job, event);\n  }\n  return job;\n}\nfunction ingestDomProperty(job, property, bindingKind, securityContexts) {\n  let expression;\n  const ast = property.expression.ast;\n  if (ast instanceof Interpolation$1) {\n    expression = new Interpolation(ast.strings, ast.expressions.map(expr => convertAst(expr, job, property.sourceSpan)), []);\n  } else {\n    expression = convertAst(ast, job, property.sourceSpan);\n  }\n  job.root.update.push(createBindingOp(job.root.xref, bindingKind, property.name, expression, null, securityContexts, false, false, null, null, property.sourceSpan));\n}\nfunction ingestHostAttribute(job, name, value, securityContexts) {\n  const attrBinding = createBindingOp(job.root.xref, BindingKind.Attribute, name, value, null, securityContexts, true, false, null, null, value.sourceSpan);\n  job.root.update.push(attrBinding);\n}\nfunction ingestHostEvent(job, event) {\n  let eventBinding;\n  if (event.type === ParsedEventType.Animation) {\n    eventBinding = createAnimationListenerOp(job.root.xref, new SlotHandle(), event.name, null, makeListenerHandlerOps(job.root, event.handler, event.handlerSpan), event.name.endsWith('enter') ? \"enter\" : \"leave\", event.targetOrPhase, true, event.sourceSpan);\n  } else {\n    const [phase, target] = event.type !== ParsedEventType.LegacyAnimation ? [null, event.targetOrPhase] : [event.targetOrPhase, null];\n    eventBinding = createListenerOp(job.root.xref, new SlotHandle(), event.name, null, makeListenerHandlerOps(job.root, event.handler, event.handlerSpan), phase, target, true, event.sourceSpan);\n  }\n  job.root.create.push(eventBinding);\n}\nfunction ingestNodes(unit, template) {\n  for (const node of template) {\n    if (node instanceof Element$1) {\n      ingestElement(unit, node);\n    } else if (node instanceof Template) {\n      ingestTemplate(unit, node);\n    } else if (node instanceof Content) {\n      ingestContent(unit, node);\n    } else if (node instanceof Text$3) {\n      ingestText(unit, node, null);\n    } else if (node instanceof BoundText) {\n      ingestBoundText(unit, node, null);\n    } else if (node instanceof IfBlock) {\n      ingestIfBlock(unit, node);\n    } else if (node instanceof SwitchBlock) {\n      ingestSwitchBlock(unit, node);\n    } else if (node instanceof DeferredBlock) {\n      ingestDeferBlock(unit, node);\n    } else if (node instanceof Icu$1) {\n      ingestIcu(unit, node);\n    } else if (node instanceof ForLoopBlock) {\n      ingestForBlock(unit, node);\n    } else if (node instanceof LetDeclaration$1) {\n      ingestLetDeclaration(unit, node);\n    } else if (node instanceof Component$1) ;else {\n      throw new Error(`Unsupported template node: ${node.constructor.name}`);\n    }\n  }\n}\nfunction ingestElement(unit, element) {\n  if (element.i18n !== undefined && !(element.i18n instanceof Message || element.i18n instanceof TagPlaceholder)) {\n    throw Error(`Unhandled i18n metadata type for element: ${element.i18n.constructor.name}`);\n  }\n  const id = unit.job.allocateXrefId();\n  const [namespaceKey, elementName] = splitNsName(element.name);\n  const startOp = createElementStartOp(elementName, id, namespaceForKey(namespaceKey), element.i18n instanceof TagPlaceholder ? element.i18n : undefined, element.startSourceSpan, element.sourceSpan);\n  unit.create.push(startOp);\n  ingestElementBindings(unit, startOp, element);\n  ingestReferences(startOp, element);\n  let i18nBlockId = null;\n  if (element.i18n instanceof Message) {\n    i18nBlockId = unit.job.allocateXrefId();\n    unit.create.push(createI18nStartOp(i18nBlockId, element.i18n, undefined, element.startSourceSpan));\n  }\n  ingestNodes(unit, element.children);\n  const endOp = createElementEndOp(id, element.endSourceSpan ?? element.startSourceSpan);\n  unit.create.push(endOp);\n  if (i18nBlockId !== null) {\n    OpList.insertBefore(createI18nEndOp(i18nBlockId, element.endSourceSpan ?? element.startSourceSpan), endOp);\n  }\n}\nfunction ingestTemplate(unit, tmpl) {\n  if (tmpl.i18n !== undefined && !(tmpl.i18n instanceof Message || tmpl.i18n instanceof TagPlaceholder)) {\n    throw Error(`Unhandled i18n metadata type for template: ${tmpl.i18n.constructor.name}`);\n  }\n  const childView = unit.job.allocateView(unit.xref);\n  let tagNameWithoutNamespace = tmpl.tagName;\n  let namespacePrefix = '';\n  if (tmpl.tagName) {\n    [namespacePrefix, tagNameWithoutNamespace] = splitNsName(tmpl.tagName);\n  }\n  const i18nPlaceholder = tmpl.i18n instanceof TagPlaceholder ? tmpl.i18n : undefined;\n  const namespace = namespaceForKey(namespacePrefix);\n  const functionNameSuffix = tagNameWithoutNamespace === null ? '' : prefixWithNamespace(tagNameWithoutNamespace, namespace);\n  const templateKind = isPlainTemplate(tmpl) ? TemplateKind.NgTemplate : TemplateKind.Structural;\n  const templateOp = createTemplateOp(childView.xref, templateKind, tagNameWithoutNamespace, functionNameSuffix, namespace, i18nPlaceholder, tmpl.startSourceSpan, tmpl.sourceSpan);\n  unit.create.push(templateOp);\n  ingestTemplateBindings(unit, templateOp, tmpl, templateKind);\n  ingestReferences(templateOp, tmpl);\n  ingestNodes(childView, tmpl.children);\n  for (const {\n    name,\n    value\n  } of tmpl.variables) {\n    childView.contextVariables.set(name, value !== '' ? value : '$implicit');\n  }\n  if (templateKind === TemplateKind.NgTemplate && tmpl.i18n instanceof Message) {\n    const id = unit.job.allocateXrefId();\n    OpList.insertAfter(createI18nStartOp(id, tmpl.i18n, undefined, tmpl.startSourceSpan), childView.create.head);\n    OpList.insertBefore(createI18nEndOp(id, tmpl.endSourceSpan ?? tmpl.startSourceSpan), childView.create.tail);\n  }\n}\nfunction ingestContent(unit, content) {\n  if (content.i18n !== undefined && !(content.i18n instanceof TagPlaceholder)) {\n    throw Error(`Unhandled i18n metadata type for element: ${content.i18n.constructor.name}`);\n  }\n  let fallbackView = null;\n  if (content.children.some(child => !(child instanceof Comment$1) && (!(child instanceof Text$3) || child.value.trim().length > 0))) {\n    fallbackView = unit.job.allocateView(unit.xref);\n    ingestNodes(fallbackView, content.children);\n  }\n  const id = unit.job.allocateXrefId();\n  const op = createProjectionOp(id, content.selector, content.i18n, fallbackView?.xref ?? null, content.sourceSpan);\n  for (const attr of content.attributes) {\n    const securityContext = domSchema.securityContext(content.name, attr.name, true);\n    unit.update.push(createBindingOp(op.xref, BindingKind.Attribute, attr.name, literal(attr.value), null, securityContext, true, false, null, asMessage(attr.i18n), attr.sourceSpan));\n  }\n  unit.create.push(op);\n}\nfunction ingestText(unit, text, icuPlaceholder) {\n  unit.create.push(createTextOp(unit.job.allocateXrefId(), text.value, icuPlaceholder, text.sourceSpan));\n}\nfunction ingestBoundText(unit, text, icuPlaceholder) {\n  let value = text.value;\n  if (value instanceof ASTWithSource) {\n    value = value.ast;\n  }\n  if (!(value instanceof Interpolation$1)) {\n    throw new Error(`AssertionError: expected Interpolation for BoundText node, got ${value.constructor.name}`);\n  }\n  if (text.i18n !== undefined && !(text.i18n instanceof Container)) {\n    throw Error(`Unhandled i18n metadata type for text interpolation: ${text.i18n?.constructor.name}`);\n  }\n  const i18nPlaceholders = text.i18n instanceof Container ? text.i18n.children.filter(node => node instanceof Placeholder).map(placeholder => placeholder.name) : [];\n  if (i18nPlaceholders.length > 0 && i18nPlaceholders.length !== value.expressions.length) {\n    throw Error(`Unexpected number of i18n placeholders (${value.expressions.length}) for BoundText with ${value.expressions.length} expressions`);\n  }\n  const textXref = unit.job.allocateXrefId();\n  unit.create.push(createTextOp(textXref, '', icuPlaceholder, text.sourceSpan));\n  const baseSourceSpan = unit.job.compatibility ? null : text.sourceSpan;\n  unit.update.push(createInterpolateTextOp(textXref, new Interpolation(value.strings, value.expressions.map(expr => convertAst(expr, unit.job, baseSourceSpan)), i18nPlaceholders), text.sourceSpan));\n}\nfunction ingestIfBlock(unit, ifBlock) {\n  let firstXref = null;\n  let conditions = [];\n  for (let i = 0; i < ifBlock.branches.length; i++) {\n    const ifCase = ifBlock.branches[i];\n    const cView = unit.job.allocateView(unit.xref);\n    const tagName = ingestControlFlowInsertionPoint(unit, cView.xref, ifCase);\n    if (ifCase.expressionAlias !== null) {\n      cView.contextVariables.set(ifCase.expressionAlias.name, CTX_REF);\n    }\n    let ifCaseI18nMeta = undefined;\n    if (ifCase.i18n !== undefined) {\n      if (!(ifCase.i18n instanceof BlockPlaceholder)) {\n        throw Error(`Unhandled i18n metadata type for if block: ${ifCase.i18n?.constructor.name}`);\n      }\n      ifCaseI18nMeta = ifCase.i18n;\n    }\n    const createOp = i === 0 ? createConditionalCreateOp : createConditionalBranchCreateOp;\n    const conditionalCreateOp = createOp(cView.xref, TemplateKind.Block, tagName, 'Conditional', Namespace.HTML, ifCaseI18nMeta, ifCase.startSourceSpan, ifCase.sourceSpan);\n    unit.create.push(conditionalCreateOp);\n    if (firstXref === null) {\n      firstXref = cView.xref;\n    }\n    const caseExpr = ifCase.expression ? convertAst(ifCase.expression, unit.job, null) : null;\n    const conditionalCaseExpr = new ConditionalCaseExpr(caseExpr, conditionalCreateOp.xref, conditionalCreateOp.handle, ifCase.expressionAlias);\n    conditions.push(conditionalCaseExpr);\n    ingestNodes(cView, ifCase.children);\n  }\n  unit.update.push(createConditionalOp(firstXref, null, conditions, ifBlock.sourceSpan));\n}\nfunction ingestSwitchBlock(unit, switchBlock) {\n  if (switchBlock.cases.length === 0) {\n    return;\n  }\n  let firstXref = null;\n  let conditions = [];\n  for (let i = 0; i < switchBlock.cases.length; i++) {\n    const switchCase = switchBlock.cases[i];\n    const cView = unit.job.allocateView(unit.xref);\n    const tagName = ingestControlFlowInsertionPoint(unit, cView.xref, switchCase);\n    let switchCaseI18nMeta = undefined;\n    if (switchCase.i18n !== undefined) {\n      if (!(switchCase.i18n instanceof BlockPlaceholder)) {\n        throw Error(`Unhandled i18n metadata type for switch block: ${switchCase.i18n?.constructor.name}`);\n      }\n      switchCaseI18nMeta = switchCase.i18n;\n    }\n    const createOp = i === 0 ? createConditionalCreateOp : createConditionalBranchCreateOp;\n    const conditionalCreateOp = createOp(cView.xref, TemplateKind.Block, tagName, 'Case', Namespace.HTML, switchCaseI18nMeta, switchCase.startSourceSpan, switchCase.sourceSpan);\n    unit.create.push(conditionalCreateOp);\n    if (firstXref === null) {\n      firstXref = cView.xref;\n    }\n    const caseExpr = switchCase.expression ? convertAst(switchCase.expression, unit.job, switchBlock.startSourceSpan) : null;\n    const conditionalCaseExpr = new ConditionalCaseExpr(caseExpr, conditionalCreateOp.xref, conditionalCreateOp.handle);\n    conditions.push(conditionalCaseExpr);\n    ingestNodes(cView, switchCase.children);\n  }\n  unit.update.push(createConditionalOp(firstXref, convertAst(switchBlock.expression, unit.job, null), conditions, switchBlock.sourceSpan));\n}\nfunction ingestDeferView(unit, suffix, i18nMeta, children, sourceSpan) {\n  if (i18nMeta !== undefined && !(i18nMeta instanceof BlockPlaceholder)) {\n    throw Error('Unhandled i18n metadata type for defer block');\n  }\n  if (children === undefined) {\n    return null;\n  }\n  const secondaryView = unit.job.allocateView(unit.xref);\n  ingestNodes(secondaryView, children);\n  const templateOp = createTemplateOp(secondaryView.xref, TemplateKind.Block, null, `Defer${suffix}`, Namespace.HTML, i18nMeta, sourceSpan, sourceSpan);\n  unit.create.push(templateOp);\n  return templateOp;\n}\nfunction ingestDeferBlock(unit, deferBlock) {\n  let ownResolverFn = null;\n  if (unit.job.deferMeta.mode === 0) {\n    if (!unit.job.deferMeta.blocks.has(deferBlock)) {\n      throw new Error(`AssertionError: unable to find a dependency function for this deferred block`);\n    }\n    ownResolverFn = unit.job.deferMeta.blocks.get(deferBlock) ?? null;\n  }\n  const main = ingestDeferView(unit, '', deferBlock.i18n, deferBlock.children, deferBlock.sourceSpan);\n  const loading = ingestDeferView(unit, 'Loading', deferBlock.loading?.i18n, deferBlock.loading?.children, deferBlock.loading?.sourceSpan);\n  const placeholder = ingestDeferView(unit, 'Placeholder', deferBlock.placeholder?.i18n, deferBlock.placeholder?.children, deferBlock.placeholder?.sourceSpan);\n  const error = ingestDeferView(unit, 'Error', deferBlock.error?.i18n, deferBlock.error?.children, deferBlock.error?.sourceSpan);\n  const deferXref = unit.job.allocateXrefId();\n  const deferOp = createDeferOp(deferXref, main.xref, main.handle, ownResolverFn, unit.job.allDeferrableDepsFn, deferBlock.sourceSpan);\n  deferOp.placeholderView = placeholder?.xref ?? null;\n  deferOp.placeholderSlot = placeholder?.handle ?? null;\n  deferOp.loadingSlot = loading?.handle ?? null;\n  deferOp.errorSlot = error?.handle ?? null;\n  deferOp.placeholderMinimumTime = deferBlock.placeholder?.minimumTime ?? null;\n  deferOp.loadingMinimumTime = deferBlock.loading?.minimumTime ?? null;\n  deferOp.loadingAfterTime = deferBlock.loading?.afterTime ?? null;\n  deferOp.flags = calcDeferBlockFlags(deferBlock);\n  unit.create.push(deferOp);\n  const deferOnOps = [];\n  const deferWhenOps = [];\n  ingestDeferTriggers(\"hydrate\", deferBlock.hydrateTriggers, deferOnOps, deferWhenOps, unit, deferXref);\n  ingestDeferTriggers(\"none\", deferBlock.triggers, deferOnOps, deferWhenOps, unit, deferXref);\n  ingestDeferTriggers(\"prefetch\", deferBlock.prefetchTriggers, deferOnOps, deferWhenOps, unit, deferXref);\n  const hasConcreteTrigger = deferOnOps.some(op => op.modifier === \"none\") || deferWhenOps.some(op => op.modifier === \"none\");\n  if (!hasConcreteTrigger) {\n    deferOnOps.push(createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Idle\n    }, \"none\", null));\n  }\n  unit.create.push(deferOnOps);\n  unit.update.push(deferWhenOps);\n}\nfunction calcDeferBlockFlags(deferBlockDetails) {\n  if (Object.keys(deferBlockDetails.hydrateTriggers).length > 0) {\n    return 1;\n  }\n  return null;\n}\nfunction ingestDeferTriggers(modifier, triggers, onOps, whenOps, unit, deferXref) {\n  if (triggers.idle !== undefined) {\n    const deferOnOp = createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Idle\n    }, modifier, triggers.idle.sourceSpan);\n    onOps.push(deferOnOp);\n  }\n  if (triggers.immediate !== undefined) {\n    const deferOnOp = createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Immediate\n    }, modifier, triggers.immediate.sourceSpan);\n    onOps.push(deferOnOp);\n  }\n  if (triggers.timer !== undefined) {\n    const deferOnOp = createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Timer,\n      delay: triggers.timer.delay\n    }, modifier, triggers.timer.sourceSpan);\n    onOps.push(deferOnOp);\n  }\n  if (triggers.hover !== undefined) {\n    const deferOnOp = createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Hover,\n      targetName: triggers.hover.reference,\n      targetXref: null,\n      targetSlot: null,\n      targetView: null,\n      targetSlotViewSteps: null\n    }, modifier, triggers.hover.sourceSpan);\n    onOps.push(deferOnOp);\n  }\n  if (triggers.interaction !== undefined) {\n    const deferOnOp = createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Interaction,\n      targetName: triggers.interaction.reference,\n      targetXref: null,\n      targetSlot: null,\n      targetView: null,\n      targetSlotViewSteps: null\n    }, modifier, triggers.interaction.sourceSpan);\n    onOps.push(deferOnOp);\n  }\n  if (triggers.viewport !== undefined) {\n    const deferOnOp = createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Viewport,\n      targetName: triggers.viewport.reference,\n      targetXref: null,\n      targetSlot: null,\n      targetView: null,\n      targetSlotViewSteps: null,\n      options: triggers.viewport.options ? convertAst(triggers.viewport.options, unit.job, triggers.viewport.sourceSpan) : null\n    }, modifier, triggers.viewport.sourceSpan);\n    onOps.push(deferOnOp);\n  }\n  if (triggers.never !== undefined) {\n    const deferOnOp = createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Never\n    }, modifier, triggers.never.sourceSpan);\n    onOps.push(deferOnOp);\n  }\n  if (triggers.when !== undefined) {\n    if (triggers.when.value instanceof Interpolation$1) {\n      throw new Error(`Unexpected interpolation in defer block when trigger`);\n    }\n    const deferOnOp = createDeferWhenOp(deferXref, convertAst(triggers.when.value, unit.job, triggers.when.sourceSpan), modifier, triggers.when.sourceSpan);\n    whenOps.push(deferOnOp);\n  }\n}\nfunction ingestIcu(unit, icu) {\n  if (icu.i18n instanceof Message && isSingleI18nIcu(icu.i18n)) {\n    const xref = unit.job.allocateXrefId();\n    unit.create.push(createIcuStartOp(xref, icu.i18n, icuFromI18nMessage(icu.i18n).name, null));\n    for (const [placeholder, text] of Object.entries({\n      ...icu.vars,\n      ...icu.placeholders\n    })) {\n      if (text instanceof BoundText) {\n        ingestBoundText(unit, text, placeholder);\n      } else {\n        ingestText(unit, text, placeholder);\n      }\n    }\n    unit.create.push(createIcuEndOp(xref));\n  } else {\n    throw Error(`Unhandled i18n metadata type for ICU: ${icu.i18n?.constructor.name}`);\n  }\n}\nfunction ingestForBlock(unit, forBlock) {\n  const repeaterView = unit.job.allocateView(unit.xref);\n  const indexName = `Éµ$index_${repeaterView.xref}`;\n  const countName = `Éµ$count_${repeaterView.xref}`;\n  const indexVarNames = new Set();\n  repeaterView.contextVariables.set(forBlock.item.name, forBlock.item.value);\n  for (const variable of forBlock.contextVariables) {\n    if (variable.value === '$index') {\n      indexVarNames.add(variable.name);\n    }\n    if (variable.name === '$index') {\n      repeaterView.contextVariables.set('$index', variable.value).set(indexName, variable.value);\n    } else if (variable.name === '$count') {\n      repeaterView.contextVariables.set('$count', variable.value).set(countName, variable.value);\n    } else {\n      repeaterView.aliases.add({\n        kind: SemanticVariableKind.Alias,\n        name: null,\n        identifier: variable.name,\n        expression: getComputedForLoopVariableExpression(variable, indexName, countName)\n      });\n    }\n  }\n  const sourceSpan = convertSourceSpan(forBlock.trackBy.span, forBlock.sourceSpan);\n  const track = convertAst(forBlock.trackBy, unit.job, sourceSpan);\n  ingestNodes(repeaterView, forBlock.children);\n  let emptyView = null;\n  let emptyTagName = null;\n  if (forBlock.empty !== null) {\n    emptyView = unit.job.allocateView(unit.xref);\n    ingestNodes(emptyView, forBlock.empty.children);\n    emptyTagName = ingestControlFlowInsertionPoint(unit, emptyView.xref, forBlock.empty);\n  }\n  const varNames = {\n    $index: indexVarNames,\n    $implicit: forBlock.item.name\n  };\n  if (forBlock.i18n !== undefined && !(forBlock.i18n instanceof BlockPlaceholder)) {\n    throw Error('AssertionError: Unhandled i18n metadata type or @for');\n  }\n  if (forBlock.empty?.i18n !== undefined && !(forBlock.empty.i18n instanceof BlockPlaceholder)) {\n    throw Error('AssertionError: Unhandled i18n metadata type or @empty');\n  }\n  const i18nPlaceholder = forBlock.i18n;\n  const emptyI18nPlaceholder = forBlock.empty?.i18n;\n  const tagName = ingestControlFlowInsertionPoint(unit, repeaterView.xref, forBlock);\n  const repeaterCreate = createRepeaterCreateOp(repeaterView.xref, emptyView?.xref ?? null, tagName, track, varNames, emptyTagName, i18nPlaceholder, emptyI18nPlaceholder, forBlock.startSourceSpan, forBlock.sourceSpan);\n  unit.create.push(repeaterCreate);\n  const expression = convertAst(forBlock.expression, unit.job, convertSourceSpan(forBlock.expression.span, forBlock.sourceSpan));\n  const repeater = createRepeaterOp(repeaterCreate.xref, repeaterCreate.handle, expression, forBlock.sourceSpan);\n  unit.update.push(repeater);\n}\nfunction getComputedForLoopVariableExpression(variable, indexName, countName) {\n  switch (variable.value) {\n    case '$index':\n      return new LexicalReadExpr(indexName);\n    case '$count':\n      return new LexicalReadExpr(countName);\n    case '$first':\n      return new LexicalReadExpr(indexName).identical(literal(0));\n    case '$last':\n      return new LexicalReadExpr(indexName).identical(new LexicalReadExpr(countName).minus(literal(1)));\n    case '$even':\n      return new LexicalReadExpr(indexName).modulo(literal(2)).identical(literal(0));\n    case '$odd':\n      return new LexicalReadExpr(indexName).modulo(literal(2)).notIdentical(literal(0));\n    default:\n      throw new Error(`AssertionError: unknown @for loop variable ${variable.value}`);\n  }\n}\nfunction ingestLetDeclaration(unit, node) {\n  const target = unit.job.allocateXrefId();\n  unit.create.push(createDeclareLetOp(target, node.name, node.sourceSpan));\n  unit.update.push(createStoreLetOp(target, node.name, convertAst(node.value, unit.job, node.valueSpan), node.sourceSpan));\n}\nfunction convertAst(ast, job, baseSourceSpan) {\n  if (ast instanceof ASTWithSource) {\n    return convertAst(ast.ast, job, baseSourceSpan);\n  } else if (ast instanceof PropertyRead) {\n    const isImplicitReceiver = ast.receiver instanceof ImplicitReceiver && !(ast.receiver instanceof ThisReceiver);\n    if (isImplicitReceiver) {\n      return new LexicalReadExpr(ast.name);\n    } else {\n      return new ReadPropExpr(convertAst(ast.receiver, job, baseSourceSpan), ast.name, null, convertSourceSpan(ast.span, baseSourceSpan));\n    }\n  } else if (ast instanceof Call) {\n    if (ast.receiver instanceof ImplicitReceiver) {\n      throw new Error(`Unexpected ImplicitReceiver`);\n    } else {\n      return new InvokeFunctionExpr(convertAst(ast.receiver, job, baseSourceSpan), ast.args.map(arg => convertAst(arg, job, baseSourceSpan)), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n    }\n  } else if (ast instanceof LiteralPrimitive) {\n    return literal(ast.value, undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof Unary) {\n    switch (ast.operator) {\n      case '+':\n        return new UnaryOperatorExpr(UnaryOperator.Plus, convertAst(ast.expr, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n      case '-':\n        return new UnaryOperatorExpr(UnaryOperator.Minus, convertAst(ast.expr, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n      default:\n        throw new Error(`AssertionError: unknown unary operator ${ast.operator}`);\n    }\n  } else if (ast instanceof Binary) {\n    const operator = BINARY_OPERATORS.get(ast.operation);\n    if (operator === undefined) {\n      throw new Error(`AssertionError: unknown binary operator ${ast.operation}`);\n    }\n    return new BinaryOperatorExpr(operator, convertAst(ast.left, job, baseSourceSpan), convertAst(ast.right, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof ThisReceiver) {\n    return new ContextExpr(job.root.xref);\n  } else if (ast instanceof KeyedRead) {\n    return new ReadKeyExpr(convertAst(ast.receiver, job, baseSourceSpan), convertAst(ast.key, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof Chain) {\n    throw new Error(`AssertionError: Chain in unknown context`);\n  } else if (ast instanceof LiteralMap) {\n    const entries = ast.keys.map((key, idx) => {\n      const value = ast.values[idx];\n      return new LiteralMapEntry(key.key, convertAst(value, job, baseSourceSpan), key.quoted);\n    });\n    return new LiteralMapExpr(entries, undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof LiteralArray) {\n    return new LiteralArrayExpr(ast.expressions.map(expr => convertAst(expr, job, baseSourceSpan)));\n  } else if (ast instanceof Conditional) {\n    return new ConditionalExpr(convertAst(ast.condition, job, baseSourceSpan), convertAst(ast.trueExp, job, baseSourceSpan), convertAst(ast.falseExp, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof NonNullAssert) {\n    return convertAst(ast.expression, job, baseSourceSpan);\n  } else if (ast instanceof BindingPipe) {\n    return new PipeBindingExpr(job.allocateXrefId(), new SlotHandle(), ast.name, [convertAst(ast.exp, job, baseSourceSpan), ...ast.args.map(arg => convertAst(arg, job, baseSourceSpan))]);\n  } else if (ast instanceof SafeKeyedRead) {\n    return new SafeKeyedReadExpr(convertAst(ast.receiver, job, baseSourceSpan), convertAst(ast.key, job, baseSourceSpan), convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof SafePropertyRead) {\n    return new SafePropertyReadExpr(convertAst(ast.receiver, job, baseSourceSpan), ast.name);\n  } else if (ast instanceof SafeCall) {\n    return new SafeInvokeFunctionExpr(convertAst(ast.receiver, job, baseSourceSpan), ast.args.map(a => convertAst(a, job, baseSourceSpan)));\n  } else if (ast instanceof EmptyExpr$1) {\n    return new EmptyExpr(convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof PrefixNot) {\n    return not(convertAst(ast.expression, job, baseSourceSpan), convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof TypeofExpression) {\n    return typeofExpr(convertAst(ast.expression, job, baseSourceSpan));\n  } else if (ast instanceof VoidExpression) {\n    return new VoidExpr(convertAst(ast.expression, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof TemplateLiteral) {\n    return convertTemplateLiteral(ast, job, baseSourceSpan);\n  } else if (ast instanceof TaggedTemplateLiteral) {\n    return new TaggedTemplateLiteralExpr(convertAst(ast.tag, job, baseSourceSpan), convertTemplateLiteral(ast.template, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof ParenthesizedExpression) {\n    return new ParenthesizedExpr(convertAst(ast.expression, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof RegularExpressionLiteral) {\n    return new RegularExpressionLiteralExpr(ast.body, ast.flags, baseSourceSpan);\n  } else {\n    throw new Error(`Unhandled expression type \"${ast.constructor.name}\" in file \"${baseSourceSpan?.start.file.url}\"`);\n  }\n}\nfunction convertTemplateLiteral(ast, job, baseSourceSpan) {\n  return new TemplateLiteralExpr(ast.elements.map(el => {\n    return new TemplateLiteralElementExpr(el.text, convertSourceSpan(el.span, baseSourceSpan));\n  }), ast.expressions.map(expr => convertAst(expr, job, baseSourceSpan)), convertSourceSpan(ast.span, baseSourceSpan));\n}\nfunction convertAstWithInterpolation(job, value, i18nMeta, sourceSpan) {\n  let expression;\n  if (value instanceof Interpolation$1) {\n    expression = new Interpolation(value.strings, value.expressions.map(e => convertAst(e, job, null)), Object.keys(asMessage(i18nMeta)?.placeholders ?? {}));\n  } else if (value instanceof AST) {\n    expression = convertAst(value, job, null);\n  } else {\n    expression = literal(value);\n  }\n  return expression;\n}\nconst BINDING_KINDS = new Map([[BindingType.Property, BindingKind.Property], [BindingType.TwoWay, BindingKind.TwoWayProperty], [BindingType.Attribute, BindingKind.Attribute], [BindingType.Class, BindingKind.ClassName], [BindingType.Style, BindingKind.StyleProperty], [BindingType.LegacyAnimation, BindingKind.LegacyAnimation], [BindingType.Animation, BindingKind.Animation]]);\nfunction isPlainTemplate(tmpl) {\n  return splitNsName(tmpl.tagName ?? '')[1] === NG_TEMPLATE_TAG_NAME;\n}\nfunction asMessage(i18nMeta) {\n  if (i18nMeta == null) {\n    return null;\n  }\n  if (!(i18nMeta instanceof Message)) {\n    throw Error(`Expected i18n meta to be a Message, but got: ${i18nMeta.constructor.name}`);\n  }\n  return i18nMeta;\n}\nfunction ingestElementBindings(unit, op, element) {\n  let bindings = new Array();\n  let i18nAttributeBindingNames = new Set();\n  for (const attr of element.attributes) {\n    const securityContext = domSchema.securityContext(element.name, attr.name, true);\n    bindings.push(createBindingOp(op.xref, BindingKind.Attribute, attr.name, convertAstWithInterpolation(unit.job, attr.value, attr.i18n), null, securityContext, true, false, null, asMessage(attr.i18n), attr.sourceSpan));\n    if (attr.i18n) {\n      i18nAttributeBindingNames.add(attr.name);\n    }\n  }\n  for (const input of element.inputs) {\n    if (i18nAttributeBindingNames.has(input.name)) {\n      console.error(`On component ${unit.job.componentName}, the binding ${input.name} is both an i18n attribute and a property. You may want to remove the property binding. This will become a compilation error in future versions of Angular.`);\n    }\n    bindings.push(createBindingOp(op.xref, BINDING_KINDS.get(input.type), input.name, convertAstWithInterpolation(unit.job, astOf(input.value), input.i18n), input.unit, input.securityContext, false, false, null, asMessage(input.i18n) ?? null, input.sourceSpan));\n    if (input.type === BindingType.Property && input.name === 'field') {\n      unit.create.push(createControlCreateOp(input.sourceSpan));\n    }\n  }\n  unit.create.push(bindings.filter(b => b?.kind === OpKind.ExtractedAttribute));\n  unit.update.push(bindings.filter(b => b?.kind === OpKind.Binding));\n  for (const output of element.outputs) {\n    if (output.type === ParsedEventType.LegacyAnimation && output.phase === null) {\n      throw Error('Animation listener should have a phase');\n    }\n    if (output.type === ParsedEventType.TwoWay) {\n      unit.create.push(createTwoWayListenerOp(op.xref, op.handle, output.name, op.tag, makeTwoWayListenerHandlerOps(unit, output.handler, output.handlerSpan), output.sourceSpan));\n    } else if (output.type === ParsedEventType.Animation) {\n      unit.create.push(createAnimationListenerOp(op.xref, op.handle, output.name, op.tag, makeListenerHandlerOps(unit, output.handler, output.handlerSpan), output.name.endsWith('enter') ? \"enter\" : \"leave\", output.target, false, output.sourceSpan));\n    } else {\n      unit.create.push(createListenerOp(op.xref, op.handle, output.name, op.tag, makeListenerHandlerOps(unit, output.handler, output.handlerSpan), output.phase, output.target, false, output.sourceSpan));\n    }\n  }\n  if (bindings.some(b => b?.i18nMessage) !== null) {\n    unit.create.push(createI18nAttributesOp(unit.job.allocateXrefId(), new SlotHandle(), op.xref));\n  }\n}\nfunction ingestTemplateBindings(unit, op, template, templateKind) {\n  let bindings = new Array();\n  for (const attr of template.templateAttrs) {\n    if (attr instanceof TextAttribute) {\n      const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, attr.name, true);\n      bindings.push(createTemplateBinding(unit, op.xref, BindingType.Attribute, attr.name, attr.value, null, securityContext, true, templateKind, asMessage(attr.i18n), attr.sourceSpan));\n    } else {\n      bindings.push(createTemplateBinding(unit, op.xref, attr.type, attr.name, astOf(attr.value), attr.unit, attr.securityContext, true, templateKind, asMessage(attr.i18n), attr.sourceSpan));\n    }\n  }\n  for (const attr of template.attributes) {\n    const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, attr.name, true);\n    bindings.push(createTemplateBinding(unit, op.xref, BindingType.Attribute, attr.name, attr.value, null, securityContext, false, templateKind, asMessage(attr.i18n), attr.sourceSpan));\n  }\n  for (const input of template.inputs) {\n    bindings.push(createTemplateBinding(unit, op.xref, input.type, input.name, astOf(input.value), input.unit, input.securityContext, false, templateKind, asMessage(input.i18n), input.sourceSpan));\n  }\n  unit.create.push(bindings.filter(b => b?.kind === OpKind.ExtractedAttribute));\n  unit.update.push(bindings.filter(b => b?.kind === OpKind.Binding));\n  for (const output of template.outputs) {\n    if (output.type === ParsedEventType.LegacyAnimation && output.phase === null) {\n      throw Error('Animation listener should have a phase');\n    }\n    if (templateKind === TemplateKind.NgTemplate) {\n      if (output.type === ParsedEventType.TwoWay) {\n        unit.create.push(createTwoWayListenerOp(op.xref, op.handle, output.name, op.tag, makeTwoWayListenerHandlerOps(unit, output.handler, output.handlerSpan), output.sourceSpan));\n      } else {\n        unit.create.push(createListenerOp(op.xref, op.handle, output.name, op.tag, makeListenerHandlerOps(unit, output.handler, output.handlerSpan), output.phase, output.target, false, output.sourceSpan));\n      }\n    }\n    if (templateKind === TemplateKind.Structural && output.type !== ParsedEventType.LegacyAnimation) {\n      const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, output.name, false);\n      unit.create.push(createExtractedAttributeOp(op.xref, BindingKind.Property, null, output.name, null, null, null, securityContext));\n    }\n  }\n  if (bindings.some(b => b?.i18nMessage) !== null) {\n    unit.create.push(createI18nAttributesOp(unit.job.allocateXrefId(), new SlotHandle(), op.xref));\n  }\n}\nfunction createTemplateBinding(view, xref, type, name, value, unit, securityContext, isStructuralTemplateAttribute, templateKind, i18nMessage, sourceSpan) {\n  const isTextBinding = typeof value === 'string';\n  if (templateKind === TemplateKind.Structural) {\n    if (!isStructuralTemplateAttribute) {\n      switch (type) {\n        case BindingType.Property:\n        case BindingType.Class:\n        case BindingType.Style:\n          return createExtractedAttributeOp(xref, BindingKind.Property, null, name, null, null, i18nMessage, securityContext);\n        case BindingType.TwoWay:\n          return createExtractedAttributeOp(xref, BindingKind.TwoWayProperty, null, name, null, null, i18nMessage, securityContext);\n      }\n    }\n    if (!isTextBinding && (type === BindingType.Attribute || type === BindingType.LegacyAnimation || type === BindingType.Animation)) {\n      return null;\n    }\n  }\n  let bindingType = BINDING_KINDS.get(type);\n  if (templateKind === TemplateKind.NgTemplate) {\n    if (type === BindingType.Class || type === BindingType.Style || type === BindingType.Attribute && !isTextBinding) {\n      bindingType = BindingKind.Property;\n    }\n  }\n  return createBindingOp(xref, bindingType, name, convertAstWithInterpolation(view.job, value, i18nMessage), unit, securityContext, isTextBinding, isStructuralTemplateAttribute, templateKind, i18nMessage, sourceSpan);\n}\nfunction makeListenerHandlerOps(unit, handler, handlerSpan) {\n  handler = astOf(handler);\n  const handlerOps = new Array();\n  let handlerExprs = handler instanceof Chain ? handler.expressions : [handler];\n  if (handlerExprs.length === 0) {\n    throw new Error('Expected listener to have non-empty expression list.');\n  }\n  const expressions = handlerExprs.map(expr => convertAst(expr, unit.job, handlerSpan));\n  const returnExpr = expressions.pop();\n  handlerOps.push(...expressions.map(e => createStatementOp(new ExpressionStatement(e, e.sourceSpan))));\n  handlerOps.push(createStatementOp(new ReturnStatement(returnExpr, returnExpr.sourceSpan)));\n  return handlerOps;\n}\nfunction makeTwoWayListenerHandlerOps(unit, handler, handlerSpan) {\n  handler = astOf(handler);\n  const handlerOps = new Array();\n  if (handler instanceof Chain) {\n    if (handler.expressions.length === 1) {\n      handler = handler.expressions[0];\n    } else {\n      throw new Error('Expected two-way listener to have a single expression.');\n    }\n  }\n  const handlerExpr = convertAst(handler, unit.job, handlerSpan);\n  const eventReference = new LexicalReadExpr('$event');\n  const twoWaySetExpr = new TwoWayBindingSetExpr(handlerExpr, eventReference);\n  handlerOps.push(createStatementOp(new ExpressionStatement(twoWaySetExpr)));\n  handlerOps.push(createStatementOp(new ReturnStatement(eventReference)));\n  return handlerOps;\n}\nfunction astOf(ast) {\n  return ast instanceof ASTWithSource ? ast.ast : ast;\n}\nfunction ingestReferences(op, element) {\n  assertIsArray(op.localRefs);\n  for (const {\n    name,\n    value\n  } of element.references) {\n    op.localRefs.push({\n      name,\n      target: value\n    });\n  }\n}\nfunction assertIsArray(value) {\n  if (!Array.isArray(value)) {\n    throw new Error(`AssertionError: expected an array`);\n  }\n}\nfunction convertSourceSpan(span, baseSourceSpan) {\n  if (baseSourceSpan === null) {\n    return null;\n  }\n  const start = baseSourceSpan.start.moveBy(span.start);\n  const end = baseSourceSpan.start.moveBy(span.end);\n  const fullStart = baseSourceSpan.fullStart.moveBy(span.start);\n  return new ParseSourceSpan(start, end, fullStart);\n}\nfunction ingestControlFlowInsertionPoint(unit, xref, node) {\n  let root = null;\n  for (const child of node.children) {\n    if (child instanceof Comment$1 || child instanceof LetDeclaration$1) {\n      continue;\n    }\n    if (root !== null) {\n      return null;\n    }\n    if (child instanceof Element$1 || child instanceof Template && child.tagName !== null) {\n      root = child;\n    } else {\n      return null;\n    }\n  }\n  if (root !== null) {\n    for (const attr of root.attributes) {\n      if (!attr.name.startsWith(ANIMATE_PREFIX$1)) {\n        const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, attr.name, true);\n        unit.update.push(createBindingOp(xref, BindingKind.Attribute, attr.name, literal(attr.value), null, securityContext, true, false, null, asMessage(attr.i18n), attr.sourceSpan));\n      }\n    }\n    for (const attr of root.inputs) {\n      if (attr.type !== BindingType.LegacyAnimation && attr.type !== BindingType.Animation && attr.type !== BindingType.Attribute) {\n        const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, attr.name, true);\n        unit.create.push(createExtractedAttributeOp(xref, BindingKind.Property, null, attr.name, null, null, null, securityContext));\n      }\n    }\n    const tagName = root instanceof Element$1 ? root.name : root.tagName;\n    return tagName === NG_TEMPLATE_TAG_NAME ? null : tagName;\n  }\n  return null;\n}\nlet ENABLE_TEMPLATE_SOURCE_LOCATIONS = false;\nfunction setEnableTemplateSourceLocations(value) {\n  ENABLE_TEMPLATE_SOURCE_LOCATIONS = value;\n}\nfunction getTemplateSourceLocationsEnabled() {\n  return ENABLE_TEMPLATE_SOURCE_LOCATIONS;\n}\nfunction renderFlagCheckIfStmt(flags, statements) {\n  return ifStmt(variable(RENDER_FLAGS).bitwiseAnd(literal(flags), null), statements);\n}\nfunction toQueryFlags(query) {\n  return (query.descendants ? 1 : 0) | (query.static ? 2 : 0) | (query.emitDistinctChangesOnly ? 4 : 0);\n}\nfunction getQueryPredicate(query, constantPool) {\n  if (Array.isArray(query.predicate)) {\n    let predicate = [];\n    query.predicate.forEach(selector => {\n      const selectors = selector.split(',').map(token => literal(token.trim()));\n      predicate.push(...selectors);\n    });\n    return constantPool.getConstLiteral(literalArr(predicate), true);\n  } else {\n    switch (query.predicate.forwardRef) {\n      case 0:\n      case 2:\n        return query.predicate.expression;\n      case 1:\n        return importExpr(Identifiers.resolveForwardRef).callFn([query.predicate.expression]);\n    }\n  }\n}\nfunction createQueryCreateCall(query, constantPool, queryTypeFns, prependParams) {\n  const parameters = [];\n  if (prependParams !== undefined) {\n    parameters.push(...prependParams);\n  }\n  if (query.isSignal) {\n    parameters.push(new ReadPropExpr(variable(CONTEXT_NAME), query.propertyName));\n  }\n  parameters.push(getQueryPredicate(query, constantPool), literal(toQueryFlags(query)));\n  if (query.read) {\n    parameters.push(query.read);\n  }\n  const queryCreateFn = query.isSignal ? queryTypeFns.signalBased : queryTypeFns.nonSignal;\n  return importExpr(queryCreateFn).callFn(parameters);\n}\nconst queryAdvancePlaceholder = Symbol('queryAdvancePlaceholder');\nfunction collapseAdvanceStatements(statements) {\n  const result = [];\n  let advanceCollapseCount = 0;\n  const flushAdvanceCount = () => {\n    if (advanceCollapseCount > 0) {\n      result.unshift(importExpr(Identifiers.queryAdvance).callFn(advanceCollapseCount === 1 ? [] : [literal(advanceCollapseCount)]).toStmt());\n      advanceCollapseCount = 0;\n    }\n  };\n  for (let i = statements.length - 1; i >= 0; i--) {\n    const st = statements[i];\n    if (st === queryAdvancePlaceholder) {\n      advanceCollapseCount++;\n    } else {\n      flushAdvanceCount();\n      result.unshift(st);\n    }\n  }\n  flushAdvanceCount();\n  return result;\n}\nfunction createViewQueriesFunction(viewQueries, constantPool, name) {\n  const createStatements = [];\n  const updateStatements = [];\n  const tempAllocator = temporaryAllocator(st => updateStatements.push(st), TEMPORARY_NAME);\n  viewQueries.forEach(query => {\n    const queryDefinitionCall = createQueryCreateCall(query, constantPool, {\n      signalBased: Identifiers.viewQuerySignal,\n      nonSignal: Identifiers.viewQuery\n    });\n    createStatements.push(queryDefinitionCall.toStmt());\n    if (query.isSignal) {\n      updateStatements.push(queryAdvancePlaceholder);\n      return;\n    }\n    const temporary = tempAllocator();\n    const getQueryList = importExpr(Identifiers.loadQuery).callFn([]);\n    const refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);\n    const updateDirective = variable(CONTEXT_NAME).prop(query.propertyName).set(query.first ? temporary.prop('first') : temporary);\n    updateStatements.push(refresh.and(updateDirective).toStmt());\n  });\n  const viewQueryFnName = name ? `${name}_Query` : null;\n  return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [renderFlagCheckIfStmt(1, createStatements), renderFlagCheckIfStmt(2, collapseAdvanceStatements(updateStatements))], INFERRED_TYPE, null, viewQueryFnName);\n}\nfunction createContentQueriesFunction(queries, constantPool, name) {\n  const createStatements = [];\n  const updateStatements = [];\n  const tempAllocator = temporaryAllocator(st => updateStatements.push(st), TEMPORARY_NAME);\n  for (const query of queries) {\n    createStatements.push(createQueryCreateCall(query, constantPool, {\n      nonSignal: Identifiers.contentQuery,\n      signalBased: Identifiers.contentQuerySignal\n    }, [variable('dirIndex')]).toStmt());\n    if (query.isSignal) {\n      updateStatements.push(queryAdvancePlaceholder);\n      continue;\n    }\n    const temporary = tempAllocator();\n    const getQueryList = importExpr(Identifiers.loadQuery).callFn([]);\n    const refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);\n    const updateDirective = variable(CONTEXT_NAME).prop(query.propertyName).set(query.first ? temporary.prop('first') : temporary);\n    updateStatements.push(refresh.and(updateDirective).toStmt());\n  }\n  const contentQueriesFnName = name ? `${name}_ContentQueries` : null;\n  return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null), new FnParam('dirIndex', null)], [renderFlagCheckIfStmt(1, createStatements), renderFlagCheckIfStmt(2, collapseAdvanceStatements(updateStatements))], INFERRED_TYPE, null, contentQueriesFnName);\n}\nclass HtmlParser extends Parser$1 {\n  constructor() {\n    super(getHtmlTagDefinition);\n  }\n  parse(source, url, options) {\n    return super.parse(source, url, options);\n  }\n}\nconst PROPERTY_PARTS_SEPARATOR = '.';\nconst ATTRIBUTE_PREFIX = 'attr';\nconst ANIMATE_PREFIX = 'animate';\nconst CLASS_PREFIX = 'class';\nconst STYLE_PREFIX = 'style';\nconst TEMPLATE_ATTR_PREFIX$1 = '*';\nconst LEGACY_ANIMATE_PROP_PREFIX = 'animate-';\nclass BindingParser {\n  _exprParser;\n  _schemaRegistry;\n  errors;\n  constructor(_exprParser, _schemaRegistry, errors) {\n    this._exprParser = _exprParser;\n    this._schemaRegistry = _schemaRegistry;\n    this.errors = errors;\n  }\n  createBoundHostProperties(properties, sourceSpan) {\n    const boundProps = [];\n    for (const propName of Object.keys(properties)) {\n      const expression = properties[propName];\n      if (typeof expression === 'string') {\n        this.parsePropertyBinding(propName, expression, true, false, sourceSpan, sourceSpan.start.offset, undefined, [], boundProps, sourceSpan);\n      } else {\n        this._reportError(`Value of the host property binding \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`, sourceSpan);\n      }\n    }\n    return boundProps;\n  }\n  createDirectiveHostEventAsts(hostListeners, sourceSpan) {\n    const targetEvents = [];\n    for (const propName of Object.keys(hostListeners)) {\n      const expression = hostListeners[propName];\n      if (typeof expression === 'string') {\n        this.parseEvent(propName, expression, false, sourceSpan, sourceSpan, [], targetEvents, sourceSpan);\n      } else {\n        this._reportError(`Value of the host listener \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`, sourceSpan);\n      }\n    }\n    return targetEvents;\n  }\n  parseInterpolation(value, sourceSpan, interpolatedTokens) {\n    const absoluteOffset = sourceSpan.fullStart.offset;\n    try {\n      const ast = this._exprParser.parseInterpolation(value, sourceSpan, absoluteOffset, interpolatedTokens);\n      if (ast) {\n        this.errors.push(...ast.errors);\n      }\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n    }\n  }\n  parseInterpolationExpression(expression, sourceSpan) {\n    const absoluteOffset = sourceSpan.start.offset;\n    try {\n      const ast = this._exprParser.parseInterpolationExpression(expression, sourceSpan, absoluteOffset);\n      if (ast) {\n        this.errors.push(...ast.errors);\n      }\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n    }\n  }\n  parseInlineTemplateBinding(tplKey, tplValue, sourceSpan, absoluteValueOffset, targetMatchableAttrs, targetProps, targetVars, isIvyAst) {\n    const absoluteKeyOffset = sourceSpan.start.offset + TEMPLATE_ATTR_PREFIX$1.length;\n    const bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);\n    for (const binding of bindings) {\n      const bindingSpan = moveParseSourceSpan(sourceSpan, binding.sourceSpan);\n      const key = binding.key.source;\n      const keySpan = moveParseSourceSpan(sourceSpan, binding.key.span);\n      if (binding instanceof VariableBinding) {\n        const value = binding.value ? binding.value.source : '$implicit';\n        const valueSpan = binding.value ? moveParseSourceSpan(sourceSpan, binding.value.span) : undefined;\n        targetVars.push(new ParsedVariable(key, value, bindingSpan, keySpan, valueSpan));\n      } else if (binding.value) {\n        const srcSpan = isIvyAst ? bindingSpan : sourceSpan;\n        const valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);\n        this._parsePropertyAst(key, binding.value, false, srcSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n      } else {\n        targetMatchableAttrs.push([key, '']);\n        this.parseLiteralAttr(key, null, keySpan, absoluteValueOffset, undefined, targetMatchableAttrs, targetProps, keySpan);\n      }\n    }\n  }\n  _parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset) {\n    try {\n      const bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);\n      bindingsResult.errors.forEach(e => this.errors.push(e));\n      bindingsResult.warnings.forEach(warning => {\n        this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);\n      });\n      return bindingsResult.templateBindings;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return [];\n    }\n  }\n  parseLiteralAttr(name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps, keySpan) {\n    if (isLegacyAnimationLabel(name)) {\n      name = name.substring(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n      }\n      if (value) {\n        this._reportError(`Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid.` + ` Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.`, sourceSpan, ParseErrorLevel.ERROR);\n      }\n      this._parseLegacyAnimation(name, value, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n    } else {\n      targetProps.push(new ParsedProperty(name, this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset), ParsedPropertyType.LITERAL_ATTR, sourceSpan, keySpan, valueSpan));\n    }\n  }\n  parsePropertyBinding(name, expression, isHost, isPartOfAssignmentBinding, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps, keySpan) {\n    if (name.length === 0) {\n      this._reportError(`Property name is missing in binding`, sourceSpan);\n    }\n    let isLegacyAnimationProp = false;\n    if (name.startsWith(LEGACY_ANIMATE_PROP_PREFIX)) {\n      isLegacyAnimationProp = true;\n      name = name.substring(LEGACY_ANIMATE_PROP_PREFIX.length);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + LEGACY_ANIMATE_PROP_PREFIX.length, keySpan.end.offset));\n      }\n    } else if (isLegacyAnimationLabel(name)) {\n      isLegacyAnimationProp = true;\n      name = name.substring(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n      }\n    }\n    if (isLegacyAnimationProp) {\n      this._parseLegacyAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n    } else if (name.startsWith(`${ANIMATE_PREFIX}${PROPERTY_PARTS_SEPARATOR}`)) {\n      this._parseAnimation(name, this.parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset), sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n    } else {\n      this._parsePropertyAst(name, this.parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset), isPartOfAssignmentBinding, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n    }\n  }\n  parsePropertyInterpolation(name, value, sourceSpan, valueSpan, targetMatchableAttrs, targetProps, keySpan, interpolatedTokens) {\n    const expr = this.parseInterpolation(value, valueSpan || sourceSpan, interpolatedTokens);\n    if (expr) {\n      this._parsePropertyAst(name, expr, false, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n      return true;\n    }\n    return false;\n  }\n  _parsePropertyAst(name, ast, isPartOfAssignmentBinding, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps) {\n    targetMatchableAttrs.push([name, ast.source]);\n    targetProps.push(new ParsedProperty(name, ast, isPartOfAssignmentBinding ? ParsedPropertyType.TWO_WAY : ParsedPropertyType.DEFAULT, sourceSpan, keySpan, valueSpan));\n  }\n  _parseAnimation(name, ast, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps) {\n    targetMatchableAttrs.push([name, ast.source]);\n    targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan, keySpan, valueSpan));\n  }\n  _parseLegacyAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps) {\n    if (name.length === 0) {\n      this._reportError('Animation trigger is missing', sourceSpan);\n    }\n    const ast = this.parseBinding(expression || 'undefined', false, valueSpan || sourceSpan, absoluteOffset);\n    targetMatchableAttrs.push([name, ast.source]);\n    targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.LEGACY_ANIMATION, sourceSpan, keySpan, valueSpan));\n  }\n  parseBinding(value, isHostBinding, sourceSpan, absoluteOffset) {\n    try {\n      const ast = isHostBinding ? this._exprParser.parseSimpleBinding(value, sourceSpan, absoluteOffset) : this._exprParser.parseBinding(value, sourceSpan, absoluteOffset);\n      if (ast) {\n        this.errors.push(...ast.errors);\n      }\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n    }\n  }\n  createBoundElementProperty(elementSelector, boundProp, skipValidation = false, mapPropertyName = true) {\n    if (boundProp.isLegacyAnimation) {\n      return new BoundElementProperty(boundProp.name, BindingType.LegacyAnimation, SecurityContext.NONE, boundProp.expression, null, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n    }\n    let unit = null;\n    let bindingType = undefined;\n    let boundPropertyName = null;\n    const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n    let securityContexts = undefined;\n    if (parts.length > 1) {\n      if (parts[0] == ATTRIBUTE_PREFIX) {\n        boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);\n        if (!skipValidation) {\n          this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n        }\n        securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);\n        const nsSeparatorIdx = boundPropertyName.indexOf(':');\n        if (nsSeparatorIdx > -1) {\n          const ns = boundPropertyName.substring(0, nsSeparatorIdx);\n          const name = boundPropertyName.substring(nsSeparatorIdx + 1);\n          boundPropertyName = mergeNsAndName(ns, name);\n        }\n        bindingType = BindingType.Attribute;\n      } else if (parts[0] == CLASS_PREFIX) {\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Class;\n        securityContexts = [SecurityContext.NONE];\n      } else if (parts[0] == STYLE_PREFIX) {\n        unit = parts.length > 2 ? parts[2] : null;\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Style;\n        securityContexts = [SecurityContext.STYLE];\n      } else if (parts[0] == ANIMATE_PREFIX) {\n        boundPropertyName = boundProp.name;\n        bindingType = BindingType.Animation;\n        securityContexts = [SecurityContext.NONE];\n      }\n    }\n    if (boundPropertyName === null) {\n      const mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);\n      boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;\n      securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, mappedPropName, false);\n      bindingType = boundProp.type === ParsedPropertyType.TWO_WAY ? BindingType.TwoWay : BindingType.Property;\n      if (!skipValidation) {\n        this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);\n      }\n    }\n    return new BoundElementProperty(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n  }\n  parseEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {\n    if (name.length === 0) {\n      this._reportError(`Event name is missing in binding`, sourceSpan);\n    }\n    if (isLegacyAnimationLabel(name)) {\n      name = name.slice(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n      }\n      this._parseLegacyAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents, keySpan);\n    } else {\n      this._parseRegularEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan);\n    }\n  }\n  calcPossibleSecurityContexts(selector, propName, isAttribute) {\n    const prop = this._schemaRegistry.getMappedPropName(propName);\n    return calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);\n  }\n  parseEventListenerName(rawName) {\n    const [target, eventName] = splitAtColon(rawName, [null, rawName]);\n    return {\n      eventName: eventName,\n      target\n    };\n  }\n  parseLegacyAnimationEventName(rawName) {\n    const matches = splitAtPeriod(rawName, [rawName, null]);\n    return {\n      eventName: matches[0],\n      phase: matches[1] === null ? null : matches[1].toLowerCase()\n    };\n  }\n  _parseLegacyAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents, keySpan) {\n    const {\n      eventName,\n      phase\n    } = this.parseLegacyAnimationEventName(name);\n    const ast = this._parseAction(expression, handlerSpan);\n    targetEvents.push(new ParsedEvent(eventName, phase, ParsedEventType.LegacyAnimation, ast, sourceSpan, handlerSpan, keySpan));\n    if (eventName.length === 0) {\n      this._reportError(`Animation event name is missing in binding`, sourceSpan);\n    }\n    if (phase) {\n      if (phase !== 'start' && phase !== 'done') {\n        this._reportError(`The provided animation output phase value \"${phase}\" for \"@${eventName}\" is not supported (use start or done)`, sourceSpan);\n      }\n    } else {\n      this._reportError(`The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`, sourceSpan);\n    }\n  }\n  _parseRegularEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {\n    const {\n      eventName,\n      target\n    } = this.parseEventListenerName(name);\n    const prevErrorCount = this.errors.length;\n    const ast = this._parseAction(expression, handlerSpan);\n    const isValid = this.errors.length === prevErrorCount;\n    targetMatchableAttrs.push([name, ast.source]);\n    if (isAssignmentEvent && isValid && !this._isAllowedAssignmentEvent(ast)) {\n      this._reportError('Unsupported expression in a two-way binding', sourceSpan);\n    }\n    let eventType = ParsedEventType.Regular;\n    if (isAssignmentEvent) {\n      eventType = ParsedEventType.TwoWay;\n    }\n    if (name.startsWith(`${ANIMATE_PREFIX}${PROPERTY_PARTS_SEPARATOR}`)) {\n      eventType = ParsedEventType.Animation;\n    }\n    targetEvents.push(new ParsedEvent(eventName, target, eventType, ast, sourceSpan, handlerSpan, keySpan));\n  }\n  _parseAction(value, sourceSpan) {\n    const absoluteOffset = sourceSpan && sourceSpan.start ? sourceSpan.start.offset : 0;\n    try {\n      const ast = this._exprParser.parseAction(value, sourceSpan, absoluteOffset);\n      if (ast) {\n        this.errors.push(...ast.errors);\n      }\n      if (!ast || ast.ast instanceof EmptyExpr$1) {\n        this._reportError(`Empty expressions are not allowed`, sourceSpan);\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n      }\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n    }\n  }\n  _reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {\n    this.errors.push(new ParseError(sourceSpan, message, level));\n  }\n  _validatePropertyOrAttributeName(propName, sourceSpan, isAttr) {\n    const report = isAttr ? this._schemaRegistry.validateAttribute(propName) : this._schemaRegistry.validateProperty(propName);\n    if (report.error) {\n      this._reportError(report.msg, sourceSpan, ParseErrorLevel.ERROR);\n    }\n  }\n  _isAllowedAssignmentEvent(ast) {\n    if (ast instanceof ASTWithSource) {\n      return this._isAllowedAssignmentEvent(ast.ast);\n    }\n    if (ast instanceof NonNullAssert) {\n      return this._isAllowedAssignmentEvent(ast.expression);\n    }\n    if (ast instanceof Call && ast.args.length === 1 && ast.receiver instanceof PropertyRead && ast.receiver.name === '$any' && ast.receiver.receiver instanceof ImplicitReceiver && !(ast.receiver.receiver instanceof ThisReceiver)) {\n      return this._isAllowedAssignmentEvent(ast.args[0]);\n    }\n    if (ast instanceof PropertyRead || ast instanceof KeyedRead) {\n      if (!hasRecursiveSafeReceiver(ast)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\nfunction hasRecursiveSafeReceiver(ast) {\n  if (ast instanceof SafePropertyRead || ast instanceof SafeKeyedRead) {\n    return true;\n  }\n  if (ast instanceof ParenthesizedExpression) {\n    return hasRecursiveSafeReceiver(ast.expression);\n  }\n  if (ast instanceof PropertyRead || ast instanceof KeyedRead || ast instanceof Call) {\n    return hasRecursiveSafeReceiver(ast.receiver);\n  }\n  return false;\n}\nfunction isLegacyAnimationLabel(name) {\n  return name[0] == '@';\n}\nfunction calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {\n  let ctxs;\n  const nameToContext = elName => registry.securityContext(elName, propName, isAttribute);\n  if (selector === null) {\n    ctxs = registry.allKnownElementNames().map(nameToContext);\n  } else {\n    ctxs = [];\n    CssSelector.parse(selector).forEach(selector => {\n      const elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n      const notElementNames = new Set(selector.notSelectors.filter(selector => selector.isElementSelector()).map(selector => selector.element));\n      const possibleElementNames = elementNames.filter(elName => !notElementNames.has(elName));\n      ctxs.push(...possibleElementNames.map(nameToContext));\n    });\n  }\n  return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n}\nfunction moveParseSourceSpan(sourceSpan, absoluteSpan) {\n  const startDiff = absoluteSpan.start - sourceSpan.start.offset;\n  const endDiff = absoluteSpan.end - sourceSpan.end.offset;\n  return new ParseSourceSpan(sourceSpan.start.moveBy(startDiff), sourceSpan.end.moveBy(endDiff), sourceSpan.fullStart.moveBy(startDiff), sourceSpan.details);\n}\nfunction isStyleUrlResolvable(url) {\n  if (url == null || url.length === 0 || url[0] == '/') return false;\n  const schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);\n  return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';\n}\nconst URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;\nconst NG_CONTENT_SELECT_ATTR = 'select';\nconst LINK_ELEMENT = 'link';\nconst LINK_STYLE_REL_ATTR = 'rel';\nconst LINK_STYLE_HREF_ATTR = 'href';\nconst LINK_STYLE_REL_VALUE = 'stylesheet';\nconst STYLE_ELEMENT = 'style';\nconst SCRIPT_ELEMENT = 'script';\nconst NG_NON_BINDABLE_ATTR = 'ngNonBindable';\nconst NG_PROJECT_AS = 'ngProjectAs';\nfunction preparseElement(ast) {\n  let selectAttr = null;\n  let hrefAttr = null;\n  let relAttr = null;\n  let nonBindable = false;\n  let projectAs = '';\n  ast.attrs.forEach(attr => {\n    const lcAttrName = attr.name.toLowerCase();\n    if (lcAttrName == NG_CONTENT_SELECT_ATTR) {\n      selectAttr = attr.value;\n    } else if (lcAttrName == LINK_STYLE_HREF_ATTR) {\n      hrefAttr = attr.value;\n    } else if (lcAttrName == LINK_STYLE_REL_ATTR) {\n      relAttr = attr.value;\n    } else if (attr.name == NG_NON_BINDABLE_ATTR) {\n      nonBindable = true;\n    } else if (attr.name == NG_PROJECT_AS) {\n      if (attr.value.length > 0) {\n        projectAs = attr.value;\n      }\n    }\n  });\n  selectAttr = normalizeNgContentSelect(selectAttr);\n  const nodeName = ast.name.toLowerCase();\n  let type = PreparsedElementType.OTHER;\n  if (isNgContent(nodeName)) {\n    type = PreparsedElementType.NG_CONTENT;\n  } else if (nodeName == STYLE_ELEMENT) {\n    type = PreparsedElementType.STYLE;\n  } else if (nodeName == SCRIPT_ELEMENT) {\n    type = PreparsedElementType.SCRIPT;\n  } else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {\n    type = PreparsedElementType.STYLESHEET;\n  }\n  return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);\n}\nvar PreparsedElementType;\n(function (PreparsedElementType) {\n  PreparsedElementType[PreparsedElementType[\"NG_CONTENT\"] = 0] = \"NG_CONTENT\";\n  PreparsedElementType[PreparsedElementType[\"STYLE\"] = 1] = \"STYLE\";\n  PreparsedElementType[PreparsedElementType[\"STYLESHEET\"] = 2] = \"STYLESHEET\";\n  PreparsedElementType[PreparsedElementType[\"SCRIPT\"] = 3] = \"SCRIPT\";\n  PreparsedElementType[PreparsedElementType[\"OTHER\"] = 4] = \"OTHER\";\n})(PreparsedElementType || (PreparsedElementType = {}));\nclass PreparsedElement {\n  type;\n  selectAttr;\n  hrefAttr;\n  nonBindable;\n  projectAs;\n  constructor(type, selectAttr, hrefAttr, nonBindable, projectAs) {\n    this.type = type;\n    this.selectAttr = selectAttr;\n    this.hrefAttr = hrefAttr;\n    this.nonBindable = nonBindable;\n    this.projectAs = projectAs;\n  }\n}\nfunction normalizeNgContentSelect(selectAttr) {\n  if (selectAttr === null || selectAttr.length === 0) {\n    return '*';\n  }\n  return selectAttr;\n}\nconst FOR_LOOP_EXPRESSION_PATTERN = /^\\s*([0-9A-Za-z_$]*)\\s+of\\s+([\\S\\s]*)/;\nconst FOR_LOOP_TRACK_PATTERN = /^track\\s+([\\S\\s]*)/;\nconst CONDITIONAL_ALIAS_PATTERN = /^(as\\s+)(.*)/;\nconst ELSE_IF_PATTERN = /^else[^\\S\\r\\n]+if/;\nconst FOR_LOOP_LET_PATTERN = /^let\\s+([\\S\\s]*)/;\nconst IDENTIFIER_PATTERN = /^[$A-Z_][0-9A-Z_$]*$/i;\nconst CHARACTERS_IN_SURROUNDING_WHITESPACE_PATTERN = /(\\s*)(\\S+)(\\s*)/;\nconst ALLOWED_FOR_LOOP_LET_VARIABLES = new Set(['$index', '$first', '$last', '$even', '$odd', '$count']);\nfunction isConnectedForLoopBlock(name) {\n  return name === 'empty';\n}\nfunction isConnectedIfLoopBlock(name) {\n  return name === 'else' || ELSE_IF_PATTERN.test(name);\n}\nfunction createIfBlock(ast, connectedBlocks, visitor, bindingParser) {\n  const errors = validateIfConnectedBlocks(connectedBlocks);\n  const branches = [];\n  const mainBlockParams = parseConditionalBlockParameters(ast, errors, bindingParser);\n  if (mainBlockParams !== null) {\n    branches.push(new IfBlockBranch(mainBlockParams.expression, visitAll(visitor, ast.children, ast.children), mainBlockParams.expressionAlias, ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan, ast.nameSpan, ast.i18n));\n  }\n  for (const block of connectedBlocks) {\n    if (ELSE_IF_PATTERN.test(block.name)) {\n      const params = parseConditionalBlockParameters(block, errors, bindingParser);\n      if (params !== null) {\n        const children = visitAll(visitor, block.children, block.children);\n        branches.push(new IfBlockBranch(params.expression, children, params.expressionAlias, block.sourceSpan, block.startSourceSpan, block.endSourceSpan, block.nameSpan, block.i18n));\n      }\n    } else if (block.name === 'else') {\n      const children = visitAll(visitor, block.children, block.children);\n      branches.push(new IfBlockBranch(null, children, null, block.sourceSpan, block.startSourceSpan, block.endSourceSpan, block.nameSpan, block.i18n));\n    }\n  }\n  const ifBlockStartSourceSpan = branches.length > 0 ? branches[0].startSourceSpan : ast.startSourceSpan;\n  const ifBlockEndSourceSpan = branches.length > 0 ? branches[branches.length - 1].endSourceSpan : ast.endSourceSpan;\n  let wholeSourceSpan = ast.sourceSpan;\n  const lastBranch = branches[branches.length - 1];\n  if (lastBranch !== undefined) {\n    wholeSourceSpan = new ParseSourceSpan(ifBlockStartSourceSpan.start, lastBranch.sourceSpan.end);\n  }\n  return {\n    node: new IfBlock(branches, wholeSourceSpan, ast.startSourceSpan, ifBlockEndSourceSpan, ast.nameSpan),\n    errors\n  };\n}\nfunction createForLoop(ast, connectedBlocks, visitor, bindingParser) {\n  const errors = [];\n  const params = parseForLoopParameters(ast, errors, bindingParser);\n  let node = null;\n  let empty = null;\n  for (const block of connectedBlocks) {\n    if (block.name === 'empty') {\n      if (empty !== null) {\n        errors.push(new ParseError(block.sourceSpan, '@for loop can only have one @empty block'));\n      } else if (block.parameters.length > 0) {\n        errors.push(new ParseError(block.sourceSpan, '@empty block cannot have parameters'));\n      } else {\n        empty = new ForLoopBlockEmpty(visitAll(visitor, block.children, block.children), block.sourceSpan, block.startSourceSpan, block.endSourceSpan, block.nameSpan, block.i18n);\n      }\n    } else {\n      errors.push(new ParseError(block.sourceSpan, `Unrecognized @for loop block \"${block.name}\"`));\n    }\n  }\n  if (params !== null) {\n    if (params.trackBy === null) {\n      errors.push(new ParseError(ast.startSourceSpan, '@for loop must have a \"track\" expression'));\n    } else {\n      const endSpan = empty?.endSourceSpan ?? ast.endSourceSpan;\n      const sourceSpan = new ParseSourceSpan(ast.sourceSpan.start, endSpan?.end ?? ast.sourceSpan.end);\n      validateTrackByExpression(params.trackBy.expression, params.trackBy.keywordSpan, errors);\n      node = new ForLoopBlock(params.itemName, params.expression, params.trackBy.expression, params.trackBy.keywordSpan, params.context, visitAll(visitor, ast.children, ast.children), empty, sourceSpan, ast.sourceSpan, ast.startSourceSpan, endSpan, ast.nameSpan, ast.i18n);\n    }\n  }\n  return {\n    node,\n    errors\n  };\n}\nfunction createSwitchBlock(ast, visitor, bindingParser) {\n  const errors = validateSwitchBlock(ast);\n  const primaryExpression = ast.parameters.length > 0 ? parseBlockParameterToBinding(ast.parameters[0], bindingParser) : bindingParser.parseBinding('', false, ast.sourceSpan, 0);\n  const cases = [];\n  const unknownBlocks = [];\n  let defaultCase = null;\n  for (const node of ast.children) {\n    if (!(node instanceof Block)) {\n      continue;\n    }\n    if ((node.name !== 'case' || node.parameters.length === 0) && node.name !== 'default') {\n      unknownBlocks.push(new UnknownBlock(node.name, node.sourceSpan, node.nameSpan));\n      continue;\n    }\n    const expression = node.name === 'case' ? parseBlockParameterToBinding(node.parameters[0], bindingParser) : null;\n    const ast = new SwitchBlockCase(expression, visitAll(visitor, node.children, node.children), node.sourceSpan, node.startSourceSpan, node.endSourceSpan, node.nameSpan, node.i18n);\n    if (expression === null) {\n      defaultCase = ast;\n    } else {\n      cases.push(ast);\n    }\n  }\n  if (defaultCase !== null) {\n    cases.push(defaultCase);\n  }\n  return {\n    node: new SwitchBlock(primaryExpression, cases, unknownBlocks, ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan, ast.nameSpan),\n    errors\n  };\n}\nfunction parseForLoopParameters(block, errors, bindingParser) {\n  if (block.parameters.length === 0) {\n    errors.push(new ParseError(block.startSourceSpan, '@for loop does not have an expression'));\n    return null;\n  }\n  const [expressionParam, ...secondaryParams] = block.parameters;\n  const match = stripOptionalParentheses(expressionParam, errors)?.match(FOR_LOOP_EXPRESSION_PATTERN);\n  if (!match || match[2].trim().length === 0) {\n    errors.push(new ParseError(expressionParam.sourceSpan, 'Cannot parse expression. @for loop expression must match the pattern \"<identifier> of <expression>\"'));\n    return null;\n  }\n  const [, itemName, rawExpression] = match;\n  if (ALLOWED_FOR_LOOP_LET_VARIABLES.has(itemName)) {\n    errors.push(new ParseError(expressionParam.sourceSpan, `@for loop item name cannot be one of ${Array.from(ALLOWED_FOR_LOOP_LET_VARIABLES).join(', ')}.`));\n  }\n  const variableName = expressionParam.expression.split(' ')[0];\n  const variableSpan = new ParseSourceSpan(expressionParam.sourceSpan.start, expressionParam.sourceSpan.start.moveBy(variableName.length));\n  const result = {\n    itemName: new Variable(itemName, '$implicit', variableSpan, variableSpan),\n    trackBy: null,\n    expression: parseBlockParameterToBinding(expressionParam, bindingParser, rawExpression),\n    context: Array.from(ALLOWED_FOR_LOOP_LET_VARIABLES, variableName => {\n      const emptySpanAfterForBlockStart = new ParseSourceSpan(block.startSourceSpan.end, block.startSourceSpan.end);\n      return new Variable(variableName, variableName, emptySpanAfterForBlockStart, emptySpanAfterForBlockStart);\n    })\n  };\n  for (const param of secondaryParams) {\n    const letMatch = param.expression.match(FOR_LOOP_LET_PATTERN);\n    if (letMatch !== null) {\n      const variablesSpan = new ParseSourceSpan(param.sourceSpan.start.moveBy(letMatch[0].length - letMatch[1].length), param.sourceSpan.end);\n      parseLetParameter(param.sourceSpan, letMatch[1], variablesSpan, itemName, result.context, errors);\n      continue;\n    }\n    const trackMatch = param.expression.match(FOR_LOOP_TRACK_PATTERN);\n    if (trackMatch !== null) {\n      if (result.trackBy !== null) {\n        errors.push(new ParseError(param.sourceSpan, '@for loop can only have one \"track\" expression'));\n      } else {\n        const expression = parseBlockParameterToBinding(param, bindingParser, trackMatch[1]);\n        if (expression.ast instanceof EmptyExpr$1) {\n          errors.push(new ParseError(block.startSourceSpan, '@for loop must have a \"track\" expression'));\n        }\n        const keywordSpan = new ParseSourceSpan(param.sourceSpan.start, param.sourceSpan.start.moveBy('track'.length));\n        result.trackBy = {\n          expression,\n          keywordSpan\n        };\n      }\n      continue;\n    }\n    errors.push(new ParseError(param.sourceSpan, `Unrecognized @for loop parameter \"${param.expression}\"`));\n  }\n  return result;\n}\nfunction validateTrackByExpression(expression, parseSourceSpan, errors) {\n  const visitor = new PipeVisitor();\n  expression.ast.visit(visitor);\n  if (visitor.hasPipe) {\n    errors.push(new ParseError(parseSourceSpan, 'Cannot use pipes in track expressions'));\n  }\n}\nfunction parseLetParameter(sourceSpan, expression, span, loopItemName, context, errors) {\n  const parts = expression.split(',');\n  let startSpan = span.start;\n  for (const part of parts) {\n    const expressionParts = part.split('=');\n    const name = expressionParts.length === 2 ? expressionParts[0].trim() : '';\n    const variableName = expressionParts.length === 2 ? expressionParts[1].trim() : '';\n    if (name.length === 0 || variableName.length === 0) {\n      errors.push(new ParseError(sourceSpan, `Invalid @for loop \"let\" parameter. Parameter should match the pattern \"<name> = <variable name>\"`));\n    } else if (!ALLOWED_FOR_LOOP_LET_VARIABLES.has(variableName)) {\n      errors.push(new ParseError(sourceSpan, `Unknown \"let\" parameter variable \"${variableName}\". The allowed variables are: ${Array.from(ALLOWED_FOR_LOOP_LET_VARIABLES).join(', ')}`));\n    } else if (name === loopItemName) {\n      errors.push(new ParseError(sourceSpan, `Invalid @for loop \"let\" parameter. Variable cannot be called \"${loopItemName}\"`));\n    } else if (context.some(v => v.name === name)) {\n      errors.push(new ParseError(sourceSpan, `Duplicate \"let\" parameter variable \"${variableName}\"`));\n    } else {\n      const [, keyLeadingWhitespace, keyName] = expressionParts[0].match(CHARACTERS_IN_SURROUNDING_WHITESPACE_PATTERN) ?? [];\n      const keySpan = keyLeadingWhitespace !== undefined && expressionParts.length === 2 ? new ParseSourceSpan(startSpan.moveBy(keyLeadingWhitespace.length), startSpan.moveBy(keyLeadingWhitespace.length + keyName.length)) : span;\n      let valueSpan = undefined;\n      if (expressionParts.length === 2) {\n        const [, valueLeadingWhitespace, implicit] = expressionParts[1].match(CHARACTERS_IN_SURROUNDING_WHITESPACE_PATTERN) ?? [];\n        valueSpan = valueLeadingWhitespace !== undefined ? new ParseSourceSpan(startSpan.moveBy(expressionParts[0].length + 1 + valueLeadingWhitespace.length), startSpan.moveBy(expressionParts[0].length + 1 + valueLeadingWhitespace.length + implicit.length)) : undefined;\n      }\n      const sourceSpan = new ParseSourceSpan(keySpan.start, valueSpan?.end ?? keySpan.end);\n      context.push(new Variable(name, variableName, sourceSpan, keySpan, valueSpan));\n    }\n    startSpan = startSpan.moveBy(part.length + 1);\n  }\n}\nfunction validateIfConnectedBlocks(connectedBlocks) {\n  const errors = [];\n  let hasElse = false;\n  for (let i = 0; i < connectedBlocks.length; i++) {\n    const block = connectedBlocks[i];\n    if (block.name === 'else') {\n      if (hasElse) {\n        errors.push(new ParseError(block.startSourceSpan, 'Conditional can only have one @else block'));\n      } else if (connectedBlocks.length > 1 && i < connectedBlocks.length - 1) {\n        errors.push(new ParseError(block.startSourceSpan, '@else block must be last inside the conditional'));\n      } else if (block.parameters.length > 0) {\n        errors.push(new ParseError(block.startSourceSpan, '@else block cannot have parameters'));\n      }\n      hasElse = true;\n    } else if (!ELSE_IF_PATTERN.test(block.name)) {\n      errors.push(new ParseError(block.startSourceSpan, `Unrecognized conditional block @${block.name}`));\n    }\n  }\n  return errors;\n}\nfunction validateSwitchBlock(ast) {\n  const errors = [];\n  let hasDefault = false;\n  if (ast.parameters.length !== 1) {\n    errors.push(new ParseError(ast.startSourceSpan, '@switch block must have exactly one parameter'));\n    return errors;\n  }\n  for (const node of ast.children) {\n    if (node instanceof Comment || node instanceof Text && node.value.trim().length === 0) {\n      continue;\n    }\n    if (!(node instanceof Block) || node.name !== 'case' && node.name !== 'default') {\n      errors.push(new ParseError(node.sourceSpan, '@switch block can only contain @case and @default blocks'));\n      continue;\n    }\n    if (node.name === 'default') {\n      if (hasDefault) {\n        errors.push(new ParseError(node.startSourceSpan, '@switch block can only have one @default block'));\n      } else if (node.parameters.length > 0) {\n        errors.push(new ParseError(node.startSourceSpan, '@default block cannot have parameters'));\n      }\n      hasDefault = true;\n    } else if (node.name === 'case' && node.parameters.length !== 1) {\n      errors.push(new ParseError(node.startSourceSpan, '@case block must have exactly one parameter'));\n    }\n  }\n  return errors;\n}\nfunction parseBlockParameterToBinding(ast, bindingParser, part) {\n  let start;\n  let end;\n  if (typeof part === 'string') {\n    start = Math.max(0, ast.expression.lastIndexOf(part));\n    end = start + part.length;\n  } else {\n    start = 0;\n    end = ast.expression.length;\n  }\n  return bindingParser.parseBinding(ast.expression.slice(start, end), false, ast.sourceSpan, ast.sourceSpan.start.offset + start);\n}\nfunction parseConditionalBlockParameters(block, errors, bindingParser) {\n  if (block.parameters.length === 0) {\n    errors.push(new ParseError(block.startSourceSpan, 'Conditional block does not have an expression'));\n    return null;\n  }\n  const expression = parseBlockParameterToBinding(block.parameters[0], bindingParser);\n  let expressionAlias = null;\n  for (let i = 1; i < block.parameters.length; i++) {\n    const param = block.parameters[i];\n    const aliasMatch = param.expression.match(CONDITIONAL_ALIAS_PATTERN);\n    if (aliasMatch === null) {\n      errors.push(new ParseError(param.sourceSpan, `Unrecognized conditional parameter \"${param.expression}\"`));\n    } else if (block.name !== 'if' && !ELSE_IF_PATTERN.test(block.name)) {\n      errors.push(new ParseError(param.sourceSpan, '\"as\" expression is only allowed on `@if` and `@else if` blocks'));\n    } else if (expressionAlias !== null) {\n      errors.push(new ParseError(param.sourceSpan, 'Conditional can only have one \"as\" expression'));\n    } else {\n      const name = aliasMatch[2].trim();\n      if (IDENTIFIER_PATTERN.test(name)) {\n        const variableStart = param.sourceSpan.start.moveBy(aliasMatch[1].length);\n        const variableSpan = new ParseSourceSpan(variableStart, variableStart.moveBy(name.length));\n        expressionAlias = new Variable(name, name, variableSpan, variableSpan);\n      } else {\n        errors.push(new ParseError(param.sourceSpan, '\"as\" expression must be a valid JavaScript identifier'));\n      }\n    }\n  }\n  return {\n    expression,\n    expressionAlias\n  };\n}\nfunction stripOptionalParentheses(param, errors) {\n  const expression = param.expression;\n  const spaceRegex = /^\\s$/;\n  let openParens = 0;\n  let start = 0;\n  let end = expression.length - 1;\n  for (let i = 0; i < expression.length; i++) {\n    const char = expression[i];\n    if (char === '(') {\n      start = i + 1;\n      openParens++;\n    } else if (spaceRegex.test(char)) {\n      continue;\n    } else {\n      break;\n    }\n  }\n  if (openParens === 0) {\n    return expression;\n  }\n  for (let i = expression.length - 1; i > -1; i--) {\n    const char = expression[i];\n    if (char === ')') {\n      end = i;\n      openParens--;\n      if (openParens === 0) {\n        break;\n      }\n    } else if (spaceRegex.test(char)) {\n      continue;\n    } else {\n      break;\n    }\n  }\n  if (openParens !== 0) {\n    errors.push(new ParseError(param.sourceSpan, 'Unclosed parentheses in expression'));\n    return null;\n  }\n  return expression.slice(start, end);\n}\nclass PipeVisitor extends RecursiveAstVisitor {\n  hasPipe = false;\n  visitPipe() {\n    this.hasPipe = true;\n  }\n}\nconst TIME_PATTERN = /^\\d+\\.?\\d*(ms|s)?$/;\nconst SEPARATOR_PATTERN = /^\\s$/;\nconst COMMA_DELIMITED_SYNTAX = new Map([[$LBRACE, $RBRACE], [$LBRACKET, $RBRACKET], [$LPAREN, $RPAREN]]);\nvar OnTriggerType;\n(function (OnTriggerType) {\n  OnTriggerType[\"IDLE\"] = \"idle\";\n  OnTriggerType[\"TIMER\"] = \"timer\";\n  OnTriggerType[\"INTERACTION\"] = \"interaction\";\n  OnTriggerType[\"IMMEDIATE\"] = \"immediate\";\n  OnTriggerType[\"HOVER\"] = \"hover\";\n  OnTriggerType[\"VIEWPORT\"] = \"viewport\";\n  OnTriggerType[\"NEVER\"] = \"never\";\n})(OnTriggerType || (OnTriggerType = {}));\nfunction parseNeverTrigger({\n  expression,\n  sourceSpan\n}, triggers, errors) {\n  const neverIndex = expression.indexOf('never');\n  const neverSourceSpan = new ParseSourceSpan(sourceSpan.start.moveBy(neverIndex), sourceSpan.start.moveBy(neverIndex + 'never'.length));\n  const prefetchSpan = getPrefetchSpan(expression, sourceSpan);\n  const hydrateSpan = getHydrateSpan(expression, sourceSpan);\n  if (neverIndex === -1) {\n    errors.push(new ParseError(sourceSpan, `Could not find \"never\" keyword in expression`));\n  } else {\n    trackTrigger('never', triggers, errors, new NeverDeferredTrigger(neverSourceSpan, sourceSpan, prefetchSpan, null, hydrateSpan));\n  }\n}\nfunction parseWhenTrigger({\n  expression,\n  sourceSpan\n}, bindingParser, triggers, errors) {\n  const whenIndex = expression.indexOf('when');\n  const whenSourceSpan = new ParseSourceSpan(sourceSpan.start.moveBy(whenIndex), sourceSpan.start.moveBy(whenIndex + 'when'.length));\n  const prefetchSpan = getPrefetchSpan(expression, sourceSpan);\n  const hydrateSpan = getHydrateSpan(expression, sourceSpan);\n  if (whenIndex === -1) {\n    errors.push(new ParseError(sourceSpan, `Could not find \"when\" keyword in expression`));\n  } else {\n    const start = getTriggerParametersStart(expression, whenIndex + 1);\n    const parsed = bindingParser.parseBinding(expression.slice(start), false, sourceSpan, sourceSpan.start.offset + start);\n    trackTrigger('when', triggers, errors, new BoundDeferredTrigger(parsed, sourceSpan, prefetchSpan, whenSourceSpan, hydrateSpan));\n  }\n}\nfunction parseOnTrigger({\n  expression,\n  sourceSpan\n}, bindingParser, triggers, errors, placeholder) {\n  const onIndex = expression.indexOf('on');\n  const onSourceSpan = new ParseSourceSpan(sourceSpan.start.moveBy(onIndex), sourceSpan.start.moveBy(onIndex + 'on'.length));\n  const prefetchSpan = getPrefetchSpan(expression, sourceSpan);\n  const hydrateSpan = getHydrateSpan(expression, sourceSpan);\n  if (onIndex === -1) {\n    errors.push(new ParseError(sourceSpan, `Could not find \"on\" keyword in expression`));\n  } else {\n    const start = getTriggerParametersStart(expression, onIndex + 1);\n    const isHydrationTrigger = expression.startsWith('hydrate');\n    const parser = new OnTriggerParser(expression, bindingParser, start, sourceSpan, triggers, errors, isHydrationTrigger ? validateHydrateReferenceBasedTrigger : validatePlainReferenceBasedTrigger, isHydrationTrigger, prefetchSpan, onSourceSpan, hydrateSpan);\n    parser.parse();\n  }\n}\nfunction getPrefetchSpan(expression, sourceSpan) {\n  if (!expression.startsWith('prefetch')) {\n    return null;\n  }\n  return new ParseSourceSpan(sourceSpan.start, sourceSpan.start.moveBy('prefetch'.length));\n}\nfunction getHydrateSpan(expression, sourceSpan) {\n  if (!expression.startsWith('hydrate')) {\n    return null;\n  }\n  return new ParseSourceSpan(sourceSpan.start, sourceSpan.start.moveBy('hydrate'.length));\n}\nclass OnTriggerParser {\n  expression;\n  bindingParser;\n  start;\n  span;\n  triggers;\n  errors;\n  validator;\n  isHydrationTrigger;\n  prefetchSpan;\n  onSourceSpan;\n  hydrateSpan;\n  index = 0;\n  tokens;\n  constructor(expression, bindingParser, start, span, triggers, errors, validator, isHydrationTrigger, prefetchSpan, onSourceSpan, hydrateSpan) {\n    this.expression = expression;\n    this.bindingParser = bindingParser;\n    this.start = start;\n    this.span = span;\n    this.triggers = triggers;\n    this.errors = errors;\n    this.validator = validator;\n    this.isHydrationTrigger = isHydrationTrigger;\n    this.prefetchSpan = prefetchSpan;\n    this.onSourceSpan = onSourceSpan;\n    this.hydrateSpan = hydrateSpan;\n    this.tokens = new Lexer().tokenize(expression.slice(start));\n  }\n  parse() {\n    while (this.tokens.length > 0 && this.index < this.tokens.length) {\n      const token = this.token();\n      if (!token.isIdentifier()) {\n        this.unexpectedToken(token);\n        break;\n      }\n      if (this.isFollowedByOrLast($COMMA)) {\n        this.consumeTrigger(token, []);\n        this.advance();\n      } else if (this.isFollowedByOrLast($LPAREN)) {\n        this.advance();\n        const prevErrors = this.errors.length;\n        const parameters = this.consumeParameters();\n        if (this.errors.length !== prevErrors) {\n          break;\n        }\n        this.consumeTrigger(token, parameters);\n        this.advance();\n      } else if (this.index < this.tokens.length - 1) {\n        this.unexpectedToken(this.tokens[this.index + 1]);\n      }\n      this.advance();\n    }\n  }\n  advance() {\n    this.index++;\n  }\n  isFollowedByOrLast(char) {\n    if (this.index === this.tokens.length - 1) {\n      return true;\n    }\n    return this.tokens[this.index + 1].isCharacter(char);\n  }\n  token() {\n    return this.tokens[Math.min(this.index, this.tokens.length - 1)];\n  }\n  consumeTrigger(identifier, parameters) {\n    const triggerNameStartSpan = this.span.start.moveBy(this.start + identifier.index - this.tokens[0].index);\n    const nameSpan = new ParseSourceSpan(triggerNameStartSpan, triggerNameStartSpan.moveBy(identifier.strValue.length));\n    const endSpan = triggerNameStartSpan.moveBy(this.token().end - identifier.index);\n    const isFirstTrigger = identifier.index === 0;\n    const onSourceSpan = isFirstTrigger ? this.onSourceSpan : null;\n    const prefetchSourceSpan = isFirstTrigger ? this.prefetchSpan : null;\n    const hydrateSourceSpan = isFirstTrigger ? this.hydrateSpan : null;\n    const sourceSpan = new ParseSourceSpan(isFirstTrigger ? this.span.start : triggerNameStartSpan, endSpan);\n    try {\n      switch (identifier.toString()) {\n        case OnTriggerType.IDLE:\n          this.trackTrigger('idle', createIdleTrigger(parameters, nameSpan, sourceSpan, prefetchSourceSpan, onSourceSpan, hydrateSourceSpan));\n          break;\n        case OnTriggerType.TIMER:\n          this.trackTrigger('timer', createTimerTrigger(parameters, nameSpan, sourceSpan, this.prefetchSpan, this.onSourceSpan, this.hydrateSpan));\n          break;\n        case OnTriggerType.INTERACTION:\n          this.trackTrigger('interaction', createInteractionTrigger(parameters, nameSpan, sourceSpan, this.prefetchSpan, this.onSourceSpan, this.hydrateSpan, this.validator));\n          break;\n        case OnTriggerType.IMMEDIATE:\n          this.trackTrigger('immediate', createImmediateTrigger(parameters, nameSpan, sourceSpan, this.prefetchSpan, this.onSourceSpan, this.hydrateSpan));\n          break;\n        case OnTriggerType.HOVER:\n          this.trackTrigger('hover', createHoverTrigger(parameters, nameSpan, sourceSpan, this.prefetchSpan, this.onSourceSpan, this.hydrateSpan, this.validator));\n          break;\n        case OnTriggerType.VIEWPORT:\n          this.trackTrigger('viewport', createViewportTrigger(this.start, this.isHydrationTrigger, this.bindingParser, parameters, nameSpan, sourceSpan, this.prefetchSpan, this.onSourceSpan, this.hydrateSpan, this.validator));\n          break;\n        default:\n          throw new Error(`Unrecognized trigger type \"${identifier}\"`);\n      }\n    } catch (e) {\n      this.error(identifier, e.message);\n    }\n  }\n  consumeParameters() {\n    const parameters = [];\n    if (!this.token().isCharacter($LPAREN)) {\n      this.unexpectedToken(this.token());\n      return parameters;\n    }\n    this.advance();\n    const commaDelimStack = [];\n    let tokens = [];\n    while (this.index < this.tokens.length) {\n      const token = this.token();\n      if (token.isCharacter($RPAREN) && commaDelimStack.length === 0) {\n        if (tokens.length) {\n          parameters.push({\n            expression: this.tokenRangeText(tokens),\n            start: tokens[0].index\n          });\n        }\n        break;\n      }\n      if (token.type === TokenType.Character && COMMA_DELIMITED_SYNTAX.has(token.numValue)) {\n        commaDelimStack.push(COMMA_DELIMITED_SYNTAX.get(token.numValue));\n      }\n      if (commaDelimStack.length > 0 && token.isCharacter(commaDelimStack[commaDelimStack.length - 1])) {\n        commaDelimStack.pop();\n      }\n      if (commaDelimStack.length === 0 && token.isCharacter($COMMA) && tokens.length > 0) {\n        parameters.push({\n          expression: this.tokenRangeText(tokens),\n          start: tokens[0].index\n        });\n        this.advance();\n        tokens = [];\n        continue;\n      }\n      tokens.push(token);\n      this.advance();\n    }\n    if (!this.token().isCharacter($RPAREN) || commaDelimStack.length > 0) {\n      this.error(this.token(), 'Unexpected end of expression');\n    }\n    if (this.index < this.tokens.length - 1 && !this.tokens[this.index + 1].isCharacter($COMMA)) {\n      this.unexpectedToken(this.tokens[this.index + 1]);\n    }\n    return parameters;\n  }\n  tokenRangeText(tokens) {\n    if (tokens.length === 0) {\n      return '';\n    }\n    return this.expression.slice(this.start + tokens[0].index, this.start + tokens[tokens.length - 1].end);\n  }\n  trackTrigger(name, trigger) {\n    trackTrigger(name, this.triggers, this.errors, trigger);\n  }\n  error(token, message) {\n    const newStart = this.span.start.moveBy(this.start + token.index);\n    const newEnd = newStart.moveBy(token.end - token.index);\n    this.errors.push(new ParseError(new ParseSourceSpan(newStart, newEnd), message));\n  }\n  unexpectedToken(token) {\n    this.error(token, `Unexpected token \"${token}\"`);\n  }\n}\nfunction trackTrigger(name, allTriggers, errors, trigger) {\n  if (allTriggers[name]) {\n    errors.push(new ParseError(trigger.sourceSpan, `Duplicate \"${name}\" trigger is not allowed`));\n  } else {\n    allTriggers[name] = trigger;\n  }\n}\nfunction createIdleTrigger(parameters, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan) {\n  if (parameters.length > 0) {\n    throw new Error(`\"${OnTriggerType.IDLE}\" trigger cannot have parameters`);\n  }\n  return new IdleDeferredTrigger(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n}\nfunction createTimerTrigger(parameters, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan) {\n  if (parameters.length !== 1) {\n    throw new Error(`\"${OnTriggerType.TIMER}\" trigger must have exactly one parameter`);\n  }\n  const delay = parseDeferredTime(parameters[0].expression);\n  if (delay === null) {\n    throw new Error(`Could not parse time value of trigger \"${OnTriggerType.TIMER}\"`);\n  }\n  return new TimerDeferredTrigger(delay, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n}\nfunction createImmediateTrigger(parameters, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan) {\n  if (parameters.length > 0) {\n    throw new Error(`\"${OnTriggerType.IMMEDIATE}\" trigger cannot have parameters`);\n  }\n  return new ImmediateDeferredTrigger(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n}\nfunction createHoverTrigger(parameters, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan, validator) {\n  validator(OnTriggerType.HOVER, parameters);\n  return new HoverDeferredTrigger(parameters[0]?.expression ?? null, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n}\nfunction createInteractionTrigger(parameters, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan, validator) {\n  validator(OnTriggerType.INTERACTION, parameters);\n  return new InteractionDeferredTrigger(parameters[0]?.expression ?? null, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n}\nfunction createViewportTrigger(start, isHydrationTrigger, bindingParser, parameters, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan, validator) {\n  validator(OnTriggerType.VIEWPORT, parameters);\n  let reference;\n  let options;\n  if (parameters.length === 0) {\n    reference = options = null;\n  } else if (!parameters[0].expression.startsWith('{')) {\n    reference = parameters[0].expression;\n    options = null;\n  } else {\n    const parsed = bindingParser.parseBinding(parameters[0].expression, false, sourceSpan, sourceSpan.start.offset + start + parameters[0].start);\n    if (!(parsed.ast instanceof LiteralMap)) {\n      throw new Error('Options parameter of the \"viewport\" trigger must be an object literal');\n    } else if (parsed.ast.keys.some(key => key.key === 'root')) {\n      throw new Error('The \"root\" option is not supported in the options parameter of the \"viewport\" trigger');\n    }\n    const triggerIndex = parsed.ast.keys.findIndex(key => key.key === 'trigger');\n    if (triggerIndex === -1) {\n      reference = null;\n      options = parsed.ast;\n    } else {\n      const value = parsed.ast.values[triggerIndex];\n      const triggerFilter = (_, index) => index !== triggerIndex;\n      if (!(value instanceof PropertyRead) || !(value.receiver instanceof ImplicitReceiver) || value.receiver instanceof ThisReceiver) {\n        throw new Error(`\"trigger\" option of the \"viewport\" trigger must be an identifier`);\n      }\n      reference = value.name;\n      options = new LiteralMap(parsed.ast.span, parsed.ast.sourceSpan, parsed.ast.keys.filter(triggerFilter), parsed.ast.values.filter(triggerFilter));\n    }\n  }\n  if (isHydrationTrigger && reference !== null) {\n    throw new Error(`\"viewport\" hydration trigger cannot have a \"trigger\"`);\n  } else if (options) {\n    const dynamicNode = DynamicAstValidator.findDynamicNode(options);\n    if (dynamicNode !== null) {\n      throw new Error(`Options of the \"viewport\" trigger must be an object ` + `literal containing only literal values, but \"${dynamicNode.constructor.name}\" was found`);\n    }\n  }\n  return new ViewportDeferredTrigger(reference, options, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n}\nfunction validatePlainReferenceBasedTrigger(type, parameters) {\n  if (parameters.length > 1) {\n    throw new Error(`\"${type}\" trigger can only have zero or one parameters`);\n  }\n}\nfunction validateHydrateReferenceBasedTrigger(type, parameters) {\n  if (type === OnTriggerType.VIEWPORT) {\n    if (parameters.length > 1) {\n      throw new Error(`Hydration trigger \"${type}\" cannot have more than one parameter`);\n    }\n    return;\n  }\n  if (parameters.length > 0) {\n    throw new Error(`Hydration trigger \"${type}\" cannot have parameters`);\n  }\n}\nfunction getTriggerParametersStart(value, startPosition = 0) {\n  let hasFoundSeparator = false;\n  for (let i = startPosition; i < value.length; i++) {\n    if (SEPARATOR_PATTERN.test(value[i])) {\n      hasFoundSeparator = true;\n    } else if (hasFoundSeparator) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction parseDeferredTime(value) {\n  const match = value.match(TIME_PATTERN);\n  if (!match) {\n    return null;\n  }\n  const [time, units] = match;\n  return parseFloat(time) * (units === 's' ? 1000 : 1);\n}\nclass DynamicAstValidator extends RecursiveAstVisitor {\n  dynamicNode = null;\n  static findDynamicNode(ast) {\n    const visitor = new DynamicAstValidator();\n    visitor.visit(ast);\n    return visitor.dynamicNode;\n  }\n  visit(ast) {\n    if (!(ast instanceof ASTWithSource) && !(ast instanceof LiteralPrimitive) && !(ast instanceof LiteralArray) && !(ast instanceof LiteralMap)) {\n      this.dynamicNode = ast;\n    } else {\n      super.visit(ast);\n    }\n  }\n}\nconst PREFETCH_WHEN_PATTERN = /^prefetch\\s+when\\s/;\nconst PREFETCH_ON_PATTERN = /^prefetch\\s+on\\s/;\nconst HYDRATE_WHEN_PATTERN = /^hydrate\\s+when\\s/;\nconst HYDRATE_ON_PATTERN = /^hydrate\\s+on\\s/;\nconst HYDRATE_NEVER_PATTERN = /^hydrate\\s+never(\\s*)$/;\nconst MINIMUM_PARAMETER_PATTERN = /^minimum\\s/;\nconst AFTER_PARAMETER_PATTERN = /^after\\s/;\nconst WHEN_PARAMETER_PATTERN = /^when\\s/;\nconst ON_PARAMETER_PATTERN = /^on\\s/;\nfunction isConnectedDeferLoopBlock(name) {\n  return name === 'placeholder' || name === 'loading' || name === 'error';\n}\nfunction createDeferredBlock(ast, connectedBlocks, visitor, bindingParser) {\n  const errors = [];\n  const {\n    placeholder,\n    loading,\n    error\n  } = parseConnectedBlocks(connectedBlocks, errors, visitor);\n  const {\n    triggers,\n    prefetchTriggers,\n    hydrateTriggers\n  } = parsePrimaryTriggers(ast, bindingParser, errors);\n  let lastEndSourceSpan = ast.endSourceSpan;\n  let endOfLastSourceSpan = ast.sourceSpan.end;\n  if (connectedBlocks.length > 0) {\n    const lastConnectedBlock = connectedBlocks[connectedBlocks.length - 1];\n    lastEndSourceSpan = lastConnectedBlock.endSourceSpan;\n    endOfLastSourceSpan = lastConnectedBlock.sourceSpan.end;\n  }\n  const sourceSpanWithConnectedBlocks = new ParseSourceSpan(ast.sourceSpan.start, endOfLastSourceSpan);\n  const node = new DeferredBlock(visitAll(visitor, ast.children, ast.children), triggers, prefetchTriggers, hydrateTriggers, placeholder, loading, error, ast.nameSpan, sourceSpanWithConnectedBlocks, ast.sourceSpan, ast.startSourceSpan, lastEndSourceSpan, ast.i18n);\n  return {\n    node,\n    errors\n  };\n}\nfunction parseConnectedBlocks(connectedBlocks, errors, visitor) {\n  let placeholder = null;\n  let loading = null;\n  let error = null;\n  for (const block of connectedBlocks) {\n    try {\n      if (!isConnectedDeferLoopBlock(block.name)) {\n        errors.push(new ParseError(block.startSourceSpan, `Unrecognized block \"@${block.name}\"`));\n        break;\n      }\n      switch (block.name) {\n        case 'placeholder':\n          if (placeholder !== null) {\n            errors.push(new ParseError(block.startSourceSpan, `@defer block can only have one @placeholder block`));\n          } else {\n            placeholder = parsePlaceholderBlock(block, visitor);\n          }\n          break;\n        case 'loading':\n          if (loading !== null) {\n            errors.push(new ParseError(block.startSourceSpan, `@defer block can only have one @loading block`));\n          } else {\n            loading = parseLoadingBlock(block, visitor);\n          }\n          break;\n        case 'error':\n          if (error !== null) {\n            errors.push(new ParseError(block.startSourceSpan, `@defer block can only have one @error block`));\n          } else {\n            error = parseErrorBlock(block, visitor);\n          }\n          break;\n      }\n    } catch (e) {\n      errors.push(new ParseError(block.startSourceSpan, e.message));\n    }\n  }\n  return {\n    placeholder,\n    loading,\n    error\n  };\n}\nfunction parsePlaceholderBlock(ast, visitor) {\n  let minimumTime = null;\n  for (const param of ast.parameters) {\n    if (MINIMUM_PARAMETER_PATTERN.test(param.expression)) {\n      if (minimumTime != null) {\n        throw new Error(`@placeholder block can only have one \"minimum\" parameter`);\n      }\n      const parsedTime = parseDeferredTime(param.expression.slice(getTriggerParametersStart(param.expression)));\n      if (parsedTime === null) {\n        throw new Error(`Could not parse time value of parameter \"minimum\"`);\n      }\n      minimumTime = parsedTime;\n    } else {\n      throw new Error(`Unrecognized parameter in @placeholder block: \"${param.expression}\"`);\n    }\n  }\n  return new DeferredBlockPlaceholder(visitAll(visitor, ast.children, ast.children), minimumTime, ast.nameSpan, ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan, ast.i18n);\n}\nfunction parseLoadingBlock(ast, visitor) {\n  let afterTime = null;\n  let minimumTime = null;\n  for (const param of ast.parameters) {\n    if (AFTER_PARAMETER_PATTERN.test(param.expression)) {\n      if (afterTime != null) {\n        throw new Error(`@loading block can only have one \"after\" parameter`);\n      }\n      const parsedTime = parseDeferredTime(param.expression.slice(getTriggerParametersStart(param.expression)));\n      if (parsedTime === null) {\n        throw new Error(`Could not parse time value of parameter \"after\"`);\n      }\n      afterTime = parsedTime;\n    } else if (MINIMUM_PARAMETER_PATTERN.test(param.expression)) {\n      if (minimumTime != null) {\n        throw new Error(`@loading block can only have one \"minimum\" parameter`);\n      }\n      const parsedTime = parseDeferredTime(param.expression.slice(getTriggerParametersStart(param.expression)));\n      if (parsedTime === null) {\n        throw new Error(`Could not parse time value of parameter \"minimum\"`);\n      }\n      minimumTime = parsedTime;\n    } else {\n      throw new Error(`Unrecognized parameter in @loading block: \"${param.expression}\"`);\n    }\n  }\n  return new DeferredBlockLoading(visitAll(visitor, ast.children, ast.children), afterTime, minimumTime, ast.nameSpan, ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan, ast.i18n);\n}\nfunction parseErrorBlock(ast, visitor) {\n  if (ast.parameters.length > 0) {\n    throw new Error(`@error block cannot have parameters`);\n  }\n  return new DeferredBlockError(visitAll(visitor, ast.children, ast.children), ast.nameSpan, ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan, ast.i18n);\n}\nfunction parsePrimaryTriggers(ast, bindingParser, errors, placeholder) {\n  const triggers = {};\n  const prefetchTriggers = {};\n  const hydrateTriggers = {};\n  for (const param of ast.parameters) {\n    if (WHEN_PARAMETER_PATTERN.test(param.expression)) {\n      parseWhenTrigger(param, bindingParser, triggers, errors);\n    } else if (ON_PARAMETER_PATTERN.test(param.expression)) {\n      parseOnTrigger(param, bindingParser, triggers, errors);\n    } else if (PREFETCH_WHEN_PATTERN.test(param.expression)) {\n      parseWhenTrigger(param, bindingParser, prefetchTriggers, errors);\n    } else if (PREFETCH_ON_PATTERN.test(param.expression)) {\n      parseOnTrigger(param, bindingParser, prefetchTriggers, errors);\n    } else if (HYDRATE_WHEN_PATTERN.test(param.expression)) {\n      parseWhenTrigger(param, bindingParser, hydrateTriggers, errors);\n    } else if (HYDRATE_ON_PATTERN.test(param.expression)) {\n      parseOnTrigger(param, bindingParser, hydrateTriggers, errors);\n    } else if (HYDRATE_NEVER_PATTERN.test(param.expression)) {\n      parseNeverTrigger(param, hydrateTriggers, errors);\n    } else {\n      errors.push(new ParseError(param.sourceSpan, 'Unrecognized trigger'));\n    }\n  }\n  if (hydrateTriggers.never && Object.keys(hydrateTriggers).length > 1) {\n    errors.push(new ParseError(ast.startSourceSpan, 'Cannot specify additional `hydrate` triggers if `hydrate never` is present'));\n  }\n  return {\n    triggers,\n    prefetchTriggers,\n    hydrateTriggers\n  };\n}\nconst BIND_NAME_REGEXP = /^(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*)$/;\nconst KW_BIND_IDX = 1;\nconst KW_LET_IDX = 2;\nconst KW_REF_IDX = 3;\nconst KW_ON_IDX = 4;\nconst KW_BINDON_IDX = 5;\nconst KW_AT_IDX = 6;\nconst IDENT_KW_IDX = 7;\nconst BINDING_DELIMS = {\n  BANANA_BOX: {\n    start: '[(',\n    end: ')]'\n  },\n  PROPERTY: {\n    start: '[',\n    end: ']'\n  },\n  EVENT: {\n    start: '(',\n    end: ')'\n  }\n};\nconst TEMPLATE_ATTR_PREFIX = '*';\nconst UNSUPPORTED_SELECTORLESS_TAGS = new Set(['link', 'style', 'script', 'ng-template', 'ng-container', 'ng-content']);\nconst UNSUPPORTED_SELECTORLESS_DIRECTIVE_ATTRS = new Set(['ngProjectAs', 'ngNonBindable']);\nfunction htmlAstToRender3Ast(htmlNodes, bindingParser, options) {\n  const transformer = new HtmlAstToIvyAst(bindingParser, options);\n  const ivyNodes = visitAll(transformer, htmlNodes, htmlNodes);\n  const allErrors = bindingParser.errors.concat(transformer.errors);\n  const result = {\n    nodes: ivyNodes,\n    errors: allErrors,\n    styleUrls: transformer.styleUrls,\n    styles: transformer.styles,\n    ngContentSelectors: transformer.ngContentSelectors\n  };\n  if (options.collectCommentNodes) {\n    result.commentNodes = transformer.commentNodes;\n  }\n  return result;\n}\nclass HtmlAstToIvyAst {\n  bindingParser;\n  options;\n  errors = [];\n  styles = [];\n  styleUrls = [];\n  ngContentSelectors = [];\n  commentNodes = [];\n  inI18nBlock = false;\n  processedNodes = new Set();\n  constructor(bindingParser, options) {\n    this.bindingParser = bindingParser;\n    this.options = options;\n  }\n  visitElement(element) {\n    const isI18nRootElement = isI18nRootNode(element.i18n);\n    if (isI18nRootElement) {\n      if (this.inI18nBlock) {\n        this.reportError('Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.', element.sourceSpan);\n      }\n      this.inI18nBlock = true;\n    }\n    const preparsedElement = preparseElement(element);\n    if (preparsedElement.type === PreparsedElementType.SCRIPT) {\n      return null;\n    } else if (preparsedElement.type === PreparsedElementType.STYLE) {\n      const contents = textContents(element);\n      if (contents !== null) {\n        this.styles.push(contents);\n      }\n      return null;\n    } else if (preparsedElement.type === PreparsedElementType.STYLESHEET && isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n      this.styleUrls.push(preparsedElement.hrefAttr);\n      return null;\n    }\n    const isTemplateElement = isNgTemplate(element.name);\n    const {\n      attributes,\n      boundEvents,\n      references,\n      variables,\n      templateVariables,\n      elementHasInlineTemplate,\n      parsedProperties,\n      templateParsedProperties,\n      i18nAttrsMeta\n    } = this.prepareAttributes(element.attrs, isTemplateElement);\n    const directives = this.extractDirectives(element);\n    let children;\n    if (preparsedElement.nonBindable) {\n      children = visitAll(NON_BINDABLE_VISITOR, element.children).flat(Infinity);\n    } else {\n      children = visitAll(this, element.children, element.children);\n    }\n    let parsedElement;\n    if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n      const selector = preparsedElement.selectAttr;\n      const attrs = element.attrs.map(attr => this.visitAttribute(attr));\n      parsedElement = new Content(selector, attrs, children, element.isSelfClosing, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n      this.ngContentSelectors.push(selector);\n    } else if (isTemplateElement) {\n      const attrs = this.categorizePropertyAttributes(element.name, parsedProperties, i18nAttrsMeta);\n      parsedElement = new Template(element.name, attributes, attrs.bound, boundEvents, directives, [], children, references, variables, element.isSelfClosing, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n    } else {\n      const attrs = this.categorizePropertyAttributes(element.name, parsedProperties, i18nAttrsMeta);\n      if (element.name === 'ng-container') {\n        for (const bound of attrs.bound) {\n          if (bound.type === BindingType.Attribute) {\n            this.reportError(`Attribute bindings are not supported on ng-container. Use property bindings instead.`, bound.sourceSpan);\n          }\n        }\n      }\n      parsedElement = new Element$1(element.name, attributes, attrs.bound, boundEvents, directives, children, references, element.isSelfClosing, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.isVoid, element.i18n);\n    }\n    if (elementHasInlineTemplate) {\n      parsedElement = this.wrapInTemplate(parsedElement, templateParsedProperties, templateVariables, i18nAttrsMeta, isTemplateElement, isI18nRootElement);\n    }\n    if (isI18nRootElement) {\n      this.inI18nBlock = false;\n    }\n    return parsedElement;\n  }\n  visitAttribute(attribute) {\n    return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);\n  }\n  visitText(text) {\n    return this.processedNodes.has(text) ? null : this._visitTextWithInterpolation(text.value, text.sourceSpan, text.tokens, text.i18n);\n  }\n  visitExpansion(expansion) {\n    if (!expansion.i18n) {\n      return null;\n    }\n    if (!isI18nRootNode(expansion.i18n)) {\n      throw new Error(`Invalid type \"${expansion.i18n.constructor}\" for \"i18n\" property of ${expansion.sourceSpan.toString()}. Expected a \"Message\"`);\n    }\n    const message = expansion.i18n;\n    const vars = {};\n    const placeholders = {};\n    Object.keys(message.placeholders).forEach(key => {\n      const value = message.placeholders[key];\n      if (key.startsWith(I18N_ICU_VAR_PREFIX)) {\n        const formattedKey = key.trim();\n        const ast = this.bindingParser.parseInterpolationExpression(value.text, value.sourceSpan);\n        vars[formattedKey] = new BoundText(ast, value.sourceSpan);\n      } else {\n        placeholders[key] = this._visitTextWithInterpolation(value.text, value.sourceSpan, null);\n      }\n    });\n    return new Icu$1(vars, placeholders, expansion.sourceSpan, message);\n  }\n  visitExpansionCase(expansionCase) {\n    return null;\n  }\n  visitComment(comment) {\n    if (this.options.collectCommentNodes) {\n      this.commentNodes.push(new Comment$1(comment.value || '', comment.sourceSpan));\n    }\n    return null;\n  }\n  visitLetDeclaration(decl, context) {\n    const value = this.bindingParser.parseBinding(decl.value, false, decl.valueSpan, decl.valueSpan.start.offset);\n    if (value.errors.length === 0 && value.ast instanceof EmptyExpr$1) {\n      this.reportError('@let declaration value cannot be empty', decl.valueSpan);\n    }\n    return new LetDeclaration$1(decl.name, value, decl.sourceSpan, decl.nameSpan, decl.valueSpan);\n  }\n  visitComponent(component) {\n    const isI18nRootElement = isI18nRootNode(component.i18n);\n    if (isI18nRootElement) {\n      if (this.inI18nBlock) {\n        this.reportError('Cannot mark a component as translatable inside of a translatable section. Please remove the nested i18n marker.', component.sourceSpan);\n      }\n      this.inI18nBlock = true;\n    }\n    if (component.tagName !== null && UNSUPPORTED_SELECTORLESS_TAGS.has(component.tagName)) {\n      this.reportError(`Tag name \"${component.tagName}\" cannot be used as a component tag`, component.startSourceSpan);\n      return null;\n    }\n    const {\n      attributes,\n      boundEvents,\n      references,\n      templateVariables,\n      elementHasInlineTemplate,\n      parsedProperties,\n      templateParsedProperties,\n      i18nAttrsMeta\n    } = this.prepareAttributes(component.attrs, false);\n    this.validateSelectorlessReferences(references);\n    const directives = this.extractDirectives(component);\n    let children;\n    if (component.attrs.find(attr => attr.name === 'ngNonBindable')) {\n      children = visitAll(NON_BINDABLE_VISITOR, component.children).flat(Infinity);\n    } else {\n      children = visitAll(this, component.children, component.children);\n    }\n    const attrs = this.categorizePropertyAttributes(component.tagName, parsedProperties, i18nAttrsMeta);\n    let node = new Component$1(component.componentName, component.tagName, component.fullName, attributes, attrs.bound, boundEvents, directives, children, references, component.isSelfClosing, component.sourceSpan, component.startSourceSpan, component.endSourceSpan, component.i18n);\n    if (elementHasInlineTemplate) {\n      node = this.wrapInTemplate(node, templateParsedProperties, templateVariables, i18nAttrsMeta, false, isI18nRootElement);\n    }\n    if (isI18nRootElement) {\n      this.inI18nBlock = false;\n    }\n    return node;\n  }\n  visitDirective() {\n    return null;\n  }\n  visitBlockParameter() {\n    return null;\n  }\n  visitBlock(block, context) {\n    const index = Array.isArray(context) ? context.indexOf(block) : -1;\n    if (index === -1) {\n      throw new Error('Visitor invoked incorrectly. Expecting visitBlock to be invoked siblings array as its context');\n    }\n    if (this.processedNodes.has(block)) {\n      return null;\n    }\n    let result = null;\n    switch (block.name) {\n      case 'defer':\n        result = createDeferredBlock(block, this.findConnectedBlocks(index, context, isConnectedDeferLoopBlock), this, this.bindingParser);\n        break;\n      case 'switch':\n        result = createSwitchBlock(block, this, this.bindingParser);\n        break;\n      case 'for':\n        result = createForLoop(block, this.findConnectedBlocks(index, context, isConnectedForLoopBlock), this, this.bindingParser);\n        break;\n      case 'if':\n        result = createIfBlock(block, this.findConnectedBlocks(index, context, isConnectedIfLoopBlock), this, this.bindingParser);\n        break;\n      default:\n        let errorMessage;\n        if (isConnectedDeferLoopBlock(block.name)) {\n          errorMessage = `@${block.name} block can only be used after an @defer block.`;\n          this.processedNodes.add(block);\n        } else if (isConnectedForLoopBlock(block.name)) {\n          errorMessage = `@${block.name} block can only be used after an @for block.`;\n          this.processedNodes.add(block);\n        } else if (isConnectedIfLoopBlock(block.name)) {\n          errorMessage = `@${block.name} block can only be used after an @if or @else if block.`;\n          this.processedNodes.add(block);\n        } else {\n          errorMessage = `Unrecognized block @${block.name}.`;\n        }\n        result = {\n          node: new UnknownBlock(block.name, block.sourceSpan, block.nameSpan),\n          errors: [new ParseError(block.sourceSpan, errorMessage)]\n        };\n        break;\n    }\n    this.errors.push(...result.errors);\n    return result.node;\n  }\n  findConnectedBlocks(primaryBlockIndex, siblings, predicate) {\n    const relatedBlocks = [];\n    for (let i = primaryBlockIndex + 1; i < siblings.length; i++) {\n      const node = siblings[i];\n      if (node instanceof Comment) {\n        continue;\n      }\n      if (node instanceof Text && node.value.trim().length === 0) {\n        this.processedNodes.add(node);\n        continue;\n      }\n      if (!(node instanceof Block) || !predicate(node.name)) {\n        break;\n      }\n      relatedBlocks.push(node);\n      this.processedNodes.add(node);\n    }\n    return relatedBlocks;\n  }\n  categorizePropertyAttributes(elementName, properties, i18nPropsMeta) {\n    const bound = [];\n    const literal = [];\n    properties.forEach(prop => {\n      const i18n = i18nPropsMeta[prop.name];\n      if (prop.isLiteral) {\n        literal.push(new TextAttribute(prop.name, prop.expression.source || '', prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n));\n      } else {\n        const bep = this.bindingParser.createBoundElementProperty(elementName, prop, true, false);\n        bound.push(BoundAttribute.fromBoundElementProperty(bep, i18n));\n      }\n    });\n    return {\n      bound,\n      literal\n    };\n  }\n  prepareAttributes(attrs, isTemplateElement) {\n    const parsedProperties = [];\n    const boundEvents = [];\n    const variables = [];\n    const references = [];\n    const attributes = [];\n    const i18nAttrsMeta = {};\n    const templateParsedProperties = [];\n    const templateVariables = [];\n    let elementHasInlineTemplate = false;\n    for (const attribute of attrs) {\n      let hasBinding = false;\n      const normalizedName = normalizeAttributeName(attribute.name);\n      let isTemplateBinding = false;\n      if (attribute.i18n) {\n        i18nAttrsMeta[attribute.name] = attribute.i18n;\n      }\n      if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {\n        if (elementHasInlineTemplate) {\n          this.reportError(`Can't have multiple template bindings on one element. Use only one attribute prefixed with *`, attribute.sourceSpan);\n        }\n        isTemplateBinding = true;\n        elementHasInlineTemplate = true;\n        const templateValue = attribute.value;\n        const templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);\n        const parsedVariables = [];\n        const absoluteValueOffset = attribute.valueSpan ? attribute.valueSpan.fullStart.offset : attribute.sourceSpan.fullStart.offset + attribute.name.length;\n        this.bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attribute.sourceSpan, absoluteValueOffset, [], templateParsedProperties, parsedVariables, true);\n        templateVariables.push(...parsedVariables.map(v => new Variable(v.name, v.value, v.sourceSpan, v.keySpan, v.valueSpan)));\n      } else {\n        hasBinding = this.parseAttribute(isTemplateElement, attribute, [], parsedProperties, boundEvents, variables, references);\n      }\n      if (!hasBinding && !isTemplateBinding) {\n        attributes.push(this.visitAttribute(attribute));\n      }\n    }\n    return {\n      attributes,\n      boundEvents,\n      references,\n      variables,\n      templateVariables,\n      elementHasInlineTemplate,\n      parsedProperties,\n      templateParsedProperties,\n      i18nAttrsMeta\n    };\n  }\n  parseAttribute(isTemplateElement, attribute, matchableAttributes, parsedProperties, boundEvents, variables, references) {\n    const name = normalizeAttributeName(attribute.name);\n    const value = attribute.value;\n    const srcSpan = attribute.sourceSpan;\n    const absoluteOffset = attribute.valueSpan ? attribute.valueSpan.fullStart.offset : srcSpan.fullStart.offset;\n    function createKeySpan(srcSpan, prefix, identifier) {\n      const normalizationAdjustment = attribute.name.length - name.length;\n      const keySpanStart = srcSpan.start.moveBy(prefix.length + normalizationAdjustment);\n      const keySpanEnd = keySpanStart.moveBy(identifier.length);\n      return new ParseSourceSpan(keySpanStart, keySpanEnd, keySpanStart, identifier);\n    }\n    const bindParts = name.match(BIND_NAME_REGEXP);\n    if (bindParts) {\n      if (bindParts[KW_BIND_IDX] != null) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_BIND_IDX], identifier);\n        this.bindingParser.parsePropertyBinding(identifier, value, false, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n      } else if (bindParts[KW_LET_IDX]) {\n        if (isTemplateElement) {\n          const identifier = bindParts[IDENT_KW_IDX];\n          const keySpan = createKeySpan(srcSpan, bindParts[KW_LET_IDX], identifier);\n          this.parseVariable(identifier, value, srcSpan, keySpan, attribute.valueSpan, variables);\n        } else {\n          this.reportError(`\"let-\" is only supported on ng-template elements.`, srcSpan);\n        }\n      } else if (bindParts[KW_REF_IDX]) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_REF_IDX], identifier);\n        this.parseReference(identifier, value, srcSpan, keySpan, attribute.valueSpan, references);\n      } else if (bindParts[KW_ON_IDX]) {\n        const events = [];\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_ON_IDX], identifier);\n        this.bindingParser.parseEvent(identifier, value, false, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan);\n        addEvents(events, boundEvents);\n      } else if (bindParts[KW_BINDON_IDX]) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_BINDON_IDX], identifier);\n        this.bindingParser.parsePropertyBinding(identifier, value, false, true, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n        this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan, absoluteOffset);\n      } else if (bindParts[KW_AT_IDX]) {\n        const keySpan = createKeySpan(srcSpan, '', name);\n        this.bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n      }\n      return true;\n    }\n    let delims = null;\n    if (name.startsWith(BINDING_DELIMS.BANANA_BOX.start)) {\n      delims = BINDING_DELIMS.BANANA_BOX;\n    } else if (name.startsWith(BINDING_DELIMS.PROPERTY.start)) {\n      delims = BINDING_DELIMS.PROPERTY;\n    } else if (name.startsWith(BINDING_DELIMS.EVENT.start)) {\n      delims = BINDING_DELIMS.EVENT;\n    }\n    if (delims !== null && name.endsWith(delims.end) && name.length > delims.start.length + delims.end.length) {\n      const identifier = name.substring(delims.start.length, name.length - delims.end.length);\n      const keySpan = createKeySpan(srcSpan, delims.start, identifier);\n      if (delims.start === BINDING_DELIMS.BANANA_BOX.start) {\n        this.bindingParser.parsePropertyBinding(identifier, value, false, true, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n        this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan, absoluteOffset);\n      } else if (delims.start === BINDING_DELIMS.PROPERTY.start) {\n        this.bindingParser.parsePropertyBinding(identifier, value, false, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n      } else {\n        const events = [];\n        this.bindingParser.parseEvent(identifier, value, false, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan);\n        addEvents(events, boundEvents);\n      }\n      return true;\n    }\n    const keySpan = createKeySpan(srcSpan, '', name);\n    const hasBinding = this.bindingParser.parsePropertyInterpolation(name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan, attribute.valueTokens ?? null);\n    return hasBinding;\n  }\n  extractDirectives(node) {\n    const elementName = node instanceof Component ? node.tagName : node.name;\n    const directives = [];\n    const seenDirectives = new Set();\n    for (const directive of node.directives) {\n      let invalid = false;\n      for (const attr of directive.attrs) {\n        if (attr.name.startsWith(TEMPLATE_ATTR_PREFIX)) {\n          invalid = true;\n          this.reportError(`Shorthand template syntax \"${attr.name}\" is not supported inside a directive context`, attr.sourceSpan);\n        } else if (UNSUPPORTED_SELECTORLESS_DIRECTIVE_ATTRS.has(attr.name)) {\n          invalid = true;\n          this.reportError(`Attribute \"${attr.name}\" is not supported in a directive context`, attr.sourceSpan);\n        }\n      }\n      if (!invalid && seenDirectives.has(directive.name)) {\n        invalid = true;\n        this.reportError(`Cannot apply directive \"${directive.name}\" multiple times on the same element`, directive.sourceSpan);\n      }\n      if (invalid) {\n        continue;\n      }\n      const {\n        attributes,\n        parsedProperties,\n        boundEvents,\n        references,\n        i18nAttrsMeta\n      } = this.prepareAttributes(directive.attrs, false);\n      this.validateSelectorlessReferences(references);\n      const {\n        bound: inputs\n      } = this.categorizePropertyAttributes(elementName, parsedProperties, i18nAttrsMeta);\n      for (const input of inputs) {\n        if (input.type !== BindingType.Property && input.type !== BindingType.TwoWay) {\n          invalid = true;\n          this.reportError('Binding is not supported in a directive context', input.sourceSpan);\n        }\n      }\n      if (invalid) {\n        continue;\n      }\n      seenDirectives.add(directive.name);\n      directives.push(new Directive$1(directive.name, attributes, inputs, boundEvents, references, directive.sourceSpan, directive.startSourceSpan, directive.endSourceSpan, undefined));\n    }\n    return directives;\n  }\n  filterAnimationAttributes(attributes) {\n    return attributes.filter(a => !a.name.startsWith('animate.'));\n  }\n  filterAnimationInputs(attributes) {\n    return attributes.filter(a => a.type !== BindingType.Animation);\n  }\n  wrapInTemplate(node, templateProperties, templateVariables, i18nAttrsMeta, isTemplateElement, isI18nRootElement) {\n    const attrs = this.categorizePropertyAttributes('ng-template', templateProperties, i18nAttrsMeta);\n    const templateAttrs = [];\n    attrs.literal.forEach(attr => templateAttrs.push(attr));\n    attrs.bound.forEach(attr => templateAttrs.push(attr));\n    const hoistedAttrs = {\n      attributes: [],\n      inputs: [],\n      outputs: []\n    };\n    if (node instanceof Element$1 || node instanceof Component$1) {\n      hoistedAttrs.attributes.push(...this.filterAnimationAttributes(node.attributes));\n      hoistedAttrs.inputs.push(...this.filterAnimationInputs(node.inputs));\n      hoistedAttrs.outputs.push(...node.outputs);\n    }\n    const i18n = isTemplateElement && isI18nRootElement ? undefined : node.i18n;\n    let name;\n    if (node instanceof Component$1) {\n      name = node.tagName;\n    } else if (node instanceof Template) {\n      name = null;\n    } else {\n      name = node.name;\n    }\n    return new Template(name, hoistedAttrs.attributes, hoistedAttrs.inputs, hoistedAttrs.outputs, [], templateAttrs, [node], [], templateVariables, false, node.sourceSpan, node.startSourceSpan, node.endSourceSpan, i18n);\n  }\n  _visitTextWithInterpolation(value, sourceSpan, interpolatedTokens, i18n) {\n    const valueNoNgsp = replaceNgsp(value);\n    const expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan, interpolatedTokens);\n    return expr ? new BoundText(expr, sourceSpan, i18n) : new Text$3(valueNoNgsp, sourceSpan);\n  }\n  parseVariable(identifier, value, sourceSpan, keySpan, valueSpan, variables) {\n    if (identifier.indexOf('-') > -1) {\n      this.reportError(`\"-\" is not allowed in variable names`, sourceSpan);\n    } else if (identifier.length === 0) {\n      this.reportError(`Variable does not have a name`, sourceSpan);\n    }\n    variables.push(new Variable(identifier, value, sourceSpan, keySpan, valueSpan));\n  }\n  parseReference(identifier, value, sourceSpan, keySpan, valueSpan, references) {\n    if (identifier.indexOf('-') > -1) {\n      this.reportError(`\"-\" is not allowed in reference names`, sourceSpan);\n    } else if (identifier.length === 0) {\n      this.reportError(`Reference does not have a name`, sourceSpan);\n    } else if (references.some(reference => reference.name === identifier)) {\n      this.reportError(`Reference \"#${identifier}\" is defined more than once`, sourceSpan);\n    }\n    references.push(new Reference(identifier, value, sourceSpan, keySpan, valueSpan));\n  }\n  parseAssignmentEvent(name, expression, sourceSpan, valueSpan, targetMatchableAttrs, boundEvents, keySpan, absoluteOffset) {\n    const events = [];\n    this.bindingParser.parseEvent(`${name}Change`, expression, true, sourceSpan, valueSpan || sourceSpan, targetMatchableAttrs, events, keySpan);\n    addEvents(events, boundEvents);\n  }\n  validateSelectorlessReferences(references) {\n    if (references.length === 0) {\n      return;\n    }\n    const seenNames = new Set();\n    for (const ref of references) {\n      if (ref.value.length > 0) {\n        this.reportError('Cannot specify a value for a local reference in this context', ref.valueSpan || ref.sourceSpan);\n      } else if (seenNames.has(ref.name)) {\n        this.reportError('Duplicate reference names are not allowed', ref.sourceSpan);\n      } else {\n        seenNames.add(ref.name);\n      }\n    }\n  }\n  reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {\n    this.errors.push(new ParseError(sourceSpan, message, level));\n  }\n}\nclass NonBindableVisitor {\n  visitElement(ast) {\n    const preparsedElement = preparseElement(ast);\n    if (preparsedElement.type === PreparsedElementType.SCRIPT || preparsedElement.type === PreparsedElementType.STYLE || preparsedElement.type === PreparsedElementType.STYLESHEET) {\n      return null;\n    }\n    const children = visitAll(this, ast.children, null);\n    return new Element$1(ast.name, visitAll(this, ast.attrs), [], [], [], children, [], ast.isSelfClosing, ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan, ast.isVoid);\n  }\n  visitComment(comment) {\n    return null;\n  }\n  visitAttribute(attribute) {\n    return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);\n  }\n  visitText(text) {\n    return new Text$3(text.value, text.sourceSpan);\n  }\n  visitExpansion(expansion) {\n    return null;\n  }\n  visitExpansionCase(expansionCase) {\n    return null;\n  }\n  visitBlock(block, context) {\n    const nodes = [new Text$3(block.startSourceSpan.toString(), block.startSourceSpan), ...visitAll(this, block.children)];\n    if (block.endSourceSpan !== null) {\n      nodes.push(new Text$3(block.endSourceSpan.toString(), block.endSourceSpan));\n    }\n    return nodes;\n  }\n  visitBlockParameter(parameter, context) {\n    return null;\n  }\n  visitLetDeclaration(decl, context) {\n    return new Text$3(`@let ${decl.name} = ${decl.value};`, decl.sourceSpan);\n  }\n  visitComponent(ast, context) {\n    const children = visitAll(this, ast.children, null);\n    return new Element$1(ast.fullName, visitAll(this, ast.attrs), [], [], [], children, [], ast.isSelfClosing, ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan, false);\n  }\n  visitDirective(directive, context) {\n    return null;\n  }\n}\nconst NON_BINDABLE_VISITOR = new NonBindableVisitor();\nfunction normalizeAttributeName(attrName) {\n  return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n}\nfunction addEvents(events, boundEvents) {\n  boundEvents.push(...events.map(e => BoundEvent.fromParsedEvent(e)));\n}\nfunction textContents(node) {\n  if (node.children.length !== 1 || !(node.children[0] instanceof Text)) {\n    return null;\n  } else {\n    return node.children[0].value;\n  }\n}\nconst LEADING_TRIVIA_CHARS = [' ', '\\n', '\\r', '\\t'];\nfunction parseTemplate(template, templateUrl, options = {}) {\n  const {\n    preserveWhitespaces,\n    enableI18nLegacyMessageIdFormat\n  } = options;\n  const selectorlessEnabled = options.enableSelectorless ?? false;\n  const bindingParser = makeBindingParser(selectorlessEnabled);\n  const htmlParser = new HtmlParser();\n  const parseResult = htmlParser.parse(template, templateUrl, {\n    leadingTriviaChars: LEADING_TRIVIA_CHARS,\n    ...options,\n    tokenizeExpansionForms: true,\n    tokenizeBlocks: options.enableBlockSyntax ?? true,\n    tokenizeLet: options.enableLetSyntax ?? true,\n    selectorlessEnabled\n  });\n  if (!options.alwaysAttemptHtmlToR3AstConversion && parseResult.errors && parseResult.errors.length > 0) {\n    const parsedTemplate = {\n      preserveWhitespaces,\n      errors: parseResult.errors,\n      nodes: [],\n      styleUrls: [],\n      styles: [],\n      ngContentSelectors: []\n    };\n    if (options.collectCommentNodes) {\n      parsedTemplate.commentNodes = [];\n    }\n    return parsedTemplate;\n  }\n  let rootNodes = parseResult.rootNodes;\n  const retainEmptyTokens = !(options.preserveSignificantWhitespace ?? true);\n  const i18nMetaVisitor = new I18nMetaVisitor(!preserveWhitespaces, enableI18nLegacyMessageIdFormat, undefined, options.preserveSignificantWhitespace, retainEmptyTokens);\n  const i18nMetaResult = i18nMetaVisitor.visitAllWithErrors(rootNodes);\n  if (!options.alwaysAttemptHtmlToR3AstConversion && i18nMetaResult.errors && i18nMetaResult.errors.length > 0) {\n    const parsedTemplate = {\n      preserveWhitespaces,\n      errors: i18nMetaResult.errors,\n      nodes: [],\n      styleUrls: [],\n      styles: [],\n      ngContentSelectors: []\n    };\n    if (options.collectCommentNodes) {\n      parsedTemplate.commentNodes = [];\n    }\n    return parsedTemplate;\n  }\n  rootNodes = i18nMetaResult.rootNodes;\n  if (!preserveWhitespaces) {\n    rootNodes = visitAll(new WhitespaceVisitor(true, undefined, false), rootNodes);\n    if (i18nMetaVisitor.hasI18nMeta) {\n      rootNodes = visitAll(new I18nMetaVisitor(false, undefined, undefined, true, retainEmptyTokens), rootNodes);\n    }\n  }\n  const {\n    nodes,\n    errors,\n    styleUrls,\n    styles,\n    ngContentSelectors,\n    commentNodes\n  } = htmlAstToRender3Ast(rootNodes, bindingParser, {\n    collectCommentNodes: !!options.collectCommentNodes\n  });\n  errors.push(...parseResult.errors, ...i18nMetaResult.errors);\n  const parsedTemplate = {\n    preserveWhitespaces,\n    errors: errors.length > 0 ? errors : null,\n    nodes,\n    styleUrls,\n    styles,\n    ngContentSelectors\n  };\n  if (options.collectCommentNodes) {\n    parsedTemplate.commentNodes = commentNodes;\n  }\n  return parsedTemplate;\n}\nconst elementRegistry = new DomElementSchemaRegistry();\nfunction makeBindingParser(selectorlessEnabled = false) {\n  return new BindingParser(new Parser(new Lexer(), selectorlessEnabled), elementRegistry, []);\n}\nconst COMPONENT_VARIABLE = '%COMP%';\nconst HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\nconst CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\nfunction baseDirectiveFields(meta, constantPool, bindingParser) {\n  const definitionMap = new DefinitionMap();\n  const selectors = parseSelectorToR3Selector(meta.selector);\n  definitionMap.set('type', meta.type.value);\n  if (selectors.length > 0) {\n    definitionMap.set('selectors', asLiteral(selectors));\n  }\n  if (meta.queries.length > 0) {\n    definitionMap.set('contentQueries', createContentQueriesFunction(meta.queries, constantPool, meta.name));\n  }\n  if (meta.viewQueries.length) {\n    definitionMap.set('viewQuery', createViewQueriesFunction(meta.viewQueries, constantPool, meta.name));\n  }\n  definitionMap.set('hostBindings', createHostBindingsFunction(meta.host, meta.typeSourceSpan, bindingParser, constantPool, meta.selector || '', meta.name, definitionMap));\n  definitionMap.set('inputs', conditionallyCreateDirectiveBindingLiteral(meta.inputs, true));\n  definitionMap.set('outputs', conditionallyCreateDirectiveBindingLiteral(meta.outputs));\n  if (meta.exportAs !== null) {\n    definitionMap.set('exportAs', literalArr(meta.exportAs.map(e => literal(e))));\n  }\n  if (meta.isStandalone === false) {\n    definitionMap.set('standalone', literal(false));\n  }\n  if (meta.isSignal) {\n    definitionMap.set('signals', literal(true));\n  }\n  return definitionMap;\n}\nfunction addFeatures(definitionMap, meta) {\n  const features = [];\n  const providers = meta.providers;\n  const viewProviders = meta.viewProviders;\n  if (providers || viewProviders) {\n    const args = [providers || new LiteralArrayExpr([])];\n    if (viewProviders) {\n      args.push(viewProviders);\n    }\n    features.push(importExpr(Identifiers.ProvidersFeature).callFn(args));\n  }\n  if (meta.hostDirectives?.length) {\n    features.push(importExpr(Identifiers.HostDirectivesFeature).callFn([createHostDirectivesFeatureArg(meta.hostDirectives)]));\n  }\n  if (meta.usesInheritance) {\n    features.push(importExpr(Identifiers.InheritDefinitionFeature));\n  }\n  if (meta.lifecycle.usesOnChanges) {\n    features.push(importExpr(Identifiers.NgOnChangesFeature));\n  }\n  if ('externalStyles' in meta && meta.externalStyles?.length) {\n    const externalStyleNodes = meta.externalStyles.map(externalStyle => literal(externalStyle));\n    features.push(importExpr(Identifiers.ExternalStylesFeature).callFn([literalArr(externalStyleNodes)]));\n  }\n  if (features.length) {\n    definitionMap.set('features', literalArr(features));\n  }\n}\nfunction compileDirectiveFromMetadata(meta, constantPool, bindingParser) {\n  const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n  addFeatures(definitionMap, meta);\n  const expression = importExpr(Identifiers.defineDirective).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createDirectiveType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction compileComponentFromMetadata(meta, constantPool, bindingParser) {\n  const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n  addFeatures(definitionMap, meta);\n  const selector = meta.selector && CssSelector.parse(meta.selector);\n  const firstSelector = selector && selector[0];\n  if (firstSelector) {\n    const selectorAttributes = firstSelector.getAttrs();\n    if (selectorAttributes.length) {\n      definitionMap.set('attrs', constantPool.getConstLiteral(literalArr(selectorAttributes.map(value => value != null ? literal(value) : literal(undefined))), true));\n    }\n  }\n  const templateTypeName = meta.name;\n  let allDeferrableDepsFn = null;\n  if (meta.defer.mode === 1 && meta.defer.dependenciesFn !== null) {\n    const fnName = `${templateTypeName}_DeferFn`;\n    constantPool.statements.push(new DeclareVarStmt(fnName, meta.defer.dependenciesFn, undefined, StmtModifier.Final));\n    allDeferrableDepsFn = variable(fnName);\n  }\n  const compilationMode = meta.isStandalone && !meta.hasDirectiveDependencies ? TemplateCompilationMode.DomOnly : TemplateCompilationMode.Full;\n  const tpl = ingestComponent(meta.name, meta.template.nodes, constantPool, compilationMode, meta.relativeContextFilePath, meta.i18nUseExternalIds, meta.defer, allDeferrableDepsFn, meta.relativeTemplatePath, getTemplateSourceLocationsEnabled());\n  transform(tpl, CompilationJobKind.Tmpl);\n  const templateFn = emitTemplateFn(tpl, constantPool);\n  if (tpl.contentSelectors !== null) {\n    definitionMap.set('ngContentSelectors', tpl.contentSelectors);\n  }\n  definitionMap.set('decls', literal(tpl.root.decls));\n  definitionMap.set('vars', literal(tpl.root.vars));\n  if (tpl.consts.length > 0) {\n    if (tpl.constsInitializers.length > 0) {\n      definitionMap.set('consts', arrowFn([], [...tpl.constsInitializers, new ReturnStatement(literalArr(tpl.consts))]));\n    } else {\n      definitionMap.set('consts', literalArr(tpl.consts));\n    }\n  }\n  definitionMap.set('template', templateFn);\n  if (meta.declarationListEmitMode !== 3 && meta.declarations.length > 0) {\n    definitionMap.set('dependencies', compileDeclarationList(literalArr(meta.declarations.map(decl => decl.type)), meta.declarationListEmitMode));\n  } else if (meta.declarationListEmitMode === 3) {\n    const args = [meta.type.value];\n    if (meta.rawImports) {\n      args.push(meta.rawImports);\n    }\n    definitionMap.set('dependencies', importExpr(Identifiers.getComponentDepsFactory).callFn(args));\n  }\n  if (meta.encapsulation === null) {\n    meta.encapsulation = ViewEncapsulation$1.Emulated;\n  }\n  let hasStyles = !!meta.externalStyles?.length;\n  if (meta.styles && meta.styles.length) {\n    const styleValues = meta.encapsulation == ViewEncapsulation$1.Emulated ? compileStyles(meta.styles, CONTENT_ATTR, HOST_ATTR) : meta.styles;\n    const styleNodes = styleValues.reduce((result, style) => {\n      if (style.trim().length > 0) {\n        result.push(constantPool.getConstLiteral(literal(style)));\n      }\n      return result;\n    }, []);\n    if (styleNodes.length > 0) {\n      hasStyles = true;\n      definitionMap.set('styles', literalArr(styleNodes));\n    }\n  }\n  if (!hasStyles && meta.encapsulation === ViewEncapsulation$1.Emulated) {\n    meta.encapsulation = ViewEncapsulation$1.None;\n  }\n  if (meta.encapsulation !== ViewEncapsulation$1.Emulated) {\n    definitionMap.set('encapsulation', literal(meta.encapsulation));\n  }\n  if (meta.animations !== null) {\n    definitionMap.set('data', literalMap([{\n      key: 'animation',\n      value: meta.animations,\n      quoted: false\n    }]));\n  }\n  if (meta.changeDetection !== null) {\n    if (typeof meta.changeDetection === 'number' && meta.changeDetection !== ChangeDetectionStrategy.Default) {\n      definitionMap.set('changeDetection', literal(meta.changeDetection));\n    } else if (typeof meta.changeDetection === 'object') {\n      definitionMap.set('changeDetection', meta.changeDetection);\n    }\n  }\n  const expression = importExpr(Identifiers.defineComponent).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createComponentType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createComponentType(meta) {\n  const typeParams = createBaseDirectiveTypeParams(meta);\n  typeParams.push(stringArrayAsType(meta.template.ngContentSelectors));\n  typeParams.push(expressionType(literal(meta.isStandalone)));\n  typeParams.push(createHostDirectivesType(meta));\n  if (meta.isSignal) {\n    typeParams.push(expressionType(literal(meta.isSignal)));\n  }\n  return expressionType(importExpr(Identifiers.ComponentDeclaration, typeParams));\n}\nfunction compileDeclarationList(list, mode) {\n  switch (mode) {\n    case 0:\n      return list;\n    case 1:\n      return arrowFn([], list);\n    case 2:\n      const resolvedList = list.prop('map').callFn([importExpr(Identifiers.resolveForwardRef)]);\n      return arrowFn([], resolvedList);\n    case 3:\n      throw new Error(`Unsupported with an array of pre-resolved dependencies`);\n  }\n}\nfunction stringAsType(str) {\n  return expressionType(literal(str));\n}\nfunction stringMapAsLiteralExpression(map) {\n  const mapValues = Object.keys(map).map(key => {\n    const value = Array.isArray(map[key]) ? map[key][0] : map[key];\n    return {\n      key,\n      value: literal(value),\n      quoted: true\n    };\n  });\n  return literalMap(mapValues);\n}\nfunction stringArrayAsType(arr) {\n  return arr.length > 0 ? expressionType(literalArr(arr.map(value => literal(value)))) : NONE_TYPE;\n}\nfunction createBaseDirectiveTypeParams(meta) {\n  const selectorForType = meta.selector !== null ? meta.selector.replace(/\\n/g, '') : null;\n  return [typeWithParameters(meta.type.type, meta.typeArgumentCount), selectorForType !== null ? stringAsType(selectorForType) : NONE_TYPE, meta.exportAs !== null ? stringArrayAsType(meta.exportAs) : NONE_TYPE, expressionType(getInputsTypeExpression(meta)), expressionType(stringMapAsLiteralExpression(meta.outputs)), stringArrayAsType(meta.queries.map(q => q.propertyName))];\n}\nfunction getInputsTypeExpression(meta) {\n  return literalMap(Object.keys(meta.inputs).map(key => {\n    const value = meta.inputs[key];\n    const values = [{\n      key: 'alias',\n      value: literal(value.bindingPropertyName),\n      quoted: true\n    }, {\n      key: 'required',\n      value: literal(value.required),\n      quoted: true\n    }];\n    if (value.isSignal) {\n      values.push({\n        key: 'isSignal',\n        value: literal(value.isSignal),\n        quoted: true\n      });\n    }\n    return {\n      key,\n      value: literalMap(values),\n      quoted: true\n    };\n  }));\n}\nfunction createDirectiveType(meta) {\n  const typeParams = createBaseDirectiveTypeParams(meta);\n  typeParams.push(NONE_TYPE);\n  typeParams.push(expressionType(literal(meta.isStandalone)));\n  typeParams.push(createHostDirectivesType(meta));\n  if (meta.isSignal) {\n    typeParams.push(expressionType(literal(meta.isSignal)));\n  }\n  return expressionType(importExpr(Identifiers.DirectiveDeclaration, typeParams));\n}\nfunction createHostBindingsFunction(hostBindingsMetadata, typeSourceSpan, bindingParser, constantPool, selector, name, definitionMap) {\n  const bindings = bindingParser.createBoundHostProperties(hostBindingsMetadata.properties, typeSourceSpan);\n  const eventBindings = bindingParser.createDirectiveHostEventAsts(hostBindingsMetadata.listeners, typeSourceSpan);\n  if (hostBindingsMetadata.specialAttributes.styleAttr) {\n    hostBindingsMetadata.attributes['style'] = literal(hostBindingsMetadata.specialAttributes.styleAttr);\n  }\n  if (hostBindingsMetadata.specialAttributes.classAttr) {\n    hostBindingsMetadata.attributes['class'] = literal(hostBindingsMetadata.specialAttributes.classAttr);\n  }\n  const hostJob = ingestHostBinding({\n    componentName: name,\n    componentSelector: selector,\n    properties: bindings,\n    events: eventBindings,\n    attributes: hostBindingsMetadata.attributes\n  }, bindingParser, constantPool);\n  transform(hostJob, CompilationJobKind.Host);\n  definitionMap.set('hostAttrs', hostJob.root.attributes);\n  const varCount = hostJob.root.vars;\n  if (varCount !== null && varCount > 0) {\n    definitionMap.set('hostVars', literal(varCount));\n  }\n  return emitHostBindingFunction(hostJob);\n}\nconst HOST_REG_EXP = /^(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\))$/;\nfunction parseHostBindings(host) {\n  const attributes = {};\n  const listeners = {};\n  const properties = {};\n  const specialAttributes = {};\n  for (const key of Object.keys(host)) {\n    const value = host[key];\n    const matches = key.match(HOST_REG_EXP);\n    if (matches === null) {\n      switch (key) {\n        case 'class':\n          if (typeof value !== 'string') {\n            throw new Error(`Class binding must be string`);\n          }\n          specialAttributes.classAttr = value;\n          break;\n        case 'style':\n          if (typeof value !== 'string') {\n            throw new Error(`Style binding must be string`);\n          }\n          specialAttributes.styleAttr = value;\n          break;\n        default:\n          if (typeof value === 'string') {\n            attributes[key] = literal(value);\n          } else {\n            attributes[key] = value;\n          }\n      }\n    } else if (matches[1] != null) {\n      if (typeof value !== 'string') {\n        throw new Error(`Property binding must be string`);\n      }\n      properties[matches[1]] = value;\n    } else if (matches[2] != null) {\n      if (typeof value !== 'string') {\n        throw new Error(`Event binding must be string`);\n      }\n      listeners[matches[2]] = value;\n    }\n  }\n  return {\n    attributes,\n    listeners,\n    properties,\n    specialAttributes\n  };\n}\nfunction verifyHostBindings(bindings, sourceSpan) {\n  const bindingParser = makeBindingParser();\n  bindingParser.createDirectiveHostEventAsts(bindings.listeners, sourceSpan);\n  bindingParser.createBoundHostProperties(bindings.properties, sourceSpan);\n  return bindingParser.errors;\n}\nfunction compileStyles(styles, selector, hostSelector) {\n  const shadowCss = new ShadowCss();\n  return styles.map(style => {\n    return shadowCss.shimCssText(style, selector, hostSelector);\n  });\n}\nfunction encapsulateStyle(style, componentIdentifier) {\n  const shadowCss = new ShadowCss();\n  const selector = componentIdentifier ? CONTENT_ATTR.replace(COMPONENT_VARIABLE, componentIdentifier) : CONTENT_ATTR;\n  const hostSelector = componentIdentifier ? HOST_ATTR.replace(COMPONENT_VARIABLE, componentIdentifier) : HOST_ATTR;\n  return shadowCss.shimCssText(style, selector, hostSelector);\n}\nfunction createHostDirectivesType(meta) {\n  if (!meta.hostDirectives?.length) {\n    return NONE_TYPE;\n  }\n  return expressionType(literalArr(meta.hostDirectives.map(hostMeta => literalMap([{\n    key: 'directive',\n    value: typeofExpr(hostMeta.directive.type),\n    quoted: false\n  }, {\n    key: 'inputs',\n    value: stringMapAsLiteralExpression(hostMeta.inputs || {}),\n    quoted: false\n  }, {\n    key: 'outputs',\n    value: stringMapAsLiteralExpression(hostMeta.outputs || {}),\n    quoted: false\n  }]))));\n}\nfunction createHostDirectivesFeatureArg(hostDirectives) {\n  const expressions = [];\n  let hasForwardRef = false;\n  for (const current of hostDirectives) {\n    if (!current.inputs && !current.outputs) {\n      expressions.push(current.directive.type);\n    } else {\n      const keys = [{\n        key: 'directive',\n        value: current.directive.type,\n        quoted: false\n      }];\n      if (current.inputs) {\n        const inputsLiteral = createHostDirectivesMappingArray(current.inputs);\n        if (inputsLiteral) {\n          keys.push({\n            key: 'inputs',\n            value: inputsLiteral,\n            quoted: false\n          });\n        }\n      }\n      if (current.outputs) {\n        const outputsLiteral = createHostDirectivesMappingArray(current.outputs);\n        if (outputsLiteral) {\n          keys.push({\n            key: 'outputs',\n            value: outputsLiteral,\n            quoted: false\n          });\n        }\n      }\n      expressions.push(literalMap(keys));\n    }\n    if (current.isForwardReference) {\n      hasForwardRef = true;\n    }\n  }\n  return hasForwardRef ? new FunctionExpr([], [new ReturnStatement(literalArr(expressions))]) : literalArr(expressions);\n}\nfunction createHostDirectivesMappingArray(mapping) {\n  const elements = [];\n  for (const publicName in mapping) {\n    if (mapping.hasOwnProperty(publicName)) {\n      elements.push(literal(publicName), literal(mapping[publicName]));\n    }\n  }\n  return elements.length > 0 ? literalArr(elements) : null;\n}\nfunction compileDeferResolverFunction(meta) {\n  const depExpressions = [];\n  if (meta.mode === 0) {\n    for (const dep of meta.dependencies) {\n      if (dep.isDeferrable) {\n        const innerFn = arrowFn([new FnParam('m', DYNAMIC_TYPE)], variable('m').prop(dep.isDefaultImport ? 'default' : dep.symbolName));\n        const importExpr = new DynamicImportExpr(dep.importPath).prop('then').callFn([innerFn]);\n        depExpressions.push(importExpr);\n      } else {\n        depExpressions.push(dep.typeReference);\n      }\n    }\n  } else {\n    for (const {\n      symbolName,\n      importPath,\n      isDefaultImport\n    } of meta.dependencies) {\n      const innerFn = arrowFn([new FnParam('m', DYNAMIC_TYPE)], variable('m').prop(isDefaultImport ? 'default' : symbolName));\n      const importExpr = new DynamicImportExpr(importPath).prop('then').callFn([innerFn]);\n      depExpressions.push(importExpr);\n    }\n  }\n  return arrowFn([], literalArr(depExpressions));\n}\nclass CombinedRecursiveAstVisitor extends RecursiveAstVisitor {\n  visit(node) {\n    if (node instanceof ASTWithSource) {\n      this.visit(node.ast);\n    } else {\n      node.visit(this);\n    }\n  }\n  visitElement(element) {\n    this.visitAllTemplateNodes(element.attributes);\n    this.visitAllTemplateNodes(element.inputs);\n    this.visitAllTemplateNodes(element.outputs);\n    this.visitAllTemplateNodes(element.directives);\n    this.visitAllTemplateNodes(element.references);\n    this.visitAllTemplateNodes(element.children);\n  }\n  visitTemplate(template) {\n    this.visitAllTemplateNodes(template.attributes);\n    this.visitAllTemplateNodes(template.inputs);\n    this.visitAllTemplateNodes(template.outputs);\n    this.visitAllTemplateNodes(template.directives);\n    this.visitAllTemplateNodes(template.templateAttrs);\n    this.visitAllTemplateNodes(template.variables);\n    this.visitAllTemplateNodes(template.references);\n    this.visitAllTemplateNodes(template.children);\n  }\n  visitContent(content) {\n    this.visitAllTemplateNodes(content.children);\n  }\n  visitBoundAttribute(attribute) {\n    this.visit(attribute.value);\n  }\n  visitBoundEvent(attribute) {\n    this.visit(attribute.handler);\n  }\n  visitBoundText(text) {\n    this.visit(text.value);\n  }\n  visitIcu(icu) {\n    Object.keys(icu.vars).forEach(key => this.visit(icu.vars[key]));\n    Object.keys(icu.placeholders).forEach(key => this.visit(icu.placeholders[key]));\n  }\n  visitDeferredBlock(deferred) {\n    deferred.visitAll(this);\n  }\n  visitDeferredTrigger(trigger) {\n    if (trigger instanceof BoundDeferredTrigger) {\n      this.visit(trigger.value);\n    } else if (trigger instanceof ViewportDeferredTrigger && trigger.options !== null) {\n      this.visit(trigger.options);\n    }\n  }\n  visitDeferredBlockPlaceholder(block) {\n    this.visitAllTemplateNodes(block.children);\n  }\n  visitDeferredBlockError(block) {\n    this.visitAllTemplateNodes(block.children);\n  }\n  visitDeferredBlockLoading(block) {\n    this.visitAllTemplateNodes(block.children);\n  }\n  visitSwitchBlock(block) {\n    this.visit(block.expression);\n    this.visitAllTemplateNodes(block.cases);\n  }\n  visitSwitchBlockCase(block) {\n    block.expression && this.visit(block.expression);\n    this.visitAllTemplateNodes(block.children);\n  }\n  visitForLoopBlock(block) {\n    block.item.visit(this);\n    this.visitAllTemplateNodes(block.contextVariables);\n    this.visit(block.expression);\n    this.visitAllTemplateNodes(block.children);\n    block.empty?.visit(this);\n  }\n  visitForLoopBlockEmpty(block) {\n    this.visitAllTemplateNodes(block.children);\n  }\n  visitIfBlock(block) {\n    this.visitAllTemplateNodes(block.branches);\n  }\n  visitIfBlockBranch(block) {\n    block.expression && this.visit(block.expression);\n    block.expressionAlias?.visit(this);\n    this.visitAllTemplateNodes(block.children);\n  }\n  visitLetDeclaration(decl) {\n    this.visit(decl.value);\n  }\n  visitComponent(component) {\n    this.visitAllTemplateNodes(component.attributes);\n    this.visitAllTemplateNodes(component.inputs);\n    this.visitAllTemplateNodes(component.outputs);\n    this.visitAllTemplateNodes(component.directives);\n    this.visitAllTemplateNodes(component.references);\n    this.visitAllTemplateNodes(component.children);\n  }\n  visitDirective(directive) {\n    this.visitAllTemplateNodes(directive.attributes);\n    this.visitAllTemplateNodes(directive.inputs);\n    this.visitAllTemplateNodes(directive.outputs);\n    this.visitAllTemplateNodes(directive.references);\n  }\n  visitVariable(variable) {}\n  visitReference(reference) {}\n  visitTextAttribute(attribute) {}\n  visitText(text) {}\n  visitUnknownBlock(block) {}\n  visitAllTemplateNodes(nodes) {\n    for (const node of nodes) {\n      this.visit(node);\n    }\n  }\n}\nfunction diff(fullList, itemsToExclude) {\n  const exclude = new Set(itemsToExclude);\n  return fullList.filter(item => !exclude.has(item));\n}\nfunction findMatchingDirectivesAndPipes(template, directiveSelectors) {\n  const matcher = new SelectorMatcher();\n  for (const selector of directiveSelectors) {\n    const fakeDirective = {\n      selector,\n      exportAs: null,\n      inputs: {\n        hasBindingPropertyName() {\n          return false;\n        }\n      },\n      outputs: {\n        hasBindingPropertyName() {\n          return false;\n        }\n      }\n    };\n    matcher.addSelectables(CssSelector.parse(selector), [fakeDirective]);\n  }\n  const parsedTemplate = parseTemplate(template, '');\n  const binder = new R3TargetBinder(matcher);\n  const bound = binder.bind({\n    template: parsedTemplate.nodes\n  });\n  const eagerDirectiveSelectors = bound.getEagerlyUsedDirectives().map(dir => dir.selector);\n  const allMatchedDirectiveSelectors = bound.getUsedDirectives().map(dir => dir.selector);\n  const eagerPipes = bound.getEagerlyUsedPipes();\n  return {\n    directives: {\n      regular: eagerDirectiveSelectors,\n      deferCandidates: diff(allMatchedDirectiveSelectors, eagerDirectiveSelectors)\n    },\n    pipes: {\n      regular: eagerPipes,\n      deferCandidates: diff(bound.getUsedPipes(), eagerPipes)\n    }\n  };\n}\nclass R3TargetBinder {\n  directiveMatcher;\n  constructor(directiveMatcher) {\n    this.directiveMatcher = directiveMatcher;\n  }\n  bind(target) {\n    if (!target.template && !target.host) {\n      throw new Error('Empty bound targets are not supported');\n    }\n    const directives = new Map();\n    const eagerDirectives = [];\n    const missingDirectives = new Set();\n    const bindings = new Map();\n    const references = new Map();\n    const scopedNodeEntities = new Map();\n    const expressions = new Map();\n    const symbols = new Map();\n    const nestingLevel = new Map();\n    const usedPipes = new Set();\n    const eagerPipes = new Set();\n    const deferBlocks = [];\n    if (target.template) {\n      const scope = Scope.apply(target.template);\n      extractScopedNodeEntities(scope, scopedNodeEntities);\n      DirectiveBinder.apply(target.template, this.directiveMatcher, directives, eagerDirectives, missingDirectives, bindings, references);\n      TemplateBinder.applyWithScope(target.template, scope, expressions, symbols, nestingLevel, usedPipes, eagerPipes, deferBlocks);\n    }\n    if (target.host) {\n      directives.set(target.host.node, target.host.directives);\n      TemplateBinder.applyWithScope(target.host.node, Scope.apply(target.host.node), expressions, symbols, nestingLevel, usedPipes, eagerPipes, deferBlocks);\n    }\n    return new R3BoundTarget(target, directives, eagerDirectives, missingDirectives, bindings, references, expressions, symbols, nestingLevel, scopedNodeEntities, usedPipes, eagerPipes, deferBlocks);\n  }\n}\nclass Scope {\n  parentScope;\n  rootNode;\n  namedEntities = new Map();\n  elementLikeInScope = new Set();\n  childScopes = new Map();\n  isDeferred;\n  constructor(parentScope, rootNode) {\n    this.parentScope = parentScope;\n    this.rootNode = rootNode;\n    this.isDeferred = parentScope !== null && parentScope.isDeferred ? true : rootNode instanceof DeferredBlock;\n  }\n  static newRootScope() {\n    return new Scope(null, null);\n  }\n  static apply(template) {\n    const scope = Scope.newRootScope();\n    scope.ingest(template);\n    return scope;\n  }\n  ingest(nodeOrNodes) {\n    if (nodeOrNodes instanceof Template) {\n      nodeOrNodes.variables.forEach(node => this.visitVariable(node));\n      nodeOrNodes.children.forEach(node => node.visit(this));\n    } else if (nodeOrNodes instanceof IfBlockBranch) {\n      if (nodeOrNodes.expressionAlias !== null) {\n        this.visitVariable(nodeOrNodes.expressionAlias);\n      }\n      nodeOrNodes.children.forEach(node => node.visit(this));\n    } else if (nodeOrNodes instanceof ForLoopBlock) {\n      this.visitVariable(nodeOrNodes.item);\n      nodeOrNodes.contextVariables.forEach(v => this.visitVariable(v));\n      nodeOrNodes.children.forEach(node => node.visit(this));\n    } else if (nodeOrNodes instanceof SwitchBlockCase || nodeOrNodes instanceof ForLoopBlockEmpty || nodeOrNodes instanceof DeferredBlock || nodeOrNodes instanceof DeferredBlockError || nodeOrNodes instanceof DeferredBlockPlaceholder || nodeOrNodes instanceof DeferredBlockLoading || nodeOrNodes instanceof Content) {\n      nodeOrNodes.children.forEach(node => node.visit(this));\n    } else if (!(nodeOrNodes instanceof HostElement)) {\n      nodeOrNodes.forEach(node => node.visit(this));\n    }\n  }\n  visitElement(element) {\n    this.visitElementLike(element);\n  }\n  visitTemplate(template) {\n    template.directives.forEach(node => node.visit(this));\n    template.references.forEach(node => this.visitReference(node));\n    this.ingestScopedNode(template);\n  }\n  visitVariable(variable) {\n    this.maybeDeclare(variable);\n  }\n  visitReference(reference) {\n    this.maybeDeclare(reference);\n  }\n  visitDeferredBlock(deferred) {\n    this.ingestScopedNode(deferred);\n    deferred.placeholder?.visit(this);\n    deferred.loading?.visit(this);\n    deferred.error?.visit(this);\n  }\n  visitDeferredBlockPlaceholder(block) {\n    this.ingestScopedNode(block);\n  }\n  visitDeferredBlockError(block) {\n    this.ingestScopedNode(block);\n  }\n  visitDeferredBlockLoading(block) {\n    this.ingestScopedNode(block);\n  }\n  visitSwitchBlock(block) {\n    block.cases.forEach(node => node.visit(this));\n  }\n  visitSwitchBlockCase(block) {\n    this.ingestScopedNode(block);\n  }\n  visitForLoopBlock(block) {\n    this.ingestScopedNode(block);\n    block.empty?.visit(this);\n  }\n  visitForLoopBlockEmpty(block) {\n    this.ingestScopedNode(block);\n  }\n  visitIfBlock(block) {\n    block.branches.forEach(node => node.visit(this));\n  }\n  visitIfBlockBranch(block) {\n    this.ingestScopedNode(block);\n  }\n  visitContent(content) {\n    this.ingestScopedNode(content);\n  }\n  visitLetDeclaration(decl) {\n    this.maybeDeclare(decl);\n  }\n  visitComponent(component) {\n    this.visitElementLike(component);\n  }\n  visitDirective(directive) {\n    directive.references.forEach(current => this.visitReference(current));\n  }\n  visitBoundAttribute(attr) {}\n  visitBoundEvent(event) {}\n  visitBoundText(text) {}\n  visitText(text) {}\n  visitTextAttribute(attr) {}\n  visitIcu(icu) {}\n  visitDeferredTrigger(trigger) {}\n  visitUnknownBlock(block) {}\n  visitElementLike(node) {\n    node.directives.forEach(current => current.visit(this));\n    node.references.forEach(current => this.visitReference(current));\n    node.children.forEach(current => current.visit(this));\n    this.elementLikeInScope.add(node);\n  }\n  maybeDeclare(thing) {\n    if (!this.namedEntities.has(thing.name)) {\n      this.namedEntities.set(thing.name, thing);\n    }\n  }\n  lookup(name) {\n    if (this.namedEntities.has(name)) {\n      return this.namedEntities.get(name);\n    } else if (this.parentScope !== null) {\n      return this.parentScope.lookup(name);\n    } else {\n      return null;\n    }\n  }\n  getChildScope(node) {\n    const res = this.childScopes.get(node);\n    if (res === undefined) {\n      throw new Error(`Assertion error: child scope for ${node} not found`);\n    }\n    return res;\n  }\n  ingestScopedNode(node) {\n    const scope = new Scope(this, node);\n    scope.ingest(node);\n    this.childScopes.set(node, scope);\n  }\n}\nclass DirectiveBinder {\n  directiveMatcher;\n  directives;\n  eagerDirectives;\n  missingDirectives;\n  bindings;\n  references;\n  isInDeferBlock = false;\n  constructor(directiveMatcher, directives, eagerDirectives, missingDirectives, bindings, references) {\n    this.directiveMatcher = directiveMatcher;\n    this.directives = directives;\n    this.eagerDirectives = eagerDirectives;\n    this.missingDirectives = missingDirectives;\n    this.bindings = bindings;\n    this.references = references;\n  }\n  static apply(template, directiveMatcher, directives, eagerDirectives, missingDirectives, bindings, references) {\n    const matcher = new DirectiveBinder(directiveMatcher, directives, eagerDirectives, missingDirectives, bindings, references);\n    matcher.ingest(template);\n  }\n  ingest(template) {\n    template.forEach(node => node.visit(this));\n  }\n  visitElement(element) {\n    this.visitElementOrTemplate(element);\n  }\n  visitTemplate(template) {\n    this.visitElementOrTemplate(template);\n  }\n  visitDeferredBlock(deferred) {\n    const wasInDeferBlock = this.isInDeferBlock;\n    this.isInDeferBlock = true;\n    deferred.children.forEach(child => child.visit(this));\n    this.isInDeferBlock = wasInDeferBlock;\n    deferred.placeholder?.visit(this);\n    deferred.loading?.visit(this);\n    deferred.error?.visit(this);\n  }\n  visitDeferredBlockPlaceholder(block) {\n    block.children.forEach(child => child.visit(this));\n  }\n  visitDeferredBlockError(block) {\n    block.children.forEach(child => child.visit(this));\n  }\n  visitDeferredBlockLoading(block) {\n    block.children.forEach(child => child.visit(this));\n  }\n  visitSwitchBlock(block) {\n    block.cases.forEach(node => node.visit(this));\n  }\n  visitSwitchBlockCase(block) {\n    block.children.forEach(node => node.visit(this));\n  }\n  visitForLoopBlock(block) {\n    block.item.visit(this);\n    block.contextVariables.forEach(v => v.visit(this));\n    block.children.forEach(node => node.visit(this));\n    block.empty?.visit(this);\n  }\n  visitForLoopBlockEmpty(block) {\n    block.children.forEach(node => node.visit(this));\n  }\n  visitIfBlock(block) {\n    block.branches.forEach(node => node.visit(this));\n  }\n  visitIfBlockBranch(block) {\n    block.expressionAlias?.visit(this);\n    block.children.forEach(node => node.visit(this));\n  }\n  visitContent(content) {\n    content.children.forEach(child => child.visit(this));\n  }\n  visitComponent(node) {\n    if (this.directiveMatcher instanceof SelectorlessMatcher) {\n      const componentMatches = this.directiveMatcher.match(node.componentName);\n      if (componentMatches.length > 0) {\n        this.trackSelectorlessMatchesAndDirectives(node, componentMatches);\n      } else {\n        this.missingDirectives.add(node.componentName);\n      }\n    }\n    node.directives.forEach(directive => directive.visit(this));\n    node.children.forEach(child => child.visit(this));\n  }\n  visitDirective(node) {\n    if (this.directiveMatcher instanceof SelectorlessMatcher) {\n      const directives = this.directiveMatcher.match(node.name);\n      if (directives.length > 0) {\n        this.trackSelectorlessMatchesAndDirectives(node, directives);\n      } else {\n        this.missingDirectives.add(node.name);\n      }\n    }\n  }\n  visitElementOrTemplate(node) {\n    if (this.directiveMatcher instanceof SelectorMatcher) {\n      const directives = [];\n      const cssSelector = createCssSelectorFromNode(node);\n      this.directiveMatcher.match(cssSelector, (_, results) => directives.push(...results));\n      this.trackSelectorBasedBindingsAndDirectives(node, directives);\n    } else {\n      node.references.forEach(ref => {\n        if (ref.value.trim() === '') {\n          this.references.set(ref, node);\n        }\n      });\n    }\n    node.directives.forEach(directive => directive.visit(this));\n    node.children.forEach(child => child.visit(this));\n  }\n  trackMatchedDirectives(node, directives) {\n    if (directives.length > 0) {\n      this.directives.set(node, directives);\n      if (!this.isInDeferBlock) {\n        this.eagerDirectives.push(...directives);\n      }\n    }\n  }\n  trackSelectorlessMatchesAndDirectives(node, directives) {\n    if (directives.length === 0) {\n      return;\n    }\n    this.trackMatchedDirectives(node, directives);\n    const setBinding = (meta, attribute, ioType) => {\n      if (meta[ioType].hasBindingPropertyName(attribute.name)) {\n        this.bindings.set(attribute, meta);\n      }\n    };\n    for (const directive of directives) {\n      node.inputs.forEach(input => setBinding(directive, input, 'inputs'));\n      node.attributes.forEach(attr => setBinding(directive, attr, 'inputs'));\n      node.outputs.forEach(output => setBinding(directive, output, 'outputs'));\n    }\n    node.references.forEach(ref => this.references.set(ref, {\n      directive: directives[0],\n      node: node\n    }));\n  }\n  trackSelectorBasedBindingsAndDirectives(node, directives) {\n    this.trackMatchedDirectives(node, directives);\n    node.references.forEach(ref => {\n      let dirTarget = null;\n      if (ref.value.trim() === '') {\n        dirTarget = directives.find(dir => dir.isComponent) || null;\n      } else {\n        dirTarget = directives.find(dir => dir.exportAs !== null && dir.exportAs.some(value => value === ref.value)) || null;\n        if (dirTarget === null) {\n          return;\n        }\n      }\n      if (dirTarget !== null) {\n        this.references.set(ref, {\n          directive: dirTarget,\n          node\n        });\n      } else {\n        this.references.set(ref, node);\n      }\n    });\n    const setAttributeBinding = (attribute, ioType) => {\n      const dir = directives.find(dir => dir[ioType].hasBindingPropertyName(attribute.name));\n      const binding = dir !== undefined ? dir : node;\n      this.bindings.set(attribute, binding);\n    };\n    node.inputs.forEach(input => setAttributeBinding(input, 'inputs'));\n    node.attributes.forEach(attr => setAttributeBinding(attr, 'inputs'));\n    if (node instanceof Template) {\n      node.templateAttrs.forEach(attr => setAttributeBinding(attr, 'inputs'));\n    }\n    node.outputs.forEach(output => setAttributeBinding(output, 'outputs'));\n  }\n  visitVariable(variable) {}\n  visitReference(reference) {}\n  visitTextAttribute(attribute) {}\n  visitBoundAttribute(attribute) {}\n  visitBoundEvent(attribute) {}\n  visitBoundAttributeOrEvent(node) {}\n  visitText(text) {}\n  visitBoundText(text) {}\n  visitIcu(icu) {}\n  visitDeferredTrigger(trigger) {}\n  visitUnknownBlock(block) {}\n  visitLetDeclaration(decl) {}\n}\nclass TemplateBinder extends CombinedRecursiveAstVisitor {\n  bindings;\n  symbols;\n  usedPipes;\n  eagerPipes;\n  deferBlocks;\n  nestingLevel;\n  scope;\n  rootNode;\n  level;\n  visitNode = node => node.visit(this);\n  constructor(bindings, symbols, usedPipes, eagerPipes, deferBlocks, nestingLevel, scope, rootNode, level) {\n    super();\n    this.bindings = bindings;\n    this.symbols = symbols;\n    this.usedPipes = usedPipes;\n    this.eagerPipes = eagerPipes;\n    this.deferBlocks = deferBlocks;\n    this.nestingLevel = nestingLevel;\n    this.scope = scope;\n    this.rootNode = rootNode;\n    this.level = level;\n  }\n  static applyWithScope(nodeOrNodes, scope, expressions, symbols, nestingLevel, usedPipes, eagerPipes, deferBlocks) {\n    const template = nodeOrNodes instanceof Template ? nodeOrNodes : null;\n    const binder = new TemplateBinder(expressions, symbols, usedPipes, eagerPipes, deferBlocks, nestingLevel, scope, template, 0);\n    binder.ingest(nodeOrNodes);\n  }\n  ingest(nodeOrNodes) {\n    if (nodeOrNodes instanceof Template) {\n      nodeOrNodes.variables.forEach(this.visitNode);\n      nodeOrNodes.children.forEach(this.visitNode);\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (nodeOrNodes instanceof IfBlockBranch) {\n      if (nodeOrNodes.expressionAlias !== null) {\n        this.visitNode(nodeOrNodes.expressionAlias);\n      }\n      nodeOrNodes.children.forEach(this.visitNode);\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (nodeOrNodes instanceof ForLoopBlock) {\n      this.visitNode(nodeOrNodes.item);\n      nodeOrNodes.contextVariables.forEach(v => this.visitNode(v));\n      nodeOrNodes.trackBy.visit(this);\n      nodeOrNodes.children.forEach(this.visitNode);\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (nodeOrNodes instanceof DeferredBlock) {\n      if (this.scope.rootNode !== nodeOrNodes) {\n        throw new Error(`Assertion error: resolved incorrect scope for deferred block ${nodeOrNodes}`);\n      }\n      this.deferBlocks.push([nodeOrNodes, this.scope]);\n      nodeOrNodes.children.forEach(node => node.visit(this));\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (nodeOrNodes instanceof SwitchBlockCase || nodeOrNodes instanceof ForLoopBlockEmpty || nodeOrNodes instanceof DeferredBlockError || nodeOrNodes instanceof DeferredBlockPlaceholder || nodeOrNodes instanceof DeferredBlockLoading || nodeOrNodes instanceof Content) {\n      nodeOrNodes.children.forEach(node => node.visit(this));\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (nodeOrNodes instanceof HostElement) {\n      this.nestingLevel.set(nodeOrNodes, 0);\n    } else {\n      nodeOrNodes.forEach(this.visitNode);\n    }\n  }\n  visitTemplate(template) {\n    template.inputs.forEach(this.visitNode);\n    template.outputs.forEach(this.visitNode);\n    template.directives.forEach(this.visitNode);\n    template.templateAttrs.forEach(this.visitNode);\n    template.references.forEach(this.visitNode);\n    this.ingestScopedNode(template);\n  }\n  visitVariable(variable) {\n    if (this.rootNode !== null) {\n      this.symbols.set(variable, this.rootNode);\n    }\n  }\n  visitReference(reference) {\n    if (this.rootNode !== null) {\n      this.symbols.set(reference, this.rootNode);\n    }\n  }\n  visitDeferredBlock(deferred) {\n    this.ingestScopedNode(deferred);\n    deferred.triggers.when?.value.visit(this);\n    deferred.prefetchTriggers.when?.value.visit(this);\n    deferred.hydrateTriggers.when?.value.visit(this);\n    deferred.hydrateTriggers.never?.visit(this);\n    deferred.placeholder && this.visitNode(deferred.placeholder);\n    deferred.loading && this.visitNode(deferred.loading);\n    deferred.error && this.visitNode(deferred.error);\n  }\n  visitDeferredBlockPlaceholder(block) {\n    this.ingestScopedNode(block);\n  }\n  visitDeferredBlockError(block) {\n    this.ingestScopedNode(block);\n  }\n  visitDeferredBlockLoading(block) {\n    this.ingestScopedNode(block);\n  }\n  visitSwitchBlockCase(block) {\n    block.expression?.visit(this);\n    this.ingestScopedNode(block);\n  }\n  visitForLoopBlock(block) {\n    block.expression.visit(this);\n    this.ingestScopedNode(block);\n    block.empty?.visit(this);\n  }\n  visitForLoopBlockEmpty(block) {\n    this.ingestScopedNode(block);\n  }\n  visitIfBlockBranch(block) {\n    block.expression?.visit(this);\n    this.ingestScopedNode(block);\n  }\n  visitContent(content) {\n    this.ingestScopedNode(content);\n  }\n  visitLetDeclaration(decl) {\n    super.visitLetDeclaration(decl);\n    if (this.rootNode !== null) {\n      this.symbols.set(decl, this.rootNode);\n    }\n  }\n  visitPipe(ast, context) {\n    this.usedPipes.add(ast.name);\n    if (!this.scope.isDeferred) {\n      this.eagerPipes.add(ast.name);\n    }\n    return super.visitPipe(ast, context);\n  }\n  visitPropertyRead(ast, context) {\n    this.maybeMap(ast, ast.name);\n    return super.visitPropertyRead(ast, context);\n  }\n  visitSafePropertyRead(ast, context) {\n    this.maybeMap(ast, ast.name);\n    return super.visitSafePropertyRead(ast, context);\n  }\n  ingestScopedNode(node) {\n    const childScope = this.scope.getChildScope(node);\n    const binder = new TemplateBinder(this.bindings, this.symbols, this.usedPipes, this.eagerPipes, this.deferBlocks, this.nestingLevel, childScope, node, this.level + 1);\n    binder.ingest(node);\n  }\n  maybeMap(ast, name) {\n    if (!(ast.receiver instanceof ImplicitReceiver) || ast.receiver instanceof ThisReceiver) {\n      return;\n    }\n    const target = this.scope.lookup(name);\n    if (target !== null) {\n      this.bindings.set(ast, target);\n    }\n  }\n}\nclass R3BoundTarget {\n  target;\n  directives;\n  eagerDirectives;\n  missingDirectives;\n  bindings;\n  references;\n  exprTargets;\n  symbols;\n  nestingLevel;\n  scopedNodeEntities;\n  usedPipes;\n  eagerPipes;\n  deferredBlocks;\n  deferredScopes;\n  constructor(target, directives, eagerDirectives, missingDirectives, bindings, references, exprTargets, symbols, nestingLevel, scopedNodeEntities, usedPipes, eagerPipes, rawDeferred) {\n    this.target = target;\n    this.directives = directives;\n    this.eagerDirectives = eagerDirectives;\n    this.missingDirectives = missingDirectives;\n    this.bindings = bindings;\n    this.references = references;\n    this.exprTargets = exprTargets;\n    this.symbols = symbols;\n    this.nestingLevel = nestingLevel;\n    this.scopedNodeEntities = scopedNodeEntities;\n    this.usedPipes = usedPipes;\n    this.eagerPipes = eagerPipes;\n    this.deferredBlocks = rawDeferred.map(current => current[0]);\n    this.deferredScopes = new Map(rawDeferred);\n  }\n  getEntitiesInScope(node) {\n    return this.scopedNodeEntities.get(node) ?? new Set();\n  }\n  getDirectivesOfNode(node) {\n    return this.directives.get(node) || null;\n  }\n  getReferenceTarget(ref) {\n    return this.references.get(ref) || null;\n  }\n  getConsumerOfBinding(binding) {\n    return this.bindings.get(binding) || null;\n  }\n  getExpressionTarget(expr) {\n    return this.exprTargets.get(expr) || null;\n  }\n  getDefinitionNodeOfSymbol(symbol) {\n    return this.symbols.get(symbol) || null;\n  }\n  getNestingLevel(node) {\n    return this.nestingLevel.get(node) || 0;\n  }\n  getUsedDirectives() {\n    const set = new Set();\n    this.directives.forEach(dirs => dirs.forEach(dir => set.add(dir)));\n    return Array.from(set.values());\n  }\n  getEagerlyUsedDirectives() {\n    const set = new Set(this.eagerDirectives);\n    return Array.from(set.values());\n  }\n  getUsedPipes() {\n    return Array.from(this.usedPipes);\n  }\n  getEagerlyUsedPipes() {\n    return Array.from(this.eagerPipes);\n  }\n  getDeferBlocks() {\n    return this.deferredBlocks;\n  }\n  getDeferredTriggerTarget(block, trigger) {\n    if (!(trigger instanceof InteractionDeferredTrigger) && !(trigger instanceof ViewportDeferredTrigger) && !(trigger instanceof HoverDeferredTrigger)) {\n      return null;\n    }\n    const name = trigger.reference;\n    if (name === null) {\n      let target = null;\n      if (block.placeholder !== null) {\n        for (const child of block.placeholder.children) {\n          if (child instanceof Comment$1) {\n            continue;\n          }\n          if (target !== null) {\n            return null;\n          }\n          if (child instanceof Element$1) {\n            target = child;\n          }\n        }\n      }\n      return target;\n    }\n    const outsideRef = this.findEntityInScope(block, name);\n    if (outsideRef instanceof Reference && this.getDefinitionNodeOfSymbol(outsideRef) !== block) {\n      const target = this.getReferenceTarget(outsideRef);\n      if (target !== null) {\n        return this.referenceTargetToElement(target);\n      }\n    }\n    if (block.placeholder !== null) {\n      const refInPlaceholder = this.findEntityInScope(block.placeholder, name);\n      const targetInPlaceholder = refInPlaceholder instanceof Reference ? this.getReferenceTarget(refInPlaceholder) : null;\n      if (targetInPlaceholder !== null) {\n        return this.referenceTargetToElement(targetInPlaceholder);\n      }\n    }\n    return null;\n  }\n  isDeferred(element) {\n    for (const block of this.deferredBlocks) {\n      if (!this.deferredScopes.has(block)) {\n        continue;\n      }\n      const stack = [this.deferredScopes.get(block)];\n      while (stack.length > 0) {\n        const current = stack.pop();\n        if (current.elementLikeInScope.has(element)) {\n          return true;\n        }\n        stack.push(...current.childScopes.values());\n      }\n    }\n    return false;\n  }\n  referencedDirectiveExists(name) {\n    return !this.missingDirectives.has(name);\n  }\n  findEntityInScope(rootNode, name) {\n    const entities = this.getEntitiesInScope(rootNode);\n    for (const entity of entities) {\n      if (entity.name === name) {\n        return entity;\n      }\n    }\n    return null;\n  }\n  referenceTargetToElement(target) {\n    if (target instanceof Element$1) {\n      return target;\n    }\n    if (target instanceof Template || target.node instanceof Component$1 || target.node instanceof Directive$1 || target.node instanceof HostElement) {\n      return null;\n    }\n    return this.referenceTargetToElement(target.node);\n  }\n}\nfunction extractScopedNodeEntities(rootScope, templateEntities) {\n  const entityMap = new Map();\n  function extractScopeEntities(scope) {\n    if (entityMap.has(scope.rootNode)) {\n      return entityMap.get(scope.rootNode);\n    }\n    const currentEntities = scope.namedEntities;\n    let entities;\n    if (scope.parentScope !== null) {\n      entities = new Map([...extractScopeEntities(scope.parentScope), ...currentEntities]);\n    } else {\n      entities = new Map(currentEntities);\n    }\n    entityMap.set(scope.rootNode, entities);\n    return entities;\n  }\n  const scopesToProcess = [rootScope];\n  while (scopesToProcess.length > 0) {\n    const scope = scopesToProcess.pop();\n    for (const childScope of scope.childScopes.values()) {\n      scopesToProcess.push(childScope);\n    }\n    extractScopeEntities(scope);\n  }\n  for (const [template, entities] of entityMap) {\n    templateEntities.set(template, new Set(entities.values()));\n  }\n}\nclass ResourceLoader {}\nclass CompilerFacadeImpl {\n  jitEvaluator;\n  FactoryTarget = FactoryTarget;\n  ResourceLoader = ResourceLoader;\n  elementSchemaRegistry = new DomElementSchemaRegistry();\n  constructor(jitEvaluator = new JitEvaluator()) {\n    this.jitEvaluator = jitEvaluator;\n  }\n  compilePipe(angularCoreEnv, sourceMapUrl, facade) {\n    const metadata = {\n      name: facade.name,\n      type: wrapReference(facade.type),\n      typeArgumentCount: 0,\n      deps: null,\n      pipeName: facade.pipeName,\n      pure: facade.pure,\n      isStandalone: facade.isStandalone\n    };\n    const res = compilePipeFromMetadata(metadata);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n  compilePipeDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n    const meta = convertDeclarePipeFacadeToMetadata(declaration);\n    const res = compilePipeFromMetadata(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n  compileInjectable(angularCoreEnv, sourceMapUrl, facade) {\n    const {\n      expression,\n      statements\n    } = compileInjectable({\n      name: facade.name,\n      type: wrapReference(facade.type),\n      typeArgumentCount: facade.typeArgumentCount,\n      providedIn: computeProvidedIn(facade.providedIn),\n      useClass: convertToProviderExpression(facade, 'useClass'),\n      useFactory: wrapExpression(facade, 'useFactory'),\n      useValue: convertToProviderExpression(facade, 'useValue'),\n      useExisting: convertToProviderExpression(facade, 'useExisting'),\n      deps: facade.deps?.map(convertR3DependencyMetadata)\n    }, true);\n    return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n  }\n  compileInjectableDeclaration(angularCoreEnv, sourceMapUrl, facade) {\n    const {\n      expression,\n      statements\n    } = compileInjectable({\n      name: facade.type.name,\n      type: wrapReference(facade.type),\n      typeArgumentCount: 0,\n      providedIn: computeProvidedIn(facade.providedIn),\n      useClass: convertToProviderExpression(facade, 'useClass'),\n      useFactory: wrapExpression(facade, 'useFactory'),\n      useValue: convertToProviderExpression(facade, 'useValue'),\n      useExisting: convertToProviderExpression(facade, 'useExisting'),\n      deps: facade.deps?.map(convertR3DeclareDependencyMetadata)\n    }, true);\n    return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n  }\n  compileInjector(angularCoreEnv, sourceMapUrl, facade) {\n    const meta = {\n      name: facade.name,\n      type: wrapReference(facade.type),\n      providers: facade.providers && facade.providers.length > 0 ? new WrappedNodeExpr(facade.providers) : null,\n      imports: facade.imports.map(i => new WrappedNodeExpr(i))\n    };\n    const res = compileInjector(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n  compileInjectorDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n    const meta = convertDeclareInjectorFacadeToMetadata(declaration);\n    const res = compileInjector(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n  compileNgModule(angularCoreEnv, sourceMapUrl, facade) {\n    const meta = {\n      kind: R3NgModuleMetadataKind.Global,\n      type: wrapReference(facade.type),\n      bootstrap: facade.bootstrap.map(wrapReference),\n      declarations: facade.declarations.map(wrapReference),\n      publicDeclarationTypes: null,\n      imports: facade.imports.map(wrapReference),\n      includeImportTypes: true,\n      exports: facade.exports.map(wrapReference),\n      selectorScopeMode: R3SelectorScopeMode.Inline,\n      containsForwardDecls: false,\n      schemas: facade.schemas ? facade.schemas.map(wrapReference) : null,\n      id: facade.id ? new WrappedNodeExpr(facade.id) : null\n    };\n    const res = compileNgModule(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n  compileNgModuleDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n    const expression = compileNgModuleDeclarationExpression(declaration);\n    return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, []);\n  }\n  compileDirective(angularCoreEnv, sourceMapUrl, facade) {\n    const meta = convertDirectiveFacadeToMetadata(facade);\n    return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n  }\n  compileDirectiveDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n    const typeSourceSpan = this.createParseSourceSpan('Directive', declaration.type.name, sourceMapUrl);\n    const meta = convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan);\n    return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n  }\n  compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta) {\n    const constantPool = new ConstantPool();\n    const bindingParser = makeBindingParser();\n    const res = compileDirectiveFromMetadata(meta, constantPool, bindingParser);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n  }\n  compileComponent(angularCoreEnv, sourceMapUrl, facade) {\n    const {\n      template,\n      defer\n    } = parseJitTemplate(facade.template, facade.name, sourceMapUrl, facade.preserveWhitespaces, undefined);\n    const meta = {\n      ...facade,\n      ...convertDirectiveFacadeToMetadata(facade),\n      selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(),\n      template,\n      declarations: facade.declarations.map(convertDeclarationFacadeToMetadata),\n      declarationListEmitMode: 0,\n      defer,\n      styles: [...facade.styles, ...template.styles],\n      encapsulation: facade.encapsulation,\n      changeDetection: facade.changeDetection ?? null,\n      animations: facade.animations != null ? new WrappedNodeExpr(facade.animations) : null,\n      viewProviders: facade.viewProviders != null ? new WrappedNodeExpr(facade.viewProviders) : null,\n      relativeContextFilePath: '',\n      i18nUseExternalIds: true,\n      relativeTemplatePath: null\n    };\n    const jitExpressionSourceMap = `ng:///${facade.name}.js`;\n    return this.compileComponentFromMeta(angularCoreEnv, jitExpressionSourceMap, meta);\n  }\n  compileComponentDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n    const typeSourceSpan = this.createParseSourceSpan('Component', declaration.type.name, sourceMapUrl);\n    const meta = convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl);\n    return this.compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta);\n  }\n  compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta) {\n    const constantPool = new ConstantPool();\n    const bindingParser = makeBindingParser();\n    const res = compileComponentFromMetadata(meta, constantPool, bindingParser);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n  }\n  compileFactory(angularCoreEnv, sourceMapUrl, meta) {\n    const factoryRes = compileFactoryFunction({\n      name: meta.name,\n      type: wrapReference(meta.type),\n      typeArgumentCount: meta.typeArgumentCount,\n      deps: convertR3DependencyMetadataArray(meta.deps),\n      target: meta.target\n    });\n    return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);\n  }\n  compileFactoryDeclaration(angularCoreEnv, sourceMapUrl, meta) {\n    const factoryRes = compileFactoryFunction({\n      name: meta.type.name,\n      type: wrapReference(meta.type),\n      typeArgumentCount: 0,\n      deps: Array.isArray(meta.deps) ? meta.deps.map(convertR3DeclareDependencyMetadata) : meta.deps,\n      target: meta.target\n    });\n    return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);\n  }\n  createParseSourceSpan(kind, typeName, sourceUrl) {\n    return r3JitTypeSourceSpan(kind, typeName, sourceUrl);\n  }\n  jitExpression(def, context, sourceUrl, preStatements) {\n    const statements = [...preStatements, new DeclareVarStmt('$def', def, undefined, StmtModifier.Exported)];\n    const res = this.jitEvaluator.evaluateStatements(sourceUrl, statements, new R3JitReflector(context), true);\n    return res['$def'];\n  }\n}\nfunction convertToR3QueryMetadata(facade) {\n  return {\n    ...facade,\n    isSignal: facade.isSignal,\n    predicate: convertQueryPredicate(facade.predicate),\n    read: facade.read ? new WrappedNodeExpr(facade.read) : null,\n    static: facade.static,\n    emitDistinctChangesOnly: facade.emitDistinctChangesOnly\n  };\n}\nfunction convertQueryDeclarationToMetadata(declaration) {\n  return {\n    propertyName: declaration.propertyName,\n    first: declaration.first ?? false,\n    predicate: convertQueryPredicate(declaration.predicate),\n    descendants: declaration.descendants ?? false,\n    read: declaration.read ? new WrappedNodeExpr(declaration.read) : null,\n    static: declaration.static ?? false,\n    emitDistinctChangesOnly: declaration.emitDistinctChangesOnly ?? true,\n    isSignal: !!declaration.isSignal\n  };\n}\nfunction convertQueryPredicate(predicate) {\n  return Array.isArray(predicate) ? predicate : createMayBeForwardRefExpression(new WrappedNodeExpr(predicate), 1);\n}\nfunction convertDirectiveFacadeToMetadata(facade) {\n  const inputsFromMetadata = parseInputsArray(facade.inputs || []);\n  const outputsFromMetadata = parseMappingStringArray(facade.outputs || []);\n  const propMetadata = facade.propMetadata;\n  const inputsFromType = {};\n  const outputsFromType = {};\n  for (const field in propMetadata) {\n    if (propMetadata.hasOwnProperty(field)) {\n      propMetadata[field].forEach(ann => {\n        if (isInput(ann)) {\n          inputsFromType[field] = {\n            bindingPropertyName: ann.alias || field,\n            classPropertyName: field,\n            required: ann.required || false,\n            isSignal: !!ann.isSignal,\n            transformFunction: ann.transform != null ? new WrappedNodeExpr(ann.transform) : null\n          };\n        } else if (isOutput(ann)) {\n          outputsFromType[field] = ann.alias || field;\n        }\n      });\n    }\n  }\n  const hostDirectives = facade.hostDirectives?.length ? facade.hostDirectives.map(hostDirective => {\n    return typeof hostDirective === 'function' ? {\n      directive: wrapReference(hostDirective),\n      inputs: null,\n      outputs: null,\n      isForwardReference: false\n    } : {\n      directive: wrapReference(hostDirective.directive),\n      isForwardReference: false,\n      inputs: hostDirective.inputs ? parseMappingStringArray(hostDirective.inputs) : null,\n      outputs: hostDirective.outputs ? parseMappingStringArray(hostDirective.outputs) : null\n    };\n  }) : null;\n  return {\n    ...facade,\n    typeArgumentCount: 0,\n    typeSourceSpan: facade.typeSourceSpan,\n    type: wrapReference(facade.type),\n    deps: null,\n    host: {\n      ...extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host)\n    },\n    inputs: {\n      ...inputsFromMetadata,\n      ...inputsFromType\n    },\n    outputs: {\n      ...outputsFromMetadata,\n      ...outputsFromType\n    },\n    queries: facade.queries.map(convertToR3QueryMetadata),\n    providers: facade.providers != null ? new WrappedNodeExpr(facade.providers) : null,\n    viewQueries: facade.viewQueries.map(convertToR3QueryMetadata),\n    hostDirectives\n  };\n}\nfunction convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan) {\n  const hostDirectives = declaration.hostDirectives?.length ? declaration.hostDirectives.map(dir => ({\n    directive: wrapReference(dir.directive),\n    isForwardReference: false,\n    inputs: dir.inputs ? getHostDirectiveBindingMapping(dir.inputs) : null,\n    outputs: dir.outputs ? getHostDirectiveBindingMapping(dir.outputs) : null\n  })) : null;\n  return {\n    name: declaration.type.name,\n    type: wrapReference(declaration.type),\n    typeSourceSpan,\n    selector: declaration.selector ?? null,\n    inputs: declaration.inputs ? inputsPartialMetadataToInputMetadata(declaration.inputs) : {},\n    outputs: declaration.outputs ?? {},\n    host: convertHostDeclarationToMetadata(declaration.host),\n    queries: (declaration.queries ?? []).map(convertQueryDeclarationToMetadata),\n    viewQueries: (declaration.viewQueries ?? []).map(convertQueryDeclarationToMetadata),\n    providers: declaration.providers !== undefined ? new WrappedNodeExpr(declaration.providers) : null,\n    exportAs: declaration.exportAs ?? null,\n    usesInheritance: declaration.usesInheritance ?? false,\n    lifecycle: {\n      usesOnChanges: declaration.usesOnChanges ?? false\n    },\n    deps: null,\n    typeArgumentCount: 0,\n    isStandalone: declaration.isStandalone ?? getJitStandaloneDefaultForVersion(declaration.version),\n    isSignal: declaration.isSignal ?? false,\n    hostDirectives\n  };\n}\nfunction convertHostDeclarationToMetadata(host = {}) {\n  return {\n    attributes: convertOpaqueValuesToExpressions(host.attributes ?? {}),\n    listeners: host.listeners ?? {},\n    properties: host.properties ?? {},\n    specialAttributes: {\n      classAttr: host.classAttribute,\n      styleAttr: host.styleAttribute\n    }\n  };\n}\nfunction getHostDirectiveBindingMapping(array) {\n  let result = null;\n  for (let i = 1; i < array.length; i += 2) {\n    result = result || {};\n    result[array[i - 1]] = array[i];\n  }\n  return result;\n}\nfunction convertOpaqueValuesToExpressions(obj) {\n  const result = {};\n  for (const key of Object.keys(obj)) {\n    result[key] = new WrappedNodeExpr(obj[key]);\n  }\n  return result;\n}\nfunction convertDeclareComponentFacadeToMetadata(decl, typeSourceSpan, sourceMapUrl) {\n  const {\n    template,\n    defer\n  } = parseJitTemplate(decl.template, decl.type.name, sourceMapUrl, decl.preserveWhitespaces ?? false, decl.deferBlockDependencies);\n  const declarations = [];\n  if (decl.dependencies) {\n    for (const innerDep of decl.dependencies) {\n      switch (innerDep.kind) {\n        case 'directive':\n        case 'component':\n          declarations.push(convertDirectiveDeclarationToMetadata(innerDep));\n          break;\n        case 'pipe':\n          declarations.push(convertPipeDeclarationToMetadata(innerDep));\n          break;\n      }\n    }\n  } else if (decl.components || decl.directives || decl.pipes) {\n    decl.components && declarations.push(...decl.components.map(dir => convertDirectiveDeclarationToMetadata(dir, true)));\n    decl.directives && declarations.push(...decl.directives.map(dir => convertDirectiveDeclarationToMetadata(dir)));\n    decl.pipes && declarations.push(...convertPipeMapToMetadata(decl.pipes));\n  }\n  const hasDirectiveDependencies = declarations.some(({\n    kind\n  }) => kind === R3TemplateDependencyKind.Directive || kind === R3TemplateDependencyKind.NgModule);\n  return {\n    ...convertDeclareDirectiveFacadeToMetadata(decl, typeSourceSpan),\n    template,\n    styles: decl.styles ?? [],\n    declarations,\n    viewProviders: decl.viewProviders !== undefined ? new WrappedNodeExpr(decl.viewProviders) : null,\n    animations: decl.animations !== undefined ? new WrappedNodeExpr(decl.animations) : null,\n    defer,\n    changeDetection: decl.changeDetection ?? ChangeDetectionStrategy.Default,\n    encapsulation: decl.encapsulation ?? ViewEncapsulation$1.Emulated,\n    declarationListEmitMode: 2,\n    relativeContextFilePath: '',\n    i18nUseExternalIds: true,\n    relativeTemplatePath: null,\n    hasDirectiveDependencies\n  };\n}\nfunction convertDeclarationFacadeToMetadata(declaration) {\n  return {\n    ...declaration,\n    type: new WrappedNodeExpr(declaration.type)\n  };\n}\nfunction convertDirectiveDeclarationToMetadata(declaration, isComponent = null) {\n  return {\n    kind: R3TemplateDependencyKind.Directive,\n    isComponent: isComponent || declaration.kind === 'component',\n    selector: declaration.selector,\n    type: new WrappedNodeExpr(declaration.type),\n    inputs: declaration.inputs ?? [],\n    outputs: declaration.outputs ?? [],\n    exportAs: declaration.exportAs ?? null\n  };\n}\nfunction convertPipeMapToMetadata(pipes) {\n  if (!pipes) {\n    return [];\n  }\n  return Object.keys(pipes).map(name => {\n    return {\n      kind: R3TemplateDependencyKind.Pipe,\n      name,\n      type: new WrappedNodeExpr(pipes[name])\n    };\n  });\n}\nfunction convertPipeDeclarationToMetadata(pipe) {\n  return {\n    kind: R3TemplateDependencyKind.Pipe,\n    name: pipe.name,\n    type: new WrappedNodeExpr(pipe.type)\n  };\n}\nfunction parseJitTemplate(template, typeName, sourceMapUrl, preserveWhitespaces, deferBlockDependencies) {\n  const parsed = parseTemplate(template, sourceMapUrl, {\n    preserveWhitespaces\n  });\n  if (parsed.errors !== null) {\n    const errors = parsed.errors.map(err => err.toString()).join(', ');\n    throw new Error(`Errors during JIT compilation of template for ${typeName}: ${errors}`);\n  }\n  const binder = new R3TargetBinder(null);\n  const boundTarget = binder.bind({\n    template: parsed.nodes\n  });\n  return {\n    template: parsed,\n    defer: createR3ComponentDeferMetadata(boundTarget, deferBlockDependencies)\n  };\n}\nfunction convertToProviderExpression(obj, property) {\n  if (obj.hasOwnProperty(property)) {\n    return createMayBeForwardRefExpression(new WrappedNodeExpr(obj[property]), 0);\n  } else {\n    return undefined;\n  }\n}\nfunction wrapExpression(obj, property) {\n  if (obj.hasOwnProperty(property)) {\n    return new WrappedNodeExpr(obj[property]);\n  } else {\n    return undefined;\n  }\n}\nfunction computeProvidedIn(providedIn) {\n  const expression = typeof providedIn === 'function' ? new WrappedNodeExpr(providedIn) : new LiteralExpr(providedIn ?? null);\n  return createMayBeForwardRefExpression(expression, 0);\n}\nfunction convertR3DependencyMetadataArray(facades) {\n  return facades == null ? null : facades.map(convertR3DependencyMetadata);\n}\nfunction convertR3DependencyMetadata(facade) {\n  const isAttributeDep = facade.attribute != null;\n  const rawToken = facade.token === null ? null : new WrappedNodeExpr(facade.token);\n  const token = isAttributeDep ? new WrappedNodeExpr(facade.attribute) : rawToken;\n  return createR3DependencyMetadata(token, isAttributeDep, facade.host, facade.optional, facade.self, facade.skipSelf);\n}\nfunction convertR3DeclareDependencyMetadata(facade) {\n  const isAttributeDep = facade.attribute ?? false;\n  const token = facade.token === null ? null : new WrappedNodeExpr(facade.token);\n  return createR3DependencyMetadata(token, isAttributeDep, facade.host ?? false, facade.optional ?? false, facade.self ?? false, facade.skipSelf ?? false);\n}\nfunction createR3DependencyMetadata(token, isAttributeDep, host, optional, self, skipSelf) {\n  const attributeNameType = isAttributeDep ? literal('unknown') : null;\n  return {\n    token,\n    attributeNameType,\n    host,\n    optional,\n    self,\n    skipSelf\n  };\n}\nfunction createR3ComponentDeferMetadata(boundTarget, deferBlockDependencies) {\n  const deferredBlocks = boundTarget.getDeferBlocks();\n  const blocks = new Map();\n  for (let i = 0; i < deferredBlocks.length; i++) {\n    const dependencyFn = deferBlockDependencies?.[i];\n    blocks.set(deferredBlocks[i], dependencyFn ? new WrappedNodeExpr(dependencyFn) : null);\n  }\n  return {\n    mode: 0,\n    blocks\n  };\n}\nfunction extractHostBindings(propMetadata, sourceSpan, host) {\n  const bindings = parseHostBindings(host || {});\n  const errors = verifyHostBindings(bindings, sourceSpan);\n  if (errors.length) {\n    throw new Error(errors.map(error => error.msg).join('\\n'));\n  }\n  for (const field in propMetadata) {\n    if (propMetadata.hasOwnProperty(field)) {\n      propMetadata[field].forEach(ann => {\n        if (isHostBinding(ann)) {\n          bindings.properties[ann.hostPropertyName || field] = getSafePropertyAccessString('this', field);\n        } else if (isHostListener(ann)) {\n          bindings.listeners[ann.eventName || field] = `${field}(${(ann.args || []).join(',')})`;\n        }\n      });\n    }\n  }\n  return bindings;\n}\nfunction isHostBinding(value) {\n  return value.ngMetadataName === 'HostBinding';\n}\nfunction isHostListener(value) {\n  return value.ngMetadataName === 'HostListener';\n}\nfunction isInput(value) {\n  return value.ngMetadataName === 'Input';\n}\nfunction isOutput(value) {\n  return value.ngMetadataName === 'Output';\n}\nfunction inputsPartialMetadataToInputMetadata(inputs) {\n  return Object.keys(inputs).reduce((result, minifiedClassName) => {\n    const value = inputs[minifiedClassName];\n    if (typeof value === 'string' || Array.isArray(value)) {\n      result[minifiedClassName] = parseLegacyInputPartialOutput(value);\n    } else {\n      result[minifiedClassName] = {\n        bindingPropertyName: value.publicName,\n        classPropertyName: minifiedClassName,\n        transformFunction: value.transformFunction !== null ? new WrappedNodeExpr(value.transformFunction) : null,\n        required: value.isRequired,\n        isSignal: value.isSignal\n      };\n    }\n    return result;\n  }, {});\n}\nfunction parseLegacyInputPartialOutput(value) {\n  if (typeof value === 'string') {\n    return {\n      bindingPropertyName: value,\n      classPropertyName: value,\n      transformFunction: null,\n      required: false,\n      isSignal: false\n    };\n  }\n  return {\n    bindingPropertyName: value[0],\n    classPropertyName: value[1],\n    transformFunction: value[2] ? new WrappedNodeExpr(value[2]) : null,\n    required: false,\n    isSignal: false\n  };\n}\nfunction parseInputsArray(values) {\n  return values.reduce((results, value) => {\n    if (typeof value === 'string') {\n      const [bindingPropertyName, classPropertyName] = parseMappingString(value);\n      results[classPropertyName] = {\n        bindingPropertyName,\n        classPropertyName,\n        required: false,\n        isSignal: false,\n        transformFunction: null\n      };\n    } else {\n      results[value.name] = {\n        bindingPropertyName: value.alias || value.name,\n        classPropertyName: value.name,\n        required: value.required || false,\n        isSignal: false,\n        transformFunction: value.transform != null ? new WrappedNodeExpr(value.transform) : null\n      };\n    }\n    return results;\n  }, {});\n}\nfunction parseMappingStringArray(values) {\n  return values.reduce((results, value) => {\n    const [alias, fieldName] = parseMappingString(value);\n    results[fieldName] = alias;\n    return results;\n  }, {});\n}\nfunction parseMappingString(value) {\n  const [fieldName, bindingPropertyName] = value.split(':', 2).map(str => str.trim());\n  return [bindingPropertyName ?? fieldName, fieldName];\n}\nfunction convertDeclarePipeFacadeToMetadata(declaration) {\n  return {\n    name: declaration.type.name,\n    type: wrapReference(declaration.type),\n    typeArgumentCount: 0,\n    pipeName: declaration.name,\n    deps: null,\n    pure: declaration.pure ?? true,\n    isStandalone: declaration.isStandalone ?? getJitStandaloneDefaultForVersion(declaration.version)\n  };\n}\nfunction convertDeclareInjectorFacadeToMetadata(declaration) {\n  return {\n    name: declaration.type.name,\n    type: wrapReference(declaration.type),\n    providers: declaration.providers !== undefined && declaration.providers.length > 0 ? new WrappedNodeExpr(declaration.providers) : null,\n    imports: declaration.imports !== undefined ? declaration.imports.map(i => new WrappedNodeExpr(i)) : []\n  };\n}\nfunction publishFacade(global) {\n  const ng = global.ng || (global.ng = {});\n  ng.ÉµcompilerFacade = new CompilerFacadeImpl();\n}\nclass CompilerConfig {\n  defaultEncapsulation;\n  preserveWhitespaces;\n  strictInjectionParameters;\n  constructor({\n    defaultEncapsulation = ViewEncapsulation$1.Emulated,\n    preserveWhitespaces,\n    strictInjectionParameters\n  } = {}) {\n    this.defaultEncapsulation = defaultEncapsulation;\n    this.preserveWhitespaces = preserveWhitespacesDefault(noUndefined(preserveWhitespaces));\n    this.strictInjectionParameters = strictInjectionParameters === true;\n  }\n}\nfunction preserveWhitespacesDefault(preserveWhitespacesOption, defaultSetting = false) {\n  return preserveWhitespacesOption === null ? defaultSetting : preserveWhitespacesOption;\n}\nconst _I18N_ATTR = 'i18n';\nconst _I18N_ATTR_PREFIX = 'i18n-';\nconst _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;\nconst MEANING_SEPARATOR = '|';\nconst ID_SEPARATOR = '@@';\nlet i18nCommentsWarned = false;\nfunction extractMessages(nodes, implicitTags, implicitAttrs, preserveSignificantWhitespace) {\n  const visitor = new _Visitor(implicitTags, implicitAttrs, preserveSignificantWhitespace);\n  return visitor.extract(nodes);\n}\nfunction mergeTranslations(nodes, translations, implicitTags, implicitAttrs) {\n  const visitor = new _Visitor(implicitTags, implicitAttrs);\n  return visitor.merge(nodes, translations);\n}\nclass ExtractionResult {\n  messages;\n  errors;\n  constructor(messages, errors) {\n    this.messages = messages;\n    this.errors = errors;\n  }\n}\nvar _VisitorMode;\n(function (_VisitorMode) {\n  _VisitorMode[_VisitorMode[\"Extract\"] = 0] = \"Extract\";\n  _VisitorMode[_VisitorMode[\"Merge\"] = 1] = \"Merge\";\n})(_VisitorMode || (_VisitorMode = {}));\nclass _Visitor {\n  _implicitTags;\n  _implicitAttrs;\n  _preserveSignificantWhitespace;\n  _depth;\n  _inI18nNode;\n  _inImplicitNode;\n  _inI18nBlock;\n  _blockMeaningAndDesc;\n  _blockChildren;\n  _blockStartDepth;\n  _inIcu;\n  _msgCountAtSectionStart;\n  _errors;\n  _mode;\n  _messages;\n  _translations;\n  _createI18nMessage;\n  constructor(_implicitTags, _implicitAttrs, _preserveSignificantWhitespace = true) {\n    this._implicitTags = _implicitTags;\n    this._implicitAttrs = _implicitAttrs;\n    this._preserveSignificantWhitespace = _preserveSignificantWhitespace;\n  }\n  extract(nodes) {\n    this._init(_VisitorMode.Extract);\n    nodes.forEach(node => node.visit(this, null));\n    if (this._inI18nBlock) {\n      this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n    }\n    return new ExtractionResult(this._messages, this._errors);\n  }\n  merge(nodes, translations) {\n    this._init(_VisitorMode.Merge);\n    this._translations = translations;\n    const wrapper = new Element('wrapper', [], [], nodes, false, undefined, undefined, undefined, false);\n    const translatedNode = wrapper.visit(this, null);\n    if (this._inI18nBlock) {\n      this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n    }\n    return new ParseTreeResult(translatedNode.children, this._errors);\n  }\n  visitExpansionCase(icuCase, context) {\n    const expression = visitAll(this, icuCase.expression, context);\n    if (this._mode === _VisitorMode.Merge) {\n      return new ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);\n    }\n  }\n  visitExpansion(icu, context) {\n    this._mayBeAddBlockChildren(icu);\n    const wasInIcu = this._inIcu;\n    if (!this._inIcu) {\n      if (this._isInTranslatableSection) {\n        this._addMessage([icu]);\n      }\n      this._inIcu = true;\n    }\n    const cases = visitAll(this, icu.cases, context);\n    if (this._mode === _VisitorMode.Merge) {\n      icu = new Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);\n    }\n    this._inIcu = wasInIcu;\n    return icu;\n  }\n  visitComment(comment, context) {\n    const isOpening = _isOpeningComment(comment);\n    if (isOpening && this._isInTranslatableSection) {\n      this._reportError(comment, 'Could not start a block inside a translatable section');\n      return;\n    }\n    const isClosing = _isClosingComment(comment);\n    if (isClosing && !this._inI18nBlock) {\n      this._reportError(comment, 'Trying to close an unopened block');\n      return;\n    }\n    if (!this._inI18nNode && !this._inIcu) {\n      if (!this._inI18nBlock) {\n        if (isOpening) {\n          if (!i18nCommentsWarned && console && console.warn) {\n            i18nCommentsWarned = true;\n            const details = comment.sourceSpan.details ? `, ${comment.sourceSpan.details}` : '';\n            console.warn(`I18n comments are deprecated, use an <ng-container> element instead (${comment.sourceSpan.start}${details})`);\n          }\n          this._inI18nBlock = true;\n          this._blockStartDepth = this._depth;\n          this._blockChildren = [];\n          this._blockMeaningAndDesc = comment.value.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();\n          this._openTranslatableSection(comment);\n        }\n      } else {\n        if (isClosing) {\n          if (this._depth == this._blockStartDepth) {\n            this._closeTranslatableSection(comment, this._blockChildren);\n            this._inI18nBlock = false;\n            const message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc);\n            const nodes = this._translateMessage(comment, message);\n            return visitAll(this, nodes);\n          } else {\n            this._reportError(comment, 'I18N blocks should not cross element boundaries');\n            return;\n          }\n        }\n      }\n    }\n  }\n  visitText(text, context) {\n    if (this._isInTranslatableSection) {\n      this._mayBeAddBlockChildren(text);\n    }\n    return text;\n  }\n  visitElement(el, context) {\n    return this._visitElementLike(el, context);\n  }\n  visitAttribute(attribute, context) {\n    throw new Error('unreachable code');\n  }\n  visitBlock(block, context) {\n    visitAll(this, block.children, context);\n  }\n  visitBlockParameter(parameter, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {\n    return this._visitElementLike(component, context);\n  }\n  visitDirective(directive, context) {\n    throw new Error('unreachable code');\n  }\n  _init(mode) {\n    this._mode = mode;\n    this._inI18nBlock = false;\n    this._inI18nNode = false;\n    this._depth = 0;\n    this._inIcu = false;\n    this._msgCountAtSectionStart = undefined;\n    this._errors = [];\n    this._messages = [];\n    this._inImplicitNode = false;\n    this._createI18nMessage = createI18nMessageFactory(DEFAULT_CONTAINER_BLOCKS, !this._preserveSignificantWhitespace, this._preserveSignificantWhitespace);\n  }\n  _visitElementLike(node, context) {\n    this._mayBeAddBlockChildren(node);\n    this._depth++;\n    const wasInI18nNode = this._inI18nNode;\n    const wasInImplicitNode = this._inImplicitNode;\n    let childNodes = [];\n    let translatedChildNodes = undefined;\n    const nodeName = node instanceof Component ? node.tagName : node.name;\n    const i18nAttr = _getI18nAttr(node);\n    const i18nMeta = i18nAttr ? i18nAttr.value : '';\n    const isImplicit = this._implicitTags.some(tag => nodeName === tag) && !this._inIcu && !this._isInTranslatableSection;\n    const isTopLevelImplicit = !wasInImplicitNode && isImplicit;\n    this._inImplicitNode = wasInImplicitNode || isImplicit;\n    if (!this._isInTranslatableSection && !this._inIcu) {\n      if (i18nAttr || isTopLevelImplicit) {\n        this._inI18nNode = true;\n        const message = this._addMessage(node.children, i18nMeta);\n        translatedChildNodes = this._translateMessage(node, message);\n      }\n      if (this._mode == _VisitorMode.Extract) {\n        const isTranslatable = i18nAttr || isTopLevelImplicit;\n        if (isTranslatable) this._openTranslatableSection(node);\n        visitAll(this, node.children);\n        if (isTranslatable) this._closeTranslatableSection(node, node.children);\n      }\n    } else {\n      if (i18nAttr || isTopLevelImplicit) {\n        this._reportError(node, 'Could not mark an element as translatable inside a translatable section');\n      }\n      if (this._mode == _VisitorMode.Extract) {\n        visitAll(this, node.children);\n      }\n    }\n    if (this._mode === _VisitorMode.Merge) {\n      const visitNodes = translatedChildNodes || node.children;\n      visitNodes.forEach(child => {\n        const visited = child.visit(this, context);\n        if (visited && !this._isInTranslatableSection) {\n          childNodes = childNodes.concat(visited);\n        }\n      });\n    }\n    this._visitAttributesOf(node);\n    this._depth--;\n    this._inI18nNode = wasInI18nNode;\n    this._inImplicitNode = wasInImplicitNode;\n    if (this._mode === _VisitorMode.Merge) {\n      if (node instanceof Element) {\n        return new Element(node.name, this._translateAttributes(node), this._translateDirectives(node), childNodes, node.isSelfClosing, node.sourceSpan, node.startSourceSpan, node.endSourceSpan, node.isVoid);\n      } else {\n        return new Component(node.componentName, node.tagName, node.fullName, this._translateAttributes(node), this._translateDirectives(node), childNodes, node.isSelfClosing, node.sourceSpan, node.startSourceSpan, node.endSourceSpan);\n      }\n    }\n    return null;\n  }\n  _visitAttributesOf(el) {\n    const explicitAttrNameToValue = {};\n    const implicitAttrNames = this._implicitAttrs[el instanceof Component ? el.tagName || '' : el.name] || [];\n    el.attrs.filter(attr => attr instanceof Attribute && attr.name.startsWith(_I18N_ATTR_PREFIX)).forEach(attr => {\n      explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] = attr.value;\n    });\n    el.attrs.forEach(attr => {\n      if (attr.name in explicitAttrNameToValue) {\n        this._addMessage([attr], explicitAttrNameToValue[attr.name]);\n      } else if (implicitAttrNames.some(name => attr.name === name)) {\n        this._addMessage([attr]);\n      }\n    });\n  }\n  _addMessage(ast, msgMeta) {\n    if (ast.length == 0 || this._isEmptyAttributeValue(ast) || this._isPlaceholderOnlyAttributeValue(ast) || this._isPlaceholderOnlyMessage(ast)) {\n      return null;\n    }\n    const {\n      meaning,\n      description,\n      id\n    } = _parseMessageMeta(msgMeta);\n    const message = this._createI18nMessage(ast, meaning, description, id);\n    this._messages.push(message);\n    return message;\n  }\n  _isEmptyAttributeValue(ast) {\n    if (!isAttrNode(ast)) return false;\n    const node = ast[0];\n    return node.value.trim() === '';\n  }\n  _isPlaceholderOnlyAttributeValue(ast) {\n    if (!isAttrNode(ast)) return false;\n    const tokens = ast[0].valueTokens ?? [];\n    const interpolations = tokens.filter(token => token.type === 17);\n    const plainText = tokens.filter(token => token.type === 16).map(token => token.parts[0].trim()).join('');\n    return interpolations.length === 1 && plainText === '';\n  }\n  _isPlaceholderOnlyMessage(ast) {\n    if (!isTextNode(ast)) return false;\n    const tokens = ast[0].tokens;\n    const interpolations = tokens.filter(token => token.type === 8);\n    const plainText = tokens.filter(token => token.type === 5).map(token => token.parts[0].trim()).join('');\n    return interpolations.length === 1 && plainText === '';\n  }\n  _translateMessage(el, message) {\n    if (message && this._mode === _VisitorMode.Merge) {\n      const nodes = this._translations.get(message);\n      if (nodes) {\n        return nodes;\n      }\n      this._reportError(el, `Translation unavailable for message id=\"${this._translations.digest(message)}\"`);\n    }\n    return [];\n  }\n  _translateAttributes(node) {\n    const i18nParsedMessageMeta = {};\n    const translatedAttributes = [];\n    node.attrs.forEach(attr => {\n      if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n        i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] = _parseMessageMeta(attr.value);\n      }\n    });\n    node.attrs.forEach(attr => {\n      if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n        return;\n      }\n      if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {\n        const {\n          meaning,\n          description,\n          id\n        } = i18nParsedMessageMeta[attr.name];\n        const message = this._createI18nMessage([attr], meaning, description, id);\n        const nodes = this._translations.get(message);\n        if (nodes) {\n          if (nodes.length == 0) {\n            translatedAttributes.push(new Attribute(attr.name, '', attr.sourceSpan, undefined, undefined, undefined, undefined));\n          } else if (nodes[0] instanceof Text) {\n            const value = nodes[0].value;\n            translatedAttributes.push(new Attribute(attr.name, value, attr.sourceSpan, undefined, undefined, undefined, undefined));\n          } else {\n            this._reportError(node, `Unexpected translation for attribute \"${attr.name}\" (id=\"${id || this._translations.digest(message)}\")`);\n          }\n        } else {\n          this._reportError(node, `Translation unavailable for attribute \"${attr.name}\" (id=\"${id || this._translations.digest(message)}\")`);\n        }\n      } else {\n        translatedAttributes.push(attr);\n      }\n    });\n    return translatedAttributes;\n  }\n  _translateDirectives(node) {\n    return node.directives.map(dir => new Directive(dir.name, this._translateAttributes(dir), dir.sourceSpan, dir.startSourceSpan, dir.endSourceSpan));\n  }\n  _mayBeAddBlockChildren(node) {\n    if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {\n      this._blockChildren.push(node);\n    }\n  }\n  _openTranslatableSection(node) {\n    if (this._isInTranslatableSection) {\n      this._reportError(node, 'Unexpected section start');\n    } else {\n      this._msgCountAtSectionStart = this._messages.length;\n    }\n  }\n  get _isInTranslatableSection() {\n    return this._msgCountAtSectionStart !== void 0;\n  }\n  _closeTranslatableSection(node, directChildren) {\n    if (!this._isInTranslatableSection) {\n      this._reportError(node, 'Unexpected section end');\n      return;\n    }\n    const startIndex = this._msgCountAtSectionStart;\n    const significantChildren = directChildren.reduce((count, node) => count + (node instanceof Comment ? 0 : 1), 0);\n    if (significantChildren == 1) {\n      for (let i = this._messages.length - 1; i >= startIndex; i--) {\n        const ast = this._messages[i].nodes;\n        if (!(ast.length == 1 && ast[0] instanceof Text$2)) {\n          this._messages.splice(i, 1);\n          break;\n        }\n      }\n    }\n    this._msgCountAtSectionStart = undefined;\n  }\n  _reportError(node, msg) {\n    this._errors.push(new ParseError(node.sourceSpan, msg));\n  }\n}\nfunction _isOpeningComment(n) {\n  return !!(n instanceof Comment && n.value && n.value.startsWith('i18n'));\n}\nfunction _isClosingComment(n) {\n  return !!(n instanceof Comment && n.value && n.value === '/i18n');\n}\nfunction _getI18nAttr(p) {\n  return p.attrs.find(attr => attr instanceof Attribute && attr.name === _I18N_ATTR) || null;\n}\nfunction _parseMessageMeta(i18n) {\n  if (!i18n) return {\n    meaning: '',\n    description: '',\n    id: ''\n  };\n  const idIndex = i18n.indexOf(ID_SEPARATOR);\n  const descIndex = i18n.indexOf(MEANING_SEPARATOR);\n  const [meaningAndDesc, id] = idIndex > -1 ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''];\n  const [meaning, description] = descIndex > -1 ? [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] : ['', meaningAndDesc];\n  return {\n    meaning,\n    description,\n    id: id.trim()\n  };\n}\nfunction isTextNode(ast) {\n  return ast.length === 1 && ast[0] instanceof Text;\n}\nfunction isAttrNode(ast) {\n  return ast.length === 1 && ast[0] instanceof Attribute;\n}\nclass XmlTagDefinition {\n  closedByParent = false;\n  implicitNamespacePrefix = null;\n  isVoid = false;\n  ignoreFirstLf = false;\n  canSelfClose = true;\n  preventNamespaceInheritance = false;\n  requireExtraParent(currentParent) {\n    return false;\n  }\n  isClosedByChild(name) {\n    return false;\n  }\n  getContentType() {\n    return TagContentType.PARSABLE_DATA;\n  }\n}\nconst _TAG_DEFINITION = new XmlTagDefinition();\nfunction getXmlTagDefinition(tagName) {\n  return _TAG_DEFINITION;\n}\nclass XmlParser extends Parser$1 {\n  constructor() {\n    super(getXmlTagDefinition);\n  }\n  parse(source, url, options = {}) {\n    return super.parse(source, url, {\n      ...options,\n      tokenizeBlocks: false,\n      tokenizeLet: false,\n      selectorlessEnabled: false\n    });\n  }\n}\nconst _VERSION$1 = '1.2';\nconst _XMLNS$1 = 'urn:oasis:names:tc:xliff:document:1.2';\nconst _DEFAULT_SOURCE_LANG$1 = 'en';\nconst _PLACEHOLDER_TAG$2 = 'x';\nconst _MARKER_TAG$1 = 'mrk';\nconst _FILE_TAG = 'file';\nconst _SOURCE_TAG$1 = 'source';\nconst _SEGMENT_SOURCE_TAG = 'seg-source';\nconst _ALT_TRANS_TAG = 'alt-trans';\nconst _TARGET_TAG$1 = 'target';\nconst _UNIT_TAG$1 = 'trans-unit';\nconst _CONTEXT_GROUP_TAG = 'context-group';\nconst _CONTEXT_TAG = 'context';\nclass Xliff extends Serializer {\n  write(messages, locale) {\n    const visitor = new _WriteVisitor$1();\n    const transUnits = [];\n    messages.forEach(message => {\n      let contextTags = [];\n      message.sources.forEach(source => {\n        let contextGroupTag = new Tag(_CONTEXT_GROUP_TAG, {\n          purpose: 'location'\n        });\n        contextGroupTag.children.push(new CR(10), new Tag(_CONTEXT_TAG, {\n          'context-type': 'sourcefile'\n        }, [new Text$1(source.filePath)]), new CR(10), new Tag(_CONTEXT_TAG, {\n          'context-type': 'linenumber'\n        }, [new Text$1(`${source.startLine}`)]), new CR(8));\n        contextTags.push(new CR(8), contextGroupTag);\n      });\n      const transUnit = new Tag(_UNIT_TAG$1, {\n        id: message.id,\n        datatype: 'html'\n      });\n      transUnit.children.push(new CR(8), new Tag(_SOURCE_TAG$1, {}, visitor.serialize(message.nodes)), ...contextTags);\n      if (message.description) {\n        transUnit.children.push(new CR(8), new Tag('note', {\n          priority: '1',\n          from: 'description'\n        }, [new Text$1(message.description)]));\n      }\n      if (message.meaning) {\n        transUnit.children.push(new CR(8), new Tag('note', {\n          priority: '1',\n          from: 'meaning'\n        }, [new Text$1(message.meaning)]));\n      }\n      transUnit.children.push(new CR(6));\n      transUnits.push(new CR(6), transUnit);\n    });\n    const body = new Tag('body', {}, [...transUnits, new CR(4)]);\n    const file = new Tag('file', {\n      'source-language': locale || _DEFAULT_SOURCE_LANG$1,\n      datatype: 'plaintext',\n      original: 'ng2.template'\n    }, [new CR(4), body, new CR(2)]);\n    const xliff = new Tag('xliff', {\n      version: _VERSION$1,\n      xmlns: _XMLNS$1\n    }, [new CR(2), file, new CR()]);\n    return serialize$1([new Declaration({\n      version: '1.0',\n      encoding: 'UTF-8'\n    }), new CR(), xliff, new CR()]);\n  }\n  load(content, url) {\n    const xliffParser = new XliffParser();\n    const {\n      locale,\n      msgIdToHtml,\n      errors\n    } = xliffParser.parse(content, url);\n    const i18nNodesByMsgId = {};\n    const converter = new XmlToI18n$2();\n    Object.keys(msgIdToHtml).forEach(msgId => {\n      const {\n        i18nNodes,\n        errors: e\n      } = converter.convert(msgIdToHtml[msgId], url);\n      errors.push(...e);\n      i18nNodesByMsgId[msgId] = i18nNodes;\n    });\n    if (errors.length) {\n      throw new Error(`xliff parse errors:\\n${errors.join('\\n')}`);\n    }\n    return {\n      locale: locale,\n      i18nNodesByMsgId\n    };\n  }\n  digest(message) {\n    return digest$1(message);\n  }\n}\nlet _WriteVisitor$1 = class _WriteVisitor {\n  visitText(text, context) {\n    return [new Text$1(text.value)];\n  }\n  visitContainer(container, context) {\n    const nodes = [];\n    container.children.forEach(node => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n  visitIcu(icu, context) {\n    const nodes = [new Text$1(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n    Object.keys(icu.cases).forEach(c => {\n      nodes.push(new Text$1(`${c} {`), ...icu.cases[c].visit(this), new Text$1(`} `));\n    });\n    nodes.push(new Text$1(`}`));\n    return nodes;\n  }\n  visitTagPlaceholder(ph, context) {\n    const ctype = getCtypeForTag(ph.tag);\n    if (ph.isVoid) {\n      return [new Tag(_PLACEHOLDER_TAG$2, {\n        id: ph.startName,\n        ctype,\n        'equiv-text': `<${ph.tag}/>`\n      })];\n    }\n    const startTagPh = new Tag(_PLACEHOLDER_TAG$2, {\n      id: ph.startName,\n      ctype,\n      'equiv-text': `<${ph.tag}>`\n    });\n    const closeTagPh = new Tag(_PLACEHOLDER_TAG$2, {\n      id: ph.closeName,\n      ctype,\n      'equiv-text': `</${ph.tag}>`\n    });\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n  visitPlaceholder(ph, context) {\n    return [new Tag(_PLACEHOLDER_TAG$2, {\n      id: ph.name,\n      'equiv-text': `{{${ph.value}}}`\n    })];\n  }\n  visitBlockPlaceholder(ph, context) {\n    const ctype = `x-${ph.name.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;\n    const startTagPh = new Tag(_PLACEHOLDER_TAG$2, {\n      id: ph.startName,\n      ctype,\n      'equiv-text': `@${ph.name}`\n    });\n    const closeTagPh = new Tag(_PLACEHOLDER_TAG$2, {\n      id: ph.closeName,\n      ctype,\n      'equiv-text': `}`\n    });\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n  visitIcuPlaceholder(ph, context) {\n    const equivText = `{${ph.value.expression}, ${ph.value.type}, ${Object.keys(ph.value.cases).map(value => value + ' {...}').join(' ')}}`;\n    return [new Tag(_PLACEHOLDER_TAG$2, {\n      id: ph.name,\n      'equiv-text': equivText\n    })];\n  }\n  serialize(nodes) {\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n};\nclass XliffParser {\n  _unitMlString;\n  _errors;\n  _msgIdToHtml;\n  _locale = null;\n  parse(xliff, url) {\n    this._unitMlString = null;\n    this._msgIdToHtml = {};\n    const xml = new XmlParser().parse(xliff, url);\n    this._errors = xml.errors;\n    visitAll(this, xml.rootNodes, null);\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors,\n      locale: this._locale\n    };\n  }\n  visitElement(element, context) {\n    switch (element.name) {\n      case _UNIT_TAG$1:\n        this._unitMlString = null;\n        const idAttr = element.attrs.find(attr => attr.name === 'id');\n        if (!idAttr) {\n          this._addError(element, `<${_UNIT_TAG$1}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            visitAll(this, element.children, null);\n            if (typeof this._unitMlString === 'string') {\n              this._msgIdToHtml[id] = this._unitMlString;\n            } else {\n              this._addError(element, `Message ${id} misses a translation`);\n            }\n          }\n        }\n        break;\n      case _SOURCE_TAG$1:\n      case _SEGMENT_SOURCE_TAG:\n      case _ALT_TRANS_TAG:\n        break;\n      case _TARGET_TAG$1:\n        const innerTextStart = element.startSourceSpan.end.offset;\n        const innerTextEnd = element.endSourceSpan.start.offset;\n        const content = element.startSourceSpan.start.file.content;\n        const innerText = content.slice(innerTextStart, innerTextEnd);\n        this._unitMlString = innerText;\n        break;\n      case _FILE_TAG:\n        const localeAttr = element.attrs.find(attr => attr.name === 'target-language');\n        if (localeAttr) {\n          this._locale = localeAttr.value;\n        }\n        visitAll(this, element.children, null);\n        break;\n      default:\n        visitAll(this, element.children, null);\n    }\n  }\n  visitAttribute(attribute, context) {}\n  visitText(text, context) {}\n  visitComment(comment, context) {}\n  visitExpansion(expansion, context) {}\n  visitExpansionCase(expansionCase, context) {}\n  visitBlock(block, context) {}\n  visitBlockParameter(parameter, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {}\n  visitDirective(directive, context) {}\n  _addError(node, message) {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n}\nlet XmlToI18n$2 = class XmlToI18n {\n  _errors;\n  convert(message, url) {\n    const xmlIcu = new XmlParser().parse(message, url, {\n      tokenizeExpansionForms: true\n    });\n    this._errors = xmlIcu.errors;\n    const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ? [] : [].concat(...visitAll(this, xmlIcu.rootNodes));\n    return {\n      i18nNodes: i18nNodes,\n      errors: this._errors\n    };\n  }\n  visitText(text, context) {\n    return new Text$2(text.value, text.sourceSpan);\n  }\n  visitElement(el, context) {\n    if (el.name === _PLACEHOLDER_TAG$2) {\n      const nameAttr = el.attrs.find(attr => attr.name === 'id');\n      if (nameAttr) {\n        return new Placeholder('', nameAttr.value, el.sourceSpan);\n      }\n      this._addError(el, `<${_PLACEHOLDER_TAG$2}> misses the \"id\" attribute`);\n      return null;\n    }\n    if (el.name === _MARKER_TAG$1) {\n      return [].concat(...visitAll(this, el.children));\n    }\n    this._addError(el, `Unexpected tag`);\n    return null;\n  }\n  visitExpansion(icu, context) {\n    const caseMap = {};\n    visitAll(this, icu.cases).forEach(c => {\n      caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n    });\n    return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n  visitExpansionCase(icuCase, context) {\n    return {\n      value: icuCase.value,\n      nodes: visitAll(this, icuCase.expression)\n    };\n  }\n  visitComment(comment, context) {}\n  visitAttribute(attribute, context) {}\n  visitBlock(block, context) {}\n  visitBlockParameter(parameter, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {\n    this._addError(component, 'Unexpected node');\n  }\n  visitDirective(directive, context) {\n    this._addError(directive, 'Unexpected node');\n  }\n  _addError(node, message) {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n};\nfunction getCtypeForTag(tag) {\n  switch (tag.toLowerCase()) {\n    case 'br':\n      return 'lb';\n    case 'img':\n      return 'image';\n    default:\n      return `x-${tag}`;\n  }\n}\nconst _VERSION = '2.0';\nconst _XMLNS = 'urn:oasis:names:tc:xliff:document:2.0';\nconst _DEFAULT_SOURCE_LANG = 'en';\nconst _PLACEHOLDER_TAG$1 = 'ph';\nconst _PLACEHOLDER_SPANNING_TAG = 'pc';\nconst _MARKER_TAG = 'mrk';\nconst _XLIFF_TAG = 'xliff';\nconst _SOURCE_TAG = 'source';\nconst _TARGET_TAG = 'target';\nconst _UNIT_TAG = 'unit';\nclass Xliff2 extends Serializer {\n  write(messages, locale) {\n    const visitor = new _WriteVisitor();\n    const units = [];\n    messages.forEach(message => {\n      const unit = new Tag(_UNIT_TAG, {\n        id: message.id\n      });\n      const notes = new Tag('notes');\n      if (message.description || message.meaning) {\n        if (message.description) {\n          notes.children.push(new CR(8), new Tag('note', {\n            category: 'description'\n          }, [new Text$1(message.description)]));\n        }\n        if (message.meaning) {\n          notes.children.push(new CR(8), new Tag('note', {\n            category: 'meaning'\n          }, [new Text$1(message.meaning)]));\n        }\n      }\n      message.sources.forEach(source => {\n        notes.children.push(new CR(8), new Tag('note', {\n          category: 'location'\n        }, [new Text$1(`${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? ',' + source.endLine : ''}`)]));\n      });\n      notes.children.push(new CR(6));\n      unit.children.push(new CR(6), notes);\n      const segment = new Tag('segment');\n      segment.children.push(new CR(8), new Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)), new CR(6));\n      unit.children.push(new CR(6), segment, new CR(4));\n      units.push(new CR(4), unit);\n    });\n    const file = new Tag('file', {\n      'original': 'ng.template',\n      id: 'ngi18n'\n    }, [...units, new CR(2)]);\n    const xliff = new Tag(_XLIFF_TAG, {\n      version: _VERSION,\n      xmlns: _XMLNS,\n      srcLang: locale || _DEFAULT_SOURCE_LANG\n    }, [new CR(2), file, new CR()]);\n    return serialize$1([new Declaration({\n      version: '1.0',\n      encoding: 'UTF-8'\n    }), new CR(), xliff, new CR()]);\n  }\n  load(content, url) {\n    const xliff2Parser = new Xliff2Parser();\n    const {\n      locale,\n      msgIdToHtml,\n      errors\n    } = xliff2Parser.parse(content, url);\n    const i18nNodesByMsgId = {};\n    const converter = new XmlToI18n$1();\n    Object.keys(msgIdToHtml).forEach(msgId => {\n      const {\n        i18nNodes,\n        errors: e\n      } = converter.convert(msgIdToHtml[msgId], url);\n      errors.push(...e);\n      i18nNodesByMsgId[msgId] = i18nNodes;\n    });\n    if (errors.length) {\n      throw new Error(`xliff2 parse errors:\\n${errors.join('\\n')}`);\n    }\n    return {\n      locale: locale,\n      i18nNodesByMsgId\n    };\n  }\n  digest(message) {\n    return decimalDigest(message);\n  }\n}\nclass _WriteVisitor {\n  _nextPlaceholderId = 0;\n  visitText(text, context) {\n    return [new Text$1(text.value)];\n  }\n  visitContainer(container, context) {\n    const nodes = [];\n    container.children.forEach(node => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n  visitIcu(icu, context) {\n    const nodes = [new Text$1(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n    Object.keys(icu.cases).forEach(c => {\n      nodes.push(new Text$1(`${c} {`), ...icu.cases[c].visit(this), new Text$1(`} `));\n    });\n    nodes.push(new Text$1(`}`));\n    return nodes;\n  }\n  visitTagPlaceholder(ph, context) {\n    const type = getTypeForTag(ph.tag);\n    if (ph.isVoid) {\n      const tagPh = new Tag(_PLACEHOLDER_TAG$1, {\n        id: (this._nextPlaceholderId++).toString(),\n        equiv: ph.startName,\n        type: type,\n        disp: `<${ph.tag}/>`\n      });\n      return [tagPh];\n    }\n    const tagPc = new Tag(_PLACEHOLDER_SPANNING_TAG, {\n      id: (this._nextPlaceholderId++).toString(),\n      equivStart: ph.startName,\n      equivEnd: ph.closeName,\n      type: type,\n      dispStart: `<${ph.tag}>`,\n      dispEnd: `</${ph.tag}>`\n    });\n    const nodes = [].concat(...ph.children.map(node => node.visit(this)));\n    if (nodes.length) {\n      nodes.forEach(node => tagPc.children.push(node));\n    } else {\n      tagPc.children.push(new Text$1(''));\n    }\n    return [tagPc];\n  }\n  visitPlaceholder(ph, context) {\n    const idStr = (this._nextPlaceholderId++).toString();\n    return [new Tag(_PLACEHOLDER_TAG$1, {\n      id: idStr,\n      equiv: ph.name,\n      disp: `{{${ph.value}}}`\n    })];\n  }\n  visitBlockPlaceholder(ph, context) {\n    const tagPc = new Tag(_PLACEHOLDER_SPANNING_TAG, {\n      id: (this._nextPlaceholderId++).toString(),\n      equivStart: ph.startName,\n      equivEnd: ph.closeName,\n      type: 'other',\n      dispStart: `@${ph.name}`,\n      dispEnd: `}`\n    });\n    const nodes = [].concat(...ph.children.map(node => node.visit(this)));\n    if (nodes.length) {\n      nodes.forEach(node => tagPc.children.push(node));\n    } else {\n      tagPc.children.push(new Text$1(''));\n    }\n    return [tagPc];\n  }\n  visitIcuPlaceholder(ph, context) {\n    const cases = Object.keys(ph.value.cases).map(value => value + ' {...}').join(' ');\n    const idStr = (this._nextPlaceholderId++).toString();\n    return [new Tag(_PLACEHOLDER_TAG$1, {\n      id: idStr,\n      equiv: ph.name,\n      disp: `{${ph.value.expression}, ${ph.value.type}, ${cases}}`\n    })];\n  }\n  serialize(nodes) {\n    this._nextPlaceholderId = 0;\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n}\nclass Xliff2Parser {\n  _unitMlString;\n  _errors;\n  _msgIdToHtml;\n  _locale = null;\n  parse(xliff, url) {\n    this._unitMlString = null;\n    this._msgIdToHtml = {};\n    const xml = new XmlParser().parse(xliff, url);\n    this._errors = xml.errors;\n    visitAll(this, xml.rootNodes, null);\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors,\n      locale: this._locale\n    };\n  }\n  visitElement(element, context) {\n    switch (element.name) {\n      case _UNIT_TAG:\n        this._unitMlString = null;\n        const idAttr = element.attrs.find(attr => attr.name === 'id');\n        if (!idAttr) {\n          this._addError(element, `<${_UNIT_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            visitAll(this, element.children, null);\n            if (typeof this._unitMlString === 'string') {\n              this._msgIdToHtml[id] = this._unitMlString;\n            } else {\n              this._addError(element, `Message ${id} misses a translation`);\n            }\n          }\n        }\n        break;\n      case _SOURCE_TAG:\n        break;\n      case _TARGET_TAG:\n        const innerTextStart = element.startSourceSpan.end.offset;\n        const innerTextEnd = element.endSourceSpan.start.offset;\n        const content = element.startSourceSpan.start.file.content;\n        const innerText = content.slice(innerTextStart, innerTextEnd);\n        this._unitMlString = innerText;\n        break;\n      case _XLIFF_TAG:\n        const localeAttr = element.attrs.find(attr => attr.name === 'trgLang');\n        if (localeAttr) {\n          this._locale = localeAttr.value;\n        }\n        const versionAttr = element.attrs.find(attr => attr.name === 'version');\n        if (versionAttr) {\n          const version = versionAttr.value;\n          if (version !== '2.0') {\n            this._addError(element, `The XLIFF file version ${version} is not compatible with XLIFF 2.0 serializer`);\n          } else {\n            visitAll(this, element.children, null);\n          }\n        }\n        break;\n      default:\n        visitAll(this, element.children, null);\n    }\n  }\n  visitAttribute(attribute, context) {}\n  visitText(text, context) {}\n  visitComment(comment, context) {}\n  visitExpansion(expansion, context) {}\n  visitExpansionCase(expansionCase, context) {}\n  visitBlock(block, context) {}\n  visitBlockParameter(parameter, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {}\n  visitDirective(directive, context) {}\n  _addError(node, message) {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n}\nlet XmlToI18n$1 = class XmlToI18n {\n  _errors;\n  convert(message, url) {\n    const xmlIcu = new XmlParser().parse(message, url, {\n      tokenizeExpansionForms: true\n    });\n    this._errors = xmlIcu.errors;\n    const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ? [] : [].concat(...visitAll(this, xmlIcu.rootNodes));\n    return {\n      i18nNodes,\n      errors: this._errors\n    };\n  }\n  visitText(text, context) {\n    return new Text$2(text.value, text.sourceSpan);\n  }\n  visitElement(el, context) {\n    switch (el.name) {\n      case _PLACEHOLDER_TAG$1:\n        const nameAttr = el.attrs.find(attr => attr.name === 'equiv');\n        if (nameAttr) {\n          return [new Placeholder('', nameAttr.value, el.sourceSpan)];\n        }\n        this._addError(el, `<${_PLACEHOLDER_TAG$1}> misses the \"equiv\" attribute`);\n        break;\n      case _PLACEHOLDER_SPANNING_TAG:\n        const startAttr = el.attrs.find(attr => attr.name === 'equivStart');\n        const endAttr = el.attrs.find(attr => attr.name === 'equivEnd');\n        if (!startAttr) {\n          this._addError(el, `<${_PLACEHOLDER_TAG$1}> misses the \"equivStart\" attribute`);\n        } else if (!endAttr) {\n          this._addError(el, `<${_PLACEHOLDER_TAG$1}> misses the \"equivEnd\" attribute`);\n        } else {\n          const startId = startAttr.value;\n          const endId = endAttr.value;\n          const nodes = [];\n          return nodes.concat(new Placeholder('', startId, el.sourceSpan), ...el.children.map(node => node.visit(this, null)), new Placeholder('', endId, el.sourceSpan));\n        }\n        break;\n      case _MARKER_TAG:\n        return [].concat(...visitAll(this, el.children));\n      default:\n        this._addError(el, `Unexpected tag`);\n    }\n    return null;\n  }\n  visitExpansion(icu, context) {\n    const caseMap = {};\n    visitAll(this, icu.cases).forEach(c => {\n      caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n    });\n    return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n  visitExpansionCase(icuCase, context) {\n    return {\n      value: icuCase.value,\n      nodes: [].concat(...visitAll(this, icuCase.expression))\n    };\n  }\n  visitComment(comment, context) {}\n  visitAttribute(attribute, context) {}\n  visitBlock(block, context) {}\n  visitBlockParameter(parameter, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {\n    this._addError(component, 'Unexpected node');\n  }\n  visitDirective(directive, context) {\n    this._addError(directive, 'Unexpected node');\n  }\n  _addError(node, message) {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n};\nfunction getTypeForTag(tag) {\n  switch (tag.toLowerCase()) {\n    case 'br':\n    case 'b':\n    case 'i':\n    case 'u':\n      return 'fmt';\n    case 'img':\n      return 'image';\n    case 'a':\n      return 'link';\n    default:\n      return 'other';\n  }\n}\nconst _TRANSLATIONS_TAG = 'translationbundle';\nconst _TRANSLATION_TAG = 'translation';\nconst _PLACEHOLDER_TAG = 'ph';\nclass Xtb extends Serializer {\n  write(messages, locale) {\n    throw new Error('Unsupported');\n  }\n  load(content, url) {\n    const xtbParser = new XtbParser();\n    const {\n      locale,\n      msgIdToHtml,\n      errors\n    } = xtbParser.parse(content, url);\n    const i18nNodesByMsgId = {};\n    const converter = new XmlToI18n();\n    Object.keys(msgIdToHtml).forEach(msgId => {\n      const valueFn = function () {\n        const {\n          i18nNodes,\n          errors\n        } = converter.convert(msgIdToHtml[msgId], url);\n        if (errors.length) {\n          throw new Error(`xtb parse errors:\\n${errors.join('\\n')}`);\n        }\n        return i18nNodes;\n      };\n      createLazyProperty(i18nNodesByMsgId, msgId, valueFn);\n    });\n    if (errors.length) {\n      throw new Error(`xtb parse errors:\\n${errors.join('\\n')}`);\n    }\n    return {\n      locale: locale,\n      i18nNodesByMsgId\n    };\n  }\n  digest(message) {\n    return digest(message);\n  }\n  createNameMapper(message) {\n    return new SimplePlaceholderMapper(message, toPublicName);\n  }\n}\nfunction createLazyProperty(messages, id, valueFn) {\n  Object.defineProperty(messages, id, {\n    configurable: true,\n    enumerable: true,\n    get: function () {\n      const value = valueFn();\n      Object.defineProperty(messages, id, {\n        enumerable: true,\n        value\n      });\n      return value;\n    },\n    set: _ => {\n      throw new Error('Could not overwrite an XTB translation');\n    }\n  });\n}\nclass XtbParser {\n  _bundleDepth;\n  _errors;\n  _msgIdToHtml;\n  _locale = null;\n  parse(xtb, url) {\n    this._bundleDepth = 0;\n    this._msgIdToHtml = {};\n    const xml = new XmlParser().parse(xtb, url);\n    this._errors = xml.errors;\n    visitAll(this, xml.rootNodes);\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors,\n      locale: this._locale\n    };\n  }\n  visitElement(element, context) {\n    switch (element.name) {\n      case _TRANSLATIONS_TAG:\n        this._bundleDepth++;\n        if (this._bundleDepth > 1) {\n          this._addError(element, `<${_TRANSLATIONS_TAG}> elements can not be nested`);\n        }\n        const langAttr = element.attrs.find(attr => attr.name === 'lang');\n        if (langAttr) {\n          this._locale = langAttr.value;\n        }\n        visitAll(this, element.children, null);\n        this._bundleDepth--;\n        break;\n      case _TRANSLATION_TAG:\n        const idAttr = element.attrs.find(attr => attr.name === 'id');\n        if (!idAttr) {\n          this._addError(element, `<${_TRANSLATION_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            const innerTextStart = element.startSourceSpan.end.offset;\n            const innerTextEnd = element.endSourceSpan.start.offset;\n            const content = element.startSourceSpan.start.file.content;\n            const innerText = content.slice(innerTextStart, innerTextEnd);\n            this._msgIdToHtml[id] = innerText;\n          }\n        }\n        break;\n      default:\n        this._addError(element, 'Unexpected tag');\n    }\n  }\n  visitAttribute(attribute, context) {}\n  visitText(text, context) {}\n  visitComment(comment, context) {}\n  visitExpansion(expansion, context) {}\n  visitExpansionCase(expansionCase, context) {}\n  visitBlock(block, context) {}\n  visitBlockParameter(block, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {\n    this._addError(component, 'Unexpected node');\n  }\n  visitDirective(directive, context) {\n    this._addError(directive, 'Unexpected node');\n  }\n  _addError(node, message) {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n}\nclass XmlToI18n {\n  _errors;\n  convert(message, url) {\n    const xmlIcu = new XmlParser().parse(message, url, {\n      tokenizeExpansionForms: true\n    });\n    this._errors = xmlIcu.errors;\n    const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ? [] : visitAll(this, xmlIcu.rootNodes);\n    return {\n      i18nNodes,\n      errors: this._errors\n    };\n  }\n  visitText(text, context) {\n    return new Text$2(text.value, text.sourceSpan);\n  }\n  visitExpansion(icu, context) {\n    const caseMap = {};\n    visitAll(this, icu.cases).forEach(c => {\n      caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n    });\n    return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n  visitExpansionCase(icuCase, context) {\n    return {\n      value: icuCase.value,\n      nodes: visitAll(this, icuCase.expression)\n    };\n  }\n  visitElement(el, context) {\n    if (el.name === _PLACEHOLDER_TAG) {\n      const nameAttr = el.attrs.find(attr => attr.name === 'name');\n      if (nameAttr) {\n        return new Placeholder('', nameAttr.value, el.sourceSpan);\n      }\n      this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"name\" attribute`);\n    } else {\n      this._addError(el, `Unexpected tag`);\n    }\n    return null;\n  }\n  visitComment(comment, context) {}\n  visitAttribute(attribute, context) {}\n  visitBlock(block, context) {}\n  visitBlockParameter(block, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {\n    this._addError(component, 'Unexpected node');\n  }\n  visitDirective(directive, context) {\n    this._addError(directive, 'Unexpected node');\n  }\n  _addError(node, message) {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n}\nclass TranslationBundle {\n  _i18nNodesByMsgId;\n  digest;\n  mapperFactory;\n  _i18nToHtml;\n  constructor(_i18nNodesByMsgId = {}, locale, digest, mapperFactory, missingTranslationStrategy = MissingTranslationStrategy.Warning, console) {\n    this._i18nNodesByMsgId = _i18nNodesByMsgId;\n    this.digest = digest;\n    this.mapperFactory = mapperFactory;\n    this._i18nToHtml = new I18nToHtmlVisitor(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console);\n  }\n  static load(content, url, serializer, missingTranslationStrategy, console) {\n    const {\n      locale,\n      i18nNodesByMsgId\n    } = serializer.load(content, url);\n    const digestFn = m => serializer.digest(m);\n    const mapperFactory = m => serializer.createNameMapper(m);\n    return new TranslationBundle(i18nNodesByMsgId, locale, digestFn, mapperFactory, missingTranslationStrategy, console);\n  }\n  get(srcMsg) {\n    const html = this._i18nToHtml.convert(srcMsg);\n    if (html.errors.length) {\n      throw new Error(html.errors.join('\\n'));\n    }\n    return html.nodes;\n  }\n  has(srcMsg) {\n    return this.digest(srcMsg) in this._i18nNodesByMsgId;\n  }\n}\nclass I18nToHtmlVisitor {\n  _i18nNodesByMsgId;\n  _locale;\n  _digest;\n  _mapperFactory;\n  _missingTranslationStrategy;\n  _console;\n  _srcMsg;\n  _errors = [];\n  _contextStack = [];\n  _mapper;\n  constructor(_i18nNodesByMsgId = {}, _locale, _digest, _mapperFactory, _missingTranslationStrategy, _console) {\n    this._i18nNodesByMsgId = _i18nNodesByMsgId;\n    this._locale = _locale;\n    this._digest = _digest;\n    this._mapperFactory = _mapperFactory;\n    this._missingTranslationStrategy = _missingTranslationStrategy;\n    this._console = _console;\n  }\n  convert(srcMsg) {\n    this._contextStack.length = 0;\n    this._errors.length = 0;\n    const text = this._convertToText(srcMsg);\n    const url = srcMsg.nodes[0].sourceSpan.start.file.url;\n    const html = new HtmlParser().parse(text, url, {\n      tokenizeExpansionForms: true\n    });\n    return {\n      nodes: html.rootNodes,\n      errors: [...this._errors, ...html.errors]\n    };\n  }\n  visitText(text, context) {\n    return escapeXml(text.value);\n  }\n  visitContainer(container, context) {\n    return container.children.map(n => n.visit(this)).join('');\n  }\n  visitIcu(icu, context) {\n    const cases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n    const exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression) ? this._srcMsg.placeholders[icu.expression].text : icu.expression;\n    return `{${exp}, ${icu.type}, ${cases.join(' ')}}`;\n  }\n  visitPlaceholder(ph, context) {\n    const phName = this._mapper(ph.name);\n    if (this._srcMsg.placeholders.hasOwnProperty(phName)) {\n      return this._srcMsg.placeholders[phName].text;\n    }\n    if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {\n      return this._convertToText(this._srcMsg.placeholderToMessage[phName]);\n    }\n    this._addError(ph, `Unknown placeholder \"${ph.name}\"`);\n    return '';\n  }\n  visitTagPlaceholder(ph, context) {\n    const tag = `${ph.tag}`;\n    const attrs = Object.keys(ph.attrs).map(name => `${name}=\"${ph.attrs[name]}\"`).join(' ');\n    if (ph.isVoid) {\n      return `<${tag} ${attrs}/>`;\n    }\n    const children = ph.children.map(c => c.visit(this)).join('');\n    return `<${tag} ${attrs}>${children}</${tag}>`;\n  }\n  visitIcuPlaceholder(ph, context) {\n    return this._convertToText(this._srcMsg.placeholderToMessage[ph.name]);\n  }\n  visitBlockPlaceholder(ph, context) {\n    const params = ph.parameters.length === 0 ? '' : ` (${ph.parameters.join('; ')})`;\n    const children = ph.children.map(c => c.visit(this)).join('');\n    return `@${ph.name}${params} {${children}}`;\n  }\n  _convertToText(srcMsg) {\n    const id = this._digest(srcMsg);\n    const mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;\n    let nodes;\n    this._contextStack.push({\n      msg: this._srcMsg,\n      mapper: this._mapper\n    });\n    this._srcMsg = srcMsg;\n    if (this._i18nNodesByMsgId.hasOwnProperty(id)) {\n      nodes = this._i18nNodesByMsgId[id];\n      this._mapper = name => mapper ? mapper.toInternalName(name) : name;\n    } else {\n      if (this._missingTranslationStrategy === MissingTranslationStrategy.Error) {\n        const ctx = this._locale ? ` for locale \"${this._locale}\"` : '';\n        this._addError(srcMsg.nodes[0], `Missing translation for message \"${id}\"${ctx}`);\n      } else if (this._console && this._missingTranslationStrategy === MissingTranslationStrategy.Warning) {\n        const ctx = this._locale ? ` for locale \"${this._locale}\"` : '';\n        this._console.warn(`Missing translation for message \"${id}\"${ctx}`);\n      }\n      nodes = srcMsg.nodes;\n      this._mapper = name => name;\n    }\n    const text = nodes.map(node => node.visit(this)).join('');\n    const context = this._contextStack.pop();\n    this._srcMsg = context.msg;\n    this._mapper = context.mapper;\n    return text;\n  }\n  _addError(el, msg) {\n    this._errors.push(new ParseError(el.sourceSpan, msg));\n  }\n}\nclass I18NHtmlParser {\n  _htmlParser;\n  getTagDefinition;\n  _translationBundle;\n  constructor(_htmlParser, translations, translationsFormat, missingTranslation = MissingTranslationStrategy.Warning, console) {\n    this._htmlParser = _htmlParser;\n    if (translations) {\n      const serializer = createSerializer(translationsFormat);\n      this._translationBundle = TranslationBundle.load(translations, 'i18n', serializer, missingTranslation, console);\n    } else {\n      this._translationBundle = new TranslationBundle({}, null, digest$1, undefined, missingTranslation, console);\n    }\n  }\n  parse(source, url, options = {}) {\n    const parseResult = this._htmlParser.parse(source, url, {\n      ...options\n    });\n    if (parseResult.errors.length) {\n      return new ParseTreeResult(parseResult.rootNodes, parseResult.errors);\n    }\n    return mergeTranslations(parseResult.rootNodes, this._translationBundle, [], {});\n  }\n}\nfunction createSerializer(format) {\n  format = (format || 'xlf').toLowerCase();\n  switch (format) {\n    case 'xmb':\n      return new Xmb();\n    case 'xtb':\n      return new Xtb();\n    case 'xliff2':\n    case 'xlf2':\n      return new Xliff2();\n    case 'xliff':\n    case 'xlf':\n    default:\n      return new Xliff();\n  }\n}\nclass MessageBundle {\n  _htmlParser;\n  _implicitTags;\n  _implicitAttrs;\n  _locale;\n  _preserveWhitespace;\n  _messages = [];\n  constructor(_htmlParser, _implicitTags, _implicitAttrs, _locale = null, _preserveWhitespace = true) {\n    this._htmlParser = _htmlParser;\n    this._implicitTags = _implicitTags;\n    this._implicitAttrs = _implicitAttrs;\n    this._locale = _locale;\n    this._preserveWhitespace = _preserveWhitespace;\n  }\n  updateFromTemplate(source, url) {\n    const htmlParserResult = this._htmlParser.parse(source, url, {\n      tokenizeExpansionForms: true\n    });\n    if (htmlParserResult.errors.length) {\n      return htmlParserResult.errors;\n    }\n    const rootNodes = this._preserveWhitespace ? htmlParserResult.rootNodes : visitAllWithSiblings(new WhitespaceVisitor(false), htmlParserResult.rootNodes);\n    const i18nParserResult = extractMessages(rootNodes, this._implicitTags, this._implicitAttrs, this._preserveWhitespace);\n    if (i18nParserResult.errors.length) {\n      return i18nParserResult.errors;\n    }\n    this._messages.push(...i18nParserResult.messages);\n    return [];\n  }\n  getMessages() {\n    return this._messages;\n  }\n  write(serializer, filterSources) {\n    const messages = {};\n    const mapperVisitor = new MapPlaceholderNames();\n    this._messages.forEach(message => {\n      const id = serializer.digest(message);\n      if (!messages.hasOwnProperty(id)) {\n        messages[id] = message;\n      } else {\n        messages[id].sources.push(...message.sources);\n      }\n    });\n    const msgList = Object.keys(messages).map(id => {\n      const mapper = serializer.createNameMapper(messages[id]);\n      const src = messages[id];\n      const nodes = mapper ? mapperVisitor.convert(src.nodes, mapper) : src.nodes;\n      let transformedMessage = new Message(nodes, {}, {}, src.meaning, src.description, id);\n      transformedMessage.sources = src.sources;\n      if (filterSources) {\n        transformedMessage.sources.forEach(source => source.filePath = filterSources(source.filePath));\n      }\n      return transformedMessage;\n    });\n    return serializer.write(msgList, this._locale);\n  }\n}\nclass MapPlaceholderNames extends CloneVisitor {\n  convert(nodes, mapper) {\n    return mapper ? nodes.map(n => n.visit(this, mapper)) : nodes;\n  }\n  visitTagPlaceholder(ph, mapper) {\n    const startName = mapper.toPublicName(ph.startName);\n    const closeName = ph.closeName ? mapper.toPublicName(ph.closeName) : ph.closeName;\n    const children = ph.children.map(n => n.visit(this, mapper));\n    return new TagPlaceholder(ph.tag, ph.attrs, startName, closeName, children, ph.isVoid, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);\n  }\n  visitBlockPlaceholder(ph, mapper) {\n    const startName = mapper.toPublicName(ph.startName);\n    const closeName = ph.closeName ? mapper.toPublicName(ph.closeName) : ph.closeName;\n    const children = ph.children.map(n => n.visit(this, mapper));\n    return new BlockPlaceholder(ph.name, ph.parameters, startName, closeName, children, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);\n  }\n  visitPlaceholder(ph, mapper) {\n    return new Placeholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\n  }\n  visitIcuPlaceholder(ph, mapper) {\n    return new IcuPlaceholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\n  }\n}\nfunction compileClassMetadata(metadata) {\n  const fnCall = internalCompileClassMetadata(metadata);\n  return arrowFn([], [devOnlyGuardedExpression(fnCall).toStmt()]).callFn([]);\n}\nfunction internalCompileClassMetadata(metadata) {\n  return importExpr(Identifiers.setClassMetadata).callFn([metadata.type, metadata.decorators, metadata.ctorParameters ?? literal(null), metadata.propDecorators ?? literal(null)]);\n}\nfunction compileComponentClassMetadata(metadata, dependencies) {\n  if (dependencies === null || dependencies.length === 0) {\n    return compileClassMetadata(metadata);\n  }\n  return internalCompileSetClassMetadataAsync(metadata, dependencies.map(dep => new FnParam(dep.symbolName, DYNAMIC_TYPE)), compileComponentMetadataAsyncResolver(dependencies));\n}\nfunction compileOpaqueAsyncClassMetadata(metadata, deferResolver, deferredDependencyNames) {\n  return internalCompileSetClassMetadataAsync(metadata, deferredDependencyNames.map(name => new FnParam(name, DYNAMIC_TYPE)), deferResolver);\n}\nfunction internalCompileSetClassMetadataAsync(metadata, wrapperParams, dependencyResolverFn) {\n  const setClassMetadataCall = internalCompileClassMetadata(metadata);\n  const setClassMetaWrapper = arrowFn(wrapperParams, [setClassMetadataCall.toStmt()]);\n  const setClassMetaAsync = importExpr(Identifiers.setClassMetadataAsync).callFn([metadata.type, dependencyResolverFn, setClassMetaWrapper]);\n  return arrowFn([], [devOnlyGuardedExpression(setClassMetaAsync).toStmt()]).callFn([]);\n}\nfunction compileComponentMetadataAsyncResolver(dependencies) {\n  const dynamicImports = dependencies.map(({\n    symbolName,\n    importPath,\n    isDefaultImport\n  }) => {\n    const innerFn = arrowFn([new FnParam('m', DYNAMIC_TYPE)], variable('m').prop(isDefaultImport ? 'default' : symbolName));\n    return new DynamicImportExpr(importPath).prop('then').callFn([innerFn]);\n  });\n  return arrowFn([], literalArr(dynamicImports));\n}\nconst MINIMUM_PARTIAL_LINKER_VERSION$5 = '12.0.0';\nconst MINIMUM_PARTIAL_LINKER_DEFER_SUPPORT_VERSION = '18.0.0';\nfunction compileDeclareClassMetadata(metadata) {\n  const definitionMap = new DefinitionMap();\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$5));\n  definitionMap.set('version', literal('21.0.0'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', metadata.type);\n  definitionMap.set('decorators', metadata.decorators);\n  definitionMap.set('ctorParameters', metadata.ctorParameters);\n  definitionMap.set('propDecorators', metadata.propDecorators);\n  return importExpr(Identifiers.declareClassMetadata).callFn([definitionMap.toLiteralMap()]);\n}\nfunction compileComponentDeclareClassMetadata(metadata, dependencies) {\n  if (dependencies === null || dependencies.length === 0) {\n    return compileDeclareClassMetadata(metadata);\n  }\n  const definitionMap = new DefinitionMap();\n  const callbackReturnDefinitionMap = new DefinitionMap();\n  callbackReturnDefinitionMap.set('decorators', metadata.decorators);\n  callbackReturnDefinitionMap.set('ctorParameters', metadata.ctorParameters ?? literal(null));\n  callbackReturnDefinitionMap.set('propDecorators', metadata.propDecorators ?? literal(null));\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_DEFER_SUPPORT_VERSION));\n  definitionMap.set('version', literal('21.0.0'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', metadata.type);\n  definitionMap.set('resolveDeferredDeps', compileComponentMetadataAsyncResolver(dependencies));\n  definitionMap.set('resolveMetadata', arrowFn(dependencies.map(dep => new FnParam(dep.symbolName, DYNAMIC_TYPE)), callbackReturnDefinitionMap.toLiteralMap()));\n  return importExpr(Identifiers.declareClassMetadataAsync).callFn([definitionMap.toLiteralMap()]);\n}\nfunction toOptionalLiteralArray(values, mapper) {\n  if (values === null || values.length === 0) {\n    return null;\n  }\n  return literalArr(values.map(value => mapper(value)));\n}\nfunction toOptionalLiteralMap(object, mapper) {\n  const entries = Object.keys(object).map(key => {\n    const value = object[key];\n    return {\n      key,\n      value: mapper(value),\n      quoted: true\n    };\n  });\n  if (entries.length > 0) {\n    return literalMap(entries);\n  } else {\n    return null;\n  }\n}\nfunction compileDependencies(deps) {\n  if (deps === 'invalid') {\n    return literal('invalid');\n  } else if (deps === null) {\n    return literal(null);\n  } else {\n    return literalArr(deps.map(compileDependency));\n  }\n}\nfunction compileDependency(dep) {\n  const depMeta = new DefinitionMap();\n  depMeta.set('token', dep.token);\n  if (dep.attributeNameType !== null) {\n    depMeta.set('attribute', literal(true));\n  }\n  if (dep.host) {\n    depMeta.set('host', literal(true));\n  }\n  if (dep.optional) {\n    depMeta.set('optional', literal(true));\n  }\n  if (dep.self) {\n    depMeta.set('self', literal(true));\n  }\n  if (dep.skipSelf) {\n    depMeta.set('skipSelf', literal(true));\n  }\n  return depMeta.toLiteralMap();\n}\nfunction compileDeclareDirectiveFromMetadata(meta) {\n  const definitionMap = createDirectiveDefinitionMap(meta);\n  const expression = importExpr(Identifiers.declareDirective).callFn([definitionMap.toLiteralMap()]);\n  const type = createDirectiveType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createDirectiveDefinitionMap(meta) {\n  const definitionMap = new DefinitionMap();\n  const minVersion = getMinimumVersionForPartialOutput(meta);\n  definitionMap.set('minVersion', literal(minVersion));\n  definitionMap.set('version', literal('21.0.0'));\n  definitionMap.set('type', meta.type.value);\n  if (meta.isStandalone !== undefined) {\n    definitionMap.set('isStandalone', literal(meta.isStandalone));\n  }\n  if (meta.isSignal) {\n    definitionMap.set('isSignal', literal(meta.isSignal));\n  }\n  if (meta.selector !== null) {\n    definitionMap.set('selector', literal(meta.selector));\n  }\n  definitionMap.set('inputs', needsNewInputPartialOutput(meta) ? createInputsPartialMetadata(meta.inputs) : legacyInputsPartialMetadata(meta.inputs));\n  definitionMap.set('outputs', conditionallyCreateDirectiveBindingLiteral(meta.outputs));\n  definitionMap.set('host', compileHostMetadata(meta.host));\n  definitionMap.set('providers', meta.providers);\n  if (meta.queries.length > 0) {\n    definitionMap.set('queries', literalArr(meta.queries.map(compileQuery)));\n  }\n  if (meta.viewQueries.length > 0) {\n    definitionMap.set('viewQueries', literalArr(meta.viewQueries.map(compileQuery)));\n  }\n  if (meta.exportAs !== null) {\n    definitionMap.set('exportAs', asLiteral(meta.exportAs));\n  }\n  if (meta.usesInheritance) {\n    definitionMap.set('usesInheritance', literal(true));\n  }\n  if (meta.lifecycle.usesOnChanges) {\n    definitionMap.set('usesOnChanges', literal(true));\n  }\n  if (meta.hostDirectives?.length) {\n    definitionMap.set('hostDirectives', createHostDirectives(meta.hostDirectives));\n  }\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  return definitionMap;\n}\nfunction getMinimumVersionForPartialOutput(meta) {\n  let minVersion = '14.0.0';\n  const hasDecoratorTransformFunctions = Object.values(meta.inputs).some(input => input.transformFunction !== null);\n  if (hasDecoratorTransformFunctions) {\n    minVersion = '16.1.0';\n  }\n  if (needsNewInputPartialOutput(meta)) {\n    minVersion = '17.1.0';\n  }\n  if (meta.queries.some(q => q.isSignal) || meta.viewQueries.some(q => q.isSignal)) {\n    minVersion = '17.2.0';\n  }\n  return minVersion;\n}\nfunction needsNewInputPartialOutput(meta) {\n  return Object.values(meta.inputs).some(input => input.isSignal);\n}\nfunction compileQuery(query) {\n  const meta = new DefinitionMap();\n  meta.set('propertyName', literal(query.propertyName));\n  if (query.first) {\n    meta.set('first', literal(true));\n  }\n  meta.set('predicate', Array.isArray(query.predicate) ? asLiteral(query.predicate) : convertFromMaybeForwardRefExpression(query.predicate));\n  if (!query.emitDistinctChangesOnly) {\n    meta.set('emitDistinctChangesOnly', literal(false));\n  }\n  if (query.descendants) {\n    meta.set('descendants', literal(true));\n  }\n  meta.set('read', query.read);\n  if (query.static) {\n    meta.set('static', literal(true));\n  }\n  if (query.isSignal) {\n    meta.set('isSignal', literal(true));\n  }\n  return meta.toLiteralMap();\n}\nfunction compileHostMetadata(meta) {\n  const hostMetadata = new DefinitionMap();\n  hostMetadata.set('attributes', toOptionalLiteralMap(meta.attributes, expression => expression));\n  hostMetadata.set('listeners', toOptionalLiteralMap(meta.listeners, literal));\n  hostMetadata.set('properties', toOptionalLiteralMap(meta.properties, literal));\n  if (meta.specialAttributes.styleAttr) {\n    hostMetadata.set('styleAttribute', literal(meta.specialAttributes.styleAttr));\n  }\n  if (meta.specialAttributes.classAttr) {\n    hostMetadata.set('classAttribute', literal(meta.specialAttributes.classAttr));\n  }\n  if (hostMetadata.values.length > 0) {\n    return hostMetadata.toLiteralMap();\n  } else {\n    return null;\n  }\n}\nfunction createHostDirectives(hostDirectives) {\n  const expressions = hostDirectives.map(current => {\n    const keys = [{\n      key: 'directive',\n      value: current.isForwardReference ? generateForwardRef(current.directive.type) : current.directive.type,\n      quoted: false\n    }];\n    const inputsLiteral = current.inputs ? createHostDirectivesMappingArray(current.inputs) : null;\n    const outputsLiteral = current.outputs ? createHostDirectivesMappingArray(current.outputs) : null;\n    if (inputsLiteral) {\n      keys.push({\n        key: 'inputs',\n        value: inputsLiteral,\n        quoted: false\n      });\n    }\n    if (outputsLiteral) {\n      keys.push({\n        key: 'outputs',\n        value: outputsLiteral,\n        quoted: false\n      });\n    }\n    return literalMap(keys);\n  });\n  return literalArr(expressions);\n}\nfunction createInputsPartialMetadata(inputs) {\n  const keys = Object.getOwnPropertyNames(inputs);\n  if (keys.length === 0) {\n    return null;\n  }\n  return literalMap(keys.map(declaredName => {\n    const value = inputs[declaredName];\n    return {\n      key: declaredName,\n      quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(declaredName),\n      value: literalMap([{\n        key: 'classPropertyName',\n        quoted: false,\n        value: asLiteral(value.classPropertyName)\n      }, {\n        key: 'publicName',\n        quoted: false,\n        value: asLiteral(value.bindingPropertyName)\n      }, {\n        key: 'isSignal',\n        quoted: false,\n        value: asLiteral(value.isSignal)\n      }, {\n        key: 'isRequired',\n        quoted: false,\n        value: asLiteral(value.required)\n      }, {\n        key: 'transformFunction',\n        quoted: false,\n        value: value.transformFunction ?? NULL_EXPR\n      }])\n    };\n  }));\n}\nfunction legacyInputsPartialMetadata(inputs) {\n  const keys = Object.getOwnPropertyNames(inputs);\n  if (keys.length === 0) {\n    return null;\n  }\n  return literalMap(keys.map(declaredName => {\n    const value = inputs[declaredName];\n    const publicName = value.bindingPropertyName;\n    const differentDeclaringName = publicName !== declaredName;\n    let result;\n    if (differentDeclaringName || value.transformFunction !== null) {\n      const values = [asLiteral(publicName), asLiteral(declaredName)];\n      if (value.transformFunction !== null) {\n        values.push(value.transformFunction);\n      }\n      result = literalArr(values);\n    } else {\n      result = asLiteral(publicName);\n    }\n    return {\n      key: declaredName,\n      quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(declaredName),\n      value: result\n    };\n  }));\n}\nfunction compileDeclareComponentFromMetadata(meta, template, additionalTemplateInfo) {\n  const definitionMap = createComponentDefinitionMap(meta, template, additionalTemplateInfo);\n  const expression = importExpr(Identifiers.declareComponent).callFn([definitionMap.toLiteralMap()]);\n  const type = createComponentType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createComponentDefinitionMap(meta, template, templateInfo) {\n  const definitionMap = createDirectiveDefinitionMap(meta);\n  const blockVisitor = new BlockPresenceVisitor();\n  visitAll$1(blockVisitor, template.nodes);\n  definitionMap.set('template', getTemplateExpression(template, templateInfo));\n  if (templateInfo.isInline) {\n    definitionMap.set('isInline', literal(true));\n  }\n  if (blockVisitor.hasBlocks) {\n    definitionMap.set('minVersion', literal('17.0.0'));\n  }\n  definitionMap.set('styles', toOptionalLiteralArray(meta.styles, literal));\n  definitionMap.set('dependencies', compileUsedDependenciesMetadata(meta));\n  definitionMap.set('viewProviders', meta.viewProviders);\n  definitionMap.set('animations', meta.animations);\n  if (meta.changeDetection !== null) {\n    if (typeof meta.changeDetection === 'object') {\n      throw new Error('Impossible state! Change detection flag is not resolved!');\n    }\n    definitionMap.set('changeDetection', importExpr(Identifiers.ChangeDetectionStrategy).prop(ChangeDetectionStrategy[meta.changeDetection]));\n  }\n  if (meta.encapsulation !== ViewEncapsulation$1.Emulated) {\n    definitionMap.set('encapsulation', importExpr(Identifiers.ViewEncapsulation).prop(ViewEncapsulation$1[meta.encapsulation]));\n  }\n  if (template.preserveWhitespaces === true) {\n    definitionMap.set('preserveWhitespaces', literal(true));\n  }\n  if (meta.defer.mode === 0) {\n    const resolvers = [];\n    let hasResolvers = false;\n    for (const deps of meta.defer.blocks.values()) {\n      if (deps === null) {\n        resolvers.push(literal(null));\n      } else {\n        resolvers.push(deps);\n        hasResolvers = true;\n      }\n    }\n    if (hasResolvers) {\n      definitionMap.set('deferBlockDependencies', literalArr(resolvers));\n    }\n  } else {\n    throw new Error('Unsupported defer function emit mode in partial compilation');\n  }\n  return definitionMap;\n}\nfunction getTemplateExpression(template, templateInfo) {\n  if (templateInfo.inlineTemplateLiteralExpression !== null) {\n    return templateInfo.inlineTemplateLiteralExpression;\n  }\n  if (templateInfo.isInline) {\n    return literal(templateInfo.content, null, null);\n  }\n  const contents = templateInfo.content;\n  const file = new ParseSourceFile(contents, templateInfo.sourceUrl);\n  const start = new ParseLocation(file, 0, 0, 0);\n  const end = computeEndLocation(file, contents);\n  const span = new ParseSourceSpan(start, end);\n  return literal(contents, null, span);\n}\nfunction computeEndLocation(file, contents) {\n  const length = contents.length;\n  let lineStart = 0;\n  let lastLineStart = 0;\n  let line = 0;\n  do {\n    lineStart = contents.indexOf('\\n', lastLineStart);\n    if (lineStart !== -1) {\n      lastLineStart = lineStart + 1;\n      line++;\n    }\n  } while (lineStart !== -1);\n  return new ParseLocation(file, length, line, length - lastLineStart);\n}\nfunction compileUsedDependenciesMetadata(meta) {\n  const wrapType = meta.declarationListEmitMode !== 0 ? generateForwardRef : expr => expr;\n  if (meta.declarationListEmitMode === 3) {\n    throw new Error(`Unsupported emit mode`);\n  }\n  return toOptionalLiteralArray(meta.declarations, decl => {\n    switch (decl.kind) {\n      case R3TemplateDependencyKind.Directive:\n        const dirMeta = new DefinitionMap();\n        dirMeta.set('kind', literal(decl.isComponent ? 'component' : 'directive'));\n        dirMeta.set('type', wrapType(decl.type));\n        dirMeta.set('selector', literal(decl.selector));\n        dirMeta.set('inputs', toOptionalLiteralArray(decl.inputs, literal));\n        dirMeta.set('outputs', toOptionalLiteralArray(decl.outputs, literal));\n        dirMeta.set('exportAs', toOptionalLiteralArray(decl.exportAs, literal));\n        return dirMeta.toLiteralMap();\n      case R3TemplateDependencyKind.Pipe:\n        const pipeMeta = new DefinitionMap();\n        pipeMeta.set('kind', literal('pipe'));\n        pipeMeta.set('type', wrapType(decl.type));\n        pipeMeta.set('name', literal(decl.name));\n        return pipeMeta.toLiteralMap();\n      case R3TemplateDependencyKind.NgModule:\n        const ngModuleMeta = new DefinitionMap();\n        ngModuleMeta.set('kind', literal('ngmodule'));\n        ngModuleMeta.set('type', wrapType(decl.type));\n        return ngModuleMeta.toLiteralMap();\n    }\n  });\n}\nclass BlockPresenceVisitor extends RecursiveVisitor$1 {\n  hasBlocks = false;\n  visitDeferredBlock() {\n    this.hasBlocks = true;\n  }\n  visitDeferredBlockPlaceholder() {\n    this.hasBlocks = true;\n  }\n  visitDeferredBlockLoading() {\n    this.hasBlocks = true;\n  }\n  visitDeferredBlockError() {\n    this.hasBlocks = true;\n  }\n  visitIfBlock() {\n    this.hasBlocks = true;\n  }\n  visitIfBlockBranch() {\n    this.hasBlocks = true;\n  }\n  visitForLoopBlock() {\n    this.hasBlocks = true;\n  }\n  visitForLoopBlockEmpty() {\n    this.hasBlocks = true;\n  }\n  visitSwitchBlock() {\n    this.hasBlocks = true;\n  }\n  visitSwitchBlockCase() {\n    this.hasBlocks = true;\n  }\n}\nconst MINIMUM_PARTIAL_LINKER_VERSION$4 = '12.0.0';\nfunction compileDeclareFactoryFunction(meta) {\n  const definitionMap = new DefinitionMap();\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$4));\n  definitionMap.set('version', literal('21.0.0'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', meta.type.value);\n  definitionMap.set('deps', compileDependencies(meta.deps));\n  definitionMap.set('target', importExpr(Identifiers.FactoryTarget).prop(FactoryTarget[meta.target]));\n  return {\n    expression: importExpr(Identifiers.declareFactory).callFn([definitionMap.toLiteralMap()]),\n    statements: [],\n    type: createFactoryType(meta)\n  };\n}\nconst MINIMUM_PARTIAL_LINKER_VERSION$3 = '12.0.0';\nfunction compileDeclareInjectableFromMetadata(meta) {\n  const definitionMap = createInjectableDefinitionMap(meta);\n  const expression = importExpr(Identifiers.declareInjectable).callFn([definitionMap.toLiteralMap()]);\n  const type = createInjectableType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createInjectableDefinitionMap(meta) {\n  const definitionMap = new DefinitionMap();\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$3));\n  definitionMap.set('version', literal('21.0.0'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', meta.type.value);\n  if (meta.providedIn !== undefined) {\n    const providedIn = convertFromMaybeForwardRefExpression(meta.providedIn);\n    if (providedIn.value !== null) {\n      definitionMap.set('providedIn', providedIn);\n    }\n  }\n  if (meta.useClass !== undefined) {\n    definitionMap.set('useClass', convertFromMaybeForwardRefExpression(meta.useClass));\n  }\n  if (meta.useExisting !== undefined) {\n    definitionMap.set('useExisting', convertFromMaybeForwardRefExpression(meta.useExisting));\n  }\n  if (meta.useValue !== undefined) {\n    definitionMap.set('useValue', convertFromMaybeForwardRefExpression(meta.useValue));\n  }\n  if (meta.useFactory !== undefined) {\n    definitionMap.set('useFactory', meta.useFactory);\n  }\n  if (meta.deps !== undefined) {\n    definitionMap.set('deps', literalArr(meta.deps.map(compileDependency)));\n  }\n  return definitionMap;\n}\nconst MINIMUM_PARTIAL_LINKER_VERSION$2 = '12.0.0';\nfunction compileDeclareInjectorFromMetadata(meta) {\n  const definitionMap = createInjectorDefinitionMap(meta);\n  const expression = importExpr(Identifiers.declareInjector).callFn([definitionMap.toLiteralMap()]);\n  const type = createInjectorType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createInjectorDefinitionMap(meta) {\n  const definitionMap = new DefinitionMap();\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$2));\n  definitionMap.set('version', literal('21.0.0'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', meta.type.value);\n  definitionMap.set('providers', meta.providers);\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', literalArr(meta.imports));\n  }\n  return definitionMap;\n}\nconst MINIMUM_PARTIAL_LINKER_VERSION$1 = '14.0.0';\nfunction compileDeclareNgModuleFromMetadata(meta) {\n  const definitionMap = createNgModuleDefinitionMap(meta);\n  const expression = importExpr(Identifiers.declareNgModule).callFn([definitionMap.toLiteralMap()]);\n  const type = createNgModuleType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createNgModuleDefinitionMap(meta) {\n  const definitionMap = new DefinitionMap();\n  if (meta.kind === R3NgModuleMetadataKind.Local) {\n    throw new Error('Invalid path! Local compilation mode should not get into the partial compilation path');\n  }\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$1));\n  definitionMap.set('version', literal('21.0.0'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', meta.type.value);\n  if (meta.bootstrap.length > 0) {\n    definitionMap.set('bootstrap', refsToArray(meta.bootstrap, meta.containsForwardDecls));\n  }\n  if (meta.declarations.length > 0) {\n    definitionMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\n  }\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\n  }\n  if (meta.exports.length > 0) {\n    definitionMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\n  }\n  if (meta.schemas !== null && meta.schemas.length > 0) {\n    definitionMap.set('schemas', literalArr(meta.schemas.map(ref => ref.value)));\n  }\n  if (meta.id !== null) {\n    definitionMap.set('id', meta.id);\n  }\n  return definitionMap;\n}\nconst MINIMUM_PARTIAL_LINKER_VERSION = '14.0.0';\nfunction compileDeclarePipeFromMetadata(meta) {\n  const definitionMap = createPipeDefinitionMap(meta);\n  const expression = importExpr(Identifiers.declarePipe).callFn([definitionMap.toLiteralMap()]);\n  const type = createPipeType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createPipeDefinitionMap(meta) {\n  const definitionMap = new DefinitionMap();\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', literal('21.0.0'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', meta.type.value);\n  if (meta.isStandalone !== undefined) {\n    definitionMap.set('isStandalone', literal(meta.isStandalone));\n  }\n  definitionMap.set('name', literal(meta.pipeName ?? meta.name));\n  if (meta.pure === false) {\n    definitionMap.set('pure', literal(meta.pure));\n  }\n  return definitionMap;\n}\nfunction compileClassDebugInfo(debugInfo) {\n  const debugInfoObject = {\n    className: debugInfo.className\n  };\n  if (debugInfo.filePath) {\n    debugInfoObject.filePath = debugInfo.filePath;\n    debugInfoObject.lineNumber = debugInfo.lineNumber;\n  }\n  if (debugInfo.forbidOrphanRendering) {\n    debugInfoObject.forbidOrphanRendering = literal(true);\n  }\n  const fnCall = importExpr(Identifiers.setClassDebugInfo).callFn([debugInfo.type, mapLiteral(debugInfoObject)]);\n  const iife = arrowFn([], [devOnlyGuardedExpression(fnCall).toStmt()]);\n  return iife.callFn([]);\n}\nfunction compileHmrInitializer(meta) {\n  const moduleName = 'm';\n  const dataName = 'd';\n  const timestampName = 't';\n  const idName = 'id';\n  const importCallbackName = `${meta.className}_HmrLoad`;\n  const namespaces = meta.namespaceDependencies.map(dep => {\n    return new ExternalExpr({\n      moduleName: dep.moduleName,\n      name: null\n    });\n  });\n  const defaultRead = variable(moduleName).prop('default');\n  const replaceCall = importExpr(Identifiers.replaceMetadata).callFn([meta.type, defaultRead, literalArr(namespaces), literalArr(meta.localDependencies.map(l => l.runtimeRepresentation)), variable('import').prop('meta'), variable(idName)]);\n  const replaceCallback = arrowFn([new FnParam(moduleName)], defaultRead.and(replaceCall));\n  const url = importExpr(Identifiers.getReplaceMetadataURL).callFn([variable(idName), variable(timestampName), variable('import').prop('meta').prop('url')]);\n  const importCallback = new DeclareFunctionStmt(importCallbackName, [new FnParam(timestampName)], [new DynamicImportExpr(url, null, '@vite-ignore').prop('then').callFn([replaceCallback]).toStmt()], null, StmtModifier.Final);\n  const updateCallback = arrowFn([new FnParam(dataName)], variable(dataName).prop('id').identical(variable(idName)).and(variable(importCallbackName).callFn([variable(dataName).prop('timestamp')])));\n  const initialCall = variable(importCallbackName).callFn([variable('Date').prop('now').callFn([])]);\n  const hotRead = variable('import').prop('meta').prop('hot');\n  const hotListener = hotRead.clone().prop('on').callFn([literal('angular:component-update'), updateCallback]);\n  return arrowFn([], [new DeclareVarStmt(idName, literal(encodeURIComponent(`${meta.filePath}@${meta.className}`)), null, StmtModifier.Final), importCallback, devOnlyGuardedExpression(initialCall).toStmt(), devOnlyGuardedExpression(hotRead.and(hotListener)).toStmt()]).callFn([]);\n}\nfunction compileHmrUpdateCallback(definitions, constantStatements, meta) {\n  const namespaces = 'ÉµÉµnamespaces';\n  const params = [meta.className, namespaces].map(name => new FnParam(name, DYNAMIC_TYPE));\n  const body = [];\n  for (const local of meta.localDependencies) {\n    params.push(new FnParam(local.name));\n  }\n  for (let i = 0; i < meta.namespaceDependencies.length; i++) {\n    body.push(new DeclareVarStmt(meta.namespaceDependencies[i].assignedName, variable(namespaces).key(literal(i)), DYNAMIC_TYPE, StmtModifier.Final));\n  }\n  body.push(...constantStatements);\n  for (const field of definitions) {\n    if (field.initializer !== null) {\n      body.push(variable(meta.className).prop(field.name).set(field.initializer).toStmt());\n      for (const stmt of field.statements) {\n        body.push(stmt);\n      }\n    }\n  }\n  return new DeclareFunctionStmt(`${meta.className}_UpdateMetadata`, params, body, null, StmtModifier.Final);\n}\nconst VERSION = new Version('21.0.0');\npublishFacade(_global);\nexport { AST, ASTWithName, ASTWithSource, AbsoluteSourceSpan, ArrayType, ArrowFunctionExpr, Attribute, Binary, BinaryOperator, BinaryOperatorExpr, BindingPipe, BindingPipeType, BindingType, Block, BlockParameter, BoundElementProperty, BuiltinType, BuiltinTypeName, CUSTOM_ELEMENTS_SCHEMA, Call, Chain, ChangeDetectionStrategy, CombinedRecursiveAstVisitor, CommaExpr, Comment, CompilerConfig, CompilerFacadeImpl, Component, Conditional, ConditionalExpr, ConstantPool, CssSelector, DEFAULT_INTERPOLATION_CONFIG, DYNAMIC_TYPE, DeclareFunctionStmt, DeclareVarStmt, Directive, DomElementSchemaRegistry, DynamicImportExpr, EOF, Element, ElementSchemaRegistry, EmitterVisitorContext, EmptyExpr$1 as EmptyExpr, Expansion, ExpansionCase, Expression, ExpressionBinding, ExpressionStatement, ExpressionType, ExternalExpr, ExternalReference, FactoryTarget, FunctionExpr, HtmlParser, HtmlTagDefinition, I18NHtmlParser, IfStmt, ImplicitReceiver, InstantiateExpr, Interpolation$1 as Interpolation, InterpolationConfig, InvokeFunctionExpr, JSDocComment, JitEvaluator, KeyedRead, LeadingComment, LetDeclaration, Lexer, LiteralArray, LiteralArrayExpr, LiteralExpr, LiteralMap, LiteralMapExpr, LiteralPrimitive, LocalizedString, MapType, MessageBundle, NONE_TYPE, NO_ERRORS_SCHEMA, NodeWithI18n, NonNullAssert, NotExpr, ParenthesizedExpr, ParenthesizedExpression, ParseError, ParseErrorLevel, ParseLocation, ParseSourceFile, ParseSourceSpan, ParseSpan, ParseTreeResult, ParsedEvent, ParsedEventType, ParsedProperty, ParsedPropertyType, ParsedVariable, Parser, PrefixNot, PropertyRead, Identifiers as R3Identifiers, R3NgModuleMetadataKind, R3SelectorScopeMode, R3TargetBinder, R3TemplateDependencyKind, ReadKeyExpr, ReadPropExpr, ReadVarExpr, RecursiveAstVisitor, RecursiveVisitor, RegularExpressionLiteral, RegularExpressionLiteralExpr, ResourceLoader, ReturnStatement, SCHEMA, SECURITY_SCHEMA, STRING_TYPE, SafeCall, SafeKeyedRead, SafePropertyRead, SelectorContext, SelectorListContext, SelectorMatcher, SelectorlessMatcher, Serializer, SplitInterpolation, Statement, StmtModifier, StringToken, StringTokenKind, TagContentType, TaggedTemplateLiteral, TaggedTemplateLiteralExpr, TemplateBindingParseResult, TemplateLiteral, TemplateLiteralElement, TemplateLiteralElementExpr, TemplateLiteralExpr, Text, ThisReceiver, BlockNode as TmplAstBlockNode, BoundAttribute as TmplAstBoundAttribute, BoundDeferredTrigger as TmplAstBoundDeferredTrigger, BoundEvent as TmplAstBoundEvent, BoundText as TmplAstBoundText, Component$1 as TmplAstComponent, Content as TmplAstContent, DeferredBlock as TmplAstDeferredBlock, DeferredBlockError as TmplAstDeferredBlockError, DeferredBlockLoading as TmplAstDeferredBlockLoading, DeferredBlockPlaceholder as TmplAstDeferredBlockPlaceholder, DeferredTrigger as TmplAstDeferredTrigger, Directive$1 as TmplAstDirective, Element$1 as TmplAstElement, ForLoopBlock as TmplAstForLoopBlock, ForLoopBlockEmpty as TmplAstForLoopBlockEmpty, HostElement as TmplAstHostElement, HoverDeferredTrigger as TmplAstHoverDeferredTrigger, Icu$1 as TmplAstIcu, IdleDeferredTrigger as TmplAstIdleDeferredTrigger, IfBlock as TmplAstIfBlock, IfBlockBranch as TmplAstIfBlockBranch, ImmediateDeferredTrigger as TmplAstImmediateDeferredTrigger, InteractionDeferredTrigger as TmplAstInteractionDeferredTrigger, LetDeclaration$1 as TmplAstLetDeclaration, NeverDeferredTrigger as TmplAstNeverDeferredTrigger, RecursiveVisitor$1 as TmplAstRecursiveVisitor, Reference as TmplAstReference, SwitchBlock as TmplAstSwitchBlock, SwitchBlockCase as TmplAstSwitchBlockCase, Template as TmplAstTemplate, Text$3 as TmplAstText, TextAttribute as TmplAstTextAttribute, TimerDeferredTrigger as TmplAstTimerDeferredTrigger, UnknownBlock as TmplAstUnknownBlock, Variable as TmplAstVariable, ViewportDeferredTrigger as TmplAstViewportDeferredTrigger, Token, TokenType, TransplantedType, TreeError, Type, TypeModifier, TypeofExpr, TypeofExpression, Unary, UnaryOperator, UnaryOperatorExpr, VERSION, VariableBinding, Version, ViewEncapsulation$1 as ViewEncapsulation, VoidExpr, VoidExpression, WrappedNodeExpr, Xliff, Xliff2, Xmb, XmlParser, Xtb, _ATTR_TO_PROP, compileClassDebugInfo, compileClassMetadata, compileComponentClassMetadata, compileComponentDeclareClassMetadata, compileComponentFromMetadata, compileDeclareClassMetadata, compileDeclareComponentFromMetadata, compileDeclareDirectiveFromMetadata, compileDeclareFactoryFunction, compileDeclareInjectableFromMetadata, compileDeclareInjectorFromMetadata, compileDeclareNgModuleFromMetadata, compileDeclarePipeFromMetadata, compileDeferResolverFunction, compileDirectiveFromMetadata, compileFactoryFunction, compileHmrInitializer, compileHmrUpdateCallback, compileInjectable, compileInjector, compileNgModule, compileOpaqueAsyncClassMetadata, compilePipeFromMetadata, computeMsgId, core, createCssSelectorFromNode, createInjectableType, createMayBeForwardRefExpression, devOnlyGuardedExpression, emitDistinctChangesOnlyDefaultValue, encapsulateStyle, escapeRegExp, findMatchingDirectivesAndPipes, getHtmlTagDefinition, getNsPrefix, getSafePropertyAccessString, identifierName, isNgContainer, isNgContent, isNgTemplate, jsDocComment, leadingComment, literal, literalMap, makeBindingParser, mergeNsAndName, output_ast as outputAst, parseHostBindings, parseTemplate, preserveWhitespacesDefault, publishFacade, r3JitTypeSourceSpan, sanitizeIdentifier, setEnableTemplateSourceLocations, splitNsName, visitAll$1 as tmplAstVisitAll, verifyHostBindings, visitAll };","map":{"version":3,"names":["_SELECTOR_REGEXP","RegExp","CssSelector","element","classNames","attrs","notSelectors","parse","selector","results","_addResult","res","cssSel","length","push","cssSelector","match","current","inNot","lastIndex","exec","Error","tag","prefix","addAttribute","slice","addClassName","setElement","attribute","unescapeAttribute","attr","result","escaping","i","char","charAt","escapeAttribute","replace","isElementSelector","hasElementSelector","getAttrs","join","concat","name","value","toLowerCase","toString","forEach","klass","notSelector","SelectorMatcher","createNotMatcher","notMatcher","addSelectables","_elementMap","Map","_elementPartialMap","_classMap","_classPartialMap","_attrValueMap","_attrValuePartialMap","_listContexts","cssSelectors","callbackCtxt","listContext","SelectorListContext","_addSelectable","matcher","selectable","SelectorContext","isTerminal","_addTerminal","_addPartial","className","terminalMap","terminalValuesMap","get","set","partialMap","partialValuesMap","map","terminalList","matchedCallback","alreadyMatched","_matchTerminal","_matchPartial","selectables","starSelectables","finalize","nestedSelector","selectors","constructor","cbContext","callback","SelectorlessMatcher","registry","has","emitDistinctChangesOnlyDefaultValue","ViewEncapsulation$1","ViewEncapsulation","ChangeDetectionStrategy","InputFlags","CUSTOM_ELEMENTS_SCHEMA","NO_ERRORS_SCHEMA","Type$1","Function","SecurityContext","MissingTranslationStrategy","parserSelectorToSimpleSelector","classes","elementName","parserSelectorToNegativeSelector","parserSelectorToR3Selector","positive","negative","parseSelectorToR3Selector","core","Object","freeze","__proto__","Type","FactoryTarget","R3TemplateDependencyKind$1","R3TemplateDependencyKind","textEncoder","digest$1","message","id","computeDigest","sha1","serializeNodes","nodes","meaning","decimalDigest","computeDecimalDigest","visitor","_SerializerIgnoreIcuExpVisitor","parts","a","visit","computeMsgId","_SerializerVisitor","visitText","text","context","visitContainer","container","children","child","visitIcu","icu","strCases","keys","cases","k","expression","type","visitTagPlaceholder","ph","isVoid","startName","closeName","visitPlaceholder","visitIcuPlaceholder","visitBlockPlaceholder","serializerVisitor$1","str","TextEncoder","utf8","encode","words32","bytesToWords32","Endian","Big","len","w","Uint32Array","b","c","d","e","h0","h1","h2","h3","h4","j","rol32","fkVal","fk","f","temp","reduce","add32","toHexU32","padStart","index","fingerprint","view","DataView","buffer","byteOffset","byteLength","hi","hash32","lo","BigInt","asUintN","msg","msgFingerprint","end","getUint32","mix","remainder","getUint8","add32to64","low","high","count","bytes","endian","size","wordAt","byteAt","word","TypeModifier","modifiers","None","hasModifier","modifier","BuiltinTypeName","BuiltinType","visitType","visitBuiltinType","ExpressionType","typeParams","visitExpressionType","ArrayType","of","visitArrayType","MapType","valueType","visitMapType","TransplantedType","visitTransplantedType","DYNAMIC_TYPE","Dynamic","INFERRED_TYPE","Inferred","BOOL_TYPE","Bool","INT_TYPE","Int","NUMBER_TYPE","Number","STRING_TYPE","String","FUNCTION_TYPE","NONE_TYPE","UnaryOperator","BinaryOperator","nullSafeIsEquivalent","base","other","isEquivalent","areAllEquivalentPredicate","equivalentPredicate","areAllEquivalent","baseElement","otherElement","Expression","sourceSpan","prop","ReadPropExpr","key","ReadKeyExpr","callFn","params","pure","InvokeFunctionExpr","instantiate","InstantiateExpr","conditional","trueCase","falseCase","ConditionalExpr","equals","rhs","BinaryOperatorExpr","Equals","notEquals","NotEquals","identical","Identical","notIdentical","NotIdentical","minus","Minus","plus","Plus","divide","Divide","multiply","Multiply","modulo","Modulo","power","Exponentiation","and","And","bitwiseOr","BitwiseOr","bitwiseAnd","BitwiseAnd","or","Or","lower","Lower","lowerEquals","LowerEquals","bigger","Bigger","biggerEquals","BiggerEquals","isBlank","TYPED_NULL_EXPR","nullishCoalesce","NullishCoalesce","toStmt","ExpressionStatement","ReadVarExpr","isConstant","visitExpression","visitReadVarExpr","clone","Assign","TypeofExpr","expr","visitTypeofExpr","VoidExpr","visitVoidExpr","WrappedNodeExpr","node","visitWrappedNodeExpr","fn","args","receiver","visitInvokeFunctionExpr","arg","TaggedTemplateLiteralExpr","template","visitTaggedTemplateLiteralExpr","classExpr","visitInstantiateExpr","RegularExpressionLiteralExpr","body","flags","visitRegularExpressionLiteral","LiteralExpr","visitLiteralExpr","TemplateLiteralExpr","elements","expressions","visitTemplateLiteralExpr","el","TemplateLiteralElementExpr","rawText","escapeForTemplateLiteral","escapeSlashes","visitTemplateLiteralElementExpr","LiteralPiece","PlaceholderPiece","associatedMessage","MEANING_SEPARATOR$1","ID_SEPARATOR$1","LEGACY_ID_INDICATOR","LocalizedString","metaBlock","messageParts","placeHolderNames","visitLocalizedString","serializeI18nHead","description","customId","legacyIds","legacyId","createCookedRawString","getMessagePartSourceSpan","getPlaceholderSourceSpan","serializeI18nTemplatePart","partIndex","placeholder","messagePart","messageString","escapeStartingColon","escapeColons","range","cooked","raw","ExternalExpr","moduleName","visitExternalExpr","ExternalReference","condition","visitConditionalExpr","DynamicImportExpr","url","urlComment","visitDynamicImportExpr","NotExpr","visitNotExpr","FnParam","param","FunctionExpr","statements","DeclareFunctionStmt","visitFunctionExpr","toDeclStmt","p","ArrowFunctionExpr","Array","isArray","visitArrowFunctionExpr","DeclareVarStmt","UnaryOperatorExpr","operator","parens","visitUnaryOperatorExpr","ParenthesizedExpr","visitParenthesizedExpr","lhs","visitBinaryOperatorExpr","isAssignment","op","AdditionAssignment","SubtractionAssignment","MultiplicationAssignment","DivisionAssignment","RemainderAssignment","ExponentiationAssignment","AndAssignment","OrAssignment","NullishCoalesceAssignment","visitReadPropExpr","visitReadKeyExpr","LiteralArrayExpr","entries","every","visitLiteralArrayExpr","LiteralMapEntry","quoted","LiteralMapExpr","visitLiteralMapExpr","entriesClone","entry","CommaExpr","visitCommaExpr","NULL_EXPR","StmtModifier","LeadingComment","multiline","trailingNewline","JSDocComment","tags","serializeTags","Statement","leadingComments","addLeadingComment","leadingComment","stmt","visitStatement","visitDeclareVarStmt","visitDeclareFunctionStmt","visitExpressionStmt","ReturnStatement","visitReturnStmt","IfStmt","visitIfStmt","RecursiveAstVisitor$1","RecursiveAstVisitor","ast","visitAllExpressions","visitAllStatements","exprs","stmts","jsDocComment","variable","importExpr","importType","typeModifiers","expressionType","transplantedType","typeofExpr","literalArr","values","literalMap","unary","not","arrowFn","ifStmt","thenClause","elseClause","taggedTemplate","literal","localizedString","placeholderNames","isNull","exp","tagToString","out","tagName","output_ast","CONSTANT_PREFIX","UNKNOWN_VALUE_KEY","KEY_CONTEXT","POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS","FixupExpression","resolved","original","shared","fixup","ConstantPool","isClosureCompilerEnabled","literals","literalFactories","sharedConstants","_claimedNames","nextNameIndex","getConstLiteral","forceShared","isLongStringLiteral","GenericKeyFn","INSTANCE","keyOf","newValue","freshName","usage","Final","getSharedConstant","def","toSharedConstantDeclaration","getLiteralFactory","argumentsForKey","_getLiteralFactory","expressionForKey","getSharedFunctionReference","useUniqueName","isArrow","uniqueName","resultMap","literalFactory","literalFactoryArguments","filter","resultExpressions","parameters","isVariable","pureFunctionDeclaration","alwaysIncludeSuffix","CORE","Identifiers","NEW_METHOD","TRANSFORM_METHOD","PATCH_DEPS","namespaceHTML","namespaceMathML","namespaceSVG","elementStart","elementEnd","domElement","domElementStart","domElementEnd","domElementContainer","domElementContainerStart","domElementContainerEnd","domTemplate","domListener","advance","syntheticHostProperty","syntheticHostListener","classProp","elementContainerStart","elementContainerEnd","elementContainer","styleMap","classMap","styleProp","interpolate","interpolate1","interpolate2","interpolate3","interpolate4","interpolate5","interpolate6","interpolate7","interpolate8","interpolateV","nextContext","resetView","templateCreate","defer","deferWhen","deferOnIdle","deferOnImmediate","deferOnTimer","deferOnHover","deferOnInteraction","deferOnViewport","deferPrefetchWhen","deferPrefetchOnIdle","deferPrefetchOnImmediate","deferPrefetchOnTimer","deferPrefetchOnHover","deferPrefetchOnInteraction","deferPrefetchOnViewport","deferHydrateWhen","deferHydrateNever","deferHydrateOnIdle","deferHydrateOnImmediate","deferHydrateOnTimer","deferHydrateOnHover","deferHydrateOnInteraction","deferHydrateOnViewport","deferEnableTimerScheduling","conditionalCreate","conditionalBranchCreate","repeater","repeaterCreate","repeaterTrackByIndex","repeaterTrackByIdentity","componentInstance","enableBindings","disableBindings","getCurrentView","textInterpolate","textInterpolate1","textInterpolate2","textInterpolate3","textInterpolate4","textInterpolate5","textInterpolate6","textInterpolate7","textInterpolate8","textInterpolateV","restoreView","pureFunction0","pureFunction1","pureFunction2","pureFunction3","pureFunction4","pureFunction5","pureFunction6","pureFunction7","pureFunction8","pureFunctionV","pipeBind1","pipeBind2","pipeBind3","pipeBind4","pipeBindV","domProperty","ariaProperty","property","control","controlCreate","animationEnterListener","animationLeaveListener","animationEnter","animationLeave","i18n","i18nAttributes","i18nExp","i18nStart","i18nEnd","i18nApply","i18nPostprocess","pipe","projection","projectionDef","reference","inject","injectAttribute","directiveInject","invalidFactory","invalidFactoryDep","templateRefExtractor","forwardRef","resolveForwardRef","replaceMetadata","getReplaceMetadataURL","ÉµÉµdefineInjectable","declareInjectable","InjectableDeclaration","resolveWindow","resolveDocument","resolveBody","getComponentDepsFactory","defineComponent","declareComponent","setComponentScope","ComponentDeclaration","FactoryDeclaration","declareFactory","defineDirective","declareDirective","DirectiveDeclaration","InjectorDef","InjectorDeclaration","defineInjector","declareInjector","NgModuleDeclaration","ModuleWithProviders","defineNgModule","declareNgModule","setNgModuleScope","registerNgModuleType","PipeDeclaration","definePipe","declarePipe","declareClassMetadata","declareClassMetadataAsync","setClassMetadata","setClassMetadataAsync","setClassDebugInfo","queryRefresh","viewQuery","loadQuery","contentQuery","viewQuerySignal","contentQuerySignal","queryAdvance","twoWayProperty","twoWayBindingSet","twoWayListener","declareLet","storeLet","readContextLet","attachSourceLocations","NgOnChangesFeature","InheritDefinitionFeature","ProvidersFeature","HostDirectivesFeature","ExternalStylesFeature","listener","getInheritedFactory","sanitizeHtml","sanitizeStyle","sanitizeResourceUrl","sanitizeScript","sanitizeUrl","sanitizeUrlOrResourceUrl","trustConstantHtml","trustConstantResourceUrl","validateIframeAttribute","inputDecorator","outputDecorator","viewChildDecorator","viewChildrenDecorator","contentChildDecorator","contentChildrenDecorator","InputSignalBrandWriteType","UnwrapDirectiveSignalInputs","unwrapWritableSignal","assertType","DASH_CASE_REGEXP","dashCaseToCamelCase","input","m","toUpperCase","splitAtColon","defaultValues","_splitAt","splitAtPeriod","character","characterIndex","indexOf","trim","noUndefined","val","undefined","escapeRegExp","s","utf8Encode","encoded","codePoint","charCodeAt","stringify","token","overriddenName","newLineIndex","Version","full","major","minor","patch","splits","split","_global","globalThis","V1_TO_18","getJitStandaloneDefaultForVersion","version","startsWith","test","VERSION$1","JS_B64_PREFIX","SourceMapGenerator","file","sourcesContent","lines","lastCol0","hasMappings","addSource","content","addLine","addMapping","col0","sourceUrl","sourceLine0","sourceCol0","currentLine","toJSON","sourcesIndex","sources","from","mappings","lastSourceIndex","lastSourceLine0","lastSourceCol0","segments","segment","segAsStr","toBase64VLQ","toJsComment","toBase64String","JSON","b64","i1","i2","i3","toBase64Digit","digit","B64_DIGITS","_SINGLE_QUOTE_ESCAPE_STRING_RE","_LEGAL_IDENTIFIER_RE","_INDENT_WITH","_EmittedLine","indent","partsLength","srcSpans","BINARY_OPERATORS$1","In","EmitterVisitorContext","_indent","createRoot","_lines","_currentLine","println","lastPart","print","lineIsEmpty","lineLength","part","newLine","removeEmptyLastLine","pop","incIndent","decIndent","toSource","sourceLines","l","_createIndent","toSourceMapGenerator","genFilePath","startsAtLine","firstOffsetMapped","mapFirstOffsetIfNeeded","line","lineIdx","spans","spanIdx","span","source","start","sourceLine","sourceCol","col","spanOf","column","emittedLine","columnsLeft","AbstractEmitterVisitor","_escapeDollarInStrings","lastIfCondition","printLeadingComments","ctx","comment","hasElseCase","shouldParenthesize","escapeIdentifier","head","opStr","visitAllObjects","separator","handler","incrementedIndent","escapeDollar","alwaysQuote","requiresQuotes","typeWithParameters","numParams","getSafePropertyAccessString","accessor","escapedName","jitOnlyGuardedExpression","guardedExpression","devOnlyGuardedExpression","guard","guardExpr","guardNotDefined","guardUndefinedOrTrue","wrapReference","wrapped","refsToArray","refs","shouldForwardDeclare","ref","createMayBeForwardRefExpression","convertFromMaybeForwardRefExpression","generateForwardRef","R3FactoryDelegateType","compileFactoryFunction","meta","t","baseFactoryVar","typeForCtor","isDelegatedFactoryMetadata","ctorExpr","deps","injectDependencies","target","retExpr","makeConditionalFactory","nonCtorExpr","r","ctorStmt","delegateArgs","delegateDeps","factoryExpr","delegateType","Class","delegate","isExpressionFactoryMetadata","getInheritedFactoryCall","baseFactory","factoryFn","createFactoryType","ctorDepsType","createCtorDepsType","typeArgumentCount","dep","compileInjectDependency","attributeNameType","self","skipSelf","host","optional","Pipe","flagsParam","injectArgs","injectFn","getInjectFn","hasTypes","attributeTypes","createCtorDepType","Component","Directive","NgModule","Injectable","ParseSpan","toAbsolute","absoluteOffset","AbsoluteSourceSpan","AST","ASTWithName","nameSpan","EmptyExpr$1","EmptyExpr","ImplicitReceiver","visitImplicitReceiver","ThisReceiver","visitThisReceiver","Chain","visitChain","Conditional","trueExp","falseExp","visitConditional","PropertyRead","visitPropertyRead","SafePropertyRead","visitSafePropertyRead","KeyedRead","visitKeyedRead","SafeKeyedRead","visitSafeKeyedRead","BindingPipeType","BindingPipe","visitPipe","LiteralPrimitive","visitLiteralPrimitive","LiteralArray","visitLiteralArray","LiteralMap","visitLiteralMap","Interpolation$1","Interpolation","strings","visitInterpolation","Binary","operation","left","right","visitBinary","isAssignmentOperation","Unary","createMinus","createPlus","binaryOp","binaryLeft","binaryRight","visitUnary","PrefixNot","visitPrefixNot","TypeofExpression","visitTypeofExpression","VoidExpression","visitVoidExpression","NonNullAssert","visitNonNullAssert","Call","argumentSpan","visitCall","SafeCall","visitSafeCall","TaggedTemplateLiteral","visitTaggedTemplateLiteral","TemplateLiteral","visitTemplateLiteral","TemplateLiteralElement","visitTemplateLiteralElement","ParenthesizedExpression","visitParenthesizedExpression","RegularExpressionLiteral","ASTWithSource","location","errors","visitASTWithSource","VariableBinding","ExpressionBinding","visitAll","asts","ParsedProperty","keySpan","valueSpan","isLiteral","isLegacyAnimation","isAnimation","ParsedPropertyType","LITERAL_ATTR","LEGACY_ANIMATION","ANIMATION","ParsedEventType","ParsedEvent","targetOrPhase","handlerSpan","ParsedVariable","BindingType","BoundElementProperty","securityContext","unit","TagContentType","splitNsName","fatal","colonIndex","isNgContainer","isNgContent","isNgTemplate","getNsPrefix","fullName","mergeNsAndName","localName","Comment$1","Comment","_visitor","Text$3","Text","BoundText","visitBoundText","TextAttribute","visitTextAttribute","BoundAttribute","fromBoundElementProperty","visitBoundAttribute","BoundEvent","phase","fromParsedEvent","event","Regular","LegacyAnimation","visitBoundEvent","Element$1","Element","attributes","inputs","outputs","directives","references","isSelfClosing","startSourceSpan","endSourceSpan","visitElement","DeferredTrigger","prefetchSpan","whenOrOnSourceSpan","hydrateSpan","visitDeferredTrigger","BoundDeferredTrigger","whenSourceSpan","NeverDeferredTrigger","IdleDeferredTrigger","ImmediateDeferredTrigger","HoverDeferredTrigger","onSourceSpan","TimerDeferredTrigger","delay","InteractionDeferredTrigger","ViewportDeferredTrigger","options","BlockNode","DeferredBlockPlaceholder","minimumTime","visitDeferredBlockPlaceholder","DeferredBlockLoading","afterTime","visitDeferredBlockLoading","DeferredBlockError","visitDeferredBlockError","DeferredBlock","loading","error","mainBlockSpan","triggers","prefetchTriggers","hydrateTriggers","definedTriggers","definedPrefetchTriggers","definedHydrateTriggers","visitDeferredBlock","visitTriggers","visitAll$1","remainingBlocks","x","SwitchBlock","unknownBlocks","visitSwitchBlock","SwitchBlockCase","visitSwitchBlockCase","ForLoopBlock","item","trackBy","trackKeywordSpan","contextVariables","empty","visitForLoopBlock","ForLoopBlockEmpty","visitForLoopBlockEmpty","IfBlock","branches","visitIfBlock","IfBlockBranch","expressionAlias","visitIfBlockBranch","UnknownBlock","visitUnknownBlock","LetDeclaration$1","LetDeclaration","visitLetDeclaration","Component$1","componentName","visitComponent","Directive$1","visitDirective","Template","templateAttrs","variables","visitTemplate","Content","visitContent","Variable","visitVariable","Reference","visitReference","Icu$1","Icu","vars","placeholders","HostElement","tagNames","bindings","listeners","RecursiveVisitor$1","RecursiveVisitor","deferred","block","blockItems","component","directive","trigger","decl","newNode","Message","placeholderToMessage","serializeMessage","filePath","startLine","startCol","endLine","endCol","Text$2","Container","expressionPlaceholder","TagPlaceholder","Placeholder","IcuPlaceholder","previousMessage","BlockPlaceholder","CloneVisitor","n","RecurseVisitor","messageNodes","LocalizeMessageStringVisitor","Serializer","createNameMapper","SimplePlaceholderMapper","mapName","internalToPublic","publicToNextId","publicToInternal","toPublicName","internalName","hasOwnProperty","toInternalName","publicName","visitPlaceholderName","nextId","_Visitor$2","_Visitor","visitTag","strAttrs","_serializeAttributes","strChildren","visitDeclaration","visitDoctype","doctype","rootTag","dtd","serialize$1","Declaration","unescapedAttrs","escapeXml","Doctype","Tag","Text$1","unescapedValue","CR","ws","_ESCAPED_CHARS","_XMB_HANDLER","_MESSAGES_TAG","_MESSAGE_TAG","_PLACEHOLDER_TAG$3","_EXAMPLE_TAG","_SOURCE_TAG$2","_DOCTYPE","Xmb","write","messages","locale","exampleVisitor","ExampleVisitor","_Visitor$1","rootNode","sourceTags","serialize","encoding","addDefaultExamples","load","digest","startTagAsText","startEx","startTagPh","closeTagAsText","closeEx","closeTagPh","interpolationAsText","exTag","startAsText","closeAsText","icuExpression","icuType","icuCases","icuAsText","exText","I18N_ATTR","I18N_ATTR_PREFIX","I18N_ICU_VAR_PREFIX","isI18nAttribute","hasI18nAttrs","some","icuFromI18nMessage","formatI18nPlaceholderNamesInMap","useCamelCase","_params","formatI18nPlaceholderName","chunks","postfix","shift","UNSAFE_OBJECT_KEY_NAME_REGEXP","TEMPORARY_NAME","CONTEXT_NAME","RENDER_FLAGS","temporaryAllocator","pushStatement","asLiteral","conditionallyCreateDirectiveBindingLiteral","forInputs","getOwnPropertyNames","declaredName","minifiedName","expressionValue","classPropertyName","bindingPropertyName","differentDeclaringName","hasDecoratorInputTransform","transformFunction","isSignal","SignalBased","HasDecoratorInputTransform","DefinitionMap","existing","find","toLiteralMap","createCssSelectorFromNode","getAttrsForDirectiveMatching","elementNameNoNs","nameNoNs","elOrTpl","attributesMap","Property","TwoWay","o","compileInjectable","resolveForwardRefs","factoryMeta","useClass","useClassOnSelf","delegateToFactory","useFactory","useValue","useExisting","injectableProps","providedIn","createInjectableType","useType","unwrapForwardRefs","createFactoryFunction","unwrappedType","$EOF","$BSPACE","$TAB","$LF","$VTAB","$FF","$CR","$SPACE","$BANG","$DQ","$HASH","$$","$PERCENT","$AMPERSAND","$SQ","$LPAREN","$RPAREN","$STAR","$PLUS","$COMMA","$MINUS","$PERIOD","$SLASH","$COLON","$SEMICOLON","$LT","$EQ","$GT","$QUESTION","$0","$7","$9","$A","$E","$F","$X","$Z","$LBRACKET","$BACKSLASH","$RBRACKET","$CARET","$_","$a","$b","$e","$f","$n","$r","$t","$u","$v","$x","$z","$LBRACE","$BAR","$RBRACE","$NBSP","$AT","$BT","isWhitespace","code","isDigit","isAsciiLetter","isAsciiHexDigit","isNewLine","isOctalDigit","isQuote","ParseLocation","offset","moveBy","delta","ch","priorLine","substring","lastIndexOf","fromCharCode","getContext","maxChars","maxLines","startOffset","endOffset","ctxChars","ctxLines","before","after","ParseSourceFile","ParseSourceSpan","fullStart","details","ParseErrorLevel","ParseError","level","relatedError","ERROR","setPrototypeOf","new","prototype","contextualMessage","r3JitTypeSourceSpan","kind","typeName","sourceFileName","sourceFile","_anonymousTypeIndex","identifierName","compileIdentifier","identifier","sanitizeIdentifier","makeTemplateObjectPolyfill","AbstractJsEmitterVisitor","_visitParams","isObjectLiteral","policy","getPolicy","trustedTypes","createPolicy","createScript","trustedScriptFromString","script","newTrustedFunctionForJIT","fnArgs","fnBody","bind","JitEvaluator","evaluateStatements","refResolver","createSourceMaps","converter","JitEmitterVisitor","isUseStrictStatement","createReturnStmt","evaluateCode","getArgs","createSourceMap","fnArgNames","fnArgValues","argName","emptyFn","headerLines","executeFunction","_evalArgNames","_evalArgValues","_evalExportedVars","resultVar","_emitReferenceToExternal","resolveExternalReference","Exported","statement","compileInjector","definitionMap","providers","imports","createInjectorType","R3JitReflector","R3SelectorScopeMode","R3NgModuleMetadataKind","compileNgModule","Global","bootstrap","containsForwardDecls","selectorScopeMode","Inline","declarations","exports","SideEffect","setNgModuleScopeCall","generateSetNgModuleScopeCall","schemas","createNgModuleType","compileNgModuleDeclarationExpression","Local","moduleType","includeImportTypes","publicDeclarationTypes","tupleTypeOf","tupleOfTypes","scopeMap","declarationsExpression","importsExpression","exportsExpression","bootstrapExpression","fnCall","guardedCall","iife","iifeCall","types","typeofTypes","compilePipeFromMetadata","metadata","definitionMapValues","pipeName","isStandalone","createPipeType","animationKeywords","Set","scopedAtRuleIdentifiers","ShadowCss","shimCssText","cssText","hostSelector","comments","_commentRe","_commentWithHashRe","newLinesMatches","_newLinesRe","COMMENT_PLACEHOLDER","_insertDirectives","scopedCssText","_scopeCssText","commentIdx","_commentWithHashPlaceHolderRe","_insertPolyfillDirectivesInCssText","_insertPolyfillRulesInCssText","_scopeKeyframesRelatedCss","scopeSelector","unscopedKeyframesSet","scopedKeyframesCssText","processRules","rule","_scopeLocalKeyframeDeclarations","_scopeAnimationRule","_","quote","keyframeName","endSpaces","add","unescapeQuotes","_scopeAnimationKeyframe","keyframe","spaces1","spaces2","_animationDeclarationKeyframesRe","animationDeclarations","leadingSpaces","quotedName","nonQuotedName","_match","commaSeparatedKeyframes","_cssContentNextSelectorRe","_cssContentRuleRe","unscopedRules","_extractUnscopedRulesFromCssText","_insertPolyfillHostInCssText","_convertColonHost","_convertColonHostContext","_convertShadowDOMSelectors","_scopeSelectors","_cssContentUnscopedRuleRe","_cssColonHostRe","hostSelectors","otherSelectors","convertedSelectors","_splitOnTopLevelCommas","trimmedHostSelector","convertedSelector","_polyfillHostNoCombinator","_polyfillHost","returnOnClosingParen","prev","charCode","_convertColonHostContextInSelectorPart","_cssColonHostContextReGlobal","selectorText","pseudoPrefix","contextSelectorGroups","startIndex","_polyfillHostContext","afterPrefix","newContextSelectors","endIndex","trimmed","contextSelectorGroupsLength","repeatGroups","contextSelectors","_combineHostContextSelectors","_shadowDOMSelectorsRe","pattern","_scopeSelector","isParentSelector","atRule","_stripScopingSelectors","CssRule","_shadowDeepSelectors","_polyfillHostNoCombinatorRe","_safeSelector","_shouldScopeIndicator","selectorSplitRe","deepParts","shallowPart","otherParts","applyScope","_selectorNeedsScoping","_applySelectorScope","re","_makeScopeMatcher","lre","rre","_selectorReSuffix","_applySimpleSelectorScope","_polyfillHostRe","replaceBy","_hnc","colon","isRe","attrName","_scopeSelectorPart","scopedP","includes","_polyfillHostNoCombinatorOutsidePseudoFunction","matches","_pseudoFunctionAwareScopeSelectorPart","selectorPart","scopedPart","pseudoSelectorParts","pseudoSelectorMatch","_cssPrefixWithPseudoSelectorFunction","openedBrackets","currentSymbol","cssPseudoSelectorFunction","selectorToScope","scopedInnerPart","SafeSelector","scopedSelector","sep","hasHost","restore","_colonHostContextRe","_colonHostRe","_content","_escapeRegexMatches","keep","nthRegex","pseudo","_ph","_cssScopedPseudoFunctionPrefix","_noParens","_level1Parens","_level2Parens","_parenSuffix","_hostContextPattern","BLOCK_PLACEHOLDER","_ruleRe","CONTENT_PAIRS","COMMA_IN_PLACEHOLDER","SEMI_IN_PLACEHOLDER","COLON_IN_PLACEHOLDER","_cssCommaInPlaceholderReGlobal","_cssSemiInPlaceholderReGlobal","_cssColonInPlaceholderReGlobal","ruleCallback","escaped","escapeInStrings","inputWithEscapedBlocks","escapeBlocks","nextBlockIndex","escapedResult","escapedString","suffix","contentPrefix","blocks","unescapeInStrings","StringWithEscapedBlocks","charPairs","resultParts","escapedBlocks","openCharCount","nonBlockStartIndex","blockStartIndex","openChar","closeChar","ESCAPE_IN_STRING_MAP","currentQuoteChar","substr","isQuoted","hostMarker","otherSelectorsHasHost","combined","contextSelector","previousSelectors","groups","multiples","OpKind","ExpressionKind","VariableFlags","SemanticVariableKind","CompatibilityMode","BindingKind","I18nParamResolutionTime","I18nExpressionFor","I18nParamValueFlags","Namespace","DeferTriggerKind","I18nContextKind","TemplateKind","ConsumesSlot","Symbol","DependsOnSlotContext","ConsumesVarsTrait","UsesVarOffset","TRAIT_CONSUMES_SLOT","numSlotsUsed","TRAIT_DEPENDS_ON_SLOT_CONTEXT","TRAIT_CONSUMES_VARS","hasConsumesSlotTrait","hasDependsOnSlotContextTrait","hasConsumesVarsTrait","hasUsesVarOffsetTrait","createStatementOp","NEW_OP","createVariableOp","xref","initializer","debugListId","next","createInterpolateTextOp","interpolation","InterpolateText","i18nPlaceholders","createBindingOp","isTextAttribute","isStructuralTemplateAttribute","templateKind","i18nMessage","Binding","bindingKind","i18nContext","createPropertyOp","sanitizer","createTwoWayPropertyOp","TwoWayProperty","createStylePropOp","StyleProp","createClassPropOp","ClassProp","createStyleMapOp","StyleMap","createClassMapOp","ClassMap","createAttributeOp","namespace","Attribute","createAdvanceOp","Advance","createConditionalOp","conditions","processed","contextValue","createRepeaterOp","targetSlot","collection","Repeater","createAnimationBindingOp","animationKind","animationBindingKind","AnimationBinding","createDeferWhenOp","DeferWhen","createI18nExpressionOp","i18nOwner","handle","icuPlaceholder","i18nPlaceholder","resolutionTime","I18nExpression","createI18nApplyOp","owner","I18nApply","createStoreLetOp","StoreLet","createControlOp","Control","isIrExpression","ExpressionBase","LexicalReadExpr","LexicalRead","transformInternalExpressions","ReferenceExpr","StoreLetExpr","transform","transformExpressionsInExpression","ContextLetReferenceExpr","ContextLetReference","ContextExpr","Context","TrackContextExpr","TrackContext","NextContextExpr","NextContext","steps","GetCurrentViewExpr","GetCurrentView","RestoreViewExpr","RestoreView","ResetViewExpr","ResetView","TwoWayBindingSetExpr","TwoWayBindingSet","ReadVariableExpr","ReadVariable","PureFunctionExpr","varOffset","idx","VisitorContextFlag","InChildOperation","PureFunctionParameterExpr","PipeBindingExpr","PipeBinding","PipeBindingVariadicExpr","numArgs","PipeBindingVariadic","SafePropertyReadExpr","SafeKeyedReadExpr","SafeInvokeFunctionExpr","SafeInvokeFunction","SafeTernaryExpr","AssignTemporaryExpr","ReadTemporaryExpr","SlotLiteralExpr","slot","ConditionalCaseExpr","alias","ConditionalCase","ConstCollectedExpr","ConstCollected","visitExpressionsInOp","transformExpressionsInOp","transformExpressionsInInterpolation","AnimationString","DomProperty","transformExpressionsInStatement","Animation","AnimationListener","Listener","TwoWayListener","innerOp","handlerOps","ExtractedAttribute","trustedValueFn","RepeaterCreate","trackByOps","track","trackByFn","Defer","loadingConfig","placeholderConfig","resolverFn","I18nMessage","postprocessingParams","ContainerEnd","ContainerStart","DeferOn","DisableBindings","ElementEnd","ElementStart","EnableBindings","I18n","I18nContext","I18nEnd","I18nStart","IcuEnd","IcuStart","Projection","ProjectionDef","I18nAttributes","DeclareLet","SourceLocation","ConditionalCreate","ConditionalBranchCreate","ControlCreate","caseStatement","isStringLiteral","OpList","nextListId","ListEnd","tail","assertIsNotEnd","assertIsUnowned","oldLast","prepend","ops","first","iterator","assertIsOwned","reversed","oldOp","newOp","replaceWithMany","newOps","remove","listId","oldPrev","oldNext","last","insertBefore","insertAfter","byList","SlotHandle","elementContainerOpKinds","isElementOrContainerOp","createElementStartOp","wholeSourceSpan","localRefs","nonBindable","createTemplateOp","functionNameSuffix","decls","createConditionalCreateOp","createConditionalBranchCreateOp","createRepeaterCreateOp","primaryView","emptyView","varNames","emptyTag","emptyI18nPlaceholder","emptyAttributes","HTML","usesComponentInstance","createElementEndOp","createDisableBindingsOp","createEnableBindingsOp","createTextOp","initialValue","createAnimationStringOp","createAnimationOp","callbackOps","handlerFnName","createListenerOp","legacyAnimationPhase","eventTarget","hostListener","handlerList","consumesDollarEvent","isLegacyAnimationListener","createAnimationListenerOp","createTwoWayListenerOp","createPipeOp","createNamespaceOp","active","createProjectionDefOp","createProjectionOp","fallbackView","projectionSlotIndex","createExtractedAttributeOp","createDeferOp","main","mainSlot","ownResolverFn","mainView","loadingView","loadingSlot","loadingMinimumTime","loadingAfterTime","placeholderView","placeholderSlot","placeholderMinimumTime","errorView","errorSlot","createDeferOnOp","createDeclareLetOp","createI18nMessageOp","i18nBlock","messagePlaceholder","needsPostprocessing","subMessages","createI18nStartOp","root","messageIndex","subTemplateIndex","createI18nEndOp","createIcuStartOp","createIcuEndOp","createIcuPlaceholderOp","expressionPlaceholders","createI18nContextOp","contextKind","Attr","createI18nAttributesOp","i18nAttributesConfig","createSourceLocationOp","templatePath","locations","createControlCreateOp","createDomPropertyOp","CTX_REF","CompilationJobKind","TemplateCompilationMode","CompilationJob","pool","compatibility","mode","Both","allocateXrefId","nextXrefId","ComponentCompilationJob","relativeContextFilePath","i18nUseExternalIds","deferMeta","allDeferrableDepsFn","relativeTemplatePath","enableDebugLocations","ViewCompilationUnit","views","Tmpl","fnSuffix","contentSelectors","allocateView","parent","units","addConst","newConst","initializers","consts","constsInitializers","CompilationUnit","create","update","fnName","listenerOp","trackOp","job","aliases","HostBindingCompilationJob","HostBindingCompilationUnit","Host","deleteAnyCasts","removeAnys","applyI18nExpressions","i18nContexts","needsApplication","assignI18nSlotDependencies","updateOp","i18nExpressionsInProgress","state","createOp","blockXref","lastSlotConsumer","I18nText","opToRemove","hasDifferentTarget","createOpXrefMap","extractAttributes","extractAttributeOp","lookupElement$3","TemplateDefinitionBuilder","STYLE","extractedAttributeOp","NONE","extractable","ownerOp","ARIA_PREFIX","isAriaAttribute","lookupElement$2","specializeBindings","DomOnly","ClassName","StyleProperty","CHAIN_COMPATIBILITY","MAX_CHAIN_LENGTH","chain","chainOperationsInList","opList","instruction","collapseSingletonInterpolations","eligibleOpKind","generateConditionalExpressions","defaultCase","findIndex","cond","splice","tmp","caseExpressionTemporaryXref","conditionalCase","useTmp","BINARY_OPERATORS","namespaceForKey","namespacePrefixKey","NAMESPACES","SVG","Math","keyForNamespace","prefixWithNamespace","strippedTag","literalOrArrayLiteral","collectElementConsts","allElementAttributes","ElementAttributes","attrArray","serializeAttributes","getConstIndex","FLYWEIGHT_ARRAY","known","byKind","propertyBindings","projectAs","styles","isKnown","nameToValue","allowDuplicates","array","arrayFor","getAttributeNameLiterals","nameLiteral","parsedR3Selector","lookupElement$1","convertAnimations","getAnimationOp","convertI18nBindings","i18nAttributesByElem","i18nAttributesForElem","Creation","I18nAttribute","createI18nContexts","attrContextByMessage","blockContextByI18nBlock","contextOp","RootI18n","rootContext","currentI18nOp","deduplicateTextBindings","seen","seenForElement","configureDeferInstructions","resolveDeferTargetNames","scopes","getScopeForView","scope","Scope$1","targets","resolveTrigger","deferOwnerView","Idle","Never","Immediate","Timer","Hover","Interaction","Viewport","targetName","placeholderOp","targetXref","targetView","targetSlotViewSteps","step","defers","deferOp","Scope","REPLACEMENTS","IGNORED_OP_KINDS","collapseEmptyInstructions","opReplacements","startKind","mergedKind","prevOp","expandSafeReads","safeTransform","ternaryTransform","needsTemporaryInSafeAccess","temporariesIn","temporaries","eliminateTemporaryAssignments","tmps","read","safeTernaryWithTemporary","isSafeAccessExpression","isUnsafeAccessExpression","isAccessExpression","deepestSafeTernary","st","dst","ESCAPE$1","ELEMENT_MARKER","TEMPLATE_MARKER","TAG_CLOSE_MARKER","CONTEXT_MARKER","LIST_START_MARKER","LIST_END_MARKER","LIST_DELIMITER","extractI18nMessages","i18nMessagesByContext","i18nBlocks","i18nMessageOp","createI18nMessage","currentIcu","icuContext","rootI18nBlock","rootMessage","subMessage","formatIcuPlaceholder","formattedParams","formatParams","formattedPostprocessingParams","v","formatValue","flatMap","placeholderValues","serializedValues","formatParamValues","ElementTag","TemplateTag","elementValue","templateValue","OpenTag","CloseTag","tagMarker","closeMarker","generateAdvance","slotMap","slotContext","consumer","generateLocalLetReferences","Identifier","local","generateProjectionDefs","share","defExpr","generateVariables","recursivelyProcessView","parentScope","generateVariablesInScopeForView","viewContextVariable","letDeclarations","targetId","isCallback","scopeView","AlwaysInline","collectConstExpressions","STYLE_DOT","CLASS_DOT","STYLE_BANG","CLASS_BANG","BANG_IMPORTANT","parseHostStyleProperties","endsWith","isCssCustomProperty","hyphenate$1","parseProperty","overrideIndex","unitIndex","mapLiteral","obj","IcuSerializerVisitor","formatPh","serializer","serializeIcuNode","NodeWithI18n","tokens","Expansion","switchValue","switchValueSourceSpan","visitExpansion","ExpansionCase","valueSourceSpan","expSourceSpan","visitExpansionCase","valueTokens","visitAttribute","visitComment","Block","visitBlock","BlockParameter","visitBlockParameter","astResult","visitChildren","cb","apply","NAMED_ENTITIES","NGSP_UNICODE","TokenizeResult","nonNormalizedIcuExpressions","tokenize","getTagDefinition","tokenizer","_Tokenizer","mergeTextTokens","_CR_OR_CRLF_REGEXP","_unexpectedCharacterErrorMsg","_unknownEntityErrorMsg","entitySrc","_unparsableEntityErrorMsg","entityStr","CharacterReferenceType","SUPPORTED_BLOCKS","INTERPOLATION","_getTagDefinition","_cursor","_tokenizeIcu","_leadingTriviaCodePoints","_currentTokenStart","_currentTokenType","_expansionCaseStack","_openDirectiveCount","_inInterpolation","_preserveLineEndings","_i18nNormalizeLineEndingsInICUs","_tokenizeBlocks","_tokenizeLet","_selectorlessEnabled","_file","tokenizeExpansionForms","leadingTriviaChars","codePointAt","endPos","startPos","EscapedCharacterCursor","PlainCharacterCursor","preserveLineEndings","i18nNormalizeLineEndingsInICUs","tokenizeBlocks","tokenizeLet","selectorlessEnabled","init","handleError","_processCarriageReturns","peek","_attemptCharCode","_consumeCdata","_consumeComment","_consumeDocType","_consumeTagClose","_consumeTagOpen","_isLetStart","_consumeLetDeclaration","_isBlockStart","_consumeBlockStart","_isInExpansionCase","_isInExpansionForm","_consumeBlockEnd","_tokenizeExpansionForm","_consumeWithInterpolation","_isTextEnd","_isTagStart","_beginToken","_endToken","_getBlockName","spacesInNameAllowed","nameCursor","_attemptCharCodeUntilFn","isBlockNameChar","getChars","_requireCharCode","startToken","_consumeBlockParameters","isNotWhitespace","isBlockParameterChar","inQuote","openParens","_requireStr","_getLetDeclarationName","_consumeLetDeclarationValue","endChar","getSpan","allowDigit","inner","isExpansionFormStart","_consumeExpansionFormStart","isExpansionCaseStart","_consumeExpansionCaseStart","_consumeExpansionCaseEnd","_consumeExpansionFormEnd","_createError","CursorError","cursor","_attemptCharCodeCaseInsensitive","compareCharCodeCaseInsensitive","_attemptStr","chars","charsLeft","initialPosition","_attemptStrCaseInsensitive","predicate","_requireCharCodeUntilFn","diff","_attemptUntilChar","_readChar","fromCodePoint","_peekStr","blockName","_consumeEntity","textTokenType","isHex","codeStart","isDigitEntityEnd","entityType","HEX","DEC","strNum","parseInt","nameStart","isNamedEntityEnd","_consumeRawText","consumeEntities","endMarkerPredicate","tagCloseStart","foundEndMarker","contentStart","_consumePrefixAndName","endPredicate","nameOrPrefixStart","isPrefixEnd","closingTagName","openToken","isSelectorlessNameStart","_consumeComponentOpenStart","_consumeTagOpenStart","isAttributeTerminator","_consumeDirective","_consumeAttribute","_consumeComponentOpenEnd","_consumeTagOpenEnd","contentTokenType","getContentType","RAW_TEXT","_consumeRawTextWithTagClose","ESCAPABLE_RAW_TEXT","isNameEnd","_consumeComponentName","isSelectorlessNameChar","_consumeAttributeName","_consumeAttributeValue","attrNameStart","nameEndPredicate","openBrackets","prefixAndName","quoteChar","_consumeQuote","tokenType","_readUntil","normalizedCondition","conditionToken","interpolationTokenType","endInterpolation","_consumeInterpolation","interpolationStart","prematureEndPredicate","expressionStart","inComment","_getProcessedChars","_isInExpansion","isInterpolation","code1","code2","toUpperCaseCharCode","srcTokens","dstTokens","lastDstToken","fileOrCursor","advanceState","updatePeek","leadingTriviaCodePoints","startLocation","locationFromCursor","endLocation","fullStartLocation","pos","currentChar","internalState","processEscapeSequence","digitStart","decodeHexDigits","octal","previous","hex","isNaN","TreeError","ParseTreeResult","rootNodes","Parser$1","Parser","tokenizeResult","parser","_TreeBuilder","build","tagDefinitionResolver","_index","_peek","_containerStack","_advance","_consumeElementStartTag","_consumeElementEndTag","_closeVoidElement","_consumeText","_consumeExpansion","_consumeBlockOpen","_consumeBlockClose","_consumeIncompleteBlock","_consumeLet","_consumeIncompleteLet","_consumeComponentStartTag","_consumeComponentEndTag","leftoverContainer","_advanceIf","_startToken","endToken","_addToParent","expCase","_parseExpansionCase","_collectExpansionExpTokens","expansionCaseParser","expansionFormStack","lastOnStack","startSpan","_getContainer","ignoreFirstLf","decodeEntity","endSpan","startTagToken","_consumeAttributesAndDirectives","_getElementFullName","_getClosestElementLikeParent","tagDef","selfClosing","canSelfClose","isClosedByChild","_pushContainer","_popContainer","closestElement","_getComponentTagName","_getComponentFullName","attributesResult","directivesResult","_consumeAttr","errMsg","nodeOrName","endTagToken","expectedName","expectedType","unexpectedCloseTagDetected","stackIndex","nodeName","closedByParent","attrEnd","valueStartSpan","valueEnd","nextTokenType","valueToken","quoteToken","nameToken","startSourceSpanEnd","paramToken","nameString","_getPrefix","implicitNamespacePrefix","parentName","parentTagName","parentTagDefinition","preventNamespaceInheritance","stack","entity","PRESERVE_WS_ATTR_NAME","SKIP_WS_TRIM_TAGS","WS_CHARS","NO_WS_REGEXP","WS_REPLACE_REGEXP","hasPreserveWhitespacesAttr","replaceNgsp","WhitespaceVisitor","preserveSignificantWhitespace","originalNodeMap","requireContext","icuExpansionDepth","newElement","visitAllWithSiblings","isNotBlank","hasExpansionSibling","inIcuExpansion","createWhitespaceProcessedTextToken","firstToken","trimLeadingWhitespace","lastToken","trimTrailingWhitespace","processWhitespace","trimLeadingAndTrailingWhitespace","expansion","newExpansion","expansionCase","newExpansionCase","newBlock","parameter","_node","isFirstTokenInTag","transformTextToken","trimStart","isLastTokenInTag","trimEnd","maybeTrimmedStart","maybeTrimmed","TokenType","StringTokenKind","KEYWORDS","Lexer","_Scanner","scan","Token","numValue","strValue","isCharacter","Character","isNumber","isString","isOperator","Operator","isIdentifier","isPrivateIdentifier","PrivateIdentifier","isKeyword","Keyword","isKeywordLet","isKeywordAs","isKeywordNull","isKeywordUndefined","isKeywordTrue","isKeywordFalse","isKeywordThis","isKeywordTypeof","isKeywordVoid","isKeywordIn","isError","isRegExpBody","RegExpBody","isRegExpFlags","RegExpFlags","toNumber","isTemplateLiteralPart","TemplateLiteralPart","isTemplateLiteralEnd","TemplateLiteralEnd","isTemplateLiteralInterpolationStart","StringToken","newCharacterToken","newIdentifierToken","newPrivateIdentifierToken","newKeywordToken","newOperatorToken","newNumberToken","newErrorToken","newRegExpBodyToken","newRegExpFlagsToken","EOF","braceStack","scanToken","isIdentifierStart","scanIdentifier","scanNumber","scanCharacter","scanOpenBrace","scanCloseBrace","scanString","scanTemplateLiteralPart","scanPrivateIdentifier","scanComplexOperator","isStartOfRegex","scanRegex","scanOperator","scanStar","scanQuestion","currentBrace","one","twoCode","two","threeCode","three","isIdentifierPart","simple","hasSeparators","isExponentStart","isExponentSign","parseIntAutoRadix","parseFloat","marker","scanStringBackslash","Plain","dollar","position","unescapedCode","unescape","prevToken","beforePrevToken","isNegation","tokenStart","textStart","inEscape","inCharacterClass","bodyToken","flagsToken","scanRegexFlags","SplitInterpolation","offsets","TemplateBindingParseResult","templateBindings","warnings","getLocation","_lexer","_supportsDirectPipeReferences","parseAction","parseSourceSpan","_checkNoInterpolation","stripped","sourceToLex","_stripComments","_ParseAST","parseChain","parseBinding","_parseBindingAst","checkSimpleExpression","checker","SimpleExpressionChecker","parseSimpleBinding","simplExpressionErrors","getParseError","parseTemplateBindings","templateKey","absoluteKeyOffset","absoluteValueOffset","parseInterpolation","interpolatedTokens","splitInterpolation","expressionNodes","expressionSpan","expressionText","hasComments","createInterpolationAst","parseInterpolationExpression","inputToTemplateIndexMap","getIndexMapForOriginalTemplate","atInterpolation","extendLastString","interpStart","interpEnd","exprStart","exprEnd","_getInterpolationEndIndex","fullEnd","startInOriginalTemplate","piece","wrapLiteralPrimitive","sourceSpanOrLocation","_commentStart","outerQuote","nextChar","charIndex","_forEachUnquotedChar","expressionEnd","currentQuote","escapeCount","ParseContextFlags","SUPPORTED_REGEX_FLAGS","parseFlags","supportsDirectPipeReferences","rparensExpected","rbracketsExpected","rbracesExpected","sourceSpanCache","atEOF","inputIndex","currentEndIndex","curToken","currentAbsoluteOffset","artificialEndIndex","serial","withContext","ret","consumeOptionalCharacter","peekKeywordLet","peekKeywordAs","expectCharacter","consumeOptionalOperator","isAssignmentOperator","expectOperator","prettyPrintToken","tok","expectIdentifierOrKeyword","_reportErrorForPrivateIdentifier","expectIdentifierOrKeywordOrString","parsePipe","errorIndex","artificialStart","artificialEnd","parseExpression","nameId","fullSpanEnd","ReferencedDirectly","ReferencedByName","parseConditional","parseLogicalOr","yes","no","parseLogicalAnd","parseNullishCoalescing","parseEquality","parseRelational","parseAdditive","parseMultiplicative","parseExponentiation","parsePrefix","parseCallChain","parsePrimary","parseAccessMember","parseCall","parseKeyedReadOrWrite","parseNoInterpolationTaggedTemplateLiteral","parseTaggedTemplateLiteral","parseExpressionList","parseLiteralMap","parseNoInterpolationTemplateLiteral","parseTemplateLiteral","literalValue","parseRegularExpressionLiteral","terminator","keyStart","literalMapKey","isShorthandInitialized","readReceiver","isSafe","Writable","argumentStart","parseCallArguments","positionals","expectTemplateBindingKey","operatorFound","parseDirectiveKeywordBindings","letBinding","parseLetBinding","binding","parseAsBinding","consumeStatementTerminator","binaryReceiver","getDirectiveBoundTarget","spanEnd","asBinding","spanStart","partStart","seenFlags","getErrorLocationText","skip","extraMessage","errorMessage","locationText","offsetMap","consumedInOriginalTemplate","consumedInInput","tokenIndex","currentToken","decoded","lengthOfParts","sum","SerializeExpressionVisitor","interleave","zip","max","_SECURITY_SCHEMA","SECURITY_SCHEMA","registerContext","URL","RESOURCE_URL","specs","spec","IFRAME_SECURITY_SENSITIVE_ATTRS","isIframeSecuritySensitiveAttr","ElementSchemaRegistry","BOOLEAN","NUMBER","STRING","OBJECT","SCHEMA","_ATTR_TO_PROP","_PROP_TO_ATTR","inverted","propertyName","attributeName","DomElementSchemaRegistry","_schema","_eventSchema","encodedType","events","strType","strProperties","properties","typeNames","superName","superType","superEvent","hasProperty","propName","schemaMetas","schema","elementProperties","hasElement","isAttribute","getMappedPropName","getDefaultComponentElementName","validateProperty","validateAttribute","allKnownElementNames","allKnownAttributesOfElement","allKnownEventsOfElement","normalizeAnimationStyleProperty","normalizeAnimationStyleValue","camelCaseProp","userProvidedProp","strVal","errorMsg","_isPixelDimensionStyle","valAndSuffixMatch","HtmlTagDefinition","closedByChildren","contentType","PARSABLE_DATA","overrideType","default","DEFAULT_TAG_DEFINITION","TAG_DEFINITIONS","getHtmlTagDefinition","assign","svg","knownTagName","TAG_TO_PLACEHOLDER_NAMES","PlaceholderRegistry","_placeHolderNameCounts","_signatureToName","getStartTagPlaceholderName","signature","_hashTag","upperTag","baseName","_generateUniqueName","getCloseTagPlaceholderName","_hashClosingTag","getPlaceholderName","upperName","getUniquePlaceholder","getStartBlockPlaceholderName","_hashBlock","_toSnakeCase","getCloseBlockPlaceholderName","_hashClosingBlock","sort","_expParser","createI18nMessageFactory","containerBlocks","retainEmptyTokens","preserveExpressionWhitespace","_I18nVisitor","visitNodeFn","toI18nMessage","noopVisitNodeFn","_html","_expressionParser","_containerBlocks","_retainEmptyTokens","_preserveExpressionWhitespace","isIcu","icuDepth","placeholderRegistry","placeholderToContent","i18nodes","_visitElementLike","_visitTextWithInterpolation","i18nIcuCases","i18nIcu","caze","expPh","phName","_icuCase","_context","startPhName","closePhName","_parameter","dir","i18nNode","previousI18n","hasInterpolation","startMarker","endMarker","extractPlaceholderName","normalized","normalizeExpression","reusePreviousSourceSpans","assertSingleContainerMessage","assertEquivalentNodes","previousNodes","_CUSTOM_PH_EXP","UNUSABLE_INTERPOLATION_REGEXPS","assertInterpolationSymbols","regexp","InterpolationConfig","fromArray","markers","DEFAULT_INTERPOLATION_CONFIG","DEFAULT_CONTAINER_BLOCKS","TRUSTED_TYPES_SINKS","isTrustedTypesSink","setI18nRefs","trimmedNode","originalNode","I18nMetaVisitor","keepI18nAttrs","enableI18nLegacyMessageIdFormat","hasI18nMeta","_errors","_generateI18nMessage","_parseMetadata","_setMessageId","_setLegacyIds","visitAllWithErrors","currentMessage","attrsMeta","trimmedNodes","isTrustedType","_reportError","parseI18nMeta","I18N_MEANING_SEPARATOR","I18N_ID_SEPARATOR","idIndex","descIndex","meaningAndDesc","i18nMetaToJSDoc","GOOG_GET_MSG","createGoogleGetMsgStatements","variable$1","closureVar","serializeI18nMessageForGetMsg","original_code","googGetMsgStmt","i18nAssignmentStmt","GetMsgSerializerVisitor","serializerVisitor","createLocalizeStatements","placeHolders","serializeI18nMessageForLocalize","getSourceSpan","localizedString$1","variableInitialization","LocalizeSerializerVisitor","pieces","createPlaceholderPiece","processMessagePieces","startNode","endNode","createEmptyMessagePart","NG_I18N_CLOSURE_MODE","TRANSLATION_VAR_PREFIX","I18N_ICU_MAPPING_PREFIX","ESCAPE","CLOSURE_TRANSLATION_VAR_PREFIX","getTranslationConstPrefix","extra","declareI18nVariable","collectI18nConsts","fileBasedI18nSuffix","extractedAttributesByI18nContext","i18nAttributesByElement","i18nExpressionsByElement","i18nValuesByContext","messageConstIndices","mainVar","collectMessage","i18nConst","attributesForMessage","elem","i18nExpressions","seenPropertyNames","i18nExpr","i18nAttributeConfig","i18nExprValue","msgIndex","messageOp","subMessagePlaceholders","subMessageId","subMessageVar","subMessageStatements","addSubMessageParams","i18nGenerateClosureVar","transformFn","fromEntries","extraTransformFnParams","getTranslationDeclStmts","paramsObject","createClosureModeGuard","messageId","useExternalIds","uniqueSuffix","convertI18nText","currentI18n","textNodeI18nBlocks","textNodeIcus","icuPlaceholderByText","icuPlaceholderOp","i18nOp","icuOp","contextId","Postproccessing","liftLocalRefs","serializeLocalRefs","constRefs","emitNamespaceChanges","activeNamespace","parenDepth","valueStart","propStart","currentProp","hyphenate","styleVal","parseExtractedStyles","Structural","parsedStyles","parsedClasses","parsedClass","nameFunctionsAndVariables","addNamesToView","animation","getVariableName","childView","normalizeStylePropName","stripImportant","compatPrefix","importantIndex","mergeNextContextExpressions","mergeNextContextsInOps","mergeSteps","tryToMerge","candidate","CONTAINER_TAG","generateNgContainerOps","updatedElementXrefs","lookupElement","disableBindings$1","kindTest","kindWithInterpolationTest","basicListenerKindTest","nonInterpolationPropertyKindTest","CREATE_ORDERING","UPDATE_ORDERING","keepLast","UPDATE_HOST_ORDERING","handledOpKinds","orderOps","orderWithin","ordering","opsToOrder","firstTargetInGroup","currentTarget","reorder","groupIndex","group","removeContentSelectors","lookupInXrefMap","isSelectAttribute","createPipes","processPipeBindingsInView","slotHandle","addPipeToCreationBlock","afterTargetXref","createVariadicPipes","propagateI18nBlocks","propagateI18nBlocksToTemplates","propagateI18nBlocksForView","forView","fallbackViewI18nPlaceholder","wrapTemplateWithI18n","parentI18n","extractPureFunctions","constantDef","PureFunctionConstant","declName","keyExpr","fnParams","returnExpr","generatePureLiteralStructures","transformLiteralArray","transformLiteralMap","derivedEntries","nonConstantArgs","optimizeRegularExpressions","RegularExpressionConstant","constIndex","localRefIndex","elementOrContainerBase","call","templateBase","templateFnRef","propertyBase","interpolationToExpression","handlerFn","eventTargetResolver","syntheticHost","namespaceMath","savedView","returnValue","selfSlot","primarySlot","dependencyResolverFn","enableTimerScheduling","deferTriggerToR3TriggerInstructionsMap","deferOn","instructionToCall","fallbackFnName","fallbackDecls","fallbackVars","viewFnName","trackByUsesComponentInstance","emptyViewFnName","emptyDecls","emptyVars","emptyConstIndex","PIPE_BINDINGS","pipeBind","interpolationArgs","collateInterpolationArgs","callVariadicInstruction","TEXT_INTERPOLATE_CONFIG","animationString","animationListener","pureFunction","callVariadicInstructionExpr","PURE_FUNCTION_CONFIG","attachSourceLocation","VALUE_INTERPOLATE_CONFIG","constant","mapping","config","baseArgs","extraArgs","lastInterpolationArg","at","GLOBAL_TARGET_RESOLVERS","DOM_PROPERTY_REMAPPING","reify","reifyCreateOperations","reifyUpdateOperations","reifyIrExpression","animationCallbackFn","reifyListenerHandler","animationListenerFn","listenerFn","timerScheduling","fallbackViewFnName","conditionalCreateChildView","conditionalBranchCreateChildView","repeaterView","reifyTrackBy","locationsLiteral","reifyDomProperty","reifyProperty","reifyControl","handlerStmts","fn$1","removeEmptyBindings","removeI18nContexts","removeIllegalLetReferences","removeUnusedI18nAttributesOps","ownersWithI18nExpressions","resolveContexts","processLexicalScope$1","resolveDeferDepsFns","fullPathName","resolveDollarEvent","transformDollarEvent","resolveI18nElementPlaceholders","resolvePlaceholdersForView","pendingStructuralDirective","currentOps","pendingStructuralDirectiveCloses","recordElementStart","startOp","recordElementClose","delete","recordTemplateStart","recordTemplateClose","forSlot","emptySlot","structuralDirective","addParam","getSubTemplateIndexForTemplateTag","childOp","resolveI18nExpressionPlaceholders","subTemplateIndices","icuPlaceholders","expressionIndices","referenceIndex","ExpressionIndex","updatePlaceholder","resolveNames","processLexicalScope","localDefinitions","Alias","SavedView","sanitizerFns","SCRIPT","trustedValueFns","resolveSanitizers","getOnlySecurityContext","sanitizerFn","isIframe","isIframeElement","saveAndRestoreView","needsRestoreView","handlerOp","addSaveRestoreViewOperationToListener","allocateSlots","slotCount","optimizeStoreLet","letUsedExternally","declareLetOps","hasPipe","stripNonrequiredParentheses","requiredParens","checkExponentiationParens","checkNullishCoalescingParens","checkAndOrParens","isLogicalAndOr","specializeStyleBindings","generateTemporaryVariables","generateTemporaries","opCount","generatedStatements","finalReads","flag","assigned","released","defs","assignName","names","optimizeTrackFns","isTrackByFunctionCall","trackOpList","rootView","arg0","arg1","generateTrackVariables","$index","$implicit","transformTwoWayBindingSet","countVariables","varCount","varsUsedByOp","varsUsedByIrExpression","slots","isSingletonInterpolation","optimizeVariables","inlineAlwaysInlineVariables","optimizeVariablesInOpList","Fence","fencesForIrExpression","varOp","varDecls","varUsages","varRemoteUsages","opMap","collectOpInfo","countVariableUsages","contextIsUsed","opInfo","fences","ViewContextWrite","SideEffectful","stmtOp","uncountVariableUsages","ViewContextRead","toInline","isAlwaysInline","varInfo","targetOp","variablesUsed","allowConservativeInlining","tryInlineVariableInitializer","safeToInlinePastFences","varRemoteUsage","declFences","inlined","inliningAllowed","exprFences","wrapI18nIcus","addedI18nId","phases","emitTemplateFn","tpl","rootFn","emitView","emitChildViews","viewFn","createStatements","updateStatements","createCond","maybeGenerateRfBlock","updateCond","emitHostBindingFunction","compatibilityMode","domSchema","NG_TEMPLATE_TAG_NAME","ANIMATE_PREFIX$1","isI18nRootNode","isSingleI18nIcu","ingestComponent","constantPool","compilationMode","ingestNodes","ingestHostBinding","bindingParser","securityContexts","calcPossibleSecurityContexts","componentSelector","ingestDomProperty","ingestHostAttribute","ingestHostEvent","convertAst","attrBinding","eventBinding","makeListenerHandlerOps","ingestElement","ingestTemplate","ingestContent","ingestText","ingestBoundText","ingestIfBlock","ingestSwitchBlock","ingestDeferBlock","ingestIcu","ingestForBlock","ingestLetDeclaration","namespaceKey","ingestElementBindings","ingestReferences","i18nBlockId","endOp","tmpl","tagNameWithoutNamespace","namespacePrefix","isPlainTemplate","NgTemplate","templateOp","ingestTemplateBindings","asMessage","textXref","baseSourceSpan","ifBlock","firstXref","ifCase","cView","ingestControlFlowInsertionPoint","ifCaseI18nMeta","conditionalCreateOp","caseExpr","conditionalCaseExpr","switchBlock","switchCase","switchCaseI18nMeta","ingestDeferView","i18nMeta","secondaryView","deferBlock","deferXref","calcDeferBlockFlags","deferOnOps","deferWhenOps","ingestDeferTriggers","hasConcreteTrigger","deferBlockDetails","onOps","whenOps","idle","deferOnOp","immediate","timer","hover","interaction","viewport","never","when","forBlock","indexName","countName","indexVarNames","getComputedForLoopVariableExpression","convertSourceSpan","emptyTagName","isImplicitReceiver","convertTemplateLiteral","convertAstWithInterpolation","BINDING_KINDS","Style","i18nAttributeBindingNames","console","astOf","output","makeTwoWayListenerHandlerOps","createTemplateBinding","isTextBinding","bindingType","handlerExprs","handlerExpr","eventReference","twoWaySetExpr","assertIsArray","ENABLE_TEMPLATE_SOURCE_LOCATIONS","setEnableTemplateSourceLocations","getTemplateSourceLocationsEnabled","renderFlagCheckIfStmt","toQueryFlags","query","descendants","static","emitDistinctChangesOnly","getQueryPredicate","createQueryCreateCall","queryTypeFns","prependParams","queryCreateFn","signalBased","nonSignal","queryAdvancePlaceholder","collapseAdvanceStatements","advanceCollapseCount","flushAdvanceCount","unshift","createViewQueriesFunction","viewQueries","tempAllocator","queryDefinitionCall","temporary","getQueryList","refresh","updateDirective","viewQueryFnName","createContentQueriesFunction","queries","contentQueriesFnName","HtmlParser","PROPERTY_PARTS_SEPARATOR","ATTRIBUTE_PREFIX","ANIMATE_PREFIX","CLASS_PREFIX","STYLE_PREFIX","TEMPLATE_ATTR_PREFIX$1","LEGACY_ANIMATE_PROP_PREFIX","BindingParser","_exprParser","_schemaRegistry","createBoundHostProperties","boundProps","parsePropertyBinding","createDirectiveHostEventAsts","hostListeners","targetEvents","parseEvent","parseInlineTemplateBinding","tplKey","tplValue","targetMatchableAttrs","targetProps","targetVars","isIvyAst","_parseTemplateBindings","bindingSpan","moveParseSourceSpan","srcSpan","_parsePropertyAst","parseLiteralAttr","bindingsResult","warning","WARNING","isLegacyAnimationLabel","_parseLegacyAnimation","isHost","isPartOfAssignmentBinding","isLegacyAnimationProp","_parseAnimation","parsePropertyInterpolation","TWO_WAY","DEFAULT","isHostBinding","createBoundElementProperty","elementSelector","boundProp","skipValidation","mapPropertyName","boundPropertyName","_validatePropertyOrAttributeName","nsSeparatorIdx","ns","mappedPropName","isAssignmentEvent","_parseLegacyAnimationEvent","_parseRegularEvent","parseEventListenerName","rawName","eventName","parseLegacyAnimationEventName","_parseAction","prevErrorCount","isValid","_isAllowedAssignmentEvent","eventType","isAttr","report","hasRecursiveSafeReceiver","ctxs","nameToContext","elName","elementNames","notElementNames","possibleElementNames","absoluteSpan","startDiff","endDiff","isStyleUrlResolvable","schemeMatch","URL_WITH_SCHEMA_REGEXP","NG_CONTENT_SELECT_ATTR","LINK_ELEMENT","LINK_STYLE_REL_ATTR","LINK_STYLE_HREF_ATTR","LINK_STYLE_REL_VALUE","STYLE_ELEMENT","SCRIPT_ELEMENT","NG_NON_BINDABLE_ATTR","NG_PROJECT_AS","preparseElement","selectAttr","hrefAttr","relAttr","lcAttrName","normalizeNgContentSelect","PreparsedElementType","OTHER","NG_CONTENT","STYLESHEET","PreparsedElement","FOR_LOOP_EXPRESSION_PATTERN","FOR_LOOP_TRACK_PATTERN","CONDITIONAL_ALIAS_PATTERN","ELSE_IF_PATTERN","FOR_LOOP_LET_PATTERN","IDENTIFIER_PATTERN","CHARACTERS_IN_SURROUNDING_WHITESPACE_PATTERN","ALLOWED_FOR_LOOP_LET_VARIABLES","isConnectedForLoopBlock","isConnectedIfLoopBlock","createIfBlock","connectedBlocks","validateIfConnectedBlocks","mainBlockParams","parseConditionalBlockParameters","ifBlockStartSourceSpan","ifBlockEndSourceSpan","lastBranch","createForLoop","parseForLoopParameters","validateTrackByExpression","keywordSpan","itemName","createSwitchBlock","validateSwitchBlock","primaryExpression","parseBlockParameterToBinding","expressionParam","secondaryParams","stripOptionalParentheses","rawExpression","variableName","variableSpan","emptySpanAfterForBlockStart","letMatch","variablesSpan","parseLetParameter","trackMatch","PipeVisitor","loopItemName","expressionParts","keyLeadingWhitespace","keyName","valueLeadingWhitespace","implicit","hasElse","hasDefault","aliasMatch","variableStart","spaceRegex","TIME_PATTERN","SEPARATOR_PATTERN","COMMA_DELIMITED_SYNTAX","OnTriggerType","parseNeverTrigger","neverIndex","neverSourceSpan","getPrefetchSpan","getHydrateSpan","trackTrigger","parseWhenTrigger","whenIndex","getTriggerParametersStart","parsed","parseOnTrigger","onIndex","isHydrationTrigger","OnTriggerParser","validateHydrateReferenceBasedTrigger","validatePlainReferenceBasedTrigger","validator","unexpectedToken","isFollowedByOrLast","consumeTrigger","prevErrors","consumeParameters","min","triggerNameStartSpan","isFirstTrigger","prefetchSourceSpan","hydrateSourceSpan","IDLE","createIdleTrigger","TIMER","createTimerTrigger","INTERACTION","createInteractionTrigger","IMMEDIATE","createImmediateTrigger","HOVER","createHoverTrigger","VIEWPORT","createViewportTrigger","commaDelimStack","tokenRangeText","newStart","newEnd","allTriggers","parseDeferredTime","triggerIndex","triggerFilter","dynamicNode","DynamicAstValidator","findDynamicNode","startPosition","hasFoundSeparator","time","PREFETCH_WHEN_PATTERN","PREFETCH_ON_PATTERN","HYDRATE_WHEN_PATTERN","HYDRATE_ON_PATTERN","HYDRATE_NEVER_PATTERN","MINIMUM_PARAMETER_PATTERN","AFTER_PARAMETER_PATTERN","WHEN_PARAMETER_PATTERN","ON_PARAMETER_PATTERN","isConnectedDeferLoopBlock","createDeferredBlock","parseConnectedBlocks","parsePrimaryTriggers","lastEndSourceSpan","endOfLastSourceSpan","lastConnectedBlock","sourceSpanWithConnectedBlocks","parsePlaceholderBlock","parseLoadingBlock","parseErrorBlock","parsedTime","BIND_NAME_REGEXP","KW_BIND_IDX","KW_LET_IDX","KW_REF_IDX","KW_ON_IDX","KW_BINDON_IDX","KW_AT_IDX","IDENT_KW_IDX","BINDING_DELIMS","BANANA_BOX","PROPERTY","EVENT","TEMPLATE_ATTR_PREFIX","UNSUPPORTED_SELECTORLESS_TAGS","UNSUPPORTED_SELECTORLESS_DIRECTIVE_ATTRS","htmlAstToRender3Ast","htmlNodes","transformer","HtmlAstToIvyAst","ivyNodes","allErrors","styleUrls","ngContentSelectors","collectCommentNodes","commentNodes","inI18nBlock","processedNodes","isI18nRootElement","reportError","preparsedElement","contents","textContents","isTemplateElement","boundEvents","templateVariables","elementHasInlineTemplate","parsedProperties","templateParsedProperties","i18nAttrsMeta","prepareAttributes","extractDirectives","NON_BINDABLE_VISITOR","flat","Infinity","parsedElement","categorizePropertyAttributes","bound","wrapInTemplate","formattedKey","validateSelectorlessReferences","findConnectedBlocks","primaryBlockIndex","siblings","relatedBlocks","i18nPropsMeta","bep","hasBinding","normalizedName","normalizeAttributeName","isTemplateBinding","parsedVariables","parseAttribute","matchableAttributes","createKeySpan","normalizationAdjustment","keySpanStart","keySpanEnd","bindParts","parseVariable","parseReference","addEvents","parseAssignmentEvent","delims","seenDirectives","invalid","filterAnimationAttributes","filterAnimationInputs","templateProperties","hoistedAttrs","valueNoNgsp","seenNames","NonBindableVisitor","LEADING_TRIVIA_CHARS","parseTemplate","templateUrl","preserveWhitespaces","enableSelectorless","makeBindingParser","htmlParser","parseResult","enableBlockSyntax","enableLetSyntax","alwaysAttemptHtmlToR3AstConversion","parsedTemplate","i18nMetaVisitor","i18nMetaResult","elementRegistry","COMPONENT_VARIABLE","HOST_ATTR","CONTENT_ATTR","baseDirectiveFields","createHostBindingsFunction","typeSourceSpan","exportAs","addFeatures","features","viewProviders","hostDirectives","createHostDirectivesFeatureArg","usesInheritance","lifecycle","usesOnChanges","externalStyles","externalStyleNodes","externalStyle","compileDirectiveFromMetadata","createDirectiveType","compileComponentFromMetadata","firstSelector","selectorAttributes","templateTypeName","dependenciesFn","hasDirectiveDependencies","Full","templateFn","declarationListEmitMode","compileDeclarationList","rawImports","encapsulation","Emulated","hasStyles","styleValues","compileStyles","styleNodes","style","animations","changeDetection","Default","createComponentType","createBaseDirectiveTypeParams","stringArrayAsType","createHostDirectivesType","list","resolvedList","stringAsType","stringMapAsLiteralExpression","mapValues","arr","selectorForType","getInputsTypeExpression","q","required","hostBindingsMetadata","eventBindings","specialAttributes","styleAttr","classAttr","hostJob","HOST_REG_EXP","parseHostBindings","verifyHostBindings","shadowCss","encapsulateStyle","componentIdentifier","hostMeta","hasForwardRef","inputsLiteral","createHostDirectivesMappingArray","outputsLiteral","isForwardReference","compileDeferResolverFunction","depExpressions","dependencies","isDeferrable","innerFn","isDefaultImport","symbolName","importPath","typeReference","CombinedRecursiveAstVisitor","visitAllTemplateNodes","fullList","itemsToExclude","exclude","findMatchingDirectivesAndPipes","directiveSelectors","fakeDirective","hasBindingPropertyName","binder","R3TargetBinder","eagerDirectiveSelectors","getEagerlyUsedDirectives","allMatchedDirectiveSelectors","getUsedDirectives","eagerPipes","getEagerlyUsedPipes","regular","deferCandidates","pipes","getUsedPipes","directiveMatcher","eagerDirectives","missingDirectives","scopedNodeEntities","symbols","nestingLevel","usedPipes","deferBlocks","extractScopedNodeEntities","DirectiveBinder","TemplateBinder","applyWithScope","R3BoundTarget","namedEntities","elementLikeInScope","childScopes","isDeferred","newRootScope","ingest","nodeOrNodes","visitElementLike","ingestScopedNode","maybeDeclare","thing","lookup","getChildScope","isInDeferBlock","visitElementOrTemplate","wasInDeferBlock","componentMatches","trackSelectorlessMatchesAndDirectives","trackSelectorBasedBindingsAndDirectives","trackMatchedDirectives","setBinding","ioType","dirTarget","isComponent","setAttributeBinding","visitBoundAttributeOrEvent","visitNode","maybeMap","childScope","exprTargets","deferredBlocks","deferredScopes","rawDeferred","getEntitiesInScope","getDirectivesOfNode","getReferenceTarget","getConsumerOfBinding","getExpressionTarget","getDefinitionNodeOfSymbol","symbol","getNestingLevel","dirs","getDeferBlocks","getDeferredTriggerTarget","outsideRef","findEntityInScope","referenceTargetToElement","refInPlaceholder","targetInPlaceholder","referencedDirectiveExists","entities","rootScope","templateEntities","entityMap","extractScopeEntities","currentEntities","scopesToProcess","ResourceLoader","CompilerFacadeImpl","jitEvaluator","elementSchemaRegistry","compilePipe","angularCoreEnv","sourceMapUrl","facade","jitExpression","compilePipeDeclaration","declaration","convertDeclarePipeFacadeToMetadata","computeProvidedIn","convertToProviderExpression","wrapExpression","convertR3DependencyMetadata","compileInjectableDeclaration","convertR3DeclareDependencyMetadata","compileInjectorDeclaration","convertDeclareInjectorFacadeToMetadata","compileNgModuleDeclaration","compileDirective","convertDirectiveFacadeToMetadata","compileDirectiveFromMeta","compileDirectiveDeclaration","createParseSourceSpan","convertDeclareDirectiveFacadeToMetadata","compileComponent","parseJitTemplate","convertDeclarationFacadeToMetadata","jitExpressionSourceMap","compileComponentFromMeta","compileComponentDeclaration","convertDeclareComponentFacadeToMetadata","compileFactory","factoryRes","convertR3DependencyMetadataArray","compileFactoryDeclaration","preStatements","convertToR3QueryMetadata","convertQueryPredicate","convertQueryDeclarationToMetadata","inputsFromMetadata","parseInputsArray","outputsFromMetadata","parseMappingStringArray","propMetadata","inputsFromType","outputsFromType","field","ann","isInput","isOutput","hostDirective","extractHostBindings","getHostDirectiveBindingMapping","inputsPartialMetadataToInputMetadata","convertHostDeclarationToMetadata","convertOpaqueValuesToExpressions","classAttribute","styleAttribute","deferBlockDependencies","innerDep","convertDirectiveDeclarationToMetadata","convertPipeDeclarationToMetadata","components","convertPipeMapToMetadata","err","boundTarget","createR3ComponentDeferMetadata","facades","isAttributeDep","rawToken","createR3DependencyMetadata","dependencyFn","hostPropertyName","isHostListener","ngMetadataName","minifiedClassName","parseLegacyInputPartialOutput","isRequired","parseMappingString","fieldName","publishFacade","global","ng","ÉµcompilerFacade","CompilerConfig","defaultEncapsulation","strictInjectionParameters","preserveWhitespacesDefault","preserveWhitespacesOption","defaultSetting","_I18N_ATTR","_I18N_ATTR_PREFIX","_I18N_COMMENT_PREFIX_REGEXP","MEANING_SEPARATOR","ID_SEPARATOR","i18nCommentsWarned","extractMessages","implicitTags","implicitAttrs","extract","mergeTranslations","translations","merge","ExtractionResult","_VisitorMode","_implicitTags","_implicitAttrs","_preserveSignificantWhitespace","_depth","_inI18nNode","_inImplicitNode","_inI18nBlock","_blockMeaningAndDesc","_blockChildren","_blockStartDepth","_inIcu","_msgCountAtSectionStart","_mode","_messages","_translations","_createI18nMessage","_init","Extract","Merge","wrapper","translatedNode","icuCase","_mayBeAddBlockChildren","wasInIcu","_isInTranslatableSection","_addMessage","isOpening","_isOpeningComment","isClosing","_isClosingComment","warn","_openTranslatableSection","_closeTranslatableSection","_translateMessage","wasInI18nNode","wasInImplicitNode","childNodes","translatedChildNodes","i18nAttr","_getI18nAttr","isImplicit","isTopLevelImplicit","isTranslatable","visitNodes","visited","_visitAttributesOf","_translateAttributes","_translateDirectives","explicitAttrNameToValue","implicitAttrNames","msgMeta","_isEmptyAttributeValue","_isPlaceholderOnlyAttributeValue","_isPlaceholderOnlyMessage","_parseMessageMeta","isAttrNode","interpolations","plainText","isTextNode","i18nParsedMessageMeta","translatedAttributes","directChildren","significantChildren","XmlTagDefinition","requireExtraParent","currentParent","_TAG_DEFINITION","getXmlTagDefinition","XmlParser","_VERSION$1","_XMLNS$1","_DEFAULT_SOURCE_LANG$1","_PLACEHOLDER_TAG$2","_MARKER_TAG$1","_FILE_TAG","_SOURCE_TAG$1","_SEGMENT_SOURCE_TAG","_ALT_TRANS_TAG","_TARGET_TAG$1","_UNIT_TAG$1","_CONTEXT_GROUP_TAG","_CONTEXT_TAG","Xliff","_WriteVisitor$1","transUnits","contextTags","contextGroupTag","purpose","transUnit","datatype","priority","xliff","xmlns","xliffParser","XliffParser","msgIdToHtml","i18nNodesByMsgId","XmlToI18n$2","msgId","i18nNodes","convert","_WriteVisitor","ctype","getCtypeForTag","equivText","_unitMlString","_msgIdToHtml","_locale","xml","idAttr","_addError","innerTextStart","innerTextEnd","innerText","localeAttr","XmlToI18n","xmlIcu","nameAttr","caseMap","_VERSION","_XMLNS","_DEFAULT_SOURCE_LANG","_PLACEHOLDER_TAG$1","_PLACEHOLDER_SPANNING_TAG","_MARKER_TAG","_XLIFF_TAG","_SOURCE_TAG","_TARGET_TAG","_UNIT_TAG","Xliff2","notes","category","srcLang","xliff2Parser","Xliff2Parser","XmlToI18n$1","_nextPlaceholderId","getTypeForTag","tagPh","equiv","disp","tagPc","equivStart","equivEnd","dispStart","dispEnd","idStr","versionAttr","startAttr","endAttr","startId","endId","_TRANSLATIONS_TAG","_TRANSLATION_TAG","_PLACEHOLDER_TAG","Xtb","xtbParser","XtbParser","valueFn","createLazyProperty","defineProperty","configurable","enumerable","_bundleDepth","xtb","langAttr","TranslationBundle","_i18nNodesByMsgId","mapperFactory","_i18nToHtml","missingTranslationStrategy","Warning","I18nToHtmlVisitor","digestFn","srcMsg","html","_digest","_mapperFactory","_missingTranslationStrategy","_console","_srcMsg","_contextStack","_mapper","_convertToText","mapper","I18NHtmlParser","_htmlParser","_translationBundle","translationsFormat","missingTranslation","createSerializer","format","MessageBundle","_preserveWhitespace","updateFromTemplate","htmlParserResult","i18nParserResult","getMessages","filterSources","mapperVisitor","MapPlaceholderNames","msgList","src","transformedMessage","compileClassMetadata","internalCompileClassMetadata","decorators","ctorParameters","propDecorators","compileComponentClassMetadata","internalCompileSetClassMetadataAsync","compileComponentMetadataAsyncResolver","compileOpaqueAsyncClassMetadata","deferResolver","deferredDependencyNames","wrapperParams","setClassMetadataCall","setClassMetaWrapper","setClassMetaAsync","dynamicImports","MINIMUM_PARTIAL_LINKER_VERSION$5","MINIMUM_PARTIAL_LINKER_DEFER_SUPPORT_VERSION","compileDeclareClassMetadata","compileComponentDeclareClassMetadata","callbackReturnDefinitionMap","toOptionalLiteralArray","toOptionalLiteralMap","object","compileDependencies","compileDependency","depMeta","compileDeclareDirectiveFromMetadata","createDirectiveDefinitionMap","minVersion","getMinimumVersionForPartialOutput","needsNewInputPartialOutput","createInputsPartialMetadata","legacyInputsPartialMetadata","compileHostMetadata","compileQuery","createHostDirectives","hasDecoratorTransformFunctions","hostMetadata","compileDeclareComponentFromMetadata","additionalTemplateInfo","createComponentDefinitionMap","templateInfo","blockVisitor","BlockPresenceVisitor","getTemplateExpression","isInline","hasBlocks","compileUsedDependenciesMetadata","resolvers","hasResolvers","inlineTemplateLiteralExpression","computeEndLocation","lineStart","lastLineStart","wrapType","dirMeta","pipeMeta","ngModuleMeta","MINIMUM_PARTIAL_LINKER_VERSION$4","compileDeclareFactoryFunction","MINIMUM_PARTIAL_LINKER_VERSION$3","compileDeclareInjectableFromMetadata","createInjectableDefinitionMap","MINIMUM_PARTIAL_LINKER_VERSION$2","compileDeclareInjectorFromMetadata","createInjectorDefinitionMap","MINIMUM_PARTIAL_LINKER_VERSION$1","compileDeclareNgModuleFromMetadata","createNgModuleDefinitionMap","MINIMUM_PARTIAL_LINKER_VERSION","compileDeclarePipeFromMetadata","createPipeDefinitionMap","compileClassDebugInfo","debugInfo","debugInfoObject","lineNumber","forbidOrphanRendering","compileHmrInitializer","dataName","timestampName","idName","importCallbackName","namespaces","namespaceDependencies","defaultRead","replaceCall","localDependencies","runtimeRepresentation","replaceCallback","importCallback","updateCallback","initialCall","hotRead","hotListener","encodeURIComponent","compileHmrUpdateCallback","definitions","constantStatements","assignedName","VERSION","R3Identifiers","TmplAstBlockNode","TmplAstBoundAttribute","TmplAstBoundDeferredTrigger","TmplAstBoundEvent","TmplAstBoundText","TmplAstComponent","TmplAstContent","TmplAstDeferredBlock","TmplAstDeferredBlockError","TmplAstDeferredBlockLoading","TmplAstDeferredBlockPlaceholder","TmplAstDeferredTrigger","TmplAstDirective","TmplAstElement","TmplAstForLoopBlock","TmplAstForLoopBlockEmpty","TmplAstHostElement","TmplAstHoverDeferredTrigger","TmplAstIcu","TmplAstIdleDeferredTrigger","TmplAstIfBlock","TmplAstIfBlockBranch","TmplAstImmediateDeferredTrigger","TmplAstInteractionDeferredTrigger","TmplAstLetDeclaration","TmplAstNeverDeferredTrigger","TmplAstRecursiveVisitor","TmplAstReference","TmplAstSwitchBlock","TmplAstSwitchBlockCase","TmplAstTemplate","TmplAstText","TmplAstTextAttribute","TmplAstTimerDeferredTrigger","TmplAstUnknownBlock","TmplAstVariable","TmplAstViewportDeferredTrigger","outputAst","tmplAstVisitAll"],"sources":["C:/Users/juanj/Desktop/juan_website/website2/my-website/node_modules/@angular/compiler/fesm2022/compiler.mjs"],"sourcesContent":["/**\n * @license Angular v21.0.0\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nconst _SELECTOR_REGEXP = new RegExp('(\\\\:not\\\\()|' + '(([\\\\.\\\\#]?)[-\\\\w]+)|' + '(?:\\\\[([-.\\\\w*\\\\\\\\$]+)(?:=([\"\\']?)([^\\\\]\"\\']*)\\\\5)?\\\\])|' + '(\\\\))|' + '(\\\\s*,\\\\s*)', 'g');\nclass CssSelector {\n  element = null;\n  classNames = [];\n  attrs = [];\n  notSelectors = [];\n  static parse(selector) {\n    const results = [];\n    const _addResult = (res, cssSel) => {\n      if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 && cssSel.attrs.length == 0) {\n        cssSel.element = '*';\n      }\n      res.push(cssSel);\n    };\n    let cssSelector = new CssSelector();\n    let match;\n    let current = cssSelector;\n    let inNot = false;\n    _SELECTOR_REGEXP.lastIndex = 0;\n    while (match = _SELECTOR_REGEXP.exec(selector)) {\n      if (match[1]) {\n        if (inNot) {\n          throw new Error('Nesting :not in a selector is not allowed');\n        }\n        inNot = true;\n        current = new CssSelector();\n        cssSelector.notSelectors.push(current);\n      }\n      const tag = match[2];\n      if (tag) {\n        const prefix = match[3];\n        if (prefix === '#') {\n          current.addAttribute('id', tag.slice(1));\n        } else if (prefix === '.') {\n          current.addClassName(tag.slice(1));\n        } else {\n          current.setElement(tag);\n        }\n      }\n      const attribute = match[4];\n      if (attribute) {\n        current.addAttribute(current.unescapeAttribute(attribute), match[6]);\n      }\n      if (match[7]) {\n        inNot = false;\n        current = cssSelector;\n      }\n      if (match[8]) {\n        if (inNot) {\n          throw new Error('Multiple selectors in :not are not supported');\n        }\n        _addResult(results, cssSelector);\n        cssSelector = current = new CssSelector();\n      }\n    }\n    _addResult(results, cssSelector);\n    return results;\n  }\n  unescapeAttribute(attr) {\n    let result = '';\n    let escaping = false;\n    for (let i = 0; i < attr.length; i++) {\n      const char = attr.charAt(i);\n      if (char === '\\\\') {\n        escaping = true;\n        continue;\n      }\n      if (char === '$' && !escaping) {\n        throw new Error(`Error in attribute selector \"${attr}\". ` + `Unescaped \"$\" is not supported. Please escape with \"\\\\$\".`);\n      }\n      escaping = false;\n      result += char;\n    }\n    return result;\n  }\n  escapeAttribute(attr) {\n    return attr.replace(/\\\\/g, '\\\\\\\\').replace(/\\$/g, '\\\\$');\n  }\n  isElementSelector() {\n    return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 && this.notSelectors.length === 0;\n  }\n  hasElementSelector() {\n    return !!this.element;\n  }\n  setElement(element = null) {\n    this.element = element;\n  }\n  getAttrs() {\n    const result = [];\n    if (this.classNames.length > 0) {\n      result.push('class', this.classNames.join(' '));\n    }\n    return result.concat(this.attrs);\n  }\n  addAttribute(name, value = '') {\n    this.attrs.push(name, value && value.toLowerCase() || '');\n  }\n  addClassName(name) {\n    this.classNames.push(name.toLowerCase());\n  }\n  toString() {\n    let res = this.element || '';\n    if (this.classNames) {\n      this.classNames.forEach(klass => res += `.${klass}`);\n    }\n    if (this.attrs) {\n      for (let i = 0; i < this.attrs.length; i += 2) {\n        const name = this.escapeAttribute(this.attrs[i]);\n        const value = this.attrs[i + 1];\n        res += `[${name}${value ? '=' + value : ''}]`;\n      }\n    }\n    this.notSelectors.forEach(notSelector => res += `:not(${notSelector})`);\n    return res;\n  }\n}\nclass SelectorMatcher {\n  static createNotMatcher(notSelectors) {\n    const notMatcher = new SelectorMatcher();\n    notMatcher.addSelectables(notSelectors, null);\n    return notMatcher;\n  }\n  _elementMap = new Map();\n  _elementPartialMap = new Map();\n  _classMap = new Map();\n  _classPartialMap = new Map();\n  _attrValueMap = new Map();\n  _attrValuePartialMap = new Map();\n  _listContexts = [];\n  addSelectables(cssSelectors, callbackCtxt) {\n    let listContext = null;\n    if (cssSelectors.length > 1) {\n      listContext = new SelectorListContext(cssSelectors);\n      this._listContexts.push(listContext);\n    }\n    for (let i = 0; i < cssSelectors.length; i++) {\n      this._addSelectable(cssSelectors[i], callbackCtxt, listContext);\n    }\n  }\n  _addSelectable(cssSelector, callbackCtxt, listContext) {\n    let matcher = this;\n    const element = cssSelector.element;\n    const classNames = cssSelector.classNames;\n    const attrs = cssSelector.attrs;\n    const selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n    if (element) {\n      const isTerminal = attrs.length === 0 && classNames.length === 0;\n      if (isTerminal) {\n        this._addTerminal(matcher._elementMap, element, selectable);\n      } else {\n        matcher = this._addPartial(matcher._elementPartialMap, element);\n      }\n    }\n    if (classNames) {\n      for (let i = 0; i < classNames.length; i++) {\n        const isTerminal = attrs.length === 0 && i === classNames.length - 1;\n        const className = classNames[i];\n        if (isTerminal) {\n          this._addTerminal(matcher._classMap, className, selectable);\n        } else {\n          matcher = this._addPartial(matcher._classPartialMap, className);\n        }\n      }\n    }\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i += 2) {\n        const isTerminal = i === attrs.length - 2;\n        const name = attrs[i];\n        const value = attrs[i + 1];\n        if (isTerminal) {\n          const terminalMap = matcher._attrValueMap;\n          let terminalValuesMap = terminalMap.get(name);\n          if (!terminalValuesMap) {\n            terminalValuesMap = new Map();\n            terminalMap.set(name, terminalValuesMap);\n          }\n          this._addTerminal(terminalValuesMap, value, selectable);\n        } else {\n          const partialMap = matcher._attrValuePartialMap;\n          let partialValuesMap = partialMap.get(name);\n          if (!partialValuesMap) {\n            partialValuesMap = new Map();\n            partialMap.set(name, partialValuesMap);\n          }\n          matcher = this._addPartial(partialValuesMap, value);\n        }\n      }\n    }\n  }\n  _addTerminal(map, name, selectable) {\n    let terminalList = map.get(name);\n    if (!terminalList) {\n      terminalList = [];\n      map.set(name, terminalList);\n    }\n    terminalList.push(selectable);\n  }\n  _addPartial(map, name) {\n    let matcher = map.get(name);\n    if (!matcher) {\n      matcher = new SelectorMatcher();\n      map.set(name, matcher);\n    }\n    return matcher;\n  }\n  match(cssSelector, matchedCallback) {\n    let result = false;\n    const element = cssSelector.element;\n    const classNames = cssSelector.classNames;\n    const attrs = cssSelector.attrs;\n    for (let i = 0; i < this._listContexts.length; i++) {\n      this._listContexts[i].alreadyMatched = false;\n    }\n    result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n    result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) || result;\n    if (classNames) {\n      for (let i = 0; i < classNames.length; i++) {\n        const className = classNames[i];\n        result = this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n        result = this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) || result;\n      }\n    }\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i += 2) {\n        const name = attrs[i];\n        const value = attrs[i + 1];\n        const terminalValuesMap = this._attrValueMap.get(name);\n        if (value) {\n          result = this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result = this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n        const partialValuesMap = this._attrValuePartialMap.get(name);\n        if (value) {\n          result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result = this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n      }\n    }\n    return result;\n  }\n  _matchTerminal(map, name, cssSelector, matchedCallback) {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n    let selectables = map.get(name) || [];\n    const starSelectables = map.get('*');\n    if (starSelectables) {\n      selectables = selectables.concat(starSelectables);\n    }\n    if (selectables.length === 0) {\n      return false;\n    }\n    let selectable;\n    let result = false;\n    for (let i = 0; i < selectables.length; i++) {\n      selectable = selectables[i];\n      result = selectable.finalize(cssSelector, matchedCallback) || result;\n    }\n    return result;\n  }\n  _matchPartial(map, name, cssSelector, matchedCallback) {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n    const nestedSelector = map.get(name);\n    if (!nestedSelector) {\n      return false;\n    }\n    return nestedSelector.match(cssSelector, matchedCallback);\n  }\n}\nclass SelectorListContext {\n  selectors;\n  alreadyMatched = false;\n  constructor(selectors) {\n    this.selectors = selectors;\n  }\n}\nclass SelectorContext {\n  selector;\n  cbContext;\n  listContext;\n  notSelectors;\n  constructor(selector, cbContext, listContext) {\n    this.selector = selector;\n    this.cbContext = cbContext;\n    this.listContext = listContext;\n    this.notSelectors = selector.notSelectors;\n  }\n  finalize(cssSelector, callback) {\n    let result = true;\n    if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n      const notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n      result = !notMatcher.match(cssSelector, null);\n    }\n    if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n      if (this.listContext) {\n        this.listContext.alreadyMatched = true;\n      }\n      callback(this.selector, this.cbContext);\n    }\n    return result;\n  }\n}\nclass SelectorlessMatcher {\n  registry;\n  constructor(registry) {\n    this.registry = registry;\n  }\n  match(name) {\n    return this.registry.has(name) ? this.registry.get(name) : [];\n  }\n}\n\nconst emitDistinctChangesOnlyDefaultValue = true;\nvar ViewEncapsulation$1;\n(function (ViewEncapsulation) {\n  ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n  ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n  ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n  ViewEncapsulation[ViewEncapsulation[\"ExperimentalIsolatedShadowDom\"] = 4] = \"ExperimentalIsolatedShadowDom\";\n})(ViewEncapsulation$1 || (ViewEncapsulation$1 = {}));\nvar ChangeDetectionStrategy;\n(function (ChangeDetectionStrategy) {\n  ChangeDetectionStrategy[ChangeDetectionStrategy[\"OnPush\"] = 0] = \"OnPush\";\n  ChangeDetectionStrategy[ChangeDetectionStrategy[\"Default\"] = 1] = \"Default\";\n})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));\nvar InputFlags;\n(function (InputFlags) {\n  InputFlags[InputFlags[\"None\"] = 0] = \"None\";\n  InputFlags[InputFlags[\"SignalBased\"] = 1] = \"SignalBased\";\n  InputFlags[InputFlags[\"HasDecoratorInputTransform\"] = 2] = \"HasDecoratorInputTransform\";\n})(InputFlags || (InputFlags = {}));\nconst CUSTOM_ELEMENTS_SCHEMA = {\n  name: 'custom-elements'\n};\nconst NO_ERRORS_SCHEMA = {\n  name: 'no-errors-schema'\n};\nconst Type$1 = Function;\nvar SecurityContext;\n(function (SecurityContext) {\n  SecurityContext[SecurityContext[\"NONE\"] = 0] = \"NONE\";\n  SecurityContext[SecurityContext[\"HTML\"] = 1] = \"HTML\";\n  SecurityContext[SecurityContext[\"STYLE\"] = 2] = \"STYLE\";\n  SecurityContext[SecurityContext[\"SCRIPT\"] = 3] = \"SCRIPT\";\n  SecurityContext[SecurityContext[\"URL\"] = 4] = \"URL\";\n  SecurityContext[SecurityContext[\"RESOURCE_URL\"] = 5] = \"RESOURCE_URL\";\n})(SecurityContext || (SecurityContext = {}));\nvar MissingTranslationStrategy;\n(function (MissingTranslationStrategy) {\n  MissingTranslationStrategy[MissingTranslationStrategy[\"Error\"] = 0] = \"Error\";\n  MissingTranslationStrategy[MissingTranslationStrategy[\"Warning\"] = 1] = \"Warning\";\n  MissingTranslationStrategy[MissingTranslationStrategy[\"Ignore\"] = 2] = \"Ignore\";\n})(MissingTranslationStrategy || (MissingTranslationStrategy = {}));\nfunction parserSelectorToSimpleSelector(selector) {\n  const classes = selector.classNames && selector.classNames.length ? [8, ...selector.classNames] : [];\n  const elementName = selector.element && selector.element !== '*' ? selector.element : '';\n  return [elementName, ...selector.attrs, ...classes];\n}\nfunction parserSelectorToNegativeSelector(selector) {\n  const classes = selector.classNames && selector.classNames.length ? [8, ...selector.classNames] : [];\n  if (selector.element) {\n    return [1 | 4, selector.element, ...selector.attrs, ...classes];\n  } else if (selector.attrs.length) {\n    return [1 | 2, ...selector.attrs, ...classes];\n  } else {\n    return selector.classNames && selector.classNames.length ? [1 | 8, ...selector.classNames] : [];\n  }\n}\nfunction parserSelectorToR3Selector(selector) {\n  const positive = parserSelectorToSimpleSelector(selector);\n  const negative = selector.notSelectors && selector.notSelectors.length ? selector.notSelectors.map(notSelector => parserSelectorToNegativeSelector(notSelector)) : [];\n  return positive.concat(...negative);\n}\nfunction parseSelectorToR3Selector(selector) {\n  return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];\n}\n\nvar core = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    CUSTOM_ELEMENTS_SCHEMA: CUSTOM_ELEMENTS_SCHEMA,\n    get ChangeDetectionStrategy () { return ChangeDetectionStrategy; },\n    get InputFlags () { return InputFlags; },\n    get MissingTranslationStrategy () { return MissingTranslationStrategy; },\n    NO_ERRORS_SCHEMA: NO_ERRORS_SCHEMA,\n    get SecurityContext () { return SecurityContext; },\n    Type: Type$1,\n    get ViewEncapsulation () { return ViewEncapsulation$1; },\n    emitDistinctChangesOnlyDefaultValue: emitDistinctChangesOnlyDefaultValue,\n    parseSelectorToR3Selector: parseSelectorToR3Selector\n});\n\nvar FactoryTarget;\n(function (FactoryTarget) {\n  FactoryTarget[FactoryTarget[\"Directive\"] = 0] = \"Directive\";\n  FactoryTarget[FactoryTarget[\"Component\"] = 1] = \"Component\";\n  FactoryTarget[FactoryTarget[\"Injectable\"] = 2] = \"Injectable\";\n  FactoryTarget[FactoryTarget[\"Pipe\"] = 3] = \"Pipe\";\n  FactoryTarget[FactoryTarget[\"NgModule\"] = 4] = \"NgModule\";\n})(FactoryTarget || (FactoryTarget = {}));\nvar R3TemplateDependencyKind$1;\n(function (R3TemplateDependencyKind) {\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"Directive\"] = 0] = \"Directive\";\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"Pipe\"] = 1] = \"Pipe\";\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"NgModule\"] = 2] = \"NgModule\";\n})(R3TemplateDependencyKind$1 || (R3TemplateDependencyKind$1 = {}));\nvar ViewEncapsulation;\n(function (ViewEncapsulation) {\n  ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n  ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n  ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n  ViewEncapsulation[ViewEncapsulation[\"ExperimentalIsolatedShadowDom\"] = 4] = \"ExperimentalIsolatedShadowDom\";\n})(ViewEncapsulation || (ViewEncapsulation = {}));\n\nlet textEncoder;\nfunction digest$1(message) {\n  return message.id || computeDigest(message);\n}\nfunction computeDigest(message) {\n  return sha1(serializeNodes(message.nodes).join('') + `[${message.meaning}]`);\n}\nfunction decimalDigest(message) {\n  return message.id || computeDecimalDigest(message);\n}\nfunction computeDecimalDigest(message) {\n  const visitor = new _SerializerIgnoreIcuExpVisitor();\n  const parts = message.nodes.map(a => a.visit(visitor, null));\n  return computeMsgId(parts.join(''), message.meaning);\n}\nclass _SerializerVisitor {\n  visitText(text, context) {\n    return text.value;\n  }\n  visitContainer(container, context) {\n    return `[${container.children.map(child => child.visit(this)).join(', ')}]`;\n  }\n  visitIcu(icu, context) {\n    const strCases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n    return `{${icu.expression}, ${icu.type}, ${strCases.join(', ')}}`;\n  }\n  visitTagPlaceholder(ph, context) {\n    return ph.isVoid ? `<ph tag name=\"${ph.startName}\"/>` : `<ph tag name=\"${ph.startName}\">${ph.children.map(child => child.visit(this)).join(', ')}</ph name=\"${ph.closeName}\">`;\n  }\n  visitPlaceholder(ph, context) {\n    return ph.value ? `<ph name=\"${ph.name}\">${ph.value}</ph>` : `<ph name=\"${ph.name}\"/>`;\n  }\n  visitIcuPlaceholder(ph, context) {\n    return `<ph icu name=\"${ph.name}\">${ph.value.visit(this)}</ph>`;\n  }\n  visitBlockPlaceholder(ph, context) {\n    return `<ph block name=\"${ph.startName}\">${ph.children.map(child => child.visit(this)).join(', ')}</ph name=\"${ph.closeName}\">`;\n  }\n}\nconst serializerVisitor$1 = new _SerializerVisitor();\nfunction serializeNodes(nodes) {\n  return nodes.map(a => a.visit(serializerVisitor$1, null));\n}\nclass _SerializerIgnoreIcuExpVisitor extends _SerializerVisitor {\n  visitIcu(icu) {\n    let strCases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n    return `{${icu.type}, ${strCases.join(', ')}}`;\n  }\n}\nfunction sha1(str) {\n  textEncoder ??= new TextEncoder();\n  const utf8 = [...textEncoder.encode(str)];\n  const words32 = bytesToWords32(utf8, Endian.Big);\n  const len = utf8.length * 8;\n  const w = new Uint32Array(80);\n  let a = 0x67452301,\n    b = 0xefcdab89,\n    c = 0x98badcfe,\n    d = 0x10325476,\n    e = 0xc3d2e1f0;\n  words32[len >> 5] |= 0x80 << 24 - len % 32;\n  words32[(len + 64 >> 9 << 4) + 15] = len;\n  for (let i = 0; i < words32.length; i += 16) {\n    const h0 = a,\n      h1 = b,\n      h2 = c,\n      h3 = d,\n      h4 = e;\n    for (let j = 0; j < 80; j++) {\n      if (j < 16) {\n        w[j] = words32[i + j];\n      } else {\n        w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n      }\n      const fkVal = fk(j, b, c, d);\n      const f = fkVal[0];\n      const k = fkVal[1];\n      const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n      e = d;\n      d = c;\n      c = rol32(b, 30);\n      b = a;\n      a = temp;\n    }\n    a = add32(a, h0);\n    b = add32(b, h1);\n    c = add32(c, h2);\n    d = add32(d, h3);\n    e = add32(e, h4);\n  }\n  return toHexU32(a) + toHexU32(b) + toHexU32(c) + toHexU32(d) + toHexU32(e);\n}\nfunction toHexU32(value) {\n  return (value >>> 0).toString(16).padStart(8, '0');\n}\nfunction fk(index, b, c, d) {\n  if (index < 20) {\n    return [b & c | ~b & d, 0x5a827999];\n  }\n  if (index < 40) {\n    return [b ^ c ^ d, 0x6ed9eba1];\n  }\n  if (index < 60) {\n    return [b & c | b & d | c & d, 0x8f1bbcdc];\n  }\n  return [b ^ c ^ d, 0xca62c1d6];\n}\nfunction fingerprint(str) {\n  textEncoder ??= new TextEncoder();\n  const utf8 = textEncoder.encode(str);\n  const view = new DataView(utf8.buffer, utf8.byteOffset, utf8.byteLength);\n  let hi = hash32(view, utf8.length, 0);\n  let lo = hash32(view, utf8.length, 102072);\n  if (hi == 0 && (lo == 0 || lo == 1)) {\n    hi = hi ^ 0x130f9bef;\n    lo = lo ^ -0x6b5f56d8;\n  }\n  return BigInt.asUintN(32, BigInt(hi)) << BigInt(32) | BigInt.asUintN(32, BigInt(lo));\n}\nfunction computeMsgId(msg, meaning = '') {\n  let msgFingerprint = fingerprint(msg);\n  if (meaning) {\n    msgFingerprint = BigInt.asUintN(64, msgFingerprint << BigInt(1)) | msgFingerprint >> BigInt(63) & BigInt(1);\n    msgFingerprint += fingerprint(meaning);\n  }\n  return BigInt.asUintN(63, msgFingerprint).toString();\n}\nfunction hash32(view, length, c) {\n  let a = 0x9e3779b9,\n    b = 0x9e3779b9;\n  let index = 0;\n  const end = length - 12;\n  for (; index <= end; index += 12) {\n    a += view.getUint32(index, true);\n    b += view.getUint32(index + 4, true);\n    c += view.getUint32(index + 8, true);\n    const res = mix(a, b, c);\n    a = res[0], b = res[1], c = res[2];\n  }\n  const remainder = length - index;\n  c += length;\n  if (remainder >= 4) {\n    a += view.getUint32(index, true);\n    index += 4;\n    if (remainder >= 8) {\n      b += view.getUint32(index, true);\n      index += 4;\n      if (remainder >= 9) {\n        c += view.getUint8(index++) << 8;\n      }\n      if (remainder >= 10) {\n        c += view.getUint8(index++) << 16;\n      }\n      if (remainder === 11) {\n        c += view.getUint8(index++) << 24;\n      }\n    } else {\n      if (remainder >= 5) {\n        b += view.getUint8(index++);\n      }\n      if (remainder >= 6) {\n        b += view.getUint8(index++) << 8;\n      }\n      if (remainder === 7) {\n        b += view.getUint8(index++) << 16;\n      }\n    }\n  } else {\n    if (remainder >= 1) {\n      a += view.getUint8(index++);\n    }\n    if (remainder >= 2) {\n      a += view.getUint8(index++) << 8;\n    }\n    if (remainder === 3) {\n      a += view.getUint8(index++) << 16;\n    }\n  }\n  return mix(a, b, c)[2];\n}\nfunction mix(a, b, c) {\n  a -= b;\n  a -= c;\n  a ^= c >>> 13;\n  b -= c;\n  b -= a;\n  b ^= a << 8;\n  c -= a;\n  c -= b;\n  c ^= b >>> 13;\n  a -= b;\n  a -= c;\n  a ^= c >>> 12;\n  b -= c;\n  b -= a;\n  b ^= a << 16;\n  c -= a;\n  c -= b;\n  c ^= b >>> 5;\n  a -= b;\n  a -= c;\n  a ^= c >>> 3;\n  b -= c;\n  b -= a;\n  b ^= a << 10;\n  c -= a;\n  c -= b;\n  c ^= b >>> 15;\n  return [a, b, c];\n}\nvar Endian;\n(function (Endian) {\n  Endian[Endian[\"Little\"] = 0] = \"Little\";\n  Endian[Endian[\"Big\"] = 1] = \"Big\";\n})(Endian || (Endian = {}));\nfunction add32(a, b) {\n  return add32to64(a, b)[1];\n}\nfunction add32to64(a, b) {\n  const low = (a & 0xffff) + (b & 0xffff);\n  const high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n  return [high >>> 16, high << 16 | low & 0xffff];\n}\nfunction rol32(a, count) {\n  return a << count | a >>> 32 - count;\n}\nfunction bytesToWords32(bytes, endian) {\n  const size = bytes.length + 3 >>> 2;\n  const words32 = [];\n  for (let i = 0; i < size; i++) {\n    words32[i] = wordAt(bytes, i * 4, endian);\n  }\n  return words32;\n}\nfunction byteAt(bytes, index) {\n  return index >= bytes.length ? 0 : bytes[index];\n}\nfunction wordAt(bytes, index, endian) {\n  let word = 0;\n  if (endian === Endian.Big) {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(bytes, index + i) << 24 - 8 * i;\n    }\n  } else {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(bytes, index + i) << 8 * i;\n    }\n  }\n  return word;\n}\n\nvar TypeModifier;\n(function (TypeModifier) {\n  TypeModifier[TypeModifier[\"None\"] = 0] = \"None\";\n  TypeModifier[TypeModifier[\"Const\"] = 1] = \"Const\";\n})(TypeModifier || (TypeModifier = {}));\nclass Type {\n  modifiers;\n  constructor(modifiers = TypeModifier.None) {\n    this.modifiers = modifiers;\n  }\n  hasModifier(modifier) {\n    return (this.modifiers & modifier) !== 0;\n  }\n}\nvar BuiltinTypeName;\n(function (BuiltinTypeName) {\n  BuiltinTypeName[BuiltinTypeName[\"Dynamic\"] = 0] = \"Dynamic\";\n  BuiltinTypeName[BuiltinTypeName[\"Bool\"] = 1] = \"Bool\";\n  BuiltinTypeName[BuiltinTypeName[\"String\"] = 2] = \"String\";\n  BuiltinTypeName[BuiltinTypeName[\"Int\"] = 3] = \"Int\";\n  BuiltinTypeName[BuiltinTypeName[\"Number\"] = 4] = \"Number\";\n  BuiltinTypeName[BuiltinTypeName[\"Function\"] = 5] = \"Function\";\n  BuiltinTypeName[BuiltinTypeName[\"Inferred\"] = 6] = \"Inferred\";\n  BuiltinTypeName[BuiltinTypeName[\"None\"] = 7] = \"None\";\n})(BuiltinTypeName || (BuiltinTypeName = {}));\nclass BuiltinType extends Type {\n  name;\n  constructor(name, modifiers) {\n    super(modifiers);\n    this.name = name;\n  }\n  visitType(visitor, context) {\n    return visitor.visitBuiltinType(this, context);\n  }\n}\nclass ExpressionType extends Type {\n  value;\n  typeParams;\n  constructor(value, modifiers, typeParams = null) {\n    super(modifiers);\n    this.value = value;\n    this.typeParams = typeParams;\n  }\n  visitType(visitor, context) {\n    return visitor.visitExpressionType(this, context);\n  }\n}\nclass ArrayType extends Type {\n  of;\n  constructor(of, modifiers) {\n    super(modifiers);\n    this.of = of;\n  }\n  visitType(visitor, context) {\n    return visitor.visitArrayType(this, context);\n  }\n}\nclass MapType extends Type {\n  valueType;\n  constructor(valueType, modifiers) {\n    super(modifiers);\n    this.valueType = valueType || null;\n  }\n  visitType(visitor, context) {\n    return visitor.visitMapType(this, context);\n  }\n}\nclass TransplantedType extends Type {\n  type;\n  constructor(type, modifiers) {\n    super(modifiers);\n    this.type = type;\n  }\n  visitType(visitor, context) {\n    return visitor.visitTransplantedType(this, context);\n  }\n}\nconst DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\nconst INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\nconst BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\nconst INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\nconst NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\nconst STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\nconst FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\nconst NONE_TYPE = new BuiltinType(BuiltinTypeName.None);\nvar UnaryOperator;\n(function (UnaryOperator) {\n  UnaryOperator[UnaryOperator[\"Minus\"] = 0] = \"Minus\";\n  UnaryOperator[UnaryOperator[\"Plus\"] = 1] = \"Plus\";\n})(UnaryOperator || (UnaryOperator = {}));\nvar BinaryOperator;\n(function (BinaryOperator) {\n  BinaryOperator[BinaryOperator[\"Equals\"] = 0] = \"Equals\";\n  BinaryOperator[BinaryOperator[\"NotEquals\"] = 1] = \"NotEquals\";\n  BinaryOperator[BinaryOperator[\"Assign\"] = 2] = \"Assign\";\n  BinaryOperator[BinaryOperator[\"Identical\"] = 3] = \"Identical\";\n  BinaryOperator[BinaryOperator[\"NotIdentical\"] = 4] = \"NotIdentical\";\n  BinaryOperator[BinaryOperator[\"Minus\"] = 5] = \"Minus\";\n  BinaryOperator[BinaryOperator[\"Plus\"] = 6] = \"Plus\";\n  BinaryOperator[BinaryOperator[\"Divide\"] = 7] = \"Divide\";\n  BinaryOperator[BinaryOperator[\"Multiply\"] = 8] = \"Multiply\";\n  BinaryOperator[BinaryOperator[\"Modulo\"] = 9] = \"Modulo\";\n  BinaryOperator[BinaryOperator[\"And\"] = 10] = \"And\";\n  BinaryOperator[BinaryOperator[\"Or\"] = 11] = \"Or\";\n  BinaryOperator[BinaryOperator[\"BitwiseOr\"] = 12] = \"BitwiseOr\";\n  BinaryOperator[BinaryOperator[\"BitwiseAnd\"] = 13] = \"BitwiseAnd\";\n  BinaryOperator[BinaryOperator[\"Lower\"] = 14] = \"Lower\";\n  BinaryOperator[BinaryOperator[\"LowerEquals\"] = 15] = \"LowerEquals\";\n  BinaryOperator[BinaryOperator[\"Bigger\"] = 16] = \"Bigger\";\n  BinaryOperator[BinaryOperator[\"BiggerEquals\"] = 17] = \"BiggerEquals\";\n  BinaryOperator[BinaryOperator[\"NullishCoalesce\"] = 18] = \"NullishCoalesce\";\n  BinaryOperator[BinaryOperator[\"Exponentiation\"] = 19] = \"Exponentiation\";\n  BinaryOperator[BinaryOperator[\"In\"] = 20] = \"In\";\n  BinaryOperator[BinaryOperator[\"AdditionAssignment\"] = 21] = \"AdditionAssignment\";\n  BinaryOperator[BinaryOperator[\"SubtractionAssignment\"] = 22] = \"SubtractionAssignment\";\n  BinaryOperator[BinaryOperator[\"MultiplicationAssignment\"] = 23] = \"MultiplicationAssignment\";\n  BinaryOperator[BinaryOperator[\"DivisionAssignment\"] = 24] = \"DivisionAssignment\";\n  BinaryOperator[BinaryOperator[\"RemainderAssignment\"] = 25] = \"RemainderAssignment\";\n  BinaryOperator[BinaryOperator[\"ExponentiationAssignment\"] = 26] = \"ExponentiationAssignment\";\n  BinaryOperator[BinaryOperator[\"AndAssignment\"] = 27] = \"AndAssignment\";\n  BinaryOperator[BinaryOperator[\"OrAssignment\"] = 28] = \"OrAssignment\";\n  BinaryOperator[BinaryOperator[\"NullishCoalesceAssignment\"] = 29] = \"NullishCoalesceAssignment\";\n})(BinaryOperator || (BinaryOperator = {}));\nfunction nullSafeIsEquivalent(base, other) {\n  if (base == null || other == null) {\n    return base == other;\n  }\n  return base.isEquivalent(other);\n}\nfunction areAllEquivalentPredicate(base, other, equivalentPredicate) {\n  const len = base.length;\n  if (len !== other.length) {\n    return false;\n  }\n  for (let i = 0; i < len; i++) {\n    if (!equivalentPredicate(base[i], other[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction areAllEquivalent(base, other) {\n  return areAllEquivalentPredicate(base, other, (baseElement, otherElement) => baseElement.isEquivalent(otherElement));\n}\nclass Expression {\n  type;\n  sourceSpan;\n  constructor(type, sourceSpan) {\n    this.type = type || null;\n    this.sourceSpan = sourceSpan || null;\n  }\n  prop(name, sourceSpan) {\n    return new ReadPropExpr(this, name, null, sourceSpan);\n  }\n  key(index, type, sourceSpan) {\n    return new ReadKeyExpr(this, index, type, sourceSpan);\n  }\n  callFn(params, sourceSpan, pure) {\n    return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);\n  }\n  instantiate(params, type, sourceSpan) {\n    return new InstantiateExpr(this, params, type, sourceSpan);\n  }\n  conditional(trueCase, falseCase = null, sourceSpan) {\n    return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n  }\n  equals(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n  }\n  notEquals(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n  }\n  identical(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n  }\n  notIdentical(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n  }\n  minus(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n  }\n  plus(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n  }\n  divide(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n  }\n  multiply(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n  }\n  modulo(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n  }\n  power(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Exponentiation, this, rhs, null, sourceSpan);\n  }\n  and(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n  }\n  bitwiseOr(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.BitwiseOr, this, rhs, null, sourceSpan);\n  }\n  bitwiseAnd(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan);\n  }\n  or(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n  }\n  lower(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n  }\n  lowerEquals(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n  }\n  bigger(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n  }\n  biggerEquals(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n  }\n  isBlank(sourceSpan) {\n    return this.equals(TYPED_NULL_EXPR, sourceSpan);\n  }\n  nullishCoalesce(rhs, sourceSpan) {\n    return new BinaryOperatorExpr(BinaryOperator.NullishCoalesce, this, rhs, null, sourceSpan);\n  }\n  toStmt() {\n    return new ExpressionStatement(this, null);\n  }\n}\nclass ReadVarExpr extends Expression {\n  name;\n  constructor(name, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.name = name;\n  }\n  isEquivalent(e) {\n    return e instanceof ReadVarExpr && this.name === e.name;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitReadVarExpr(this, context);\n  }\n  clone() {\n    return new ReadVarExpr(this.name, this.type, this.sourceSpan);\n  }\n  set(value) {\n    return new BinaryOperatorExpr(BinaryOperator.Assign, this, value, null, this.sourceSpan);\n  }\n}\nclass TypeofExpr extends Expression {\n  expr;\n  constructor(expr, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.expr = expr;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitTypeofExpr(this, context);\n  }\n  isEquivalent(e) {\n    return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);\n  }\n  isConstant() {\n    return this.expr.isConstant();\n  }\n  clone() {\n    return new TypeofExpr(this.expr.clone());\n  }\n}\nclass VoidExpr extends Expression {\n  expr;\n  constructor(expr, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.expr = expr;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitVoidExpr(this, context);\n  }\n  isEquivalent(e) {\n    return e instanceof VoidExpr && e.expr.isEquivalent(this.expr);\n  }\n  isConstant() {\n    return this.expr.isConstant();\n  }\n  clone() {\n    return new VoidExpr(this.expr.clone());\n  }\n}\nclass WrappedNodeExpr extends Expression {\n  node;\n  constructor(node, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.node = node;\n  }\n  isEquivalent(e) {\n    return e instanceof WrappedNodeExpr && this.node === e.node;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitWrappedNodeExpr(this, context);\n  }\n  clone() {\n    return new WrappedNodeExpr(this.node, this.type, this.sourceSpan);\n  }\n}\nclass InvokeFunctionExpr extends Expression {\n  fn;\n  args;\n  pure;\n  constructor(fn, args, type, sourceSpan, pure = false) {\n    super(type, sourceSpan);\n    this.fn = fn;\n    this.args = args;\n    this.pure = pure;\n  }\n  get receiver() {\n    return this.fn;\n  }\n  isEquivalent(e) {\n    return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) && areAllEquivalent(this.args, e.args) && this.pure === e.pure;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitInvokeFunctionExpr(this, context);\n  }\n  clone() {\n    return new InvokeFunctionExpr(this.fn.clone(), this.args.map(arg => arg.clone()), this.type, this.sourceSpan, this.pure);\n  }\n}\nclass TaggedTemplateLiteralExpr extends Expression {\n  tag;\n  template;\n  constructor(tag, template, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.tag = tag;\n    this.template = template;\n  }\n  isEquivalent(e) {\n    return e instanceof TaggedTemplateLiteralExpr && this.tag.isEquivalent(e.tag) && this.template.isEquivalent(e.template);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitTaggedTemplateLiteralExpr(this, context);\n  }\n  clone() {\n    return new TaggedTemplateLiteralExpr(this.tag.clone(), this.template.clone(), this.type, this.sourceSpan);\n  }\n}\nclass InstantiateExpr extends Expression {\n  classExpr;\n  args;\n  constructor(classExpr, args, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.classExpr = classExpr;\n    this.args = args;\n  }\n  isEquivalent(e) {\n    return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) && areAllEquivalent(this.args, e.args);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitInstantiateExpr(this, context);\n  }\n  clone() {\n    return new InstantiateExpr(this.classExpr.clone(), this.args.map(arg => arg.clone()), this.type, this.sourceSpan);\n  }\n}\nclass RegularExpressionLiteralExpr extends Expression {\n  body;\n  flags;\n  constructor(body, flags, sourceSpan) {\n    super(null, sourceSpan);\n    this.body = body;\n    this.flags = flags;\n  }\n  isEquivalent(e) {\n    return e instanceof RegularExpressionLiteralExpr && this.body === e.body && this.flags === e.flags;\n  }\n  isConstant() {\n    return true;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitRegularExpressionLiteral(this, context);\n  }\n  clone() {\n    return new RegularExpressionLiteralExpr(this.body, this.flags, this.sourceSpan);\n  }\n}\nclass LiteralExpr extends Expression {\n  value;\n  constructor(value, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.value = value;\n  }\n  isEquivalent(e) {\n    return e instanceof LiteralExpr && this.value === e.value;\n  }\n  isConstant() {\n    return true;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitLiteralExpr(this, context);\n  }\n  clone() {\n    return new LiteralExpr(this.value, this.type, this.sourceSpan);\n  }\n}\nclass TemplateLiteralExpr extends Expression {\n  elements;\n  expressions;\n  constructor(elements, expressions, sourceSpan) {\n    super(null, sourceSpan);\n    this.elements = elements;\n    this.expressions = expressions;\n  }\n  isEquivalent(e) {\n    return e instanceof TemplateLiteralExpr && areAllEquivalentPredicate(this.elements, e.elements, (a, b) => a.text === b.text) && areAllEquivalent(this.expressions, e.expressions);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitTemplateLiteralExpr(this, context);\n  }\n  clone() {\n    return new TemplateLiteralExpr(this.elements.map(el => el.clone()), this.expressions.map(expr => expr.clone()));\n  }\n}\nclass TemplateLiteralElementExpr extends Expression {\n  text;\n  rawText;\n  constructor(text, sourceSpan, rawText) {\n    super(STRING_TYPE, sourceSpan);\n    this.text = text;\n    this.rawText = rawText ?? escapeForTemplateLiteral(escapeSlashes(text));\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitTemplateLiteralElementExpr(this, context);\n  }\n  isEquivalent(e) {\n    return e instanceof TemplateLiteralElementExpr && e.text === this.text && e.rawText === this.rawText;\n  }\n  isConstant() {\n    return true;\n  }\n  clone() {\n    return new TemplateLiteralElementExpr(this.text, this.sourceSpan, this.rawText);\n  }\n}\nclass LiteralPiece {\n  text;\n  sourceSpan;\n  constructor(text, sourceSpan) {\n    this.text = text;\n    this.sourceSpan = sourceSpan;\n  }\n}\nclass PlaceholderPiece {\n  text;\n  sourceSpan;\n  associatedMessage;\n  constructor(text, sourceSpan, associatedMessage) {\n    this.text = text;\n    this.sourceSpan = sourceSpan;\n    this.associatedMessage = associatedMessage;\n  }\n}\nconst MEANING_SEPARATOR$1 = '|';\nconst ID_SEPARATOR$1 = '@@';\nconst LEGACY_ID_INDICATOR = 'âŸ';\nclass LocalizedString extends Expression {\n  metaBlock;\n  messageParts;\n  placeHolderNames;\n  expressions;\n  constructor(metaBlock, messageParts, placeHolderNames, expressions, sourceSpan) {\n    super(STRING_TYPE, sourceSpan);\n    this.metaBlock = metaBlock;\n    this.messageParts = messageParts;\n    this.placeHolderNames = placeHolderNames;\n    this.expressions = expressions;\n  }\n  isEquivalent(e) {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitLocalizedString(this, context);\n  }\n  clone() {\n    return new LocalizedString(this.metaBlock, this.messageParts, this.placeHolderNames, this.expressions.map(expr => expr.clone()), this.sourceSpan);\n  }\n  serializeI18nHead() {\n    let metaBlock = this.metaBlock.description || '';\n    if (this.metaBlock.meaning) {\n      metaBlock = `${this.metaBlock.meaning}${MEANING_SEPARATOR$1}${metaBlock}`;\n    }\n    if (this.metaBlock.customId) {\n      metaBlock = `${metaBlock}${ID_SEPARATOR$1}${this.metaBlock.customId}`;\n    }\n    if (this.metaBlock.legacyIds) {\n      this.metaBlock.legacyIds.forEach(legacyId => {\n        metaBlock = `${metaBlock}${LEGACY_ID_INDICATOR}${legacyId}`;\n      });\n    }\n    return createCookedRawString(metaBlock, this.messageParts[0].text, this.getMessagePartSourceSpan(0));\n  }\n  getMessagePartSourceSpan(i) {\n    return this.messageParts[i]?.sourceSpan ?? this.sourceSpan;\n  }\n  getPlaceholderSourceSpan(i) {\n    return this.placeHolderNames[i]?.sourceSpan ?? this.expressions[i]?.sourceSpan ?? this.sourceSpan;\n  }\n  serializeI18nTemplatePart(partIndex) {\n    const placeholder = this.placeHolderNames[partIndex - 1];\n    const messagePart = this.messageParts[partIndex];\n    let metaBlock = placeholder.text;\n    if (placeholder.associatedMessage?.legacyIds.length === 0) {\n      metaBlock += `${ID_SEPARATOR$1}${computeMsgId(placeholder.associatedMessage.messageString, placeholder.associatedMessage.meaning)}`;\n    }\n    return createCookedRawString(metaBlock, messagePart.text, this.getMessagePartSourceSpan(partIndex));\n  }\n}\nconst escapeSlashes = str => str.replace(/\\\\/g, '\\\\\\\\');\nconst escapeStartingColon = str => str.replace(/^:/, '\\\\:');\nconst escapeColons = str => str.replace(/:/g, '\\\\:');\nconst escapeForTemplateLiteral = str => str.replace(/`/g, '\\\\`').replace(/\\${/g, '$\\\\{');\nfunction createCookedRawString(metaBlock, messagePart, range) {\n  if (metaBlock === '') {\n    return {\n      cooked: messagePart,\n      raw: escapeForTemplateLiteral(escapeStartingColon(escapeSlashes(messagePart))),\n      range\n    };\n  } else {\n    return {\n      cooked: `:${metaBlock}:${messagePart}`,\n      raw: escapeForTemplateLiteral(`:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`),\n      range\n    };\n  }\n}\nclass ExternalExpr extends Expression {\n  value;\n  typeParams;\n  constructor(value, type, typeParams = null, sourceSpan) {\n    super(type, sourceSpan);\n    this.value = value;\n    this.typeParams = typeParams;\n  }\n  isEquivalent(e) {\n    return e instanceof ExternalExpr && this.value.name === e.value.name && this.value.moduleName === e.value.moduleName;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitExternalExpr(this, context);\n  }\n  clone() {\n    return new ExternalExpr(this.value, this.type, this.typeParams, this.sourceSpan);\n  }\n}\nclass ExternalReference {\n  moduleName;\n  name;\n  constructor(moduleName, name) {\n    this.moduleName = moduleName;\n    this.name = name;\n  }\n}\nclass ConditionalExpr extends Expression {\n  condition;\n  falseCase;\n  trueCase;\n  constructor(condition, trueCase, falseCase = null, type, sourceSpan) {\n    super(type || trueCase.type, sourceSpan);\n    this.condition = condition;\n    this.falseCase = falseCase;\n    this.trueCase = trueCase;\n  }\n  isEquivalent(e) {\n    return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) && this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitConditionalExpr(this, context);\n  }\n  clone() {\n    return new ConditionalExpr(this.condition.clone(), this.trueCase.clone(), this.falseCase?.clone(), this.type, this.sourceSpan);\n  }\n}\nclass DynamicImportExpr extends Expression {\n  url;\n  urlComment;\n  constructor(url, sourceSpan, urlComment) {\n    super(null, sourceSpan);\n    this.url = url;\n    this.urlComment = urlComment;\n  }\n  isEquivalent(e) {\n    return e instanceof DynamicImportExpr && this.url === e.url && this.urlComment === e.urlComment;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitDynamicImportExpr(this, context);\n  }\n  clone() {\n    return new DynamicImportExpr(typeof this.url === 'string' ? this.url : this.url.clone(), this.sourceSpan, this.urlComment);\n  }\n}\nclass NotExpr extends Expression {\n  condition;\n  constructor(condition, sourceSpan) {\n    super(BOOL_TYPE, sourceSpan);\n    this.condition = condition;\n  }\n  isEquivalent(e) {\n    return e instanceof NotExpr && this.condition.isEquivalent(e.condition);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitNotExpr(this, context);\n  }\n  clone() {\n    return new NotExpr(this.condition.clone(), this.sourceSpan);\n  }\n}\nclass FnParam {\n  name;\n  type;\n  constructor(name, type = null) {\n    this.name = name;\n    this.type = type;\n  }\n  isEquivalent(param) {\n    return this.name === param.name;\n  }\n  clone() {\n    return new FnParam(this.name, this.type);\n  }\n}\nclass FunctionExpr extends Expression {\n  params;\n  statements;\n  name;\n  constructor(params, statements, type, sourceSpan, name) {\n    super(type, sourceSpan);\n    this.params = params;\n    this.statements = statements;\n    this.name = name;\n  }\n  isEquivalent(e) {\n    return (e instanceof FunctionExpr || e instanceof DeclareFunctionStmt) && areAllEquivalent(this.params, e.params) && areAllEquivalent(this.statements, e.statements);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitFunctionExpr(this, context);\n  }\n  toDeclStmt(name, modifiers) {\n    return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\n  }\n  clone() {\n    return new FunctionExpr(this.params.map(p => p.clone()), this.statements, this.type, this.sourceSpan, this.name);\n  }\n}\nclass ArrowFunctionExpr extends Expression {\n  params;\n  body;\n  constructor(params, body, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.params = params;\n    this.body = body;\n  }\n  isEquivalent(e) {\n    if (!(e instanceof ArrowFunctionExpr) || !areAllEquivalent(this.params, e.params)) {\n      return false;\n    }\n    if (this.body instanceof Expression && e.body instanceof Expression) {\n      return this.body.isEquivalent(e.body);\n    }\n    if (Array.isArray(this.body) && Array.isArray(e.body)) {\n      return areAllEquivalent(this.body, e.body);\n    }\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitArrowFunctionExpr(this, context);\n  }\n  clone() {\n    return new ArrowFunctionExpr(this.params.map(p => p.clone()), Array.isArray(this.body) ? this.body : this.body.clone(), this.type, this.sourceSpan);\n  }\n  toDeclStmt(name, modifiers) {\n    return new DeclareVarStmt(name, this, INFERRED_TYPE, modifiers, this.sourceSpan);\n  }\n}\nclass UnaryOperatorExpr extends Expression {\n  operator;\n  expr;\n  parens;\n  constructor(operator, expr, type, sourceSpan, parens = true) {\n    super(type || NUMBER_TYPE, sourceSpan);\n    this.operator = operator;\n    this.expr = expr;\n    this.parens = parens;\n  }\n  isEquivalent(e) {\n    return e instanceof UnaryOperatorExpr && this.operator === e.operator && this.expr.isEquivalent(e.expr);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitUnaryOperatorExpr(this, context);\n  }\n  clone() {\n    return new UnaryOperatorExpr(this.operator, this.expr.clone(), this.type, this.sourceSpan, this.parens);\n  }\n}\nclass ParenthesizedExpr extends Expression {\n  expr;\n  constructor(expr, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.expr = expr;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitParenthesizedExpr(this, context);\n  }\n  isEquivalent(e) {\n    return e instanceof ParenthesizedExpr && e.expr.isEquivalent(this.expr);\n  }\n  isConstant() {\n    return this.expr.isConstant();\n  }\n  clone() {\n    return new ParenthesizedExpr(this.expr.clone());\n  }\n}\nclass BinaryOperatorExpr extends Expression {\n  operator;\n  rhs;\n  lhs;\n  constructor(operator, lhs, rhs, type, sourceSpan) {\n    super(type || lhs.type, sourceSpan);\n    this.operator = operator;\n    this.rhs = rhs;\n    this.lhs = lhs;\n  }\n  isEquivalent(e) {\n    return e instanceof BinaryOperatorExpr && this.operator === e.operator && this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitBinaryOperatorExpr(this, context);\n  }\n  clone() {\n    return new BinaryOperatorExpr(this.operator, this.lhs.clone(), this.rhs.clone(), this.type, this.sourceSpan);\n  }\n  isAssignment() {\n    const op = this.operator;\n    return op === BinaryOperator.Assign || op === BinaryOperator.AdditionAssignment || op === BinaryOperator.SubtractionAssignment || op === BinaryOperator.MultiplicationAssignment || op === BinaryOperator.DivisionAssignment || op === BinaryOperator.RemainderAssignment || op === BinaryOperator.ExponentiationAssignment || op === BinaryOperator.AndAssignment || op === BinaryOperator.OrAssignment || op === BinaryOperator.NullishCoalesceAssignment;\n  }\n}\nclass ReadPropExpr extends Expression {\n  receiver;\n  name;\n  constructor(receiver, name, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.receiver = receiver;\n    this.name = name;\n  }\n  get index() {\n    return this.name;\n  }\n  isEquivalent(e) {\n    return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name;\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitReadPropExpr(this, context);\n  }\n  set(value) {\n    return new BinaryOperatorExpr(BinaryOperator.Assign, this.receiver.prop(this.name), value, null, this.sourceSpan);\n  }\n  clone() {\n    return new ReadPropExpr(this.receiver.clone(), this.name, this.type, this.sourceSpan);\n  }\n}\nclass ReadKeyExpr extends Expression {\n  receiver;\n  index;\n  constructor(receiver, index, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.receiver = receiver;\n    this.index = index;\n  }\n  isEquivalent(e) {\n    return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) && this.index.isEquivalent(e.index);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitReadKeyExpr(this, context);\n  }\n  set(value) {\n    return new BinaryOperatorExpr(BinaryOperator.Assign, this.receiver.key(this.index), value, null, this.sourceSpan);\n  }\n  clone() {\n    return new ReadKeyExpr(this.receiver.clone(), this.index.clone(), this.type, this.sourceSpan);\n  }\n}\nclass LiteralArrayExpr extends Expression {\n  entries;\n  constructor(entries, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.entries = entries;\n  }\n  isConstant() {\n    return this.entries.every(e => e.isConstant());\n  }\n  isEquivalent(e) {\n    return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitLiteralArrayExpr(this, context);\n  }\n  clone() {\n    return new LiteralArrayExpr(this.entries.map(e => e.clone()), this.type, this.sourceSpan);\n  }\n}\nclass LiteralMapEntry {\n  key;\n  value;\n  quoted;\n  constructor(key, value, quoted) {\n    this.key = key;\n    this.value = value;\n    this.quoted = quoted;\n  }\n  isEquivalent(e) {\n    return this.key === e.key && this.value.isEquivalent(e.value);\n  }\n  clone() {\n    return new LiteralMapEntry(this.key, this.value.clone(), this.quoted);\n  }\n}\nclass LiteralMapExpr extends Expression {\n  entries;\n  valueType = null;\n  constructor(entries, type, sourceSpan) {\n    super(type, sourceSpan);\n    this.entries = entries;\n    if (type) {\n      this.valueType = type.valueType;\n    }\n  }\n  isEquivalent(e) {\n    return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);\n  }\n  isConstant() {\n    return this.entries.every(e => e.value.isConstant());\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitLiteralMapExpr(this, context);\n  }\n  clone() {\n    const entriesClone = this.entries.map(entry => entry.clone());\n    return new LiteralMapExpr(entriesClone, this.type, this.sourceSpan);\n  }\n}\nclass CommaExpr extends Expression {\n  parts;\n  constructor(parts, sourceSpan) {\n    super(parts[parts.length - 1].type, sourceSpan);\n    this.parts = parts;\n  }\n  isEquivalent(e) {\n    return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);\n  }\n  isConstant() {\n    return false;\n  }\n  visitExpression(visitor, context) {\n    return visitor.visitCommaExpr(this, context);\n  }\n  clone() {\n    return new CommaExpr(this.parts.map(p => p.clone()));\n  }\n}\nconst NULL_EXPR = new LiteralExpr(null, null, null);\nconst TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);\nvar StmtModifier;\n(function (StmtModifier) {\n  StmtModifier[StmtModifier[\"None\"] = 0] = \"None\";\n  StmtModifier[StmtModifier[\"Final\"] = 1] = \"Final\";\n  StmtModifier[StmtModifier[\"Private\"] = 2] = \"Private\";\n  StmtModifier[StmtModifier[\"Exported\"] = 4] = \"Exported\";\n  StmtModifier[StmtModifier[\"Static\"] = 8] = \"Static\";\n})(StmtModifier || (StmtModifier = {}));\nclass LeadingComment {\n  text;\n  multiline;\n  trailingNewline;\n  constructor(text, multiline, trailingNewline) {\n    this.text = text;\n    this.multiline = multiline;\n    this.trailingNewline = trailingNewline;\n  }\n  toString() {\n    return this.multiline ? ` ${this.text} ` : this.text;\n  }\n}\nclass JSDocComment extends LeadingComment {\n  tags;\n  constructor(tags) {\n    super('', true, true);\n    this.tags = tags;\n  }\n  toString() {\n    return serializeTags(this.tags);\n  }\n}\nclass Statement {\n  modifiers;\n  sourceSpan;\n  leadingComments;\n  constructor(modifiers = StmtModifier.None, sourceSpan = null, leadingComments) {\n    this.modifiers = modifiers;\n    this.sourceSpan = sourceSpan;\n    this.leadingComments = leadingComments;\n  }\n  hasModifier(modifier) {\n    return (this.modifiers & modifier) !== 0;\n  }\n  addLeadingComment(leadingComment) {\n    this.leadingComments = this.leadingComments ?? [];\n    this.leadingComments.push(leadingComment);\n  }\n}\nclass DeclareVarStmt extends Statement {\n  name;\n  value;\n  type;\n  constructor(name, value, type, modifiers, sourceSpan, leadingComments) {\n    super(modifiers, sourceSpan, leadingComments);\n    this.name = name;\n    this.value = value;\n    this.type = type || value && value.type || null;\n  }\n  isEquivalent(stmt) {\n    return stmt instanceof DeclareVarStmt && this.name === stmt.name && (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);\n  }\n  visitStatement(visitor, context) {\n    return visitor.visitDeclareVarStmt(this, context);\n  }\n}\nclass DeclareFunctionStmt extends Statement {\n  name;\n  params;\n  statements;\n  type;\n  constructor(name, params, statements, type, modifiers, sourceSpan, leadingComments) {\n    super(modifiers, sourceSpan, leadingComments);\n    this.name = name;\n    this.params = params;\n    this.statements = statements;\n    this.type = type || null;\n  }\n  isEquivalent(stmt) {\n    return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) && areAllEquivalent(this.statements, stmt.statements);\n  }\n  visitStatement(visitor, context) {\n    return visitor.visitDeclareFunctionStmt(this, context);\n  }\n}\nclass ExpressionStatement extends Statement {\n  expr;\n  constructor(expr, sourceSpan, leadingComments) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n    this.expr = expr;\n  }\n  isEquivalent(stmt) {\n    return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);\n  }\n  visitStatement(visitor, context) {\n    return visitor.visitExpressionStmt(this, context);\n  }\n}\nclass ReturnStatement extends Statement {\n  value;\n  constructor(value, sourceSpan = null, leadingComments) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n    this.value = value;\n  }\n  isEquivalent(stmt) {\n    return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);\n  }\n  visitStatement(visitor, context) {\n    return visitor.visitReturnStmt(this, context);\n  }\n}\nclass IfStmt extends Statement {\n  condition;\n  trueCase;\n  falseCase;\n  constructor(condition, trueCase, falseCase = [], sourceSpan, leadingComments) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n    this.condition = condition;\n    this.trueCase = trueCase;\n    this.falseCase = falseCase;\n  }\n  isEquivalent(stmt) {\n    return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) && areAllEquivalent(this.trueCase, stmt.trueCase) && areAllEquivalent(this.falseCase, stmt.falseCase);\n  }\n  visitStatement(visitor, context) {\n    return visitor.visitIfStmt(this, context);\n  }\n}\nlet RecursiveAstVisitor$1 = class RecursiveAstVisitor {\n  visitType(ast, context) {\n    return ast;\n  }\n  visitExpression(ast, context) {\n    if (ast.type) {\n      ast.type.visitType(this, context);\n    }\n    return ast;\n  }\n  visitBuiltinType(type, context) {\n    return this.visitType(type, context);\n  }\n  visitExpressionType(type, context) {\n    type.value.visitExpression(this, context);\n    if (type.typeParams !== null) {\n      type.typeParams.forEach(param => this.visitType(param, context));\n    }\n    return this.visitType(type, context);\n  }\n  visitArrayType(type, context) {\n    return this.visitType(type, context);\n  }\n  visitMapType(type, context) {\n    return this.visitType(type, context);\n  }\n  visitTransplantedType(type, context) {\n    return type;\n  }\n  visitWrappedNodeExpr(ast, context) {\n    return ast;\n  }\n  visitReadVarExpr(ast, context) {\n    return this.visitExpression(ast, context);\n  }\n  visitDynamicImportExpr(ast, context) {\n    return this.visitExpression(ast, context);\n  }\n  visitInvokeFunctionExpr(ast, context) {\n    ast.fn.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTaggedTemplateLiteralExpr(ast, context) {\n    ast.tag.visitExpression(this, context);\n    ast.template.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitInstantiateExpr(ast, context) {\n    ast.classExpr.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralExpr(ast, context) {\n    return this.visitExpression(ast, context);\n  }\n  visitRegularExpressionLiteral(ast, context) {\n    return this.visitExpression(ast, context);\n  }\n  visitLocalizedString(ast, context) {\n    return this.visitExpression(ast, context);\n  }\n  visitExternalExpr(ast, context) {\n    if (ast.typeParams) {\n      ast.typeParams.forEach(type => type.visitType(this, context));\n    }\n    return this.visitExpression(ast, context);\n  }\n  visitConditionalExpr(ast, context) {\n    ast.condition.visitExpression(this, context);\n    ast.trueCase.visitExpression(this, context);\n    ast.falseCase.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitNotExpr(ast, context) {\n    ast.condition.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitFunctionExpr(ast, context) {\n    this.visitAllStatements(ast.statements, context);\n    return this.visitExpression(ast, context);\n  }\n  visitArrowFunctionExpr(ast, context) {\n    if (Array.isArray(ast.body)) {\n      this.visitAllStatements(ast.body, context);\n    } else {\n      ast.body.visitExpression(this, context);\n    }\n    return this.visitExpression(ast, context);\n  }\n  visitUnaryOperatorExpr(ast, context) {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTypeofExpr(ast, context) {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitVoidExpr(ast, context) {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitBinaryOperatorExpr(ast, context) {\n    ast.lhs.visitExpression(this, context);\n    ast.rhs.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitReadPropExpr(ast, context) {\n    ast.receiver.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitReadKeyExpr(ast, context) {\n    ast.receiver.visitExpression(this, context);\n    ast.index.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralArrayExpr(ast, context) {\n    this.visitAllExpressions(ast.entries, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralMapExpr(ast, context) {\n    ast.entries.forEach(entry => entry.value.visitExpression(this, context));\n    return this.visitExpression(ast, context);\n  }\n  visitCommaExpr(ast, context) {\n    this.visitAllExpressions(ast.parts, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTemplateLiteralExpr(ast, context) {\n    this.visitAllExpressions(ast.elements, context);\n    this.visitAllExpressions(ast.expressions, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTemplateLiteralElementExpr(ast, context) {\n    return this.visitExpression(ast, context);\n  }\n  visitParenthesizedExpr(ast, context) {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitAllExpressions(exprs, context) {\n    exprs.forEach(expr => expr.visitExpression(this, context));\n  }\n  visitDeclareVarStmt(stmt, context) {\n    if (stmt.value) {\n      stmt.value.visitExpression(this, context);\n    }\n    if (stmt.type) {\n      stmt.type.visitType(this, context);\n    }\n    return stmt;\n  }\n  visitDeclareFunctionStmt(stmt, context) {\n    this.visitAllStatements(stmt.statements, context);\n    if (stmt.type) {\n      stmt.type.visitType(this, context);\n    }\n    return stmt;\n  }\n  visitExpressionStmt(stmt, context) {\n    stmt.expr.visitExpression(this, context);\n    return stmt;\n  }\n  visitReturnStmt(stmt, context) {\n    stmt.value.visitExpression(this, context);\n    return stmt;\n  }\n  visitIfStmt(stmt, context) {\n    stmt.condition.visitExpression(this, context);\n    this.visitAllStatements(stmt.trueCase, context);\n    this.visitAllStatements(stmt.falseCase, context);\n    return stmt;\n  }\n  visitAllStatements(stmts, context) {\n    stmts.forEach(stmt => stmt.visitStatement(this, context));\n  }\n};\nfunction leadingComment(text, multiline = false, trailingNewline = true) {\n  return new LeadingComment(text, multiline, trailingNewline);\n}\nfunction jsDocComment(tags = []) {\n  return new JSDocComment(tags);\n}\nfunction variable(name, type, sourceSpan) {\n  return new ReadVarExpr(name, type, sourceSpan);\n}\nfunction importExpr(id, typeParams = null, sourceSpan) {\n  return new ExternalExpr(id, null, typeParams, sourceSpan);\n}\nfunction importType(id, typeParams, typeModifiers) {\n  return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\n}\nfunction expressionType(expr, typeModifiers, typeParams) {\n  return new ExpressionType(expr, typeModifiers, typeParams);\n}\nfunction transplantedType(type, typeModifiers) {\n  return new TransplantedType(type, typeModifiers);\n}\nfunction typeofExpr(expr) {\n  return new TypeofExpr(expr);\n}\nfunction literalArr(values, type, sourceSpan) {\n  return new LiteralArrayExpr(values, type, sourceSpan);\n}\nfunction literalMap(values, type = null) {\n  return new LiteralMapExpr(values.map(e => new LiteralMapEntry(e.key, e.value, e.quoted)), type, null);\n}\nfunction unary(operator, expr, type, sourceSpan) {\n  return new UnaryOperatorExpr(operator, expr, type, sourceSpan);\n}\nfunction not(expr, sourceSpan) {\n  return new NotExpr(expr, sourceSpan);\n}\nfunction fn(params, body, type, sourceSpan, name) {\n  return new FunctionExpr(params, body, type, sourceSpan, name);\n}\nfunction arrowFn(params, body, type, sourceSpan) {\n  return new ArrowFunctionExpr(params, body, type, sourceSpan);\n}\nfunction ifStmt(condition, thenClause, elseClause, sourceSpan, leadingComments) {\n  return new IfStmt(condition, thenClause, elseClause, sourceSpan, leadingComments);\n}\nfunction taggedTemplate(tag, template, type, sourceSpan) {\n  return new TaggedTemplateLiteralExpr(tag, template, type, sourceSpan);\n}\nfunction literal(value, type, sourceSpan) {\n  return new LiteralExpr(value, type, sourceSpan);\n}\nfunction localizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan) {\n  return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);\n}\nfunction isNull(exp) {\n  return exp instanceof LiteralExpr && exp.value === null;\n}\nfunction tagToString(tag) {\n  let out = '';\n  if (tag.tagName) {\n    out += ` @${tag.tagName}`;\n  }\n  if (tag.text) {\n    if (tag.text.match(/\\/\\*|\\*\\//)) {\n      throw new Error('JSDoc text cannot contain \"/*\" and \"*/\"');\n    }\n    out += ' ' + tag.text.replace(/@/g, '\\\\@');\n  }\n  return out;\n}\nfunction serializeTags(tags) {\n  if (tags.length === 0) return '';\n  if (tags.length === 1 && tags[0].tagName && !tags[0].text) {\n    return `*${tagToString(tags[0])} `;\n  }\n  let out = '*\\n';\n  for (const tag of tags) {\n    out += ' *';\n    out += tagToString(tag).replace(/\\n/g, '\\n * ');\n    out += '\\n';\n  }\n  out += ' ';\n  return out;\n}\n\nvar output_ast = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ArrayType: ArrayType,\n    ArrowFunctionExpr: ArrowFunctionExpr,\n    BOOL_TYPE: BOOL_TYPE,\n    get BinaryOperator () { return BinaryOperator; },\n    BinaryOperatorExpr: BinaryOperatorExpr,\n    BuiltinType: BuiltinType,\n    get BuiltinTypeName () { return BuiltinTypeName; },\n    CommaExpr: CommaExpr,\n    ConditionalExpr: ConditionalExpr,\n    DYNAMIC_TYPE: DYNAMIC_TYPE,\n    DeclareFunctionStmt: DeclareFunctionStmt,\n    DeclareVarStmt: DeclareVarStmt,\n    DynamicImportExpr: DynamicImportExpr,\n    Expression: Expression,\n    ExpressionStatement: ExpressionStatement,\n    ExpressionType: ExpressionType,\n    ExternalExpr: ExternalExpr,\n    ExternalReference: ExternalReference,\n    FUNCTION_TYPE: FUNCTION_TYPE,\n    FnParam: FnParam,\n    FunctionExpr: FunctionExpr,\n    INFERRED_TYPE: INFERRED_TYPE,\n    INT_TYPE: INT_TYPE,\n    IfStmt: IfStmt,\n    InstantiateExpr: InstantiateExpr,\n    InvokeFunctionExpr: InvokeFunctionExpr,\n    JSDocComment: JSDocComment,\n    LeadingComment: LeadingComment,\n    LiteralArrayExpr: LiteralArrayExpr,\n    LiteralExpr: LiteralExpr,\n    LiteralMapEntry: LiteralMapEntry,\n    LiteralMapExpr: LiteralMapExpr,\n    LiteralPiece: LiteralPiece,\n    LocalizedString: LocalizedString,\n    MapType: MapType,\n    NONE_TYPE: NONE_TYPE,\n    NULL_EXPR: NULL_EXPR,\n    NUMBER_TYPE: NUMBER_TYPE,\n    NotExpr: NotExpr,\n    ParenthesizedExpr: ParenthesizedExpr,\n    PlaceholderPiece: PlaceholderPiece,\n    ReadKeyExpr: ReadKeyExpr,\n    ReadPropExpr: ReadPropExpr,\n    ReadVarExpr: ReadVarExpr,\n    RecursiveAstVisitor: RecursiveAstVisitor$1,\n    RegularExpressionLiteralExpr: RegularExpressionLiteralExpr,\n    ReturnStatement: ReturnStatement,\n    STRING_TYPE: STRING_TYPE,\n    Statement: Statement,\n    get StmtModifier () { return StmtModifier; },\n    TYPED_NULL_EXPR: TYPED_NULL_EXPR,\n    TaggedTemplateLiteralExpr: TaggedTemplateLiteralExpr,\n    TemplateLiteralElementExpr: TemplateLiteralElementExpr,\n    TemplateLiteralExpr: TemplateLiteralExpr,\n    TransplantedType: TransplantedType,\n    Type: Type,\n    get TypeModifier () { return TypeModifier; },\n    TypeofExpr: TypeofExpr,\n    get UnaryOperator () { return UnaryOperator; },\n    UnaryOperatorExpr: UnaryOperatorExpr,\n    VoidExpr: VoidExpr,\n    WrappedNodeExpr: WrappedNodeExpr,\n    areAllEquivalent: areAllEquivalent,\n    arrowFn: arrowFn,\n    expressionType: expressionType,\n    fn: fn,\n    ifStmt: ifStmt,\n    importExpr: importExpr,\n    importType: importType,\n    isNull: isNull,\n    jsDocComment: jsDocComment,\n    leadingComment: leadingComment,\n    literal: literal,\n    literalArr: literalArr,\n    literalMap: literalMap,\n    localizedString: localizedString,\n    not: not,\n    nullSafeIsEquivalent: nullSafeIsEquivalent,\n    taggedTemplate: taggedTemplate,\n    transplantedType: transplantedType,\n    typeofExpr: typeofExpr,\n    unary: unary,\n    variable: variable\n});\n\nconst CONSTANT_PREFIX = '_c';\nconst UNKNOWN_VALUE_KEY = variable('<unknown>');\nconst KEY_CONTEXT = {};\nconst POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS = 50;\nclass FixupExpression extends Expression {\n  resolved;\n  original;\n  shared = false;\n  constructor(resolved) {\n    super(resolved.type);\n    this.resolved = resolved;\n    this.original = resolved;\n  }\n  visitExpression(visitor, context) {\n    if (context === KEY_CONTEXT) {\n      return this.original.visitExpression(visitor, context);\n    } else {\n      return this.resolved.visitExpression(visitor, context);\n    }\n  }\n  isEquivalent(e) {\n    return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n  }\n  isConstant() {\n    return true;\n  }\n  clone() {\n    throw new Error(`Not supported.`);\n  }\n  fixup(expression) {\n    this.resolved = expression;\n    this.shared = true;\n  }\n}\nclass ConstantPool {\n  isClosureCompilerEnabled;\n  statements = [];\n  literals = new Map();\n  literalFactories = new Map();\n  sharedConstants = new Map();\n  _claimedNames = new Map();\n  nextNameIndex = 0;\n  constructor(isClosureCompilerEnabled = false) {\n    this.isClosureCompilerEnabled = isClosureCompilerEnabled;\n  }\n  getConstLiteral(literal, forceShared) {\n    if (literal instanceof LiteralExpr && !isLongStringLiteral(literal) || literal instanceof FixupExpression) {\n      return literal;\n    }\n    const key = GenericKeyFn.INSTANCE.keyOf(literal);\n    let fixup = this.literals.get(key);\n    let newValue = false;\n    if (!fixup) {\n      fixup = new FixupExpression(literal);\n      this.literals.set(key, fixup);\n      newValue = true;\n    }\n    if (!newValue && !fixup.shared || newValue && forceShared) {\n      const name = this.freshName();\n      let value;\n      let usage;\n      if (this.isClosureCompilerEnabled && isLongStringLiteral(literal)) {\n        value = new FunctionExpr([], [new ReturnStatement(literal)]);\n        usage = variable(name).callFn([]);\n      } else {\n        value = literal;\n        usage = variable(name);\n      }\n      this.statements.push(new DeclareVarStmt(name, value, INFERRED_TYPE, StmtModifier.Final));\n      fixup.fixup(usage);\n    }\n    return fixup;\n  }\n  getSharedConstant(def, expr) {\n    const key = def.keyOf(expr);\n    if (!this.sharedConstants.has(key)) {\n      const id = this.freshName();\n      this.sharedConstants.set(key, variable(id));\n      this.statements.push(def.toSharedConstantDeclaration(id, expr));\n    }\n    return this.sharedConstants.get(key);\n  }\n  getLiteralFactory(literal) {\n    if (literal instanceof LiteralArrayExpr) {\n      const argumentsForKey = literal.entries.map(e => e.isConstant() ? e : UNKNOWN_VALUE_KEY);\n      const key = GenericKeyFn.INSTANCE.keyOf(literalArr(argumentsForKey));\n      return this._getLiteralFactory(key, literal.entries, entries => literalArr(entries));\n    } else {\n      const expressionForKey = literalMap(literal.entries.map(e => ({\n        key: e.key,\n        value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,\n        quoted: e.quoted\n      })));\n      const key = GenericKeyFn.INSTANCE.keyOf(expressionForKey);\n      return this._getLiteralFactory(key, literal.entries.map(e => e.value), entries => literalMap(entries.map((value, index) => ({\n        key: literal.entries[index].key,\n        value,\n        quoted: literal.entries[index].quoted\n      }))));\n    }\n  }\n  getSharedFunctionReference(fn, prefix, useUniqueName = true) {\n    const isArrow = fn instanceof ArrowFunctionExpr;\n    for (const current of this.statements) {\n      if (isArrow && current instanceof DeclareVarStmt && current.value?.isEquivalent(fn)) {\n        return variable(current.name);\n      }\n      if (!isArrow && current instanceof DeclareFunctionStmt && fn instanceof FunctionExpr && fn.isEquivalent(current)) {\n        return variable(current.name);\n      }\n    }\n    const name = useUniqueName ? this.uniqueName(prefix) : prefix;\n    this.statements.push(fn instanceof FunctionExpr ? fn.toDeclStmt(name, StmtModifier.Final) : new DeclareVarStmt(name, fn, INFERRED_TYPE, StmtModifier.Final, fn.sourceSpan));\n    return variable(name);\n  }\n  _getLiteralFactory(key, values, resultMap) {\n    let literalFactory = this.literalFactories.get(key);\n    const literalFactoryArguments = values.filter(e => !e.isConstant());\n    if (!literalFactory) {\n      const resultExpressions = values.map((e, index) => e.isConstant() ? this.getConstLiteral(e, true) : variable(`a${index}`));\n      const parameters = resultExpressions.filter(isVariable).map(e => new FnParam(e.name, DYNAMIC_TYPE));\n      const pureFunctionDeclaration = arrowFn(parameters, resultMap(resultExpressions), INFERRED_TYPE);\n      const name = this.freshName();\n      this.statements.push(new DeclareVarStmt(name, pureFunctionDeclaration, INFERRED_TYPE, StmtModifier.Final));\n      literalFactory = variable(name);\n      this.literalFactories.set(key, literalFactory);\n    }\n    return {\n      literalFactory,\n      literalFactoryArguments\n    };\n  }\n  uniqueName(name, alwaysIncludeSuffix = true) {\n    const count = this._claimedNames.get(name) ?? 0;\n    const result = count === 0 && !alwaysIncludeSuffix ? `${name}` : `${name}${count}`;\n    this._claimedNames.set(name, count + 1);\n    return result;\n  }\n  freshName() {\n    return this.uniqueName(CONSTANT_PREFIX);\n  }\n}\nclass GenericKeyFn {\n  static INSTANCE = new GenericKeyFn();\n  keyOf(expr) {\n    if (expr instanceof LiteralExpr && typeof expr.value === 'string') {\n      return `\"${expr.value}\"`;\n    } else if (expr instanceof LiteralExpr) {\n      return String(expr.value);\n    } else if (expr instanceof RegularExpressionLiteralExpr) {\n      return `/${expr.body}/${expr.flags ?? ''}`;\n    } else if (expr instanceof LiteralArrayExpr) {\n      const entries = [];\n      for (const entry of expr.entries) {\n        entries.push(this.keyOf(entry));\n      }\n      return `[${entries.join(',')}]`;\n    } else if (expr instanceof LiteralMapExpr) {\n      const entries = [];\n      for (const entry of expr.entries) {\n        let key = entry.key;\n        if (entry.quoted) {\n          key = `\"${key}\"`;\n        }\n        entries.push(key + ':' + this.keyOf(entry.value));\n      }\n      return `{${entries.join(',')}}`;\n    } else if (expr instanceof ExternalExpr) {\n      return `import(\"${expr.value.moduleName}\", ${expr.value.name})`;\n    } else if (expr instanceof ReadVarExpr) {\n      return `read(${expr.name})`;\n    } else if (expr instanceof TypeofExpr) {\n      return `typeof(${this.keyOf(expr.expr)})`;\n    } else {\n      throw new Error(`${this.constructor.name} does not handle expressions of type ${expr.constructor.name}`);\n    }\n  }\n}\nfunction isVariable(e) {\n  return e instanceof ReadVarExpr;\n}\nfunction isLongStringLiteral(expr) {\n  return expr instanceof LiteralExpr && typeof expr.value === 'string' && expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS;\n}\n\nconst CORE = '@angular/core';\nclass Identifiers {\n  static NEW_METHOD = 'factory';\n  static TRANSFORM_METHOD = 'transform';\n  static PATCH_DEPS = 'patchedDeps';\n  static core = {\n    name: null,\n    moduleName: CORE\n  };\n  static namespaceHTML = {\n    name: 'ÉµÉµnamespaceHTML',\n    moduleName: CORE\n  };\n  static namespaceMathML = {\n    name: 'ÉµÉµnamespaceMathML',\n    moduleName: CORE\n  };\n  static namespaceSVG = {\n    name: 'ÉµÉµnamespaceSVG',\n    moduleName: CORE\n  };\n  static element = {\n    name: 'ÉµÉµelement',\n    moduleName: CORE\n  };\n  static elementStart = {\n    name: 'ÉµÉµelementStart',\n    moduleName: CORE\n  };\n  static elementEnd = {\n    name: 'ÉµÉµelementEnd',\n    moduleName: CORE\n  };\n  static domElement = {\n    name: 'ÉµÉµdomElement',\n    moduleName: CORE\n  };\n  static domElementStart = {\n    name: 'ÉµÉµdomElementStart',\n    moduleName: CORE\n  };\n  static domElementEnd = {\n    name: 'ÉµÉµdomElementEnd',\n    moduleName: CORE\n  };\n  static domElementContainer = {\n    name: 'ÉµÉµdomElementContainer',\n    moduleName: CORE\n  };\n  static domElementContainerStart = {\n    name: 'ÉµÉµdomElementContainerStart',\n    moduleName: CORE\n  };\n  static domElementContainerEnd = {\n    name: 'ÉµÉµdomElementContainerEnd',\n    moduleName: CORE\n  };\n  static domTemplate = {\n    name: 'ÉµÉµdomTemplate',\n    moduleName: CORE\n  };\n  static domListener = {\n    name: 'ÉµÉµdomListener',\n    moduleName: CORE\n  };\n  static advance = {\n    name: 'ÉµÉµadvance',\n    moduleName: CORE\n  };\n  static syntheticHostProperty = {\n    name: 'ÉµÉµsyntheticHostProperty',\n    moduleName: CORE\n  };\n  static syntheticHostListener = {\n    name: 'ÉµÉµsyntheticHostListener',\n    moduleName: CORE\n  };\n  static attribute = {\n    name: 'ÉµÉµattribute',\n    moduleName: CORE\n  };\n  static classProp = {\n    name: 'ÉµÉµclassProp',\n    moduleName: CORE\n  };\n  static elementContainerStart = {\n    name: 'ÉµÉµelementContainerStart',\n    moduleName: CORE\n  };\n  static elementContainerEnd = {\n    name: 'ÉµÉµelementContainerEnd',\n    moduleName: CORE\n  };\n  static elementContainer = {\n    name: 'ÉµÉµelementContainer',\n    moduleName: CORE\n  };\n  static styleMap = {\n    name: 'ÉµÉµstyleMap',\n    moduleName: CORE\n  };\n  static classMap = {\n    name: 'ÉµÉµclassMap',\n    moduleName: CORE\n  };\n  static styleProp = {\n    name: 'ÉµÉµstyleProp',\n    moduleName: CORE\n  };\n  static interpolate = {\n    name: 'ÉµÉµinterpolate',\n    moduleName: CORE\n  };\n  static interpolate1 = {\n    name: 'ÉµÉµinterpolate1',\n    moduleName: CORE\n  };\n  static interpolate2 = {\n    name: 'ÉµÉµinterpolate2',\n    moduleName: CORE\n  };\n  static interpolate3 = {\n    name: 'ÉµÉµinterpolate3',\n    moduleName: CORE\n  };\n  static interpolate4 = {\n    name: 'ÉµÉµinterpolate4',\n    moduleName: CORE\n  };\n  static interpolate5 = {\n    name: 'ÉµÉµinterpolate5',\n    moduleName: CORE\n  };\n  static interpolate6 = {\n    name: 'ÉµÉµinterpolate6',\n    moduleName: CORE\n  };\n  static interpolate7 = {\n    name: 'ÉµÉµinterpolate7',\n    moduleName: CORE\n  };\n  static interpolate8 = {\n    name: 'ÉµÉµinterpolate8',\n    moduleName: CORE\n  };\n  static interpolateV = {\n    name: 'ÉµÉµinterpolateV',\n    moduleName: CORE\n  };\n  static nextContext = {\n    name: 'ÉµÉµnextContext',\n    moduleName: CORE\n  };\n  static resetView = {\n    name: 'ÉµÉµresetView',\n    moduleName: CORE\n  };\n  static templateCreate = {\n    name: 'ÉµÉµtemplate',\n    moduleName: CORE\n  };\n  static defer = {\n    name: 'ÉµÉµdefer',\n    moduleName: CORE\n  };\n  static deferWhen = {\n    name: 'ÉµÉµdeferWhen',\n    moduleName: CORE\n  };\n  static deferOnIdle = {\n    name: 'ÉµÉµdeferOnIdle',\n    moduleName: CORE\n  };\n  static deferOnImmediate = {\n    name: 'ÉµÉµdeferOnImmediate',\n    moduleName: CORE\n  };\n  static deferOnTimer = {\n    name: 'ÉµÉµdeferOnTimer',\n    moduleName: CORE\n  };\n  static deferOnHover = {\n    name: 'ÉµÉµdeferOnHover',\n    moduleName: CORE\n  };\n  static deferOnInteraction = {\n    name: 'ÉµÉµdeferOnInteraction',\n    moduleName: CORE\n  };\n  static deferOnViewport = {\n    name: 'ÉµÉµdeferOnViewport',\n    moduleName: CORE\n  };\n  static deferPrefetchWhen = {\n    name: 'ÉµÉµdeferPrefetchWhen',\n    moduleName: CORE\n  };\n  static deferPrefetchOnIdle = {\n    name: 'ÉµÉµdeferPrefetchOnIdle',\n    moduleName: CORE\n  };\n  static deferPrefetchOnImmediate = {\n    name: 'ÉµÉµdeferPrefetchOnImmediate',\n    moduleName: CORE\n  };\n  static deferPrefetchOnTimer = {\n    name: 'ÉµÉµdeferPrefetchOnTimer',\n    moduleName: CORE\n  };\n  static deferPrefetchOnHover = {\n    name: 'ÉµÉµdeferPrefetchOnHover',\n    moduleName: CORE\n  };\n  static deferPrefetchOnInteraction = {\n    name: 'ÉµÉµdeferPrefetchOnInteraction',\n    moduleName: CORE\n  };\n  static deferPrefetchOnViewport = {\n    name: 'ÉµÉµdeferPrefetchOnViewport',\n    moduleName: CORE\n  };\n  static deferHydrateWhen = {\n    name: 'ÉµÉµdeferHydrateWhen',\n    moduleName: CORE\n  };\n  static deferHydrateNever = {\n    name: 'ÉµÉµdeferHydrateNever',\n    moduleName: CORE\n  };\n  static deferHydrateOnIdle = {\n    name: 'ÉµÉµdeferHydrateOnIdle',\n    moduleName: CORE\n  };\n  static deferHydrateOnImmediate = {\n    name: 'ÉµÉµdeferHydrateOnImmediate',\n    moduleName: CORE\n  };\n  static deferHydrateOnTimer = {\n    name: 'ÉµÉµdeferHydrateOnTimer',\n    moduleName: CORE\n  };\n  static deferHydrateOnHover = {\n    name: 'ÉµÉµdeferHydrateOnHover',\n    moduleName: CORE\n  };\n  static deferHydrateOnInteraction = {\n    name: 'ÉµÉµdeferHydrateOnInteraction',\n    moduleName: CORE\n  };\n  static deferHydrateOnViewport = {\n    name: 'ÉµÉµdeferHydrateOnViewport',\n    moduleName: CORE\n  };\n  static deferEnableTimerScheduling = {\n    name: 'ÉµÉµdeferEnableTimerScheduling',\n    moduleName: CORE\n  };\n  static conditionalCreate = {\n    name: 'ÉµÉµconditionalCreate',\n    moduleName: CORE\n  };\n  static conditionalBranchCreate = {\n    name: 'ÉµÉµconditionalBranchCreate',\n    moduleName: CORE\n  };\n  static conditional = {\n    name: 'ÉµÉµconditional',\n    moduleName: CORE\n  };\n  static repeater = {\n    name: 'ÉµÉµrepeater',\n    moduleName: CORE\n  };\n  static repeaterCreate = {\n    name: 'ÉµÉµrepeaterCreate',\n    moduleName: CORE\n  };\n  static repeaterTrackByIndex = {\n    name: 'ÉµÉµrepeaterTrackByIndex',\n    moduleName: CORE\n  };\n  static repeaterTrackByIdentity = {\n    name: 'ÉµÉµrepeaterTrackByIdentity',\n    moduleName: CORE\n  };\n  static componentInstance = {\n    name: 'ÉµÉµcomponentInstance',\n    moduleName: CORE\n  };\n  static text = {\n    name: 'ÉµÉµtext',\n    moduleName: CORE\n  };\n  static enableBindings = {\n    name: 'ÉµÉµenableBindings',\n    moduleName: CORE\n  };\n  static disableBindings = {\n    name: 'ÉµÉµdisableBindings',\n    moduleName: CORE\n  };\n  static getCurrentView = {\n    name: 'ÉµÉµgetCurrentView',\n    moduleName: CORE\n  };\n  static textInterpolate = {\n    name: 'ÉµÉµtextInterpolate',\n    moduleName: CORE\n  };\n  static textInterpolate1 = {\n    name: 'ÉµÉµtextInterpolate1',\n    moduleName: CORE\n  };\n  static textInterpolate2 = {\n    name: 'ÉµÉµtextInterpolate2',\n    moduleName: CORE\n  };\n  static textInterpolate3 = {\n    name: 'ÉµÉµtextInterpolate3',\n    moduleName: CORE\n  };\n  static textInterpolate4 = {\n    name: 'ÉµÉµtextInterpolate4',\n    moduleName: CORE\n  };\n  static textInterpolate5 = {\n    name: 'ÉµÉµtextInterpolate5',\n    moduleName: CORE\n  };\n  static textInterpolate6 = {\n    name: 'ÉµÉµtextInterpolate6',\n    moduleName: CORE\n  };\n  static textInterpolate7 = {\n    name: 'ÉµÉµtextInterpolate7',\n    moduleName: CORE\n  };\n  static textInterpolate8 = {\n    name: 'ÉµÉµtextInterpolate8',\n    moduleName: CORE\n  };\n  static textInterpolateV = {\n    name: 'ÉµÉµtextInterpolateV',\n    moduleName: CORE\n  };\n  static restoreView = {\n    name: 'ÉµÉµrestoreView',\n    moduleName: CORE\n  };\n  static pureFunction0 = {\n    name: 'ÉµÉµpureFunction0',\n    moduleName: CORE\n  };\n  static pureFunction1 = {\n    name: 'ÉµÉµpureFunction1',\n    moduleName: CORE\n  };\n  static pureFunction2 = {\n    name: 'ÉµÉµpureFunction2',\n    moduleName: CORE\n  };\n  static pureFunction3 = {\n    name: 'ÉµÉµpureFunction3',\n    moduleName: CORE\n  };\n  static pureFunction4 = {\n    name: 'ÉµÉµpureFunction4',\n    moduleName: CORE\n  };\n  static pureFunction5 = {\n    name: 'ÉµÉµpureFunction5',\n    moduleName: CORE\n  };\n  static pureFunction6 = {\n    name: 'ÉµÉµpureFunction6',\n    moduleName: CORE\n  };\n  static pureFunction7 = {\n    name: 'ÉµÉµpureFunction7',\n    moduleName: CORE\n  };\n  static pureFunction8 = {\n    name: 'ÉµÉµpureFunction8',\n    moduleName: CORE\n  };\n  static pureFunctionV = {\n    name: 'ÉµÉµpureFunctionV',\n    moduleName: CORE\n  };\n  static pipeBind1 = {\n    name: 'ÉµÉµpipeBind1',\n    moduleName: CORE\n  };\n  static pipeBind2 = {\n    name: 'ÉµÉµpipeBind2',\n    moduleName: CORE\n  };\n  static pipeBind3 = {\n    name: 'ÉµÉµpipeBind3',\n    moduleName: CORE\n  };\n  static pipeBind4 = {\n    name: 'ÉµÉµpipeBind4',\n    moduleName: CORE\n  };\n  static pipeBindV = {\n    name: 'ÉµÉµpipeBindV',\n    moduleName: CORE\n  };\n  static domProperty = {\n    name: 'ÉµÉµdomProperty',\n    moduleName: CORE\n  };\n  static ariaProperty = {\n    name: 'ÉµÉµariaProperty',\n    moduleName: CORE\n  };\n  static property = {\n    name: 'ÉµÉµproperty',\n    moduleName: CORE\n  };\n  static control = {\n    name: 'ÉµÉµcontrol',\n    moduleName: CORE\n  };\n  static controlCreate = {\n    name: 'ÉµÉµcontrolCreate',\n    moduleName: CORE\n  };\n  static animationEnterListener = {\n    name: 'ÉµÉµanimateEnterListener',\n    moduleName: CORE\n  };\n  static animationLeaveListener = {\n    name: 'ÉµÉµanimateLeaveListener',\n    moduleName: CORE\n  };\n  static animationEnter = {\n    name: 'ÉµÉµanimateEnter',\n    moduleName: CORE\n  };\n  static animationLeave = {\n    name: 'ÉµÉµanimateLeave',\n    moduleName: CORE\n  };\n  static i18n = {\n    name: 'ÉµÉµi18n',\n    moduleName: CORE\n  };\n  static i18nAttributes = {\n    name: 'ÉµÉµi18nAttributes',\n    moduleName: CORE\n  };\n  static i18nExp = {\n    name: 'ÉµÉµi18nExp',\n    moduleName: CORE\n  };\n  static i18nStart = {\n    name: 'ÉµÉµi18nStart',\n    moduleName: CORE\n  };\n  static i18nEnd = {\n    name: 'ÉµÉµi18nEnd',\n    moduleName: CORE\n  };\n  static i18nApply = {\n    name: 'ÉµÉµi18nApply',\n    moduleName: CORE\n  };\n  static i18nPostprocess = {\n    name: 'ÉµÉµi18nPostprocess',\n    moduleName: CORE\n  };\n  static pipe = {\n    name: 'ÉµÉµpipe',\n    moduleName: CORE\n  };\n  static projection = {\n    name: 'ÉµÉµprojection',\n    moduleName: CORE\n  };\n  static projectionDef = {\n    name: 'ÉµÉµprojectionDef',\n    moduleName: CORE\n  };\n  static reference = {\n    name: 'ÉµÉµreference',\n    moduleName: CORE\n  };\n  static inject = {\n    name: 'ÉµÉµinject',\n    moduleName: CORE\n  };\n  static injectAttribute = {\n    name: 'ÉµÉµinjectAttribute',\n    moduleName: CORE\n  };\n  static directiveInject = {\n    name: 'ÉµÉµdirectiveInject',\n    moduleName: CORE\n  };\n  static invalidFactory = {\n    name: 'ÉµÉµinvalidFactory',\n    moduleName: CORE\n  };\n  static invalidFactoryDep = {\n    name: 'ÉµÉµinvalidFactoryDep',\n    moduleName: CORE\n  };\n  static templateRefExtractor = {\n    name: 'ÉµÉµtemplateRefExtractor',\n    moduleName: CORE\n  };\n  static forwardRef = {\n    name: 'forwardRef',\n    moduleName: CORE\n  };\n  static resolveForwardRef = {\n    name: 'resolveForwardRef',\n    moduleName: CORE\n  };\n  static replaceMetadata = {\n    name: 'ÉµÉµreplaceMetadata',\n    moduleName: CORE\n  };\n  static getReplaceMetadataURL = {\n    name: 'ÉµÉµgetReplaceMetadataURL',\n    moduleName: CORE\n  };\n  static ÉµÉµdefineInjectable = {\n    name: 'ÉµÉµdefineInjectable',\n    moduleName: CORE\n  };\n  static declareInjectable = {\n    name: 'ÉµÉµngDeclareInjectable',\n    moduleName: CORE\n  };\n  static InjectableDeclaration = {\n    name: 'ÉµÉµInjectableDeclaration',\n    moduleName: CORE\n  };\n  static resolveWindow = {\n    name: 'ÉµÉµresolveWindow',\n    moduleName: CORE\n  };\n  static resolveDocument = {\n    name: 'ÉµÉµresolveDocument',\n    moduleName: CORE\n  };\n  static resolveBody = {\n    name: 'ÉµÉµresolveBody',\n    moduleName: CORE\n  };\n  static getComponentDepsFactory = {\n    name: 'ÉµÉµgetComponentDepsFactory',\n    moduleName: CORE\n  };\n  static defineComponent = {\n    name: 'ÉµÉµdefineComponent',\n    moduleName: CORE\n  };\n  static declareComponent = {\n    name: 'ÉµÉµngDeclareComponent',\n    moduleName: CORE\n  };\n  static setComponentScope = {\n    name: 'ÉµÉµsetComponentScope',\n    moduleName: CORE\n  };\n  static ChangeDetectionStrategy = {\n    name: 'ChangeDetectionStrategy',\n    moduleName: CORE\n  };\n  static ViewEncapsulation = {\n    name: 'ViewEncapsulation',\n    moduleName: CORE\n  };\n  static ComponentDeclaration = {\n    name: 'ÉµÉµComponentDeclaration',\n    moduleName: CORE\n  };\n  static FactoryDeclaration = {\n    name: 'ÉµÉµFactoryDeclaration',\n    moduleName: CORE\n  };\n  static declareFactory = {\n    name: 'ÉµÉµngDeclareFactory',\n    moduleName: CORE\n  };\n  static FactoryTarget = {\n    name: 'ÉµÉµFactoryTarget',\n    moduleName: CORE\n  };\n  static defineDirective = {\n    name: 'ÉµÉµdefineDirective',\n    moduleName: CORE\n  };\n  static declareDirective = {\n    name: 'ÉµÉµngDeclareDirective',\n    moduleName: CORE\n  };\n  static DirectiveDeclaration = {\n    name: 'ÉµÉµDirectiveDeclaration',\n    moduleName: CORE\n  };\n  static InjectorDef = {\n    name: 'ÉµÉµInjectorDef',\n    moduleName: CORE\n  };\n  static InjectorDeclaration = {\n    name: 'ÉµÉµInjectorDeclaration',\n    moduleName: CORE\n  };\n  static defineInjector = {\n    name: 'ÉµÉµdefineInjector',\n    moduleName: CORE\n  };\n  static declareInjector = {\n    name: 'ÉµÉµngDeclareInjector',\n    moduleName: CORE\n  };\n  static NgModuleDeclaration = {\n    name: 'ÉµÉµNgModuleDeclaration',\n    moduleName: CORE\n  };\n  static ModuleWithProviders = {\n    name: 'ModuleWithProviders',\n    moduleName: CORE\n  };\n  static defineNgModule = {\n    name: 'ÉµÉµdefineNgModule',\n    moduleName: CORE\n  };\n  static declareNgModule = {\n    name: 'ÉµÉµngDeclareNgModule',\n    moduleName: CORE\n  };\n  static setNgModuleScope = {\n    name: 'ÉµÉµsetNgModuleScope',\n    moduleName: CORE\n  };\n  static registerNgModuleType = {\n    name: 'ÉµÉµregisterNgModuleType',\n    moduleName: CORE\n  };\n  static PipeDeclaration = {\n    name: 'ÉµÉµPipeDeclaration',\n    moduleName: CORE\n  };\n  static definePipe = {\n    name: 'ÉµÉµdefinePipe',\n    moduleName: CORE\n  };\n  static declarePipe = {\n    name: 'ÉµÉµngDeclarePipe',\n    moduleName: CORE\n  };\n  static declareClassMetadata = {\n    name: 'ÉµÉµngDeclareClassMetadata',\n    moduleName: CORE\n  };\n  static declareClassMetadataAsync = {\n    name: 'ÉµÉµngDeclareClassMetadataAsync',\n    moduleName: CORE\n  };\n  static setClassMetadata = {\n    name: 'ÉµsetClassMetadata',\n    moduleName: CORE\n  };\n  static setClassMetadataAsync = {\n    name: 'ÉµsetClassMetadataAsync',\n    moduleName: CORE\n  };\n  static setClassDebugInfo = {\n    name: 'ÉµsetClassDebugInfo',\n    moduleName: CORE\n  };\n  static queryRefresh = {\n    name: 'ÉµÉµqueryRefresh',\n    moduleName: CORE\n  };\n  static viewQuery = {\n    name: 'ÉµÉµviewQuery',\n    moduleName: CORE\n  };\n  static loadQuery = {\n    name: 'ÉµÉµloadQuery',\n    moduleName: CORE\n  };\n  static contentQuery = {\n    name: 'ÉµÉµcontentQuery',\n    moduleName: CORE\n  };\n  static viewQuerySignal = {\n    name: 'ÉµÉµviewQuerySignal',\n    moduleName: CORE\n  };\n  static contentQuerySignal = {\n    name: 'ÉµÉµcontentQuerySignal',\n    moduleName: CORE\n  };\n  static queryAdvance = {\n    name: 'ÉµÉµqueryAdvance',\n    moduleName: CORE\n  };\n  static twoWayProperty = {\n    name: 'ÉµÉµtwoWayProperty',\n    moduleName: CORE\n  };\n  static twoWayBindingSet = {\n    name: 'ÉµÉµtwoWayBindingSet',\n    moduleName: CORE\n  };\n  static twoWayListener = {\n    name: 'ÉµÉµtwoWayListener',\n    moduleName: CORE\n  };\n  static declareLet = {\n    name: 'ÉµÉµdeclareLet',\n    moduleName: CORE\n  };\n  static storeLet = {\n    name: 'ÉµÉµstoreLet',\n    moduleName: CORE\n  };\n  static readContextLet = {\n    name: 'ÉµÉµreadContextLet',\n    moduleName: CORE\n  };\n  static attachSourceLocations = {\n    name: 'ÉµÉµattachSourceLocations',\n    moduleName: CORE\n  };\n  static NgOnChangesFeature = {\n    name: 'ÉµÉµNgOnChangesFeature',\n    moduleName: CORE\n  };\n  static InheritDefinitionFeature = {\n    name: 'ÉµÉµInheritDefinitionFeature',\n    moduleName: CORE\n  };\n  static ProvidersFeature = {\n    name: 'ÉµÉµProvidersFeature',\n    moduleName: CORE\n  };\n  static HostDirectivesFeature = {\n    name: 'ÉµÉµHostDirectivesFeature',\n    moduleName: CORE\n  };\n  static ExternalStylesFeature = {\n    name: 'ÉµÉµExternalStylesFeature',\n    moduleName: CORE\n  };\n  static listener = {\n    name: 'ÉµÉµlistener',\n    moduleName: CORE\n  };\n  static getInheritedFactory = {\n    name: 'ÉµÉµgetInheritedFactory',\n    moduleName: CORE\n  };\n  static sanitizeHtml = {\n    name: 'ÉµÉµsanitizeHtml',\n    moduleName: CORE\n  };\n  static sanitizeStyle = {\n    name: 'ÉµÉµsanitizeStyle',\n    moduleName: CORE\n  };\n  static sanitizeResourceUrl = {\n    name: 'ÉµÉµsanitizeResourceUrl',\n    moduleName: CORE\n  };\n  static sanitizeScript = {\n    name: 'ÉµÉµsanitizeScript',\n    moduleName: CORE\n  };\n  static sanitizeUrl = {\n    name: 'ÉµÉµsanitizeUrl',\n    moduleName: CORE\n  };\n  static sanitizeUrlOrResourceUrl = {\n    name: 'ÉµÉµsanitizeUrlOrResourceUrl',\n    moduleName: CORE\n  };\n  static trustConstantHtml = {\n    name: 'ÉµÉµtrustConstantHtml',\n    moduleName: CORE\n  };\n  static trustConstantResourceUrl = {\n    name: 'ÉµÉµtrustConstantResourceUrl',\n    moduleName: CORE\n  };\n  static validateIframeAttribute = {\n    name: 'ÉµÉµvalidateIframeAttribute',\n    moduleName: CORE\n  };\n  static inputDecorator = {\n    name: 'Input',\n    moduleName: CORE\n  };\n  static outputDecorator = {\n    name: 'Output',\n    moduleName: CORE\n  };\n  static viewChildDecorator = {\n    name: 'ViewChild',\n    moduleName: CORE\n  };\n  static viewChildrenDecorator = {\n    name: 'ViewChildren',\n    moduleName: CORE\n  };\n  static contentChildDecorator = {\n    name: 'ContentChild',\n    moduleName: CORE\n  };\n  static contentChildrenDecorator = {\n    name: 'ContentChildren',\n    moduleName: CORE\n  };\n  static InputSignalBrandWriteType = {\n    name: 'ÉµINPUT_SIGNAL_BRAND_WRITE_TYPE',\n    moduleName: CORE\n  };\n  static UnwrapDirectiveSignalInputs = {\n    name: 'ÉµUnwrapDirectiveSignalInputs',\n    moduleName: CORE\n  };\n  static unwrapWritableSignal = {\n    name: 'ÉµunwrapWritableSignal',\n    moduleName: CORE\n  };\n  static assertType = {\n    name: 'ÉµassertType',\n    moduleName: CORE\n  };\n}\n\nconst DASH_CASE_REGEXP = /-+([a-z0-9])/g;\nfunction dashCaseToCamelCase(input) {\n  return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());\n}\nfunction splitAtColon(input, defaultValues) {\n  return _splitAt(input, ':', defaultValues);\n}\nfunction splitAtPeriod(input, defaultValues) {\n  return _splitAt(input, '.', defaultValues);\n}\nfunction _splitAt(input, character, defaultValues) {\n  const characterIndex = input.indexOf(character);\n  if (characterIndex == -1) return defaultValues;\n  return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\nfunction noUndefined(val) {\n  return val === undefined ? null : val;\n}\nfunction escapeRegExp(s) {\n  return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}\nfunction utf8Encode(str) {\n  let encoded = [];\n  for (let index = 0; index < str.length; index++) {\n    let codePoint = str.charCodeAt(index);\n    if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > index + 1) {\n      const low = str.charCodeAt(index + 1);\n      if (low >= 0xdc00 && low <= 0xdfff) {\n        index++;\n        codePoint = (codePoint - 0xd800 << 10) + low - 0xdc00 + 0x10000;\n      }\n    }\n    if (codePoint <= 0x7f) {\n      encoded.push(codePoint);\n    } else if (codePoint <= 0x7ff) {\n      encoded.push(codePoint >> 6 & 0x1f | 0xc0, codePoint & 0x3f | 0x80);\n    } else if (codePoint <= 0xffff) {\n      encoded.push(codePoint >> 12 | 0xe0, codePoint >> 6 & 0x3f | 0x80, codePoint & 0x3f | 0x80);\n    } else if (codePoint <= 0x1fffff) {\n      encoded.push(codePoint >> 18 & 0x07 | 0xf0, codePoint >> 12 & 0x3f | 0x80, codePoint >> 6 & 0x3f | 0x80, codePoint & 0x3f | 0x80);\n    }\n  }\n  return encoded;\n}\nfunction stringify(token) {\n  if (typeof token === 'string') {\n    return token;\n  }\n  if (Array.isArray(token)) {\n    return `[${token.map(stringify).join(', ')}]`;\n  }\n  if (token == null) {\n    return '' + token;\n  }\n  const name = token.overriddenName || token.name;\n  if (name) {\n    return `${name}`;\n  }\n  if (!token.toString) {\n    return 'object';\n  }\n  const result = token.toString();\n  if (result == null) {\n    return '' + result;\n  }\n  const newLineIndex = result.indexOf('\\n');\n  return newLineIndex >= 0 ? result.slice(0, newLineIndex) : result;\n}\nclass Version {\n  full;\n  major;\n  minor;\n  patch;\n  constructor(full) {\n    this.full = full;\n    const splits = full.split('.');\n    this.major = splits[0];\n    this.minor = splits[1];\n    this.patch = splits.slice(2).join('.');\n  }\n}\nconst _global = globalThis;\nconst V1_TO_18 = /^([1-9]|1[0-8])\\./;\nfunction getJitStandaloneDefaultForVersion(version) {\n  if (version.startsWith('0.')) {\n    return true;\n  }\n  if (V1_TO_18.test(version)) {\n    return false;\n  }\n  return true;\n}\n\nconst VERSION$1 = 3;\nconst JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\nclass SourceMapGenerator {\n  file;\n  sourcesContent = new Map();\n  lines = [];\n  lastCol0 = 0;\n  hasMappings = false;\n  constructor(file = null) {\n    this.file = file;\n  }\n  addSource(url, content = null) {\n    if (!this.sourcesContent.has(url)) {\n      this.sourcesContent.set(url, content);\n    }\n    return this;\n  }\n  addLine() {\n    this.lines.push([]);\n    this.lastCol0 = 0;\n    return this;\n  }\n  addMapping(col0, sourceUrl, sourceLine0, sourceCol0) {\n    if (!this.currentLine) {\n      throw new Error(`A line must be added before mappings can be added`);\n    }\n    if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n      throw new Error(`Unknown source file \"${sourceUrl}\"`);\n    }\n    if (col0 == null) {\n      throw new Error(`The column in the generated code must be provided`);\n    }\n    if (col0 < this.lastCol0) {\n      throw new Error(`Mapping should be added in output order`);\n    }\n    if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n      throw new Error(`The source location must be provided when a source url is provided`);\n    }\n    this.hasMappings = true;\n    this.lastCol0 = col0;\n    this.currentLine.push({\n      col0,\n      sourceUrl,\n      sourceLine0,\n      sourceCol0\n    });\n    return this;\n  }\n  get currentLine() {\n    return this.lines.slice(-1)[0];\n  }\n  toJSON() {\n    if (!this.hasMappings) {\n      return null;\n    }\n    const sourcesIndex = new Map();\n    const sources = [];\n    const sourcesContent = [];\n    Array.from(this.sourcesContent.keys()).forEach((url, i) => {\n      sourcesIndex.set(url, i);\n      sources.push(url);\n      sourcesContent.push(this.sourcesContent.get(url) || null);\n    });\n    let mappings = '';\n    let lastCol0 = 0;\n    let lastSourceIndex = 0;\n    let lastSourceLine0 = 0;\n    let lastSourceCol0 = 0;\n    this.lines.forEach(segments => {\n      lastCol0 = 0;\n      mappings += segments.map(segment => {\n        let segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n        lastCol0 = segment.col0;\n        if (segment.sourceUrl != null) {\n          segAsStr += toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);\n          lastSourceIndex = sourcesIndex.get(segment.sourceUrl);\n          segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);\n          lastSourceLine0 = segment.sourceLine0;\n          segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);\n          lastSourceCol0 = segment.sourceCol0;\n        }\n        return segAsStr;\n      }).join(',');\n      mappings += ';';\n    });\n    mappings = mappings.slice(0, -1);\n    return {\n      'file': this.file || '',\n      'version': VERSION$1,\n      'sourceRoot': '',\n      'sources': sources,\n      'sourcesContent': sourcesContent,\n      'mappings': mappings\n    };\n  }\n  toJsComment() {\n    return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) : '';\n  }\n}\nfunction toBase64String(value) {\n  let b64 = '';\n  const encoded = utf8Encode(value);\n  for (let i = 0; i < encoded.length;) {\n    const i1 = encoded[i++];\n    const i2 = i < encoded.length ? encoded[i++] : null;\n    const i3 = i < encoded.length ? encoded[i++] : null;\n    b64 += toBase64Digit(i1 >> 2);\n    b64 += toBase64Digit((i1 & 3) << 4 | (i2 === null ? 0 : i2 >> 4));\n    b64 += i2 === null ? '=' : toBase64Digit((i2 & 15) << 2 | (i3 === null ? 0 : i3 >> 6));\n    b64 += i2 === null || i3 === null ? '=' : toBase64Digit(i3 & 63);\n  }\n  return b64;\n}\nfunction toBase64VLQ(value) {\n  value = value < 0 ? (-value << 1) + 1 : value << 1;\n  let out = '';\n  do {\n    let digit = value & 31;\n    value = value >> 5;\n    if (value > 0) {\n      digit = digit | 32;\n    }\n    out += toBase64Digit(digit);\n  } while (value > 0);\n  return out;\n}\nconst B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfunction toBase64Digit(value) {\n  if (value < 0 || value >= 64) {\n    throw new Error(`Can only encode value in the range [0, 63]`);\n  }\n  return B64_DIGITS[value];\n}\n\nconst _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nconst _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nconst _INDENT_WITH = '  ';\nclass _EmittedLine {\n  indent;\n  partsLength = 0;\n  parts = [];\n  srcSpans = [];\n  constructor(indent) {\n    this.indent = indent;\n  }\n}\nconst BINARY_OPERATORS$1 = new Map([[BinaryOperator.And, '&&'], [BinaryOperator.Bigger, '>'], [BinaryOperator.BiggerEquals, '>='], [BinaryOperator.BitwiseOr, '|'], [BinaryOperator.BitwiseAnd, '&'], [BinaryOperator.Divide, '/'], [BinaryOperator.Assign, '='], [BinaryOperator.Equals, '=='], [BinaryOperator.Identical, '==='], [BinaryOperator.Lower, '<'], [BinaryOperator.LowerEquals, '<='], [BinaryOperator.Minus, '-'], [BinaryOperator.Modulo, '%'], [BinaryOperator.Exponentiation, '**'], [BinaryOperator.Multiply, '*'], [BinaryOperator.NotEquals, '!='], [BinaryOperator.NotIdentical, '!=='], [BinaryOperator.NullishCoalesce, '??'], [BinaryOperator.Or, '||'], [BinaryOperator.Plus, '+'], [BinaryOperator.In, 'in'], [BinaryOperator.AdditionAssignment, '+='], [BinaryOperator.SubtractionAssignment, '-='], [BinaryOperator.MultiplicationAssignment, '*='], [BinaryOperator.DivisionAssignment, '/='], [BinaryOperator.RemainderAssignment, '%='], [BinaryOperator.ExponentiationAssignment, '**='], [BinaryOperator.AndAssignment, '&&='], [BinaryOperator.OrAssignment, '||='], [BinaryOperator.NullishCoalesceAssignment, '??=']]);\nclass EmitterVisitorContext {\n  _indent;\n  static createRoot() {\n    return new EmitterVisitorContext(0);\n  }\n  _lines;\n  constructor(_indent) {\n    this._indent = _indent;\n    this._lines = [new _EmittedLine(_indent)];\n  }\n  get _currentLine() {\n    return this._lines[this._lines.length - 1];\n  }\n  println(from, lastPart = '') {\n    this.print(from || null, lastPart, true);\n  }\n  lineIsEmpty() {\n    return this._currentLine.parts.length === 0;\n  }\n  lineLength() {\n    return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n  }\n  print(from, part, newLine = false) {\n    if (part.length > 0) {\n      this._currentLine.parts.push(part);\n      this._currentLine.partsLength += part.length;\n      this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n    }\n    if (newLine) {\n      this._lines.push(new _EmittedLine(this._indent));\n    }\n  }\n  removeEmptyLastLine() {\n    if (this.lineIsEmpty()) {\n      this._lines.pop();\n    }\n  }\n  incIndent() {\n    this._indent++;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n  decIndent() {\n    this._indent--;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n  toSource() {\n    return this.sourceLines.map(l => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '').join('\\n');\n  }\n  toSourceMapGenerator(genFilePath, startsAtLine = 0) {\n    const map = new SourceMapGenerator(genFilePath);\n    let firstOffsetMapped = false;\n    const mapFirstOffsetIfNeeded = () => {\n      if (!firstOffsetMapped) {\n        map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\n        firstOffsetMapped = true;\n      }\n    };\n    for (let i = 0; i < startsAtLine; i++) {\n      map.addLine();\n      mapFirstOffsetIfNeeded();\n    }\n    this.sourceLines.forEach((line, lineIdx) => {\n      map.addLine();\n      const spans = line.srcSpans;\n      const parts = line.parts;\n      let col0 = line.indent * _INDENT_WITH.length;\n      let spanIdx = 0;\n      while (spanIdx < spans.length && !spans[spanIdx]) {\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n      }\n      if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n        firstOffsetMapped = true;\n      } else {\n        mapFirstOffsetIfNeeded();\n      }\n      while (spanIdx < spans.length) {\n        const span = spans[spanIdx];\n        const source = span.start.file;\n        const sourceLine = span.start.line;\n        const sourceCol = span.start.col;\n        map.addSource(source.url, source.content).addMapping(col0, source.url, sourceLine, sourceCol);\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n        while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n          col0 += parts[spanIdx].length;\n          spanIdx++;\n        }\n      }\n    });\n    return map;\n  }\n  spanOf(line, column) {\n    const emittedLine = this._lines[line];\n    if (emittedLine) {\n      let columnsLeft = column - _createIndent(emittedLine.indent).length;\n      for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n        const part = emittedLine.parts[partIndex];\n        if (part.length > columnsLeft) {\n          return emittedLine.srcSpans[partIndex];\n        }\n        columnsLeft -= part.length;\n      }\n    }\n    return null;\n  }\n  get sourceLines() {\n    if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n      return this._lines.slice(0, -1);\n    }\n    return this._lines;\n  }\n}\nclass AbstractEmitterVisitor {\n  _escapeDollarInStrings;\n  lastIfCondition = null;\n  constructor(_escapeDollarInStrings) {\n    this._escapeDollarInStrings = _escapeDollarInStrings;\n  }\n  printLeadingComments(stmt, ctx) {\n    if (stmt.leadingComments === undefined) {\n      return;\n    }\n    for (const comment of stmt.leadingComments) {\n      if (comment instanceof JSDocComment) {\n        ctx.print(stmt, `/*${comment.toString()}*/`, comment.trailingNewline);\n      } else {\n        if (comment.multiline) {\n          ctx.print(stmt, `/* ${comment.text} */`, comment.trailingNewline);\n        } else {\n          comment.text.split('\\n').forEach(line => {\n            ctx.println(stmt, `// ${line}`);\n          });\n        }\n      }\n    }\n  }\n  visitExpressionStmt(stmt, ctx) {\n    this.printLeadingComments(stmt, ctx);\n    stmt.expr.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n  visitReturnStmt(stmt, ctx) {\n    this.printLeadingComments(stmt, ctx);\n    ctx.print(stmt, `return `);\n    stmt.value.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n  visitIfStmt(stmt, ctx) {\n    this.printLeadingComments(stmt, ctx);\n    ctx.print(stmt, `if (`);\n    this.lastIfCondition = stmt.condition;\n    stmt.condition.visitExpression(this, ctx);\n    this.lastIfCondition = null;\n    ctx.print(stmt, `) {`);\n    const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n    if (stmt.trueCase.length <= 1 && !hasElseCase) {\n      ctx.print(stmt, ` `);\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.removeEmptyLastLine();\n      ctx.print(stmt, ` `);\n    } else {\n      ctx.println();\n      ctx.incIndent();\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.decIndent();\n      if (hasElseCase) {\n        ctx.println(stmt, `} else {`);\n        ctx.incIndent();\n        this.visitAllStatements(stmt.falseCase, ctx);\n        ctx.decIndent();\n      }\n    }\n    ctx.println(stmt, `}`);\n    return null;\n  }\n  visitInvokeFunctionExpr(expr, ctx) {\n    const shouldParenthesize = expr.fn instanceof ArrowFunctionExpr;\n    if (shouldParenthesize) {\n      ctx.print(expr.fn, '(');\n    }\n    expr.fn.visitExpression(this, ctx);\n    if (shouldParenthesize) {\n      ctx.print(expr.fn, ')');\n    }\n    ctx.print(expr, `(`);\n    this.visitAllExpressions(expr.args, ctx, ',');\n    ctx.print(expr, `)`);\n    return null;\n  }\n  visitTaggedTemplateLiteralExpr(expr, ctx) {\n    expr.tag.visitExpression(this, ctx);\n    expr.template.visitExpression(this, ctx);\n    return null;\n  }\n  visitTemplateLiteralExpr(expr, ctx) {\n    ctx.print(expr, '`');\n    for (let i = 0; i < expr.elements.length; i++) {\n      expr.elements[i].visitExpression(this, ctx);\n      const expression = i < expr.expressions.length ? expr.expressions[i] : null;\n      if (expression !== null) {\n        ctx.print(expression, '${');\n        expression.visitExpression(this, ctx);\n        ctx.print(expression, '}');\n      }\n    }\n    ctx.print(expr, '`');\n  }\n  visitTemplateLiteralElementExpr(expr, ctx) {\n    ctx.print(expr, expr.rawText);\n  }\n  visitWrappedNodeExpr(ast, ctx) {\n    throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');\n  }\n  visitTypeofExpr(expr, ctx) {\n    ctx.print(expr, 'typeof ');\n    expr.expr.visitExpression(this, ctx);\n  }\n  visitVoidExpr(expr, ctx) {\n    ctx.print(expr, 'void ');\n    expr.expr.visitExpression(this, ctx);\n  }\n  visitReadVarExpr(ast, ctx) {\n    ctx.print(ast, ast.name);\n    return null;\n  }\n  visitInstantiateExpr(ast, ctx) {\n    ctx.print(ast, `new `);\n    ast.classExpr.visitExpression(this, ctx);\n    ctx.print(ast, `(`);\n    this.visitAllExpressions(ast.args, ctx, ',');\n    ctx.print(ast, `)`);\n    return null;\n  }\n  visitLiteralExpr(ast, ctx) {\n    const value = ast.value;\n    if (typeof value === 'string') {\n      ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n    } else {\n      ctx.print(ast, `${value}`);\n    }\n    return null;\n  }\n  visitRegularExpressionLiteral(ast, ctx) {\n    ctx.print(ast, `/${ast.body}/${ast.flags || ''}`);\n    return null;\n  }\n  visitLocalizedString(ast, ctx) {\n    const head = ast.serializeI18nHead();\n    ctx.print(ast, '$localize `' + head.raw);\n    for (let i = 1; i < ast.messageParts.length; i++) {\n      ctx.print(ast, '${');\n      ast.expressions[i - 1].visitExpression(this, ctx);\n      ctx.print(ast, `}${ast.serializeI18nTemplatePart(i).raw}`);\n    }\n    ctx.print(ast, '`');\n    return null;\n  }\n  visitConditionalExpr(ast, ctx) {\n    ctx.print(ast, `(`);\n    ast.condition.visitExpression(this, ctx);\n    ctx.print(ast, '? ');\n    ast.trueCase.visitExpression(this, ctx);\n    ctx.print(ast, ': ');\n    ast.falseCase.visitExpression(this, ctx);\n    ctx.print(ast, `)`);\n    return null;\n  }\n  visitDynamicImportExpr(ast, ctx) {\n    ctx.print(ast, `import(${ast.url})`);\n  }\n  visitNotExpr(ast, ctx) {\n    ctx.print(ast, '!');\n    ast.condition.visitExpression(this, ctx);\n    return null;\n  }\n  visitUnaryOperatorExpr(ast, ctx) {\n    let opStr;\n    switch (ast.operator) {\n      case UnaryOperator.Plus:\n        opStr = '+';\n        break;\n      case UnaryOperator.Minus:\n        opStr = '-';\n        break;\n      default:\n        throw new Error(`Unknown operator ${ast.operator}`);\n    }\n    const parens = ast !== this.lastIfCondition;\n    if (parens) ctx.print(ast, `(`);\n    ctx.print(ast, opStr);\n    ast.expr.visitExpression(this, ctx);\n    if (parens) ctx.print(ast, `)`);\n    return null;\n  }\n  visitBinaryOperatorExpr(ast, ctx) {\n    const operator = BINARY_OPERATORS$1.get(ast.operator);\n    if (!operator) {\n      throw new Error(`Unknown operator ${ast.operator}`);\n    }\n    const parens = ast !== this.lastIfCondition;\n    if (parens) ctx.print(ast, `(`);\n    ast.lhs.visitExpression(this, ctx);\n    ctx.print(ast, ` ${operator} `);\n    ast.rhs.visitExpression(this, ctx);\n    if (parens) ctx.print(ast, `)`);\n    return null;\n  }\n  visitReadPropExpr(ast, ctx) {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `.`);\n    ctx.print(ast, ast.name);\n    return null;\n  }\n  visitReadKeyExpr(ast, ctx) {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `[`);\n    ast.index.visitExpression(this, ctx);\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralArrayExpr(ast, ctx) {\n    ctx.print(ast, `[`);\n    this.visitAllExpressions(ast.entries, ctx, ',');\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralMapExpr(ast, ctx) {\n    ctx.print(ast, `{`);\n    this.visitAllObjects(entry => {\n      ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);\n      entry.value.visitExpression(this, ctx);\n    }, ast.entries, ctx, ',');\n    ctx.print(ast, `}`);\n    return null;\n  }\n  visitCommaExpr(ast, ctx) {\n    ctx.print(ast, '(');\n    this.visitAllExpressions(ast.parts, ctx, ',');\n    ctx.print(ast, ')');\n    return null;\n  }\n  visitParenthesizedExpr(ast, ctx) {\n    ast.expr.visitExpression(this, ctx);\n  }\n  visitAllExpressions(expressions, ctx, separator) {\n    this.visitAllObjects(expr => expr.visitExpression(this, ctx), expressions, ctx, separator);\n  }\n  visitAllObjects(handler, expressions, ctx, separator) {\n    let incrementedIndent = false;\n    for (let i = 0; i < expressions.length; i++) {\n      if (i > 0) {\n        if (ctx.lineLength() > 80) {\n          ctx.print(null, separator, true);\n          if (!incrementedIndent) {\n            ctx.incIndent();\n            ctx.incIndent();\n            incrementedIndent = true;\n          }\n        } else {\n          ctx.print(null, separator, false);\n        }\n      }\n      handler(expressions[i]);\n    }\n    if (incrementedIndent) {\n      ctx.decIndent();\n      ctx.decIndent();\n    }\n  }\n  visitAllStatements(statements, ctx) {\n    statements.forEach(stmt => stmt.visitStatement(this, ctx));\n  }\n}\nfunction escapeIdentifier(input, escapeDollar, alwaysQuote = true) {\n  if (input == null) {\n    return null;\n  }\n  const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match) => {\n    if (match[0] == '$') {\n      return escapeDollar ? '\\\\$' : '$';\n    } else if (match[0] == '\\n') {\n      return '\\\\n';\n    } else if (match[0] == '\\r') {\n      return '\\\\r';\n    } else {\n      return `\\\\${match[0]}`;\n    }\n  });\n  const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n  return requiresQuotes ? `'${body}'` : body;\n}\nfunction _createIndent(count) {\n  let res = '';\n  for (let i = 0; i < count; i++) {\n    res += _INDENT_WITH;\n  }\n  return res;\n}\n\nfunction typeWithParameters(type, numParams) {\n  if (numParams === 0) {\n    return expressionType(type);\n  }\n  const params = [];\n  for (let i = 0; i < numParams; i++) {\n    params.push(DYNAMIC_TYPE);\n  }\n  return expressionType(type, undefined, params);\n}\nfunction getSafePropertyAccessString(accessor, name) {\n  const escapedName = escapeIdentifier(name, false, false);\n  return escapedName !== name ? `${accessor}[${escapedName}]` : `${accessor}.${name}`;\n}\nfunction jitOnlyGuardedExpression(expr) {\n  return guardedExpression('ngJitMode', expr);\n}\nfunction devOnlyGuardedExpression(expr) {\n  return guardedExpression('ngDevMode', expr);\n}\nfunction guardedExpression(guard, expr) {\n  const guardExpr = new ExternalExpr({\n    name: guard,\n    moduleName: null\n  });\n  const guardNotDefined = new BinaryOperatorExpr(BinaryOperator.Identical, new TypeofExpr(guardExpr), literal('undefined'));\n  const guardUndefinedOrTrue = new BinaryOperatorExpr(BinaryOperator.Or, guardNotDefined, guardExpr, undefined, undefined);\n  return new BinaryOperatorExpr(BinaryOperator.And, guardUndefinedOrTrue, expr);\n}\nfunction wrapReference(value) {\n  const wrapped = new WrappedNodeExpr(value);\n  return {\n    value: wrapped,\n    type: wrapped\n  };\n}\nfunction refsToArray(refs, shouldForwardDeclare) {\n  const values = literalArr(refs.map(ref => ref.value));\n  return shouldForwardDeclare ? arrowFn([], values) : values;\n}\nfunction createMayBeForwardRefExpression(expression, forwardRef) {\n  return {\n    expression,\n    forwardRef\n  };\n}\nfunction convertFromMaybeForwardRefExpression({\n  expression,\n  forwardRef\n}) {\n  switch (forwardRef) {\n    case 0:\n    case 1:\n      return expression;\n    case 2:\n      return generateForwardRef(expression);\n  }\n}\nfunction generateForwardRef(expr) {\n  return importExpr(Identifiers.forwardRef).callFn([arrowFn([], expr)]);\n}\n\nvar R3FactoryDelegateType;\n(function (R3FactoryDelegateType) {\n  R3FactoryDelegateType[R3FactoryDelegateType[\"Class\"] = 0] = \"Class\";\n  R3FactoryDelegateType[R3FactoryDelegateType[\"Function\"] = 1] = \"Function\";\n})(R3FactoryDelegateType || (R3FactoryDelegateType = {}));\nfunction compileFactoryFunction(meta) {\n  const t = variable('__ngFactoryType__');\n  let baseFactoryVar = null;\n  const typeForCtor = !isDelegatedFactoryMetadata(meta) ? new BinaryOperatorExpr(BinaryOperator.Or, t, meta.type.value) : t;\n  let ctorExpr = null;\n  if (meta.deps !== null) {\n    if (meta.deps !== 'invalid') {\n      ctorExpr = new InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.target));\n    }\n  } else {\n    baseFactoryVar = variable(`Éµ${meta.name}_BaseFactory`);\n    ctorExpr = baseFactoryVar.callFn([typeForCtor]);\n  }\n  const body = [];\n  let retExpr = null;\n  function makeConditionalFactory(nonCtorExpr) {\n    const r = variable('__ngConditionalFactory__');\n    body.push(new DeclareVarStmt(r.name, NULL_EXPR, INFERRED_TYPE));\n    const ctorStmt = ctorExpr !== null ? r.set(ctorExpr).toStmt() : importExpr(Identifiers.invalidFactory).callFn([]).toStmt();\n    body.push(ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));\n    return r;\n  }\n  if (isDelegatedFactoryMetadata(meta)) {\n    const delegateArgs = injectDependencies(meta.delegateDeps, meta.target);\n    const factoryExpr = new (meta.delegateType === R3FactoryDelegateType.Class ? InstantiateExpr : InvokeFunctionExpr)(meta.delegate, delegateArgs);\n    retExpr = makeConditionalFactory(factoryExpr);\n  } else if (isExpressionFactoryMetadata(meta)) {\n    retExpr = makeConditionalFactory(meta.expression);\n  } else {\n    retExpr = ctorExpr;\n  }\n  if (retExpr === null) {\n    body.push(importExpr(Identifiers.invalidFactory).callFn([]).toStmt());\n  } else if (baseFactoryVar !== null) {\n    const getInheritedFactoryCall = importExpr(Identifiers.getInheritedFactory).callFn([meta.type.value]);\n    const baseFactory = new BinaryOperatorExpr(BinaryOperator.Or, baseFactoryVar, baseFactoryVar.set(getInheritedFactoryCall));\n    body.push(new ReturnStatement(baseFactory.callFn([typeForCtor])));\n  } else {\n    body.push(new ReturnStatement(retExpr));\n  }\n  let factoryFn = fn([new FnParam(t.name, DYNAMIC_TYPE)], body, INFERRED_TYPE, undefined, `${meta.name}_Factory`);\n  if (baseFactoryVar !== null) {\n    factoryFn = arrowFn([], [new DeclareVarStmt(baseFactoryVar.name), new ReturnStatement(factoryFn)]).callFn([], undefined, true);\n  }\n  return {\n    expression: factoryFn,\n    statements: [],\n    type: createFactoryType(meta)\n  };\n}\nfunction createFactoryType(meta) {\n  const ctorDepsType = meta.deps !== null && meta.deps !== 'invalid' ? createCtorDepsType(meta.deps) : NONE_TYPE;\n  return expressionType(importExpr(Identifiers.FactoryDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount), ctorDepsType]));\n}\nfunction injectDependencies(deps, target) {\n  return deps.map((dep, index) => compileInjectDependency(dep, target, index));\n}\nfunction compileInjectDependency(dep, target, index) {\n  if (dep.token === null) {\n    return importExpr(Identifiers.invalidFactoryDep).callFn([literal(index)]);\n  } else if (dep.attributeNameType === null) {\n    const flags = 0 | (dep.self ? 2 : 0) | (dep.skipSelf ? 4 : 0) | (dep.host ? 1 : 0) | (dep.optional ? 8 : 0) | (target === FactoryTarget.Pipe ? 16 : 0);\n    let flagsParam = flags !== 0 || dep.optional ? literal(flags) : null;\n    const injectArgs = [dep.token];\n    if (flagsParam) {\n      injectArgs.push(flagsParam);\n    }\n    const injectFn = getInjectFn(target);\n    return importExpr(injectFn).callFn(injectArgs);\n  } else {\n    return importExpr(Identifiers.injectAttribute).callFn([dep.token]);\n  }\n}\nfunction createCtorDepsType(deps) {\n  let hasTypes = false;\n  const attributeTypes = deps.map(dep => {\n    const type = createCtorDepType(dep);\n    if (type !== null) {\n      hasTypes = true;\n      return type;\n    } else {\n      return literal(null);\n    }\n  });\n  if (hasTypes) {\n    return expressionType(literalArr(attributeTypes));\n  } else {\n    return NONE_TYPE;\n  }\n}\nfunction createCtorDepType(dep) {\n  const entries = [];\n  if (dep.attributeNameType !== null) {\n    entries.push({\n      key: 'attribute',\n      value: dep.attributeNameType,\n      quoted: false\n    });\n  }\n  if (dep.optional) {\n    entries.push({\n      key: 'optional',\n      value: literal(true),\n      quoted: false\n    });\n  }\n  if (dep.host) {\n    entries.push({\n      key: 'host',\n      value: literal(true),\n      quoted: false\n    });\n  }\n  if (dep.self) {\n    entries.push({\n      key: 'self',\n      value: literal(true),\n      quoted: false\n    });\n  }\n  if (dep.skipSelf) {\n    entries.push({\n      key: 'skipSelf',\n      value: literal(true),\n      quoted: false\n    });\n  }\n  return entries.length > 0 ? literalMap(entries) : null;\n}\nfunction isDelegatedFactoryMetadata(meta) {\n  return meta.delegateType !== undefined;\n}\nfunction isExpressionFactoryMetadata(meta) {\n  return meta.expression !== undefined;\n}\nfunction getInjectFn(target) {\n  switch (target) {\n    case FactoryTarget.Component:\n    case FactoryTarget.Directive:\n    case FactoryTarget.Pipe:\n      return Identifiers.directiveInject;\n    case FactoryTarget.NgModule:\n    case FactoryTarget.Injectable:\n    default:\n      return Identifiers.inject;\n  }\n}\n\nclass ParseSpan {\n  start;\n  end;\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n  toAbsolute(absoluteOffset) {\n    return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);\n  }\n}\nclass AST {\n  span;\n  sourceSpan;\n  constructor(span, sourceSpan) {\n    this.span = span;\n    this.sourceSpan = sourceSpan;\n  }\n  toString() {\n    return 'AST';\n  }\n}\nclass ASTWithName extends AST {\n  nameSpan;\n  constructor(span, sourceSpan, nameSpan) {\n    super(span, sourceSpan);\n    this.nameSpan = nameSpan;\n  }\n}\nlet EmptyExpr$1 = class EmptyExpr extends AST {\n  visit(visitor, context = null) {}\n};\nclass ImplicitReceiver extends AST {\n  visit(visitor, context = null) {\n    return visitor.visitImplicitReceiver(this, context);\n  }\n}\nclass ThisReceiver extends ImplicitReceiver {\n  visit(visitor, context = null) {\n    return visitor.visitThisReceiver?.(this, context);\n  }\n}\nclass Chain extends AST {\n  expressions;\n  constructor(span, sourceSpan, expressions) {\n    super(span, sourceSpan);\n    this.expressions = expressions;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitChain(this, context);\n  }\n}\nclass Conditional extends AST {\n  condition;\n  trueExp;\n  falseExp;\n  constructor(span, sourceSpan, condition, trueExp, falseExp) {\n    super(span, sourceSpan);\n    this.condition = condition;\n    this.trueExp = trueExp;\n    this.falseExp = falseExp;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitConditional(this, context);\n  }\n}\nclass PropertyRead extends ASTWithName {\n  receiver;\n  name;\n  constructor(span, sourceSpan, nameSpan, receiver, name) {\n    super(span, sourceSpan, nameSpan);\n    this.receiver = receiver;\n    this.name = name;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitPropertyRead(this, context);\n  }\n}\nclass SafePropertyRead extends ASTWithName {\n  receiver;\n  name;\n  constructor(span, sourceSpan, nameSpan, receiver, name) {\n    super(span, sourceSpan, nameSpan);\n    this.receiver = receiver;\n    this.name = name;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitSafePropertyRead(this, context);\n  }\n}\nclass KeyedRead extends AST {\n  receiver;\n  key;\n  constructor(span, sourceSpan, receiver, key) {\n    super(span, sourceSpan);\n    this.receiver = receiver;\n    this.key = key;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitKeyedRead(this, context);\n  }\n}\nclass SafeKeyedRead extends AST {\n  receiver;\n  key;\n  constructor(span, sourceSpan, receiver, key) {\n    super(span, sourceSpan);\n    this.receiver = receiver;\n    this.key = key;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitSafeKeyedRead(this, context);\n  }\n}\nvar BindingPipeType;\n(function (BindingPipeType) {\n  BindingPipeType[BindingPipeType[\"ReferencedByName\"] = 0] = \"ReferencedByName\";\n  BindingPipeType[BindingPipeType[\"ReferencedDirectly\"] = 1] = \"ReferencedDirectly\";\n})(BindingPipeType || (BindingPipeType = {}));\nclass BindingPipe extends ASTWithName {\n  exp;\n  name;\n  args;\n  type;\n  constructor(span, sourceSpan, exp, name, args, type, nameSpan) {\n    super(span, sourceSpan, nameSpan);\n    this.exp = exp;\n    this.name = name;\n    this.args = args;\n    this.type = type;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitPipe(this, context);\n  }\n}\nclass LiteralPrimitive extends AST {\n  value;\n  constructor(span, sourceSpan, value) {\n    super(span, sourceSpan);\n    this.value = value;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitLiteralPrimitive(this, context);\n  }\n}\nclass LiteralArray extends AST {\n  expressions;\n  constructor(span, sourceSpan, expressions) {\n    super(span, sourceSpan);\n    this.expressions = expressions;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitLiteralArray(this, context);\n  }\n}\nclass LiteralMap extends AST {\n  keys;\n  values;\n  constructor(span, sourceSpan, keys, values) {\n    super(span, sourceSpan);\n    this.keys = keys;\n    this.values = values;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitLiteralMap(this, context);\n  }\n}\nlet Interpolation$1 = class Interpolation extends AST {\n  strings;\n  expressions;\n  constructor(span, sourceSpan, strings, expressions) {\n    super(span, sourceSpan);\n    this.strings = strings;\n    this.expressions = expressions;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitInterpolation(this, context);\n  }\n};\nclass Binary extends AST {\n  operation;\n  left;\n  right;\n  constructor(span, sourceSpan, operation, left, right) {\n    super(span, sourceSpan);\n    this.operation = operation;\n    this.left = left;\n    this.right = right;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitBinary(this, context);\n  }\n  static isAssignmentOperation(op) {\n    return op === '=' || op === '+=' || op === '-=' || op === '*=' || op === '/=' || op === '%=' || op === '**=' || op === '&&=' || op === '||=' || op === '??=';\n  }\n}\nclass Unary extends Binary {\n  operator;\n  expr;\n  left = null;\n  right = null;\n  operation = null;\n  static createMinus(span, sourceSpan, expr) {\n    return new Unary(span, sourceSpan, '-', expr, '-', new LiteralPrimitive(span, sourceSpan, 0), expr);\n  }\n  static createPlus(span, sourceSpan, expr) {\n    return new Unary(span, sourceSpan, '+', expr, '-', expr, new LiteralPrimitive(span, sourceSpan, 0));\n  }\n  constructor(span, sourceSpan, operator, expr, binaryOp, binaryLeft, binaryRight) {\n    super(span, sourceSpan, binaryOp, binaryLeft, binaryRight);\n    this.operator = operator;\n    this.expr = expr;\n  }\n  visit(visitor, context = null) {\n    if (visitor.visitUnary !== undefined) {\n      return visitor.visitUnary(this, context);\n    }\n    return visitor.visitBinary(this, context);\n  }\n}\nclass PrefixNot extends AST {\n  expression;\n  constructor(span, sourceSpan, expression) {\n    super(span, sourceSpan);\n    this.expression = expression;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitPrefixNot(this, context);\n  }\n}\nclass TypeofExpression extends AST {\n  expression;\n  constructor(span, sourceSpan, expression) {\n    super(span, sourceSpan);\n    this.expression = expression;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitTypeofExpression(this, context);\n  }\n}\nclass VoidExpression extends AST {\n  expression;\n  constructor(span, sourceSpan, expression) {\n    super(span, sourceSpan);\n    this.expression = expression;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitVoidExpression(this, context);\n  }\n}\nclass NonNullAssert extends AST {\n  expression;\n  constructor(span, sourceSpan, expression) {\n    super(span, sourceSpan);\n    this.expression = expression;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitNonNullAssert(this, context);\n  }\n}\nclass Call extends AST {\n  receiver;\n  args;\n  argumentSpan;\n  constructor(span, sourceSpan, receiver, args, argumentSpan) {\n    super(span, sourceSpan);\n    this.receiver = receiver;\n    this.args = args;\n    this.argumentSpan = argumentSpan;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitCall(this, context);\n  }\n}\nclass SafeCall extends AST {\n  receiver;\n  args;\n  argumentSpan;\n  constructor(span, sourceSpan, receiver, args, argumentSpan) {\n    super(span, sourceSpan);\n    this.receiver = receiver;\n    this.args = args;\n    this.argumentSpan = argumentSpan;\n  }\n  visit(visitor, context = null) {\n    return visitor.visitSafeCall(this, context);\n  }\n}\nclass TaggedTemplateLiteral extends AST {\n  tag;\n  template;\n  constructor(span, sourceSpan, tag, template) {\n    super(span, sourceSpan);\n    this.tag = tag;\n    this.template = template;\n  }\n  visit(visitor, context) {\n    return visitor.visitTaggedTemplateLiteral(this, context);\n  }\n}\nclass TemplateLiteral extends AST {\n  elements;\n  expressions;\n  constructor(span, sourceSpan, elements, expressions) {\n    super(span, sourceSpan);\n    this.elements = elements;\n    this.expressions = expressions;\n  }\n  visit(visitor, context) {\n    return visitor.visitTemplateLiteral(this, context);\n  }\n}\nclass TemplateLiteralElement extends AST {\n  text;\n  constructor(span, sourceSpan, text) {\n    super(span, sourceSpan);\n    this.text = text;\n  }\n  visit(visitor, context) {\n    return visitor.visitTemplateLiteralElement(this, context);\n  }\n}\nclass ParenthesizedExpression extends AST {\n  expression;\n  constructor(span, sourceSpan, expression) {\n    super(span, sourceSpan);\n    this.expression = expression;\n  }\n  visit(visitor, context) {\n    return visitor.visitParenthesizedExpression(this, context);\n  }\n}\nclass RegularExpressionLiteral extends AST {\n  body;\n  flags;\n  constructor(span, sourceSpan, body, flags) {\n    super(span, sourceSpan);\n    this.body = body;\n    this.flags = flags;\n  }\n  visit(visitor, context) {\n    return visitor.visitRegularExpressionLiteral(this, context);\n  }\n}\nclass AbsoluteSourceSpan {\n  start;\n  end;\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n}\nclass ASTWithSource extends AST {\n  ast;\n  source;\n  location;\n  errors;\n  constructor(ast, source, location, absoluteOffset, errors) {\n    super(new ParseSpan(0, source === null ? 0 : source.length), new AbsoluteSourceSpan(absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length));\n    this.ast = ast;\n    this.source = source;\n    this.location = location;\n    this.errors = errors;\n  }\n  visit(visitor, context = null) {\n    if (visitor.visitASTWithSource) {\n      return visitor.visitASTWithSource(this, context);\n    }\n    return this.ast.visit(visitor, context);\n  }\n  toString() {\n    return `${this.source} in ${this.location}`;\n  }\n}\nclass VariableBinding {\n  sourceSpan;\n  key;\n  value;\n  constructor(sourceSpan, key, value) {\n    this.sourceSpan = sourceSpan;\n    this.key = key;\n    this.value = value;\n  }\n}\nclass ExpressionBinding {\n  sourceSpan;\n  key;\n  value;\n  constructor(sourceSpan, key, value) {\n    this.sourceSpan = sourceSpan;\n    this.key = key;\n    this.value = value;\n  }\n}\nclass RecursiveAstVisitor {\n  visit(ast, context) {\n    ast.visit(this, context);\n  }\n  visitUnary(ast, context) {\n    this.visit(ast.expr, context);\n  }\n  visitBinary(ast, context) {\n    this.visit(ast.left, context);\n    this.visit(ast.right, context);\n  }\n  visitChain(ast, context) {\n    this.visitAll(ast.expressions, context);\n  }\n  visitConditional(ast, context) {\n    this.visit(ast.condition, context);\n    this.visit(ast.trueExp, context);\n    this.visit(ast.falseExp, context);\n  }\n  visitPipe(ast, context) {\n    this.visit(ast.exp, context);\n    this.visitAll(ast.args, context);\n  }\n  visitImplicitReceiver(ast, context) {}\n  visitThisReceiver(ast, context) {}\n  visitInterpolation(ast, context) {\n    this.visitAll(ast.expressions, context);\n  }\n  visitKeyedRead(ast, context) {\n    this.visit(ast.receiver, context);\n    this.visit(ast.key, context);\n  }\n  visitLiteralArray(ast, context) {\n    this.visitAll(ast.expressions, context);\n  }\n  visitLiteralMap(ast, context) {\n    this.visitAll(ast.values, context);\n  }\n  visitLiteralPrimitive(ast, context) {}\n  visitPrefixNot(ast, context) {\n    this.visit(ast.expression, context);\n  }\n  visitTypeofExpression(ast, context) {\n    this.visit(ast.expression, context);\n  }\n  visitVoidExpression(ast, context) {\n    this.visit(ast.expression, context);\n  }\n  visitNonNullAssert(ast, context) {\n    this.visit(ast.expression, context);\n  }\n  visitPropertyRead(ast, context) {\n    this.visit(ast.receiver, context);\n  }\n  visitSafePropertyRead(ast, context) {\n    this.visit(ast.receiver, context);\n  }\n  visitSafeKeyedRead(ast, context) {\n    this.visit(ast.receiver, context);\n    this.visit(ast.key, context);\n  }\n  visitCall(ast, context) {\n    this.visit(ast.receiver, context);\n    this.visitAll(ast.args, context);\n  }\n  visitSafeCall(ast, context) {\n    this.visit(ast.receiver, context);\n    this.visitAll(ast.args, context);\n  }\n  visitTemplateLiteral(ast, context) {\n    for (let i = 0; i < ast.elements.length; i++) {\n      this.visit(ast.elements[i], context);\n      const expression = i < ast.expressions.length ? ast.expressions[i] : null;\n      if (expression !== null) {\n        this.visit(expression, context);\n      }\n    }\n  }\n  visitTemplateLiteralElement(ast, context) {}\n  visitTaggedTemplateLiteral(ast, context) {\n    this.visit(ast.tag, context);\n    this.visit(ast.template, context);\n  }\n  visitParenthesizedExpression(ast, context) {\n    this.visit(ast.expression, context);\n  }\n  visitRegularExpressionLiteral(ast, context) {}\n  visitAll(asts, context) {\n    for (const ast of asts) {\n      this.visit(ast, context);\n    }\n  }\n}\nclass ParsedProperty {\n  name;\n  expression;\n  type;\n  sourceSpan;\n  keySpan;\n  valueSpan;\n  isLiteral;\n  isLegacyAnimation;\n  isAnimation;\n  constructor(name, expression, type, sourceSpan, keySpan, valueSpan) {\n    this.name = name;\n    this.expression = expression;\n    this.type = type;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n    this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;\n    this.isLegacyAnimation = this.type === ParsedPropertyType.LEGACY_ANIMATION;\n    this.isAnimation = this.type === ParsedPropertyType.ANIMATION;\n  }\n}\nvar ParsedPropertyType;\n(function (ParsedPropertyType) {\n  ParsedPropertyType[ParsedPropertyType[\"DEFAULT\"] = 0] = \"DEFAULT\";\n  ParsedPropertyType[ParsedPropertyType[\"LITERAL_ATTR\"] = 1] = \"LITERAL_ATTR\";\n  ParsedPropertyType[ParsedPropertyType[\"LEGACY_ANIMATION\"] = 2] = \"LEGACY_ANIMATION\";\n  ParsedPropertyType[ParsedPropertyType[\"TWO_WAY\"] = 3] = \"TWO_WAY\";\n  ParsedPropertyType[ParsedPropertyType[\"ANIMATION\"] = 4] = \"ANIMATION\";\n})(ParsedPropertyType || (ParsedPropertyType = {}));\nvar ParsedEventType;\n(function (ParsedEventType) {\n  ParsedEventType[ParsedEventType[\"Regular\"] = 0] = \"Regular\";\n  ParsedEventType[ParsedEventType[\"LegacyAnimation\"] = 1] = \"LegacyAnimation\";\n  ParsedEventType[ParsedEventType[\"TwoWay\"] = 2] = \"TwoWay\";\n  ParsedEventType[ParsedEventType[\"Animation\"] = 3] = \"Animation\";\n})(ParsedEventType || (ParsedEventType = {}));\nclass ParsedEvent {\n  name;\n  targetOrPhase;\n  type;\n  handler;\n  sourceSpan;\n  handlerSpan;\n  keySpan;\n  constructor(name, targetOrPhase, type, handler, sourceSpan, handlerSpan, keySpan) {\n    this.name = name;\n    this.targetOrPhase = targetOrPhase;\n    this.type = type;\n    this.handler = handler;\n    this.sourceSpan = sourceSpan;\n    this.handlerSpan = handlerSpan;\n    this.keySpan = keySpan;\n  }\n}\nclass ParsedVariable {\n  name;\n  value;\n  sourceSpan;\n  keySpan;\n  valueSpan;\n  constructor(name, value, sourceSpan, keySpan, valueSpan) {\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n  }\n}\nvar BindingType;\n(function (BindingType) {\n  BindingType[BindingType[\"Property\"] = 0] = \"Property\";\n  BindingType[BindingType[\"Attribute\"] = 1] = \"Attribute\";\n  BindingType[BindingType[\"Class\"] = 2] = \"Class\";\n  BindingType[BindingType[\"Style\"] = 3] = \"Style\";\n  BindingType[BindingType[\"LegacyAnimation\"] = 4] = \"LegacyAnimation\";\n  BindingType[BindingType[\"TwoWay\"] = 5] = \"TwoWay\";\n  BindingType[BindingType[\"Animation\"] = 6] = \"Animation\";\n})(BindingType || (BindingType = {}));\nclass BoundElementProperty {\n  name;\n  type;\n  securityContext;\n  value;\n  unit;\n  sourceSpan;\n  keySpan;\n  valueSpan;\n  constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan) {\n    this.name = name;\n    this.type = type;\n    this.securityContext = securityContext;\n    this.value = value;\n    this.unit = unit;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n  }\n}\n\nvar TagContentType;\n(function (TagContentType) {\n  TagContentType[TagContentType[\"RAW_TEXT\"] = 0] = \"RAW_TEXT\";\n  TagContentType[TagContentType[\"ESCAPABLE_RAW_TEXT\"] = 1] = \"ESCAPABLE_RAW_TEXT\";\n  TagContentType[TagContentType[\"PARSABLE_DATA\"] = 2] = \"PARSABLE_DATA\";\n})(TagContentType || (TagContentType = {}));\nfunction splitNsName(elementName, fatal = true) {\n  if (elementName[0] != ':') {\n    return [null, elementName];\n  }\n  const colonIndex = elementName.indexOf(':', 1);\n  if (colonIndex === -1) {\n    if (fatal) {\n      throw new Error(`Unsupported format \"${elementName}\" expecting \":namespace:name\"`);\n    } else {\n      return [null, elementName];\n    }\n  }\n  return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n}\nfunction isNgContainer(tagName) {\n  return splitNsName(tagName)[1] === 'ng-container';\n}\nfunction isNgContent(tagName) {\n  return splitNsName(tagName)[1] === 'ng-content';\n}\nfunction isNgTemplate(tagName) {\n  return splitNsName(tagName)[1] === 'ng-template';\n}\nfunction getNsPrefix(fullName) {\n  return fullName === null ? null : splitNsName(fullName)[0];\n}\nfunction mergeNsAndName(prefix, localName) {\n  return prefix ? `:${prefix}:${localName}` : localName;\n}\n\nlet Comment$1 = class Comment {\n  value;\n  sourceSpan;\n  constructor(value, sourceSpan) {\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(_visitor) {\n    throw new Error('visit() not implemented for Comment');\n  }\n};\nlet Text$3 = class Text {\n  value;\n  sourceSpan;\n  constructor(value, sourceSpan) {\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(visitor) {\n    return visitor.visitText(this);\n  }\n};\nclass BoundText {\n  value;\n  sourceSpan;\n  i18n;\n  constructor(value, sourceSpan, i18n) {\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitBoundText(this);\n  }\n}\nclass TextAttribute {\n  name;\n  value;\n  sourceSpan;\n  keySpan;\n  valueSpan;\n  i18n;\n  constructor(name, value, sourceSpan, keySpan, valueSpan, i18n) {\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitTextAttribute(this);\n  }\n}\nclass BoundAttribute {\n  name;\n  type;\n  securityContext;\n  value;\n  unit;\n  sourceSpan;\n  keySpan;\n  valueSpan;\n  i18n;\n  constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan, i18n) {\n    this.name = name;\n    this.type = type;\n    this.securityContext = securityContext;\n    this.value = value;\n    this.unit = unit;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n    this.i18n = i18n;\n  }\n  static fromBoundElementProperty(prop, i18n) {\n    if (prop.keySpan === undefined) {\n      throw new Error(`Unexpected state: keySpan must be defined for bound attributes but was not for ${prop.name}: ${prop.sourceSpan}`);\n    }\n    return new BoundAttribute(prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n);\n  }\n  visit(visitor) {\n    return visitor.visitBoundAttribute(this);\n  }\n}\nclass BoundEvent {\n  name;\n  type;\n  handler;\n  target;\n  phase;\n  sourceSpan;\n  handlerSpan;\n  keySpan;\n  constructor(name, type, handler, target, phase, sourceSpan, handlerSpan, keySpan) {\n    this.name = name;\n    this.type = type;\n    this.handler = handler;\n    this.target = target;\n    this.phase = phase;\n    this.sourceSpan = sourceSpan;\n    this.handlerSpan = handlerSpan;\n    this.keySpan = keySpan;\n  }\n  static fromParsedEvent(event) {\n    const target = event.type === ParsedEventType.Regular ? event.targetOrPhase : null;\n    const phase = event.type === ParsedEventType.LegacyAnimation ? event.targetOrPhase : null;\n    if (event.keySpan === undefined) {\n      throw new Error(`Unexpected state: keySpan must be defined for bound event but was not for ${event.name}: ${event.sourceSpan}`);\n    }\n    return new BoundEvent(event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan, event.keySpan);\n  }\n  visit(visitor) {\n    return visitor.visitBoundEvent(this);\n  }\n}\nlet Element$1 = class Element {\n  name;\n  attributes;\n  inputs;\n  outputs;\n  directives;\n  children;\n  references;\n  isSelfClosing;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  isVoid;\n  i18n;\n  constructor(name, attributes, inputs, outputs, directives, children, references, isSelfClosing, sourceSpan, startSourceSpan, endSourceSpan, isVoid, i18n) {\n    this.name = name;\n    this.attributes = attributes;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.directives = directives;\n    this.children = children;\n    this.references = references;\n    this.isSelfClosing = isSelfClosing;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n    this.isVoid = isVoid;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitElement(this);\n  }\n};\nclass DeferredTrigger {\n  nameSpan;\n  sourceSpan;\n  prefetchSpan;\n  whenOrOnSourceSpan;\n  hydrateSpan;\n  constructor(nameSpan, sourceSpan, prefetchSpan, whenOrOnSourceSpan, hydrateSpan) {\n    this.nameSpan = nameSpan;\n    this.sourceSpan = sourceSpan;\n    this.prefetchSpan = prefetchSpan;\n    this.whenOrOnSourceSpan = whenOrOnSourceSpan;\n    this.hydrateSpan = hydrateSpan;\n  }\n  visit(visitor) {\n    return visitor.visitDeferredTrigger(this);\n  }\n}\nclass BoundDeferredTrigger extends DeferredTrigger {\n  value;\n  constructor(value, sourceSpan, prefetchSpan, whenSourceSpan, hydrateSpan) {\n    super(null, sourceSpan, prefetchSpan, whenSourceSpan, hydrateSpan);\n    this.value = value;\n  }\n}\nclass NeverDeferredTrigger extends DeferredTrigger {}\nclass IdleDeferredTrigger extends DeferredTrigger {}\nclass ImmediateDeferredTrigger extends DeferredTrigger {}\nclass HoverDeferredTrigger extends DeferredTrigger {\n  reference;\n  constructor(reference, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan) {\n    super(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n    this.reference = reference;\n  }\n}\nclass TimerDeferredTrigger extends DeferredTrigger {\n  delay;\n  constructor(delay, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan) {\n    super(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n    this.delay = delay;\n  }\n}\nclass InteractionDeferredTrigger extends DeferredTrigger {\n  reference;\n  constructor(reference, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan) {\n    super(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n    this.reference = reference;\n  }\n}\nclass ViewportDeferredTrigger extends DeferredTrigger {\n  reference;\n  options;\n  constructor(reference, options, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan) {\n    super(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n    this.reference = reference;\n    this.options = options;\n  }\n}\nclass BlockNode {\n  nameSpan;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  constructor(nameSpan, sourceSpan, startSourceSpan, endSourceSpan) {\n    this.nameSpan = nameSpan;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n  }\n}\nclass DeferredBlockPlaceholder extends BlockNode {\n  children;\n  minimumTime;\n  i18n;\n  constructor(children, minimumTime, nameSpan, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.children = children;\n    this.minimumTime = minimumTime;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitDeferredBlockPlaceholder(this);\n  }\n}\nclass DeferredBlockLoading extends BlockNode {\n  children;\n  afterTime;\n  minimumTime;\n  i18n;\n  constructor(children, afterTime, minimumTime, nameSpan, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.children = children;\n    this.afterTime = afterTime;\n    this.minimumTime = minimumTime;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitDeferredBlockLoading(this);\n  }\n}\nclass DeferredBlockError extends BlockNode {\n  children;\n  i18n;\n  constructor(children, nameSpan, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.children = children;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitDeferredBlockError(this);\n  }\n}\nclass DeferredBlock extends BlockNode {\n  children;\n  placeholder;\n  loading;\n  error;\n  mainBlockSpan;\n  i18n;\n  triggers;\n  prefetchTriggers;\n  hydrateTriggers;\n  definedTriggers;\n  definedPrefetchTriggers;\n  definedHydrateTriggers;\n  constructor(children, triggers, prefetchTriggers, hydrateTriggers, placeholder, loading, error, nameSpan, sourceSpan, mainBlockSpan, startSourceSpan, endSourceSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.children = children;\n    this.placeholder = placeholder;\n    this.loading = loading;\n    this.error = error;\n    this.mainBlockSpan = mainBlockSpan;\n    this.i18n = i18n;\n    this.triggers = triggers;\n    this.prefetchTriggers = prefetchTriggers;\n    this.hydrateTriggers = hydrateTriggers;\n    this.definedTriggers = Object.keys(triggers);\n    this.definedPrefetchTriggers = Object.keys(prefetchTriggers);\n    this.definedHydrateTriggers = Object.keys(hydrateTriggers);\n  }\n  visit(visitor) {\n    return visitor.visitDeferredBlock(this);\n  }\n  visitAll(visitor) {\n    this.visitTriggers(this.definedHydrateTriggers, this.hydrateTriggers, visitor);\n    this.visitTriggers(this.definedTriggers, this.triggers, visitor);\n    this.visitTriggers(this.definedPrefetchTriggers, this.prefetchTriggers, visitor);\n    visitAll$1(visitor, this.children);\n    const remainingBlocks = [this.placeholder, this.loading, this.error].filter(x => x !== null);\n    visitAll$1(visitor, remainingBlocks);\n  }\n  visitTriggers(keys, triggers, visitor) {\n    visitAll$1(visitor, keys.map(k => triggers[k]));\n  }\n}\nclass SwitchBlock extends BlockNode {\n  expression;\n  cases;\n  unknownBlocks;\n  constructor(expression, cases, unknownBlocks, sourceSpan, startSourceSpan, endSourceSpan, nameSpan) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.expression = expression;\n    this.cases = cases;\n    this.unknownBlocks = unknownBlocks;\n  }\n  visit(visitor) {\n    return visitor.visitSwitchBlock(this);\n  }\n}\nclass SwitchBlockCase extends BlockNode {\n  expression;\n  children;\n  i18n;\n  constructor(expression, children, sourceSpan, startSourceSpan, endSourceSpan, nameSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.expression = expression;\n    this.children = children;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitSwitchBlockCase(this);\n  }\n}\nclass ForLoopBlock extends BlockNode {\n  item;\n  expression;\n  trackBy;\n  trackKeywordSpan;\n  contextVariables;\n  children;\n  empty;\n  mainBlockSpan;\n  i18n;\n  constructor(item, expression, trackBy, trackKeywordSpan, contextVariables, children, empty, sourceSpan, mainBlockSpan, startSourceSpan, endSourceSpan, nameSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.item = item;\n    this.expression = expression;\n    this.trackBy = trackBy;\n    this.trackKeywordSpan = trackKeywordSpan;\n    this.contextVariables = contextVariables;\n    this.children = children;\n    this.empty = empty;\n    this.mainBlockSpan = mainBlockSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitForLoopBlock(this);\n  }\n}\nclass ForLoopBlockEmpty extends BlockNode {\n  children;\n  i18n;\n  constructor(children, sourceSpan, startSourceSpan, endSourceSpan, nameSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.children = children;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitForLoopBlockEmpty(this);\n  }\n}\nclass IfBlock extends BlockNode {\n  branches;\n  constructor(branches, sourceSpan, startSourceSpan, endSourceSpan, nameSpan) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.branches = branches;\n  }\n  visit(visitor) {\n    return visitor.visitIfBlock(this);\n  }\n}\nclass IfBlockBranch extends BlockNode {\n  expression;\n  children;\n  expressionAlias;\n  i18n;\n  constructor(expression, children, expressionAlias, sourceSpan, startSourceSpan, endSourceSpan, nameSpan, i18n) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.expression = expression;\n    this.children = children;\n    this.expressionAlias = expressionAlias;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitIfBlockBranch(this);\n  }\n}\nclass UnknownBlock {\n  name;\n  sourceSpan;\n  nameSpan;\n  constructor(name, sourceSpan, nameSpan) {\n    this.name = name;\n    this.sourceSpan = sourceSpan;\n    this.nameSpan = nameSpan;\n  }\n  visit(visitor) {\n    return visitor.visitUnknownBlock(this);\n  }\n}\nlet LetDeclaration$1 = class LetDeclaration {\n  name;\n  value;\n  sourceSpan;\n  nameSpan;\n  valueSpan;\n  constructor(name, value, sourceSpan, nameSpan, valueSpan) {\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.nameSpan = nameSpan;\n    this.valueSpan = valueSpan;\n  }\n  visit(visitor) {\n    return visitor.visitLetDeclaration(this);\n  }\n};\nlet Component$1 = class Component {\n  componentName;\n  tagName;\n  fullName;\n  attributes;\n  inputs;\n  outputs;\n  directives;\n  children;\n  references;\n  isSelfClosing;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  i18n;\n  constructor(componentName, tagName, fullName, attributes, inputs, outputs, directives, children, references, isSelfClosing, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    this.componentName = componentName;\n    this.tagName = tagName;\n    this.fullName = fullName;\n    this.attributes = attributes;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.directives = directives;\n    this.children = children;\n    this.references = references;\n    this.isSelfClosing = isSelfClosing;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitComponent(this);\n  }\n};\nlet Directive$1 = class Directive {\n  name;\n  attributes;\n  inputs;\n  outputs;\n  references;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  i18n;\n  constructor(name, attributes, inputs, outputs, references, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    this.name = name;\n    this.attributes = attributes;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.references = references;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitDirective(this);\n  }\n};\nclass Template {\n  tagName;\n  attributes;\n  inputs;\n  outputs;\n  directives;\n  templateAttrs;\n  children;\n  references;\n  variables;\n  isSelfClosing;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  i18n;\n  constructor(tagName, attributes, inputs, outputs, directives, templateAttrs, children, references, variables, isSelfClosing, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    this.tagName = tagName;\n    this.attributes = attributes;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.directives = directives;\n    this.templateAttrs = templateAttrs;\n    this.children = children;\n    this.references = references;\n    this.variables = variables;\n    this.isSelfClosing = isSelfClosing;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitTemplate(this);\n  }\n}\nclass Content {\n  selector;\n  attributes;\n  children;\n  isSelfClosing;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  i18n;\n  name = 'ng-content';\n  constructor(selector, attributes, children, isSelfClosing, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    this.selector = selector;\n    this.attributes = attributes;\n    this.children = children;\n    this.isSelfClosing = isSelfClosing;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitContent(this);\n  }\n}\nclass Variable {\n  name;\n  value;\n  sourceSpan;\n  keySpan;\n  valueSpan;\n  constructor(name, value, sourceSpan, keySpan, valueSpan) {\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n  }\n  visit(visitor) {\n    return visitor.visitVariable(this);\n  }\n}\nclass Reference {\n  name;\n  value;\n  sourceSpan;\n  keySpan;\n  valueSpan;\n  constructor(name, value, sourceSpan, keySpan, valueSpan) {\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n  }\n  visit(visitor) {\n    return visitor.visitReference(this);\n  }\n}\nlet Icu$1 = class Icu {\n  vars;\n  placeholders;\n  sourceSpan;\n  i18n;\n  constructor(vars, placeholders, sourceSpan, i18n) {\n    this.vars = vars;\n    this.placeholders = placeholders;\n    this.sourceSpan = sourceSpan;\n    this.i18n = i18n;\n  }\n  visit(visitor) {\n    return visitor.visitIcu(this);\n  }\n};\nclass HostElement {\n  tagNames;\n  bindings;\n  listeners;\n  sourceSpan;\n  constructor(tagNames, bindings, listeners, sourceSpan) {\n    this.tagNames = tagNames;\n    this.bindings = bindings;\n    this.listeners = listeners;\n    this.sourceSpan = sourceSpan;\n    if (tagNames.length === 0) {\n      throw new Error('HostElement must have at least one tag name.');\n    }\n  }\n  visit() {\n    throw new Error(`HostElement cannot be visited`);\n  }\n}\nlet RecursiveVisitor$1 = class RecursiveVisitor {\n  visitElement(element) {\n    visitAll$1(this, element.attributes);\n    visitAll$1(this, element.inputs);\n    visitAll$1(this, element.outputs);\n    visitAll$1(this, element.directives);\n    visitAll$1(this, element.children);\n    visitAll$1(this, element.references);\n  }\n  visitTemplate(template) {\n    visitAll$1(this, template.attributes);\n    visitAll$1(this, template.inputs);\n    visitAll$1(this, template.outputs);\n    visitAll$1(this, template.directives);\n    visitAll$1(this, template.children);\n    visitAll$1(this, template.references);\n    visitAll$1(this, template.variables);\n  }\n  visitDeferredBlock(deferred) {\n    deferred.visitAll(this);\n  }\n  visitDeferredBlockPlaceholder(block) {\n    visitAll$1(this, block.children);\n  }\n  visitDeferredBlockError(block) {\n    visitAll$1(this, block.children);\n  }\n  visitDeferredBlockLoading(block) {\n    visitAll$1(this, block.children);\n  }\n  visitSwitchBlock(block) {\n    visitAll$1(this, block.cases);\n  }\n  visitSwitchBlockCase(block) {\n    visitAll$1(this, block.children);\n  }\n  visitForLoopBlock(block) {\n    const blockItems = [block.item, ...block.contextVariables, ...block.children];\n    block.empty && blockItems.push(block.empty);\n    visitAll$1(this, blockItems);\n  }\n  visitForLoopBlockEmpty(block) {\n    visitAll$1(this, block.children);\n  }\n  visitIfBlock(block) {\n    visitAll$1(this, block.branches);\n  }\n  visitIfBlockBranch(block) {\n    const blockItems = block.children;\n    block.expressionAlias && blockItems.push(block.expressionAlias);\n    visitAll$1(this, blockItems);\n  }\n  visitContent(content) {\n    visitAll$1(this, content.children);\n  }\n  visitComponent(component) {\n    visitAll$1(this, component.attributes);\n    visitAll$1(this, component.inputs);\n    visitAll$1(this, component.outputs);\n    visitAll$1(this, component.directives);\n    visitAll$1(this, component.children);\n    visitAll$1(this, component.references);\n  }\n  visitDirective(directive) {\n    visitAll$1(this, directive.attributes);\n    visitAll$1(this, directive.inputs);\n    visitAll$1(this, directive.outputs);\n    visitAll$1(this, directive.references);\n  }\n  visitVariable(variable) {}\n  visitReference(reference) {}\n  visitTextAttribute(attribute) {}\n  visitBoundAttribute(attribute) {}\n  visitBoundEvent(attribute) {}\n  visitText(text) {}\n  visitBoundText(text) {}\n  visitIcu(icu) {}\n  visitDeferredTrigger(trigger) {}\n  visitUnknownBlock(block) {}\n  visitLetDeclaration(decl) {}\n};\nfunction visitAll$1(visitor, nodes) {\n  const result = [];\n  if (visitor.visit) {\n    for (const node of nodes) {\n      visitor.visit(node);\n    }\n  } else {\n    for (const node of nodes) {\n      const newNode = node.visit(visitor);\n      if (newNode) {\n        result.push(newNode);\n      }\n    }\n  }\n  return result;\n}\n\nclass Message {\n  nodes;\n  placeholders;\n  placeholderToMessage;\n  meaning;\n  description;\n  customId;\n  sources;\n  id;\n  legacyIds = [];\n  messageString;\n  constructor(nodes, placeholders, placeholderToMessage, meaning, description, customId) {\n    this.nodes = nodes;\n    this.placeholders = placeholders;\n    this.placeholderToMessage = placeholderToMessage;\n    this.meaning = meaning;\n    this.description = description;\n    this.customId = customId;\n    this.id = this.customId;\n    this.messageString = serializeMessage(this.nodes);\n    if (nodes.length) {\n      this.sources = [{\n        filePath: nodes[0].sourceSpan.start.file.url,\n        startLine: nodes[0].sourceSpan.start.line + 1,\n        startCol: nodes[0].sourceSpan.start.col + 1,\n        endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n        endCol: nodes[0].sourceSpan.start.col + 1\n      }];\n    } else {\n      this.sources = [];\n    }\n  }\n}\nlet Text$2 = class Text {\n  value;\n  sourceSpan;\n  constructor(value, sourceSpan) {\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitText(this, context);\n  }\n};\nclass Container {\n  children;\n  sourceSpan;\n  constructor(children, sourceSpan) {\n    this.children = children;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitContainer(this, context);\n  }\n}\nclass Icu {\n  expression;\n  type;\n  cases;\n  sourceSpan;\n  expressionPlaceholder;\n  constructor(expression, type, cases, sourceSpan, expressionPlaceholder) {\n    this.expression = expression;\n    this.type = type;\n    this.cases = cases;\n    this.sourceSpan = sourceSpan;\n    this.expressionPlaceholder = expressionPlaceholder;\n  }\n  visit(visitor, context) {\n    return visitor.visitIcu(this, context);\n  }\n}\nclass TagPlaceholder {\n  tag;\n  attrs;\n  startName;\n  closeName;\n  children;\n  isVoid;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  constructor(tag, attrs, startName, closeName, children, isVoid, sourceSpan, startSourceSpan, endSourceSpan) {\n    this.tag = tag;\n    this.attrs = attrs;\n    this.startName = startName;\n    this.closeName = closeName;\n    this.children = children;\n    this.isVoid = isVoid;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitTagPlaceholder(this, context);\n  }\n}\nclass Placeholder {\n  value;\n  name;\n  sourceSpan;\n  constructor(value, name, sourceSpan) {\n    this.value = value;\n    this.name = name;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitPlaceholder(this, context);\n  }\n}\nclass IcuPlaceholder {\n  value;\n  name;\n  sourceSpan;\n  previousMessage;\n  constructor(value, name, sourceSpan) {\n    this.value = value;\n    this.name = name;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitIcuPlaceholder(this, context);\n  }\n}\nclass BlockPlaceholder {\n  name;\n  parameters;\n  startName;\n  closeName;\n  children;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  constructor(name, parameters, startName, closeName, children, sourceSpan, startSourceSpan, endSourceSpan) {\n    this.name = name;\n    this.parameters = parameters;\n    this.startName = startName;\n    this.closeName = closeName;\n    this.children = children;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitBlockPlaceholder(this, context);\n  }\n}\nclass CloneVisitor {\n  visitText(text, context) {\n    return new Text$2(text.value, text.sourceSpan);\n  }\n  visitContainer(container, context) {\n    const children = container.children.map(n => n.visit(this, context));\n    return new Container(children, container.sourceSpan);\n  }\n  visitIcu(icu, context) {\n    const cases = {};\n    Object.keys(icu.cases).forEach(key => cases[key] = icu.cases[key].visit(this, context));\n    const msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan, icu.expressionPlaceholder);\n    return msg;\n  }\n  visitTagPlaceholder(ph, context) {\n    const children = ph.children.map(n => n.visit(this, context));\n    return new TagPlaceholder(ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);\n  }\n  visitPlaceholder(ph, context) {\n    return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n  }\n  visitIcuPlaceholder(ph, context) {\n    return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n  }\n  visitBlockPlaceholder(ph, context) {\n    const children = ph.children.map(n => n.visit(this, context));\n    return new BlockPlaceholder(ph.name, ph.parameters, ph.startName, ph.closeName, children, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);\n  }\n}\nclass RecurseVisitor {\n  visitText(text, context) {}\n  visitContainer(container, context) {\n    container.children.forEach(child => child.visit(this));\n  }\n  visitIcu(icu, context) {\n    Object.keys(icu.cases).forEach(k => {\n      icu.cases[k].visit(this);\n    });\n  }\n  visitTagPlaceholder(ph, context) {\n    ph.children.forEach(child => child.visit(this));\n  }\n  visitPlaceholder(ph, context) {}\n  visitIcuPlaceholder(ph, context) {}\n  visitBlockPlaceholder(ph, context) {\n    ph.children.forEach(child => child.visit(this));\n  }\n}\nfunction serializeMessage(messageNodes) {\n  const visitor = new LocalizeMessageStringVisitor();\n  const str = messageNodes.map(n => n.visit(visitor)).join('');\n  return str;\n}\nclass LocalizeMessageStringVisitor {\n  visitText(text) {\n    return text.value;\n  }\n  visitContainer(container) {\n    return container.children.map(child => child.visit(this)).join('');\n  }\n  visitIcu(icu) {\n    const strCases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n    return `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;\n  }\n  visitTagPlaceholder(ph) {\n    const children = ph.children.map(child => child.visit(this)).join('');\n    return `{$${ph.startName}}${children}{$${ph.closeName}}`;\n  }\n  visitPlaceholder(ph) {\n    return `{$${ph.name}}`;\n  }\n  visitIcuPlaceholder(ph) {\n    return `{$${ph.name}}`;\n  }\n  visitBlockPlaceholder(ph) {\n    const children = ph.children.map(child => child.visit(this)).join('');\n    return `{$${ph.startName}}${children}{$${ph.closeName}}`;\n  }\n}\n\nclass Serializer {\n  createNameMapper(message) {\n    return null;\n  }\n}\nclass SimplePlaceholderMapper extends RecurseVisitor {\n  mapName;\n  internalToPublic = {};\n  publicToNextId = {};\n  publicToInternal = {};\n  constructor(message, mapName) {\n    super();\n    this.mapName = mapName;\n    message.nodes.forEach(node => node.visit(this));\n  }\n  toPublicName(internalName) {\n    return this.internalToPublic.hasOwnProperty(internalName) ? this.internalToPublic[internalName] : null;\n  }\n  toInternalName(publicName) {\n    return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] : null;\n  }\n  visitText(text, context) {\n    return null;\n  }\n  visitTagPlaceholder(ph, context) {\n    this.visitPlaceholderName(ph.startName);\n    super.visitTagPlaceholder(ph, context);\n    this.visitPlaceholderName(ph.closeName);\n  }\n  visitPlaceholder(ph, context) {\n    this.visitPlaceholderName(ph.name);\n  }\n  visitBlockPlaceholder(ph, context) {\n    this.visitPlaceholderName(ph.startName);\n    super.visitBlockPlaceholder(ph, context);\n    this.visitPlaceholderName(ph.closeName);\n  }\n  visitIcuPlaceholder(ph, context) {\n    this.visitPlaceholderName(ph.name);\n  }\n  visitPlaceholderName(internalName) {\n    if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n      return;\n    }\n    let publicName = this.mapName(internalName);\n    if (this.publicToInternal.hasOwnProperty(publicName)) {\n      const nextId = this.publicToNextId[publicName];\n      this.publicToNextId[publicName] = nextId + 1;\n      publicName = `${publicName}_${nextId}`;\n    } else {\n      this.publicToNextId[publicName] = 1;\n    }\n    this.internalToPublic[internalName] = publicName;\n    this.publicToInternal[publicName] = internalName;\n  }\n}\n\nlet _Visitor$2 = class _Visitor {\n  visitTag(tag) {\n    const strAttrs = this._serializeAttributes(tag.attrs);\n    if (tag.children.length == 0) {\n      return `<${tag.name}${strAttrs}/>`;\n    }\n    const strChildren = tag.children.map(node => node.visit(this));\n    return `<${tag.name}${strAttrs}>${strChildren.join('')}</${tag.name}>`;\n  }\n  visitText(text) {\n    return text.value;\n  }\n  visitDeclaration(decl) {\n    return `<?xml${this._serializeAttributes(decl.attrs)} ?>`;\n  }\n  _serializeAttributes(attrs) {\n    const strAttrs = Object.keys(attrs).map(name => `${name}=\"${attrs[name]}\"`).join(' ');\n    return strAttrs.length > 0 ? ' ' + strAttrs : '';\n  }\n  visitDoctype(doctype) {\n    return `<!DOCTYPE ${doctype.rootTag} [\\n${doctype.dtd}\\n]>`;\n  }\n};\nconst _visitor = new _Visitor$2();\nfunction serialize$1(nodes) {\n  return nodes.map(node => node.visit(_visitor)).join('');\n}\nclass Declaration {\n  attrs = {};\n  constructor(unescapedAttrs) {\n    Object.keys(unescapedAttrs).forEach(k => {\n      this.attrs[k] = escapeXml(unescapedAttrs[k]);\n    });\n  }\n  visit(visitor) {\n    return visitor.visitDeclaration(this);\n  }\n}\nclass Doctype {\n  rootTag;\n  dtd;\n  constructor(rootTag, dtd) {\n    this.rootTag = rootTag;\n    this.dtd = dtd;\n  }\n  visit(visitor) {\n    return visitor.visitDoctype(this);\n  }\n}\nclass Tag {\n  name;\n  children;\n  attrs = {};\n  constructor(name, unescapedAttrs = {}, children = []) {\n    this.name = name;\n    this.children = children;\n    Object.keys(unescapedAttrs).forEach(k => {\n      this.attrs[k] = escapeXml(unescapedAttrs[k]);\n    });\n  }\n  visit(visitor) {\n    return visitor.visitTag(this);\n  }\n}\nlet Text$1 = class Text {\n  value;\n  constructor(unescapedValue) {\n    this.value = escapeXml(unescapedValue);\n  }\n  visit(visitor) {\n    return visitor.visitText(this);\n  }\n};\nclass CR extends Text$1 {\n  constructor(ws = 0) {\n    super(`\\n${new Array(ws + 1).join(' ')}`);\n  }\n}\nconst _ESCAPED_CHARS = [[/&/g, '&amp;'], [/\"/g, '&quot;'], [/'/g, '&apos;'], [/</g, '&lt;'], [/>/g, '&gt;']];\nfunction escapeXml(text) {\n  return _ESCAPED_CHARS.reduce((text, entry) => text.replace(entry[0], entry[1]), text);\n}\n\nconst _XMB_HANDLER = 'angular';\nconst _MESSAGES_TAG = 'messagebundle';\nconst _MESSAGE_TAG = 'msg';\nconst _PLACEHOLDER_TAG$3 = 'ph';\nconst _EXAMPLE_TAG = 'ex';\nconst _SOURCE_TAG$2 = 'source';\nconst _DOCTYPE = `<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>`;\nclass Xmb extends Serializer {\n  write(messages, locale) {\n    const exampleVisitor = new ExampleVisitor();\n    const visitor = new _Visitor$1();\n    const rootNode = new Tag(_MESSAGES_TAG);\n    rootNode.attrs['handler'] = _XMB_HANDLER;\n    messages.forEach(message => {\n      const attrs = {\n        id: message.id\n      };\n      if (message.description) {\n        attrs['desc'] = message.description;\n      }\n      if (message.meaning) {\n        attrs['meaning'] = message.meaning;\n      }\n      let sourceTags = [];\n      message.sources.forEach(source => {\n        sourceTags.push(new Tag(_SOURCE_TAG$2, {}, [new Text$1(`${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? ',' + source.endLine : ''}`)]));\n      });\n      rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, [...sourceTags, ...visitor.serialize(message.nodes)]));\n    });\n    rootNode.children.push(new CR());\n    return serialize$1([new Declaration({\n      version: '1.0',\n      encoding: 'UTF-8'\n    }), new CR(), new Doctype(_MESSAGES_TAG, _DOCTYPE), new CR(), exampleVisitor.addDefaultExamples(rootNode), new CR()]);\n  }\n  load(content, url) {\n    throw new Error('Unsupported');\n  }\n  digest(message) {\n    return digest(message);\n  }\n  createNameMapper(message) {\n    return new SimplePlaceholderMapper(message, toPublicName);\n  }\n}\nlet _Visitor$1 = class _Visitor {\n  visitText(text, context) {\n    return [new Text$1(text.value)];\n  }\n  visitContainer(container, context) {\n    const nodes = [];\n    container.children.forEach(node => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n  visitIcu(icu, context) {\n    const nodes = [new Text$1(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n    Object.keys(icu.cases).forEach(c => {\n      nodes.push(new Text$1(`${c} {`), ...icu.cases[c].visit(this), new Text$1(`} `));\n    });\n    nodes.push(new Text$1(`}`));\n    return nodes;\n  }\n  visitTagPlaceholder(ph, context) {\n    const startTagAsText = new Text$1(`<${ph.tag}>`);\n    const startEx = new Tag(_EXAMPLE_TAG, {}, [startTagAsText]);\n    const startTagPh = new Tag(_PLACEHOLDER_TAG$3, {\n      name: ph.startName\n    }, [startEx, startTagAsText]);\n    if (ph.isVoid) {\n      return [startTagPh];\n    }\n    const closeTagAsText = new Text$1(`</${ph.tag}>`);\n    const closeEx = new Tag(_EXAMPLE_TAG, {}, [closeTagAsText]);\n    const closeTagPh = new Tag(_PLACEHOLDER_TAG$3, {\n      name: ph.closeName\n    }, [closeEx, closeTagAsText]);\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n  visitPlaceholder(ph, context) {\n    const interpolationAsText = new Text$1(`{{${ph.value}}}`);\n    const exTag = new Tag(_EXAMPLE_TAG, {}, [interpolationAsText]);\n    return [new Tag(_PLACEHOLDER_TAG$3, {\n      name: ph.name\n    }, [exTag, interpolationAsText])];\n  }\n  visitBlockPlaceholder(ph, context) {\n    const startAsText = new Text$1(`@${ph.name}`);\n    const startEx = new Tag(_EXAMPLE_TAG, {}, [startAsText]);\n    const startTagPh = new Tag(_PLACEHOLDER_TAG$3, {\n      name: ph.startName\n    }, [startEx, startAsText]);\n    const closeAsText = new Text$1(`}`);\n    const closeEx = new Tag(_EXAMPLE_TAG, {}, [closeAsText]);\n    const closeTagPh = new Tag(_PLACEHOLDER_TAG$3, {\n      name: ph.closeName\n    }, [closeEx, closeAsText]);\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n  visitIcuPlaceholder(ph, context) {\n    const icuExpression = ph.value.expression;\n    const icuType = ph.value.type;\n    const icuCases = Object.keys(ph.value.cases).map(value => value + ' {...}').join(' ');\n    const icuAsText = new Text$1(`{${icuExpression}, ${icuType}, ${icuCases}}`);\n    const exTag = new Tag(_EXAMPLE_TAG, {}, [icuAsText]);\n    return [new Tag(_PLACEHOLDER_TAG$3, {\n      name: ph.name\n    }, [exTag, icuAsText])];\n  }\n  serialize(nodes) {\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n};\nfunction digest(message) {\n  return decimalDigest(message);\n}\nclass ExampleVisitor {\n  addDefaultExamples(node) {\n    node.visit(this);\n    return node;\n  }\n  visitTag(tag) {\n    if (tag.name === _PLACEHOLDER_TAG$3) {\n      if (!tag.children || tag.children.length == 0) {\n        const exText = new Text$1(tag.attrs['name'] || '...');\n        tag.children = [new Tag(_EXAMPLE_TAG, {}, [exText])];\n      }\n    } else if (tag.children) {\n      tag.children.forEach(node => node.visit(this));\n    }\n  }\n  visitText(text) {}\n  visitDeclaration(decl) {}\n  visitDoctype(doctype) {}\n}\nfunction toPublicName(internalName) {\n  return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');\n}\n\nconst I18N_ATTR = 'i18n';\nconst I18N_ATTR_PREFIX = 'i18n-';\nconst I18N_ICU_VAR_PREFIX = 'VAR_';\nfunction isI18nAttribute(name) {\n  return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);\n}\nfunction hasI18nAttrs(node) {\n  return node.attrs.some(attr => isI18nAttribute(attr.name));\n}\nfunction icuFromI18nMessage(message) {\n  return message.nodes[0];\n}\nfunction formatI18nPlaceholderNamesInMap(params = {}, useCamelCase) {\n  const _params = {};\n  if (params && Object.keys(params).length) {\n    Object.keys(params).forEach(key => _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key]);\n  }\n  return _params;\n}\nfunction formatI18nPlaceholderName(name, useCamelCase = true) {\n  const publicName = toPublicName(name);\n  if (!useCamelCase) {\n    return publicName;\n  }\n  const chunks = publicName.split('_');\n  if (chunks.length === 1) {\n    return name.toLowerCase();\n  }\n  let postfix;\n  if (/^\\d+$/.test(chunks[chunks.length - 1])) {\n    postfix = chunks.pop();\n  }\n  let raw = chunks.shift().toLowerCase();\n  if (chunks.length) {\n    raw += chunks.map(c => c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()).join('');\n  }\n  return postfix ? `${raw}_${postfix}` : raw;\n}\n\nconst UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;\nconst TEMPORARY_NAME = '_t';\nconst CONTEXT_NAME = 'ctx';\nconst RENDER_FLAGS = 'rf';\nfunction temporaryAllocator(pushStatement, name) {\n  let temp = null;\n  return () => {\n    if (!temp) {\n      pushStatement(new DeclareVarStmt(TEMPORARY_NAME, undefined, DYNAMIC_TYPE));\n      temp = variable(name);\n    }\n    return temp;\n  };\n}\nfunction asLiteral(value) {\n  if (Array.isArray(value)) {\n    return literalArr(value.map(asLiteral));\n  }\n  return literal(value, INFERRED_TYPE);\n}\nfunction conditionallyCreateDirectiveBindingLiteral(map, forInputs) {\n  const keys = Object.getOwnPropertyNames(map);\n  if (keys.length === 0) {\n    return null;\n  }\n  return literalMap(keys.map(key => {\n    const value = map[key];\n    let declaredName;\n    let publicName;\n    let minifiedName;\n    let expressionValue;\n    if (typeof value === 'string') {\n      declaredName = key;\n      minifiedName = key;\n      publicName = value;\n      expressionValue = asLiteral(publicName);\n    } else {\n      minifiedName = key;\n      declaredName = value.classPropertyName;\n      publicName = value.bindingPropertyName;\n      const differentDeclaringName = publicName !== declaredName;\n      const hasDecoratorInputTransform = value.transformFunction !== null;\n      let flags = InputFlags.None;\n      if (value.isSignal) {\n        flags |= InputFlags.SignalBased;\n      }\n      if (hasDecoratorInputTransform) {\n        flags |= InputFlags.HasDecoratorInputTransform;\n      }\n      if (forInputs && (differentDeclaringName || hasDecoratorInputTransform || flags !== InputFlags.None)) {\n        const result = [literal(flags), asLiteral(publicName)];\n        if (differentDeclaringName || hasDecoratorInputTransform) {\n          result.push(asLiteral(declaredName));\n          if (hasDecoratorInputTransform) {\n            result.push(value.transformFunction);\n          }\n        }\n        expressionValue = literalArr(result);\n      } else {\n        expressionValue = asLiteral(publicName);\n      }\n    }\n    return {\n      key: minifiedName,\n      quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),\n      value: expressionValue\n    };\n  }));\n}\nclass DefinitionMap {\n  values = [];\n  set(key, value) {\n    if (value) {\n      const existing = this.values.find(value => value.key === key);\n      if (existing) {\n        existing.value = value;\n      } else {\n        this.values.push({\n          key: key,\n          value,\n          quoted: false\n        });\n      }\n    }\n  }\n  toLiteralMap() {\n    return literalMap(this.values);\n  }\n}\nfunction createCssSelectorFromNode(node) {\n  const elementName = node instanceof Element$1 ? node.name : 'ng-template';\n  const attributes = getAttrsForDirectiveMatching(node);\n  const cssSelector = new CssSelector();\n  const elementNameNoNs = splitNsName(elementName)[1];\n  cssSelector.setElement(elementNameNoNs);\n  Object.getOwnPropertyNames(attributes).forEach(name => {\n    const nameNoNs = splitNsName(name)[1];\n    const value = attributes[name];\n    cssSelector.addAttribute(nameNoNs, value);\n    if (name.toLowerCase() === 'class') {\n      const classes = value.trim().split(/\\s+/);\n      classes.forEach(className => cssSelector.addClassName(className));\n    }\n  });\n  return cssSelector;\n}\nfunction getAttrsForDirectiveMatching(elOrTpl) {\n  const attributesMap = {};\n  if (elOrTpl instanceof Template && elOrTpl.tagName !== 'ng-template') {\n    elOrTpl.templateAttrs.forEach(a => attributesMap[a.name] = '');\n  } else {\n    elOrTpl.attributes.forEach(a => {\n      if (!isI18nAttribute(a.name)) {\n        attributesMap[a.name] = a.value;\n      }\n    });\n    elOrTpl.inputs.forEach(i => {\n      if (i.type === BindingType.Property || i.type === BindingType.TwoWay) {\n        attributesMap[i.name] = '';\n      }\n    });\n    elOrTpl.outputs.forEach(o => {\n      attributesMap[o.name] = '';\n    });\n  }\n  return attributesMap;\n}\n\nfunction compileInjectable(meta, resolveForwardRefs) {\n  let result = null;\n  const factoryMeta = {\n    name: meta.name,\n    type: meta.type,\n    typeArgumentCount: meta.typeArgumentCount,\n    deps: [],\n    target: FactoryTarget.Injectable\n  };\n  if (meta.useClass !== undefined) {\n    const useClassOnSelf = meta.useClass.expression.isEquivalent(meta.type.value);\n    let deps = undefined;\n    if (meta.deps !== undefined) {\n      deps = meta.deps;\n    }\n    if (deps !== undefined) {\n      result = compileFactoryFunction({\n        ...factoryMeta,\n        delegate: meta.useClass.expression,\n        delegateDeps: deps,\n        delegateType: R3FactoryDelegateType.Class\n      });\n    } else if (useClassOnSelf) {\n      result = compileFactoryFunction(factoryMeta);\n    } else {\n      result = {\n        statements: [],\n        expression: delegateToFactory(meta.type.value, meta.useClass.expression, resolveForwardRefs)\n      };\n    }\n  } else if (meta.useFactory !== undefined) {\n    if (meta.deps !== undefined) {\n      result = compileFactoryFunction({\n        ...factoryMeta,\n        delegate: meta.useFactory,\n        delegateDeps: meta.deps || [],\n        delegateType: R3FactoryDelegateType.Function\n      });\n    } else {\n      result = {\n        statements: [],\n        expression: arrowFn([], meta.useFactory.callFn([]))\n      };\n    }\n  } else if (meta.useValue !== undefined) {\n    result = compileFactoryFunction({\n      ...factoryMeta,\n      expression: meta.useValue.expression\n    });\n  } else if (meta.useExisting !== undefined) {\n    result = compileFactoryFunction({\n      ...factoryMeta,\n      expression: importExpr(Identifiers.inject).callFn([meta.useExisting.expression])\n    });\n  } else {\n    result = {\n      statements: [],\n      expression: delegateToFactory(meta.type.value, meta.type.value, resolveForwardRefs)\n    };\n  }\n  const token = meta.type.value;\n  const injectableProps = new DefinitionMap();\n  injectableProps.set('token', token);\n  injectableProps.set('factory', result.expression);\n  if (meta.providedIn.expression.value !== null) {\n    injectableProps.set('providedIn', convertFromMaybeForwardRefExpression(meta.providedIn));\n  }\n  const expression = importExpr(Identifiers.ÉµÉµdefineInjectable).callFn([injectableProps.toLiteralMap()], undefined, true);\n  return {\n    expression,\n    type: createInjectableType(meta),\n    statements: result.statements\n  };\n}\nfunction createInjectableType(meta) {\n  return new ExpressionType(importExpr(Identifiers.InjectableDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));\n}\nfunction delegateToFactory(type, useType, unwrapForwardRefs) {\n  if (type.node === useType.node) {\n    return useType.prop('Éµfac');\n  }\n  if (!unwrapForwardRefs) {\n    return createFactoryFunction(useType);\n  }\n  const unwrappedType = importExpr(Identifiers.resolveForwardRef).callFn([useType]);\n  return createFactoryFunction(unwrappedType);\n}\nfunction createFactoryFunction(type) {\n  const t = new FnParam('__ngFactoryType__', DYNAMIC_TYPE);\n  return arrowFn([t], type.prop('Éµfac').callFn([variable(t.name)]));\n}\n\nconst $EOF = 0;\nconst $BSPACE = 8;\nconst $TAB = 9;\nconst $LF = 10;\nconst $VTAB = 11;\nconst $FF = 12;\nconst $CR = 13;\nconst $SPACE = 32;\nconst $BANG = 33;\nconst $DQ = 34;\nconst $HASH = 35;\nconst $$ = 36;\nconst $PERCENT = 37;\nconst $AMPERSAND = 38;\nconst $SQ = 39;\nconst $LPAREN = 40;\nconst $RPAREN = 41;\nconst $STAR = 42;\nconst $PLUS = 43;\nconst $COMMA = 44;\nconst $MINUS = 45;\nconst $PERIOD = 46;\nconst $SLASH = 47;\nconst $COLON = 58;\nconst $SEMICOLON = 59;\nconst $LT = 60;\nconst $EQ = 61;\nconst $GT = 62;\nconst $QUESTION = 63;\nconst $0 = 48;\nconst $7 = 55;\nconst $9 = 57;\nconst $A = 65;\nconst $E = 69;\nconst $F = 70;\nconst $X = 88;\nconst $Z = 90;\nconst $LBRACKET = 91;\nconst $BACKSLASH = 92;\nconst $RBRACKET = 93;\nconst $CARET = 94;\nconst $_ = 95;\nconst $a = 97;\nconst $b = 98;\nconst $e = 101;\nconst $f = 102;\nconst $n = 110;\nconst $r = 114;\nconst $t = 116;\nconst $u = 117;\nconst $v = 118;\nconst $x = 120;\nconst $z = 122;\nconst $LBRACE = 123;\nconst $BAR = 124;\nconst $RBRACE = 125;\nconst $NBSP = 160;\nconst $AT = 64;\nconst $BT = 96;\nfunction isWhitespace(code) {\n  return code >= $TAB && code <= $SPACE || code == $NBSP;\n}\nfunction isDigit(code) {\n  return $0 <= code && code <= $9;\n}\nfunction isAsciiLetter(code) {\n  return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\nfunction isAsciiHexDigit(code) {\n  return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}\nfunction isNewLine(code) {\n  return code === $LF || code === $CR;\n}\nfunction isOctalDigit(code) {\n  return $0 <= code && code <= $7;\n}\nfunction isQuote(code) {\n  return code === $SQ || code === $DQ || code === $BT;\n}\n\nclass ParseLocation {\n  file;\n  offset;\n  line;\n  col;\n  constructor(file, offset, line, col) {\n    this.file = file;\n    this.offset = offset;\n    this.line = line;\n    this.col = col;\n  }\n  toString() {\n    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;\n  }\n  moveBy(delta) {\n    const source = this.file.content;\n    const len = source.length;\n    let offset = this.offset;\n    let line = this.line;\n    let col = this.col;\n    while (offset > 0 && delta < 0) {\n      offset--;\n      delta++;\n      const ch = source.charCodeAt(offset);\n      if (ch == $LF) {\n        line--;\n        const priorLine = source.substring(0, offset - 1).lastIndexOf(String.fromCharCode($LF));\n        col = priorLine > 0 ? offset - priorLine : offset;\n      } else {\n        col--;\n      }\n    }\n    while (offset < len && delta > 0) {\n      const ch = source.charCodeAt(offset);\n      offset++;\n      delta--;\n      if (ch == $LF) {\n        line++;\n        col = 0;\n      } else {\n        col++;\n      }\n    }\n    return new ParseLocation(this.file, offset, line, col);\n  }\n  getContext(maxChars, maxLines) {\n    const content = this.file.content;\n    let startOffset = this.offset;\n    if (startOffset != null) {\n      if (startOffset > content.length - 1) {\n        startOffset = content.length - 1;\n      }\n      let endOffset = startOffset;\n      let ctxChars = 0;\n      let ctxLines = 0;\n      while (ctxChars < maxChars && startOffset > 0) {\n        startOffset--;\n        ctxChars++;\n        if (content[startOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n      ctxChars = 0;\n      ctxLines = 0;\n      while (ctxChars < maxChars && endOffset < content.length - 1) {\n        endOffset++;\n        ctxChars++;\n        if (content[endOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n      return {\n        before: content.substring(startOffset, this.offset),\n        after: content.substring(this.offset, endOffset + 1)\n      };\n    }\n    return null;\n  }\n}\nclass ParseSourceFile {\n  content;\n  url;\n  constructor(content, url) {\n    this.content = content;\n    this.url = url;\n  }\n}\nclass ParseSourceSpan {\n  start;\n  end;\n  fullStart;\n  details;\n  constructor(start, end, fullStart = start, details = null) {\n    this.start = start;\n    this.end = end;\n    this.fullStart = fullStart;\n    this.details = details;\n  }\n  toString() {\n    return this.start.file.content.substring(this.start.offset, this.end.offset);\n  }\n}\nvar ParseErrorLevel;\n(function (ParseErrorLevel) {\n  ParseErrorLevel[ParseErrorLevel[\"WARNING\"] = 0] = \"WARNING\";\n  ParseErrorLevel[ParseErrorLevel[\"ERROR\"] = 1] = \"ERROR\";\n})(ParseErrorLevel || (ParseErrorLevel = {}));\nclass ParseError extends Error {\n  span;\n  msg;\n  level;\n  relatedError;\n  constructor(span, msg, level = ParseErrorLevel.ERROR, relatedError) {\n    super(msg);\n    this.span = span;\n    this.msg = msg;\n    this.level = level;\n    this.relatedError = relatedError;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n  contextualMessage() {\n    const ctx = this.span.start.getContext(100, 3);\n    return ctx ? `${this.msg} (\"${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}\")` : this.msg;\n  }\n  toString() {\n    const details = this.span.details ? `, ${this.span.details}` : '';\n    return `${this.contextualMessage()}: ${this.span.start}${details}`;\n  }\n}\nfunction r3JitTypeSourceSpan(kind, typeName, sourceUrl) {\n  const sourceFileName = `in ${kind} ${typeName} in ${sourceUrl}`;\n  const sourceFile = new ParseSourceFile('', sourceFileName);\n  return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\nlet _anonymousTypeIndex = 0;\nfunction identifierName(compileIdentifier) {\n  if (!compileIdentifier || !compileIdentifier.reference) {\n    return null;\n  }\n  const ref = compileIdentifier.reference;\n  if (ref['__anonymousType']) {\n    return ref['__anonymousType'];\n  }\n  if (ref['__forward_ref__']) {\n    return '__forward_ref__';\n  }\n  let identifier = stringify(ref);\n  if (identifier.indexOf('(') >= 0) {\n    identifier = `anonymous_${_anonymousTypeIndex++}`;\n    ref['__anonymousType'] = identifier;\n  } else {\n    identifier = sanitizeIdentifier(identifier);\n  }\n  return identifier;\n}\nfunction sanitizeIdentifier(name) {\n  return name.replace(/\\W/g, '_');\n}\n\nconst makeTemplateObjectPolyfill = '(this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,\"raw\",{value:t}):e.raw=t,e})';\nclass AbstractJsEmitterVisitor extends AbstractEmitterVisitor {\n  constructor() {\n    super(false);\n  }\n  visitWrappedNodeExpr(ast, ctx) {\n    throw new Error('Cannot emit a WrappedNodeExpr in Javascript.');\n  }\n  visitDeclareVarStmt(stmt, ctx) {\n    ctx.print(stmt, `var ${stmt.name}`);\n    if (stmt.value) {\n      ctx.print(stmt, ' = ');\n      stmt.value.visitExpression(this, ctx);\n    }\n    ctx.println(stmt, `;`);\n    return null;\n  }\n  visitTaggedTemplateLiteralExpr(ast, ctx) {\n    const elements = ast.template.elements;\n    ast.tag.visitExpression(this, ctx);\n    ctx.print(ast, `(${makeTemplateObjectPolyfill}(`);\n    ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.text, false)).join(', ')}], `);\n    ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.rawText, false)).join(', ')}])`);\n    ast.template.expressions.forEach(expression => {\n      ctx.print(ast, ', ');\n      expression.visitExpression(this, ctx);\n    });\n    ctx.print(ast, ')');\n    return null;\n  }\n  visitTemplateLiteralExpr(expr, ctx) {\n    ctx.print(expr, '`');\n    for (let i = 0; i < expr.elements.length; i++) {\n      expr.elements[i].visitExpression(this, ctx);\n      const expression = i < expr.expressions.length ? expr.expressions[i] : null;\n      if (expression !== null) {\n        ctx.print(expression, '${');\n        expression.visitExpression(this, ctx);\n        ctx.print(expression, '}');\n      }\n    }\n    ctx.print(expr, '`');\n  }\n  visitTemplateLiteralElementExpr(expr, ctx) {\n    ctx.print(expr, expr.rawText);\n    return null;\n  }\n  visitFunctionExpr(ast, ctx) {\n    ctx.print(ast, `function${ast.name ? ' ' + ast.name : ''}(`);\n    this._visitParams(ast.params, ctx);\n    ctx.println(ast, `) {`);\n    ctx.incIndent();\n    this.visitAllStatements(ast.statements, ctx);\n    ctx.decIndent();\n    ctx.print(ast, `}`);\n    return null;\n  }\n  visitArrowFunctionExpr(ast, ctx) {\n    ctx.print(ast, '(');\n    this._visitParams(ast.params, ctx);\n    ctx.print(ast, ') =>');\n    if (Array.isArray(ast.body)) {\n      ctx.println(ast, `{`);\n      ctx.incIndent();\n      this.visitAllStatements(ast.body, ctx);\n      ctx.decIndent();\n      ctx.print(ast, `}`);\n    } else {\n      const isObjectLiteral = ast.body instanceof LiteralMapExpr;\n      if (isObjectLiteral) {\n        ctx.print(ast, '(');\n      }\n      ast.body.visitExpression(this, ctx);\n      if (isObjectLiteral) {\n        ctx.print(ast, ')');\n      }\n    }\n    return null;\n  }\n  visitDeclareFunctionStmt(stmt, ctx) {\n    ctx.print(stmt, `function ${stmt.name}(`);\n    this._visitParams(stmt.params, ctx);\n    ctx.println(stmt, `) {`);\n    ctx.incIndent();\n    this.visitAllStatements(stmt.statements, ctx);\n    ctx.decIndent();\n    ctx.println(stmt, `}`);\n    return null;\n  }\n  visitLocalizedString(ast, ctx) {\n    ctx.print(ast, `$localize(${makeTemplateObjectPolyfill}(`);\n    const parts = [ast.serializeI18nHead()];\n    for (let i = 1; i < ast.messageParts.length; i++) {\n      parts.push(ast.serializeI18nTemplatePart(i));\n    }\n    ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.cooked, false)).join(', ')}], `);\n    ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.raw, false)).join(', ')}])`);\n    ast.expressions.forEach(expression => {\n      ctx.print(ast, ', ');\n      expression.visitExpression(this, ctx);\n    });\n    ctx.print(ast, ')');\n    return null;\n  }\n  _visitParams(params, ctx) {\n    this.visitAllObjects(param => ctx.print(null, param.name), params, ctx, ',');\n  }\n}\n\nlet policy;\nfunction getPolicy() {\n  if (policy === undefined) {\n    const trustedTypes = _global['trustedTypes'];\n    policy = null;\n    if (trustedTypes) {\n      try {\n        policy = trustedTypes.createPolicy('angular#unsafe-jit', {\n          createScript: s => s\n        });\n      } catch {}\n    }\n  }\n  return policy;\n}\nfunction trustedScriptFromString(script) {\n  return getPolicy()?.createScript(script) || script;\n}\nfunction newTrustedFunctionForJIT(...args) {\n  if (!_global['trustedTypes']) {\n    return new Function(...args);\n  }\n  const fnArgs = args.slice(0, -1).join(',');\n  const fnBody = args[args.length - 1];\n  const body = `(function anonymous(${fnArgs}\n) { ${fnBody}\n})`;\n  const fn = _global['eval'](trustedScriptFromString(body));\n  if (fn.bind === undefined) {\n    return new Function(...args);\n  }\n  fn.toString = () => body;\n  return fn.bind(_global);\n}\n\nclass JitEvaluator {\n  evaluateStatements(sourceUrl, statements, refResolver, createSourceMaps) {\n    const converter = new JitEmitterVisitor(refResolver);\n    const ctx = EmitterVisitorContext.createRoot();\n    if (statements.length > 0 && !isUseStrictStatement(statements[0])) {\n      statements = [literal('use strict').toStmt(), ...statements];\n    }\n    converter.visitAllStatements(statements, ctx);\n    converter.createReturnStmt(ctx);\n    return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);\n  }\n  evaluateCode(sourceUrl, ctx, vars, createSourceMap) {\n    let fnBody = `\"use strict\";${ctx.toSource()}\\n//# sourceURL=${sourceUrl}`;\n    const fnArgNames = [];\n    const fnArgValues = [];\n    for (const argName in vars) {\n      fnArgValues.push(vars[argName]);\n      fnArgNames.push(argName);\n    }\n    if (createSourceMap) {\n      const emptyFn = newTrustedFunctionForJIT(...fnArgNames.concat('return null;')).toString();\n      const headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\n      fnBody += `\\n${ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment()}`;\n    }\n    const fn = newTrustedFunctionForJIT(...fnArgNames.concat(fnBody));\n    return this.executeFunction(fn, fnArgValues);\n  }\n  executeFunction(fn, args) {\n    return fn(...args);\n  }\n}\nclass JitEmitterVisitor extends AbstractJsEmitterVisitor {\n  refResolver;\n  _evalArgNames = [];\n  _evalArgValues = [];\n  _evalExportedVars = [];\n  constructor(refResolver) {\n    super();\n    this.refResolver = refResolver;\n  }\n  createReturnStmt(ctx) {\n    const stmt = new ReturnStatement(new LiteralMapExpr(this._evalExportedVars.map(resultVar => new LiteralMapEntry(resultVar, variable(resultVar), false))));\n    stmt.visitStatement(this, ctx);\n  }\n  getArgs() {\n    const result = {};\n    for (let i = 0; i < this._evalArgNames.length; i++) {\n      result[this._evalArgNames[i]] = this._evalArgValues[i];\n    }\n    return result;\n  }\n  visitExternalExpr(ast, ctx) {\n    this._emitReferenceToExternal(ast, this.refResolver.resolveExternalReference(ast.value), ctx);\n    return null;\n  }\n  visitWrappedNodeExpr(ast, ctx) {\n    this._emitReferenceToExternal(ast, ast.node, ctx);\n    return null;\n  }\n  visitDeclareVarStmt(stmt, ctx) {\n    if (stmt.hasModifier(StmtModifier.Exported)) {\n      this._evalExportedVars.push(stmt.name);\n    }\n    return super.visitDeclareVarStmt(stmt, ctx);\n  }\n  visitDeclareFunctionStmt(stmt, ctx) {\n    if (stmt.hasModifier(StmtModifier.Exported)) {\n      this._evalExportedVars.push(stmt.name);\n    }\n    return super.visitDeclareFunctionStmt(stmt, ctx);\n  }\n  _emitReferenceToExternal(ast, value, ctx) {\n    let id = this._evalArgValues.indexOf(value);\n    if (id === -1) {\n      id = this._evalArgValues.length;\n      this._evalArgValues.push(value);\n      const name = identifierName({\n        reference: value\n      }) || 'val';\n      this._evalArgNames.push(`jit_${name}_${id}`);\n    }\n    ctx.print(ast, this._evalArgNames[id]);\n  }\n}\nfunction isUseStrictStatement(statement) {\n  return statement.isEquivalent(literal('use strict').toStmt());\n}\n\nfunction compileInjector(meta) {\n  const definitionMap = new DefinitionMap();\n  if (meta.providers !== null) {\n    definitionMap.set('providers', meta.providers);\n  }\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', literalArr(meta.imports));\n  }\n  const expression = importExpr(Identifiers.defineInjector).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createInjectorType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createInjectorType(meta) {\n  return new ExpressionType(importExpr(Identifiers.InjectorDeclaration, [new ExpressionType(meta.type.type)]));\n}\n\nclass R3JitReflector {\n  context;\n  constructor(context) {\n    this.context = context;\n  }\n  resolveExternalReference(ref) {\n    if (ref.moduleName !== '@angular/core') {\n      throw new Error(`Cannot resolve external reference to ${ref.moduleName}, only references to @angular/core are supported.`);\n    }\n    if (!this.context.hasOwnProperty(ref.name)) {\n      throw new Error(`No value provided for @angular/core symbol '${ref.name}'.`);\n    }\n    return this.context[ref.name];\n  }\n}\n\nvar R3SelectorScopeMode;\n(function (R3SelectorScopeMode) {\n  R3SelectorScopeMode[R3SelectorScopeMode[\"Inline\"] = 0] = \"Inline\";\n  R3SelectorScopeMode[R3SelectorScopeMode[\"SideEffect\"] = 1] = \"SideEffect\";\n  R3SelectorScopeMode[R3SelectorScopeMode[\"Omit\"] = 2] = \"Omit\";\n})(R3SelectorScopeMode || (R3SelectorScopeMode = {}));\nvar R3NgModuleMetadataKind;\n(function (R3NgModuleMetadataKind) {\n  R3NgModuleMetadataKind[R3NgModuleMetadataKind[\"Global\"] = 0] = \"Global\";\n  R3NgModuleMetadataKind[R3NgModuleMetadataKind[\"Local\"] = 1] = \"Local\";\n})(R3NgModuleMetadataKind || (R3NgModuleMetadataKind = {}));\nfunction compileNgModule(meta) {\n  const statements = [];\n  const definitionMap = new DefinitionMap();\n  definitionMap.set('type', meta.type.value);\n  if (meta.kind === R3NgModuleMetadataKind.Global && meta.bootstrap.length > 0) {\n    definitionMap.set('bootstrap', refsToArray(meta.bootstrap, meta.containsForwardDecls));\n  }\n  if (meta.selectorScopeMode === R3SelectorScopeMode.Inline) {\n    if (meta.declarations.length > 0) {\n      definitionMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\n    }\n    if (meta.imports.length > 0) {\n      definitionMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\n    }\n    if (meta.exports.length > 0) {\n      definitionMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\n    }\n  } else if (meta.selectorScopeMode === R3SelectorScopeMode.SideEffect) {\n    const setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);\n    if (setNgModuleScopeCall !== null) {\n      statements.push(setNgModuleScopeCall);\n    }\n  } else ;\n  if (meta.schemas !== null && meta.schemas.length > 0) {\n    definitionMap.set('schemas', literalArr(meta.schemas.map(ref => ref.value)));\n  }\n  if (meta.id !== null) {\n    definitionMap.set('id', meta.id);\n    statements.push(importExpr(Identifiers.registerNgModuleType).callFn([meta.type.value, meta.id]).toStmt());\n  }\n  const expression = importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createNgModuleType(meta);\n  return {\n    expression,\n    type,\n    statements\n  };\n}\nfunction compileNgModuleDeclarationExpression(meta) {\n  const definitionMap = new DefinitionMap();\n  definitionMap.set('type', new WrappedNodeExpr(meta.type));\n  if (meta.bootstrap !== undefined) {\n    definitionMap.set('bootstrap', new WrappedNodeExpr(meta.bootstrap));\n  }\n  if (meta.declarations !== undefined) {\n    definitionMap.set('declarations', new WrappedNodeExpr(meta.declarations));\n  }\n  if (meta.imports !== undefined) {\n    definitionMap.set('imports', new WrappedNodeExpr(meta.imports));\n  }\n  if (meta.exports !== undefined) {\n    definitionMap.set('exports', new WrappedNodeExpr(meta.exports));\n  }\n  if (meta.schemas !== undefined) {\n    definitionMap.set('schemas', new WrappedNodeExpr(meta.schemas));\n  }\n  if (meta.id !== undefined) {\n    definitionMap.set('id', new WrappedNodeExpr(meta.id));\n  }\n  return importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()]);\n}\nfunction createNgModuleType(meta) {\n  if (meta.kind === R3NgModuleMetadataKind.Local) {\n    return new ExpressionType(meta.type.value);\n  }\n  const {\n    type: moduleType,\n    declarations,\n    exports,\n    imports,\n    includeImportTypes,\n    publicDeclarationTypes\n  } = meta;\n  return new ExpressionType(importExpr(Identifiers.NgModuleDeclaration, [new ExpressionType(moduleType.type), publicDeclarationTypes === null ? tupleTypeOf(declarations) : tupleOfTypes(publicDeclarationTypes), includeImportTypes ? tupleTypeOf(imports) : NONE_TYPE, tupleTypeOf(exports)]));\n}\nfunction generateSetNgModuleScopeCall(meta) {\n  const scopeMap = new DefinitionMap();\n  if (meta.kind === R3NgModuleMetadataKind.Global) {\n    if (meta.declarations.length > 0) {\n      scopeMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\n    }\n  } else {\n    if (meta.declarationsExpression) {\n      scopeMap.set('declarations', meta.declarationsExpression);\n    }\n  }\n  if (meta.kind === R3NgModuleMetadataKind.Global) {\n    if (meta.imports.length > 0) {\n      scopeMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\n    }\n  } else {\n    if (meta.importsExpression) {\n      scopeMap.set('imports', meta.importsExpression);\n    }\n  }\n  if (meta.kind === R3NgModuleMetadataKind.Global) {\n    if (meta.exports.length > 0) {\n      scopeMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\n    }\n  } else {\n    if (meta.exportsExpression) {\n      scopeMap.set('exports', meta.exportsExpression);\n    }\n  }\n  if (meta.kind === R3NgModuleMetadataKind.Local && meta.bootstrapExpression) {\n    scopeMap.set('bootstrap', meta.bootstrapExpression);\n  }\n  if (Object.keys(scopeMap.values).length === 0) {\n    return null;\n  }\n  const fnCall = new InvokeFunctionExpr(importExpr(Identifiers.setNgModuleScope), [meta.type.value, scopeMap.toLiteralMap()]);\n  const guardedCall = jitOnlyGuardedExpression(fnCall);\n  const iife = new FunctionExpr([], [guardedCall.toStmt()]);\n  const iifeCall = new InvokeFunctionExpr(iife, []);\n  return iifeCall.toStmt();\n}\nfunction tupleTypeOf(exp) {\n  const types = exp.map(ref => typeofExpr(ref.type));\n  return exp.length > 0 ? expressionType(literalArr(types)) : NONE_TYPE;\n}\nfunction tupleOfTypes(types) {\n  const typeofTypes = types.map(type => typeofExpr(type));\n  return types.length > 0 ? expressionType(literalArr(typeofTypes)) : NONE_TYPE;\n}\n\nfunction compilePipeFromMetadata(metadata) {\n  const definitionMapValues = [];\n  definitionMapValues.push({\n    key: 'name',\n    value: literal(metadata.pipeName ?? metadata.name),\n    quoted: false\n  });\n  definitionMapValues.push({\n    key: 'type',\n    value: metadata.type.value,\n    quoted: false\n  });\n  definitionMapValues.push({\n    key: 'pure',\n    value: literal(metadata.pure),\n    quoted: false\n  });\n  if (metadata.isStandalone === false) {\n    definitionMapValues.push({\n      key: 'standalone',\n      value: literal(false),\n      quoted: false\n    });\n  }\n  const expression = importExpr(Identifiers.definePipe).callFn([literalMap(definitionMapValues)], undefined, true);\n  const type = createPipeType(metadata);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createPipeType(metadata) {\n  return new ExpressionType(importExpr(Identifiers.PipeDeclaration, [typeWithParameters(metadata.type.type, metadata.typeArgumentCount), new ExpressionType(new LiteralExpr(metadata.pipeName)), new ExpressionType(new LiteralExpr(metadata.isStandalone))]));\n}\n\nvar R3TemplateDependencyKind;\n(function (R3TemplateDependencyKind) {\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"Directive\"] = 0] = \"Directive\";\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"Pipe\"] = 1] = \"Pipe\";\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"NgModule\"] = 2] = \"NgModule\";\n})(R3TemplateDependencyKind || (R3TemplateDependencyKind = {}));\n\nconst animationKeywords = new Set(['inherit', 'initial', 'revert', 'unset', 'alternate', 'alternate-reverse', 'normal', 'reverse', 'backwards', 'both', 'forwards', 'none', 'paused', 'running', 'ease', 'ease-in', 'ease-in-out', 'ease-out', 'linear', 'step-start', 'step-end', 'end', 'jump-both', 'jump-end', 'jump-none', 'jump-start', 'start']);\nconst scopedAtRuleIdentifiers = ['@media', '@supports', '@document', '@layer', '@container', '@scope', '@starting-style'];\nclass ShadowCss {\n  shimCssText(cssText, selector, hostSelector = '') {\n    const comments = [];\n    cssText = cssText.replace(_commentRe, m => {\n      if (m.match(_commentWithHashRe)) {\n        comments.push(m);\n      } else {\n        const newLinesMatches = m.match(_newLinesRe);\n        comments.push((newLinesMatches?.join('') ?? '') + '\\n');\n      }\n      return COMMENT_PLACEHOLDER;\n    });\n    cssText = this._insertDirectives(cssText);\n    const scopedCssText = this._scopeCssText(cssText, selector, hostSelector);\n    let commentIdx = 0;\n    return scopedCssText.replace(_commentWithHashPlaceHolderRe, () => comments[commentIdx++]);\n  }\n  _insertDirectives(cssText) {\n    cssText = this._insertPolyfillDirectivesInCssText(cssText);\n    return this._insertPolyfillRulesInCssText(cssText);\n  }\n  _scopeKeyframesRelatedCss(cssText, scopeSelector) {\n    const unscopedKeyframesSet = new Set();\n    const scopedKeyframesCssText = processRules(cssText, rule => this._scopeLocalKeyframeDeclarations(rule, scopeSelector, unscopedKeyframesSet));\n    return processRules(scopedKeyframesCssText, rule => this._scopeAnimationRule(rule, scopeSelector, unscopedKeyframesSet));\n  }\n  _scopeLocalKeyframeDeclarations(rule, scopeSelector, unscopedKeyframesSet) {\n    return {\n      ...rule,\n      selector: rule.selector.replace(/(^@(?:-webkit-)?keyframes(?:\\s+))(['\"]?)(.+)\\2(\\s*)$/, (_, start, quote, keyframeName, endSpaces) => {\n        unscopedKeyframesSet.add(unescapeQuotes(keyframeName, quote));\n        return `${start}${quote}${scopeSelector}_${keyframeName}${quote}${endSpaces}`;\n      })\n    };\n  }\n  _scopeAnimationKeyframe(keyframe, scopeSelector, unscopedKeyframesSet) {\n    return keyframe.replace(/^(\\s*)(['\"]?)(.+?)\\2(\\s*)$/, (_, spaces1, quote, name, spaces2) => {\n      name = `${unscopedKeyframesSet.has(unescapeQuotes(name, quote)) ? scopeSelector + '_' : ''}${name}`;\n      return `${spaces1}${quote}${name}${quote}${spaces2}`;\n    });\n  }\n  _animationDeclarationKeyframesRe = /(^|\\s+|,)(?:(?:(['\"])((?:\\\\\\\\|\\\\\\2|(?!\\2).)+)\\2)|(-?[A-Za-z][\\w\\-]*))(?=[,\\s]|$)/g;\n  _scopeAnimationRule(rule, scopeSelector, unscopedKeyframesSet) {\n    let content = rule.content.replace(/((?:^|\\s+|;)(?:-webkit-)?animation\\s*:\\s*),*([^;]+)/g, (_, start, animationDeclarations) => start + animationDeclarations.replace(this._animationDeclarationKeyframesRe, (original, leadingSpaces, quote = '', quotedName, nonQuotedName) => {\n      if (quotedName) {\n        return `${leadingSpaces}${this._scopeAnimationKeyframe(`${quote}${quotedName}${quote}`, scopeSelector, unscopedKeyframesSet)}`;\n      } else {\n        return animationKeywords.has(nonQuotedName) ? original : `${leadingSpaces}${this._scopeAnimationKeyframe(nonQuotedName, scopeSelector, unscopedKeyframesSet)}`;\n      }\n    }));\n    content = content.replace(/((?:^|\\s+|;)(?:-webkit-)?animation-name(?:\\s*):(?:\\s*))([^;]+)/g, (_match, start, commaSeparatedKeyframes) => `${start}${commaSeparatedKeyframes.split(',').map(keyframe => this._scopeAnimationKeyframe(keyframe, scopeSelector, unscopedKeyframesSet)).join(',')}`);\n    return {\n      ...rule,\n      content\n    };\n  }\n  _insertPolyfillDirectivesInCssText(cssText) {\n    return cssText.replace(_cssContentNextSelectorRe, function (...m) {\n      return m[2] + '{';\n    });\n  }\n  _insertPolyfillRulesInCssText(cssText) {\n    return cssText.replace(_cssContentRuleRe, (...m) => {\n      const rule = m[0].replace(m[1], '').replace(m[2], '');\n      return m[4] + rule;\n    });\n  }\n  _scopeCssText(cssText, scopeSelector, hostSelector) {\n    const unscopedRules = this._extractUnscopedRulesFromCssText(cssText);\n    cssText = this._insertPolyfillHostInCssText(cssText);\n    cssText = this._convertColonHost(cssText);\n    cssText = this._convertColonHostContext(cssText);\n    cssText = this._convertShadowDOMSelectors(cssText);\n    if (scopeSelector) {\n      cssText = this._scopeKeyframesRelatedCss(cssText, scopeSelector);\n      cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\n    }\n    cssText = cssText + '\\n' + unscopedRules;\n    return cssText.trim();\n  }\n  _extractUnscopedRulesFromCssText(cssText) {\n    let r = '';\n    let m;\n    _cssContentUnscopedRuleRe.lastIndex = 0;\n    while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {\n      const rule = m[0].replace(m[2], '').replace(m[1], m[4]);\n      r += rule + '\\n\\n';\n    }\n    return r;\n  }\n  _convertColonHost(cssText) {\n    return cssText.replace(_cssColonHostRe, (_, hostSelectors, otherSelectors) => {\n      if (hostSelectors) {\n        const convertedSelectors = [];\n        for (const hostSelector of this._splitOnTopLevelCommas(hostSelectors, true)) {\n          const trimmedHostSelector = hostSelector.trim();\n          if (!trimmedHostSelector) break;\n          const convertedSelector = _polyfillHostNoCombinator + trimmedHostSelector.replace(_polyfillHost, '') + otherSelectors;\n          convertedSelectors.push(convertedSelector);\n        }\n        return convertedSelectors.join(',');\n      } else {\n        return _polyfillHostNoCombinator + otherSelectors;\n      }\n    });\n  }\n  *_splitOnTopLevelCommas(text, returnOnClosingParen) {\n    const length = text.length;\n    let parens = 0;\n    let prev = 0;\n    for (let i = 0; i < length; i++) {\n      const charCode = text.charCodeAt(i);\n      if (charCode === $LPAREN) {\n        parens++;\n      } else if (charCode === $RPAREN) {\n        parens--;\n        if (parens < 0 && returnOnClosingParen) {\n          yield text.slice(prev, i);\n          return;\n        }\n      } else if (charCode === $COMMA && parens === 0) {\n        yield text.slice(prev, i);\n        prev = i + 1;\n      }\n    }\n    yield text.slice(prev);\n  }\n  _convertColonHostContext(cssText) {\n    const results = [];\n    for (const part of this._splitOnTopLevelCommas(cssText, false)) {\n      results.push(this._convertColonHostContextInSelectorPart(part));\n    }\n    return results.join(',');\n  }\n  _convertColonHostContextInSelectorPart(cssText) {\n    return cssText.replace(_cssColonHostContextReGlobal, (selectorText, pseudoPrefix) => {\n      const contextSelectorGroups = [[]];\n      let startIndex = selectorText.indexOf(_polyfillHostContext);\n      while (startIndex !== -1) {\n        const afterPrefix = selectorText.substring(startIndex + _polyfillHostContext.length);\n        if (!afterPrefix || afterPrefix[0] !== '(') {\n          selectorText = afterPrefix;\n          startIndex = selectorText.indexOf(_polyfillHostContext);\n          continue;\n        }\n        const newContextSelectors = [];\n        let endIndex = 0;\n        for (const selector of this._splitOnTopLevelCommas(afterPrefix.substring(1), true)) {\n          endIndex = endIndex + selector.length + 1;\n          const trimmed = selector.trim();\n          if (trimmed) {\n            newContextSelectors.push(trimmed);\n          }\n        }\n        const contextSelectorGroupsLength = contextSelectorGroups.length;\n        repeatGroups(contextSelectorGroups, newContextSelectors.length);\n        for (let i = 0; i < newContextSelectors.length; i++) {\n          for (let j = 0; j < contextSelectorGroupsLength; j++) {\n            contextSelectorGroups[j + i * contextSelectorGroupsLength].push(newContextSelectors[i]);\n          }\n        }\n        selectorText = afterPrefix.substring(endIndex + 1);\n        startIndex = selectorText.indexOf(_polyfillHostContext);\n      }\n      return contextSelectorGroups.map(contextSelectors => _combineHostContextSelectors(contextSelectors, selectorText, pseudoPrefix)).join(', ');\n    });\n  }\n  _convertShadowDOMSelectors(cssText) {\n    return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);\n  }\n  _scopeSelectors(cssText, scopeSelector, hostSelector) {\n    return processRules(cssText, rule => {\n      let selector = rule.selector;\n      let content = rule.content;\n      if (rule.selector[0] !== '@') {\n        selector = this._scopeSelector({\n          selector,\n          scopeSelector,\n          hostSelector,\n          isParentSelector: true\n        });\n      } else if (scopedAtRuleIdentifiers.some(atRule => rule.selector.startsWith(atRule))) {\n        content = this._scopeSelectors(rule.content, scopeSelector, hostSelector);\n      } else if (rule.selector.startsWith('@font-face') || rule.selector.startsWith('@page')) {\n        content = this._stripScopingSelectors(rule.content);\n      }\n      return new CssRule(selector, content);\n    });\n  }\n  _stripScopingSelectors(cssText) {\n    return processRules(cssText, rule => {\n      const selector = rule.selector.replace(_shadowDeepSelectors, ' ').replace(_polyfillHostNoCombinatorRe, ' ');\n      return new CssRule(selector, rule.content);\n    });\n  }\n  _safeSelector;\n  _shouldScopeIndicator;\n  _scopeSelector({\n    selector,\n    scopeSelector,\n    hostSelector,\n    isParentSelector = false\n  }) {\n    const selectorSplitRe = / ?,(?!(?:[^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))) ?/;\n    return selector.split(selectorSplitRe).map(part => part.split(_shadowDeepSelectors)).map(deepParts => {\n      const [shallowPart, ...otherParts] = deepParts;\n      const applyScope = shallowPart => {\n        if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {\n          return this._applySelectorScope({\n            selector: shallowPart,\n            scopeSelector,\n            hostSelector,\n            isParentSelector\n          });\n        } else {\n          return shallowPart;\n        }\n      };\n      return [applyScope(shallowPart), ...otherParts].join(' ');\n    }).join(', ');\n  }\n  _selectorNeedsScoping(selector, scopeSelector) {\n    const re = this._makeScopeMatcher(scopeSelector);\n    return !re.test(selector);\n  }\n  _makeScopeMatcher(scopeSelector) {\n    const lre = /\\[/g;\n    const rre = /\\]/g;\n    scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n    return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n  }\n  _applySimpleSelectorScope(selector, scopeSelector, hostSelector) {\n    _polyfillHostRe.lastIndex = 0;\n    if (_polyfillHostRe.test(selector)) {\n      const replaceBy = `[${hostSelector}]`;\n      let result = selector;\n      while (result.match(_polyfillHostNoCombinatorRe)) {\n        result = result.replace(_polyfillHostNoCombinatorRe, (_hnc, selector) => {\n          return selector.replace(/([^:\\)]*)(:*)(.*)/, (_, before, colon, after) => {\n            return before + replaceBy + colon + after;\n          });\n        });\n      }\n      return result.replace(_polyfillHostRe, replaceBy);\n    }\n    return scopeSelector + ' ' + selector;\n  }\n  _applySelectorScope({\n    selector,\n    scopeSelector,\n    hostSelector,\n    isParentSelector\n  }) {\n    const isRe = /\\[is=([^\\]]*)\\]/g;\n    scopeSelector = scopeSelector.replace(isRe, (_, ...parts) => parts[0]);\n    const attrName = `[${scopeSelector}]`;\n    const _scopeSelectorPart = p => {\n      let scopedP = p.trim();\n      if (!scopedP) {\n        return p;\n      }\n      if (p.includes(_polyfillHostNoCombinator)) {\n        scopedP = this._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n        if (!p.match(_polyfillHostNoCombinatorOutsidePseudoFunction)) {\n          const [_, before, colon, after] = scopedP.match(/([^:]*)(:*)([\\s\\S]*)/);\n          scopedP = before + attrName + colon + after;\n        }\n      } else {\n        const t = p.replace(_polyfillHostRe, '');\n        if (t.length > 0) {\n          const matches = t.match(/([^:]*)(:*)([\\s\\S]*)/);\n          if (matches) {\n            scopedP = matches[1] + attrName + matches[2] + matches[3];\n          }\n        }\n      }\n      return scopedP;\n    };\n    const _pseudoFunctionAwareScopeSelectorPart = selectorPart => {\n      let scopedPart = '';\n      const pseudoSelectorParts = [];\n      let pseudoSelectorMatch;\n      while ((pseudoSelectorMatch = _cssPrefixWithPseudoSelectorFunction.exec(selectorPart)) !== null) {\n        let openedBrackets = 1;\n        let index = _cssPrefixWithPseudoSelectorFunction.lastIndex;\n        while (index < selectorPart.length) {\n          const currentSymbol = selectorPart[index];\n          index++;\n          if (currentSymbol === '(') {\n            openedBrackets++;\n            continue;\n          }\n          if (currentSymbol === ')') {\n            openedBrackets--;\n            if (openedBrackets === 0) {\n              break;\n            }\n            continue;\n          }\n        }\n        pseudoSelectorParts.push(`${pseudoSelectorMatch[0]}${selectorPart.slice(_cssPrefixWithPseudoSelectorFunction.lastIndex, index)}`);\n        _cssPrefixWithPseudoSelectorFunction.lastIndex = index;\n      }\n      if (pseudoSelectorParts.join('') === selectorPart) {\n        scopedPart = pseudoSelectorParts.map(selectorPart => {\n          const [cssPseudoSelectorFunction] = selectorPart.match(_cssPrefixWithPseudoSelectorFunction) ?? [];\n          const selectorToScope = selectorPart.slice(cssPseudoSelectorFunction?.length, -1);\n          if (selectorToScope.includes(_polyfillHostNoCombinator)) {\n            this._shouldScopeIndicator = true;\n          }\n          const scopedInnerPart = this._scopeSelector({\n            selector: selectorToScope,\n            scopeSelector,\n            hostSelector\n          });\n          return `${cssPseudoSelectorFunction}${scopedInnerPart})`;\n        }).join('');\n      } else {\n        this._shouldScopeIndicator = this._shouldScopeIndicator || selectorPart.includes(_polyfillHostNoCombinator);\n        scopedPart = this._shouldScopeIndicator ? _scopeSelectorPart(selectorPart) : selectorPart;\n      }\n      return scopedPart;\n    };\n    if (isParentSelector) {\n      this._safeSelector = new SafeSelector(selector);\n      selector = this._safeSelector.content();\n    }\n    let scopedSelector = '';\n    let startIndex = 0;\n    let res;\n    const sep = /( |>|\\+|~(?!=))(?!([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)))\\s*/g;\n    const hasHost = selector.includes(_polyfillHostNoCombinator);\n    if (isParentSelector || this._shouldScopeIndicator) {\n      this._shouldScopeIndicator = !hasHost;\n    }\n    while ((res = sep.exec(selector)) !== null) {\n      const separator = res[1];\n      const part = selector.slice(startIndex, res.index);\n      if (part.match(/__esc-ph-(\\d+)__/) && selector[res.index + 1]?.match(/[a-fA-F\\d]/)) {\n        continue;\n      }\n      const scopedPart = _pseudoFunctionAwareScopeSelectorPart(part);\n      scopedSelector += `${scopedPart} ${separator} `;\n      startIndex = sep.lastIndex;\n    }\n    const part = selector.substring(startIndex);\n    scopedSelector += _pseudoFunctionAwareScopeSelectorPart(part);\n    return this._safeSelector.restore(scopedSelector);\n  }\n  _insertPolyfillHostInCssText(selector) {\n    return selector.replace(_colonHostContextRe, _polyfillHostContext).replace(_colonHostRe, _polyfillHost);\n  }\n}\nclass SafeSelector {\n  placeholders = [];\n  index = 0;\n  _content;\n  constructor(selector) {\n    selector = this._escapeRegexMatches(selector, /(\\[[^\\]]*\\])/g);\n    selector = selector.replace(/(\\\\.)/g, (_, keep) => {\n      const replaceBy = `__esc-ph-${this.index}__`;\n      this.placeholders.push(keep);\n      this.index++;\n      return replaceBy;\n    });\n    this._content = selector.replace(nthRegex, (_, pseudo, exp) => {\n      const replaceBy = `__ph-${this.index}__`;\n      this.placeholders.push(`(${exp})`);\n      this.index++;\n      return pseudo + replaceBy;\n    });\n  }\n  restore(content) {\n    return content.replace(/__(?:ph|esc-ph)-(\\d+)__/g, (_ph, index) => this.placeholders[+index]);\n  }\n  content() {\n    return this._content;\n  }\n  _escapeRegexMatches(content, pattern) {\n    return content.replace(pattern, (_, keep) => {\n      const replaceBy = `__ph-${this.index}__`;\n      this.placeholders.push(keep);\n      this.index++;\n      return replaceBy;\n    });\n  }\n}\nconst _cssScopedPseudoFunctionPrefix = '(:(where|is)\\\\()?';\nconst _cssPrefixWithPseudoSelectorFunction = /:(where|is)\\(/gi;\nconst _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\\s]*?(['\"])(.*?)\\1[;\\s]*}([^{]*?){/gim;\nconst _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _polyfillHost = '-shadowcsshost';\nconst _polyfillHostContext = '-shadowcsscontext';\nconst _noParens = '[^)(]*';\nconst _level1Parens = String.raw`(?:\\(${_noParens}\\)|${_noParens})+?`;\nconst _level2Parens = String.raw`(?:\\(${_level1Parens}\\)|${_noParens})+?`;\nconst _parenSuffix = String.raw`(?:\\((${_level2Parens})\\))`;\nconst nthRegex = new RegExp(String.raw`(:nth-[-\\w]+)` + _parenSuffix, 'g');\nconst _cssColonHostRe = new RegExp(_polyfillHost + _parenSuffix + '?([^,{]*)', 'gim');\nconst _hostContextPattern = _polyfillHostContext + _parenSuffix + '?([^{]*)';\nconst _cssColonHostContextReGlobal = new RegExp(`${_cssScopedPseudoFunctionPrefix}(${_hostContextPattern})`, 'gim');\nconst _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\nconst _polyfillHostNoCombinatorOutsidePseudoFunction = new RegExp(`${_polyfillHostNoCombinator}(?![^(]*\\\\))`, 'g');\nconst _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s,]*)/;\nconst _shadowDOMSelectorsRe = [/::shadow/g, /::content/g, /\\/shadow-deep\\//g, /\\/shadow\\//g];\nconst _shadowDeepSelectors = /(?:>>>)|(?:\\/deep\\/)|(?:::ng-deep)/g;\nconst _selectorReSuffix = '([>\\\\s~+[.,{:][\\\\s\\\\S]*)?$';\nconst _polyfillHostRe = /-shadowcsshost/gim;\nconst _colonHostRe = /:host/gim;\nconst _colonHostContextRe = /:host-context/gim;\nconst _newLinesRe = /\\r?\\n/g;\nconst _commentRe = /\\/\\*[\\s\\S]*?\\*\\//g;\nconst _commentWithHashRe = /\\/\\*\\s*#\\s*source(Mapping)?URL=/g;\nconst COMMENT_PLACEHOLDER = '%COMMENT%';\nconst _commentWithHashPlaceHolderRe = new RegExp(COMMENT_PLACEHOLDER, 'g');\nconst BLOCK_PLACEHOLDER = '%BLOCK%';\nconst _ruleRe = new RegExp(`(\\\\s*(?:${COMMENT_PLACEHOLDER}\\\\s*)*)([^;\\\\{\\\\}]+?)(\\\\s*)((?:{%BLOCK%}?\\\\s*;?)|(?:\\\\s*;))`, 'g');\nconst CONTENT_PAIRS = new Map([['{', '}']]);\nconst COMMA_IN_PLACEHOLDER = '%COMMA_IN_PLACEHOLDER%';\nconst SEMI_IN_PLACEHOLDER = '%SEMI_IN_PLACEHOLDER%';\nconst COLON_IN_PLACEHOLDER = '%COLON_IN_PLACEHOLDER%';\nconst _cssCommaInPlaceholderReGlobal = new RegExp(COMMA_IN_PLACEHOLDER, 'g');\nconst _cssSemiInPlaceholderReGlobal = new RegExp(SEMI_IN_PLACEHOLDER, 'g');\nconst _cssColonInPlaceholderReGlobal = new RegExp(COLON_IN_PLACEHOLDER, 'g');\nclass CssRule {\n  selector;\n  content;\n  constructor(selector, content) {\n    this.selector = selector;\n    this.content = content;\n  }\n}\nfunction processRules(input, ruleCallback) {\n  const escaped = escapeInStrings(input);\n  const inputWithEscapedBlocks = escapeBlocks(escaped, CONTENT_PAIRS, BLOCK_PLACEHOLDER);\n  let nextBlockIndex = 0;\n  const escapedResult = inputWithEscapedBlocks.escapedString.replace(_ruleRe, (...m) => {\n    const selector = m[2];\n    let content = '';\n    let suffix = m[4];\n    let contentPrefix = '';\n    if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n      content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n      suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n      contentPrefix = '{';\n    }\n    const rule = ruleCallback(new CssRule(selector, content));\n    return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;\n  });\n  return unescapeInStrings(escapedResult);\n}\nclass StringWithEscapedBlocks {\n  escapedString;\n  blocks;\n  constructor(escapedString, blocks) {\n    this.escapedString = escapedString;\n    this.blocks = blocks;\n  }\n}\nfunction escapeBlocks(input, charPairs, placeholder) {\n  const resultParts = [];\n  const escapedBlocks = [];\n  let openCharCount = 0;\n  let nonBlockStartIndex = 0;\n  let blockStartIndex = -1;\n  let openChar;\n  let closeChar;\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    if (char === '\\\\') {\n      i++;\n    } else if (char === closeChar) {\n      openCharCount--;\n      if (openCharCount === 0) {\n        escapedBlocks.push(input.substring(blockStartIndex, i));\n        resultParts.push(placeholder);\n        nonBlockStartIndex = i;\n        blockStartIndex = -1;\n        openChar = closeChar = undefined;\n      }\n    } else if (char === openChar) {\n      openCharCount++;\n    } else if (openCharCount === 0 && charPairs.has(char)) {\n      openChar = char;\n      closeChar = charPairs.get(char);\n      openCharCount = 1;\n      blockStartIndex = i + 1;\n      resultParts.push(input.substring(nonBlockStartIndex, blockStartIndex));\n    }\n  }\n  if (blockStartIndex !== -1) {\n    escapedBlocks.push(input.substring(blockStartIndex));\n    resultParts.push(placeholder);\n  } else {\n    resultParts.push(input.substring(nonBlockStartIndex));\n  }\n  return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n}\nconst ESCAPE_IN_STRING_MAP = {\n  ';': SEMI_IN_PLACEHOLDER,\n  ',': COMMA_IN_PLACEHOLDER,\n  ':': COLON_IN_PLACEHOLDER\n};\nfunction escapeInStrings(input) {\n  let result = input;\n  let currentQuoteChar = null;\n  for (let i = 0; i < result.length; i++) {\n    const char = result[i];\n    if (char === '\\\\') {\n      i++;\n    } else {\n      if (currentQuoteChar !== null) {\n        if (char === currentQuoteChar) {\n          currentQuoteChar = null;\n        } else {\n          const placeholder = ESCAPE_IN_STRING_MAP[char];\n          if (placeholder) {\n            result = `${result.substr(0, i)}${placeholder}${result.substr(i + 1)}`;\n            i += placeholder.length - 1;\n          }\n        }\n      } else if (char === \"'\" || char === '\"') {\n        currentQuoteChar = char;\n      }\n    }\n  }\n  return result;\n}\nfunction unescapeInStrings(input) {\n  let result = input.replace(_cssCommaInPlaceholderReGlobal, ',');\n  result = result.replace(_cssSemiInPlaceholderReGlobal, ';');\n  result = result.replace(_cssColonInPlaceholderReGlobal, ':');\n  return result;\n}\nfunction unescapeQuotes(str, isQuoted) {\n  return !isQuoted ? str : str.replace(/((?:^|[^\\\\])(?:\\\\\\\\)*)\\\\(?=['\"])/g, '$1');\n}\nfunction _combineHostContextSelectors(contextSelectors, otherSelectors, pseudoPrefix = '') {\n  const hostMarker = _polyfillHostNoCombinator;\n  _polyfillHostRe.lastIndex = 0;\n  const otherSelectorsHasHost = _polyfillHostRe.test(otherSelectors);\n  if (contextSelectors.length === 0) {\n    return hostMarker + otherSelectors;\n  }\n  const combined = [contextSelectors.pop() || ''];\n  while (contextSelectors.length > 0) {\n    const length = combined.length;\n    const contextSelector = contextSelectors.pop();\n    for (let i = 0; i < length; i++) {\n      const previousSelectors = combined[i];\n      combined[length * 2 + i] = previousSelectors + ' ' + contextSelector;\n      combined[length + i] = contextSelector + ' ' + previousSelectors;\n      combined[i] = contextSelector + previousSelectors;\n    }\n  }\n  return combined.map(s => otherSelectorsHasHost ? `${pseudoPrefix}${s}${otherSelectors}` : `${pseudoPrefix}${s}${hostMarker}${otherSelectors}, ${pseudoPrefix}${s} ${hostMarker}${otherSelectors}`).join(',');\n}\nfunction repeatGroups(groups, multiples) {\n  const length = groups.length;\n  for (let i = 1; i < multiples; i++) {\n    for (let j = 0; j < length; j++) {\n      groups[j + i * length] = groups[j].slice(0);\n    }\n  }\n}\n\nvar OpKind;\n(function (OpKind) {\n  OpKind[OpKind[\"ListEnd\"] = 0] = \"ListEnd\";\n  OpKind[OpKind[\"Statement\"] = 1] = \"Statement\";\n  OpKind[OpKind[\"Variable\"] = 2] = \"Variable\";\n  OpKind[OpKind[\"ElementStart\"] = 3] = \"ElementStart\";\n  OpKind[OpKind[\"Element\"] = 4] = \"Element\";\n  OpKind[OpKind[\"Template\"] = 5] = \"Template\";\n  OpKind[OpKind[\"ElementEnd\"] = 6] = \"ElementEnd\";\n  OpKind[OpKind[\"ContainerStart\"] = 7] = \"ContainerStart\";\n  OpKind[OpKind[\"Container\"] = 8] = \"Container\";\n  OpKind[OpKind[\"ContainerEnd\"] = 9] = \"ContainerEnd\";\n  OpKind[OpKind[\"DisableBindings\"] = 10] = \"DisableBindings\";\n  OpKind[OpKind[\"ConditionalCreate\"] = 11] = \"ConditionalCreate\";\n  OpKind[OpKind[\"ConditionalBranchCreate\"] = 12] = \"ConditionalBranchCreate\";\n  OpKind[OpKind[\"Conditional\"] = 13] = \"Conditional\";\n  OpKind[OpKind[\"EnableBindings\"] = 14] = \"EnableBindings\";\n  OpKind[OpKind[\"Text\"] = 15] = \"Text\";\n  OpKind[OpKind[\"Listener\"] = 16] = \"Listener\";\n  OpKind[OpKind[\"InterpolateText\"] = 17] = \"InterpolateText\";\n  OpKind[OpKind[\"Binding\"] = 18] = \"Binding\";\n  OpKind[OpKind[\"Property\"] = 19] = \"Property\";\n  OpKind[OpKind[\"StyleProp\"] = 20] = \"StyleProp\";\n  OpKind[OpKind[\"ClassProp\"] = 21] = \"ClassProp\";\n  OpKind[OpKind[\"StyleMap\"] = 22] = \"StyleMap\";\n  OpKind[OpKind[\"ClassMap\"] = 23] = \"ClassMap\";\n  OpKind[OpKind[\"Advance\"] = 24] = \"Advance\";\n  OpKind[OpKind[\"Pipe\"] = 25] = \"Pipe\";\n  OpKind[OpKind[\"Attribute\"] = 26] = \"Attribute\";\n  OpKind[OpKind[\"ExtractedAttribute\"] = 27] = \"ExtractedAttribute\";\n  OpKind[OpKind[\"Defer\"] = 28] = \"Defer\";\n  OpKind[OpKind[\"DeferOn\"] = 29] = \"DeferOn\";\n  OpKind[OpKind[\"DeferWhen\"] = 30] = \"DeferWhen\";\n  OpKind[OpKind[\"I18nMessage\"] = 31] = \"I18nMessage\";\n  OpKind[OpKind[\"DomProperty\"] = 32] = \"DomProperty\";\n  OpKind[OpKind[\"Namespace\"] = 33] = \"Namespace\";\n  OpKind[OpKind[\"ProjectionDef\"] = 34] = \"ProjectionDef\";\n  OpKind[OpKind[\"Projection\"] = 35] = \"Projection\";\n  OpKind[OpKind[\"RepeaterCreate\"] = 36] = \"RepeaterCreate\";\n  OpKind[OpKind[\"Repeater\"] = 37] = \"Repeater\";\n  OpKind[OpKind[\"TwoWayProperty\"] = 38] = \"TwoWayProperty\";\n  OpKind[OpKind[\"TwoWayListener\"] = 39] = \"TwoWayListener\";\n  OpKind[OpKind[\"DeclareLet\"] = 40] = \"DeclareLet\";\n  OpKind[OpKind[\"StoreLet\"] = 41] = \"StoreLet\";\n  OpKind[OpKind[\"I18nStart\"] = 42] = \"I18nStart\";\n  OpKind[OpKind[\"I18n\"] = 43] = \"I18n\";\n  OpKind[OpKind[\"I18nEnd\"] = 44] = \"I18nEnd\";\n  OpKind[OpKind[\"I18nExpression\"] = 45] = \"I18nExpression\";\n  OpKind[OpKind[\"I18nApply\"] = 46] = \"I18nApply\";\n  OpKind[OpKind[\"IcuStart\"] = 47] = \"IcuStart\";\n  OpKind[OpKind[\"IcuEnd\"] = 48] = \"IcuEnd\";\n  OpKind[OpKind[\"IcuPlaceholder\"] = 49] = \"IcuPlaceholder\";\n  OpKind[OpKind[\"I18nContext\"] = 50] = \"I18nContext\";\n  OpKind[OpKind[\"I18nAttributes\"] = 51] = \"I18nAttributes\";\n  OpKind[OpKind[\"SourceLocation\"] = 52] = \"SourceLocation\";\n  OpKind[OpKind[\"Animation\"] = 53] = \"Animation\";\n  OpKind[OpKind[\"AnimationString\"] = 54] = \"AnimationString\";\n  OpKind[OpKind[\"AnimationBinding\"] = 55] = \"AnimationBinding\";\n  OpKind[OpKind[\"AnimationListener\"] = 56] = \"AnimationListener\";\n  OpKind[OpKind[\"Control\"] = 57] = \"Control\";\n  OpKind[OpKind[\"ControlCreate\"] = 58] = \"ControlCreate\";\n})(OpKind || (OpKind = {}));\nvar ExpressionKind;\n(function (ExpressionKind) {\n  ExpressionKind[ExpressionKind[\"LexicalRead\"] = 0] = \"LexicalRead\";\n  ExpressionKind[ExpressionKind[\"Context\"] = 1] = \"Context\";\n  ExpressionKind[ExpressionKind[\"TrackContext\"] = 2] = \"TrackContext\";\n  ExpressionKind[ExpressionKind[\"ReadVariable\"] = 3] = \"ReadVariable\";\n  ExpressionKind[ExpressionKind[\"NextContext\"] = 4] = \"NextContext\";\n  ExpressionKind[ExpressionKind[\"Reference\"] = 5] = \"Reference\";\n  ExpressionKind[ExpressionKind[\"StoreLet\"] = 6] = \"StoreLet\";\n  ExpressionKind[ExpressionKind[\"ContextLetReference\"] = 7] = \"ContextLetReference\";\n  ExpressionKind[ExpressionKind[\"GetCurrentView\"] = 8] = \"GetCurrentView\";\n  ExpressionKind[ExpressionKind[\"RestoreView\"] = 9] = \"RestoreView\";\n  ExpressionKind[ExpressionKind[\"ResetView\"] = 10] = \"ResetView\";\n  ExpressionKind[ExpressionKind[\"PureFunctionExpr\"] = 11] = \"PureFunctionExpr\";\n  ExpressionKind[ExpressionKind[\"PureFunctionParameterExpr\"] = 12] = \"PureFunctionParameterExpr\";\n  ExpressionKind[ExpressionKind[\"PipeBinding\"] = 13] = \"PipeBinding\";\n  ExpressionKind[ExpressionKind[\"PipeBindingVariadic\"] = 14] = \"PipeBindingVariadic\";\n  ExpressionKind[ExpressionKind[\"SafePropertyRead\"] = 15] = \"SafePropertyRead\";\n  ExpressionKind[ExpressionKind[\"SafeKeyedRead\"] = 16] = \"SafeKeyedRead\";\n  ExpressionKind[ExpressionKind[\"SafeInvokeFunction\"] = 17] = \"SafeInvokeFunction\";\n  ExpressionKind[ExpressionKind[\"SafeTernaryExpr\"] = 18] = \"SafeTernaryExpr\";\n  ExpressionKind[ExpressionKind[\"EmptyExpr\"] = 19] = \"EmptyExpr\";\n  ExpressionKind[ExpressionKind[\"AssignTemporaryExpr\"] = 20] = \"AssignTemporaryExpr\";\n  ExpressionKind[ExpressionKind[\"ReadTemporaryExpr\"] = 21] = \"ReadTemporaryExpr\";\n  ExpressionKind[ExpressionKind[\"SlotLiteralExpr\"] = 22] = \"SlotLiteralExpr\";\n  ExpressionKind[ExpressionKind[\"ConditionalCase\"] = 23] = \"ConditionalCase\";\n  ExpressionKind[ExpressionKind[\"ConstCollected\"] = 24] = \"ConstCollected\";\n  ExpressionKind[ExpressionKind[\"TwoWayBindingSet\"] = 25] = \"TwoWayBindingSet\";\n})(ExpressionKind || (ExpressionKind = {}));\nvar VariableFlags;\n(function (VariableFlags) {\n  VariableFlags[VariableFlags[\"None\"] = 0] = \"None\";\n  VariableFlags[VariableFlags[\"AlwaysInline\"] = 1] = \"AlwaysInline\";\n})(VariableFlags || (VariableFlags = {}));\nvar SemanticVariableKind;\n(function (SemanticVariableKind) {\n  SemanticVariableKind[SemanticVariableKind[\"Context\"] = 0] = \"Context\";\n  SemanticVariableKind[SemanticVariableKind[\"Identifier\"] = 1] = \"Identifier\";\n  SemanticVariableKind[SemanticVariableKind[\"SavedView\"] = 2] = \"SavedView\";\n  SemanticVariableKind[SemanticVariableKind[\"Alias\"] = 3] = \"Alias\";\n})(SemanticVariableKind || (SemanticVariableKind = {}));\nvar CompatibilityMode;\n(function (CompatibilityMode) {\n  CompatibilityMode[CompatibilityMode[\"Normal\"] = 0] = \"Normal\";\n  CompatibilityMode[CompatibilityMode[\"TemplateDefinitionBuilder\"] = 1] = \"TemplateDefinitionBuilder\";\n})(CompatibilityMode || (CompatibilityMode = {}));\nvar BindingKind;\n(function (BindingKind) {\n  BindingKind[BindingKind[\"Attribute\"] = 0] = \"Attribute\";\n  BindingKind[BindingKind[\"ClassName\"] = 1] = \"ClassName\";\n  BindingKind[BindingKind[\"StyleProperty\"] = 2] = \"StyleProperty\";\n  BindingKind[BindingKind[\"Property\"] = 3] = \"Property\";\n  BindingKind[BindingKind[\"Template\"] = 4] = \"Template\";\n  BindingKind[BindingKind[\"I18n\"] = 5] = \"I18n\";\n  BindingKind[BindingKind[\"LegacyAnimation\"] = 6] = \"LegacyAnimation\";\n  BindingKind[BindingKind[\"TwoWayProperty\"] = 7] = \"TwoWayProperty\";\n  BindingKind[BindingKind[\"Animation\"] = 8] = \"Animation\";\n})(BindingKind || (BindingKind = {}));\nvar I18nParamResolutionTime;\n(function (I18nParamResolutionTime) {\n  I18nParamResolutionTime[I18nParamResolutionTime[\"Creation\"] = 0] = \"Creation\";\n  I18nParamResolutionTime[I18nParamResolutionTime[\"Postproccessing\"] = 1] = \"Postproccessing\";\n})(I18nParamResolutionTime || (I18nParamResolutionTime = {}));\nvar I18nExpressionFor;\n(function (I18nExpressionFor) {\n  I18nExpressionFor[I18nExpressionFor[\"I18nText\"] = 0] = \"I18nText\";\n  I18nExpressionFor[I18nExpressionFor[\"I18nAttribute\"] = 1] = \"I18nAttribute\";\n})(I18nExpressionFor || (I18nExpressionFor = {}));\nvar I18nParamValueFlags;\n(function (I18nParamValueFlags) {\n  I18nParamValueFlags[I18nParamValueFlags[\"None\"] = 0] = \"None\";\n  I18nParamValueFlags[I18nParamValueFlags[\"ElementTag\"] = 1] = \"ElementTag\";\n  I18nParamValueFlags[I18nParamValueFlags[\"TemplateTag\"] = 2] = \"TemplateTag\";\n  I18nParamValueFlags[I18nParamValueFlags[\"OpenTag\"] = 4] = \"OpenTag\";\n  I18nParamValueFlags[I18nParamValueFlags[\"CloseTag\"] = 8] = \"CloseTag\";\n  I18nParamValueFlags[I18nParamValueFlags[\"ExpressionIndex\"] = 16] = \"ExpressionIndex\";\n})(I18nParamValueFlags || (I18nParamValueFlags = {}));\nvar Namespace;\n(function (Namespace) {\n  Namespace[Namespace[\"HTML\"] = 0] = \"HTML\";\n  Namespace[Namespace[\"SVG\"] = 1] = \"SVG\";\n  Namespace[Namespace[\"Math\"] = 2] = \"Math\";\n})(Namespace || (Namespace = {}));\nvar DeferTriggerKind;\n(function (DeferTriggerKind) {\n  DeferTriggerKind[DeferTriggerKind[\"Idle\"] = 0] = \"Idle\";\n  DeferTriggerKind[DeferTriggerKind[\"Immediate\"] = 1] = \"Immediate\";\n  DeferTriggerKind[DeferTriggerKind[\"Timer\"] = 2] = \"Timer\";\n  DeferTriggerKind[DeferTriggerKind[\"Hover\"] = 3] = \"Hover\";\n  DeferTriggerKind[DeferTriggerKind[\"Interaction\"] = 4] = \"Interaction\";\n  DeferTriggerKind[DeferTriggerKind[\"Viewport\"] = 5] = \"Viewport\";\n  DeferTriggerKind[DeferTriggerKind[\"Never\"] = 6] = \"Never\";\n})(DeferTriggerKind || (DeferTriggerKind = {}));\nvar I18nContextKind;\n(function (I18nContextKind) {\n  I18nContextKind[I18nContextKind[\"RootI18n\"] = 0] = \"RootI18n\";\n  I18nContextKind[I18nContextKind[\"Icu\"] = 1] = \"Icu\";\n  I18nContextKind[I18nContextKind[\"Attr\"] = 2] = \"Attr\";\n})(I18nContextKind || (I18nContextKind = {}));\nvar TemplateKind;\n(function (TemplateKind) {\n  TemplateKind[TemplateKind[\"NgTemplate\"] = 0] = \"NgTemplate\";\n  TemplateKind[TemplateKind[\"Structural\"] = 1] = \"Structural\";\n  TemplateKind[TemplateKind[\"Block\"] = 2] = \"Block\";\n})(TemplateKind || (TemplateKind = {}));\n\nconst ConsumesSlot = Symbol('ConsumesSlot');\nconst DependsOnSlotContext = Symbol('DependsOnSlotContext');\nconst ConsumesVarsTrait = Symbol('ConsumesVars');\nconst UsesVarOffset = Symbol('UsesVarOffset');\nconst TRAIT_CONSUMES_SLOT = {\n  [ConsumesSlot]: true,\n  numSlotsUsed: 1\n};\nconst TRAIT_DEPENDS_ON_SLOT_CONTEXT = {\n  [DependsOnSlotContext]: true\n};\nconst TRAIT_CONSUMES_VARS = {\n  [ConsumesVarsTrait]: true\n};\nfunction hasConsumesSlotTrait(op) {\n  return op[ConsumesSlot] === true;\n}\nfunction hasDependsOnSlotContextTrait(value) {\n  return value[DependsOnSlotContext] === true;\n}\nfunction hasConsumesVarsTrait(value) {\n  return value[ConsumesVarsTrait] === true;\n}\nfunction hasUsesVarOffsetTrait(expr) {\n  return expr[UsesVarOffset] === true;\n}\n\nfunction createStatementOp(statement) {\n  return {\n    kind: OpKind.Statement,\n    statement,\n    ...NEW_OP\n  };\n}\nfunction createVariableOp(xref, variable, initializer, flags) {\n  return {\n    kind: OpKind.Variable,\n    xref,\n    variable,\n    initializer,\n    flags,\n    ...NEW_OP\n  };\n}\nconst NEW_OP = {\n  debugListId: null,\n  prev: null,\n  next: null\n};\n\nfunction createInterpolateTextOp(xref, interpolation, sourceSpan) {\n  return {\n    kind: OpKind.InterpolateText,\n    target: xref,\n    interpolation,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nclass Interpolation {\n  strings;\n  expressions;\n  i18nPlaceholders;\n  constructor(strings, expressions, i18nPlaceholders) {\n    this.strings = strings;\n    this.expressions = expressions;\n    this.i18nPlaceholders = i18nPlaceholders;\n    if (i18nPlaceholders.length !== 0 && i18nPlaceholders.length !== expressions.length) {\n      throw new Error(`Expected ${expressions.length} placeholders to match interpolation expression count, but got ${i18nPlaceholders.length}`);\n    }\n  }\n}\nfunction createBindingOp(target, kind, name, expression, unit, securityContext, isTextAttribute, isStructuralTemplateAttribute, templateKind, i18nMessage, sourceSpan) {\n  return {\n    kind: OpKind.Binding,\n    bindingKind: kind,\n    target,\n    name,\n    expression,\n    unit,\n    securityContext,\n    isTextAttribute,\n    isStructuralTemplateAttribute,\n    templateKind,\n    i18nContext: null,\n    i18nMessage,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createPropertyOp(target, name, expression, bindingKind, securityContext, isStructuralTemplateAttribute, templateKind, i18nContext, i18nMessage, sourceSpan) {\n  return {\n    kind: OpKind.Property,\n    target,\n    name,\n    expression,\n    bindingKind,\n    securityContext,\n    sanitizer: null,\n    isStructuralTemplateAttribute,\n    templateKind,\n    i18nContext,\n    i18nMessage,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createTwoWayPropertyOp(target, name, expression, securityContext, isStructuralTemplateAttribute, templateKind, i18nContext, i18nMessage, sourceSpan) {\n  return {\n    kind: OpKind.TwoWayProperty,\n    target,\n    name,\n    expression,\n    securityContext,\n    sanitizer: null,\n    isStructuralTemplateAttribute,\n    templateKind,\n    i18nContext,\n    i18nMessage,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createStylePropOp(xref, name, expression, unit, sourceSpan) {\n  return {\n    kind: OpKind.StyleProp,\n    target: xref,\n    name,\n    expression,\n    unit,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createClassPropOp(xref, name, expression, sourceSpan) {\n  return {\n    kind: OpKind.ClassProp,\n    target: xref,\n    name,\n    expression,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createStyleMapOp(xref, expression, sourceSpan) {\n  return {\n    kind: OpKind.StyleMap,\n    target: xref,\n    expression,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createClassMapOp(xref, expression, sourceSpan) {\n  return {\n    kind: OpKind.ClassMap,\n    target: xref,\n    expression,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createAttributeOp(target, namespace, name, expression, securityContext, isTextAttribute, isStructuralTemplateAttribute, templateKind, i18nMessage, sourceSpan) {\n  return {\n    kind: OpKind.Attribute,\n    target,\n    namespace,\n    name,\n    expression,\n    securityContext,\n    sanitizer: null,\n    isTextAttribute,\n    isStructuralTemplateAttribute,\n    templateKind,\n    i18nContext: null,\n    i18nMessage,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createAdvanceOp(delta, sourceSpan) {\n  return {\n    kind: OpKind.Advance,\n    delta,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createConditionalOp(target, test, conditions, sourceSpan) {\n  return {\n    kind: OpKind.Conditional,\n    target,\n    test,\n    conditions,\n    processed: null,\n    sourceSpan,\n    contextValue: null,\n    ...NEW_OP,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS\n  };\n}\nfunction createRepeaterOp(repeaterCreate, targetSlot, collection, sourceSpan) {\n  return {\n    kind: OpKind.Repeater,\n    target: repeaterCreate,\n    targetSlot,\n    collection,\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT\n  };\n}\nfunction createAnimationBindingOp(name, target, animationKind, expression, securityContext, sourceSpan, animationBindingKind) {\n  return {\n    kind: OpKind.AnimationBinding,\n    name,\n    target,\n    animationKind,\n    expression,\n    i18nMessage: null,\n    securityContext,\n    sanitizer: null,\n    sourceSpan,\n    animationBindingKind,\n    ...NEW_OP\n  };\n}\nfunction createDeferWhenOp(target, expr, modifier, sourceSpan) {\n  return {\n    kind: OpKind.DeferWhen,\n    target,\n    expr,\n    modifier,\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS\n  };\n}\nfunction createI18nExpressionOp(context, target, i18nOwner, handle, expression, icuPlaceholder, i18nPlaceholder, resolutionTime, usage, name, sourceSpan) {\n  return {\n    kind: OpKind.I18nExpression,\n    context,\n    target,\n    i18nOwner,\n    handle,\n    expression,\n    icuPlaceholder,\n    i18nPlaceholder,\n    resolutionTime,\n    usage,\n    name,\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_VARS,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT\n  };\n}\nfunction createI18nApplyOp(owner, handle, sourceSpan) {\n  return {\n    kind: OpKind.I18nApply,\n    owner,\n    handle,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createStoreLetOp(target, declaredName, value, sourceSpan) {\n  return {\n    kind: OpKind.StoreLet,\n    target,\n    declaredName,\n    value,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\nfunction createControlOp(op) {\n  return {\n    kind: OpKind.Control,\n    target: op.target,\n    expression: op.expression,\n    bindingKind: op.bindingKind,\n    securityContext: op.securityContext,\n    sanitizer: null,\n    isStructuralTemplateAttribute: op.isStructuralTemplateAttribute,\n    templateKind: op.templateKind,\n    i18nContext: op.i18nContext,\n    i18nMessage: op.i18nMessage,\n    sourceSpan: op.sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\n\nfunction isIrExpression(expr) {\n  return expr instanceof ExpressionBase;\n}\nclass ExpressionBase extends Expression {\n  constructor(sourceSpan = null) {\n    super(null, sourceSpan);\n  }\n}\nclass LexicalReadExpr extends ExpressionBase {\n  name;\n  kind = ExpressionKind.LexicalRead;\n  constructor(name) {\n    super();\n    this.name = name;\n  }\n  visitExpression(visitor, context) {}\n  isEquivalent(other) {\n    return this.name === other.name;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    return new LexicalReadExpr(this.name);\n  }\n}\nclass ReferenceExpr extends ExpressionBase {\n  target;\n  targetSlot;\n  offset;\n  kind = ExpressionKind.Reference;\n  constructor(target, targetSlot, offset) {\n    super();\n    this.target = target;\n    this.targetSlot = targetSlot;\n    this.offset = offset;\n  }\n  visitExpression() {}\n  isEquivalent(e) {\n    return e instanceof ReferenceExpr && e.target === this.target;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    return new ReferenceExpr(this.target, this.targetSlot, this.offset);\n  }\n}\nclass StoreLetExpr extends ExpressionBase {\n  target;\n  value;\n  sourceSpan;\n  kind = ExpressionKind.StoreLet;\n  [ConsumesVarsTrait] = true;\n  [DependsOnSlotContext] = true;\n  constructor(target, value, sourceSpan) {\n    super();\n    this.target = target;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n  visitExpression() {}\n  isEquivalent(e) {\n    return e instanceof StoreLetExpr && e.target === this.target && e.value.isEquivalent(this.value);\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.value = transformExpressionsInExpression(this.value, transform, flags);\n  }\n  clone() {\n    return new StoreLetExpr(this.target, this.value, this.sourceSpan);\n  }\n}\nclass ContextLetReferenceExpr extends ExpressionBase {\n  target;\n  targetSlot;\n  kind = ExpressionKind.ContextLetReference;\n  constructor(target, targetSlot) {\n    super();\n    this.target = target;\n    this.targetSlot = targetSlot;\n  }\n  visitExpression() {}\n  isEquivalent(e) {\n    return e instanceof ContextLetReferenceExpr && e.target === this.target;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    return new ContextLetReferenceExpr(this.target, this.targetSlot);\n  }\n}\nclass ContextExpr extends ExpressionBase {\n  view;\n  kind = ExpressionKind.Context;\n  constructor(view) {\n    super();\n    this.view = view;\n  }\n  visitExpression() {}\n  isEquivalent(e) {\n    return e instanceof ContextExpr && e.view === this.view;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    return new ContextExpr(this.view);\n  }\n}\nclass TrackContextExpr extends ExpressionBase {\n  view;\n  kind = ExpressionKind.TrackContext;\n  constructor(view) {\n    super();\n    this.view = view;\n  }\n  visitExpression() {}\n  isEquivalent(e) {\n    return e instanceof TrackContextExpr && e.view === this.view;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    return new TrackContextExpr(this.view);\n  }\n}\nclass NextContextExpr extends ExpressionBase {\n  kind = ExpressionKind.NextContext;\n  steps = 1;\n  constructor() {\n    super();\n  }\n  visitExpression() {}\n  isEquivalent(e) {\n    return e instanceof NextContextExpr && e.steps === this.steps;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    const expr = new NextContextExpr();\n    expr.steps = this.steps;\n    return expr;\n  }\n}\nclass GetCurrentViewExpr extends ExpressionBase {\n  kind = ExpressionKind.GetCurrentView;\n  constructor() {\n    super();\n  }\n  visitExpression() {}\n  isEquivalent(e) {\n    return e instanceof GetCurrentViewExpr;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    return new GetCurrentViewExpr();\n  }\n}\nclass RestoreViewExpr extends ExpressionBase {\n  view;\n  kind = ExpressionKind.RestoreView;\n  constructor(view) {\n    super();\n    this.view = view;\n  }\n  visitExpression(visitor, context) {\n    if (typeof this.view !== 'number') {\n      this.view.visitExpression(visitor, context);\n    }\n  }\n  isEquivalent(e) {\n    if (!(e instanceof RestoreViewExpr) || typeof e.view !== typeof this.view) {\n      return false;\n    }\n    if (typeof this.view === 'number') {\n      return this.view === e.view;\n    } else {\n      return this.view.isEquivalent(e.view);\n    }\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    if (typeof this.view !== 'number') {\n      this.view = transformExpressionsInExpression(this.view, transform, flags);\n    }\n  }\n  clone() {\n    return new RestoreViewExpr(this.view instanceof Expression ? this.view.clone() : this.view);\n  }\n}\nclass ResetViewExpr extends ExpressionBase {\n  expr;\n  kind = ExpressionKind.ResetView;\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n  visitExpression(visitor, context) {\n    this.expr.visitExpression(visitor, context);\n  }\n  isEquivalent(e) {\n    return e instanceof ResetViewExpr && this.expr.isEquivalent(e.expr);\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n  }\n  clone() {\n    return new ResetViewExpr(this.expr.clone());\n  }\n}\nclass TwoWayBindingSetExpr extends ExpressionBase {\n  target;\n  value;\n  kind = ExpressionKind.TwoWayBindingSet;\n  constructor(target, value) {\n    super();\n    this.target = target;\n    this.value = value;\n  }\n  visitExpression(visitor, context) {\n    this.target.visitExpression(visitor, context);\n    this.value.visitExpression(visitor, context);\n  }\n  isEquivalent(other) {\n    return this.target.isEquivalent(other.target) && this.value.isEquivalent(other.value);\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.target = transformExpressionsInExpression(this.target, transform, flags);\n    this.value = transformExpressionsInExpression(this.value, transform, flags);\n  }\n  clone() {\n    return new TwoWayBindingSetExpr(this.target, this.value);\n  }\n}\nclass ReadVariableExpr extends ExpressionBase {\n  xref;\n  kind = ExpressionKind.ReadVariable;\n  name = null;\n  constructor(xref) {\n    super();\n    this.xref = xref;\n  }\n  visitExpression() {}\n  isEquivalent(other) {\n    return other instanceof ReadVariableExpr && other.xref === this.xref;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    const expr = new ReadVariableExpr(this.xref);\n    expr.name = this.name;\n    return expr;\n  }\n}\nclass PureFunctionExpr extends ExpressionBase {\n  kind = ExpressionKind.PureFunctionExpr;\n  [ConsumesVarsTrait] = true;\n  [UsesVarOffset] = true;\n  varOffset = null;\n  body;\n  args;\n  fn = null;\n  constructor(expression, args) {\n    super();\n    this.body = expression;\n    this.args = args;\n  }\n  visitExpression(visitor, context) {\n    this.body?.visitExpression(visitor, context);\n    for (const arg of this.args) {\n      arg.visitExpression(visitor, context);\n    }\n  }\n  isEquivalent(other) {\n    if (!(other instanceof PureFunctionExpr) || other.args.length !== this.args.length) {\n      return false;\n    }\n    return other.body !== null && this.body !== null && other.body.isEquivalent(this.body) && other.args.every((arg, idx) => arg.isEquivalent(this.args[idx]));\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    if (this.body !== null) {\n      this.body = transformExpressionsInExpression(this.body, transform, flags | VisitorContextFlag.InChildOperation);\n    } else if (this.fn !== null) {\n      this.fn = transformExpressionsInExpression(this.fn, transform, flags);\n    }\n    for (let i = 0; i < this.args.length; i++) {\n      this.args[i] = transformExpressionsInExpression(this.args[i], transform, flags);\n    }\n  }\n  clone() {\n    const expr = new PureFunctionExpr(this.body?.clone() ?? null, this.args.map(arg => arg.clone()));\n    expr.fn = this.fn?.clone() ?? null;\n    expr.varOffset = this.varOffset;\n    return expr;\n  }\n}\nclass PureFunctionParameterExpr extends ExpressionBase {\n  index;\n  kind = ExpressionKind.PureFunctionParameterExpr;\n  constructor(index) {\n    super();\n    this.index = index;\n  }\n  visitExpression() {}\n  isEquivalent(other) {\n    return other instanceof PureFunctionParameterExpr && other.index === this.index;\n  }\n  isConstant() {\n    return true;\n  }\n  transformInternalExpressions() {}\n  clone() {\n    return new PureFunctionParameterExpr(this.index);\n  }\n}\nclass PipeBindingExpr extends ExpressionBase {\n  target;\n  targetSlot;\n  name;\n  args;\n  kind = ExpressionKind.PipeBinding;\n  [ConsumesVarsTrait] = true;\n  [UsesVarOffset] = true;\n  varOffset = null;\n  constructor(target, targetSlot, name, args) {\n    super();\n    this.target = target;\n    this.targetSlot = targetSlot;\n    this.name = name;\n    this.args = args;\n  }\n  visitExpression(visitor, context) {\n    for (const arg of this.args) {\n      arg.visitExpression(visitor, context);\n    }\n  }\n  isEquivalent() {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    for (let idx = 0; idx < this.args.length; idx++) {\n      this.args[idx] = transformExpressionsInExpression(this.args[idx], transform, flags);\n    }\n  }\n  clone() {\n    const r = new PipeBindingExpr(this.target, this.targetSlot, this.name, this.args.map(a => a.clone()));\n    r.varOffset = this.varOffset;\n    return r;\n  }\n}\nclass PipeBindingVariadicExpr extends ExpressionBase {\n  target;\n  targetSlot;\n  name;\n  args;\n  numArgs;\n  kind = ExpressionKind.PipeBindingVariadic;\n  [ConsumesVarsTrait] = true;\n  [UsesVarOffset] = true;\n  varOffset = null;\n  constructor(target, targetSlot, name, args, numArgs) {\n    super();\n    this.target = target;\n    this.targetSlot = targetSlot;\n    this.name = name;\n    this.args = args;\n    this.numArgs = numArgs;\n  }\n  visitExpression(visitor, context) {\n    this.args.visitExpression(visitor, context);\n  }\n  isEquivalent() {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.args = transformExpressionsInExpression(this.args, transform, flags);\n  }\n  clone() {\n    const r = new PipeBindingVariadicExpr(this.target, this.targetSlot, this.name, this.args.clone(), this.numArgs);\n    r.varOffset = this.varOffset;\n    return r;\n  }\n}\nclass SafePropertyReadExpr extends ExpressionBase {\n  receiver;\n  name;\n  kind = ExpressionKind.SafePropertyRead;\n  constructor(receiver, name) {\n    super();\n    this.receiver = receiver;\n    this.name = name;\n  }\n  get index() {\n    return this.name;\n  }\n  visitExpression(visitor, context) {\n    this.receiver.visitExpression(visitor, context);\n  }\n  isEquivalent() {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.receiver = transformExpressionsInExpression(this.receiver, transform, flags);\n  }\n  clone() {\n    return new SafePropertyReadExpr(this.receiver.clone(), this.name);\n  }\n}\nclass SafeKeyedReadExpr extends ExpressionBase {\n  receiver;\n  index;\n  kind = ExpressionKind.SafeKeyedRead;\n  constructor(receiver, index, sourceSpan) {\n    super(sourceSpan);\n    this.receiver = receiver;\n    this.index = index;\n  }\n  visitExpression(visitor, context) {\n    this.receiver.visitExpression(visitor, context);\n    this.index.visitExpression(visitor, context);\n  }\n  isEquivalent() {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.receiver = transformExpressionsInExpression(this.receiver, transform, flags);\n    this.index = transformExpressionsInExpression(this.index, transform, flags);\n  }\n  clone() {\n    return new SafeKeyedReadExpr(this.receiver.clone(), this.index.clone(), this.sourceSpan);\n  }\n}\nclass SafeInvokeFunctionExpr extends ExpressionBase {\n  receiver;\n  args;\n  kind = ExpressionKind.SafeInvokeFunction;\n  constructor(receiver, args) {\n    super();\n    this.receiver = receiver;\n    this.args = args;\n  }\n  visitExpression(visitor, context) {\n    this.receiver.visitExpression(visitor, context);\n    for (const a of this.args) {\n      a.visitExpression(visitor, context);\n    }\n  }\n  isEquivalent() {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.receiver = transformExpressionsInExpression(this.receiver, transform, flags);\n    for (let i = 0; i < this.args.length; i++) {\n      this.args[i] = transformExpressionsInExpression(this.args[i], transform, flags);\n    }\n  }\n  clone() {\n    return new SafeInvokeFunctionExpr(this.receiver.clone(), this.args.map(a => a.clone()));\n  }\n}\nclass SafeTernaryExpr extends ExpressionBase {\n  guard;\n  expr;\n  kind = ExpressionKind.SafeTernaryExpr;\n  constructor(guard, expr) {\n    super();\n    this.guard = guard;\n    this.expr = expr;\n  }\n  visitExpression(visitor, context) {\n    this.guard.visitExpression(visitor, context);\n    this.expr.visitExpression(visitor, context);\n  }\n  isEquivalent() {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.guard = transformExpressionsInExpression(this.guard, transform, flags);\n    this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n  }\n  clone() {\n    return new SafeTernaryExpr(this.guard.clone(), this.expr.clone());\n  }\n}\nclass EmptyExpr extends ExpressionBase {\n  kind = ExpressionKind.EmptyExpr;\n  visitExpression(visitor, context) {}\n  isEquivalent(e) {\n    return e instanceof EmptyExpr;\n  }\n  isConstant() {\n    return true;\n  }\n  clone() {\n    return new EmptyExpr();\n  }\n  transformInternalExpressions() {}\n}\nclass AssignTemporaryExpr extends ExpressionBase {\n  expr;\n  xref;\n  kind = ExpressionKind.AssignTemporaryExpr;\n  name = null;\n  constructor(expr, xref) {\n    super();\n    this.expr = expr;\n    this.xref = xref;\n  }\n  visitExpression(visitor, context) {\n    this.expr.visitExpression(visitor, context);\n  }\n  isEquivalent() {\n    return false;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n  }\n  clone() {\n    const a = new AssignTemporaryExpr(this.expr.clone(), this.xref);\n    a.name = this.name;\n    return a;\n  }\n}\nclass ReadTemporaryExpr extends ExpressionBase {\n  xref;\n  kind = ExpressionKind.ReadTemporaryExpr;\n  name = null;\n  constructor(xref) {\n    super();\n    this.xref = xref;\n  }\n  visitExpression(visitor, context) {}\n  isEquivalent() {\n    return this.xref === this.xref;\n  }\n  isConstant() {\n    return false;\n  }\n  transformInternalExpressions(transform, flags) {}\n  clone() {\n    const r = new ReadTemporaryExpr(this.xref);\n    r.name = this.name;\n    return r;\n  }\n}\nclass SlotLiteralExpr extends ExpressionBase {\n  slot;\n  kind = ExpressionKind.SlotLiteralExpr;\n  constructor(slot) {\n    super();\n    this.slot = slot;\n  }\n  visitExpression(visitor, context) {}\n  isEquivalent(e) {\n    return e instanceof SlotLiteralExpr && e.slot === this.slot;\n  }\n  isConstant() {\n    return true;\n  }\n  clone() {\n    return new SlotLiteralExpr(this.slot);\n  }\n  transformInternalExpressions() {}\n}\nclass ConditionalCaseExpr extends ExpressionBase {\n  expr;\n  target;\n  targetSlot;\n  alias;\n  kind = ExpressionKind.ConditionalCase;\n  constructor(expr, target, targetSlot, alias = null) {\n    super();\n    this.expr = expr;\n    this.target = target;\n    this.targetSlot = targetSlot;\n    this.alias = alias;\n  }\n  visitExpression(visitor, context) {\n    if (this.expr !== null) {\n      this.expr.visitExpression(visitor, context);\n    }\n  }\n  isEquivalent(e) {\n    return e instanceof ConditionalCaseExpr && e.expr === this.expr;\n  }\n  isConstant() {\n    return true;\n  }\n  clone() {\n    return new ConditionalCaseExpr(this.expr, this.target, this.targetSlot);\n  }\n  transformInternalExpressions(transform, flags) {\n    if (this.expr !== null) {\n      this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n    }\n  }\n}\nclass ConstCollectedExpr extends ExpressionBase {\n  expr;\n  kind = ExpressionKind.ConstCollected;\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n  transformInternalExpressions(transform, flags) {\n    this.expr = transform(this.expr, flags);\n  }\n  visitExpression(visitor, context) {\n    this.expr.visitExpression(visitor, context);\n  }\n  isEquivalent(e) {\n    if (!(e instanceof ConstCollectedExpr)) {\n      return false;\n    }\n    return this.expr.isEquivalent(e.expr);\n  }\n  isConstant() {\n    return this.expr.isConstant();\n  }\n  clone() {\n    return new ConstCollectedExpr(this.expr);\n  }\n}\nfunction visitExpressionsInOp(op, visitor) {\n  transformExpressionsInOp(op, (expr, flags) => {\n    visitor(expr, flags);\n    return expr;\n  }, VisitorContextFlag.None);\n}\nvar VisitorContextFlag;\n(function (VisitorContextFlag) {\n  VisitorContextFlag[VisitorContextFlag[\"None\"] = 0] = \"None\";\n  VisitorContextFlag[VisitorContextFlag[\"InChildOperation\"] = 1] = \"InChildOperation\";\n})(VisitorContextFlag || (VisitorContextFlag = {}));\nfunction transformExpressionsInInterpolation(interpolation, transform, flags) {\n  for (let i = 0; i < interpolation.expressions.length; i++) {\n    interpolation.expressions[i] = transformExpressionsInExpression(interpolation.expressions[i], transform, flags);\n  }\n}\nfunction transformExpressionsInOp(op, transform, flags) {\n  switch (op.kind) {\n    case OpKind.StyleProp:\n    case OpKind.StyleMap:\n    case OpKind.ClassProp:\n    case OpKind.ClassMap:\n    case OpKind.AnimationString:\n    case OpKind.AnimationBinding:\n    case OpKind.Binding:\n      if (op.expression instanceof Interpolation) {\n        transformExpressionsInInterpolation(op.expression, transform, flags);\n      } else {\n        op.expression = transformExpressionsInExpression(op.expression, transform, flags);\n      }\n      break;\n    case OpKind.Property:\n    case OpKind.DomProperty:\n    case OpKind.Attribute:\n    case OpKind.Control:\n      if (op.expression instanceof Interpolation) {\n        transformExpressionsInInterpolation(op.expression, transform, flags);\n      } else {\n        op.expression = transformExpressionsInExpression(op.expression, transform, flags);\n      }\n      op.sanitizer = op.sanitizer && transformExpressionsInExpression(op.sanitizer, transform, flags);\n      break;\n    case OpKind.TwoWayProperty:\n      op.expression = transformExpressionsInExpression(op.expression, transform, flags);\n      op.sanitizer = op.sanitizer && transformExpressionsInExpression(op.sanitizer, transform, flags);\n      break;\n    case OpKind.I18nExpression:\n      op.expression = transformExpressionsInExpression(op.expression, transform, flags);\n      break;\n    case OpKind.InterpolateText:\n      transformExpressionsInInterpolation(op.interpolation, transform, flags);\n      break;\n    case OpKind.Statement:\n      transformExpressionsInStatement(op.statement, transform, flags);\n      break;\n    case OpKind.Variable:\n      op.initializer = transformExpressionsInExpression(op.initializer, transform, flags);\n      break;\n    case OpKind.Conditional:\n      for (const condition of op.conditions) {\n        if (condition.expr === null) {\n          continue;\n        }\n        condition.expr = transformExpressionsInExpression(condition.expr, transform, flags);\n      }\n      if (op.processed !== null) {\n        op.processed = transformExpressionsInExpression(op.processed, transform, flags);\n      }\n      if (op.contextValue !== null) {\n        op.contextValue = transformExpressionsInExpression(op.contextValue, transform, flags);\n      }\n      break;\n    case OpKind.Animation:\n    case OpKind.AnimationListener:\n    case OpKind.Listener:\n    case OpKind.TwoWayListener:\n      for (const innerOp of op.handlerOps) {\n        transformExpressionsInOp(innerOp, transform, flags | VisitorContextFlag.InChildOperation);\n      }\n      break;\n    case OpKind.ExtractedAttribute:\n      op.expression = op.expression && transformExpressionsInExpression(op.expression, transform, flags);\n      op.trustedValueFn = op.trustedValueFn && transformExpressionsInExpression(op.trustedValueFn, transform, flags);\n      break;\n    case OpKind.RepeaterCreate:\n      if (op.trackByOps === null) {\n        op.track = transformExpressionsInExpression(op.track, transform, flags);\n      } else {\n        for (const innerOp of op.trackByOps) {\n          transformExpressionsInOp(innerOp, transform, flags | VisitorContextFlag.InChildOperation);\n        }\n      }\n      if (op.trackByFn !== null) {\n        op.trackByFn = transformExpressionsInExpression(op.trackByFn, transform, flags);\n      }\n      break;\n    case OpKind.Repeater:\n      op.collection = transformExpressionsInExpression(op.collection, transform, flags);\n      break;\n    case OpKind.Defer:\n      if (op.loadingConfig !== null) {\n        op.loadingConfig = transformExpressionsInExpression(op.loadingConfig, transform, flags);\n      }\n      if (op.placeholderConfig !== null) {\n        op.placeholderConfig = transformExpressionsInExpression(op.placeholderConfig, transform, flags);\n      }\n      if (op.resolverFn !== null) {\n        op.resolverFn = transformExpressionsInExpression(op.resolverFn, transform, flags);\n      }\n      break;\n    case OpKind.I18nMessage:\n      for (const [placeholder, expr] of op.params) {\n        op.params.set(placeholder, transformExpressionsInExpression(expr, transform, flags));\n      }\n      for (const [placeholder, expr] of op.postprocessingParams) {\n        op.postprocessingParams.set(placeholder, transformExpressionsInExpression(expr, transform, flags));\n      }\n      break;\n    case OpKind.DeferWhen:\n      op.expr = transformExpressionsInExpression(op.expr, transform, flags);\n      break;\n    case OpKind.StoreLet:\n      op.value = transformExpressionsInExpression(op.value, transform, flags);\n      break;\n    case OpKind.Advance:\n    case OpKind.Container:\n    case OpKind.ContainerEnd:\n    case OpKind.ContainerStart:\n    case OpKind.DeferOn:\n    case OpKind.DisableBindings:\n    case OpKind.Element:\n    case OpKind.ElementEnd:\n    case OpKind.ElementStart:\n    case OpKind.EnableBindings:\n    case OpKind.I18n:\n    case OpKind.I18nApply:\n    case OpKind.I18nContext:\n    case OpKind.I18nEnd:\n    case OpKind.I18nStart:\n    case OpKind.IcuEnd:\n    case OpKind.IcuStart:\n    case OpKind.Namespace:\n    case OpKind.Pipe:\n    case OpKind.Projection:\n    case OpKind.ProjectionDef:\n    case OpKind.Template:\n    case OpKind.Text:\n    case OpKind.I18nAttributes:\n    case OpKind.IcuPlaceholder:\n    case OpKind.DeclareLet:\n    case OpKind.SourceLocation:\n    case OpKind.ConditionalCreate:\n    case OpKind.ConditionalBranchCreate:\n    case OpKind.ControlCreate:\n      break;\n    default:\n      throw new Error(`AssertionError: transformExpressionsInOp doesn't handle ${OpKind[op.kind]}`);\n  }\n}\nfunction transformExpressionsInExpression(expr, transform, flags) {\n  if (expr instanceof ExpressionBase) {\n    expr.transformInternalExpressions(transform, flags);\n  } else if (expr instanceof BinaryOperatorExpr) {\n    expr.lhs = transformExpressionsInExpression(expr.lhs, transform, flags);\n    expr.rhs = transformExpressionsInExpression(expr.rhs, transform, flags);\n  } else if (expr instanceof UnaryOperatorExpr) {\n    expr.expr = transformExpressionsInExpression(expr.expr, transform, flags);\n  } else if (expr instanceof ReadPropExpr) {\n    expr.receiver = transformExpressionsInExpression(expr.receiver, transform, flags);\n  } else if (expr instanceof ReadKeyExpr) {\n    expr.receiver = transformExpressionsInExpression(expr.receiver, transform, flags);\n    expr.index = transformExpressionsInExpression(expr.index, transform, flags);\n  } else if (expr instanceof InvokeFunctionExpr) {\n    expr.fn = transformExpressionsInExpression(expr.fn, transform, flags);\n    for (let i = 0; i < expr.args.length; i++) {\n      expr.args[i] = transformExpressionsInExpression(expr.args[i], transform, flags);\n    }\n  } else if (expr instanceof LiteralArrayExpr) {\n    for (let i = 0; i < expr.entries.length; i++) {\n      expr.entries[i] = transformExpressionsInExpression(expr.entries[i], transform, flags);\n    }\n  } else if (expr instanceof LiteralMapExpr) {\n    for (let i = 0; i < expr.entries.length; i++) {\n      expr.entries[i].value = transformExpressionsInExpression(expr.entries[i].value, transform, flags);\n    }\n  } else if (expr instanceof ConditionalExpr) {\n    expr.condition = transformExpressionsInExpression(expr.condition, transform, flags);\n    expr.trueCase = transformExpressionsInExpression(expr.trueCase, transform, flags);\n    if (expr.falseCase !== null) {\n      expr.falseCase = transformExpressionsInExpression(expr.falseCase, transform, flags);\n    }\n  } else if (expr instanceof TypeofExpr) {\n    expr.expr = transformExpressionsInExpression(expr.expr, transform, flags);\n  } else if (expr instanceof VoidExpr) {\n    expr.expr = transformExpressionsInExpression(expr.expr, transform, flags);\n  } else if (expr instanceof LocalizedString) {\n    for (let i = 0; i < expr.expressions.length; i++) {\n      expr.expressions[i] = transformExpressionsInExpression(expr.expressions[i], transform, flags);\n    }\n  } else if (expr instanceof NotExpr) {\n    expr.condition = transformExpressionsInExpression(expr.condition, transform, flags);\n  } else if (expr instanceof TaggedTemplateLiteralExpr) {\n    expr.tag = transformExpressionsInExpression(expr.tag, transform, flags);\n    expr.template.expressions = expr.template.expressions.map(e => transformExpressionsInExpression(e, transform, flags));\n  } else if (expr instanceof ArrowFunctionExpr) {\n    if (Array.isArray(expr.body)) {\n      for (let i = 0; i < expr.body.length; i++) {\n        transformExpressionsInStatement(expr.body[i], transform, flags);\n      }\n    } else {\n      expr.body = transformExpressionsInExpression(expr.body, transform, flags);\n    }\n  } else if (expr instanceof WrappedNodeExpr) ; else if (expr instanceof TemplateLiteralExpr) {\n    for (let i = 0; i < expr.expressions.length; i++) {\n      expr.expressions[i] = transformExpressionsInExpression(expr.expressions[i], transform, flags);\n    }\n  } else if (expr instanceof ParenthesizedExpr) {\n    expr.expr = transformExpressionsInExpression(expr.expr, transform, flags);\n  } else if (expr instanceof ReadVarExpr || expr instanceof ExternalExpr || expr instanceof LiteralExpr || expr instanceof RegularExpressionLiteralExpr) ; else {\n    throw new Error(`Unhandled expression kind: ${expr.constructor.name}`);\n  }\n  return transform(expr, flags);\n}\nfunction transformExpressionsInStatement(stmt, transform, flags) {\n  if (stmt instanceof ExpressionStatement) {\n    stmt.expr = transformExpressionsInExpression(stmt.expr, transform, flags);\n  } else if (stmt instanceof ReturnStatement) {\n    stmt.value = transformExpressionsInExpression(stmt.value, transform, flags);\n  } else if (stmt instanceof DeclareVarStmt) {\n    if (stmt.value !== undefined) {\n      stmt.value = transformExpressionsInExpression(stmt.value, transform, flags);\n    }\n  } else if (stmt instanceof IfStmt) {\n    stmt.condition = transformExpressionsInExpression(stmt.condition, transform, flags);\n    for (const caseStatement of stmt.trueCase) {\n      transformExpressionsInStatement(caseStatement, transform, flags);\n    }\n    for (const caseStatement of stmt.falseCase) {\n      transformExpressionsInStatement(caseStatement, transform, flags);\n    }\n  } else {\n    throw new Error(`Unhandled statement kind: ${stmt.constructor.name}`);\n  }\n}\nfunction isStringLiteral(expr) {\n  return expr instanceof LiteralExpr && typeof expr.value === 'string';\n}\n\nclass OpList {\n  static nextListId = 0;\n  debugListId = OpList.nextListId++;\n  head = {\n    kind: OpKind.ListEnd,\n    next: null,\n    prev: null,\n    debugListId: this.debugListId\n  };\n  tail = {\n    kind: OpKind.ListEnd,\n    next: null,\n    prev: null,\n    debugListId: this.debugListId\n  };\n  constructor() {\n    this.head.next = this.tail;\n    this.tail.prev = this.head;\n  }\n  push(op) {\n    if (Array.isArray(op)) {\n      for (const o of op) {\n        this.push(o);\n      }\n      return;\n    }\n    OpList.assertIsNotEnd(op);\n    OpList.assertIsUnowned(op);\n    op.debugListId = this.debugListId;\n    const oldLast = this.tail.prev;\n    op.prev = oldLast;\n    oldLast.next = op;\n    op.next = this.tail;\n    this.tail.prev = op;\n  }\n  prepend(ops) {\n    if (ops.length === 0) {\n      return;\n    }\n    for (const op of ops) {\n      OpList.assertIsNotEnd(op);\n      OpList.assertIsUnowned(op);\n      op.debugListId = this.debugListId;\n    }\n    const first = this.head.next;\n    let prev = this.head;\n    for (const op of ops) {\n      prev.next = op;\n      op.prev = prev;\n      prev = op;\n    }\n    prev.next = first;\n    first.prev = prev;\n  }\n  *[Symbol.iterator]() {\n    let current = this.head.next;\n    while (current !== this.tail) {\n      OpList.assertIsOwned(current, this.debugListId);\n      const next = current.next;\n      yield current;\n      current = next;\n    }\n  }\n  *reversed() {\n    let current = this.tail.prev;\n    while (current !== this.head) {\n      OpList.assertIsOwned(current, this.debugListId);\n      const prev = current.prev;\n      yield current;\n      current = prev;\n    }\n  }\n  static replace(oldOp, newOp) {\n    OpList.assertIsNotEnd(oldOp);\n    OpList.assertIsNotEnd(newOp);\n    OpList.assertIsOwned(oldOp);\n    OpList.assertIsUnowned(newOp);\n    newOp.debugListId = oldOp.debugListId;\n    if (oldOp.prev !== null) {\n      oldOp.prev.next = newOp;\n      newOp.prev = oldOp.prev;\n    }\n    if (oldOp.next !== null) {\n      oldOp.next.prev = newOp;\n      newOp.next = oldOp.next;\n    }\n    oldOp.debugListId = null;\n    oldOp.prev = null;\n    oldOp.next = null;\n  }\n  static replaceWithMany(oldOp, newOps) {\n    if (newOps.length === 0) {\n      OpList.remove(oldOp);\n      return;\n    }\n    OpList.assertIsNotEnd(oldOp);\n    OpList.assertIsOwned(oldOp);\n    const listId = oldOp.debugListId;\n    oldOp.debugListId = null;\n    for (const newOp of newOps) {\n      OpList.assertIsNotEnd(newOp);\n      OpList.assertIsUnowned(newOp);\n    }\n    const {\n      prev: oldPrev,\n      next: oldNext\n    } = oldOp;\n    oldOp.prev = null;\n    oldOp.next = null;\n    let prev = oldPrev;\n    for (const newOp of newOps) {\n      OpList.assertIsUnowned(newOp);\n      newOp.debugListId = listId;\n      prev.next = newOp;\n      newOp.prev = prev;\n      newOp.next = null;\n      prev = newOp;\n    }\n    const first = newOps[0];\n    const last = prev;\n    if (oldPrev !== null) {\n      oldPrev.next = first;\n      first.prev = oldPrev;\n    }\n    if (oldNext !== null) {\n      oldNext.prev = last;\n      last.next = oldNext;\n    }\n  }\n  static remove(op) {\n    OpList.assertIsNotEnd(op);\n    OpList.assertIsOwned(op);\n    op.prev.next = op.next;\n    op.next.prev = op.prev;\n    op.debugListId = null;\n    op.prev = null;\n    op.next = null;\n  }\n  static insertBefore(op, target) {\n    if (Array.isArray(op)) {\n      for (const o of op) {\n        OpList.insertBefore(o, target);\n      }\n      return;\n    }\n    OpList.assertIsOwned(target);\n    if (target.prev === null) {\n      throw new Error(`AssertionError: illegal operation on list start`);\n    }\n    OpList.assertIsNotEnd(op);\n    OpList.assertIsUnowned(op);\n    op.debugListId = target.debugListId;\n    op.prev = null;\n    target.prev.next = op;\n    op.prev = target.prev;\n    op.next = target;\n    target.prev = op;\n  }\n  static insertAfter(op, target) {\n    OpList.assertIsOwned(target);\n    if (target.next === null) {\n      throw new Error(`AssertionError: illegal operation on list end`);\n    }\n    OpList.assertIsNotEnd(op);\n    OpList.assertIsUnowned(op);\n    op.debugListId = target.debugListId;\n    target.next.prev = op;\n    op.next = target.next;\n    op.prev = target;\n    target.next = op;\n  }\n  static assertIsUnowned(op) {\n    if (op.debugListId !== null) {\n      throw new Error(`AssertionError: illegal operation on owned node: ${OpKind[op.kind]}`);\n    }\n  }\n  static assertIsOwned(op, byList) {\n    if (op.debugListId === null) {\n      throw new Error(`AssertionError: illegal operation on unowned node: ${OpKind[op.kind]}`);\n    } else if (byList !== undefined && op.debugListId !== byList) {\n      throw new Error(`AssertionError: node belongs to the wrong list (expected ${byList}, actual ${op.debugListId})`);\n    }\n  }\n  static assertIsNotEnd(op) {\n    if (op.kind === OpKind.ListEnd) {\n      throw new Error(`AssertionError: illegal operation on list head or tail`);\n    }\n  }\n}\n\nclass SlotHandle {\n  slot = null;\n}\n\nconst elementContainerOpKinds = new Set([OpKind.Element, OpKind.ElementStart, OpKind.Container, OpKind.ContainerStart, OpKind.Template, OpKind.RepeaterCreate, OpKind.ConditionalCreate, OpKind.ConditionalBranchCreate]);\nfunction isElementOrContainerOp(op) {\n  return elementContainerOpKinds.has(op.kind);\n}\nfunction createElementStartOp(tag, xref, namespace, i18nPlaceholder, startSourceSpan, wholeSourceSpan) {\n  return {\n    kind: OpKind.ElementStart,\n    xref,\n    tag,\n    handle: new SlotHandle(),\n    attributes: null,\n    localRefs: [],\n    nonBindable: false,\n    namespace,\n    i18nPlaceholder,\n    startSourceSpan,\n    wholeSourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP\n  };\n}\nfunction createTemplateOp(xref, templateKind, tag, functionNameSuffix, namespace, i18nPlaceholder, startSourceSpan, wholeSourceSpan) {\n  return {\n    kind: OpKind.Template,\n    xref,\n    templateKind,\n    attributes: null,\n    tag,\n    handle: new SlotHandle(),\n    functionNameSuffix,\n    decls: null,\n    vars: null,\n    localRefs: [],\n    nonBindable: false,\n    namespace,\n    i18nPlaceholder,\n    startSourceSpan,\n    wholeSourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP\n  };\n}\nfunction createConditionalCreateOp(xref, templateKind, tag, functionNameSuffix, namespace, i18nPlaceholder, startSourceSpan, wholeSourceSpan) {\n  return {\n    kind: OpKind.ConditionalCreate,\n    xref,\n    templateKind,\n    attributes: null,\n    tag,\n    handle: new SlotHandle(),\n    functionNameSuffix,\n    decls: null,\n    vars: null,\n    localRefs: [],\n    nonBindable: false,\n    namespace,\n    i18nPlaceholder,\n    startSourceSpan,\n    wholeSourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP\n  };\n}\nfunction createConditionalBranchCreateOp(xref, templateKind, tag, functionNameSuffix, namespace, i18nPlaceholder, startSourceSpan, wholeSourceSpan) {\n  return {\n    kind: OpKind.ConditionalBranchCreate,\n    xref,\n    templateKind,\n    attributes: null,\n    tag,\n    handle: new SlotHandle(),\n    functionNameSuffix,\n    decls: null,\n    vars: null,\n    localRefs: [],\n    nonBindable: false,\n    namespace,\n    i18nPlaceholder,\n    startSourceSpan,\n    wholeSourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP\n  };\n}\nfunction createRepeaterCreateOp(primaryView, emptyView, tag, track, varNames, emptyTag, i18nPlaceholder, emptyI18nPlaceholder, startSourceSpan, wholeSourceSpan) {\n  return {\n    kind: OpKind.RepeaterCreate,\n    attributes: null,\n    xref: primaryView,\n    handle: new SlotHandle(),\n    emptyView,\n    track,\n    trackByFn: null,\n    trackByOps: null,\n    tag,\n    emptyTag,\n    emptyAttributes: null,\n    functionNameSuffix: 'For',\n    namespace: Namespace.HTML,\n    nonBindable: false,\n    localRefs: [],\n    decls: null,\n    vars: null,\n    varNames,\n    usesComponentInstance: false,\n    i18nPlaceholder,\n    emptyI18nPlaceholder,\n    startSourceSpan,\n    wholeSourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_VARS,\n    numSlotsUsed: emptyView === null ? 2 : 3\n  };\n}\nfunction createElementEndOp(xref, sourceSpan) {\n  return {\n    kind: OpKind.ElementEnd,\n    xref,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createDisableBindingsOp(xref) {\n  return {\n    kind: OpKind.DisableBindings,\n    xref,\n    ...NEW_OP\n  };\n}\nfunction createEnableBindingsOp(xref) {\n  return {\n    kind: OpKind.EnableBindings,\n    xref,\n    ...NEW_OP\n  };\n}\nfunction createTextOp(xref, initialValue, icuPlaceholder, sourceSpan) {\n  return {\n    kind: OpKind.Text,\n    xref,\n    handle: new SlotHandle(),\n    initialValue,\n    icuPlaceholder,\n    sourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP\n  };\n}\nfunction createAnimationStringOp(name, target, animationKind, expression, securityContext, sourceSpan) {\n  return {\n    kind: OpKind.AnimationString,\n    name,\n    target,\n    animationKind,\n    expression,\n    i18nMessage: null,\n    securityContext,\n    sanitizer: null,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createAnimationOp(name, target, animationKind, callbackOps, securityContext, sourceSpan) {\n  const handlerOps = new OpList();\n  handlerOps.push(callbackOps);\n  return {\n    kind: OpKind.Animation,\n    name,\n    target,\n    animationKind,\n    handlerOps,\n    handlerFnName: null,\n    i18nMessage: null,\n    securityContext,\n    sanitizer: null,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createListenerOp(target, targetSlot, name, tag, handlerOps, legacyAnimationPhase, eventTarget, hostListener, sourceSpan) {\n  const handlerList = new OpList();\n  handlerList.push(handlerOps);\n  return {\n    kind: OpKind.Listener,\n    target,\n    targetSlot,\n    tag,\n    hostListener,\n    name,\n    handlerOps: handlerList,\n    handlerFnName: null,\n    consumesDollarEvent: false,\n    isLegacyAnimationListener: legacyAnimationPhase !== null,\n    legacyAnimationPhase: legacyAnimationPhase,\n    eventTarget,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createAnimationListenerOp(target, targetSlot, name, tag, handlerOps, animationKind, eventTarget, hostListener, sourceSpan) {\n  const handlerList = new OpList();\n  handlerList.push(handlerOps);\n  return {\n    kind: OpKind.AnimationListener,\n    target,\n    targetSlot,\n    tag,\n    hostListener,\n    name,\n    animationKind,\n    handlerOps: handlerList,\n    handlerFnName: null,\n    consumesDollarEvent: false,\n    eventTarget,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createTwoWayListenerOp(target, targetSlot, name, tag, handlerOps, sourceSpan) {\n  const handlerList = new OpList();\n  handlerList.push(handlerOps);\n  return {\n    kind: OpKind.TwoWayListener,\n    target,\n    targetSlot,\n    tag,\n    name,\n    handlerOps: handlerList,\n    handlerFnName: null,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createPipeOp(xref, slot, name) {\n  return {\n    kind: OpKind.Pipe,\n    xref,\n    handle: slot,\n    name,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_SLOT\n  };\n}\nfunction createNamespaceOp(namespace) {\n  return {\n    kind: OpKind.Namespace,\n    active: namespace,\n    ...NEW_OP\n  };\n}\nfunction createProjectionDefOp(def) {\n  return {\n    kind: OpKind.ProjectionDef,\n    def,\n    ...NEW_OP\n  };\n}\nfunction createProjectionOp(xref, selector, i18nPlaceholder, fallbackView, sourceSpan) {\n  return {\n    kind: OpKind.Projection,\n    xref,\n    handle: new SlotHandle(),\n    selector,\n    i18nPlaceholder,\n    fallbackView,\n    projectionSlotIndex: 0,\n    attributes: null,\n    localRefs: [],\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_SLOT,\n    numSlotsUsed: fallbackView === null ? 1 : 2\n  };\n}\nfunction createExtractedAttributeOp(target, bindingKind, namespace, name, expression, i18nContext, i18nMessage, securityContext) {\n  return {\n    kind: OpKind.ExtractedAttribute,\n    target,\n    bindingKind,\n    namespace,\n    name,\n    expression,\n    i18nContext,\n    i18nMessage,\n    securityContext,\n    trustedValueFn: null,\n    ...NEW_OP\n  };\n}\nfunction createDeferOp(xref, main, mainSlot, ownResolverFn, resolverFn, sourceSpan) {\n  return {\n    kind: OpKind.Defer,\n    xref,\n    handle: new SlotHandle(),\n    mainView: main,\n    mainSlot,\n    loadingView: null,\n    loadingSlot: null,\n    loadingConfig: null,\n    loadingMinimumTime: null,\n    loadingAfterTime: null,\n    placeholderView: null,\n    placeholderSlot: null,\n    placeholderConfig: null,\n    placeholderMinimumTime: null,\n    errorView: null,\n    errorSlot: null,\n    ownResolverFn,\n    resolverFn,\n    flags: null,\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_SLOT,\n    numSlotsUsed: 2\n  };\n}\nfunction createDeferOnOp(defer, trigger, modifier, sourceSpan) {\n  return {\n    kind: OpKind.DeferOn,\n    defer,\n    trigger,\n    modifier,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createDeclareLetOp(xref, declaredName, sourceSpan) {\n  return {\n    kind: OpKind.DeclareLet,\n    xref,\n    declaredName,\n    sourceSpan,\n    handle: new SlotHandle(),\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP\n  };\n}\nfunction createI18nMessageOp(xref, i18nContext, i18nBlock, message, messagePlaceholder, params, postprocessingParams, needsPostprocessing) {\n  return {\n    kind: OpKind.I18nMessage,\n    xref,\n    i18nContext,\n    i18nBlock,\n    message,\n    messagePlaceholder,\n    params,\n    postprocessingParams,\n    needsPostprocessing,\n    subMessages: [],\n    ...NEW_OP\n  };\n}\nfunction createI18nStartOp(xref, message, root, sourceSpan) {\n  return {\n    kind: OpKind.I18nStart,\n    xref,\n    handle: new SlotHandle(),\n    root: root ?? xref,\n    message,\n    messageIndex: null,\n    subTemplateIndex: null,\n    context: null,\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_SLOT\n  };\n}\nfunction createI18nEndOp(xref, sourceSpan) {\n  return {\n    kind: OpKind.I18nEnd,\n    xref,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createIcuStartOp(xref, message, messagePlaceholder, sourceSpan) {\n  return {\n    kind: OpKind.IcuStart,\n    xref,\n    message,\n    messagePlaceholder,\n    context: null,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\nfunction createIcuEndOp(xref) {\n  return {\n    kind: OpKind.IcuEnd,\n    xref,\n    ...NEW_OP\n  };\n}\nfunction createIcuPlaceholderOp(xref, name, strings) {\n  return {\n    kind: OpKind.IcuPlaceholder,\n    xref,\n    name,\n    strings,\n    expressionPlaceholders: [],\n    ...NEW_OP\n  };\n}\nfunction createI18nContextOp(contextKind, xref, i18nBlock, message, sourceSpan) {\n  if (i18nBlock === null && contextKind !== I18nContextKind.Attr) {\n    throw new Error('AssertionError: i18nBlock must be provided for non-attribute contexts.');\n  }\n  return {\n    kind: OpKind.I18nContext,\n    contextKind,\n    xref,\n    i18nBlock,\n    message,\n    sourceSpan,\n    params: new Map(),\n    postprocessingParams: new Map(),\n    ...NEW_OP\n  };\n}\nfunction createI18nAttributesOp(xref, handle, target) {\n  return {\n    kind: OpKind.I18nAttributes,\n    xref,\n    handle,\n    target,\n    i18nAttributesConfig: null,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_SLOT\n  };\n}\nfunction createSourceLocationOp(templatePath, locations) {\n  return {\n    kind: OpKind.SourceLocation,\n    templatePath,\n    locations,\n    ...NEW_OP\n  };\n}\nfunction createControlCreateOp(sourceSpan) {\n  return {\n    kind: OpKind.ControlCreate,\n    sourceSpan,\n    ...NEW_OP\n  };\n}\n\nfunction createDomPropertyOp(name, expression, bindingKind, i18nContext, securityContext, sourceSpan) {\n  return {\n    kind: OpKind.DomProperty,\n    name,\n    expression,\n    bindingKind,\n    i18nContext,\n    securityContext,\n    sanitizer: null,\n    sourceSpan,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP\n  };\n}\n\nconst CTX_REF = 'CTX_REF_MARKER';\n\nvar CompilationJobKind;\n(function (CompilationJobKind) {\n  CompilationJobKind[CompilationJobKind[\"Tmpl\"] = 0] = \"Tmpl\";\n  CompilationJobKind[CompilationJobKind[\"Host\"] = 1] = \"Host\";\n  CompilationJobKind[CompilationJobKind[\"Both\"] = 2] = \"Both\";\n})(CompilationJobKind || (CompilationJobKind = {}));\nvar TemplateCompilationMode;\n(function (TemplateCompilationMode) {\n  TemplateCompilationMode[TemplateCompilationMode[\"Full\"] = 0] = \"Full\";\n  TemplateCompilationMode[TemplateCompilationMode[\"DomOnly\"] = 1] = \"DomOnly\";\n})(TemplateCompilationMode || (TemplateCompilationMode = {}));\nclass CompilationJob {\n  componentName;\n  pool;\n  compatibility;\n  mode;\n  constructor(componentName, pool, compatibility, mode) {\n    this.componentName = componentName;\n    this.pool = pool;\n    this.compatibility = compatibility;\n    this.mode = mode;\n  }\n  kind = CompilationJobKind.Both;\n  allocateXrefId() {\n    return this.nextXrefId++;\n  }\n  nextXrefId = 0;\n}\nclass ComponentCompilationJob extends CompilationJob {\n  relativeContextFilePath;\n  i18nUseExternalIds;\n  deferMeta;\n  allDeferrableDepsFn;\n  relativeTemplatePath;\n  enableDebugLocations;\n  constructor(componentName, pool, compatibility, mode, relativeContextFilePath, i18nUseExternalIds, deferMeta, allDeferrableDepsFn, relativeTemplatePath, enableDebugLocations) {\n    super(componentName, pool, compatibility, mode);\n    this.relativeContextFilePath = relativeContextFilePath;\n    this.i18nUseExternalIds = i18nUseExternalIds;\n    this.deferMeta = deferMeta;\n    this.allDeferrableDepsFn = allDeferrableDepsFn;\n    this.relativeTemplatePath = relativeTemplatePath;\n    this.enableDebugLocations = enableDebugLocations;\n    this.root = new ViewCompilationUnit(this, this.allocateXrefId(), null);\n    this.views.set(this.root.xref, this.root);\n  }\n  kind = CompilationJobKind.Tmpl;\n  fnSuffix = 'Template';\n  root;\n  views = new Map();\n  contentSelectors = null;\n  allocateView(parent) {\n    const view = new ViewCompilationUnit(this, this.allocateXrefId(), parent);\n    this.views.set(view.xref, view);\n    return view;\n  }\n  get units() {\n    return this.views.values();\n  }\n  addConst(newConst, initializers) {\n    for (let idx = 0; idx < this.consts.length; idx++) {\n      if (this.consts[idx].isEquivalent(newConst)) {\n        return idx;\n      }\n    }\n    const idx = this.consts.length;\n    this.consts.push(newConst);\n    if (initializers) {\n      this.constsInitializers.push(...initializers);\n    }\n    return idx;\n  }\n  consts = [];\n  constsInitializers = [];\n}\nclass CompilationUnit {\n  xref;\n  constructor(xref) {\n    this.xref = xref;\n  }\n  create = new OpList();\n  update = new OpList();\n  fnName = null;\n  vars = null;\n  *ops() {\n    for (const op of this.create) {\n      yield op;\n      if (op.kind === OpKind.Listener || op.kind === OpKind.Animation || op.kind === OpKind.AnimationListener || op.kind === OpKind.TwoWayListener) {\n        for (const listenerOp of op.handlerOps) {\n          yield listenerOp;\n        }\n      } else if (op.kind === OpKind.RepeaterCreate && op.trackByOps !== null) {\n        for (const trackOp of op.trackByOps) {\n          yield trackOp;\n        }\n      }\n    }\n    for (const op of this.update) {\n      yield op;\n    }\n  }\n}\nclass ViewCompilationUnit extends CompilationUnit {\n  job;\n  parent;\n  constructor(job, xref, parent) {\n    super(xref);\n    this.job = job;\n    this.parent = parent;\n  }\n  contextVariables = new Map();\n  aliases = new Set();\n  decls = null;\n}\nclass HostBindingCompilationJob extends CompilationJob {\n  constructor(componentName, pool, compatibility, mode) {\n    super(componentName, pool, compatibility, mode);\n    this.root = new HostBindingCompilationUnit(this);\n  }\n  kind = CompilationJobKind.Host;\n  fnSuffix = 'HostBindings';\n  root;\n  get units() {\n    return [this.root];\n  }\n}\nclass HostBindingCompilationUnit extends CompilationUnit {\n  job;\n  constructor(job) {\n    super(0);\n    this.job = job;\n  }\n  attributes = null;\n}\n\nfunction deleteAnyCasts(job) {\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      transformExpressionsInOp(op, removeAnys, VisitorContextFlag.None);\n    }\n  }\n}\nfunction removeAnys(e) {\n  if (e instanceof InvokeFunctionExpr && e.fn instanceof LexicalReadExpr && e.fn.name === '$any') {\n    if (e.args.length !== 1) {\n      throw new Error('The $any builtin function expects exactly one argument.');\n    }\n    return e.args[0];\n  }\n  return e;\n}\n\nfunction applyI18nExpressions(job) {\n  const i18nContexts = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.I18nContext) {\n        i18nContexts.set(op.xref, op);\n      }\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      if (op.kind === OpKind.I18nExpression && needsApplication(i18nContexts, op)) {\n        OpList.insertAfter(createI18nApplyOp(op.i18nOwner, op.handle, null), op);\n      }\n    }\n  }\n}\nfunction needsApplication(i18nContexts, op) {\n  if (op.next?.kind !== OpKind.I18nExpression) {\n    return true;\n  }\n  const context = i18nContexts.get(op.context);\n  const nextContext = i18nContexts.get(op.next.context);\n  if (context === undefined) {\n    throw new Error(\"AssertionError: expected an I18nContextOp to exist for the I18nExpressionOp's context\");\n  }\n  if (nextContext === undefined) {\n    throw new Error(\"AssertionError: expected an I18nContextOp to exist for the next I18nExpressionOp's context\");\n  }\n  if (context.i18nBlock !== null) {\n    if (context.i18nBlock !== nextContext.i18nBlock) {\n      return true;\n    }\n    return false;\n  }\n  if (op.i18nOwner !== op.next.i18nOwner) {\n    return true;\n  }\n  return false;\n}\n\nfunction assignI18nSlotDependencies(job) {\n  for (const unit of job.units) {\n    let updateOp = unit.update.head;\n    let i18nExpressionsInProgress = [];\n    let state = null;\n    for (const createOp of unit.create) {\n      if (createOp.kind === OpKind.I18nStart) {\n        state = {\n          blockXref: createOp.xref,\n          lastSlotConsumer: createOp.xref\n        };\n      } else if (createOp.kind === OpKind.I18nEnd) {\n        for (const op of i18nExpressionsInProgress) {\n          op.target = state.lastSlotConsumer;\n          OpList.insertBefore(op, updateOp);\n        }\n        i18nExpressionsInProgress.length = 0;\n        state = null;\n      }\n      if (hasConsumesSlotTrait(createOp)) {\n        if (state !== null) {\n          state.lastSlotConsumer = createOp.xref;\n        }\n        while (true) {\n          if (updateOp.next === null) {\n            break;\n          }\n          if (state !== null && updateOp.kind === OpKind.I18nExpression && updateOp.usage === I18nExpressionFor.I18nText && updateOp.i18nOwner === state.blockXref) {\n            const opToRemove = updateOp;\n            updateOp = updateOp.next;\n            OpList.remove(opToRemove);\n            i18nExpressionsInProgress.push(opToRemove);\n            continue;\n          }\n          let hasDifferentTarget = false;\n          if (hasDependsOnSlotContextTrait(updateOp) && updateOp.target !== createOp.xref) {\n            hasDifferentTarget = true;\n          } else if (updateOp.kind === OpKind.Statement || updateOp.kind === OpKind.Variable) {\n            visitExpressionsInOp(updateOp, expr => {\n              if (!hasDifferentTarget && hasDependsOnSlotContextTrait(expr) && expr.target !== createOp.xref) {\n                hasDifferentTarget = true;\n              }\n            });\n          }\n          if (hasDifferentTarget) {\n            break;\n          }\n          updateOp = updateOp.next;\n        }\n      }\n    }\n  }\n}\n\nfunction attachSourceLocations(job) {\n  if (!job.enableDebugLocations || job.relativeTemplatePath === null) {\n    return;\n  }\n  for (const unit of job.units) {\n    const locations = [];\n    for (const op of unit.create) {\n      if (op.kind === OpKind.ElementStart || op.kind === OpKind.Element) {\n        const start = op.startSourceSpan.start;\n        locations.push({\n          targetSlot: op.handle,\n          offset: start.offset,\n          line: start.line,\n          column: start.col\n        });\n      }\n    }\n    if (locations.length > 0) {\n      unit.create.push(createSourceLocationOp(job.relativeTemplatePath, locations));\n    }\n  }\n}\n\nfunction createOpXrefMap(unit) {\n  const map = new Map();\n  for (const op of unit.create) {\n    if (!hasConsumesSlotTrait(op)) {\n      continue;\n    }\n    map.set(op.xref, op);\n    if (op.kind === OpKind.RepeaterCreate && op.emptyView !== null) {\n      map.set(op.emptyView, op);\n    }\n  }\n  return map;\n}\n\nfunction extractAttributes(job) {\n  for (const unit of job.units) {\n    const elements = createOpXrefMap(unit);\n    for (const op of unit.ops()) {\n      switch (op.kind) {\n        case OpKind.Attribute:\n          extractAttributeOp(unit, op, elements);\n          break;\n        case OpKind.Property:\n          if (op.bindingKind !== BindingKind.LegacyAnimation && op.bindingKind !== BindingKind.Animation) {\n            let bindingKind;\n            if (op.i18nMessage !== null && op.templateKind === null) {\n              bindingKind = BindingKind.I18n;\n            } else if (op.isStructuralTemplateAttribute) {\n              bindingKind = BindingKind.Template;\n            } else {\n              bindingKind = BindingKind.Property;\n            }\n            OpList.insertBefore(createExtractedAttributeOp(op.target, bindingKind, null, op.name, null, null, null, op.securityContext), lookupElement$3(elements, op.target));\n          }\n          break;\n        case OpKind.Control:\n          OpList.insertBefore(createExtractedAttributeOp(op.target, BindingKind.Property, null, 'field', null, null, null, op.securityContext), lookupElement$3(elements, op.target));\n          break;\n        case OpKind.TwoWayProperty:\n          OpList.insertBefore(createExtractedAttributeOp(op.target, BindingKind.TwoWayProperty, null, op.name, null, null, null, op.securityContext), lookupElement$3(elements, op.target));\n          break;\n        case OpKind.StyleProp:\n        case OpKind.ClassProp:\n          if (unit.job.compatibility === CompatibilityMode.TemplateDefinitionBuilder && op.expression instanceof EmptyExpr) {\n            OpList.insertBefore(createExtractedAttributeOp(op.target, BindingKind.Property, null, op.name, null, null, null, SecurityContext.STYLE), lookupElement$3(elements, op.target));\n          }\n          break;\n        case OpKind.Listener:\n          if (!op.isLegacyAnimationListener) {\n            const extractedAttributeOp = createExtractedAttributeOp(op.target, BindingKind.Property, null, op.name, null, null, null, SecurityContext.NONE);\n            if (job.kind === CompilationJobKind.Host) {\n              if (job.compatibility) {\n                break;\n              }\n              unit.create.push(extractedAttributeOp);\n            } else {\n              OpList.insertBefore(extractedAttributeOp, lookupElement$3(elements, op.target));\n            }\n          }\n          break;\n        case OpKind.TwoWayListener:\n          if (job.kind !== CompilationJobKind.Host) {\n            const extractedAttributeOp = createExtractedAttributeOp(op.target, BindingKind.Property, null, op.name, null, null, null, SecurityContext.NONE);\n            OpList.insertBefore(extractedAttributeOp, lookupElement$3(elements, op.target));\n          }\n          break;\n      }\n    }\n  }\n}\nfunction lookupElement$3(elements, xref) {\n  const el = elements.get(xref);\n  if (el === undefined) {\n    throw new Error('All attributes should have an element-like target.');\n  }\n  return el;\n}\nfunction extractAttributeOp(unit, op, elements) {\n  if (op.expression instanceof Interpolation) {\n    return;\n  }\n  let extractable = op.isTextAttribute || op.expression.isConstant();\n  if (unit.job.compatibility === CompatibilityMode.TemplateDefinitionBuilder) {\n    extractable &&= op.isTextAttribute;\n  }\n  if (extractable) {\n    const extractedAttributeOp = createExtractedAttributeOp(op.target, op.isStructuralTemplateAttribute ? BindingKind.Template : BindingKind.Attribute, op.namespace, op.name, op.expression, op.i18nContext, op.i18nMessage, op.securityContext);\n    if (unit.job.kind === CompilationJobKind.Host) {\n      unit.create.push(extractedAttributeOp);\n    } else {\n      const ownerOp = lookupElement$3(elements, op.target);\n      OpList.insertBefore(extractedAttributeOp, ownerOp);\n    }\n    OpList.remove(op);\n  }\n}\n\nconst ARIA_PREFIX = 'aria-';\nfunction isAriaAttribute(name) {\n  return name.startsWith(ARIA_PREFIX) && name.length > ARIA_PREFIX.length;\n}\n\nfunction lookupElement$2(elements, xref) {\n  const el = elements.get(xref);\n  if (el === undefined) {\n    throw new Error('All attributes should have an element-like target.');\n  }\n  return el;\n}\nfunction specializeBindings(job) {\n  const elements = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (!isElementOrContainerOp(op)) {\n        continue;\n      }\n      elements.set(op.xref, op);\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind !== OpKind.Binding) {\n        continue;\n      }\n      switch (op.bindingKind) {\n        case BindingKind.Attribute:\n          if (op.name === 'ngNonBindable') {\n            OpList.remove(op);\n            const target = lookupElement$2(elements, op.target);\n            target.nonBindable = true;\n          } else if (op.name.startsWith('animate.')) {\n            OpList.replace(op, createAnimationBindingOp(op.name, op.target, op.name === 'animate.enter' ? \"enter\" : \"leave\", op.expression, op.securityContext, op.sourceSpan, 0));\n          } else {\n            const [namespace, name] = splitNsName(op.name);\n            OpList.replace(op, createAttributeOp(op.target, namespace, name, op.expression, op.securityContext, op.isTextAttribute, op.isStructuralTemplateAttribute, op.templateKind, op.i18nMessage, op.sourceSpan));\n          }\n          break;\n        case BindingKind.Animation:\n          OpList.replace(op, createAnimationBindingOp(op.name, op.target, op.name === 'animate.enter' ? \"enter\" : \"leave\", op.expression, op.securityContext, op.sourceSpan, 1));\n          break;\n        case BindingKind.Property:\n        case BindingKind.LegacyAnimation:\n          if (job.mode === TemplateCompilationMode.DomOnly && isAriaAttribute(op.name)) {\n            OpList.replace(op, createAttributeOp(op.target, null, op.name, op.expression, op.securityContext, false, op.isStructuralTemplateAttribute, op.templateKind, op.i18nMessage, op.sourceSpan));\n          } else if (job.kind === CompilationJobKind.Host) {\n            OpList.replace(op, createDomPropertyOp(op.name, op.expression, op.bindingKind, op.i18nContext, op.securityContext, op.sourceSpan));\n          } else if (op.name === 'field') {\n            OpList.replace(op, createControlOp(op));\n          } else {\n            OpList.replace(op, createPropertyOp(op.target, op.name, op.expression, op.bindingKind, op.securityContext, op.isStructuralTemplateAttribute, op.templateKind, op.i18nContext, op.i18nMessage, op.sourceSpan));\n          }\n          break;\n        case BindingKind.TwoWayProperty:\n          if (!(op.expression instanceof Expression)) {\n            throw new Error(`Expected value of two-way property binding \"${op.name}\" to be an expression`);\n          }\n          OpList.replace(op, createTwoWayPropertyOp(op.target, op.name, op.expression, op.securityContext, op.isStructuralTemplateAttribute, op.templateKind, op.i18nContext, op.i18nMessage, op.sourceSpan));\n          break;\n        case BindingKind.I18n:\n        case BindingKind.ClassName:\n        case BindingKind.StyleProperty:\n          throw new Error(`Unhandled binding of kind ${BindingKind[op.bindingKind]}`);\n      }\n    }\n  }\n}\n\nconst CHAIN_COMPATIBILITY = new Map([[Identifiers.ariaProperty, Identifiers.ariaProperty], [Identifiers.attribute, Identifiers.attribute], [Identifiers.classProp, Identifiers.classProp], [Identifiers.element, Identifiers.element], [Identifiers.elementContainer, Identifiers.elementContainer], [Identifiers.elementContainerEnd, Identifiers.elementContainerEnd], [Identifiers.elementContainerStart, Identifiers.elementContainerStart], [Identifiers.elementEnd, Identifiers.elementEnd], [Identifiers.elementStart, Identifiers.elementStart], [Identifiers.domProperty, Identifiers.domProperty], [Identifiers.i18nExp, Identifiers.i18nExp], [Identifiers.listener, Identifiers.listener], [Identifiers.listener, Identifiers.listener], [Identifiers.property, Identifiers.property], [Identifiers.styleProp, Identifiers.styleProp], [Identifiers.syntheticHostListener, Identifiers.syntheticHostListener], [Identifiers.syntheticHostProperty, Identifiers.syntheticHostProperty], [Identifiers.templateCreate, Identifiers.templateCreate], [Identifiers.twoWayProperty, Identifiers.twoWayProperty], [Identifiers.twoWayListener, Identifiers.twoWayListener], [Identifiers.declareLet, Identifiers.declareLet], [Identifiers.conditionalCreate, Identifiers.conditionalBranchCreate], [Identifiers.conditionalBranchCreate, Identifiers.conditionalBranchCreate], [Identifiers.domElement, Identifiers.domElement], [Identifiers.domElementStart, Identifiers.domElementStart], [Identifiers.domElementEnd, Identifiers.domElementEnd], [Identifiers.domElementContainer, Identifiers.domElementContainer], [Identifiers.domElementContainerStart, Identifiers.domElementContainerStart], [Identifiers.domElementContainerEnd, Identifiers.domElementContainerEnd], [Identifiers.domListener, Identifiers.domListener], [Identifiers.domTemplate, Identifiers.domTemplate], [Identifiers.animationEnter, Identifiers.animationEnter], [Identifiers.animationLeave, Identifiers.animationLeave], [Identifiers.animationEnterListener, Identifiers.animationEnterListener], [Identifiers.animationLeaveListener, Identifiers.animationLeaveListener]]);\nconst MAX_CHAIN_LENGTH = 256;\nfunction chain(job) {\n  for (const unit of job.units) {\n    chainOperationsInList(unit.create);\n    chainOperationsInList(unit.update);\n  }\n}\nfunction chainOperationsInList(opList) {\n  let chain = null;\n  for (const op of opList) {\n    if (op.kind !== OpKind.Statement || !(op.statement instanceof ExpressionStatement)) {\n      chain = null;\n      continue;\n    }\n    if (!(op.statement.expr instanceof InvokeFunctionExpr) || !(op.statement.expr.fn instanceof ExternalExpr)) {\n      chain = null;\n      continue;\n    }\n    const instruction = op.statement.expr.fn.value;\n    if (!CHAIN_COMPATIBILITY.has(instruction)) {\n      chain = null;\n      continue;\n    }\n    if (chain !== null && CHAIN_COMPATIBILITY.get(chain.instruction) === instruction && chain.length < MAX_CHAIN_LENGTH) {\n      const expression = chain.expression.callFn(op.statement.expr.args, op.statement.expr.sourceSpan, op.statement.expr.pure);\n      chain.expression = expression;\n      chain.op.statement = expression.toStmt();\n      chain.length++;\n      OpList.remove(op);\n    } else {\n      chain = {\n        op,\n        instruction,\n        expression: op.statement.expr,\n        length: 1\n      };\n    }\n  }\n}\n\nfunction collapseSingletonInterpolations(job) {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      const eligibleOpKind = op.kind === OpKind.Attribute || op.kind === OpKind.StyleProp || op.kind == OpKind.StyleMap || op.kind === OpKind.ClassMap;\n      if (eligibleOpKind && op.expression instanceof Interpolation && op.expression.strings.length === 2 && op.expression.strings.every(s => s === '')) {\n        op.expression = op.expression.expressions[0];\n      }\n    }\n  }\n}\n\nfunction generateConditionalExpressions(job) {\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind !== OpKind.Conditional) {\n        continue;\n      }\n      let test;\n      const defaultCase = op.conditions.findIndex(cond => cond.expr === null);\n      if (defaultCase >= 0) {\n        const slot = op.conditions.splice(defaultCase, 1)[0].targetSlot;\n        test = new SlotLiteralExpr(slot);\n      } else {\n        test = literal(-1);\n      }\n      let tmp = op.test == null ? null : new AssignTemporaryExpr(op.test, job.allocateXrefId());\n      let caseExpressionTemporaryXref = null;\n      for (let i = op.conditions.length - 1; i >= 0; i--) {\n        let conditionalCase = op.conditions[i];\n        if (conditionalCase.expr === null) {\n          continue;\n        }\n        if (tmp !== null) {\n          const useTmp = i === 0 ? tmp : new ReadTemporaryExpr(tmp.xref);\n          conditionalCase.expr = new BinaryOperatorExpr(BinaryOperator.Identical, useTmp, conditionalCase.expr);\n        } else if (conditionalCase.alias !== null) {\n          caseExpressionTemporaryXref ??= job.allocateXrefId();\n          conditionalCase.expr = new AssignTemporaryExpr(conditionalCase.expr, caseExpressionTemporaryXref);\n          op.contextValue = new ReadTemporaryExpr(caseExpressionTemporaryXref);\n        }\n        test = new ConditionalExpr(conditionalCase.expr, new SlotLiteralExpr(conditionalCase.targetSlot), test);\n      }\n      op.processed = test;\n      op.conditions = [];\n    }\n  }\n}\n\nconst BINARY_OPERATORS = new Map([['&&', BinaryOperator.And], ['>', BinaryOperator.Bigger], ['>=', BinaryOperator.BiggerEquals], ['|', BinaryOperator.BitwiseOr], ['&', BinaryOperator.BitwiseAnd], ['/', BinaryOperator.Divide], ['=', BinaryOperator.Assign], ['==', BinaryOperator.Equals], ['===', BinaryOperator.Identical], ['<', BinaryOperator.Lower], ['<=', BinaryOperator.LowerEquals], ['-', BinaryOperator.Minus], ['%', BinaryOperator.Modulo], ['**', BinaryOperator.Exponentiation], ['*', BinaryOperator.Multiply], ['!=', BinaryOperator.NotEquals], ['!==', BinaryOperator.NotIdentical], ['??', BinaryOperator.NullishCoalesce], ['||', BinaryOperator.Or], ['+', BinaryOperator.Plus], ['in', BinaryOperator.In], ['+=', BinaryOperator.AdditionAssignment], ['-=', BinaryOperator.SubtractionAssignment], ['*=', BinaryOperator.MultiplicationAssignment], ['/=', BinaryOperator.DivisionAssignment], ['%=', BinaryOperator.RemainderAssignment], ['**=', BinaryOperator.ExponentiationAssignment], ['&&=', BinaryOperator.AndAssignment], ['||=', BinaryOperator.OrAssignment], ['??=', BinaryOperator.NullishCoalesceAssignment]]);\nfunction namespaceForKey(namespacePrefixKey) {\n  const NAMESPACES = new Map([['svg', Namespace.SVG], ['math', Namespace.Math]]);\n  if (namespacePrefixKey === null) {\n    return Namespace.HTML;\n  }\n  return NAMESPACES.get(namespacePrefixKey) ?? Namespace.HTML;\n}\nfunction keyForNamespace(namespace) {\n  const NAMESPACES = new Map([['svg', Namespace.SVG], ['math', Namespace.Math]]);\n  for (const [k, n] of NAMESPACES.entries()) {\n    if (n === namespace) {\n      return k;\n    }\n  }\n  return null;\n}\nfunction prefixWithNamespace(strippedTag, namespace) {\n  if (namespace === Namespace.HTML) {\n    return strippedTag;\n  }\n  return `:${keyForNamespace(namespace)}:${strippedTag}`;\n}\nfunction literalOrArrayLiteral(value) {\n  if (Array.isArray(value)) {\n    return literalArr(value.map(literalOrArrayLiteral));\n  }\n  return literal(value);\n}\n\nfunction collectElementConsts(job) {\n  const allElementAttributes = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.ExtractedAttribute) {\n        const attributes = allElementAttributes.get(op.target) || new ElementAttributes(job.compatibility);\n        allElementAttributes.set(op.target, attributes);\n        attributes.add(op.bindingKind, op.name, op.expression, op.namespace, op.trustedValueFn);\n        OpList.remove(op);\n      }\n    }\n  }\n  if (job instanceof ComponentCompilationJob) {\n    for (const unit of job.units) {\n      for (const op of unit.create) {\n        if (op.kind == OpKind.Projection) {\n          const attributes = allElementAttributes.get(op.xref);\n          if (attributes !== undefined) {\n            const attrArray = serializeAttributes(attributes);\n            if (attrArray.entries.length > 0) {\n              op.attributes = attrArray;\n            }\n          }\n        } else if (isElementOrContainerOp(op)) {\n          op.attributes = getConstIndex(job, allElementAttributes, op.xref);\n          if (op.kind === OpKind.RepeaterCreate && op.emptyView !== null) {\n            op.emptyAttributes = getConstIndex(job, allElementAttributes, op.emptyView);\n          }\n        }\n      }\n    }\n  } else if (job instanceof HostBindingCompilationJob) {\n    for (const [xref, attributes] of allElementAttributes.entries()) {\n      if (xref !== job.root.xref) {\n        throw new Error(`An attribute would be const collected into the host binding's template function, but is not associated with the root xref.`);\n      }\n      const attrArray = serializeAttributes(attributes);\n      if (attrArray.entries.length > 0) {\n        job.root.attributes = attrArray;\n      }\n    }\n  }\n}\nfunction getConstIndex(job, allElementAttributes, xref) {\n  const attributes = allElementAttributes.get(xref);\n  if (attributes !== undefined) {\n    const attrArray = serializeAttributes(attributes);\n    if (attrArray.entries.length > 0) {\n      return job.addConst(attrArray);\n    }\n  }\n  return null;\n}\nconst FLYWEIGHT_ARRAY = Object.freeze([]);\nclass ElementAttributes {\n  compatibility;\n  known = new Map();\n  byKind = new Map();\n  propertyBindings = null;\n  projectAs = null;\n  get attributes() {\n    return this.byKind.get(BindingKind.Attribute) ?? FLYWEIGHT_ARRAY;\n  }\n  get classes() {\n    return this.byKind.get(BindingKind.ClassName) ?? FLYWEIGHT_ARRAY;\n  }\n  get styles() {\n    return this.byKind.get(BindingKind.StyleProperty) ?? FLYWEIGHT_ARRAY;\n  }\n  get bindings() {\n    return this.propertyBindings ?? FLYWEIGHT_ARRAY;\n  }\n  get template() {\n    return this.byKind.get(BindingKind.Template) ?? FLYWEIGHT_ARRAY;\n  }\n  get i18n() {\n    return this.byKind.get(BindingKind.I18n) ?? FLYWEIGHT_ARRAY;\n  }\n  constructor(compatibility) {\n    this.compatibility = compatibility;\n  }\n  isKnown(kind, name) {\n    const nameToValue = this.known.get(kind) ?? new Set();\n    this.known.set(kind, nameToValue);\n    if (nameToValue.has(name)) {\n      return true;\n    }\n    nameToValue.add(name);\n    return false;\n  }\n  add(kind, name, value, namespace, trustedValueFn) {\n    const allowDuplicates = this.compatibility === CompatibilityMode.TemplateDefinitionBuilder && (kind === BindingKind.Attribute || kind === BindingKind.ClassName || kind === BindingKind.StyleProperty);\n    if (!allowDuplicates && this.isKnown(kind, name)) {\n      return;\n    }\n    if (name === 'ngProjectAs') {\n      if (value === null || !(value instanceof LiteralExpr) || value.value == null || typeof value.value?.toString() !== 'string') {\n        throw Error('ngProjectAs must have a string literal value');\n      }\n      this.projectAs = value.value.toString();\n    }\n    const array = this.arrayFor(kind);\n    array.push(...getAttributeNameLiterals(namespace, name));\n    if (kind === BindingKind.Attribute || kind === BindingKind.StyleProperty) {\n      if (value === null) {\n        throw Error('Attribute, i18n attribute, & style element attributes must have a value');\n      }\n      if (trustedValueFn !== null) {\n        if (!isStringLiteral(value)) {\n          throw Error('AssertionError: extracted attribute value should be string literal');\n        }\n        array.push(taggedTemplate(trustedValueFn, new TemplateLiteralExpr([new TemplateLiteralElementExpr(value.value)], []), undefined, value.sourceSpan));\n      } else {\n        array.push(value);\n      }\n    }\n  }\n  arrayFor(kind) {\n    if (kind === BindingKind.Property || kind === BindingKind.TwoWayProperty) {\n      this.propertyBindings ??= [];\n      return this.propertyBindings;\n    } else {\n      if (!this.byKind.has(kind)) {\n        this.byKind.set(kind, []);\n      }\n      return this.byKind.get(kind);\n    }\n  }\n}\nfunction getAttributeNameLiterals(namespace, name) {\n  const nameLiteral = literal(name);\n  if (namespace) {\n    return [literal(0), literal(namespace), nameLiteral];\n  }\n  return [nameLiteral];\n}\nfunction serializeAttributes({\n  attributes,\n  bindings,\n  classes,\n  i18n,\n  projectAs,\n  styles,\n  template\n}) {\n  const attrArray = [...attributes];\n  if (projectAs !== null) {\n    const parsedR3Selector = parseSelectorToR3Selector(projectAs)[0];\n    attrArray.push(literal(5), literalOrArrayLiteral(parsedR3Selector));\n  }\n  if (classes.length > 0) {\n    attrArray.push(literal(1), ...classes);\n  }\n  if (styles.length > 0) {\n    attrArray.push(literal(2), ...styles);\n  }\n  if (bindings.length > 0) {\n    attrArray.push(literal(3), ...bindings);\n  }\n  if (template.length > 0) {\n    attrArray.push(literal(4), ...template);\n  }\n  if (i18n.length > 0) {\n    attrArray.push(literal(6), ...i18n);\n  }\n  return literalArr(attrArray);\n}\n\nfunction lookupElement$1(elements, xref) {\n  const el = elements.get(xref);\n  if (el === undefined) {\n    throw new Error('All attributes should have an element-like target.');\n  }\n  return el;\n}\nfunction convertAnimations(job) {\n  const elements = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (!isElementOrContainerOp(op)) {\n        continue;\n      }\n      elements.set(op.xref, op);\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind === OpKind.AnimationBinding) {\n        const createAnimationOp = getAnimationOp(op);\n        if (job.kind === CompilationJobKind.Host) {\n          unit.create.push(createAnimationOp);\n        } else {\n          OpList.insertAfter(createAnimationOp, lookupElement$1(elements, op.target));\n        }\n        OpList.remove(op);\n      }\n    }\n  }\n}\nfunction getAnimationOp(op) {\n  if (op.animationBindingKind === 0) {\n    return createAnimationStringOp(op.name, op.target, op.name === 'animate.enter' ? \"enter\" : \"leave\", op.expression, op.securityContext, op.sourceSpan);\n  } else {\n    const expression = op.expression;\n    return createAnimationOp(op.name, op.target, op.name === 'animate.enter' ? \"enter\" : \"leave\", [createStatementOp(new ReturnStatement(expression, expression.sourceSpan))], op.securityContext, op.sourceSpan);\n  }\n}\n\nfunction convertI18nBindings(job) {\n  const i18nAttributesByElem = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.I18nAttributes) {\n        i18nAttributesByElem.set(op.target, op);\n      }\n    }\n    for (const op of unit.update) {\n      switch (op.kind) {\n        case OpKind.Property:\n        case OpKind.Attribute:\n          if (op.i18nContext === null) {\n            continue;\n          }\n          if (!(op.expression instanceof Interpolation)) {\n            continue;\n          }\n          const i18nAttributesForElem = i18nAttributesByElem.get(op.target);\n          if (i18nAttributesForElem === undefined) {\n            throw new Error('AssertionError: An i18n attribute binding instruction requires the owning element to have an I18nAttributes create instruction');\n          }\n          if (i18nAttributesForElem.target !== op.target) {\n            throw new Error('AssertionError: Expected i18nAttributes target element to match binding target element');\n          }\n          const ops = [];\n          for (let i = 0; i < op.expression.expressions.length; i++) {\n            const expr = op.expression.expressions[i];\n            if (op.expression.i18nPlaceholders.length !== op.expression.expressions.length) {\n              throw new Error(`AssertionError: An i18n attribute binding instruction requires the same number of expressions and placeholders, but found ${op.expression.i18nPlaceholders.length} placeholders and ${op.expression.expressions.length} expressions`);\n            }\n            ops.push(createI18nExpressionOp(op.i18nContext, i18nAttributesForElem.target, i18nAttributesForElem.xref, i18nAttributesForElem.handle, expr, null, op.expression.i18nPlaceholders[i], I18nParamResolutionTime.Creation, I18nExpressionFor.I18nAttribute, op.name, op.sourceSpan));\n          }\n          OpList.replaceWithMany(op, ops);\n          break;\n      }\n    }\n  }\n}\n\nfunction createI18nContexts(job) {\n  const attrContextByMessage = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      switch (op.kind) {\n        case OpKind.Binding:\n        case OpKind.Property:\n        case OpKind.Attribute:\n        case OpKind.ExtractedAttribute:\n          if (op.i18nMessage === null) {\n            continue;\n          }\n          if (!attrContextByMessage.has(op.i18nMessage)) {\n            const i18nContext = createI18nContextOp(I18nContextKind.Attr, job.allocateXrefId(), null, op.i18nMessage, null);\n            unit.create.push(i18nContext);\n            attrContextByMessage.set(op.i18nMessage, i18nContext.xref);\n          }\n          op.i18nContext = attrContextByMessage.get(op.i18nMessage);\n          break;\n      }\n    }\n  }\n  const blockContextByI18nBlock = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nStart:\n          if (op.xref === op.root) {\n            const contextOp = createI18nContextOp(I18nContextKind.RootI18n, job.allocateXrefId(), op.xref, op.message, null);\n            unit.create.push(contextOp);\n            op.context = contextOp.xref;\n            blockContextByI18nBlock.set(op.xref, contextOp);\n          }\n          break;\n      }\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.I18nStart && op.xref !== op.root) {\n        const rootContext = blockContextByI18nBlock.get(op.root);\n        if (rootContext === undefined) {\n          throw Error('AssertionError: Root i18n block i18n context should have been created.');\n        }\n        op.context = rootContext.xref;\n        blockContextByI18nBlock.set(op.xref, rootContext);\n      }\n    }\n  }\n  let currentI18nOp = null;\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nStart:\n          currentI18nOp = op;\n          break;\n        case OpKind.I18nEnd:\n          currentI18nOp = null;\n          break;\n        case OpKind.IcuStart:\n          if (currentI18nOp === null) {\n            throw Error('AssertionError: Unexpected ICU outside of an i18n block.');\n          }\n          if (op.message.id !== currentI18nOp.message.id) {\n            const contextOp = createI18nContextOp(I18nContextKind.Icu, job.allocateXrefId(), currentI18nOp.root, op.message, null);\n            unit.create.push(contextOp);\n            op.context = contextOp.xref;\n          } else {\n            op.context = currentI18nOp.context;\n            blockContextByI18nBlock.get(currentI18nOp.xref).contextKind = I18nContextKind.Icu;\n          }\n          break;\n      }\n    }\n  }\n}\n\nfunction deduplicateTextBindings(job) {\n  const seen = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.update.reversed()) {\n      if (op.kind === OpKind.Binding && op.isTextAttribute) {\n        const seenForElement = seen.get(op.target) || new Set();\n        if (seenForElement.has(op.name)) {\n          if (job.compatibility === CompatibilityMode.TemplateDefinitionBuilder) {\n            if (op.name === 'style' || op.name === 'class') {\n              OpList.remove(op);\n            }\n          }\n        }\n        seenForElement.add(op.name);\n        seen.set(op.target, seenForElement);\n      }\n    }\n  }\n}\n\nfunction configureDeferInstructions(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind !== OpKind.Defer) {\n        continue;\n      }\n      if (op.placeholderMinimumTime !== null) {\n        op.placeholderConfig = new ConstCollectedExpr(literalOrArrayLiteral([op.placeholderMinimumTime]));\n      }\n      if (op.loadingMinimumTime !== null || op.loadingAfterTime !== null) {\n        op.loadingConfig = new ConstCollectedExpr(literalOrArrayLiteral([op.loadingMinimumTime, op.loadingAfterTime]));\n      }\n    }\n  }\n}\n\nfunction resolveDeferTargetNames(job) {\n  const scopes = new Map();\n  function getScopeForView(view) {\n    if (scopes.has(view.xref)) {\n      return scopes.get(view.xref);\n    }\n    const scope = new Scope$1();\n    for (const op of view.create) {\n      if (!isElementOrContainerOp(op) || op.localRefs === null) {\n        continue;\n      }\n      if (!Array.isArray(op.localRefs)) {\n        throw new Error('LocalRefs were already processed, but were needed to resolve defer targets.');\n      }\n      for (const ref of op.localRefs) {\n        if (ref.target !== '') {\n          continue;\n        }\n        scope.targets.set(ref.name, {\n          xref: op.xref,\n          slot: op.handle\n        });\n      }\n    }\n    scopes.set(view.xref, scope);\n    return scope;\n  }\n  function resolveTrigger(deferOwnerView, op, placeholderView) {\n    switch (op.trigger.kind) {\n      case DeferTriggerKind.Idle:\n      case DeferTriggerKind.Never:\n      case DeferTriggerKind.Immediate:\n      case DeferTriggerKind.Timer:\n        return;\n      case DeferTriggerKind.Hover:\n      case DeferTriggerKind.Interaction:\n      case DeferTriggerKind.Viewport:\n        if (op.trigger.targetName === null) {\n          if (placeholderView === null) {\n            throw new Error('defer on trigger with no target name must have a placeholder block');\n          }\n          const placeholder = job.views.get(placeholderView);\n          if (placeholder == undefined) {\n            throw new Error('AssertionError: could not find placeholder view for defer on trigger');\n          }\n          for (const placeholderOp of placeholder.create) {\n            if (hasConsumesSlotTrait(placeholderOp) && (isElementOrContainerOp(placeholderOp) || placeholderOp.kind === OpKind.Projection)) {\n              op.trigger.targetXref = placeholderOp.xref;\n              op.trigger.targetView = placeholderView;\n              op.trigger.targetSlotViewSteps = -1;\n              op.trigger.targetSlot = placeholderOp.handle;\n              return;\n            }\n          }\n          return;\n        }\n        let view = placeholderView !== null ? job.views.get(placeholderView) : deferOwnerView;\n        let step = placeholderView !== null ? -1 : 0;\n        while (view !== null) {\n          const scope = getScopeForView(view);\n          if (scope.targets.has(op.trigger.targetName)) {\n            const {\n              xref,\n              slot\n            } = scope.targets.get(op.trigger.targetName);\n            op.trigger.targetXref = xref;\n            op.trigger.targetView = view.xref;\n            op.trigger.targetSlotViewSteps = step;\n            op.trigger.targetSlot = slot;\n            return;\n          }\n          view = view.parent !== null ? job.views.get(view.parent) : null;\n          step++;\n        }\n        break;\n      default:\n        throw new Error(`Trigger kind ${op.trigger.kind} not handled`);\n    }\n  }\n  for (const unit of job.units) {\n    const defers = new Map();\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.Defer:\n          defers.set(op.xref, op);\n          break;\n        case OpKind.DeferOn:\n          const deferOp = defers.get(op.defer);\n          resolveTrigger(unit, op, op.modifier === \"hydrate\" ? deferOp.mainView : deferOp.placeholderView);\n          break;\n      }\n    }\n  }\n}\nlet Scope$1 = class Scope {\n  targets = new Map();\n};\n\nconst REPLACEMENTS = new Map([[OpKind.ElementEnd, [OpKind.ElementStart, OpKind.Element]], [OpKind.ContainerEnd, [OpKind.ContainerStart, OpKind.Container]], [OpKind.I18nEnd, [OpKind.I18nStart, OpKind.I18n]]]);\nconst IGNORED_OP_KINDS = new Set([OpKind.Pipe]);\nfunction collapseEmptyInstructions(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      const opReplacements = REPLACEMENTS.get(op.kind);\n      if (opReplacements === undefined) {\n        continue;\n      }\n      const [startKind, mergedKind] = opReplacements;\n      let prevOp = op.prev;\n      while (prevOp !== null && IGNORED_OP_KINDS.has(prevOp.kind)) {\n        prevOp = prevOp.prev;\n      }\n      if (prevOp !== null && prevOp.kind === startKind) {\n        prevOp.kind = mergedKind;\n        OpList.remove(op);\n      }\n    }\n  }\n}\n\nfunction expandSafeReads(job) {\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      transformExpressionsInOp(op, e => safeTransform(e, {\n        job\n      }), VisitorContextFlag.None);\n      transformExpressionsInOp(op, ternaryTransform, VisitorContextFlag.None);\n    }\n  }\n}\nfunction needsTemporaryInSafeAccess(e) {\n  if (e instanceof UnaryOperatorExpr) {\n    return needsTemporaryInSafeAccess(e.expr);\n  } else if (e instanceof BinaryOperatorExpr) {\n    return needsTemporaryInSafeAccess(e.lhs) || needsTemporaryInSafeAccess(e.rhs);\n  } else if (e instanceof ConditionalExpr) {\n    if (e.falseCase && needsTemporaryInSafeAccess(e.falseCase)) return true;\n    return needsTemporaryInSafeAccess(e.condition) || needsTemporaryInSafeAccess(e.trueCase);\n  } else if (e instanceof NotExpr) {\n    return needsTemporaryInSafeAccess(e.condition);\n  } else if (e instanceof AssignTemporaryExpr) {\n    return needsTemporaryInSafeAccess(e.expr);\n  } else if (e instanceof ReadPropExpr) {\n    return needsTemporaryInSafeAccess(e.receiver);\n  } else if (e instanceof ReadKeyExpr) {\n    return needsTemporaryInSafeAccess(e.receiver) || needsTemporaryInSafeAccess(e.index);\n  } else if (e instanceof ParenthesizedExpr) {\n    return needsTemporaryInSafeAccess(e.expr);\n  }\n  return e instanceof InvokeFunctionExpr || e instanceof LiteralArrayExpr || e instanceof LiteralMapExpr || e instanceof SafeInvokeFunctionExpr || e instanceof PipeBindingExpr;\n}\nfunction temporariesIn(e) {\n  const temporaries = new Set();\n  transformExpressionsInExpression(e, e => {\n    if (e instanceof AssignTemporaryExpr) {\n      temporaries.add(e.xref);\n    }\n    return e;\n  }, VisitorContextFlag.None);\n  return temporaries;\n}\nfunction eliminateTemporaryAssignments(e, tmps, ctx) {\n  transformExpressionsInExpression(e, e => {\n    if (e instanceof AssignTemporaryExpr && tmps.has(e.xref)) {\n      const read = new ReadTemporaryExpr(e.xref);\n      return ctx.job.compatibility === CompatibilityMode.TemplateDefinitionBuilder ? new AssignTemporaryExpr(read, read.xref) : read;\n    }\n    return e;\n  }, VisitorContextFlag.None);\n  return e;\n}\nfunction safeTernaryWithTemporary(guard, body, ctx) {\n  let result;\n  if (needsTemporaryInSafeAccess(guard)) {\n    const xref = ctx.job.allocateXrefId();\n    result = [new AssignTemporaryExpr(guard, xref), new ReadTemporaryExpr(xref)];\n  } else {\n    result = [guard, guard.clone()];\n    eliminateTemporaryAssignments(result[1], temporariesIn(result[0]), ctx);\n  }\n  return new SafeTernaryExpr(result[0], body(result[1]));\n}\nfunction isSafeAccessExpression(e) {\n  return e instanceof SafePropertyReadExpr || e instanceof SafeKeyedReadExpr || e instanceof SafeInvokeFunctionExpr;\n}\nfunction isUnsafeAccessExpression(e) {\n  return e instanceof ReadPropExpr || e instanceof ReadKeyExpr || e instanceof InvokeFunctionExpr;\n}\nfunction isAccessExpression(e) {\n  return isSafeAccessExpression(e) || isUnsafeAccessExpression(e);\n}\nfunction deepestSafeTernary(e) {\n  if (isAccessExpression(e) && e.receiver instanceof SafeTernaryExpr) {\n    let st = e.receiver;\n    while (st.expr instanceof SafeTernaryExpr) {\n      st = st.expr;\n    }\n    return st;\n  }\n  return null;\n}\nfunction safeTransform(e, ctx) {\n  if (!isAccessExpression(e)) {\n    return e;\n  }\n  const dst = deepestSafeTernary(e);\n  if (dst) {\n    if (e instanceof InvokeFunctionExpr) {\n      dst.expr = dst.expr.callFn(e.args);\n      return e.receiver;\n    }\n    if (e instanceof ReadPropExpr) {\n      dst.expr = dst.expr.prop(e.name);\n      return e.receiver;\n    }\n    if (e instanceof ReadKeyExpr) {\n      dst.expr = dst.expr.key(e.index);\n      return e.receiver;\n    }\n    if (e instanceof SafeInvokeFunctionExpr) {\n      dst.expr = safeTernaryWithTemporary(dst.expr, r => r.callFn(e.args), ctx);\n      return e.receiver;\n    }\n    if (e instanceof SafePropertyReadExpr) {\n      dst.expr = safeTernaryWithTemporary(dst.expr, r => r.prop(e.name), ctx);\n      return e.receiver;\n    }\n    if (e instanceof SafeKeyedReadExpr) {\n      dst.expr = safeTernaryWithTemporary(dst.expr, r => r.key(e.index), ctx);\n      return e.receiver;\n    }\n  } else {\n    if (e instanceof SafeInvokeFunctionExpr) {\n      return safeTernaryWithTemporary(e.receiver, r => r.callFn(e.args), ctx);\n    }\n    if (e instanceof SafePropertyReadExpr) {\n      return safeTernaryWithTemporary(e.receiver, r => r.prop(e.name), ctx);\n    }\n    if (e instanceof SafeKeyedReadExpr) {\n      return safeTernaryWithTemporary(e.receiver, r => r.key(e.index), ctx);\n    }\n  }\n  return e;\n}\nfunction ternaryTransform(e) {\n  if (!(e instanceof SafeTernaryExpr)) {\n    return e;\n  }\n  return new ParenthesizedExpr(new ConditionalExpr(new BinaryOperatorExpr(BinaryOperator.Equals, e.guard, NULL_EXPR), NULL_EXPR, e.expr));\n}\n\nconst ESCAPE$1 = '\\uFFFD';\nconst ELEMENT_MARKER = '#';\nconst TEMPLATE_MARKER = '*';\nconst TAG_CLOSE_MARKER = '/';\nconst CONTEXT_MARKER = ':';\nconst LIST_START_MARKER = '[';\nconst LIST_END_MARKER = ']';\nconst LIST_DELIMITER = '|';\nfunction extractI18nMessages(job) {\n  const i18nMessagesByContext = new Map();\n  const i18nBlocks = new Map();\n  const i18nContexts = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nContext:\n          const i18nMessageOp = createI18nMessage(job, op);\n          unit.create.push(i18nMessageOp);\n          i18nMessagesByContext.set(op.xref, i18nMessageOp);\n          i18nContexts.set(op.xref, op);\n          break;\n        case OpKind.I18nStart:\n          i18nBlocks.set(op.xref, op);\n          break;\n      }\n    }\n  }\n  let currentIcu = null;\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.IcuStart:\n          currentIcu = op;\n          OpList.remove(op);\n          const icuContext = i18nContexts.get(op.context);\n          if (icuContext.contextKind !== I18nContextKind.Icu) {\n            continue;\n          }\n          const i18nBlock = i18nBlocks.get(icuContext.i18nBlock);\n          if (i18nBlock.context === icuContext.xref) {\n            continue;\n          }\n          const rootI18nBlock = i18nBlocks.get(i18nBlock.root);\n          const rootMessage = i18nMessagesByContext.get(rootI18nBlock.context);\n          if (rootMessage === undefined) {\n            throw Error('AssertionError: ICU sub-message should belong to a root message.');\n          }\n          const subMessage = i18nMessagesByContext.get(icuContext.xref);\n          subMessage.messagePlaceholder = op.messagePlaceholder;\n          rootMessage.subMessages.push(subMessage.xref);\n          break;\n        case OpKind.IcuEnd:\n          currentIcu = null;\n          OpList.remove(op);\n          break;\n        case OpKind.IcuPlaceholder:\n          if (currentIcu === null || currentIcu.context == null) {\n            throw Error('AssertionError: Unexpected ICU placeholder outside of i18n context');\n          }\n          const msg = i18nMessagesByContext.get(currentIcu.context);\n          msg.postprocessingParams.set(op.name, literal(formatIcuPlaceholder(op)));\n          OpList.remove(op);\n          break;\n      }\n    }\n  }\n}\nfunction createI18nMessage(job, context, messagePlaceholder) {\n  let formattedParams = formatParams(context.params);\n  const formattedPostprocessingParams = formatParams(context.postprocessingParams);\n  let needsPostprocessing = [...context.params.values()].some(v => v.length > 1);\n  return createI18nMessageOp(job.allocateXrefId(), context.xref, context.i18nBlock, context.message, null, formattedParams, formattedPostprocessingParams, needsPostprocessing);\n}\nfunction formatIcuPlaceholder(op) {\n  if (op.strings.length !== op.expressionPlaceholders.length + 1) {\n    throw Error(`AssertionError: Invalid ICU placeholder with ${op.strings.length} strings and ${op.expressionPlaceholders.length} expressions`);\n  }\n  const values = op.expressionPlaceholders.map(formatValue);\n  return op.strings.flatMap((str, i) => [str, values[i] || '']).join('');\n}\nfunction formatParams(params) {\n  const formattedParams = new Map();\n  for (const [placeholder, placeholderValues] of params) {\n    const serializedValues = formatParamValues(placeholderValues);\n    if (serializedValues !== null) {\n      formattedParams.set(placeholder, literal(serializedValues));\n    }\n  }\n  return formattedParams;\n}\nfunction formatParamValues(values) {\n  if (values.length === 0) {\n    return null;\n  }\n  const serializedValues = values.map(value => formatValue(value));\n  return serializedValues.length === 1 ? serializedValues[0] : `${LIST_START_MARKER}${serializedValues.join(LIST_DELIMITER)}${LIST_END_MARKER}`;\n}\nfunction formatValue(value) {\n  if (value.flags & I18nParamValueFlags.ElementTag && value.flags & I18nParamValueFlags.TemplateTag) {\n    if (typeof value.value !== 'object') {\n      throw Error('AssertionError: Expected i18n param value to have an element and template slot');\n    }\n    const elementValue = formatValue({\n      ...value,\n      value: value.value.element,\n      flags: value.flags & ~I18nParamValueFlags.TemplateTag\n    });\n    const templateValue = formatValue({\n      ...value,\n      value: value.value.template,\n      flags: value.flags & ~I18nParamValueFlags.ElementTag\n    });\n    if (value.flags & I18nParamValueFlags.OpenTag && value.flags & I18nParamValueFlags.CloseTag) {\n      return `${templateValue}${elementValue}${templateValue}`;\n    }\n    return value.flags & I18nParamValueFlags.CloseTag ? `${elementValue}${templateValue}` : `${templateValue}${elementValue}`;\n  }\n  if (value.flags & I18nParamValueFlags.OpenTag && value.flags & I18nParamValueFlags.CloseTag) {\n    return `${formatValue({\n      ...value,\n      flags: value.flags & ~I18nParamValueFlags.CloseTag\n    })}${formatValue({\n      ...value,\n      flags: value.flags & ~I18nParamValueFlags.OpenTag\n    })}`;\n  }\n  if (value.flags === I18nParamValueFlags.None) {\n    return `${value.value}`;\n  }\n  let tagMarker = '';\n  let closeMarker = '';\n  if (value.flags & I18nParamValueFlags.ElementTag) {\n    tagMarker = ELEMENT_MARKER;\n  } else if (value.flags & I18nParamValueFlags.TemplateTag) {\n    tagMarker = TEMPLATE_MARKER;\n  }\n  if (tagMarker !== '') {\n    closeMarker = value.flags & I18nParamValueFlags.CloseTag ? TAG_CLOSE_MARKER : '';\n  }\n  const context = value.subTemplateIndex === null ? '' : `${CONTEXT_MARKER}${value.subTemplateIndex}`;\n  return `${ESCAPE$1}${closeMarker}${tagMarker}${value.value}${context}${ESCAPE$1}`;\n}\n\nfunction generateAdvance(job) {\n  for (const unit of job.units) {\n    const slotMap = new Map();\n    for (const op of unit.create) {\n      if (!hasConsumesSlotTrait(op)) {\n        continue;\n      } else if (op.handle.slot === null) {\n        throw new Error(`AssertionError: expected slots to have been allocated before generating advance() calls`);\n      }\n      slotMap.set(op.xref, op.handle.slot);\n    }\n    let slotContext = 0;\n    for (const op of unit.update) {\n      let consumer = null;\n      if (hasDependsOnSlotContextTrait(op)) {\n        consumer = op;\n      } else {\n        visitExpressionsInOp(op, expr => {\n          if (consumer === null && hasDependsOnSlotContextTrait(expr)) {\n            consumer = expr;\n          }\n        });\n      }\n      if (consumer === null) {\n        continue;\n      }\n      if (!slotMap.has(consumer.target)) {\n        throw new Error(`AssertionError: reference to unknown slot for target ${consumer.target}`);\n      }\n      const slot = slotMap.get(consumer.target);\n      if (slotContext !== slot) {\n        const delta = slot - slotContext;\n        if (delta < 0) {\n          throw new Error(`AssertionError: slot counter should never need to move backwards`);\n        }\n        OpList.insertBefore(createAdvanceOp(delta, consumer.sourceSpan), op);\n        slotContext = slot;\n      }\n    }\n  }\n}\n\nfunction generateLocalLetReferences(job) {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      if (op.kind !== OpKind.StoreLet) {\n        continue;\n      }\n      const variable = {\n        kind: SemanticVariableKind.Identifier,\n        name: null,\n        identifier: op.declaredName,\n        local: true\n      };\n      OpList.replace(op, createVariableOp(job.allocateXrefId(), variable, new StoreLetExpr(op.target, op.value, op.sourceSpan), VariableFlags.None));\n    }\n  }\n}\n\nfunction generateProjectionDefs(job) {\n  const share = job.compatibility === CompatibilityMode.TemplateDefinitionBuilder;\n  const selectors = [];\n  let projectionSlotIndex = 0;\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.Projection) {\n        selectors.push(op.selector);\n        op.projectionSlotIndex = projectionSlotIndex++;\n      }\n    }\n  }\n  if (selectors.length > 0) {\n    let defExpr = null;\n    if (selectors.length > 1 || selectors[0] !== '*') {\n      const def = selectors.map(s => s === '*' ? s : parseSelectorToR3Selector(s));\n      defExpr = job.pool.getConstLiteral(literalOrArrayLiteral(def), share);\n    }\n    job.contentSelectors = job.pool.getConstLiteral(literalOrArrayLiteral(selectors), share);\n    job.root.create.prepend([createProjectionDefOp(defExpr)]);\n  }\n}\n\nfunction generateVariables(job) {\n  recursivelyProcessView(job.root, null);\n}\nfunction recursivelyProcessView(view, parentScope) {\n  const scope = getScopeForView(view, parentScope);\n  for (const op of view.create) {\n    switch (op.kind) {\n      case OpKind.ConditionalCreate:\n      case OpKind.ConditionalBranchCreate:\n      case OpKind.Template:\n        recursivelyProcessView(view.job.views.get(op.xref), scope);\n        break;\n      case OpKind.Projection:\n        if (op.fallbackView !== null) {\n          recursivelyProcessView(view.job.views.get(op.fallbackView), scope);\n        }\n        break;\n      case OpKind.RepeaterCreate:\n        recursivelyProcessView(view.job.views.get(op.xref), scope);\n        if (op.emptyView) {\n          recursivelyProcessView(view.job.views.get(op.emptyView), scope);\n        }\n        if (op.trackByOps !== null) {\n          op.trackByOps.prepend(generateVariablesInScopeForView(view, scope, false));\n        }\n        break;\n      case OpKind.Animation:\n      case OpKind.AnimationListener:\n      case OpKind.Listener:\n      case OpKind.TwoWayListener:\n        op.handlerOps.prepend(generateVariablesInScopeForView(view, scope, true));\n        break;\n    }\n  }\n  view.update.prepend(generateVariablesInScopeForView(view, scope, false));\n}\nfunction getScopeForView(view, parent) {\n  const scope = {\n    view: view.xref,\n    viewContextVariable: {\n      kind: SemanticVariableKind.Context,\n      name: null,\n      view: view.xref\n    },\n    contextVariables: new Map(),\n    aliases: view.aliases,\n    references: [],\n    letDeclarations: [],\n    parent\n  };\n  for (const identifier of view.contextVariables.keys()) {\n    scope.contextVariables.set(identifier, {\n      kind: SemanticVariableKind.Identifier,\n      name: null,\n      identifier,\n      local: false\n    });\n  }\n  for (const op of view.create) {\n    switch (op.kind) {\n      case OpKind.ElementStart:\n      case OpKind.ConditionalCreate:\n      case OpKind.ConditionalBranchCreate:\n      case OpKind.Template:\n        if (!Array.isArray(op.localRefs)) {\n          throw new Error(`AssertionError: expected localRefs to be an array`);\n        }\n        for (let offset = 0; offset < op.localRefs.length; offset++) {\n          scope.references.push({\n            name: op.localRefs[offset].name,\n            targetId: op.xref,\n            targetSlot: op.handle,\n            offset,\n            variable: {\n              kind: SemanticVariableKind.Identifier,\n              name: null,\n              identifier: op.localRefs[offset].name,\n              local: false\n            }\n          });\n        }\n        break;\n      case OpKind.DeclareLet:\n        scope.letDeclarations.push({\n          targetId: op.xref,\n          targetSlot: op.handle,\n          variable: {\n            kind: SemanticVariableKind.Identifier,\n            name: null,\n            identifier: op.declaredName,\n            local: false\n          }\n        });\n        break;\n    }\n  }\n  return scope;\n}\nfunction generateVariablesInScopeForView(view, scope, isCallback) {\n  const newOps = [];\n  if (scope.view !== view.xref) {\n    newOps.push(createVariableOp(view.job.allocateXrefId(), scope.viewContextVariable, new NextContextExpr(), VariableFlags.None));\n  }\n  const scopeView = view.job.views.get(scope.view);\n  for (const [name, value] of scopeView.contextVariables) {\n    const context = new ContextExpr(scope.view);\n    const variable = value === CTX_REF ? context : new ReadPropExpr(context, value);\n    newOps.push(createVariableOp(view.job.allocateXrefId(), scope.contextVariables.get(name), variable, VariableFlags.None));\n  }\n  for (const alias of scopeView.aliases) {\n    newOps.push(createVariableOp(view.job.allocateXrefId(), alias, alias.expression.clone(), VariableFlags.AlwaysInline));\n  }\n  for (const ref of scope.references) {\n    newOps.push(createVariableOp(view.job.allocateXrefId(), ref.variable, new ReferenceExpr(ref.targetId, ref.targetSlot, ref.offset), VariableFlags.None));\n  }\n  if (scope.view !== view.xref || isCallback) {\n    for (const decl of scope.letDeclarations) {\n      newOps.push(createVariableOp(view.job.allocateXrefId(), decl.variable, new ContextLetReferenceExpr(decl.targetId, decl.targetSlot), VariableFlags.None));\n    }\n  }\n  if (scope.parent !== null) {\n    newOps.push(...generateVariablesInScopeForView(view, scope.parent, false));\n  }\n  return newOps;\n}\n\nfunction collectConstExpressions(job) {\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      transformExpressionsInOp(op, expr => {\n        if (!(expr instanceof ConstCollectedExpr)) {\n          return expr;\n        }\n        return literal(job.addConst(expr.expr));\n      }, VisitorContextFlag.None);\n    }\n  }\n}\n\nconst STYLE_DOT = 'style.';\nconst CLASS_DOT = 'class.';\nconst STYLE_BANG = 'style!';\nconst CLASS_BANG = 'class!';\nconst BANG_IMPORTANT = '!important';\nfunction parseHostStyleProperties(job) {\n  for (const op of job.root.update) {\n    if (!(op.kind === OpKind.Binding && op.bindingKind === BindingKind.Property)) {\n      continue;\n    }\n    if (op.name.endsWith(BANG_IMPORTANT)) {\n      op.name = op.name.substring(0, op.name.length - BANG_IMPORTANT.length);\n    }\n    if (op.name.startsWith(STYLE_DOT)) {\n      op.bindingKind = BindingKind.StyleProperty;\n      op.name = op.name.substring(STYLE_DOT.length);\n      if (!isCssCustomProperty(op.name)) {\n        op.name = hyphenate$1(op.name);\n      }\n      const {\n        property,\n        suffix\n      } = parseProperty(op.name);\n      op.name = property;\n      op.unit = suffix;\n    } else if (op.name.startsWith(STYLE_BANG)) {\n      op.bindingKind = BindingKind.StyleProperty;\n      op.name = 'style';\n    } else if (op.name.startsWith(CLASS_DOT)) {\n      op.bindingKind = BindingKind.ClassName;\n      op.name = parseProperty(op.name.substring(CLASS_DOT.length)).property;\n    } else if (op.name.startsWith(CLASS_BANG)) {\n      op.bindingKind = BindingKind.ClassName;\n      op.name = parseProperty(op.name.substring(CLASS_BANG.length)).property;\n    }\n  }\n}\nfunction isCssCustomProperty(name) {\n  return name.startsWith('--');\n}\nfunction hyphenate$1(value) {\n  return value.replace(/[a-z][A-Z]/g, v => {\n    return v.charAt(0) + '-' + v.charAt(1);\n  }).toLowerCase();\n}\nfunction parseProperty(name) {\n  const overrideIndex = name.indexOf('!important');\n  if (overrideIndex !== -1) {\n    name = overrideIndex > 0 ? name.substring(0, overrideIndex) : '';\n  }\n  let suffix = null;\n  let property = name;\n  const unitIndex = name.lastIndexOf('.');\n  if (unitIndex > 0) {\n    suffix = name.slice(unitIndex + 1);\n    property = name.substring(0, unitIndex);\n  }\n  return {\n    property,\n    suffix\n  };\n}\n\nfunction mapLiteral(obj, quoted = false) {\n  return literalMap(Object.keys(obj).map(key => ({\n    key,\n    quoted,\n    value: obj[key]\n  })));\n}\n\nclass IcuSerializerVisitor {\n  visitText(text) {\n    return text.value;\n  }\n  visitContainer(container) {\n    return container.children.map(child => child.visit(this)).join('');\n  }\n  visitIcu(icu) {\n    const strCases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n    const result = `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;\n    return result;\n  }\n  visitTagPlaceholder(ph) {\n    return ph.isVoid ? this.formatPh(ph.startName) : `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;\n  }\n  visitPlaceholder(ph) {\n    return this.formatPh(ph.name);\n  }\n  visitBlockPlaceholder(ph) {\n    return `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;\n  }\n  visitIcuPlaceholder(ph, context) {\n    return this.formatPh(ph.name);\n  }\n  formatPh(value) {\n    return `{${formatI18nPlaceholderName(value, false)}}`;\n  }\n}\nconst serializer = new IcuSerializerVisitor();\nfunction serializeIcuNode(icu) {\n  return icu.visit(serializer);\n}\n\nclass NodeWithI18n {\n  sourceSpan;\n  i18n;\n  constructor(sourceSpan, i18n) {\n    this.sourceSpan = sourceSpan;\n    this.i18n = i18n;\n  }\n}\nclass Text extends NodeWithI18n {\n  value;\n  tokens;\n  constructor(value, sourceSpan, tokens, i18n) {\n    super(sourceSpan, i18n);\n    this.value = value;\n    this.tokens = tokens;\n  }\n  visit(visitor, context) {\n    return visitor.visitText(this, context);\n  }\n}\nclass Expansion extends NodeWithI18n {\n  switchValue;\n  type;\n  cases;\n  switchValueSourceSpan;\n  constructor(switchValue, type, cases, sourceSpan, switchValueSourceSpan, i18n) {\n    super(sourceSpan, i18n);\n    this.switchValue = switchValue;\n    this.type = type;\n    this.cases = cases;\n    this.switchValueSourceSpan = switchValueSourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitExpansion(this, context);\n  }\n}\nclass ExpansionCase {\n  value;\n  expression;\n  sourceSpan;\n  valueSourceSpan;\n  expSourceSpan;\n  constructor(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {\n    this.value = value;\n    this.expression = expression;\n    this.sourceSpan = sourceSpan;\n    this.valueSourceSpan = valueSourceSpan;\n    this.expSourceSpan = expSourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitExpansionCase(this, context);\n  }\n}\nclass Attribute extends NodeWithI18n {\n  name;\n  value;\n  keySpan;\n  valueSpan;\n  valueTokens;\n  constructor(name, value, sourceSpan, keySpan, valueSpan, valueTokens, i18n) {\n    super(sourceSpan, i18n);\n    this.name = name;\n    this.value = value;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n    this.valueTokens = valueTokens;\n  }\n  visit(visitor, context) {\n    return visitor.visitAttribute(this, context);\n  }\n}\nclass Element extends NodeWithI18n {\n  name;\n  attrs;\n  directives;\n  children;\n  isSelfClosing;\n  startSourceSpan;\n  endSourceSpan;\n  isVoid;\n  constructor(name, attrs, directives, children, isSelfClosing, sourceSpan, startSourceSpan, endSourceSpan = null, isVoid, i18n) {\n    super(sourceSpan, i18n);\n    this.name = name;\n    this.attrs = attrs;\n    this.directives = directives;\n    this.children = children;\n    this.isSelfClosing = isSelfClosing;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n    this.isVoid = isVoid;\n  }\n  visit(visitor, context) {\n    return visitor.visitElement(this, context);\n  }\n}\nclass Comment {\n  value;\n  sourceSpan;\n  constructor(value, sourceSpan) {\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitComment(this, context);\n  }\n}\nclass Block extends NodeWithI18n {\n  name;\n  parameters;\n  children;\n  nameSpan;\n  startSourceSpan;\n  endSourceSpan;\n  constructor(name, parameters, children, sourceSpan, nameSpan, startSourceSpan, endSourceSpan = null, i18n) {\n    super(sourceSpan, i18n);\n    this.name = name;\n    this.parameters = parameters;\n    this.children = children;\n    this.nameSpan = nameSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitBlock(this, context);\n  }\n}\nclass Component extends NodeWithI18n {\n  componentName;\n  tagName;\n  fullName;\n  attrs;\n  directives;\n  children;\n  isSelfClosing;\n  startSourceSpan;\n  endSourceSpan;\n  constructor(componentName, tagName, fullName, attrs, directives, children, isSelfClosing, sourceSpan, startSourceSpan, endSourceSpan = null, i18n) {\n    super(sourceSpan, i18n);\n    this.componentName = componentName;\n    this.tagName = tagName;\n    this.fullName = fullName;\n    this.attrs = attrs;\n    this.directives = directives;\n    this.children = children;\n    this.isSelfClosing = isSelfClosing;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitComponent(this, context);\n  }\n}\nclass Directive {\n  name;\n  attrs;\n  sourceSpan;\n  startSourceSpan;\n  endSourceSpan;\n  constructor(name, attrs, sourceSpan, startSourceSpan, endSourceSpan = null) {\n    this.name = name;\n    this.attrs = attrs;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitDirective(this, context);\n  }\n}\nclass BlockParameter {\n  expression;\n  sourceSpan;\n  constructor(expression, sourceSpan) {\n    this.expression = expression;\n    this.sourceSpan = sourceSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitBlockParameter(this, context);\n  }\n}\nclass LetDeclaration {\n  name;\n  value;\n  sourceSpan;\n  nameSpan;\n  valueSpan;\n  constructor(name, value, sourceSpan, nameSpan, valueSpan) {\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.nameSpan = nameSpan;\n    this.valueSpan = valueSpan;\n  }\n  visit(visitor, context) {\n    return visitor.visitLetDeclaration(this, context);\n  }\n}\nfunction visitAll(visitor, nodes, context = null) {\n  const result = [];\n  const visit = visitor.visit ? ast => visitor.visit(ast, context) || ast.visit(visitor, context) : ast => ast.visit(visitor, context);\n  nodes.forEach(ast => {\n    const astResult = visit(ast);\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\nclass RecursiveVisitor {\n  constructor() {}\n  visitElement(ast, context) {\n    this.visitChildren(context, visit => {\n      visit(ast.attrs);\n      visit(ast.directives);\n      visit(ast.children);\n    });\n  }\n  visitAttribute(ast, context) {}\n  visitText(ast, context) {}\n  visitComment(ast, context) {}\n  visitExpansion(ast, context) {\n    return this.visitChildren(context, visit => {\n      visit(ast.cases);\n    });\n  }\n  visitExpansionCase(ast, context) {}\n  visitBlock(block, context) {\n    this.visitChildren(context, visit => {\n      visit(block.parameters);\n      visit(block.children);\n    });\n  }\n  visitBlockParameter(ast, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {\n    this.visitChildren(context, visit => {\n      visit(component.attrs);\n      visit(component.children);\n    });\n  }\n  visitDirective(directive, context) {\n    this.visitChildren(context, visit => {\n      visit(directive.attrs);\n    });\n  }\n  visitChildren(context, cb) {\n    let results = [];\n    let t = this;\n    function visit(children) {\n      if (children) results.push(visitAll(t, children, context));\n    }\n    cb(visit);\n    return Array.prototype.concat.apply([], results);\n  }\n}\n\nconst NAMED_ENTITIES = {\n  'AElig': '\\u00C6',\n  'AMP': '\\u0026',\n  'amp': '\\u0026',\n  'Aacute': '\\u00C1',\n  'Abreve': '\\u0102',\n  'Acirc': '\\u00C2',\n  'Acy': '\\u0410',\n  'Afr': '\\uD835\\uDD04',\n  'Agrave': '\\u00C0',\n  'Alpha': '\\u0391',\n  'Amacr': '\\u0100',\n  'And': '\\u2A53',\n  'Aogon': '\\u0104',\n  'Aopf': '\\uD835\\uDD38',\n  'ApplyFunction': '\\u2061',\n  'af': '\\u2061',\n  'Aring': '\\u00C5',\n  'angst': '\\u00C5',\n  'Ascr': '\\uD835\\uDC9C',\n  'Assign': '\\u2254',\n  'colone': '\\u2254',\n  'coloneq': '\\u2254',\n  'Atilde': '\\u00C3',\n  'Auml': '\\u00C4',\n  'Backslash': '\\u2216',\n  'setminus': '\\u2216',\n  'setmn': '\\u2216',\n  'smallsetminus': '\\u2216',\n  'ssetmn': '\\u2216',\n  'Barv': '\\u2AE7',\n  'Barwed': '\\u2306',\n  'doublebarwedge': '\\u2306',\n  'Bcy': '\\u0411',\n  'Because': '\\u2235',\n  'becaus': '\\u2235',\n  'because': '\\u2235',\n  'Bernoullis': '\\u212C',\n  'Bscr': '\\u212C',\n  'bernou': '\\u212C',\n  'Beta': '\\u0392',\n  'Bfr': '\\uD835\\uDD05',\n  'Bopf': '\\uD835\\uDD39',\n  'Breve': '\\u02D8',\n  'breve': '\\u02D8',\n  'Bumpeq': '\\u224E',\n  'HumpDownHump': '\\u224E',\n  'bump': '\\u224E',\n  'CHcy': '\\u0427',\n  'COPY': '\\u00A9',\n  'copy': '\\u00A9',\n  'Cacute': '\\u0106',\n  'Cap': '\\u22D2',\n  'CapitalDifferentialD': '\\u2145',\n  'DD': '\\u2145',\n  'Cayleys': '\\u212D',\n  'Cfr': '\\u212D',\n  'Ccaron': '\\u010C',\n  'Ccedil': '\\u00C7',\n  'Ccirc': '\\u0108',\n  'Cconint': '\\u2230',\n  'Cdot': '\\u010A',\n  'Cedilla': '\\u00B8',\n  'cedil': '\\u00B8',\n  'CenterDot': '\\u00B7',\n  'centerdot': '\\u00B7',\n  'middot': '\\u00B7',\n  'Chi': '\\u03A7',\n  'CircleDot': '\\u2299',\n  'odot': '\\u2299',\n  'CircleMinus': '\\u2296',\n  'ominus': '\\u2296',\n  'CirclePlus': '\\u2295',\n  'oplus': '\\u2295',\n  'CircleTimes': '\\u2297',\n  'otimes': '\\u2297',\n  'ClockwiseContourIntegral': '\\u2232',\n  'cwconint': '\\u2232',\n  'CloseCurlyDoubleQuote': '\\u201D',\n  'rdquo': '\\u201D',\n  'rdquor': '\\u201D',\n  'CloseCurlyQuote': '\\u2019',\n  'rsquo': '\\u2019',\n  'rsquor': '\\u2019',\n  'Colon': '\\u2237',\n  'Proportion': '\\u2237',\n  'Colone': '\\u2A74',\n  'Congruent': '\\u2261',\n  'equiv': '\\u2261',\n  'Conint': '\\u222F',\n  'DoubleContourIntegral': '\\u222F',\n  'ContourIntegral': '\\u222E',\n  'conint': '\\u222E',\n  'oint': '\\u222E',\n  'Copf': '\\u2102',\n  'complexes': '\\u2102',\n  'Coproduct': '\\u2210',\n  'coprod': '\\u2210',\n  'CounterClockwiseContourIntegral': '\\u2233',\n  'awconint': '\\u2233',\n  'Cross': '\\u2A2F',\n  'Cscr': '\\uD835\\uDC9E',\n  'Cup': '\\u22D3',\n  'CupCap': '\\u224D',\n  'asympeq': '\\u224D',\n  'DDotrahd': '\\u2911',\n  'DJcy': '\\u0402',\n  'DScy': '\\u0405',\n  'DZcy': '\\u040F',\n  'Dagger': '\\u2021',\n  'ddagger': '\\u2021',\n  'Darr': '\\u21A1',\n  'Dashv': '\\u2AE4',\n  'DoubleLeftTee': '\\u2AE4',\n  'Dcaron': '\\u010E',\n  'Dcy': '\\u0414',\n  'Del': '\\u2207',\n  'nabla': '\\u2207',\n  'Delta': '\\u0394',\n  'Dfr': '\\uD835\\uDD07',\n  'DiacriticalAcute': '\\u00B4',\n  'acute': '\\u00B4',\n  'DiacriticalDot': '\\u02D9',\n  'dot': '\\u02D9',\n  'DiacriticalDoubleAcute': '\\u02DD',\n  'dblac': '\\u02DD',\n  'DiacriticalGrave': '\\u0060',\n  'grave': '\\u0060',\n  'DiacriticalTilde': '\\u02DC',\n  'tilde': '\\u02DC',\n  'Diamond': '\\u22C4',\n  'diam': '\\u22C4',\n  'diamond': '\\u22C4',\n  'DifferentialD': '\\u2146',\n  'dd': '\\u2146',\n  'Dopf': '\\uD835\\uDD3B',\n  'Dot': '\\u00A8',\n  'DoubleDot': '\\u00A8',\n  'die': '\\u00A8',\n  'uml': '\\u00A8',\n  'DotDot': '\\u20DC',\n  'DotEqual': '\\u2250',\n  'doteq': '\\u2250',\n  'esdot': '\\u2250',\n  'DoubleDownArrow': '\\u21D3',\n  'Downarrow': '\\u21D3',\n  'dArr': '\\u21D3',\n  'DoubleLeftArrow': '\\u21D0',\n  'Leftarrow': '\\u21D0',\n  'lArr': '\\u21D0',\n  'DoubleLeftRightArrow': '\\u21D4',\n  'Leftrightarrow': '\\u21D4',\n  'hArr': '\\u21D4',\n  'iff': '\\u21D4',\n  'DoubleLongLeftArrow': '\\u27F8',\n  'Longleftarrow': '\\u27F8',\n  'xlArr': '\\u27F8',\n  'DoubleLongLeftRightArrow': '\\u27FA',\n  'Longleftrightarrow': '\\u27FA',\n  'xhArr': '\\u27FA',\n  'DoubleLongRightArrow': '\\u27F9',\n  'Longrightarrow': '\\u27F9',\n  'xrArr': '\\u27F9',\n  'DoubleRightArrow': '\\u21D2',\n  'Implies': '\\u21D2',\n  'Rightarrow': '\\u21D2',\n  'rArr': '\\u21D2',\n  'DoubleRightTee': '\\u22A8',\n  'vDash': '\\u22A8',\n  'DoubleUpArrow': '\\u21D1',\n  'Uparrow': '\\u21D1',\n  'uArr': '\\u21D1',\n  'DoubleUpDownArrow': '\\u21D5',\n  'Updownarrow': '\\u21D5',\n  'vArr': '\\u21D5',\n  'DoubleVerticalBar': '\\u2225',\n  'par': '\\u2225',\n  'parallel': '\\u2225',\n  'shortparallel': '\\u2225',\n  'spar': '\\u2225',\n  'DownArrow': '\\u2193',\n  'ShortDownArrow': '\\u2193',\n  'darr': '\\u2193',\n  'downarrow': '\\u2193',\n  'DownArrowBar': '\\u2913',\n  'DownArrowUpArrow': '\\u21F5',\n  'duarr': '\\u21F5',\n  'DownBreve': '\\u0311',\n  'DownLeftRightVector': '\\u2950',\n  'DownLeftTeeVector': '\\u295E',\n  'DownLeftVector': '\\u21BD',\n  'leftharpoondown': '\\u21BD',\n  'lhard': '\\u21BD',\n  'DownLeftVectorBar': '\\u2956',\n  'DownRightTeeVector': '\\u295F',\n  'DownRightVector': '\\u21C1',\n  'rhard': '\\u21C1',\n  'rightharpoondown': '\\u21C1',\n  'DownRightVectorBar': '\\u2957',\n  'DownTee': '\\u22A4',\n  'top': '\\u22A4',\n  'DownTeeArrow': '\\u21A7',\n  'mapstodown': '\\u21A7',\n  'Dscr': '\\uD835\\uDC9F',\n  'Dstrok': '\\u0110',\n  'ENG': '\\u014A',\n  'ETH': '\\u00D0',\n  'Eacute': '\\u00C9',\n  'Ecaron': '\\u011A',\n  'Ecirc': '\\u00CA',\n  'Ecy': '\\u042D',\n  'Edot': '\\u0116',\n  'Efr': '\\uD835\\uDD08',\n  'Egrave': '\\u00C8',\n  'Element': '\\u2208',\n  'in': '\\u2208',\n  'isin': '\\u2208',\n  'isinv': '\\u2208',\n  'Emacr': '\\u0112',\n  'EmptySmallSquare': '\\u25FB',\n  'EmptyVerySmallSquare': '\\u25AB',\n  'Eogon': '\\u0118',\n  'Eopf': '\\uD835\\uDD3C',\n  'Epsilon': '\\u0395',\n  'Equal': '\\u2A75',\n  'EqualTilde': '\\u2242',\n  'eqsim': '\\u2242',\n  'esim': '\\u2242',\n  'Equilibrium': '\\u21CC',\n  'rightleftharpoons': '\\u21CC',\n  'rlhar': '\\u21CC',\n  'Escr': '\\u2130',\n  'expectation': '\\u2130',\n  'Esim': '\\u2A73',\n  'Eta': '\\u0397',\n  'Euml': '\\u00CB',\n  'Exists': '\\u2203',\n  'exist': '\\u2203',\n  'ExponentialE': '\\u2147',\n  'ee': '\\u2147',\n  'exponentiale': '\\u2147',\n  'Fcy': '\\u0424',\n  'Ffr': '\\uD835\\uDD09',\n  'FilledSmallSquare': '\\u25FC',\n  'FilledVerySmallSquare': '\\u25AA',\n  'blacksquare': '\\u25AA',\n  'squarf': '\\u25AA',\n  'squf': '\\u25AA',\n  'Fopf': '\\uD835\\uDD3D',\n  'ForAll': '\\u2200',\n  'forall': '\\u2200',\n  'Fouriertrf': '\\u2131',\n  'Fscr': '\\u2131',\n  'GJcy': '\\u0403',\n  'GT': '\\u003E',\n  'gt': '\\u003E',\n  'Gamma': '\\u0393',\n  'Gammad': '\\u03DC',\n  'Gbreve': '\\u011E',\n  'Gcedil': '\\u0122',\n  'Gcirc': '\\u011C',\n  'Gcy': '\\u0413',\n  'Gdot': '\\u0120',\n  'Gfr': '\\uD835\\uDD0A',\n  'Gg': '\\u22D9',\n  'ggg': '\\u22D9',\n  'Gopf': '\\uD835\\uDD3E',\n  'GreaterEqual': '\\u2265',\n  'ge': '\\u2265',\n  'geq': '\\u2265',\n  'GreaterEqualLess': '\\u22DB',\n  'gel': '\\u22DB',\n  'gtreqless': '\\u22DB',\n  'GreaterFullEqual': '\\u2267',\n  'gE': '\\u2267',\n  'geqq': '\\u2267',\n  'GreaterGreater': '\\u2AA2',\n  'GreaterLess': '\\u2277',\n  'gl': '\\u2277',\n  'gtrless': '\\u2277',\n  'GreaterSlantEqual': '\\u2A7E',\n  'geqslant': '\\u2A7E',\n  'ges': '\\u2A7E',\n  'GreaterTilde': '\\u2273',\n  'gsim': '\\u2273',\n  'gtrsim': '\\u2273',\n  'Gscr': '\\uD835\\uDCA2',\n  'Gt': '\\u226B',\n  'NestedGreaterGreater': '\\u226B',\n  'gg': '\\u226B',\n  'HARDcy': '\\u042A',\n  'Hacek': '\\u02C7',\n  'caron': '\\u02C7',\n  'Hat': '\\u005E',\n  'Hcirc': '\\u0124',\n  'Hfr': '\\u210C',\n  'Poincareplane': '\\u210C',\n  'HilbertSpace': '\\u210B',\n  'Hscr': '\\u210B',\n  'hamilt': '\\u210B',\n  'Hopf': '\\u210D',\n  'quaternions': '\\u210D',\n  'HorizontalLine': '\\u2500',\n  'boxh': '\\u2500',\n  'Hstrok': '\\u0126',\n  'HumpEqual': '\\u224F',\n  'bumpe': '\\u224F',\n  'bumpeq': '\\u224F',\n  'IEcy': '\\u0415',\n  'IJlig': '\\u0132',\n  'IOcy': '\\u0401',\n  'Iacute': '\\u00CD',\n  'Icirc': '\\u00CE',\n  'Icy': '\\u0418',\n  'Idot': '\\u0130',\n  'Ifr': '\\u2111',\n  'Im': '\\u2111',\n  'image': '\\u2111',\n  'imagpart': '\\u2111',\n  'Igrave': '\\u00CC',\n  'Imacr': '\\u012A',\n  'ImaginaryI': '\\u2148',\n  'ii': '\\u2148',\n  'Int': '\\u222C',\n  'Integral': '\\u222B',\n  'int': '\\u222B',\n  'Intersection': '\\u22C2',\n  'bigcap': '\\u22C2',\n  'xcap': '\\u22C2',\n  'InvisibleComma': '\\u2063',\n  'ic': '\\u2063',\n  'InvisibleTimes': '\\u2062',\n  'it': '\\u2062',\n  'Iogon': '\\u012E',\n  'Iopf': '\\uD835\\uDD40',\n  'Iota': '\\u0399',\n  'Iscr': '\\u2110',\n  'imagline': '\\u2110',\n  'Itilde': '\\u0128',\n  'Iukcy': '\\u0406',\n  'Iuml': '\\u00CF',\n  'Jcirc': '\\u0134',\n  'Jcy': '\\u0419',\n  'Jfr': '\\uD835\\uDD0D',\n  'Jopf': '\\uD835\\uDD41',\n  'Jscr': '\\uD835\\uDCA5',\n  'Jsercy': '\\u0408',\n  'Jukcy': '\\u0404',\n  'KHcy': '\\u0425',\n  'KJcy': '\\u040C',\n  'Kappa': '\\u039A',\n  'Kcedil': '\\u0136',\n  'Kcy': '\\u041A',\n  'Kfr': '\\uD835\\uDD0E',\n  'Kopf': '\\uD835\\uDD42',\n  'Kscr': '\\uD835\\uDCA6',\n  'LJcy': '\\u0409',\n  'LT': '\\u003C',\n  'lt': '\\u003C',\n  'Lacute': '\\u0139',\n  'Lambda': '\\u039B',\n  'Lang': '\\u27EA',\n  'Laplacetrf': '\\u2112',\n  'Lscr': '\\u2112',\n  'lagran': '\\u2112',\n  'Larr': '\\u219E',\n  'twoheadleftarrow': '\\u219E',\n  'Lcaron': '\\u013D',\n  'Lcedil': '\\u013B',\n  'Lcy': '\\u041B',\n  'LeftAngleBracket': '\\u27E8',\n  'lang': '\\u27E8',\n  'langle': '\\u27E8',\n  'LeftArrow': '\\u2190',\n  'ShortLeftArrow': '\\u2190',\n  'larr': '\\u2190',\n  'leftarrow': '\\u2190',\n  'slarr': '\\u2190',\n  'LeftArrowBar': '\\u21E4',\n  'larrb': '\\u21E4',\n  'LeftArrowRightArrow': '\\u21C6',\n  'leftrightarrows': '\\u21C6',\n  'lrarr': '\\u21C6',\n  'LeftCeiling': '\\u2308',\n  'lceil': '\\u2308',\n  'LeftDoubleBracket': '\\u27E6',\n  'lobrk': '\\u27E6',\n  'LeftDownTeeVector': '\\u2961',\n  'LeftDownVector': '\\u21C3',\n  'dharl': '\\u21C3',\n  'downharpoonleft': '\\u21C3',\n  'LeftDownVectorBar': '\\u2959',\n  'LeftFloor': '\\u230A',\n  'lfloor': '\\u230A',\n  'LeftRightArrow': '\\u2194',\n  'harr': '\\u2194',\n  'leftrightarrow': '\\u2194',\n  'LeftRightVector': '\\u294E',\n  'LeftTee': '\\u22A3',\n  'dashv': '\\u22A3',\n  'LeftTeeArrow': '\\u21A4',\n  'mapstoleft': '\\u21A4',\n  'LeftTeeVector': '\\u295A',\n  'LeftTriangle': '\\u22B2',\n  'vartriangleleft': '\\u22B2',\n  'vltri': '\\u22B2',\n  'LeftTriangleBar': '\\u29CF',\n  'LeftTriangleEqual': '\\u22B4',\n  'ltrie': '\\u22B4',\n  'trianglelefteq': '\\u22B4',\n  'LeftUpDownVector': '\\u2951',\n  'LeftUpTeeVector': '\\u2960',\n  'LeftUpVector': '\\u21BF',\n  'uharl': '\\u21BF',\n  'upharpoonleft': '\\u21BF',\n  'LeftUpVectorBar': '\\u2958',\n  'LeftVector': '\\u21BC',\n  'leftharpoonup': '\\u21BC',\n  'lharu': '\\u21BC',\n  'LeftVectorBar': '\\u2952',\n  'LessEqualGreater': '\\u22DA',\n  'leg': '\\u22DA',\n  'lesseqgtr': '\\u22DA',\n  'LessFullEqual': '\\u2266',\n  'lE': '\\u2266',\n  'leqq': '\\u2266',\n  'LessGreater': '\\u2276',\n  'lessgtr': '\\u2276',\n  'lg': '\\u2276',\n  'LessLess': '\\u2AA1',\n  'LessSlantEqual': '\\u2A7D',\n  'leqslant': '\\u2A7D',\n  'les': '\\u2A7D',\n  'LessTilde': '\\u2272',\n  'lesssim': '\\u2272',\n  'lsim': '\\u2272',\n  'Lfr': '\\uD835\\uDD0F',\n  'Ll': '\\u22D8',\n  'Lleftarrow': '\\u21DA',\n  'lAarr': '\\u21DA',\n  'Lmidot': '\\u013F',\n  'LongLeftArrow': '\\u27F5',\n  'longleftarrow': '\\u27F5',\n  'xlarr': '\\u27F5',\n  'LongLeftRightArrow': '\\u27F7',\n  'longleftrightarrow': '\\u27F7',\n  'xharr': '\\u27F7',\n  'LongRightArrow': '\\u27F6',\n  'longrightarrow': '\\u27F6',\n  'xrarr': '\\u27F6',\n  'Lopf': '\\uD835\\uDD43',\n  'LowerLeftArrow': '\\u2199',\n  'swarr': '\\u2199',\n  'swarrow': '\\u2199',\n  'LowerRightArrow': '\\u2198',\n  'searr': '\\u2198',\n  'searrow': '\\u2198',\n  'Lsh': '\\u21B0',\n  'lsh': '\\u21B0',\n  'Lstrok': '\\u0141',\n  'Lt': '\\u226A',\n  'NestedLessLess': '\\u226A',\n  'll': '\\u226A',\n  'Map': '\\u2905',\n  'Mcy': '\\u041C',\n  'MediumSpace': '\\u205F',\n  'Mellintrf': '\\u2133',\n  'Mscr': '\\u2133',\n  'phmmat': '\\u2133',\n  'Mfr': '\\uD835\\uDD10',\n  'MinusPlus': '\\u2213',\n  'mnplus': '\\u2213',\n  'mp': '\\u2213',\n  'Mopf': '\\uD835\\uDD44',\n  'Mu': '\\u039C',\n  'NJcy': '\\u040A',\n  'Nacute': '\\u0143',\n  'Ncaron': '\\u0147',\n  'Ncedil': '\\u0145',\n  'Ncy': '\\u041D',\n  'NegativeMediumSpace': '\\u200B',\n  'NegativeThickSpace': '\\u200B',\n  'NegativeThinSpace': '\\u200B',\n  'NegativeVeryThinSpace': '\\u200B',\n  'ZeroWidthSpace': '\\u200B',\n  'NewLine': '\\u000A',\n  'Nfr': '\\uD835\\uDD11',\n  'NoBreak': '\\u2060',\n  'NonBreakingSpace': '\\u00A0',\n  'nbsp': '\\u00A0',\n  'Nopf': '\\u2115',\n  'naturals': '\\u2115',\n  'Not': '\\u2AEC',\n  'NotCongruent': '\\u2262',\n  'nequiv': '\\u2262',\n  'NotCupCap': '\\u226D',\n  'NotDoubleVerticalBar': '\\u2226',\n  'npar': '\\u2226',\n  'nparallel': '\\u2226',\n  'nshortparallel': '\\u2226',\n  'nspar': '\\u2226',\n  'NotElement': '\\u2209',\n  'notin': '\\u2209',\n  'notinva': '\\u2209',\n  'NotEqual': '\\u2260',\n  'ne': '\\u2260',\n  'NotEqualTilde': '\\u2242\\u0338',\n  'nesim': '\\u2242\\u0338',\n  'NotExists': '\\u2204',\n  'nexist': '\\u2204',\n  'nexists': '\\u2204',\n  'NotGreater': '\\u226F',\n  'ngt': '\\u226F',\n  'ngtr': '\\u226F',\n  'NotGreaterEqual': '\\u2271',\n  'nge': '\\u2271',\n  'ngeq': '\\u2271',\n  'NotGreaterFullEqual': '\\u2267\\u0338',\n  'ngE': '\\u2267\\u0338',\n  'ngeqq': '\\u2267\\u0338',\n  'NotGreaterGreater': '\\u226B\\u0338',\n  'nGtv': '\\u226B\\u0338',\n  'NotGreaterLess': '\\u2279',\n  'ntgl': '\\u2279',\n  'NotGreaterSlantEqual': '\\u2A7E\\u0338',\n  'ngeqslant': '\\u2A7E\\u0338',\n  'nges': '\\u2A7E\\u0338',\n  'NotGreaterTilde': '\\u2275',\n  'ngsim': '\\u2275',\n  'NotHumpDownHump': '\\u224E\\u0338',\n  'nbump': '\\u224E\\u0338',\n  'NotHumpEqual': '\\u224F\\u0338',\n  'nbumpe': '\\u224F\\u0338',\n  'NotLeftTriangle': '\\u22EA',\n  'nltri': '\\u22EA',\n  'ntriangleleft': '\\u22EA',\n  'NotLeftTriangleBar': '\\u29CF\\u0338',\n  'NotLeftTriangleEqual': '\\u22EC',\n  'nltrie': '\\u22EC',\n  'ntrianglelefteq': '\\u22EC',\n  'NotLess': '\\u226E',\n  'nless': '\\u226E',\n  'nlt': '\\u226E',\n  'NotLessEqual': '\\u2270',\n  'nle': '\\u2270',\n  'nleq': '\\u2270',\n  'NotLessGreater': '\\u2278',\n  'ntlg': '\\u2278',\n  'NotLessLess': '\\u226A\\u0338',\n  'nLtv': '\\u226A\\u0338',\n  'NotLessSlantEqual': '\\u2A7D\\u0338',\n  'nleqslant': '\\u2A7D\\u0338',\n  'nles': '\\u2A7D\\u0338',\n  'NotLessTilde': '\\u2274',\n  'nlsim': '\\u2274',\n  'NotNestedGreaterGreater': '\\u2AA2\\u0338',\n  'NotNestedLessLess': '\\u2AA1\\u0338',\n  'NotPrecedes': '\\u2280',\n  'npr': '\\u2280',\n  'nprec': '\\u2280',\n  'NotPrecedesEqual': '\\u2AAF\\u0338',\n  'npre': '\\u2AAF\\u0338',\n  'npreceq': '\\u2AAF\\u0338',\n  'NotPrecedesSlantEqual': '\\u22E0',\n  'nprcue': '\\u22E0',\n  'NotReverseElement': '\\u220C',\n  'notni': '\\u220C',\n  'notniva': '\\u220C',\n  'NotRightTriangle': '\\u22EB',\n  'nrtri': '\\u22EB',\n  'ntriangleright': '\\u22EB',\n  'NotRightTriangleBar': '\\u29D0\\u0338',\n  'NotRightTriangleEqual': '\\u22ED',\n  'nrtrie': '\\u22ED',\n  'ntrianglerighteq': '\\u22ED',\n  'NotSquareSubset': '\\u228F\\u0338',\n  'NotSquareSubsetEqual': '\\u22E2',\n  'nsqsube': '\\u22E2',\n  'NotSquareSuperset': '\\u2290\\u0338',\n  'NotSquareSupersetEqual': '\\u22E3',\n  'nsqsupe': '\\u22E3',\n  'NotSubset': '\\u2282\\u20D2',\n  'nsubset': '\\u2282\\u20D2',\n  'vnsub': '\\u2282\\u20D2',\n  'NotSubsetEqual': '\\u2288',\n  'nsube': '\\u2288',\n  'nsubseteq': '\\u2288',\n  'NotSucceeds': '\\u2281',\n  'nsc': '\\u2281',\n  'nsucc': '\\u2281',\n  'NotSucceedsEqual': '\\u2AB0\\u0338',\n  'nsce': '\\u2AB0\\u0338',\n  'nsucceq': '\\u2AB0\\u0338',\n  'NotSucceedsSlantEqual': '\\u22E1',\n  'nsccue': '\\u22E1',\n  'NotSucceedsTilde': '\\u227F\\u0338',\n  'NotSuperset': '\\u2283\\u20D2',\n  'nsupset': '\\u2283\\u20D2',\n  'vnsup': '\\u2283\\u20D2',\n  'NotSupersetEqual': '\\u2289',\n  'nsupe': '\\u2289',\n  'nsupseteq': '\\u2289',\n  'NotTilde': '\\u2241',\n  'nsim': '\\u2241',\n  'NotTildeEqual': '\\u2244',\n  'nsime': '\\u2244',\n  'nsimeq': '\\u2244',\n  'NotTildeFullEqual': '\\u2247',\n  'ncong': '\\u2247',\n  'NotTildeTilde': '\\u2249',\n  'nap': '\\u2249',\n  'napprox': '\\u2249',\n  'NotVerticalBar': '\\u2224',\n  'nmid': '\\u2224',\n  'nshortmid': '\\u2224',\n  'nsmid': '\\u2224',\n  'Nscr': '\\uD835\\uDCA9',\n  'Ntilde': '\\u00D1',\n  'Nu': '\\u039D',\n  'OElig': '\\u0152',\n  'Oacute': '\\u00D3',\n  'Ocirc': '\\u00D4',\n  'Ocy': '\\u041E',\n  'Odblac': '\\u0150',\n  'Ofr': '\\uD835\\uDD12',\n  'Ograve': '\\u00D2',\n  'Omacr': '\\u014C',\n  'Omega': '\\u03A9',\n  'ohm': '\\u03A9',\n  'Omicron': '\\u039F',\n  'Oopf': '\\uD835\\uDD46',\n  'OpenCurlyDoubleQuote': '\\u201C',\n  'ldquo': '\\u201C',\n  'OpenCurlyQuote': '\\u2018',\n  'lsquo': '\\u2018',\n  'Or': '\\u2A54',\n  'Oscr': '\\uD835\\uDCAA',\n  'Oslash': '\\u00D8',\n  'Otilde': '\\u00D5',\n  'Otimes': '\\u2A37',\n  'Ouml': '\\u00D6',\n  'OverBar': '\\u203E',\n  'oline': '\\u203E',\n  'OverBrace': '\\u23DE',\n  'OverBracket': '\\u23B4',\n  'tbrk': '\\u23B4',\n  'OverParenthesis': '\\u23DC',\n  'PartialD': '\\u2202',\n  'part': '\\u2202',\n  'Pcy': '\\u041F',\n  'Pfr': '\\uD835\\uDD13',\n  'Phi': '\\u03A6',\n  'Pi': '\\u03A0',\n  'PlusMinus': '\\u00B1',\n  'plusmn': '\\u00B1',\n  'pm': '\\u00B1',\n  'Popf': '\\u2119',\n  'primes': '\\u2119',\n  'Pr': '\\u2ABB',\n  'Precedes': '\\u227A',\n  'pr': '\\u227A',\n  'prec': '\\u227A',\n  'PrecedesEqual': '\\u2AAF',\n  'pre': '\\u2AAF',\n  'preceq': '\\u2AAF',\n  'PrecedesSlantEqual': '\\u227C',\n  'prcue': '\\u227C',\n  'preccurlyeq': '\\u227C',\n  'PrecedesTilde': '\\u227E',\n  'precsim': '\\u227E',\n  'prsim': '\\u227E',\n  'Prime': '\\u2033',\n  'Product': '\\u220F',\n  'prod': '\\u220F',\n  'Proportional': '\\u221D',\n  'prop': '\\u221D',\n  'propto': '\\u221D',\n  'varpropto': '\\u221D',\n  'vprop': '\\u221D',\n  'Pscr': '\\uD835\\uDCAB',\n  'Psi': '\\u03A8',\n  'QUOT': '\\u0022',\n  'quot': '\\u0022',\n  'Qfr': '\\uD835\\uDD14',\n  'Qopf': '\\u211A',\n  'rationals': '\\u211A',\n  'Qscr': '\\uD835\\uDCAC',\n  'RBarr': '\\u2910',\n  'drbkarow': '\\u2910',\n  'REG': '\\u00AE',\n  'circledR': '\\u00AE',\n  'reg': '\\u00AE',\n  'Racute': '\\u0154',\n  'Rang': '\\u27EB',\n  'Rarr': '\\u21A0',\n  'twoheadrightarrow': '\\u21A0',\n  'Rarrtl': '\\u2916',\n  'Rcaron': '\\u0158',\n  'Rcedil': '\\u0156',\n  'Rcy': '\\u0420',\n  'Re': '\\u211C',\n  'Rfr': '\\u211C',\n  'real': '\\u211C',\n  'realpart': '\\u211C',\n  'ReverseElement': '\\u220B',\n  'SuchThat': '\\u220B',\n  'ni': '\\u220B',\n  'niv': '\\u220B',\n  'ReverseEquilibrium': '\\u21CB',\n  'leftrightharpoons': '\\u21CB',\n  'lrhar': '\\u21CB',\n  'ReverseUpEquilibrium': '\\u296F',\n  'duhar': '\\u296F',\n  'Rho': '\\u03A1',\n  'RightAngleBracket': '\\u27E9',\n  'rang': '\\u27E9',\n  'rangle': '\\u27E9',\n  'RightArrow': '\\u2192',\n  'ShortRightArrow': '\\u2192',\n  'rarr': '\\u2192',\n  'rightarrow': '\\u2192',\n  'srarr': '\\u2192',\n  'RightArrowBar': '\\u21E5',\n  'rarrb': '\\u21E5',\n  'RightArrowLeftArrow': '\\u21C4',\n  'rightleftarrows': '\\u21C4',\n  'rlarr': '\\u21C4',\n  'RightCeiling': '\\u2309',\n  'rceil': '\\u2309',\n  'RightDoubleBracket': '\\u27E7',\n  'robrk': '\\u27E7',\n  'RightDownTeeVector': '\\u295D',\n  'RightDownVector': '\\u21C2',\n  'dharr': '\\u21C2',\n  'downharpoonright': '\\u21C2',\n  'RightDownVectorBar': '\\u2955',\n  'RightFloor': '\\u230B',\n  'rfloor': '\\u230B',\n  'RightTee': '\\u22A2',\n  'vdash': '\\u22A2',\n  'RightTeeArrow': '\\u21A6',\n  'map': '\\u21A6',\n  'mapsto': '\\u21A6',\n  'RightTeeVector': '\\u295B',\n  'RightTriangle': '\\u22B3',\n  'vartriangleright': '\\u22B3',\n  'vrtri': '\\u22B3',\n  'RightTriangleBar': '\\u29D0',\n  'RightTriangleEqual': '\\u22B5',\n  'rtrie': '\\u22B5',\n  'trianglerighteq': '\\u22B5',\n  'RightUpDownVector': '\\u294F',\n  'RightUpTeeVector': '\\u295C',\n  'RightUpVector': '\\u21BE',\n  'uharr': '\\u21BE',\n  'upharpoonright': '\\u21BE',\n  'RightUpVectorBar': '\\u2954',\n  'RightVector': '\\u21C0',\n  'rharu': '\\u21C0',\n  'rightharpoonup': '\\u21C0',\n  'RightVectorBar': '\\u2953',\n  'Ropf': '\\u211D',\n  'reals': '\\u211D',\n  'RoundImplies': '\\u2970',\n  'Rrightarrow': '\\u21DB',\n  'rAarr': '\\u21DB',\n  'Rscr': '\\u211B',\n  'realine': '\\u211B',\n  'Rsh': '\\u21B1',\n  'rsh': '\\u21B1',\n  'RuleDelayed': '\\u29F4',\n  'SHCHcy': '\\u0429',\n  'SHcy': '\\u0428',\n  'SOFTcy': '\\u042C',\n  'Sacute': '\\u015A',\n  'Sc': '\\u2ABC',\n  'Scaron': '\\u0160',\n  'Scedil': '\\u015E',\n  'Scirc': '\\u015C',\n  'Scy': '\\u0421',\n  'Sfr': '\\uD835\\uDD16',\n  'ShortUpArrow': '\\u2191',\n  'UpArrow': '\\u2191',\n  'uarr': '\\u2191',\n  'uparrow': '\\u2191',\n  'Sigma': '\\u03A3',\n  'SmallCircle': '\\u2218',\n  'compfn': '\\u2218',\n  'Sopf': '\\uD835\\uDD4A',\n  'Sqrt': '\\u221A',\n  'radic': '\\u221A',\n  'Square': '\\u25A1',\n  'squ': '\\u25A1',\n  'square': '\\u25A1',\n  'SquareIntersection': '\\u2293',\n  'sqcap': '\\u2293',\n  'SquareSubset': '\\u228F',\n  'sqsub': '\\u228F',\n  'sqsubset': '\\u228F',\n  'SquareSubsetEqual': '\\u2291',\n  'sqsube': '\\u2291',\n  'sqsubseteq': '\\u2291',\n  'SquareSuperset': '\\u2290',\n  'sqsup': '\\u2290',\n  'sqsupset': '\\u2290',\n  'SquareSupersetEqual': '\\u2292',\n  'sqsupe': '\\u2292',\n  'sqsupseteq': '\\u2292',\n  'SquareUnion': '\\u2294',\n  'sqcup': '\\u2294',\n  'Sscr': '\\uD835\\uDCAE',\n  'Star': '\\u22C6',\n  'sstarf': '\\u22C6',\n  'Sub': '\\u22D0',\n  'Subset': '\\u22D0',\n  'SubsetEqual': '\\u2286',\n  'sube': '\\u2286',\n  'subseteq': '\\u2286',\n  'Succeeds': '\\u227B',\n  'sc': '\\u227B',\n  'succ': '\\u227B',\n  'SucceedsEqual': '\\u2AB0',\n  'sce': '\\u2AB0',\n  'succeq': '\\u2AB0',\n  'SucceedsSlantEqual': '\\u227D',\n  'sccue': '\\u227D',\n  'succcurlyeq': '\\u227D',\n  'SucceedsTilde': '\\u227F',\n  'scsim': '\\u227F',\n  'succsim': '\\u227F',\n  'Sum': '\\u2211',\n  'sum': '\\u2211',\n  'Sup': '\\u22D1',\n  'Supset': '\\u22D1',\n  'Superset': '\\u2283',\n  'sup': '\\u2283',\n  'supset': '\\u2283',\n  'SupersetEqual': '\\u2287',\n  'supe': '\\u2287',\n  'supseteq': '\\u2287',\n  'THORN': '\\u00DE',\n  'TRADE': '\\u2122',\n  'trade': '\\u2122',\n  'TSHcy': '\\u040B',\n  'TScy': '\\u0426',\n  'Tab': '\\u0009',\n  'Tau': '\\u03A4',\n  'Tcaron': '\\u0164',\n  'Tcedil': '\\u0162',\n  'Tcy': '\\u0422',\n  'Tfr': '\\uD835\\uDD17',\n  'Therefore': '\\u2234',\n  'there4': '\\u2234',\n  'therefore': '\\u2234',\n  'Theta': '\\u0398',\n  'ThickSpace': '\\u205F\\u200A',\n  'ThinSpace': '\\u2009',\n  'thinsp': '\\u2009',\n  'Tilde': '\\u223C',\n  'sim': '\\u223C',\n  'thicksim': '\\u223C',\n  'thksim': '\\u223C',\n  'TildeEqual': '\\u2243',\n  'sime': '\\u2243',\n  'simeq': '\\u2243',\n  'TildeFullEqual': '\\u2245',\n  'cong': '\\u2245',\n  'TildeTilde': '\\u2248',\n  'ap': '\\u2248',\n  'approx': '\\u2248',\n  'asymp': '\\u2248',\n  'thickapprox': '\\u2248',\n  'thkap': '\\u2248',\n  'Topf': '\\uD835\\uDD4B',\n  'TripleDot': '\\u20DB',\n  'tdot': '\\u20DB',\n  'Tscr': '\\uD835\\uDCAF',\n  'Tstrok': '\\u0166',\n  'Uacute': '\\u00DA',\n  'Uarr': '\\u219F',\n  'Uarrocir': '\\u2949',\n  'Ubrcy': '\\u040E',\n  'Ubreve': '\\u016C',\n  'Ucirc': '\\u00DB',\n  'Ucy': '\\u0423',\n  'Udblac': '\\u0170',\n  'Ufr': '\\uD835\\uDD18',\n  'Ugrave': '\\u00D9',\n  'Umacr': '\\u016A',\n  'UnderBar': '\\u005F',\n  'lowbar': '\\u005F',\n  'UnderBrace': '\\u23DF',\n  'UnderBracket': '\\u23B5',\n  'bbrk': '\\u23B5',\n  'UnderParenthesis': '\\u23DD',\n  'Union': '\\u22C3',\n  'bigcup': '\\u22C3',\n  'xcup': '\\u22C3',\n  'UnionPlus': '\\u228E',\n  'uplus': '\\u228E',\n  'Uogon': '\\u0172',\n  'Uopf': '\\uD835\\uDD4C',\n  'UpArrowBar': '\\u2912',\n  'UpArrowDownArrow': '\\u21C5',\n  'udarr': '\\u21C5',\n  'UpDownArrow': '\\u2195',\n  'updownarrow': '\\u2195',\n  'varr': '\\u2195',\n  'UpEquilibrium': '\\u296E',\n  'udhar': '\\u296E',\n  'UpTee': '\\u22A5',\n  'bot': '\\u22A5',\n  'bottom': '\\u22A5',\n  'perp': '\\u22A5',\n  'UpTeeArrow': '\\u21A5',\n  'mapstoup': '\\u21A5',\n  'UpperLeftArrow': '\\u2196',\n  'nwarr': '\\u2196',\n  'nwarrow': '\\u2196',\n  'UpperRightArrow': '\\u2197',\n  'nearr': '\\u2197',\n  'nearrow': '\\u2197',\n  'Upsi': '\\u03D2',\n  'upsih': '\\u03D2',\n  'Upsilon': '\\u03A5',\n  'Uring': '\\u016E',\n  'Uscr': '\\uD835\\uDCB0',\n  'Utilde': '\\u0168',\n  'Uuml': '\\u00DC',\n  'VDash': '\\u22AB',\n  'Vbar': '\\u2AEB',\n  'Vcy': '\\u0412',\n  'Vdash': '\\u22A9',\n  'Vdashl': '\\u2AE6',\n  'Vee': '\\u22C1',\n  'bigvee': '\\u22C1',\n  'xvee': '\\u22C1',\n  'Verbar': '\\u2016',\n  'Vert': '\\u2016',\n  'VerticalBar': '\\u2223',\n  'mid': '\\u2223',\n  'shortmid': '\\u2223',\n  'smid': '\\u2223',\n  'VerticalLine': '\\u007C',\n  'verbar': '\\u007C',\n  'vert': '\\u007C',\n  'VerticalSeparator': '\\u2758',\n  'VerticalTilde': '\\u2240',\n  'wr': '\\u2240',\n  'wreath': '\\u2240',\n  'VeryThinSpace': '\\u200A',\n  'hairsp': '\\u200A',\n  'Vfr': '\\uD835\\uDD19',\n  'Vopf': '\\uD835\\uDD4D',\n  'Vscr': '\\uD835\\uDCB1',\n  'Vvdash': '\\u22AA',\n  'Wcirc': '\\u0174',\n  'Wedge': '\\u22C0',\n  'bigwedge': '\\u22C0',\n  'xwedge': '\\u22C0',\n  'Wfr': '\\uD835\\uDD1A',\n  'Wopf': '\\uD835\\uDD4E',\n  'Wscr': '\\uD835\\uDCB2',\n  'Xfr': '\\uD835\\uDD1B',\n  'Xi': '\\u039E',\n  'Xopf': '\\uD835\\uDD4F',\n  'Xscr': '\\uD835\\uDCB3',\n  'YAcy': '\\u042F',\n  'YIcy': '\\u0407',\n  'YUcy': '\\u042E',\n  'Yacute': '\\u00DD',\n  'Ycirc': '\\u0176',\n  'Ycy': '\\u042B',\n  'Yfr': '\\uD835\\uDD1C',\n  'Yopf': '\\uD835\\uDD50',\n  'Yscr': '\\uD835\\uDCB4',\n  'Yuml': '\\u0178',\n  'ZHcy': '\\u0416',\n  'Zacute': '\\u0179',\n  'Zcaron': '\\u017D',\n  'Zcy': '\\u0417',\n  'Zdot': '\\u017B',\n  'Zeta': '\\u0396',\n  'Zfr': '\\u2128',\n  'zeetrf': '\\u2128',\n  'Zopf': '\\u2124',\n  'integers': '\\u2124',\n  'Zscr': '\\uD835\\uDCB5',\n  'aacute': '\\u00E1',\n  'abreve': '\\u0103',\n  'ac': '\\u223E',\n  'mstpos': '\\u223E',\n  'acE': '\\u223E\\u0333',\n  'acd': '\\u223F',\n  'acirc': '\\u00E2',\n  'acy': '\\u0430',\n  'aelig': '\\u00E6',\n  'afr': '\\uD835\\uDD1E',\n  'agrave': '\\u00E0',\n  'alefsym': '\\u2135',\n  'aleph': '\\u2135',\n  'alpha': '\\u03B1',\n  'amacr': '\\u0101',\n  'amalg': '\\u2A3F',\n  'and': '\\u2227',\n  'wedge': '\\u2227',\n  'andand': '\\u2A55',\n  'andd': '\\u2A5C',\n  'andslope': '\\u2A58',\n  'andv': '\\u2A5A',\n  'ang': '\\u2220',\n  'angle': '\\u2220',\n  'ange': '\\u29A4',\n  'angmsd': '\\u2221',\n  'measuredangle': '\\u2221',\n  'angmsdaa': '\\u29A8',\n  'angmsdab': '\\u29A9',\n  'angmsdac': '\\u29AA',\n  'angmsdad': '\\u29AB',\n  'angmsdae': '\\u29AC',\n  'angmsdaf': '\\u29AD',\n  'angmsdag': '\\u29AE',\n  'angmsdah': '\\u29AF',\n  'angrt': '\\u221F',\n  'angrtvb': '\\u22BE',\n  'angrtvbd': '\\u299D',\n  'angsph': '\\u2222',\n  'angzarr': '\\u237C',\n  'aogon': '\\u0105',\n  'aopf': '\\uD835\\uDD52',\n  'apE': '\\u2A70',\n  'apacir': '\\u2A6F',\n  'ape': '\\u224A',\n  'approxeq': '\\u224A',\n  'apid': '\\u224B',\n  'apos': '\\u0027',\n  'aring': '\\u00E5',\n  'ascr': '\\uD835\\uDCB6',\n  'ast': '\\u002A',\n  'midast': '\\u002A',\n  'atilde': '\\u00E3',\n  'auml': '\\u00E4',\n  'awint': '\\u2A11',\n  'bNot': '\\u2AED',\n  'backcong': '\\u224C',\n  'bcong': '\\u224C',\n  'backepsilon': '\\u03F6',\n  'bepsi': '\\u03F6',\n  'backprime': '\\u2035',\n  'bprime': '\\u2035',\n  'backsim': '\\u223D',\n  'bsim': '\\u223D',\n  'backsimeq': '\\u22CD',\n  'bsime': '\\u22CD',\n  'barvee': '\\u22BD',\n  'barwed': '\\u2305',\n  'barwedge': '\\u2305',\n  'bbrktbrk': '\\u23B6',\n  'bcy': '\\u0431',\n  'bdquo': '\\u201E',\n  'ldquor': '\\u201E',\n  'bemptyv': '\\u29B0',\n  'beta': '\\u03B2',\n  'beth': '\\u2136',\n  'between': '\\u226C',\n  'twixt': '\\u226C',\n  'bfr': '\\uD835\\uDD1F',\n  'bigcirc': '\\u25EF',\n  'xcirc': '\\u25EF',\n  'bigodot': '\\u2A00',\n  'xodot': '\\u2A00',\n  'bigoplus': '\\u2A01',\n  'xoplus': '\\u2A01',\n  'bigotimes': '\\u2A02',\n  'xotime': '\\u2A02',\n  'bigsqcup': '\\u2A06',\n  'xsqcup': '\\u2A06',\n  'bigstar': '\\u2605',\n  'starf': '\\u2605',\n  'bigtriangledown': '\\u25BD',\n  'xdtri': '\\u25BD',\n  'bigtriangleup': '\\u25B3',\n  'xutri': '\\u25B3',\n  'biguplus': '\\u2A04',\n  'xuplus': '\\u2A04',\n  'bkarow': '\\u290D',\n  'rbarr': '\\u290D',\n  'blacklozenge': '\\u29EB',\n  'lozf': '\\u29EB',\n  'blacktriangle': '\\u25B4',\n  'utrif': '\\u25B4',\n  'blacktriangledown': '\\u25BE',\n  'dtrif': '\\u25BE',\n  'blacktriangleleft': '\\u25C2',\n  'ltrif': '\\u25C2',\n  'blacktriangleright': '\\u25B8',\n  'rtrif': '\\u25B8',\n  'blank': '\\u2423',\n  'blk12': '\\u2592',\n  'blk14': '\\u2591',\n  'blk34': '\\u2593',\n  'block': '\\u2588',\n  'bne': '\\u003D\\u20E5',\n  'bnequiv': '\\u2261\\u20E5',\n  'bnot': '\\u2310',\n  'bopf': '\\uD835\\uDD53',\n  'bowtie': '\\u22C8',\n  'boxDL': '\\u2557',\n  'boxDR': '\\u2554',\n  'boxDl': '\\u2556',\n  'boxDr': '\\u2553',\n  'boxH': '\\u2550',\n  'boxHD': '\\u2566',\n  'boxHU': '\\u2569',\n  'boxHd': '\\u2564',\n  'boxHu': '\\u2567',\n  'boxUL': '\\u255D',\n  'boxUR': '\\u255A',\n  'boxUl': '\\u255C',\n  'boxUr': '\\u2559',\n  'boxV': '\\u2551',\n  'boxVH': '\\u256C',\n  'boxVL': '\\u2563',\n  'boxVR': '\\u2560',\n  'boxVh': '\\u256B',\n  'boxVl': '\\u2562',\n  'boxVr': '\\u255F',\n  'boxbox': '\\u29C9',\n  'boxdL': '\\u2555',\n  'boxdR': '\\u2552',\n  'boxdl': '\\u2510',\n  'boxdr': '\\u250C',\n  'boxhD': '\\u2565',\n  'boxhU': '\\u2568',\n  'boxhd': '\\u252C',\n  'boxhu': '\\u2534',\n  'boxminus': '\\u229F',\n  'minusb': '\\u229F',\n  'boxplus': '\\u229E',\n  'plusb': '\\u229E',\n  'boxtimes': '\\u22A0',\n  'timesb': '\\u22A0',\n  'boxuL': '\\u255B',\n  'boxuR': '\\u2558',\n  'boxul': '\\u2518',\n  'boxur': '\\u2514',\n  'boxv': '\\u2502',\n  'boxvH': '\\u256A',\n  'boxvL': '\\u2561',\n  'boxvR': '\\u255E',\n  'boxvh': '\\u253C',\n  'boxvl': '\\u2524',\n  'boxvr': '\\u251C',\n  'brvbar': '\\u00A6',\n  'bscr': '\\uD835\\uDCB7',\n  'bsemi': '\\u204F',\n  'bsol': '\\u005C',\n  'bsolb': '\\u29C5',\n  'bsolhsub': '\\u27C8',\n  'bull': '\\u2022',\n  'bullet': '\\u2022',\n  'bumpE': '\\u2AAE',\n  'cacute': '\\u0107',\n  'cap': '\\u2229',\n  'capand': '\\u2A44',\n  'capbrcup': '\\u2A49',\n  'capcap': '\\u2A4B',\n  'capcup': '\\u2A47',\n  'capdot': '\\u2A40',\n  'caps': '\\u2229\\uFE00',\n  'caret': '\\u2041',\n  'ccaps': '\\u2A4D',\n  'ccaron': '\\u010D',\n  'ccedil': '\\u00E7',\n  'ccirc': '\\u0109',\n  'ccups': '\\u2A4C',\n  'ccupssm': '\\u2A50',\n  'cdot': '\\u010B',\n  'cemptyv': '\\u29B2',\n  'cent': '\\u00A2',\n  'cfr': '\\uD835\\uDD20',\n  'chcy': '\\u0447',\n  'check': '\\u2713',\n  'checkmark': '\\u2713',\n  'chi': '\\u03C7',\n  'cir': '\\u25CB',\n  'cirE': '\\u29C3',\n  'circ': '\\u02C6',\n  'circeq': '\\u2257',\n  'cire': '\\u2257',\n  'circlearrowleft': '\\u21BA',\n  'olarr': '\\u21BA',\n  'circlearrowright': '\\u21BB',\n  'orarr': '\\u21BB',\n  'circledS': '\\u24C8',\n  'oS': '\\u24C8',\n  'circledast': '\\u229B',\n  'oast': '\\u229B',\n  'circledcirc': '\\u229A',\n  'ocir': '\\u229A',\n  'circleddash': '\\u229D',\n  'odash': '\\u229D',\n  'cirfnint': '\\u2A10',\n  'cirmid': '\\u2AEF',\n  'cirscir': '\\u29C2',\n  'clubs': '\\u2663',\n  'clubsuit': '\\u2663',\n  'colon': '\\u003A',\n  'comma': '\\u002C',\n  'commat': '\\u0040',\n  'comp': '\\u2201',\n  'complement': '\\u2201',\n  'congdot': '\\u2A6D',\n  'copf': '\\uD835\\uDD54',\n  'copysr': '\\u2117',\n  'crarr': '\\u21B5',\n  'cross': '\\u2717',\n  'cscr': '\\uD835\\uDCB8',\n  'csub': '\\u2ACF',\n  'csube': '\\u2AD1',\n  'csup': '\\u2AD0',\n  'csupe': '\\u2AD2',\n  'ctdot': '\\u22EF',\n  'cudarrl': '\\u2938',\n  'cudarrr': '\\u2935',\n  'cuepr': '\\u22DE',\n  'curlyeqprec': '\\u22DE',\n  'cuesc': '\\u22DF',\n  'curlyeqsucc': '\\u22DF',\n  'cularr': '\\u21B6',\n  'curvearrowleft': '\\u21B6',\n  'cularrp': '\\u293D',\n  'cup': '\\u222A',\n  'cupbrcap': '\\u2A48',\n  'cupcap': '\\u2A46',\n  'cupcup': '\\u2A4A',\n  'cupdot': '\\u228D',\n  'cupor': '\\u2A45',\n  'cups': '\\u222A\\uFE00',\n  'curarr': '\\u21B7',\n  'curvearrowright': '\\u21B7',\n  'curarrm': '\\u293C',\n  'curlyvee': '\\u22CE',\n  'cuvee': '\\u22CE',\n  'curlywedge': '\\u22CF',\n  'cuwed': '\\u22CF',\n  'curren': '\\u00A4',\n  'cwint': '\\u2231',\n  'cylcty': '\\u232D',\n  'dHar': '\\u2965',\n  'dagger': '\\u2020',\n  'daleth': '\\u2138',\n  'dash': '\\u2010',\n  'hyphen': '\\u2010',\n  'dbkarow': '\\u290F',\n  'rBarr': '\\u290F',\n  'dcaron': '\\u010F',\n  'dcy': '\\u0434',\n  'ddarr': '\\u21CA',\n  'downdownarrows': '\\u21CA',\n  'ddotseq': '\\u2A77',\n  'eDDot': '\\u2A77',\n  'deg': '\\u00B0',\n  'delta': '\\u03B4',\n  'demptyv': '\\u29B1',\n  'dfisht': '\\u297F',\n  'dfr': '\\uD835\\uDD21',\n  'diamondsuit': '\\u2666',\n  'diams': '\\u2666',\n  'digamma': '\\u03DD',\n  'gammad': '\\u03DD',\n  'disin': '\\u22F2',\n  'div': '\\u00F7',\n  'divide': '\\u00F7',\n  'divideontimes': '\\u22C7',\n  'divonx': '\\u22C7',\n  'djcy': '\\u0452',\n  'dlcorn': '\\u231E',\n  'llcorner': '\\u231E',\n  'dlcrop': '\\u230D',\n  'dollar': '\\u0024',\n  'dopf': '\\uD835\\uDD55',\n  'doteqdot': '\\u2251',\n  'eDot': '\\u2251',\n  'dotminus': '\\u2238',\n  'minusd': '\\u2238',\n  'dotplus': '\\u2214',\n  'plusdo': '\\u2214',\n  'dotsquare': '\\u22A1',\n  'sdotb': '\\u22A1',\n  'drcorn': '\\u231F',\n  'lrcorner': '\\u231F',\n  'drcrop': '\\u230C',\n  'dscr': '\\uD835\\uDCB9',\n  'dscy': '\\u0455',\n  'dsol': '\\u29F6',\n  'dstrok': '\\u0111',\n  'dtdot': '\\u22F1',\n  'dtri': '\\u25BF',\n  'triangledown': '\\u25BF',\n  'dwangle': '\\u29A6',\n  'dzcy': '\\u045F',\n  'dzigrarr': '\\u27FF',\n  'eacute': '\\u00E9',\n  'easter': '\\u2A6E',\n  'ecaron': '\\u011B',\n  'ecir': '\\u2256',\n  'eqcirc': '\\u2256',\n  'ecirc': '\\u00EA',\n  'ecolon': '\\u2255',\n  'eqcolon': '\\u2255',\n  'ecy': '\\u044D',\n  'edot': '\\u0117',\n  'efDot': '\\u2252',\n  'fallingdotseq': '\\u2252',\n  'efr': '\\uD835\\uDD22',\n  'eg': '\\u2A9A',\n  'egrave': '\\u00E8',\n  'egs': '\\u2A96',\n  'eqslantgtr': '\\u2A96',\n  'egsdot': '\\u2A98',\n  'el': '\\u2A99',\n  'elinters': '\\u23E7',\n  'ell': '\\u2113',\n  'els': '\\u2A95',\n  'eqslantless': '\\u2A95',\n  'elsdot': '\\u2A97',\n  'emacr': '\\u0113',\n  'empty': '\\u2205',\n  'emptyset': '\\u2205',\n  'emptyv': '\\u2205',\n  'varnothing': '\\u2205',\n  'emsp13': '\\u2004',\n  'emsp14': '\\u2005',\n  'emsp': '\\u2003',\n  'eng': '\\u014B',\n  'ensp': '\\u2002',\n  'eogon': '\\u0119',\n  'eopf': '\\uD835\\uDD56',\n  'epar': '\\u22D5',\n  'eparsl': '\\u29E3',\n  'eplus': '\\u2A71',\n  'epsi': '\\u03B5',\n  'epsilon': '\\u03B5',\n  'epsiv': '\\u03F5',\n  'straightepsilon': '\\u03F5',\n  'varepsilon': '\\u03F5',\n  'equals': '\\u003D',\n  'equest': '\\u225F',\n  'questeq': '\\u225F',\n  'equivDD': '\\u2A78',\n  'eqvparsl': '\\u29E5',\n  'erDot': '\\u2253',\n  'risingdotseq': '\\u2253',\n  'erarr': '\\u2971',\n  'escr': '\\u212F',\n  'eta': '\\u03B7',\n  'eth': '\\u00F0',\n  'euml': '\\u00EB',\n  'euro': '\\u20AC',\n  'excl': '\\u0021',\n  'fcy': '\\u0444',\n  'female': '\\u2640',\n  'ffilig': '\\uFB03',\n  'fflig': '\\uFB00',\n  'ffllig': '\\uFB04',\n  'ffr': '\\uD835\\uDD23',\n  'filig': '\\uFB01',\n  'fjlig': '\\u0066\\u006A',\n  'flat': '\\u266D',\n  'fllig': '\\uFB02',\n  'fltns': '\\u25B1',\n  'fnof': '\\u0192',\n  'fopf': '\\uD835\\uDD57',\n  'fork': '\\u22D4',\n  'pitchfork': '\\u22D4',\n  'forkv': '\\u2AD9',\n  'fpartint': '\\u2A0D',\n  'frac12': '\\u00BD',\n  'half': '\\u00BD',\n  'frac13': '\\u2153',\n  'frac14': '\\u00BC',\n  'frac15': '\\u2155',\n  'frac16': '\\u2159',\n  'frac18': '\\u215B',\n  'frac23': '\\u2154',\n  'frac25': '\\u2156',\n  'frac34': '\\u00BE',\n  'frac35': '\\u2157',\n  'frac38': '\\u215C',\n  'frac45': '\\u2158',\n  'frac56': '\\u215A',\n  'frac58': '\\u215D',\n  'frac78': '\\u215E',\n  'frasl': '\\u2044',\n  'frown': '\\u2322',\n  'sfrown': '\\u2322',\n  'fscr': '\\uD835\\uDCBB',\n  'gEl': '\\u2A8C',\n  'gtreqqless': '\\u2A8C',\n  'gacute': '\\u01F5',\n  'gamma': '\\u03B3',\n  'gap': '\\u2A86',\n  'gtrapprox': '\\u2A86',\n  'gbreve': '\\u011F',\n  'gcirc': '\\u011D',\n  'gcy': '\\u0433',\n  'gdot': '\\u0121',\n  'gescc': '\\u2AA9',\n  'gesdot': '\\u2A80',\n  'gesdoto': '\\u2A82',\n  'gesdotol': '\\u2A84',\n  'gesl': '\\u22DB\\uFE00',\n  'gesles': '\\u2A94',\n  'gfr': '\\uD835\\uDD24',\n  'gimel': '\\u2137',\n  'gjcy': '\\u0453',\n  'glE': '\\u2A92',\n  'gla': '\\u2AA5',\n  'glj': '\\u2AA4',\n  'gnE': '\\u2269',\n  'gneqq': '\\u2269',\n  'gnap': '\\u2A8A',\n  'gnapprox': '\\u2A8A',\n  'gne': '\\u2A88',\n  'gneq': '\\u2A88',\n  'gnsim': '\\u22E7',\n  'gopf': '\\uD835\\uDD58',\n  'gscr': '\\u210A',\n  'gsime': '\\u2A8E',\n  'gsiml': '\\u2A90',\n  'gtcc': '\\u2AA7',\n  'gtcir': '\\u2A7A',\n  'gtdot': '\\u22D7',\n  'gtrdot': '\\u22D7',\n  'gtlPar': '\\u2995',\n  'gtquest': '\\u2A7C',\n  'gtrarr': '\\u2978',\n  'gvertneqq': '\\u2269\\uFE00',\n  'gvnE': '\\u2269\\uFE00',\n  'hardcy': '\\u044A',\n  'harrcir': '\\u2948',\n  'harrw': '\\u21AD',\n  'leftrightsquigarrow': '\\u21AD',\n  'hbar': '\\u210F',\n  'hslash': '\\u210F',\n  'planck': '\\u210F',\n  'plankv': '\\u210F',\n  'hcirc': '\\u0125',\n  'hearts': '\\u2665',\n  'heartsuit': '\\u2665',\n  'hellip': '\\u2026',\n  'mldr': '\\u2026',\n  'hercon': '\\u22B9',\n  'hfr': '\\uD835\\uDD25',\n  'hksearow': '\\u2925',\n  'searhk': '\\u2925',\n  'hkswarow': '\\u2926',\n  'swarhk': '\\u2926',\n  'hoarr': '\\u21FF',\n  'homtht': '\\u223B',\n  'hookleftarrow': '\\u21A9',\n  'larrhk': '\\u21A9',\n  'hookrightarrow': '\\u21AA',\n  'rarrhk': '\\u21AA',\n  'hopf': '\\uD835\\uDD59',\n  'horbar': '\\u2015',\n  'hscr': '\\uD835\\uDCBD',\n  'hstrok': '\\u0127',\n  'hybull': '\\u2043',\n  'iacute': '\\u00ED',\n  'icirc': '\\u00EE',\n  'icy': '\\u0438',\n  'iecy': '\\u0435',\n  'iexcl': '\\u00A1',\n  'ifr': '\\uD835\\uDD26',\n  'igrave': '\\u00EC',\n  'iiiint': '\\u2A0C',\n  'qint': '\\u2A0C',\n  'iiint': '\\u222D',\n  'tint': '\\u222D',\n  'iinfin': '\\u29DC',\n  'iiota': '\\u2129',\n  'ijlig': '\\u0133',\n  'imacr': '\\u012B',\n  'imath': '\\u0131',\n  'inodot': '\\u0131',\n  'imof': '\\u22B7',\n  'imped': '\\u01B5',\n  'incare': '\\u2105',\n  'infin': '\\u221E',\n  'infintie': '\\u29DD',\n  'intcal': '\\u22BA',\n  'intercal': '\\u22BA',\n  'intlarhk': '\\u2A17',\n  'intprod': '\\u2A3C',\n  'iprod': '\\u2A3C',\n  'iocy': '\\u0451',\n  'iogon': '\\u012F',\n  'iopf': '\\uD835\\uDD5A',\n  'iota': '\\u03B9',\n  'iquest': '\\u00BF',\n  'iscr': '\\uD835\\uDCBE',\n  'isinE': '\\u22F9',\n  'isindot': '\\u22F5',\n  'isins': '\\u22F4',\n  'isinsv': '\\u22F3',\n  'itilde': '\\u0129',\n  'iukcy': '\\u0456',\n  'iuml': '\\u00EF',\n  'jcirc': '\\u0135',\n  'jcy': '\\u0439',\n  'jfr': '\\uD835\\uDD27',\n  'jmath': '\\u0237',\n  'jopf': '\\uD835\\uDD5B',\n  'jscr': '\\uD835\\uDCBF',\n  'jsercy': '\\u0458',\n  'jukcy': '\\u0454',\n  'kappa': '\\u03BA',\n  'kappav': '\\u03F0',\n  'varkappa': '\\u03F0',\n  'kcedil': '\\u0137',\n  'kcy': '\\u043A',\n  'kfr': '\\uD835\\uDD28',\n  'kgreen': '\\u0138',\n  'khcy': '\\u0445',\n  'kjcy': '\\u045C',\n  'kopf': '\\uD835\\uDD5C',\n  'kscr': '\\uD835\\uDCC0',\n  'lAtail': '\\u291B',\n  'lBarr': '\\u290E',\n  'lEg': '\\u2A8B',\n  'lesseqqgtr': '\\u2A8B',\n  'lHar': '\\u2962',\n  'lacute': '\\u013A',\n  'laemptyv': '\\u29B4',\n  'lambda': '\\u03BB',\n  'langd': '\\u2991',\n  'lap': '\\u2A85',\n  'lessapprox': '\\u2A85',\n  'laquo': '\\u00AB',\n  'larrbfs': '\\u291F',\n  'larrfs': '\\u291D',\n  'larrlp': '\\u21AB',\n  'looparrowleft': '\\u21AB',\n  'larrpl': '\\u2939',\n  'larrsim': '\\u2973',\n  'larrtl': '\\u21A2',\n  'leftarrowtail': '\\u21A2',\n  'lat': '\\u2AAB',\n  'latail': '\\u2919',\n  'late': '\\u2AAD',\n  'lates': '\\u2AAD\\uFE00',\n  'lbarr': '\\u290C',\n  'lbbrk': '\\u2772',\n  'lbrace': '\\u007B',\n  'lcub': '\\u007B',\n  'lbrack': '\\u005B',\n  'lsqb': '\\u005B',\n  'lbrke': '\\u298B',\n  'lbrksld': '\\u298F',\n  'lbrkslu': '\\u298D',\n  'lcaron': '\\u013E',\n  'lcedil': '\\u013C',\n  'lcy': '\\u043B',\n  'ldca': '\\u2936',\n  'ldrdhar': '\\u2967',\n  'ldrushar': '\\u294B',\n  'ldsh': '\\u21B2',\n  'le': '\\u2264',\n  'leq': '\\u2264',\n  'leftleftarrows': '\\u21C7',\n  'llarr': '\\u21C7',\n  'leftthreetimes': '\\u22CB',\n  'lthree': '\\u22CB',\n  'lescc': '\\u2AA8',\n  'lesdot': '\\u2A7F',\n  'lesdoto': '\\u2A81',\n  'lesdotor': '\\u2A83',\n  'lesg': '\\u22DA\\uFE00',\n  'lesges': '\\u2A93',\n  'lessdot': '\\u22D6',\n  'ltdot': '\\u22D6',\n  'lfisht': '\\u297C',\n  'lfr': '\\uD835\\uDD29',\n  'lgE': '\\u2A91',\n  'lharul': '\\u296A',\n  'lhblk': '\\u2584',\n  'ljcy': '\\u0459',\n  'llhard': '\\u296B',\n  'lltri': '\\u25FA',\n  'lmidot': '\\u0140',\n  'lmoust': '\\u23B0',\n  'lmoustache': '\\u23B0',\n  'lnE': '\\u2268',\n  'lneqq': '\\u2268',\n  'lnap': '\\u2A89',\n  'lnapprox': '\\u2A89',\n  'lne': '\\u2A87',\n  'lneq': '\\u2A87',\n  'lnsim': '\\u22E6',\n  'loang': '\\u27EC',\n  'loarr': '\\u21FD',\n  'longmapsto': '\\u27FC',\n  'xmap': '\\u27FC',\n  'looparrowright': '\\u21AC',\n  'rarrlp': '\\u21AC',\n  'lopar': '\\u2985',\n  'lopf': '\\uD835\\uDD5D',\n  'loplus': '\\u2A2D',\n  'lotimes': '\\u2A34',\n  'lowast': '\\u2217',\n  'loz': '\\u25CA',\n  'lozenge': '\\u25CA',\n  'lpar': '\\u0028',\n  'lparlt': '\\u2993',\n  'lrhard': '\\u296D',\n  'lrm': '\\u200E',\n  'lrtri': '\\u22BF',\n  'lsaquo': '\\u2039',\n  'lscr': '\\uD835\\uDCC1',\n  'lsime': '\\u2A8D',\n  'lsimg': '\\u2A8F',\n  'lsquor': '\\u201A',\n  'sbquo': '\\u201A',\n  'lstrok': '\\u0142',\n  'ltcc': '\\u2AA6',\n  'ltcir': '\\u2A79',\n  'ltimes': '\\u22C9',\n  'ltlarr': '\\u2976',\n  'ltquest': '\\u2A7B',\n  'ltrPar': '\\u2996',\n  'ltri': '\\u25C3',\n  'triangleleft': '\\u25C3',\n  'lurdshar': '\\u294A',\n  'luruhar': '\\u2966',\n  'lvertneqq': '\\u2268\\uFE00',\n  'lvnE': '\\u2268\\uFE00',\n  'mDDot': '\\u223A',\n  'macr': '\\u00AF',\n  'strns': '\\u00AF',\n  'male': '\\u2642',\n  'malt': '\\u2720',\n  'maltese': '\\u2720',\n  'marker': '\\u25AE',\n  'mcomma': '\\u2A29',\n  'mcy': '\\u043C',\n  'mdash': '\\u2014',\n  'mfr': '\\uD835\\uDD2A',\n  'mho': '\\u2127',\n  'micro': '\\u00B5',\n  'midcir': '\\u2AF0',\n  'minus': '\\u2212',\n  'minusdu': '\\u2A2A',\n  'mlcp': '\\u2ADB',\n  'models': '\\u22A7',\n  'mopf': '\\uD835\\uDD5E',\n  'mscr': '\\uD835\\uDCC2',\n  'mu': '\\u03BC',\n  'multimap': '\\u22B8',\n  'mumap': '\\u22B8',\n  'nGg': '\\u22D9\\u0338',\n  'nGt': '\\u226B\\u20D2',\n  'nLeftarrow': '\\u21CD',\n  'nlArr': '\\u21CD',\n  'nLeftrightarrow': '\\u21CE',\n  'nhArr': '\\u21CE',\n  'nLl': '\\u22D8\\u0338',\n  'nLt': '\\u226A\\u20D2',\n  'nRightarrow': '\\u21CF',\n  'nrArr': '\\u21CF',\n  'nVDash': '\\u22AF',\n  'nVdash': '\\u22AE',\n  'nacute': '\\u0144',\n  'nang': '\\u2220\\u20D2',\n  'napE': '\\u2A70\\u0338',\n  'napid': '\\u224B\\u0338',\n  'napos': '\\u0149',\n  'natur': '\\u266E',\n  'natural': '\\u266E',\n  'ncap': '\\u2A43',\n  'ncaron': '\\u0148',\n  'ncedil': '\\u0146',\n  'ncongdot': '\\u2A6D\\u0338',\n  'ncup': '\\u2A42',\n  'ncy': '\\u043D',\n  'ndash': '\\u2013',\n  'neArr': '\\u21D7',\n  'nearhk': '\\u2924',\n  'nedot': '\\u2250\\u0338',\n  'nesear': '\\u2928',\n  'toea': '\\u2928',\n  'nfr': '\\uD835\\uDD2B',\n  'nharr': '\\u21AE',\n  'nleftrightarrow': '\\u21AE',\n  'nhpar': '\\u2AF2',\n  'nis': '\\u22FC',\n  'nisd': '\\u22FA',\n  'njcy': '\\u045A',\n  'nlE': '\\u2266\\u0338',\n  'nleqq': '\\u2266\\u0338',\n  'nlarr': '\\u219A',\n  'nleftarrow': '\\u219A',\n  'nldr': '\\u2025',\n  'nopf': '\\uD835\\uDD5F',\n  'not': '\\u00AC',\n  'notinE': '\\u22F9\\u0338',\n  'notindot': '\\u22F5\\u0338',\n  'notinvb': '\\u22F7',\n  'notinvc': '\\u22F6',\n  'notnivb': '\\u22FE',\n  'notnivc': '\\u22FD',\n  'nparsl': '\\u2AFD\\u20E5',\n  'npart': '\\u2202\\u0338',\n  'npolint': '\\u2A14',\n  'nrarr': '\\u219B',\n  'nrightarrow': '\\u219B',\n  'nrarrc': '\\u2933\\u0338',\n  'nrarrw': '\\u219D\\u0338',\n  'nscr': '\\uD835\\uDCC3',\n  'nsub': '\\u2284',\n  'nsubE': '\\u2AC5\\u0338',\n  'nsubseteqq': '\\u2AC5\\u0338',\n  'nsup': '\\u2285',\n  'nsupE': '\\u2AC6\\u0338',\n  'nsupseteqq': '\\u2AC6\\u0338',\n  'ntilde': '\\u00F1',\n  'nu': '\\u03BD',\n  'num': '\\u0023',\n  'numero': '\\u2116',\n  'numsp': '\\u2007',\n  'nvDash': '\\u22AD',\n  'nvHarr': '\\u2904',\n  'nvap': '\\u224D\\u20D2',\n  'nvdash': '\\u22AC',\n  'nvge': '\\u2265\\u20D2',\n  'nvgt': '\\u003E\\u20D2',\n  'nvinfin': '\\u29DE',\n  'nvlArr': '\\u2902',\n  'nvle': '\\u2264\\u20D2',\n  'nvlt': '\\u003C\\u20D2',\n  'nvltrie': '\\u22B4\\u20D2',\n  'nvrArr': '\\u2903',\n  'nvrtrie': '\\u22B5\\u20D2',\n  'nvsim': '\\u223C\\u20D2',\n  'nwArr': '\\u21D6',\n  'nwarhk': '\\u2923',\n  'nwnear': '\\u2927',\n  'oacute': '\\u00F3',\n  'ocirc': '\\u00F4',\n  'ocy': '\\u043E',\n  'odblac': '\\u0151',\n  'odiv': '\\u2A38',\n  'odsold': '\\u29BC',\n  'oelig': '\\u0153',\n  'ofcir': '\\u29BF',\n  'ofr': '\\uD835\\uDD2C',\n  'ogon': '\\u02DB',\n  'ograve': '\\u00F2',\n  'ogt': '\\u29C1',\n  'ohbar': '\\u29B5',\n  'olcir': '\\u29BE',\n  'olcross': '\\u29BB',\n  'olt': '\\u29C0',\n  'omacr': '\\u014D',\n  'omega': '\\u03C9',\n  'omicron': '\\u03BF',\n  'omid': '\\u29B6',\n  'oopf': '\\uD835\\uDD60',\n  'opar': '\\u29B7',\n  'operp': '\\u29B9',\n  'or': '\\u2228',\n  'vee': '\\u2228',\n  'ord': '\\u2A5D',\n  'order': '\\u2134',\n  'orderof': '\\u2134',\n  'oscr': '\\u2134',\n  'ordf': '\\u00AA',\n  'ordm': '\\u00BA',\n  'origof': '\\u22B6',\n  'oror': '\\u2A56',\n  'orslope': '\\u2A57',\n  'orv': '\\u2A5B',\n  'oslash': '\\u00F8',\n  'osol': '\\u2298',\n  'otilde': '\\u00F5',\n  'otimesas': '\\u2A36',\n  'ouml': '\\u00F6',\n  'ovbar': '\\u233D',\n  'para': '\\u00B6',\n  'parsim': '\\u2AF3',\n  'parsl': '\\u2AFD',\n  'pcy': '\\u043F',\n  'percnt': '\\u0025',\n  'period': '\\u002E',\n  'permil': '\\u2030',\n  'pertenk': '\\u2031',\n  'pfr': '\\uD835\\uDD2D',\n  'phi': '\\u03C6',\n  'phiv': '\\u03D5',\n  'straightphi': '\\u03D5',\n  'varphi': '\\u03D5',\n  'phone': '\\u260E',\n  'pi': '\\u03C0',\n  'piv': '\\u03D6',\n  'varpi': '\\u03D6',\n  'planckh': '\\u210E',\n  'plus': '\\u002B',\n  'plusacir': '\\u2A23',\n  'pluscir': '\\u2A22',\n  'plusdu': '\\u2A25',\n  'pluse': '\\u2A72',\n  'plussim': '\\u2A26',\n  'plustwo': '\\u2A27',\n  'pointint': '\\u2A15',\n  'popf': '\\uD835\\uDD61',\n  'pound': '\\u00A3',\n  'prE': '\\u2AB3',\n  'prap': '\\u2AB7',\n  'precapprox': '\\u2AB7',\n  'precnapprox': '\\u2AB9',\n  'prnap': '\\u2AB9',\n  'precneqq': '\\u2AB5',\n  'prnE': '\\u2AB5',\n  'precnsim': '\\u22E8',\n  'prnsim': '\\u22E8',\n  'prime': '\\u2032',\n  'profalar': '\\u232E',\n  'profline': '\\u2312',\n  'profsurf': '\\u2313',\n  'prurel': '\\u22B0',\n  'pscr': '\\uD835\\uDCC5',\n  'psi': '\\u03C8',\n  'puncsp': '\\u2008',\n  'qfr': '\\uD835\\uDD2E',\n  'qopf': '\\uD835\\uDD62',\n  'qprime': '\\u2057',\n  'qscr': '\\uD835\\uDCC6',\n  'quatint': '\\u2A16',\n  'quest': '\\u003F',\n  'rAtail': '\\u291C',\n  'rHar': '\\u2964',\n  'race': '\\u223D\\u0331',\n  'racute': '\\u0155',\n  'raemptyv': '\\u29B3',\n  'rangd': '\\u2992',\n  'range': '\\u29A5',\n  'raquo': '\\u00BB',\n  'rarrap': '\\u2975',\n  'rarrbfs': '\\u2920',\n  'rarrc': '\\u2933',\n  'rarrfs': '\\u291E',\n  'rarrpl': '\\u2945',\n  'rarrsim': '\\u2974',\n  'rarrtl': '\\u21A3',\n  'rightarrowtail': '\\u21A3',\n  'rarrw': '\\u219D',\n  'rightsquigarrow': '\\u219D',\n  'ratail': '\\u291A',\n  'ratio': '\\u2236',\n  'rbbrk': '\\u2773',\n  'rbrace': '\\u007D',\n  'rcub': '\\u007D',\n  'rbrack': '\\u005D',\n  'rsqb': '\\u005D',\n  'rbrke': '\\u298C',\n  'rbrksld': '\\u298E',\n  'rbrkslu': '\\u2990',\n  'rcaron': '\\u0159',\n  'rcedil': '\\u0157',\n  'rcy': '\\u0440',\n  'rdca': '\\u2937',\n  'rdldhar': '\\u2969',\n  'rdsh': '\\u21B3',\n  'rect': '\\u25AD',\n  'rfisht': '\\u297D',\n  'rfr': '\\uD835\\uDD2F',\n  'rharul': '\\u296C',\n  'rho': '\\u03C1',\n  'rhov': '\\u03F1',\n  'varrho': '\\u03F1',\n  'rightrightarrows': '\\u21C9',\n  'rrarr': '\\u21C9',\n  'rightthreetimes': '\\u22CC',\n  'rthree': '\\u22CC',\n  'ring': '\\u02DA',\n  'rlm': '\\u200F',\n  'rmoust': '\\u23B1',\n  'rmoustache': '\\u23B1',\n  'rnmid': '\\u2AEE',\n  'roang': '\\u27ED',\n  'roarr': '\\u21FE',\n  'ropar': '\\u2986',\n  'ropf': '\\uD835\\uDD63',\n  'roplus': '\\u2A2E',\n  'rotimes': '\\u2A35',\n  'rpar': '\\u0029',\n  'rpargt': '\\u2994',\n  'rppolint': '\\u2A12',\n  'rsaquo': '\\u203A',\n  'rscr': '\\uD835\\uDCC7',\n  'rtimes': '\\u22CA',\n  'rtri': '\\u25B9',\n  'triangleright': '\\u25B9',\n  'rtriltri': '\\u29CE',\n  'ruluhar': '\\u2968',\n  'rx': '\\u211E',\n  'sacute': '\\u015B',\n  'scE': '\\u2AB4',\n  'scap': '\\u2AB8',\n  'succapprox': '\\u2AB8',\n  'scaron': '\\u0161',\n  'scedil': '\\u015F',\n  'scirc': '\\u015D',\n  'scnE': '\\u2AB6',\n  'succneqq': '\\u2AB6',\n  'scnap': '\\u2ABA',\n  'succnapprox': '\\u2ABA',\n  'scnsim': '\\u22E9',\n  'succnsim': '\\u22E9',\n  'scpolint': '\\u2A13',\n  'scy': '\\u0441',\n  'sdot': '\\u22C5',\n  'sdote': '\\u2A66',\n  'seArr': '\\u21D8',\n  'sect': '\\u00A7',\n  'semi': '\\u003B',\n  'seswar': '\\u2929',\n  'tosa': '\\u2929',\n  'sext': '\\u2736',\n  'sfr': '\\uD835\\uDD30',\n  'sharp': '\\u266F',\n  'shchcy': '\\u0449',\n  'shcy': '\\u0448',\n  'shy': '\\u00AD',\n  'sigma': '\\u03C3',\n  'sigmaf': '\\u03C2',\n  'sigmav': '\\u03C2',\n  'varsigma': '\\u03C2',\n  'simdot': '\\u2A6A',\n  'simg': '\\u2A9E',\n  'simgE': '\\u2AA0',\n  'siml': '\\u2A9D',\n  'simlE': '\\u2A9F',\n  'simne': '\\u2246',\n  'simplus': '\\u2A24',\n  'simrarr': '\\u2972',\n  'smashp': '\\u2A33',\n  'smeparsl': '\\u29E4',\n  'smile': '\\u2323',\n  'ssmile': '\\u2323',\n  'smt': '\\u2AAA',\n  'smte': '\\u2AAC',\n  'smtes': '\\u2AAC\\uFE00',\n  'softcy': '\\u044C',\n  'sol': '\\u002F',\n  'solb': '\\u29C4',\n  'solbar': '\\u233F',\n  'sopf': '\\uD835\\uDD64',\n  'spades': '\\u2660',\n  'spadesuit': '\\u2660',\n  'sqcaps': '\\u2293\\uFE00',\n  'sqcups': '\\u2294\\uFE00',\n  'sscr': '\\uD835\\uDCC8',\n  'star': '\\u2606',\n  'sub': '\\u2282',\n  'subset': '\\u2282',\n  'subE': '\\u2AC5',\n  'subseteqq': '\\u2AC5',\n  'subdot': '\\u2ABD',\n  'subedot': '\\u2AC3',\n  'submult': '\\u2AC1',\n  'subnE': '\\u2ACB',\n  'subsetneqq': '\\u2ACB',\n  'subne': '\\u228A',\n  'subsetneq': '\\u228A',\n  'subplus': '\\u2ABF',\n  'subrarr': '\\u2979',\n  'subsim': '\\u2AC7',\n  'subsub': '\\u2AD5',\n  'subsup': '\\u2AD3',\n  'sung': '\\u266A',\n  'sup1': '\\u00B9',\n  'sup2': '\\u00B2',\n  'sup3': '\\u00B3',\n  'supE': '\\u2AC6',\n  'supseteqq': '\\u2AC6',\n  'supdot': '\\u2ABE',\n  'supdsub': '\\u2AD8',\n  'supedot': '\\u2AC4',\n  'suphsol': '\\u27C9',\n  'suphsub': '\\u2AD7',\n  'suplarr': '\\u297B',\n  'supmult': '\\u2AC2',\n  'supnE': '\\u2ACC',\n  'supsetneqq': '\\u2ACC',\n  'supne': '\\u228B',\n  'supsetneq': '\\u228B',\n  'supplus': '\\u2AC0',\n  'supsim': '\\u2AC8',\n  'supsub': '\\u2AD4',\n  'supsup': '\\u2AD6',\n  'swArr': '\\u21D9',\n  'swnwar': '\\u292A',\n  'szlig': '\\u00DF',\n  'target': '\\u2316',\n  'tau': '\\u03C4',\n  'tcaron': '\\u0165',\n  'tcedil': '\\u0163',\n  'tcy': '\\u0442',\n  'telrec': '\\u2315',\n  'tfr': '\\uD835\\uDD31',\n  'theta': '\\u03B8',\n  'thetasym': '\\u03D1',\n  'thetav': '\\u03D1',\n  'vartheta': '\\u03D1',\n  'thorn': '\\u00FE',\n  'times': '\\u00D7',\n  'timesbar': '\\u2A31',\n  'timesd': '\\u2A30',\n  'topbot': '\\u2336',\n  'topcir': '\\u2AF1',\n  'topf': '\\uD835\\uDD65',\n  'topfork': '\\u2ADA',\n  'tprime': '\\u2034',\n  'triangle': '\\u25B5',\n  'utri': '\\u25B5',\n  'triangleq': '\\u225C',\n  'trie': '\\u225C',\n  'tridot': '\\u25EC',\n  'triminus': '\\u2A3A',\n  'triplus': '\\u2A39',\n  'trisb': '\\u29CD',\n  'tritime': '\\u2A3B',\n  'trpezium': '\\u23E2',\n  'tscr': '\\uD835\\uDCC9',\n  'tscy': '\\u0446',\n  'tshcy': '\\u045B',\n  'tstrok': '\\u0167',\n  'uHar': '\\u2963',\n  'uacute': '\\u00FA',\n  'ubrcy': '\\u045E',\n  'ubreve': '\\u016D',\n  'ucirc': '\\u00FB',\n  'ucy': '\\u0443',\n  'udblac': '\\u0171',\n  'ufisht': '\\u297E',\n  'ufr': '\\uD835\\uDD32',\n  'ugrave': '\\u00F9',\n  'uhblk': '\\u2580',\n  'ulcorn': '\\u231C',\n  'ulcorner': '\\u231C',\n  'ulcrop': '\\u230F',\n  'ultri': '\\u25F8',\n  'umacr': '\\u016B',\n  'uogon': '\\u0173',\n  'uopf': '\\uD835\\uDD66',\n  'upsi': '\\u03C5',\n  'upsilon': '\\u03C5',\n  'upuparrows': '\\u21C8',\n  'uuarr': '\\u21C8',\n  'urcorn': '\\u231D',\n  'urcorner': '\\u231D',\n  'urcrop': '\\u230E',\n  'uring': '\\u016F',\n  'urtri': '\\u25F9',\n  'uscr': '\\uD835\\uDCCA',\n  'utdot': '\\u22F0',\n  'utilde': '\\u0169',\n  'uuml': '\\u00FC',\n  'uwangle': '\\u29A7',\n  'vBar': '\\u2AE8',\n  'vBarv': '\\u2AE9',\n  'vangrt': '\\u299C',\n  'varsubsetneq': '\\u228A\\uFE00',\n  'vsubne': '\\u228A\\uFE00',\n  'varsubsetneqq': '\\u2ACB\\uFE00',\n  'vsubnE': '\\u2ACB\\uFE00',\n  'varsupsetneq': '\\u228B\\uFE00',\n  'vsupne': '\\u228B\\uFE00',\n  'varsupsetneqq': '\\u2ACC\\uFE00',\n  'vsupnE': '\\u2ACC\\uFE00',\n  'vcy': '\\u0432',\n  'veebar': '\\u22BB',\n  'veeeq': '\\u225A',\n  'vellip': '\\u22EE',\n  'vfr': '\\uD835\\uDD33',\n  'vopf': '\\uD835\\uDD67',\n  'vscr': '\\uD835\\uDCCB',\n  'vzigzag': '\\u299A',\n  'wcirc': '\\u0175',\n  'wedbar': '\\u2A5F',\n  'wedgeq': '\\u2259',\n  'weierp': '\\u2118',\n  'wp': '\\u2118',\n  'wfr': '\\uD835\\uDD34',\n  'wopf': '\\uD835\\uDD68',\n  'wscr': '\\uD835\\uDCCC',\n  'xfr': '\\uD835\\uDD35',\n  'xi': '\\u03BE',\n  'xnis': '\\u22FB',\n  'xopf': '\\uD835\\uDD69',\n  'xscr': '\\uD835\\uDCCD',\n  'yacute': '\\u00FD',\n  'yacy': '\\u044F',\n  'ycirc': '\\u0177',\n  'ycy': '\\u044B',\n  'yen': '\\u00A5',\n  'yfr': '\\uD835\\uDD36',\n  'yicy': '\\u0457',\n  'yopf': '\\uD835\\uDD6A',\n  'yscr': '\\uD835\\uDCCE',\n  'yucy': '\\u044E',\n  'yuml': '\\u00FF',\n  'zacute': '\\u017A',\n  'zcaron': '\\u017E',\n  'zcy': '\\u0437',\n  'zdot': '\\u017C',\n  'zeta': '\\u03B6',\n  'zfr': '\\uD835\\uDD37',\n  'zhcy': '\\u0436',\n  'zigrarr': '\\u21DD',\n  'zopf': '\\uD835\\uDD6B',\n  'zscr': '\\uD835\\uDCCF',\n  'zwj': '\\u200D',\n  'zwnj': '\\u200C'\n};\nconst NGSP_UNICODE = '\\uE500';\nNAMED_ENTITIES['ngsp'] = NGSP_UNICODE;\n\nclass TokenizeResult {\n  tokens;\n  errors;\n  nonNormalizedIcuExpressions;\n  constructor(tokens, errors, nonNormalizedIcuExpressions) {\n    this.tokens = tokens;\n    this.errors = errors;\n    this.nonNormalizedIcuExpressions = nonNormalizedIcuExpressions;\n  }\n}\nfunction tokenize(source, url, getTagDefinition, options = {}) {\n  const tokenizer = new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options);\n  tokenizer.tokenize();\n  return new TokenizeResult(mergeTextTokens(tokenizer.tokens), tokenizer.errors, tokenizer.nonNormalizedIcuExpressions);\n}\nconst _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\nfunction _unexpectedCharacterErrorMsg(charCode) {\n  const char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);\n  return `Unexpected character \"${char}\"`;\n}\nfunction _unknownEntityErrorMsg(entitySrc) {\n  return `Unknown entity \"${entitySrc}\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax`;\n}\nfunction _unparsableEntityErrorMsg(type, entityStr) {\n  return `Unable to parse entity \"${entityStr}\" - ${type} character reference entities must end with \";\"`;\n}\nvar CharacterReferenceType;\n(function (CharacterReferenceType) {\n  CharacterReferenceType[\"HEX\"] = \"hexadecimal\";\n  CharacterReferenceType[\"DEC\"] = \"decimal\";\n})(CharacterReferenceType || (CharacterReferenceType = {}));\nconst SUPPORTED_BLOCKS = ['@if', '@else', '@for', '@switch', '@case', '@default', '@empty', '@defer', '@placeholder', '@loading', '@error'];\nconst INTERPOLATION = {\n  start: '{{',\n  end: '}}'\n};\nclass _Tokenizer {\n  _getTagDefinition;\n  _cursor;\n  _tokenizeIcu;\n  _leadingTriviaCodePoints;\n  _currentTokenStart = null;\n  _currentTokenType = null;\n  _expansionCaseStack = [];\n  _openDirectiveCount = 0;\n  _inInterpolation = false;\n  _preserveLineEndings;\n  _i18nNormalizeLineEndingsInICUs;\n  _tokenizeBlocks;\n  _tokenizeLet;\n  _selectorlessEnabled;\n  tokens = [];\n  errors = [];\n  nonNormalizedIcuExpressions = [];\n  constructor(_file, _getTagDefinition, options) {\n    this._getTagDefinition = _getTagDefinition;\n    this._tokenizeIcu = options.tokenizeExpansionForms || false;\n    this._leadingTriviaCodePoints = options.leadingTriviaChars && options.leadingTriviaChars.map(c => c.codePointAt(0) || 0);\n    const range = options.range || {\n      endPos: _file.content.length,\n      startPos: 0,\n      startLine: 0,\n      startCol: 0\n    };\n    this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) : new PlainCharacterCursor(_file, range);\n    this._preserveLineEndings = options.preserveLineEndings || false;\n    this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;\n    this._tokenizeBlocks = options.tokenizeBlocks ?? true;\n    this._tokenizeLet = options.tokenizeLet ?? true;\n    this._selectorlessEnabled = options.selectorlessEnabled ?? false;\n    try {\n      this._cursor.init();\n    } catch (e) {\n      this.handleError(e);\n    }\n  }\n  _processCarriageReturns(content) {\n    if (this._preserveLineEndings) {\n      return content;\n    }\n    return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n  }\n  tokenize() {\n    while (this._cursor.peek() !== $EOF) {\n      const start = this._cursor.clone();\n      try {\n        if (this._attemptCharCode($LT)) {\n          if (this._attemptCharCode($BANG)) {\n            if (this._attemptCharCode($LBRACKET)) {\n              this._consumeCdata(start);\n            } else if (this._attemptCharCode($MINUS)) {\n              this._consumeComment(start);\n            } else {\n              this._consumeDocType(start);\n            }\n          } else if (this._attemptCharCode($SLASH)) {\n            this._consumeTagClose(start);\n          } else {\n            this._consumeTagOpen(start);\n          }\n        } else if (this._tokenizeLet && this._cursor.peek() === $AT && !this._inInterpolation && this._isLetStart()) {\n          this._consumeLetDeclaration(start);\n        } else if (this._tokenizeBlocks && this._isBlockStart()) {\n          this._consumeBlockStart(start);\n        } else if (this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansionCase() && !this._isInExpansionForm() && this._attemptCharCode($RBRACE)) {\n          this._consumeBlockEnd(start);\n        } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n          this._consumeWithInterpolation(5, 8, () => this._isTextEnd(), () => this._isTagStart());\n        }\n      } catch (e) {\n        this.handleError(e);\n      }\n    }\n    this._beginToken(41);\n    this._endToken([]);\n  }\n  _getBlockName() {\n    let spacesInNameAllowed = false;\n    const nameCursor = this._cursor.clone();\n    this._attemptCharCodeUntilFn(code => {\n      if (isWhitespace(code)) {\n        return !spacesInNameAllowed;\n      }\n      if (isBlockNameChar(code)) {\n        spacesInNameAllowed = true;\n        return false;\n      }\n      return true;\n    });\n    return this._cursor.getChars(nameCursor).trim();\n  }\n  _consumeBlockStart(start) {\n    this._requireCharCode($AT);\n    this._beginToken(24, start);\n    const startToken = this._endToken([this._getBlockName()]);\n    if (this._cursor.peek() === $LPAREN) {\n      this._cursor.advance();\n      this._consumeBlockParameters();\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      if (this._attemptCharCode($RPAREN)) {\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      } else {\n        startToken.type = 28;\n        return;\n      }\n    }\n    if (this._attemptCharCode($LBRACE)) {\n      this._beginToken(25);\n      this._endToken([]);\n    } else {\n      startToken.type = 28;\n    }\n  }\n  _consumeBlockEnd(start) {\n    this._beginToken(26, start);\n    this._endToken([]);\n  }\n  _consumeBlockParameters() {\n    this._attemptCharCodeUntilFn(isBlockParameterChar);\n    while (this._cursor.peek() !== $RPAREN && this._cursor.peek() !== $EOF) {\n      this._beginToken(27);\n      const start = this._cursor.clone();\n      let inQuote = null;\n      let openParens = 0;\n      while (this._cursor.peek() !== $SEMICOLON && this._cursor.peek() !== $EOF || inQuote !== null) {\n        const char = this._cursor.peek();\n        if (char === $BACKSLASH) {\n          this._cursor.advance();\n        } else if (char === inQuote) {\n          inQuote = null;\n        } else if (inQuote === null && isQuote(char)) {\n          inQuote = char;\n        } else if (char === $LPAREN && inQuote === null) {\n          openParens++;\n        } else if (char === $RPAREN && inQuote === null) {\n          if (openParens === 0) {\n            break;\n          } else if (openParens > 0) {\n            openParens--;\n          }\n        }\n        this._cursor.advance();\n      }\n      this._endToken([this._cursor.getChars(start)]);\n      this._attemptCharCodeUntilFn(isBlockParameterChar);\n    }\n  }\n  _consumeLetDeclaration(start) {\n    this._requireStr('@let');\n    this._beginToken(29, start);\n    if (isWhitespace(this._cursor.peek())) {\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n    } else {\n      const token = this._endToken([this._cursor.getChars(start)]);\n      token.type = 32;\n      return;\n    }\n    const startToken = this._endToken([this._getLetDeclarationName()]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    if (!this._attemptCharCode($EQ)) {\n      startToken.type = 32;\n      return;\n    }\n    this._attemptCharCodeUntilFn(code => isNotWhitespace(code) && !isNewLine(code));\n    this._consumeLetDeclarationValue();\n    const endChar = this._cursor.peek();\n    if (endChar === $SEMICOLON) {\n      this._beginToken(31);\n      this._endToken([]);\n      this._cursor.advance();\n    } else {\n      startToken.type = 32;\n      startToken.sourceSpan = this._cursor.getSpan(start);\n    }\n  }\n  _getLetDeclarationName() {\n    const nameCursor = this._cursor.clone();\n    let allowDigit = false;\n    this._attemptCharCodeUntilFn(code => {\n      if (isAsciiLetter(code) || code === $$ || code === $_ || allowDigit && isDigit(code)) {\n        allowDigit = true;\n        return false;\n      }\n      return true;\n    });\n    return this._cursor.getChars(nameCursor).trim();\n  }\n  _consumeLetDeclarationValue() {\n    const start = this._cursor.clone();\n    this._beginToken(30, start);\n    while (this._cursor.peek() !== $EOF) {\n      const char = this._cursor.peek();\n      if (char === $SEMICOLON) {\n        break;\n      }\n      if (isQuote(char)) {\n        this._cursor.advance();\n        this._attemptCharCodeUntilFn(inner => {\n          if (inner === $BACKSLASH) {\n            this._cursor.advance();\n            return false;\n          }\n          return inner === char;\n        });\n      }\n      this._cursor.advance();\n    }\n    this._endToken([this._cursor.getChars(start)]);\n  }\n  _tokenizeExpansionForm() {\n    if (this.isExpansionFormStart()) {\n      this._consumeExpansionFormStart();\n      return true;\n    }\n    if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {\n      this._consumeExpansionCaseStart();\n      return true;\n    }\n    if (this._cursor.peek() === $RBRACE) {\n      if (this._isInExpansionCase()) {\n        this._consumeExpansionCaseEnd();\n        return true;\n      }\n      if (this._isInExpansionForm()) {\n        this._consumeExpansionFormEnd();\n        return true;\n      }\n    }\n    return false;\n  }\n  _beginToken(type, start = this._cursor.clone()) {\n    this._currentTokenStart = start;\n    this._currentTokenType = type;\n  }\n  _endToken(parts, end) {\n    if (this._currentTokenStart === null) {\n      throw new ParseError(this._cursor.getSpan(end), 'Programming error - attempted to end a token when there was no start to the token');\n    }\n    if (this._currentTokenType === null) {\n      throw new ParseError(this._cursor.getSpan(this._currentTokenStart), 'Programming error - attempted to end a token which has no token type');\n    }\n    const token = {\n      type: this._currentTokenType,\n      parts,\n      sourceSpan: (end ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints)\n    };\n    this.tokens.push(token);\n    this._currentTokenStart = null;\n    this._currentTokenType = null;\n    return token;\n  }\n  _createError(msg, span) {\n    if (this._isInExpansionForm()) {\n      msg += ` (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)`;\n    }\n    const error = new ParseError(span, msg);\n    this._currentTokenStart = null;\n    this._currentTokenType = null;\n    return error;\n  }\n  handleError(e) {\n    if (e instanceof CursorError) {\n      e = this._createError(e.msg, this._cursor.getSpan(e.cursor));\n    }\n    if (e instanceof ParseError) {\n      this.errors.push(e);\n    } else {\n      throw e;\n    }\n  }\n  _attemptCharCode(charCode) {\n    if (this._cursor.peek() === charCode) {\n      this._cursor.advance();\n      return true;\n    }\n    return false;\n  }\n  _attemptCharCodeCaseInsensitive(charCode) {\n    if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {\n      this._cursor.advance();\n      return true;\n    }\n    return false;\n  }\n  _requireCharCode(charCode) {\n    const location = this._cursor.clone();\n    if (!this._attemptCharCode(charCode)) {\n      throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n    }\n  }\n  _attemptStr(chars) {\n    const len = chars.length;\n    if (this._cursor.charsLeft() < len) {\n      return false;\n    }\n    const initialPosition = this._cursor.clone();\n    for (let i = 0; i < len; i++) {\n      if (!this._attemptCharCode(chars.charCodeAt(i))) {\n        this._cursor = initialPosition;\n        return false;\n      }\n    }\n    return true;\n  }\n  _attemptStrCaseInsensitive(chars) {\n    for (let i = 0; i < chars.length; i++) {\n      if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _requireStr(chars) {\n    const location = this._cursor.clone();\n    if (!this._attemptStr(chars)) {\n      throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n    }\n  }\n  _attemptCharCodeUntilFn(predicate) {\n    while (!predicate(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n  }\n  _requireCharCodeUntilFn(predicate, len) {\n    const start = this._cursor.clone();\n    this._attemptCharCodeUntilFn(predicate);\n    if (this._cursor.diff(start) < len) {\n      throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n    }\n  }\n  _attemptUntilChar(char) {\n    while (this._cursor.peek() !== char) {\n      this._cursor.advance();\n    }\n  }\n  _readChar() {\n    const char = String.fromCodePoint(this._cursor.peek());\n    this._cursor.advance();\n    return char;\n  }\n  _peekStr(chars) {\n    const len = chars.length;\n    if (this._cursor.charsLeft() < len) {\n      return false;\n    }\n    const cursor = this._cursor.clone();\n    for (let i = 0; i < len; i++) {\n      if (cursor.peek() !== chars.charCodeAt(i)) {\n        return false;\n      }\n      cursor.advance();\n    }\n    return true;\n  }\n  _isBlockStart() {\n    return this._cursor.peek() === $AT && SUPPORTED_BLOCKS.some(blockName => this._peekStr(blockName));\n  }\n  _isLetStart() {\n    return this._cursor.peek() === $AT && this._peekStr('@let');\n  }\n  _consumeEntity(textTokenType) {\n    this._beginToken(9);\n    const start = this._cursor.clone();\n    this._cursor.advance();\n    if (this._attemptCharCode($HASH)) {\n      const isHex = this._attemptCharCode($x) || this._attemptCharCode($X);\n      const codeStart = this._cursor.clone();\n      this._attemptCharCodeUntilFn(isDigitEntityEnd);\n      if (this._cursor.peek() != $SEMICOLON) {\n        this._cursor.advance();\n        const entityType = isHex ? CharacterReferenceType.HEX : CharacterReferenceType.DEC;\n        throw this._createError(_unparsableEntityErrorMsg(entityType, this._cursor.getChars(start)), this._cursor.getSpan());\n      }\n      const strNum = this._cursor.getChars(codeStart);\n      this._cursor.advance();\n      try {\n        const charCode = parseInt(strNum, isHex ? 16 : 10);\n        this._endToken([String.fromCodePoint(charCode), this._cursor.getChars(start)]);\n      } catch {\n        throw this._createError(_unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());\n      }\n    } else {\n      const nameStart = this._cursor.clone();\n      this._attemptCharCodeUntilFn(isNamedEntityEnd);\n      if (this._cursor.peek() != $SEMICOLON) {\n        this._beginToken(textTokenType, start);\n        this._cursor = nameStart;\n        this._endToken(['&']);\n      } else {\n        const name = this._cursor.getChars(nameStart);\n        this._cursor.advance();\n        const char = NAMED_ENTITIES.hasOwnProperty(name) && NAMED_ENTITIES[name];\n        if (!char) {\n          throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));\n        }\n        this._endToken([char, `&${name};`]);\n      }\n    }\n  }\n  _consumeRawText(consumeEntities, endMarkerPredicate) {\n    this._beginToken(consumeEntities ? 6 : 7);\n    const parts = [];\n    while (true) {\n      const tagCloseStart = this._cursor.clone();\n      const foundEndMarker = endMarkerPredicate();\n      this._cursor = tagCloseStart;\n      if (foundEndMarker) {\n        break;\n      }\n      if (consumeEntities && this._cursor.peek() === $AMPERSAND) {\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n        parts.length = 0;\n        this._consumeEntity(6);\n        this._beginToken(6);\n      } else {\n        parts.push(this._readChar());\n      }\n    }\n    this._endToken([this._processCarriageReturns(parts.join(''))]);\n  }\n  _consumeComment(start) {\n    this._beginToken(10, start);\n    this._requireCharCode($MINUS);\n    this._endToken([]);\n    this._consumeRawText(false, () => this._attemptStr('-->'));\n    this._beginToken(11);\n    this._requireStr('-->');\n    this._endToken([]);\n  }\n  _consumeCdata(start) {\n    this._beginToken(12, start);\n    this._requireStr('CDATA[');\n    this._endToken([]);\n    this._consumeRawText(false, () => this._attemptStr(']]>'));\n    this._beginToken(13);\n    this._requireStr(']]>');\n    this._endToken([]);\n  }\n  _consumeDocType(start) {\n    this._beginToken(18, start);\n    const contentStart = this._cursor.clone();\n    this._attemptUntilChar($GT);\n    const content = this._cursor.getChars(contentStart);\n    this._cursor.advance();\n    this._endToken([content]);\n  }\n  _consumePrefixAndName(endPredicate) {\n    const nameOrPrefixStart = this._cursor.clone();\n    let prefix = '';\n    while (this._cursor.peek() !== $COLON && !isPrefixEnd(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n    let nameStart;\n    if (this._cursor.peek() === $COLON) {\n      prefix = this._cursor.getChars(nameOrPrefixStart);\n      this._cursor.advance();\n      nameStart = this._cursor.clone();\n    } else {\n      nameStart = nameOrPrefixStart;\n    }\n    this._requireCharCodeUntilFn(endPredicate, prefix === '' ? 0 : 1);\n    const name = this._cursor.getChars(nameStart);\n    return [prefix, name];\n  }\n  _consumeTagOpen(start) {\n    let tagName;\n    let prefix;\n    let closingTagName;\n    let openToken;\n    try {\n      if (this._selectorlessEnabled && isSelectorlessNameStart(this._cursor.peek())) {\n        openToken = this._consumeComponentOpenStart(start);\n        [closingTagName, prefix, tagName] = openToken.parts;\n        if (prefix) {\n          closingTagName += `:${prefix}`;\n        }\n        if (tagName) {\n          closingTagName += `:${tagName}`;\n        }\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      } else {\n        if (!isAsciiLetter(this._cursor.peek())) {\n          throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n        }\n        openToken = this._consumeTagOpenStart(start);\n        prefix = openToken.parts[0];\n        tagName = closingTagName = openToken.parts[1];\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      }\n      while (!isAttributeTerminator(this._cursor.peek())) {\n        if (this._selectorlessEnabled && this._cursor.peek() === $AT) {\n          const start = this._cursor.clone();\n          const nameStart = start.clone();\n          nameStart.advance();\n          if (isSelectorlessNameStart(nameStart.peek())) {\n            this._consumeDirective(start, nameStart);\n          }\n        } else {\n          this._consumeAttribute();\n        }\n      }\n      if (openToken.type === 33) {\n        this._consumeComponentOpenEnd();\n      } else {\n        this._consumeTagOpenEnd();\n      }\n    } catch (e) {\n      if (e instanceof ParseError) {\n        if (openToken) {\n          openToken.type = openToken.type === 33 ? 37 : 4;\n        } else {\n          this._beginToken(5, start);\n          this._endToken(['<']);\n        }\n        return;\n      }\n      throw e;\n    }\n    const contentTokenType = this._getTagDefinition(tagName).getContentType(prefix);\n    if (contentTokenType === TagContentType.RAW_TEXT) {\n      this._consumeRawTextWithTagClose(openToken, closingTagName, false);\n    } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n      this._consumeRawTextWithTagClose(openToken, closingTagName, true);\n    }\n  }\n  _consumeRawTextWithTagClose(openToken, tagName, consumeEntities) {\n    this._consumeRawText(consumeEntities, () => {\n      if (!this._attemptCharCode($LT)) return false;\n      if (!this._attemptCharCode($SLASH)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      if (!this._attemptStrCaseInsensitive(tagName)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      return this._attemptCharCode($GT);\n    });\n    this._beginToken(openToken.type === 33 ? 36 : 3);\n    this._requireCharCodeUntilFn(code => code === $GT, 3);\n    this._cursor.advance();\n    this._endToken(openToken.parts);\n  }\n  _consumeTagOpenStart(start) {\n    this._beginToken(0, start);\n    const parts = this._consumePrefixAndName(isNameEnd);\n    return this._endToken(parts);\n  }\n  _consumeComponentOpenStart(start) {\n    this._beginToken(33, start);\n    const parts = this._consumeComponentName();\n    return this._endToken(parts);\n  }\n  _consumeComponentName() {\n    const nameStart = this._cursor.clone();\n    while (isSelectorlessNameChar(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n    const name = this._cursor.getChars(nameStart);\n    let prefix = '';\n    let tagName = '';\n    if (this._cursor.peek() === $COLON) {\n      this._cursor.advance();\n      [prefix, tagName] = this._consumePrefixAndName(isNameEnd);\n    }\n    return [name, prefix, tagName];\n  }\n  _consumeAttribute() {\n    this._consumeAttributeName();\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    if (this._attemptCharCode($EQ)) {\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      this._consumeAttributeValue();\n    }\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n  _consumeAttributeName() {\n    const attrNameStart = this._cursor.peek();\n    if (attrNameStart === $SQ || attrNameStart === $DQ) {\n      throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());\n    }\n    this._beginToken(14);\n    let nameEndPredicate;\n    if (this._openDirectiveCount > 0) {\n      let openParens = 0;\n      nameEndPredicate = code => {\n        if (this._openDirectiveCount > 0) {\n          if (code === $LPAREN) {\n            openParens++;\n          } else if (code === $RPAREN) {\n            if (openParens === 0) {\n              return true;\n            }\n            openParens--;\n          }\n        }\n        return isNameEnd(code);\n      };\n    } else if (attrNameStart === $LBRACKET) {\n      let openBrackets = 0;\n      nameEndPredicate = code => {\n        if (code === $LBRACKET) {\n          openBrackets++;\n        } else if (code === $RBRACKET) {\n          openBrackets--;\n        }\n        return openBrackets <= 0 ? isNameEnd(code) : isNewLine(code);\n      };\n    } else {\n      nameEndPredicate = isNameEnd;\n    }\n    const prefixAndName = this._consumePrefixAndName(nameEndPredicate);\n    this._endToken(prefixAndName);\n  }\n  _consumeAttributeValue() {\n    if (this._cursor.peek() === $SQ || this._cursor.peek() === $DQ) {\n      const quoteChar = this._cursor.peek();\n      this._consumeQuote(quoteChar);\n      const endPredicate = () => this._cursor.peek() === quoteChar;\n      this._consumeWithInterpolation(16, 17, endPredicate, endPredicate);\n      this._consumeQuote(quoteChar);\n    } else {\n      const endPredicate = () => isNameEnd(this._cursor.peek());\n      this._consumeWithInterpolation(16, 17, endPredicate, endPredicate);\n    }\n  }\n  _consumeQuote(quoteChar) {\n    this._beginToken(15);\n    this._requireCharCode(quoteChar);\n    this._endToken([String.fromCodePoint(quoteChar)]);\n  }\n  _consumeTagOpenEnd() {\n    const tokenType = this._attemptCharCode($SLASH) ? 2 : 1;\n    this._beginToken(tokenType);\n    this._requireCharCode($GT);\n    this._endToken([]);\n  }\n  _consumeComponentOpenEnd() {\n    const tokenType = this._attemptCharCode($SLASH) ? 35 : 34;\n    this._beginToken(tokenType);\n    this._requireCharCode($GT);\n    this._endToken([]);\n  }\n  _consumeTagClose(start) {\n    if (this._selectorlessEnabled) {\n      const clone = start.clone();\n      while (clone.peek() !== $GT && !isSelectorlessNameStart(clone.peek())) {\n        clone.advance();\n      }\n      if (isSelectorlessNameStart(clone.peek())) {\n        this._beginToken(36, start);\n        const parts = this._consumeComponentName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._requireCharCode($GT);\n        this._endToken(parts);\n        return;\n      }\n    }\n    this._beginToken(3, start);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    const prefixAndName = this._consumePrefixAndName(isNameEnd);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._requireCharCode($GT);\n    this._endToken(prefixAndName);\n  }\n  _consumeExpansionFormStart() {\n    this._beginToken(19);\n    this._requireCharCode($LBRACE);\n    this._endToken([]);\n    this._expansionCaseStack.push(19);\n    this._beginToken(7);\n    const condition = this._readUntil($COMMA);\n    const normalizedCondition = this._processCarriageReturns(condition);\n    if (this._i18nNormalizeLineEndingsInICUs) {\n      this._endToken([normalizedCondition]);\n    } else {\n      const conditionToken = this._endToken([condition]);\n      if (normalizedCondition !== condition) {\n        this.nonNormalizedIcuExpressions.push(conditionToken);\n      }\n    }\n    this._requireCharCode($COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._beginToken(7);\n    const type = this._readUntil($COMMA);\n    this._endToken([type]);\n    this._requireCharCode($COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n  _consumeExpansionCaseStart() {\n    this._beginToken(20);\n    const value = this._readUntil($LBRACE).trim();\n    this._endToken([value]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._beginToken(21);\n    this._requireCharCode($LBRACE);\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._expansionCaseStack.push(21);\n  }\n  _consumeExpansionCaseEnd() {\n    this._beginToken(22);\n    this._requireCharCode($RBRACE);\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._expansionCaseStack.pop();\n  }\n  _consumeExpansionFormEnd() {\n    this._beginToken(23);\n    this._requireCharCode($RBRACE);\n    this._endToken([]);\n    this._expansionCaseStack.pop();\n  }\n  _consumeWithInterpolation(textTokenType, interpolationTokenType, endPredicate, endInterpolation) {\n    this._beginToken(textTokenType);\n    const parts = [];\n    while (!endPredicate()) {\n      const current = this._cursor.clone();\n      if (this._attemptStr(INTERPOLATION.start)) {\n        this._endToken([this._processCarriageReturns(parts.join(''))], current);\n        parts.length = 0;\n        this._consumeInterpolation(interpolationTokenType, current, endInterpolation);\n        this._beginToken(textTokenType);\n      } else if (this._cursor.peek() === $AMPERSAND) {\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n        parts.length = 0;\n        this._consumeEntity(textTokenType);\n        this._beginToken(textTokenType);\n      } else {\n        parts.push(this._readChar());\n      }\n    }\n    this._inInterpolation = false;\n    this._endToken([this._processCarriageReturns(parts.join(''))]);\n  }\n  _consumeInterpolation(interpolationTokenType, interpolationStart, prematureEndPredicate) {\n    const parts = [];\n    this._beginToken(interpolationTokenType, interpolationStart);\n    parts.push(INTERPOLATION.start);\n    const expressionStart = this._cursor.clone();\n    let inQuote = null;\n    let inComment = false;\n    while (this._cursor.peek() !== $EOF && (prematureEndPredicate === null || !prematureEndPredicate())) {\n      const current = this._cursor.clone();\n      if (this._isTagStart()) {\n        this._cursor = current;\n        parts.push(this._getProcessedChars(expressionStart, current));\n        this._endToken(parts);\n        return;\n      }\n      if (inQuote === null) {\n        if (this._attemptStr(INTERPOLATION.end)) {\n          parts.push(this._getProcessedChars(expressionStart, current));\n          parts.push(INTERPOLATION.end);\n          this._endToken(parts);\n          return;\n        } else if (this._attemptStr('//')) {\n          inComment = true;\n        }\n      }\n      const char = this._cursor.peek();\n      this._cursor.advance();\n      if (char === $BACKSLASH) {\n        this._cursor.advance();\n      } else if (char === inQuote) {\n        inQuote = null;\n      } else if (!inComment && inQuote === null && isQuote(char)) {\n        inQuote = char;\n      }\n    }\n    parts.push(this._getProcessedChars(expressionStart, this._cursor));\n    this._endToken(parts);\n  }\n  _consumeDirective(start, nameStart) {\n    this._requireCharCode($AT);\n    this._cursor.advance();\n    while (isSelectorlessNameChar(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n    this._beginToken(38, start);\n    const name = this._cursor.getChars(nameStart);\n    this._endToken([name]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    if (this._cursor.peek() !== $LPAREN) {\n      return;\n    }\n    this._openDirectiveCount++;\n    this._beginToken(39);\n    this._cursor.advance();\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    while (!isAttributeTerminator(this._cursor.peek()) && this._cursor.peek() !== $RPAREN) {\n      this._consumeAttribute();\n    }\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._openDirectiveCount--;\n    if (this._cursor.peek() !== $RPAREN) {\n      if (this._cursor.peek() === $GT || this._cursor.peek() === $SLASH) {\n        return;\n      }\n      throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n    }\n    this._beginToken(40);\n    this._cursor.advance();\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n  _getProcessedChars(start, end) {\n    return this._processCarriageReturns(end.getChars(start));\n  }\n  _isTextEnd() {\n    if (this._isTagStart() || this._cursor.peek() === $EOF) {\n      return true;\n    }\n    if (this._tokenizeIcu && !this._inInterpolation) {\n      if (this.isExpansionFormStart()) {\n        return true;\n      }\n      if (this._cursor.peek() === $RBRACE && this._isInExpansionCase()) {\n        return true;\n      }\n    }\n    if (this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansion() && (this._isBlockStart() || this._isLetStart() || this._cursor.peek() === $RBRACE)) {\n      return true;\n    }\n    return false;\n  }\n  _isTagStart() {\n    if (this._cursor.peek() === $LT) {\n      const tmp = this._cursor.clone();\n      tmp.advance();\n      const code = tmp.peek();\n      if ($a <= code && code <= $z || $A <= code && code <= $Z || code === $SLASH || code === $BANG) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _readUntil(char) {\n    const start = this._cursor.clone();\n    this._attemptUntilChar(char);\n    return this._cursor.getChars(start);\n  }\n  _isInExpansion() {\n    return this._isInExpansionCase() || this._isInExpansionForm();\n  }\n  _isInExpansionCase() {\n    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 21;\n  }\n  _isInExpansionForm() {\n    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 19;\n  }\n  isExpansionFormStart() {\n    if (this._cursor.peek() !== $LBRACE) {\n      return false;\n    }\n    const start = this._cursor.clone();\n    const isInterpolation = this._attemptStr(INTERPOLATION.start);\n    this._cursor = start;\n    return !isInterpolation;\n  }\n}\nfunction isNotWhitespace(code) {\n  return !isWhitespace(code) || code === $EOF;\n}\nfunction isNameEnd(code) {\n  return isWhitespace(code) || code === $GT || code === $LT || code === $SLASH || code === $SQ || code === $DQ || code === $EQ || code === $EOF;\n}\nfunction isPrefixEnd(code) {\n  return (code < $a || $z < code) && (code < $A || $Z < code) && (code < $0 || code > $9);\n}\nfunction isDigitEntityEnd(code) {\n  return code === $SEMICOLON || code === $EOF || !isAsciiHexDigit(code);\n}\nfunction isNamedEntityEnd(code) {\n  return code === $SEMICOLON || code === $EOF || !isAsciiLetter(code);\n}\nfunction isExpansionCaseStart(peek) {\n  return peek !== $RBRACE;\n}\nfunction compareCharCodeCaseInsensitive(code1, code2) {\n  return toUpperCaseCharCode(code1) === toUpperCaseCharCode(code2);\n}\nfunction toUpperCaseCharCode(code) {\n  return code >= $a && code <= $z ? code - $a + $A : code;\n}\nfunction isBlockNameChar(code) {\n  return isAsciiLetter(code) || isDigit(code) || code === $_;\n}\nfunction isBlockParameterChar(code) {\n  return code !== $SEMICOLON && isNotWhitespace(code);\n}\nfunction isSelectorlessNameStart(code) {\n  return code === $_ || code >= $A && code <= $Z;\n}\nfunction isSelectorlessNameChar(code) {\n  return isAsciiLetter(code) || isDigit(code) || code === $_;\n}\nfunction isAttributeTerminator(code) {\n  return code === $SLASH || code === $GT || code === $LT || code === $EOF;\n}\nfunction mergeTextTokens(srcTokens) {\n  const dstTokens = [];\n  let lastDstToken = undefined;\n  for (let i = 0; i < srcTokens.length; i++) {\n    const token = srcTokens[i];\n    if (lastDstToken && lastDstToken.type === 5 && token.type === 5 || lastDstToken && lastDstToken.type === 16 && token.type === 16) {\n      lastDstToken.parts[0] += token.parts[0];\n      lastDstToken.sourceSpan.end = token.sourceSpan.end;\n    } else {\n      lastDstToken = token;\n      dstTokens.push(lastDstToken);\n    }\n  }\n  return dstTokens;\n}\nclass PlainCharacterCursor {\n  state;\n  file;\n  input;\n  end;\n  constructor(fileOrCursor, range) {\n    if (fileOrCursor instanceof PlainCharacterCursor) {\n      this.file = fileOrCursor.file;\n      this.input = fileOrCursor.input;\n      this.end = fileOrCursor.end;\n      const state = fileOrCursor.state;\n      this.state = {\n        peek: state.peek,\n        offset: state.offset,\n        line: state.line,\n        column: state.column\n      };\n    } else {\n      if (!range) {\n        throw new Error('Programming error: the range argument must be provided with a file argument.');\n      }\n      this.file = fileOrCursor;\n      this.input = fileOrCursor.content;\n      this.end = range.endPos;\n      this.state = {\n        peek: -1,\n        offset: range.startPos,\n        line: range.startLine,\n        column: range.startCol\n      };\n    }\n  }\n  clone() {\n    return new PlainCharacterCursor(this);\n  }\n  peek() {\n    return this.state.peek;\n  }\n  charsLeft() {\n    return this.end - this.state.offset;\n  }\n  diff(other) {\n    return this.state.offset - other.state.offset;\n  }\n  advance() {\n    this.advanceState(this.state);\n  }\n  init() {\n    this.updatePeek(this.state);\n  }\n  getSpan(start, leadingTriviaCodePoints) {\n    start = start || this;\n    let fullStart = start;\n    if (leadingTriviaCodePoints) {\n      while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {\n        if (fullStart === start) {\n          start = start.clone();\n        }\n        start.advance();\n      }\n    }\n    const startLocation = this.locationFromCursor(start);\n    const endLocation = this.locationFromCursor(this);\n    const fullStartLocation = fullStart !== start ? this.locationFromCursor(fullStart) : startLocation;\n    return new ParseSourceSpan(startLocation, endLocation, fullStartLocation);\n  }\n  getChars(start) {\n    return this.input.substring(start.state.offset, this.state.offset);\n  }\n  charAt(pos) {\n    return this.input.charCodeAt(pos);\n  }\n  advanceState(state) {\n    if (state.offset >= this.end) {\n      this.state = state;\n      throw new CursorError('Unexpected character \"EOF\"', this);\n    }\n    const currentChar = this.charAt(state.offset);\n    if (currentChar === $LF) {\n      state.line++;\n      state.column = 0;\n    } else if (!isNewLine(currentChar)) {\n      state.column++;\n    }\n    state.offset++;\n    this.updatePeek(state);\n  }\n  updatePeek(state) {\n    state.peek = state.offset >= this.end ? $EOF : this.charAt(state.offset);\n  }\n  locationFromCursor(cursor) {\n    return new ParseLocation(cursor.file, cursor.state.offset, cursor.state.line, cursor.state.column);\n  }\n}\nclass EscapedCharacterCursor extends PlainCharacterCursor {\n  internalState;\n  constructor(fileOrCursor, range) {\n    if (fileOrCursor instanceof EscapedCharacterCursor) {\n      super(fileOrCursor);\n      this.internalState = {\n        ...fileOrCursor.internalState\n      };\n    } else {\n      super(fileOrCursor, range);\n      this.internalState = this.state;\n    }\n  }\n  advance() {\n    this.state = this.internalState;\n    super.advance();\n    this.processEscapeSequence();\n  }\n  init() {\n    super.init();\n    this.processEscapeSequence();\n  }\n  clone() {\n    return new EscapedCharacterCursor(this);\n  }\n  getChars(start) {\n    const cursor = start.clone();\n    let chars = '';\n    while (cursor.internalState.offset < this.internalState.offset) {\n      chars += String.fromCodePoint(cursor.peek());\n      cursor.advance();\n    }\n    return chars;\n  }\n  processEscapeSequence() {\n    const peek = () => this.internalState.peek;\n    if (peek() === $BACKSLASH) {\n      this.internalState = {\n        ...this.state\n      };\n      this.advanceState(this.internalState);\n      if (peek() === $n) {\n        this.state.peek = $LF;\n      } else if (peek() === $r) {\n        this.state.peek = $CR;\n      } else if (peek() === $v) {\n        this.state.peek = $VTAB;\n      } else if (peek() === $t) {\n        this.state.peek = $TAB;\n      } else if (peek() === $b) {\n        this.state.peek = $BSPACE;\n      } else if (peek() === $f) {\n        this.state.peek = $FF;\n      } else if (peek() === $u) {\n        this.advanceState(this.internalState);\n        if (peek() === $LBRACE) {\n          this.advanceState(this.internalState);\n          const digitStart = this.clone();\n          let length = 0;\n          while (peek() !== $RBRACE) {\n            this.advanceState(this.internalState);\n            length++;\n          }\n          this.state.peek = this.decodeHexDigits(digitStart, length);\n        } else {\n          const digitStart = this.clone();\n          this.advanceState(this.internalState);\n          this.advanceState(this.internalState);\n          this.advanceState(this.internalState);\n          this.state.peek = this.decodeHexDigits(digitStart, 4);\n        }\n      } else if (peek() === $x) {\n        this.advanceState(this.internalState);\n        const digitStart = this.clone();\n        this.advanceState(this.internalState);\n        this.state.peek = this.decodeHexDigits(digitStart, 2);\n      } else if (isOctalDigit(peek())) {\n        let octal = '';\n        let length = 0;\n        let previous = this.clone();\n        while (isOctalDigit(peek()) && length < 3) {\n          previous = this.clone();\n          octal += String.fromCodePoint(peek());\n          this.advanceState(this.internalState);\n          length++;\n        }\n        this.state.peek = parseInt(octal, 8);\n        this.internalState = previous.internalState;\n      } else if (isNewLine(this.internalState.peek)) {\n        this.advanceState(this.internalState);\n        this.state = this.internalState;\n      } else {\n        this.state.peek = this.internalState.peek;\n      }\n    }\n  }\n  decodeHexDigits(start, length) {\n    const hex = this.input.slice(start.internalState.offset, start.internalState.offset + length);\n    const charCode = parseInt(hex, 16);\n    if (!isNaN(charCode)) {\n      return charCode;\n    } else {\n      start.state = start.internalState;\n      throw new CursorError('Invalid hexadecimal escape sequence', start);\n    }\n  }\n}\nclass CursorError extends Error {\n  msg;\n  cursor;\n  constructor(msg, cursor) {\n    super(msg);\n    this.msg = msg;\n    this.cursor = cursor;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\n\nclass TreeError extends ParseError {\n  elementName;\n  static create(elementName, span, msg) {\n    return new TreeError(elementName, span, msg);\n  }\n  constructor(elementName, span, msg) {\n    super(span, msg);\n    this.elementName = elementName;\n  }\n}\nclass ParseTreeResult {\n  rootNodes;\n  errors;\n  constructor(rootNodes, errors) {\n    this.rootNodes = rootNodes;\n    this.errors = errors;\n  }\n}\nlet Parser$1 = class Parser {\n  getTagDefinition;\n  constructor(getTagDefinition) {\n    this.getTagDefinition = getTagDefinition;\n  }\n  parse(source, url, options) {\n    const tokenizeResult = tokenize(source, url, this.getTagDefinition, options);\n    const parser = new _TreeBuilder(tokenizeResult.tokens, this.getTagDefinition);\n    parser.build();\n    return new ParseTreeResult(parser.rootNodes, [...tokenizeResult.errors, ...parser.errors]);\n  }\n};\nclass _TreeBuilder {\n  tokens;\n  tagDefinitionResolver;\n  _index = -1;\n  _peek;\n  _containerStack = [];\n  rootNodes = [];\n  errors = [];\n  constructor(tokens, tagDefinitionResolver) {\n    this.tokens = tokens;\n    this.tagDefinitionResolver = tagDefinitionResolver;\n    this._advance();\n  }\n  build() {\n    while (this._peek.type !== 41) {\n      if (this._peek.type === 0 || this._peek.type === 4) {\n        this._consumeElementStartTag(this._advance());\n      } else if (this._peek.type === 3) {\n        this._consumeElementEndTag(this._advance());\n      } else if (this._peek.type === 12) {\n        this._closeVoidElement();\n        this._consumeCdata(this._advance());\n      } else if (this._peek.type === 10) {\n        this._closeVoidElement();\n        this._consumeComment(this._advance());\n      } else if (this._peek.type === 5 || this._peek.type === 7 || this._peek.type === 6) {\n        this._closeVoidElement();\n        this._consumeText(this._advance());\n      } else if (this._peek.type === 19) {\n        this._consumeExpansion(this._advance());\n      } else if (this._peek.type === 24) {\n        this._closeVoidElement();\n        this._consumeBlockOpen(this._advance());\n      } else if (this._peek.type === 26) {\n        this._closeVoidElement();\n        this._consumeBlockClose(this._advance());\n      } else if (this._peek.type === 28) {\n        this._closeVoidElement();\n        this._consumeIncompleteBlock(this._advance());\n      } else if (this._peek.type === 29) {\n        this._closeVoidElement();\n        this._consumeLet(this._advance());\n      } else if (this._peek.type === 32) {\n        this._closeVoidElement();\n        this._consumeIncompleteLet(this._advance());\n      } else if (this._peek.type === 33 || this._peek.type === 37) {\n        this._consumeComponentStartTag(this._advance());\n      } else if (this._peek.type === 36) {\n        this._consumeComponentEndTag(this._advance());\n      } else {\n        this._advance();\n      }\n    }\n    for (const leftoverContainer of this._containerStack) {\n      if (leftoverContainer instanceof Block) {\n        this.errors.push(TreeError.create(leftoverContainer.name, leftoverContainer.sourceSpan, `Unclosed block \"${leftoverContainer.name}\"`));\n      }\n    }\n  }\n  _advance() {\n    const prev = this._peek;\n    if (this._index < this.tokens.length - 1) {\n      this._index++;\n    }\n    this._peek = this.tokens[this._index];\n    return prev;\n  }\n  _advanceIf(type) {\n    if (this._peek.type === type) {\n      return this._advance();\n    }\n    return null;\n  }\n  _consumeCdata(_startToken) {\n    this._consumeText(this._advance());\n    this._advanceIf(13);\n  }\n  _consumeComment(token) {\n    const text = this._advanceIf(7);\n    const endToken = this._advanceIf(11);\n    const value = text != null ? text.parts[0].trim() : null;\n    const sourceSpan = endToken == null ? token.sourceSpan : new ParseSourceSpan(token.sourceSpan.start, endToken.sourceSpan.end, token.sourceSpan.fullStart);\n    this._addToParent(new Comment(value, sourceSpan));\n  }\n  _consumeExpansion(token) {\n    const switchValue = this._advance();\n    const type = this._advance();\n    const cases = [];\n    while (this._peek.type === 20) {\n      const expCase = this._parseExpansionCase();\n      if (!expCase) return;\n      cases.push(expCase);\n    }\n    if (this._peek.type !== 23) {\n      this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '}'.`));\n      return;\n    }\n    const sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end, token.sourceSpan.fullStart);\n    this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));\n    this._advance();\n  }\n  _parseExpansionCase() {\n    const value = this._advance();\n    if (this._peek.type !== 21) {\n      this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '{'.`));\n      return null;\n    }\n    const start = this._advance();\n    const exp = this._collectExpansionExpTokens(start);\n    if (!exp) return null;\n    const end = this._advance();\n    exp.push({\n      type: 41,\n      parts: [],\n      sourceSpan: end.sourceSpan\n    });\n    const expansionCaseParser = new _TreeBuilder(exp, this.tagDefinitionResolver);\n    expansionCaseParser.build();\n    if (expansionCaseParser.errors.length > 0) {\n      this.errors = this.errors.concat(expansionCaseParser.errors);\n      return null;\n    }\n    const sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end, value.sourceSpan.fullStart);\n    const expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end, start.sourceSpan.fullStart);\n    return new ExpansionCase(value.parts[0], expansionCaseParser.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);\n  }\n  _collectExpansionExpTokens(start) {\n    const exp = [];\n    const expansionFormStack = [21];\n    while (true) {\n      if (this._peek.type === 19 || this._peek.type === 21) {\n        expansionFormStack.push(this._peek.type);\n      }\n      if (this._peek.type === 22) {\n        if (lastOnStack(expansionFormStack, 21)) {\n          expansionFormStack.pop();\n          if (expansionFormStack.length === 0) return exp;\n        } else {\n          this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n          return null;\n        }\n      }\n      if (this._peek.type === 23) {\n        if (lastOnStack(expansionFormStack, 19)) {\n          expansionFormStack.pop();\n        } else {\n          this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n          return null;\n        }\n      }\n      if (this._peek.type === 41) {\n        this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n        return null;\n      }\n      exp.push(this._advance());\n    }\n  }\n  _consumeText(token) {\n    const tokens = [token];\n    const startSpan = token.sourceSpan;\n    let text = token.parts[0];\n    if (text.length > 0 && text[0] === '\\n') {\n      const parent = this._getContainer();\n      if (parent != null && parent.children.length === 0 && this._getTagDefinition(parent)?.ignoreFirstLf) {\n        text = text.substring(1);\n        tokens[0] = {\n          type: token.type,\n          sourceSpan: token.sourceSpan,\n          parts: [text]\n        };\n      }\n    }\n    while (this._peek.type === 8 || this._peek.type === 5 || this._peek.type === 9) {\n      token = this._advance();\n      tokens.push(token);\n      if (token.type === 8) {\n        text += token.parts.join('').replace(/&([^;]+);/g, decodeEntity);\n      } else if (token.type === 9) {\n        text += token.parts[0];\n      } else {\n        text += token.parts.join('');\n      }\n    }\n    if (text.length > 0) {\n      const endSpan = token.sourceSpan;\n      this._addToParent(new Text(text, new ParseSourceSpan(startSpan.start, endSpan.end, startSpan.fullStart, startSpan.details), tokens));\n    }\n  }\n  _closeVoidElement() {\n    const el = this._getContainer();\n    if (el !== null && this._getTagDefinition(el)?.isVoid) {\n      this._containerStack.pop();\n    }\n  }\n  _consumeElementStartTag(startTagToken) {\n    const attrs = [];\n    const directives = [];\n    this._consumeAttributesAndDirectives(attrs, directives);\n    const fullName = this._getElementFullName(startTagToken, this._getClosestElementLikeParent());\n    const tagDef = this._getTagDefinition(fullName);\n    let selfClosing = false;\n    if (this._peek.type === 2) {\n      this._advance();\n      selfClosing = true;\n      if (!(tagDef?.canSelfClose || getNsPrefix(fullName) !== null || tagDef?.isVoid)) {\n        this.errors.push(TreeError.create(fullName, startTagToken.sourceSpan, `Only void, custom and foreign elements can be self closed \"${startTagToken.parts[1]}\"`));\n      }\n    } else if (this._peek.type === 1) {\n      this._advance();\n      selfClosing = false;\n    }\n    const end = this._peek.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);\n    const startSpan = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);\n    const el = new Element(fullName, attrs, directives, [], selfClosing, span, startSpan, undefined, tagDef?.isVoid ?? false);\n    const parent = this._getContainer();\n    const isClosedByChild = parent !== null && !!this._getTagDefinition(parent)?.isClosedByChild(el.name);\n    this._pushContainer(el, isClosedByChild);\n    if (selfClosing) {\n      this._popContainer(fullName, Element, span);\n    } else if (startTagToken.type === 4) {\n      this._popContainer(fullName, Element, null);\n      this.errors.push(TreeError.create(fullName, span, `Opening tag \"${fullName}\" not terminated.`));\n    }\n  }\n  _consumeComponentStartTag(startToken) {\n    const componentName = startToken.parts[0];\n    const attrs = [];\n    const directives = [];\n    this._consumeAttributesAndDirectives(attrs, directives);\n    const closestElement = this._getClosestElementLikeParent();\n    const tagName = this._getComponentTagName(startToken, closestElement);\n    const fullName = this._getComponentFullName(startToken, closestElement);\n    const selfClosing = this._peek.type === 35;\n    this._advance();\n    const end = this._peek.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(startToken.sourceSpan.start, end, startToken.sourceSpan.fullStart);\n    const startSpan = new ParseSourceSpan(startToken.sourceSpan.start, end, startToken.sourceSpan.fullStart);\n    const node = new Component(componentName, tagName, fullName, attrs, directives, [], selfClosing, span, startSpan, undefined);\n    const parent = this._getContainer();\n    const isClosedByChild = parent !== null && node.tagName !== null && !!this._getTagDefinition(parent)?.isClosedByChild(node.tagName);\n    this._pushContainer(node, isClosedByChild);\n    if (selfClosing) {\n      this._popContainer(fullName, Component, span);\n    } else if (startToken.type === 37) {\n      this._popContainer(fullName, Component, null);\n      this.errors.push(TreeError.create(fullName, span, `Opening tag \"${fullName}\" not terminated.`));\n    }\n  }\n  _consumeAttributesAndDirectives(attributesResult, directivesResult) {\n    while (this._peek.type === 14 || this._peek.type === 38) {\n      if (this._peek.type === 38) {\n        directivesResult.push(this._consumeDirective(this._peek));\n      } else {\n        attributesResult.push(this._consumeAttr(this._advance()));\n      }\n    }\n  }\n  _consumeComponentEndTag(endToken) {\n    const fullName = this._getComponentFullName(endToken, this._getClosestElementLikeParent());\n    if (!this._popContainer(fullName, Component, endToken.sourceSpan)) {\n      const container = this._containerStack[this._containerStack.length - 1];\n      let suffix;\n      if (container instanceof Component && container.componentName === endToken.parts[0]) {\n        suffix = `, did you mean \"${container.fullName}\"?`;\n      } else {\n        suffix = '. It may happen when the tag has already been closed by another tag.';\n      }\n      const errMsg = `Unexpected closing tag \"${fullName}\"${suffix}`;\n      this.errors.push(TreeError.create(fullName, endToken.sourceSpan, errMsg));\n    }\n  }\n  _getTagDefinition(nodeOrName) {\n    if (typeof nodeOrName === 'string') {\n      return this.tagDefinitionResolver(nodeOrName);\n    } else if (nodeOrName instanceof Element) {\n      return this.tagDefinitionResolver(nodeOrName.name);\n    } else if (nodeOrName instanceof Component && nodeOrName.tagName !== null) {\n      return this.tagDefinitionResolver(nodeOrName.tagName);\n    } else {\n      return null;\n    }\n  }\n  _pushContainer(node, isClosedByChild) {\n    if (isClosedByChild) {\n      this._containerStack.pop();\n    }\n    this._addToParent(node);\n    this._containerStack.push(node);\n  }\n  _consumeElementEndTag(endTagToken) {\n    const fullName = this._getElementFullName(endTagToken, this._getClosestElementLikeParent());\n    if (this._getTagDefinition(fullName)?.isVoid) {\n      this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, `Void elements do not have end tags \"${endTagToken.parts[1]}\"`));\n    } else if (!this._popContainer(fullName, Element, endTagToken.sourceSpan)) {\n      const errMsg = `Unexpected closing tag \"${fullName}\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;\n      this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n    }\n  }\n  _popContainer(expectedName, expectedType, endSourceSpan) {\n    let unexpectedCloseTagDetected = false;\n    for (let stackIndex = this._containerStack.length - 1; stackIndex >= 0; stackIndex--) {\n      const node = this._containerStack[stackIndex];\n      const nodeName = node instanceof Component ? node.fullName : node.name;\n      if ((nodeName === expectedName || expectedName === null) && node instanceof expectedType) {\n        node.endSourceSpan = endSourceSpan;\n        node.sourceSpan.end = endSourceSpan !== null ? endSourceSpan.end : node.sourceSpan.end;\n        this._containerStack.splice(stackIndex, this._containerStack.length - stackIndex);\n        return !unexpectedCloseTagDetected;\n      }\n      if (node instanceof Block || !this._getTagDefinition(node)?.closedByParent) {\n        unexpectedCloseTagDetected = true;\n      }\n    }\n    return false;\n  }\n  _consumeAttr(attrName) {\n    const fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n    let attrEnd = attrName.sourceSpan.end;\n    if (this._peek.type === 15) {\n      this._advance();\n    }\n    let value = '';\n    const valueTokens = [];\n    let valueStartSpan = undefined;\n    let valueEnd = undefined;\n    const nextTokenType = this._peek.type;\n    if (nextTokenType === 16) {\n      valueStartSpan = this._peek.sourceSpan;\n      valueEnd = this._peek.sourceSpan.end;\n      while (this._peek.type === 16 || this._peek.type === 17 || this._peek.type === 9) {\n        const valueToken = this._advance();\n        valueTokens.push(valueToken);\n        if (valueToken.type === 17) {\n          value += valueToken.parts.join('').replace(/&([^;]+);/g, decodeEntity);\n        } else if (valueToken.type === 9) {\n          value += valueToken.parts[0];\n        } else {\n          value += valueToken.parts.join('');\n        }\n        valueEnd = attrEnd = valueToken.sourceSpan.end;\n      }\n    }\n    if (this._peek.type === 15) {\n      const quoteToken = this._advance();\n      attrEnd = quoteToken.sourceSpan.end;\n    }\n    const valueSpan = valueStartSpan && valueEnd && new ParseSourceSpan(valueStartSpan.start, valueEnd, valueStartSpan.fullStart);\n    return new Attribute(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, attrEnd, attrName.sourceSpan.fullStart), attrName.sourceSpan, valueSpan, valueTokens.length > 0 ? valueTokens : undefined, undefined);\n  }\n  _consumeDirective(nameToken) {\n    const attributes = [];\n    let startSourceSpanEnd = nameToken.sourceSpan.end;\n    let endSourceSpan = null;\n    this._advance();\n    if (this._peek.type === 39) {\n      startSourceSpanEnd = this._peek.sourceSpan.end;\n      this._advance();\n      while (this._peek.type === 14) {\n        attributes.push(this._consumeAttr(this._advance()));\n      }\n      if (this._peek.type === 40) {\n        endSourceSpan = this._peek.sourceSpan;\n        this._advance();\n      } else {\n        this.errors.push(TreeError.create(null, nameToken.sourceSpan, 'Unterminated directive definition'));\n      }\n    }\n    const startSourceSpan = new ParseSourceSpan(nameToken.sourceSpan.start, startSourceSpanEnd, nameToken.sourceSpan.fullStart);\n    const sourceSpan = new ParseSourceSpan(startSourceSpan.start, endSourceSpan === null ? nameToken.sourceSpan.end : endSourceSpan.end, startSourceSpan.fullStart);\n    return new Directive(nameToken.parts[0], attributes, sourceSpan, startSourceSpan, endSourceSpan);\n  }\n  _consumeBlockOpen(token) {\n    const parameters = [];\n    while (this._peek.type === 27) {\n      const paramToken = this._advance();\n      parameters.push(new BlockParameter(paramToken.parts[0], paramToken.sourceSpan));\n    }\n    if (this._peek.type === 25) {\n      this._advance();\n    }\n    const end = this._peek.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);\n    const startSpan = new ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);\n    const block = new Block(token.parts[0], parameters, [], span, token.sourceSpan, startSpan);\n    this._pushContainer(block, false);\n  }\n  _consumeBlockClose(token) {\n    if (!this._popContainer(null, Block, token.sourceSpan)) {\n      this.errors.push(TreeError.create(null, token.sourceSpan, `Unexpected closing block. The block may have been closed earlier. ` + `If you meant to write the } character, you should use the \"&#125;\" ` + `HTML entity instead.`));\n    }\n  }\n  _consumeIncompleteBlock(token) {\n    const parameters = [];\n    while (this._peek.type === 27) {\n      const paramToken = this._advance();\n      parameters.push(new BlockParameter(paramToken.parts[0], paramToken.sourceSpan));\n    }\n    const end = this._peek.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);\n    const startSpan = new ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);\n    const block = new Block(token.parts[0], parameters, [], span, token.sourceSpan, startSpan);\n    this._pushContainer(block, false);\n    this._popContainer(null, Block, null);\n    this.errors.push(TreeError.create(token.parts[0], span, `Incomplete block \"${token.parts[0]}\". If you meant to write the @ character, ` + `you should use the \"&#64;\" HTML entity instead.`));\n  }\n  _consumeLet(startToken) {\n    const name = startToken.parts[0];\n    let valueToken;\n    let endToken;\n    if (this._peek.type !== 30) {\n      this.errors.push(TreeError.create(startToken.parts[0], startToken.sourceSpan, `Invalid @let declaration \"${name}\". Declaration must have a value.`));\n      return;\n    } else {\n      valueToken = this._advance();\n    }\n    if (this._peek.type !== 31) {\n      this.errors.push(TreeError.create(startToken.parts[0], startToken.sourceSpan, `Unterminated @let declaration \"${name}\". Declaration must be terminated with a semicolon.`));\n      return;\n    } else {\n      endToken = this._advance();\n    }\n    const end = endToken.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(startToken.sourceSpan.start, end, startToken.sourceSpan.fullStart);\n    const startOffset = startToken.sourceSpan.toString().lastIndexOf(name);\n    const nameStart = startToken.sourceSpan.start.moveBy(startOffset);\n    const nameSpan = new ParseSourceSpan(nameStart, startToken.sourceSpan.end);\n    const node = new LetDeclaration(name, valueToken.parts[0], span, nameSpan, valueToken.sourceSpan);\n    this._addToParent(node);\n  }\n  _consumeIncompleteLet(token) {\n    const name = token.parts[0] ?? '';\n    const nameString = name ? ` \"${name}\"` : '';\n    if (name.length > 0) {\n      const startOffset = token.sourceSpan.toString().lastIndexOf(name);\n      const nameStart = token.sourceSpan.start.moveBy(startOffset);\n      const nameSpan = new ParseSourceSpan(nameStart, token.sourceSpan.end);\n      const valueSpan = new ParseSourceSpan(token.sourceSpan.start, token.sourceSpan.start.moveBy(0));\n      const node = new LetDeclaration(name, '', token.sourceSpan, nameSpan, valueSpan);\n      this._addToParent(node);\n    }\n    this.errors.push(TreeError.create(token.parts[0], token.sourceSpan, `Incomplete @let declaration${nameString}. ` + `@let declarations must be written as \\`@let <name> = <value>;\\``));\n  }\n  _getContainer() {\n    return this._containerStack.length > 0 ? this._containerStack[this._containerStack.length - 1] : null;\n  }\n  _getClosestElementLikeParent() {\n    for (let i = this._containerStack.length - 1; i > -1; i--) {\n      const current = this._containerStack[i];\n      if (current instanceof Element || current instanceof Component) {\n        return current;\n      }\n    }\n    return null;\n  }\n  _addToParent(node) {\n    const parent = this._getContainer();\n    if (parent === null) {\n      this.rootNodes.push(node);\n    } else {\n      parent.children.push(node);\n    }\n  }\n  _getElementFullName(token, parent) {\n    const prefix = this._getPrefix(token, parent);\n    return mergeNsAndName(prefix, token.parts[1]);\n  }\n  _getComponentFullName(token, parent) {\n    const componentName = token.parts[0];\n    const tagName = this._getComponentTagName(token, parent);\n    if (tagName === null) {\n      return componentName;\n    }\n    return tagName.startsWith(':') ? componentName + tagName : `${componentName}:${tagName}`;\n  }\n  _getComponentTagName(token, parent) {\n    const prefix = this._getPrefix(token, parent);\n    const tagName = token.parts[2];\n    if (!prefix && !tagName) {\n      return null;\n    } else if (!prefix && tagName) {\n      return tagName;\n    } else {\n      return mergeNsAndName(prefix, tagName || 'ng-component');\n    }\n  }\n  _getPrefix(token, parent) {\n    let prefix;\n    let tagName;\n    if (token.type === 33 || token.type === 37 || token.type === 36) {\n      prefix = token.parts[1];\n      tagName = token.parts[2];\n    } else {\n      prefix = token.parts[0];\n      tagName = token.parts[1];\n    }\n    prefix = prefix || this._getTagDefinition(tagName)?.implicitNamespacePrefix || '';\n    if (!prefix && parent) {\n      const parentName = parent instanceof Element ? parent.name : parent.tagName;\n      if (parentName !== null) {\n        const parentTagName = splitNsName(parentName)[1];\n        const parentTagDefinition = this._getTagDefinition(parentTagName);\n        if (parentTagDefinition !== null && !parentTagDefinition.preventNamespaceInheritance) {\n          prefix = getNsPrefix(parentName);\n        }\n      }\n    }\n    return prefix;\n  }\n}\nfunction lastOnStack(stack, element) {\n  return stack.length > 0 && stack[stack.length - 1] === element;\n}\nfunction decodeEntity(match, entity) {\n  if (NAMED_ENTITIES[entity] !== undefined) {\n    return NAMED_ENTITIES[entity] || match;\n  }\n  if (/^#x[a-f0-9]+$/i.test(entity)) {\n    return String.fromCodePoint(parseInt(entity.slice(2), 16));\n  }\n  if (/^#\\d+$/.test(entity)) {\n    return String.fromCodePoint(parseInt(entity.slice(1), 10));\n  }\n  return match;\n}\n\nconst PRESERVE_WS_ATTR_NAME = 'ngPreserveWhitespaces';\nconst SKIP_WS_TRIM_TAGS = new Set(['pre', 'template', 'textarea', 'script', 'style']);\nconst WS_CHARS = ' \\f\\n\\r\\t\\v\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff';\nconst NO_WS_REGEXP = new RegExp(`[^${WS_CHARS}]`);\nconst WS_REPLACE_REGEXP = new RegExp(`[${WS_CHARS}]{2,}`, 'g');\nfunction hasPreserveWhitespacesAttr(attrs) {\n  return attrs.some(attr => attr.name === PRESERVE_WS_ATTR_NAME);\n}\nfunction replaceNgsp(value) {\n  return value.replace(new RegExp(NGSP_UNICODE, 'g'), ' ');\n}\nclass WhitespaceVisitor {\n  preserveSignificantWhitespace;\n  originalNodeMap;\n  requireContext;\n  icuExpansionDepth = 0;\n  constructor(preserveSignificantWhitespace, originalNodeMap, requireContext = true) {\n    this.preserveSignificantWhitespace = preserveSignificantWhitespace;\n    this.originalNodeMap = originalNodeMap;\n    this.requireContext = requireContext;\n  }\n  visitElement(element, context) {\n    if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {\n      const newElement = new Element(element.name, visitAllWithSiblings(this, element.attrs), visitAllWithSiblings(this, element.directives), element.children, element.isSelfClosing, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.isVoid, element.i18n);\n      this.originalNodeMap?.set(newElement, element);\n      return newElement;\n    }\n    const newElement = new Element(element.name, element.attrs, element.directives, visitAllWithSiblings(this, element.children), element.isSelfClosing, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.isVoid, element.i18n);\n    this.originalNodeMap?.set(newElement, element);\n    return newElement;\n  }\n  visitAttribute(attribute, context) {\n    return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;\n  }\n  visitText(text, context) {\n    const isNotBlank = text.value.match(NO_WS_REGEXP);\n    const hasExpansionSibling = context && (context.prev instanceof Expansion || context.next instanceof Expansion);\n    const inIcuExpansion = this.icuExpansionDepth > 0;\n    if (inIcuExpansion && this.preserveSignificantWhitespace) return text;\n    if (isNotBlank || hasExpansionSibling) {\n      const tokens = text.tokens.map(token => token.type === 5 ? createWhitespaceProcessedTextToken(token) : token);\n      if (!this.preserveSignificantWhitespace && tokens.length > 0) {\n        const firstToken = tokens[0];\n        tokens.splice(0, 1, trimLeadingWhitespace(firstToken, context));\n        const lastToken = tokens[tokens.length - 1];\n        tokens.splice(tokens.length - 1, 1, trimTrailingWhitespace(lastToken, context));\n      }\n      const processed = processWhitespace(text.value);\n      const value = this.preserveSignificantWhitespace ? processed : trimLeadingAndTrailingWhitespace(processed, context);\n      const result = new Text(value, text.sourceSpan, tokens, text.i18n);\n      this.originalNodeMap?.set(result, text);\n      return result;\n    }\n    return null;\n  }\n  visitComment(comment, context) {\n    return comment;\n  }\n  visitExpansion(expansion, context) {\n    this.icuExpansionDepth++;\n    let newExpansion;\n    try {\n      newExpansion = new Expansion(expansion.switchValue, expansion.type, visitAllWithSiblings(this, expansion.cases), expansion.sourceSpan, expansion.switchValueSourceSpan, expansion.i18n);\n    } finally {\n      this.icuExpansionDepth--;\n    }\n    this.originalNodeMap?.set(newExpansion, expansion);\n    return newExpansion;\n  }\n  visitExpansionCase(expansionCase, context) {\n    const newExpansionCase = new ExpansionCase(expansionCase.value, visitAllWithSiblings(this, expansionCase.expression), expansionCase.sourceSpan, expansionCase.valueSourceSpan, expansionCase.expSourceSpan);\n    this.originalNodeMap?.set(newExpansionCase, expansionCase);\n    return newExpansionCase;\n  }\n  visitBlock(block, context) {\n    const newBlock = new Block(block.name, block.parameters, visitAllWithSiblings(this, block.children), block.sourceSpan, block.nameSpan, block.startSourceSpan, block.endSourceSpan);\n    this.originalNodeMap?.set(newBlock, block);\n    return newBlock;\n  }\n  visitBlockParameter(parameter, context) {\n    return parameter;\n  }\n  visitLetDeclaration(decl, context) {\n    return decl;\n  }\n  visitComponent(node, context) {\n    if (node.tagName && SKIP_WS_TRIM_TAGS.has(node.tagName) || hasPreserveWhitespacesAttr(node.attrs)) {\n      const newElement = new Component(node.componentName, node.tagName, node.fullName, visitAllWithSiblings(this, node.attrs), visitAllWithSiblings(this, node.directives), node.children, node.isSelfClosing, node.sourceSpan, node.startSourceSpan, node.endSourceSpan, node.i18n);\n      this.originalNodeMap?.set(newElement, node);\n      return newElement;\n    }\n    const newElement = new Component(node.componentName, node.tagName, node.fullName, node.attrs, node.directives, visitAllWithSiblings(this, node.children), node.isSelfClosing, node.sourceSpan, node.startSourceSpan, node.endSourceSpan, node.i18n);\n    this.originalNodeMap?.set(newElement, node);\n    return newElement;\n  }\n  visitDirective(directive, context) {\n    return directive;\n  }\n  visit(_node, context) {\n    if (this.requireContext && !context) {\n      throw new Error(`WhitespaceVisitor requires context. Visit via \\`visitAllWithSiblings\\` to get this context.`);\n    }\n    return false;\n  }\n}\nfunction trimLeadingWhitespace(token, context) {\n  if (token.type !== 5) return token;\n  const isFirstTokenInTag = !context?.prev;\n  if (!isFirstTokenInTag) return token;\n  return transformTextToken(token, text => text.trimStart());\n}\nfunction trimTrailingWhitespace(token, context) {\n  if (token.type !== 5) return token;\n  const isLastTokenInTag = !context?.next;\n  if (!isLastTokenInTag) return token;\n  return transformTextToken(token, text => text.trimEnd());\n}\nfunction trimLeadingAndTrailingWhitespace(text, context) {\n  const isFirstTokenInTag = !context?.prev;\n  const isLastTokenInTag = !context?.next;\n  const maybeTrimmedStart = isFirstTokenInTag ? text.trimStart() : text;\n  const maybeTrimmed = isLastTokenInTag ? maybeTrimmedStart.trimEnd() : maybeTrimmedStart;\n  return maybeTrimmed;\n}\nfunction createWhitespaceProcessedTextToken({\n  type,\n  parts,\n  sourceSpan\n}) {\n  return {\n    type,\n    parts: [processWhitespace(parts[0])],\n    sourceSpan\n  };\n}\nfunction transformTextToken({\n  type,\n  parts,\n  sourceSpan\n}, transform) {\n  return {\n    type,\n    parts: [transform(parts[0])],\n    sourceSpan\n  };\n}\nfunction processWhitespace(text) {\n  return replaceNgsp(text).replace(WS_REPLACE_REGEXP, ' ');\n}\nfunction visitAllWithSiblings(visitor, nodes) {\n  const result = [];\n  nodes.forEach((ast, i) => {\n    const context = {\n      prev: nodes[i - 1],\n      next: nodes[i + 1]\n    };\n    const astResult = ast.visit(visitor, context);\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\n\nvar TokenType;\n(function (TokenType) {\n  TokenType[TokenType[\"Character\"] = 0] = \"Character\";\n  TokenType[TokenType[\"Identifier\"] = 1] = \"Identifier\";\n  TokenType[TokenType[\"PrivateIdentifier\"] = 2] = \"PrivateIdentifier\";\n  TokenType[TokenType[\"Keyword\"] = 3] = \"Keyword\";\n  TokenType[TokenType[\"String\"] = 4] = \"String\";\n  TokenType[TokenType[\"Operator\"] = 5] = \"Operator\";\n  TokenType[TokenType[\"Number\"] = 6] = \"Number\";\n  TokenType[TokenType[\"RegExpBody\"] = 7] = \"RegExpBody\";\n  TokenType[TokenType[\"RegExpFlags\"] = 8] = \"RegExpFlags\";\n  TokenType[TokenType[\"Error\"] = 9] = \"Error\";\n})(TokenType || (TokenType = {}));\nvar StringTokenKind;\n(function (StringTokenKind) {\n  StringTokenKind[StringTokenKind[\"Plain\"] = 0] = \"Plain\";\n  StringTokenKind[StringTokenKind[\"TemplateLiteralPart\"] = 1] = \"TemplateLiteralPart\";\n  StringTokenKind[StringTokenKind[\"TemplateLiteralEnd\"] = 2] = \"TemplateLiteralEnd\";\n})(StringTokenKind || (StringTokenKind = {}));\nconst KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this', 'typeof', 'void', 'in'];\nclass Lexer {\n  tokenize(text) {\n    return new _Scanner(text).scan();\n  }\n}\nclass Token {\n  index;\n  end;\n  type;\n  numValue;\n  strValue;\n  constructor(index, end, type, numValue, strValue) {\n    this.index = index;\n    this.end = end;\n    this.type = type;\n    this.numValue = numValue;\n    this.strValue = strValue;\n  }\n  isCharacter(code) {\n    return this.type === TokenType.Character && this.numValue === code;\n  }\n  isNumber() {\n    return this.type === TokenType.Number;\n  }\n  isString() {\n    return this.type === TokenType.String;\n  }\n  isOperator(operator) {\n    return this.type === TokenType.Operator && this.strValue === operator;\n  }\n  isIdentifier() {\n    return this.type === TokenType.Identifier;\n  }\n  isPrivateIdentifier() {\n    return this.type === TokenType.PrivateIdentifier;\n  }\n  isKeyword() {\n    return this.type === TokenType.Keyword;\n  }\n  isKeywordLet() {\n    return this.type === TokenType.Keyword && this.strValue === 'let';\n  }\n  isKeywordAs() {\n    return this.type === TokenType.Keyword && this.strValue === 'as';\n  }\n  isKeywordNull() {\n    return this.type === TokenType.Keyword && this.strValue === 'null';\n  }\n  isKeywordUndefined() {\n    return this.type === TokenType.Keyword && this.strValue === 'undefined';\n  }\n  isKeywordTrue() {\n    return this.type === TokenType.Keyword && this.strValue === 'true';\n  }\n  isKeywordFalse() {\n    return this.type === TokenType.Keyword && this.strValue === 'false';\n  }\n  isKeywordThis() {\n    return this.type === TokenType.Keyword && this.strValue === 'this';\n  }\n  isKeywordTypeof() {\n    return this.type === TokenType.Keyword && this.strValue === 'typeof';\n  }\n  isKeywordVoid() {\n    return this.type === TokenType.Keyword && this.strValue === 'void';\n  }\n  isKeywordIn() {\n    return this.type === TokenType.Keyword && this.strValue === 'in';\n  }\n  isError() {\n    return this.type === TokenType.Error;\n  }\n  isRegExpBody() {\n    return this.type === TokenType.RegExpBody;\n  }\n  isRegExpFlags() {\n    return this.type === TokenType.RegExpFlags;\n  }\n  toNumber() {\n    return this.type === TokenType.Number ? this.numValue : -1;\n  }\n  isTemplateLiteralPart() {\n    return this.isString() && this.kind === StringTokenKind.TemplateLiteralPart;\n  }\n  isTemplateLiteralEnd() {\n    return this.isString() && this.kind === StringTokenKind.TemplateLiteralEnd;\n  }\n  isTemplateLiteralInterpolationStart() {\n    return this.isOperator('${');\n  }\n  toString() {\n    switch (this.type) {\n      case TokenType.Character:\n      case TokenType.Identifier:\n      case TokenType.Keyword:\n      case TokenType.Operator:\n      case TokenType.PrivateIdentifier:\n      case TokenType.String:\n      case TokenType.Error:\n      case TokenType.RegExpBody:\n      case TokenType.RegExpFlags:\n        return this.strValue;\n      case TokenType.Number:\n        return this.numValue.toString();\n      default:\n        return null;\n    }\n  }\n}\nclass StringToken extends Token {\n  kind;\n  constructor(index, end, strValue, kind) {\n    super(index, end, TokenType.String, 0, strValue);\n    this.kind = kind;\n  }\n}\nfunction newCharacterToken(index, end, code) {\n  return new Token(index, end, TokenType.Character, code, String.fromCharCode(code));\n}\nfunction newIdentifierToken(index, end, text) {\n  return new Token(index, end, TokenType.Identifier, 0, text);\n}\nfunction newPrivateIdentifierToken(index, end, text) {\n  return new Token(index, end, TokenType.PrivateIdentifier, 0, text);\n}\nfunction newKeywordToken(index, end, text) {\n  return new Token(index, end, TokenType.Keyword, 0, text);\n}\nfunction newOperatorToken(index, end, text) {\n  return new Token(index, end, TokenType.Operator, 0, text);\n}\nfunction newNumberToken(index, end, n) {\n  return new Token(index, end, TokenType.Number, n, '');\n}\nfunction newErrorToken(index, end, message) {\n  return new Token(index, end, TokenType.Error, 0, message);\n}\nfunction newRegExpBodyToken(index, end, text) {\n  return new Token(index, end, TokenType.RegExpBody, 0, text);\n}\nfunction newRegExpFlagsToken(index, end, text) {\n  return new Token(index, end, TokenType.RegExpFlags, 0, text);\n}\nconst EOF = new Token(-1, -1, TokenType.Character, 0, '');\nclass _Scanner {\n  input;\n  tokens = [];\n  length;\n  peek = 0;\n  index = -1;\n  braceStack = [];\n  constructor(input) {\n    this.input = input;\n    this.length = input.length;\n    this.advance();\n  }\n  scan() {\n    let token = this.scanToken();\n    while (token !== null) {\n      this.tokens.push(token);\n      token = this.scanToken();\n    }\n    return this.tokens;\n  }\n  advance() {\n    this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);\n  }\n  scanToken() {\n    const input = this.input;\n    const length = this.length;\n    let peek = this.peek;\n    let index = this.index;\n    while (peek <= $SPACE) {\n      if (++index >= length) {\n        peek = $EOF;\n        break;\n      } else {\n        peek = input.charCodeAt(index);\n      }\n    }\n    this.peek = peek;\n    this.index = index;\n    if (index >= length) {\n      return null;\n    }\n    if (isIdentifierStart(peek)) {\n      return this.scanIdentifier();\n    }\n    if (isDigit(peek)) {\n      return this.scanNumber(index);\n    }\n    const start = index;\n    switch (peek) {\n      case $PERIOD:\n        this.advance();\n        return isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, this.index, $PERIOD);\n      case $LPAREN:\n      case $RPAREN:\n      case $LBRACKET:\n      case $RBRACKET:\n      case $COMMA:\n      case $COLON:\n      case $SEMICOLON:\n        return this.scanCharacter(start, peek);\n      case $LBRACE:\n        return this.scanOpenBrace(start, peek);\n      case $RBRACE:\n        return this.scanCloseBrace(start, peek);\n      case $SQ:\n      case $DQ:\n        return this.scanString();\n      case $BT:\n        this.advance();\n        return this.scanTemplateLiteralPart(start);\n      case $HASH:\n        return this.scanPrivateIdentifier();\n      case $PLUS:\n        return this.scanComplexOperator(start, '+', $EQ, '=');\n      case $MINUS:\n        return this.scanComplexOperator(start, '-', $EQ, '=');\n      case $SLASH:\n        return this.isStartOfRegex() ? this.scanRegex(index) : this.scanComplexOperator(start, '/', $EQ, '=');\n      case $PERCENT:\n        return this.scanComplexOperator(start, '%', $EQ, '=');\n      case $CARET:\n        return this.scanOperator(start, '^');\n      case $STAR:\n        return this.scanStar(start);\n      case $QUESTION:\n        return this.scanQuestion(start);\n      case $LT:\n      case $GT:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');\n      case $BANG:\n      case $EQ:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');\n      case $AMPERSAND:\n        return this.scanComplexOperator(start, '&', $AMPERSAND, '&', $EQ, '=');\n      case $BAR:\n        return this.scanComplexOperator(start, '|', $BAR, '|', $EQ, '=');\n      case $NBSP:\n        while (isWhitespace(this.peek)) this.advance();\n        return this.scanToken();\n    }\n    this.advance();\n    return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n  }\n  scanCharacter(start, code) {\n    this.advance();\n    return newCharacterToken(start, this.index, code);\n  }\n  scanOperator(start, str) {\n    this.advance();\n    return newOperatorToken(start, this.index, str);\n  }\n  scanOpenBrace(start, code) {\n    this.braceStack.push('expression');\n    this.advance();\n    return newCharacterToken(start, this.index, code);\n  }\n  scanCloseBrace(start, code) {\n    this.advance();\n    const currentBrace = this.braceStack.pop();\n    if (currentBrace === 'interpolation') {\n      this.tokens.push(newCharacterToken(start, this.index, $RBRACE));\n      return this.scanTemplateLiteralPart(this.index);\n    }\n    return newCharacterToken(start, this.index, code);\n  }\n  scanComplexOperator(start, one, twoCode, two, threeCode, three) {\n    this.advance();\n    let str = one;\n    if (this.peek == twoCode) {\n      this.advance();\n      str += two;\n    }\n    if (threeCode != null && this.peek == threeCode) {\n      this.advance();\n      str += three;\n    }\n    return newOperatorToken(start, this.index, str);\n  }\n  scanIdentifier() {\n    const start = this.index;\n    this.advance();\n    while (isIdentifierPart(this.peek)) this.advance();\n    const str = this.input.substring(start, this.index);\n    return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, this.index, str) : newIdentifierToken(start, this.index, str);\n  }\n  scanPrivateIdentifier() {\n    const start = this.index;\n    this.advance();\n    if (!isIdentifierStart(this.peek)) {\n      return this.error('Invalid character [#]', -1);\n    }\n    while (isIdentifierPart(this.peek)) this.advance();\n    const identifierName = this.input.substring(start, this.index);\n    return newPrivateIdentifierToken(start, this.index, identifierName);\n  }\n  scanNumber(start) {\n    let simple = this.index === start;\n    let hasSeparators = false;\n    this.advance();\n    while (true) {\n      if (isDigit(this.peek)) ; else if (this.peek === $_) {\n        if (!isDigit(this.input.charCodeAt(this.index - 1)) || !isDigit(this.input.charCodeAt(this.index + 1))) {\n          return this.error('Invalid numeric separator', 0);\n        }\n        hasSeparators = true;\n      } else if (this.peek === $PERIOD) {\n        simple = false;\n      } else if (isExponentStart(this.peek)) {\n        this.advance();\n        if (isExponentSign(this.peek)) this.advance();\n        if (!isDigit(this.peek)) return this.error('Invalid exponent', -1);\n        simple = false;\n      } else {\n        break;\n      }\n      this.advance();\n    }\n    let str = this.input.substring(start, this.index);\n    if (hasSeparators) {\n      str = str.replace(/_/g, '');\n    }\n    const value = simple ? parseIntAutoRadix(str) : parseFloat(str);\n    return newNumberToken(start, this.index, value);\n  }\n  scanString() {\n    const start = this.index;\n    const quote = this.peek;\n    this.advance();\n    let buffer = '';\n    let marker = this.index;\n    const input = this.input;\n    while (this.peek != quote) {\n      if (this.peek == $BACKSLASH) {\n        const result = this.scanStringBackslash(buffer, marker);\n        if (typeof result !== 'string') {\n          return result;\n        }\n        buffer = result;\n        marker = this.index;\n      } else if (this.peek == $EOF) {\n        return this.error('Unterminated quote', 0);\n      } else {\n        this.advance();\n      }\n    }\n    const last = input.substring(marker, this.index);\n    this.advance();\n    return new StringToken(start, this.index, buffer + last, StringTokenKind.Plain);\n  }\n  scanQuestion(start) {\n    this.advance();\n    let operator = '?';\n    if (this.peek === $QUESTION) {\n      operator += '?';\n      this.advance();\n      if (this.peek === $EQ) {\n        operator += '=';\n        this.advance();\n      }\n    } else if (this.peek === $PERIOD) {\n      operator += '.';\n      this.advance();\n    }\n    return newOperatorToken(start, this.index, operator);\n  }\n  scanTemplateLiteralPart(start) {\n    let buffer = '';\n    let marker = this.index;\n    while (this.peek !== $BT) {\n      if (this.peek === $BACKSLASH) {\n        const result = this.scanStringBackslash(buffer, marker);\n        if (typeof result !== 'string') {\n          return result;\n        }\n        buffer = result;\n        marker = this.index;\n      } else if (this.peek === $$) {\n        const dollar = this.index;\n        this.advance();\n        if (this.peek === $LBRACE) {\n          this.braceStack.push('interpolation');\n          this.tokens.push(new StringToken(start, dollar, buffer + this.input.substring(marker, dollar), StringTokenKind.TemplateLiteralPart));\n          this.advance();\n          return newOperatorToken(dollar, this.index, this.input.substring(dollar, this.index));\n        }\n      } else if (this.peek === $EOF) {\n        return this.error('Unterminated template literal', 0);\n      } else {\n        this.advance();\n      }\n    }\n    const last = this.input.substring(marker, this.index);\n    this.advance();\n    return new StringToken(start, this.index, buffer + last, StringTokenKind.TemplateLiteralEnd);\n  }\n  error(message, offset) {\n    const position = this.index + offset;\n    return newErrorToken(position, this.index, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n  }\n  scanStringBackslash(buffer, marker) {\n    buffer += this.input.substring(marker, this.index);\n    let unescapedCode;\n    this.advance();\n    if (this.peek === $u) {\n      const hex = this.input.substring(this.index + 1, this.index + 5);\n      if (/^[0-9a-f]+$/i.test(hex)) {\n        unescapedCode = parseInt(hex, 16);\n      } else {\n        return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n      }\n      for (let i = 0; i < 5; i++) {\n        this.advance();\n      }\n    } else {\n      unescapedCode = unescape(this.peek);\n      this.advance();\n    }\n    buffer += String.fromCharCode(unescapedCode);\n    return buffer;\n  }\n  scanStar(start) {\n    this.advance();\n    let operator = '*';\n    if (this.peek === $STAR) {\n      operator += '*';\n      this.advance();\n      if (this.peek === $EQ) {\n        operator += '=';\n        this.advance();\n      }\n    } else if (this.peek === $EQ) {\n      operator += '=';\n      this.advance();\n    }\n    return newOperatorToken(start, this.index, operator);\n  }\n  isStartOfRegex() {\n    if (this.tokens.length === 0) {\n      return true;\n    }\n    const prevToken = this.tokens[this.tokens.length - 1];\n    if (prevToken.isOperator('!')) {\n      const beforePrevToken = this.tokens.length > 1 ? this.tokens[this.tokens.length - 2] : null;\n      const isNegation = beforePrevToken === null || beforePrevToken.type !== TokenType.Identifier && !beforePrevToken.isCharacter($RPAREN) && !beforePrevToken.isCharacter($RBRACKET);\n      return isNegation;\n    }\n    return prevToken.type === TokenType.Operator || prevToken.isCharacter($LPAREN) || prevToken.isCharacter($LBRACKET) || prevToken.isCharacter($COMMA) || prevToken.isCharacter($COLON);\n  }\n  scanRegex(tokenStart) {\n    this.advance();\n    const textStart = this.index;\n    let inEscape = false;\n    let inCharacterClass = false;\n    while (true) {\n      const peek = this.peek;\n      if (peek === $EOF) {\n        return this.error('Unterminated regular expression', 0);\n      }\n      if (inEscape) {\n        inEscape = false;\n      } else if (peek === $BACKSLASH) {\n        inEscape = true;\n      } else if (peek === $LBRACKET) {\n        inCharacterClass = true;\n      } else if (peek === $RBRACKET) {\n        inCharacterClass = false;\n      } else if (peek === $SLASH && !inCharacterClass) {\n        break;\n      }\n      this.advance();\n    }\n    const value = this.input.substring(textStart, this.index);\n    this.advance();\n    const bodyToken = newRegExpBodyToken(tokenStart, this.index, value);\n    const flagsToken = this.scanRegexFlags(this.index);\n    if (flagsToken !== null) {\n      this.tokens.push(bodyToken);\n      return flagsToken;\n    }\n    return bodyToken;\n  }\n  scanRegexFlags(start) {\n    if (!isAsciiLetter(this.peek)) {\n      return null;\n    }\n    while (isAsciiLetter(this.peek)) {\n      this.advance();\n    }\n    return newRegExpFlagsToken(start, this.index, this.input.substring(start, this.index));\n  }\n}\nfunction isIdentifierStart(code) {\n  return $a <= code && code <= $z || $A <= code && code <= $Z || code == $_ || code == $$;\n}\nfunction isIdentifierPart(code) {\n  return isAsciiLetter(code) || isDigit(code) || code == $_ || code == $$;\n}\nfunction isExponentStart(code) {\n  return code == $e || code == $E;\n}\nfunction isExponentSign(code) {\n  return code == $MINUS || code == $PLUS;\n}\nfunction unescape(code) {\n  switch (code) {\n    case $n:\n      return $LF;\n    case $f:\n      return $FF;\n    case $r:\n      return $CR;\n    case $t:\n      return $TAB;\n    case $v:\n      return $VTAB;\n    default:\n      return code;\n  }\n}\nfunction parseIntAutoRadix(text) {\n  const result = parseInt(text);\n  if (isNaN(result)) {\n    throw new Error('Invalid integer literal when parsing ' + text);\n  }\n  return result;\n}\n\nclass SplitInterpolation {\n  strings;\n  expressions;\n  offsets;\n  constructor(strings, expressions, offsets) {\n    this.strings = strings;\n    this.expressions = expressions;\n    this.offsets = offsets;\n  }\n}\nclass TemplateBindingParseResult {\n  templateBindings;\n  warnings;\n  errors;\n  constructor(templateBindings, warnings, errors) {\n    this.templateBindings = templateBindings;\n    this.warnings = warnings;\n    this.errors = errors;\n  }\n}\nfunction getLocation(span) {\n  return span.start.toString() || '(unknown)';\n}\nclass Parser {\n  _lexer;\n  _supportsDirectPipeReferences;\n  constructor(_lexer, _supportsDirectPipeReferences = false) {\n    this._lexer = _lexer;\n    this._supportsDirectPipeReferences = _supportsDirectPipeReferences;\n  }\n  parseAction(input, parseSourceSpan, absoluteOffset) {\n    const errors = [];\n    this._checkNoInterpolation(errors, input, parseSourceSpan);\n    const {\n      stripped: sourceToLex\n    } = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    const ast = new _ParseAST(input, parseSourceSpan, absoluteOffset, tokens, 1, errors, 0, this._supportsDirectPipeReferences).parseChain();\n    return new ASTWithSource(ast, input, getLocation(parseSourceSpan), absoluteOffset, errors);\n  }\n  parseBinding(input, parseSourceSpan, absoluteOffset) {\n    const errors = [];\n    const ast = this._parseBindingAst(input, parseSourceSpan, absoluteOffset, errors);\n    return new ASTWithSource(ast, input, getLocation(parseSourceSpan), absoluteOffset, errors);\n  }\n  checkSimpleExpression(ast) {\n    const checker = new SimpleExpressionChecker();\n    ast.visit(checker);\n    return checker.errors;\n  }\n  parseSimpleBinding(input, parseSourceSpan, absoluteOffset) {\n    const errors = [];\n    const ast = this._parseBindingAst(input, parseSourceSpan, absoluteOffset, errors);\n    const simplExpressionErrors = this.checkSimpleExpression(ast);\n    if (simplExpressionErrors.length > 0) {\n      errors.push(getParseError(`Host binding expression cannot contain ${simplExpressionErrors.join(' ')}`, input, '', parseSourceSpan));\n    }\n    return new ASTWithSource(ast, input, getLocation(parseSourceSpan), absoluteOffset, errors);\n  }\n  _parseBindingAst(input, parseSourceSpan, absoluteOffset, errors) {\n    this._checkNoInterpolation(errors, input, parseSourceSpan);\n    const {\n      stripped: sourceToLex\n    } = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    return new _ParseAST(input, parseSourceSpan, absoluteOffset, tokens, 0, errors, 0, this._supportsDirectPipeReferences).parseChain();\n  }\n  parseTemplateBindings(templateKey, templateValue, parseSourceSpan, absoluteKeyOffset, absoluteValueOffset) {\n    const tokens = this._lexer.tokenize(templateValue);\n    const errors = [];\n    const parser = new _ParseAST(templateValue, parseSourceSpan, absoluteValueOffset, tokens, 0, errors, 0, this._supportsDirectPipeReferences);\n    return parser.parseTemplateBindings({\n      source: templateKey,\n      span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length)\n    });\n  }\n  parseInterpolation(input, parseSourceSpan, absoluteOffset, interpolatedTokens) {\n    const errors = [];\n    const {\n      strings,\n      expressions,\n      offsets\n    } = this.splitInterpolation(input, parseSourceSpan, errors, interpolatedTokens);\n    if (expressions.length === 0) return null;\n    const expressionNodes = [];\n    for (let i = 0; i < expressions.length; ++i) {\n      const expressionSpan = interpolatedTokens?.[i * 2 + 1]?.sourceSpan;\n      const expressionText = expressions[i].text;\n      const {\n        stripped: sourceToLex,\n        hasComments\n      } = this._stripComments(expressionText);\n      const tokens = this._lexer.tokenize(sourceToLex);\n      if (hasComments && sourceToLex.trim().length === 0 && tokens.length === 0) {\n        errors.push(getParseError('Interpolation expression cannot only contain a comment', input, `at column ${expressions[i].start} in`, parseSourceSpan));\n        continue;\n      }\n      const ast = new _ParseAST(expressionSpan ? expressionText : input, expressionSpan || parseSourceSpan, absoluteOffset, tokens, 0, errors, offsets[i], this._supportsDirectPipeReferences).parseChain();\n      expressionNodes.push(ast);\n    }\n    return this.createInterpolationAst(strings.map(s => s.text), expressionNodes, input, getLocation(parseSourceSpan), absoluteOffset, errors);\n  }\n  parseInterpolationExpression(expression, parseSourceSpan, absoluteOffset) {\n    const {\n      stripped: sourceToLex\n    } = this._stripComments(expression);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    const errors = [];\n    const ast = new _ParseAST(expression, parseSourceSpan, absoluteOffset, tokens, 0, errors, 0, this._supportsDirectPipeReferences).parseChain();\n    const strings = ['', ''];\n    return this.createInterpolationAst(strings, [ast], expression, getLocation(parseSourceSpan), absoluteOffset, errors);\n  }\n  createInterpolationAst(strings, expressions, input, location, absoluteOffset, errors) {\n    const span = new ParseSpan(0, input.length);\n    const interpolation = new Interpolation$1(span, span.toAbsolute(absoluteOffset), strings, expressions);\n    return new ASTWithSource(interpolation, input, location, absoluteOffset, errors);\n  }\n  splitInterpolation(input, parseSourceSpan, errors, interpolatedTokens) {\n    const strings = [];\n    const expressions = [];\n    const offsets = [];\n    const inputToTemplateIndexMap = interpolatedTokens ? getIndexMapForOriginalTemplate(interpolatedTokens) : null;\n    let i = 0;\n    let atInterpolation = false;\n    let extendLastString = false;\n    const interpStart = '{{';\n    const interpEnd = '}}';\n    while (i < input.length) {\n      if (!atInterpolation) {\n        const start = i;\n        i = input.indexOf(interpStart, i);\n        if (i === -1) {\n          i = input.length;\n        }\n        const text = input.substring(start, i);\n        strings.push({\n          text,\n          start,\n          end: i\n        });\n        atInterpolation = true;\n      } else {\n        const fullStart = i;\n        const exprStart = fullStart + interpStart.length;\n        const exprEnd = this._getInterpolationEndIndex(input, interpEnd, exprStart);\n        if (exprEnd === -1) {\n          atInterpolation = false;\n          extendLastString = true;\n          break;\n        }\n        const fullEnd = exprEnd + interpEnd.length;\n        const text = input.substring(exprStart, exprEnd);\n        if (text.trim().length === 0) {\n          errors.push(getParseError('Blank expressions are not allowed in interpolated strings', input, `at column ${i} in`, parseSourceSpan));\n        }\n        expressions.push({\n          text,\n          start: fullStart,\n          end: fullEnd\n        });\n        const startInOriginalTemplate = inputToTemplateIndexMap?.get(fullStart) ?? fullStart;\n        const offset = startInOriginalTemplate + interpStart.length;\n        offsets.push(offset);\n        i = fullEnd;\n        atInterpolation = false;\n      }\n    }\n    if (!atInterpolation) {\n      if (extendLastString) {\n        const piece = strings[strings.length - 1];\n        piece.text += input.substring(i);\n        piece.end = input.length;\n      } else {\n        strings.push({\n          text: input.substring(i),\n          start: i,\n          end: input.length\n        });\n      }\n    }\n    return new SplitInterpolation(strings, expressions, offsets);\n  }\n  wrapLiteralPrimitive(input, sourceSpanOrLocation, absoluteOffset) {\n    const span = new ParseSpan(0, input == null ? 0 : input.length);\n    return new ASTWithSource(new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, typeof sourceSpanOrLocation === 'string' ? sourceSpanOrLocation : getLocation(sourceSpanOrLocation), absoluteOffset, []);\n  }\n  _stripComments(input) {\n    const i = this._commentStart(input);\n    return i != null ? {\n      stripped: input.substring(0, i),\n      hasComments: true\n    } : {\n      stripped: input,\n      hasComments: false\n    };\n  }\n  _commentStart(input) {\n    let outerQuote = null;\n    for (let i = 0; i < input.length - 1; i++) {\n      const char = input.charCodeAt(i);\n      const nextChar = input.charCodeAt(i + 1);\n      if (char === $SLASH && nextChar == $SLASH && outerQuote == null) return i;\n      if (outerQuote === char) {\n        outerQuote = null;\n      } else if (outerQuote == null && isQuote(char)) {\n        outerQuote = char;\n      }\n    }\n    return null;\n  }\n  _checkNoInterpolation(errors, input, parseSourceSpan) {\n    let startIndex = -1;\n    let endIndex = -1;\n    for (const charIndex of this._forEachUnquotedChar(input, 0)) {\n      if (startIndex === -1) {\n        if (input.startsWith('{{')) {\n          startIndex = charIndex;\n        }\n      } else {\n        endIndex = this._getInterpolationEndIndex(input, '}}', charIndex);\n        if (endIndex > -1) {\n          break;\n        }\n      }\n    }\n    if (startIndex > -1 && endIndex > -1) {\n      errors.push(getParseError(`Got interpolation ({{}}) where expression was expected`, input, `at column ${startIndex} in`, parseSourceSpan));\n    }\n  }\n  _getInterpolationEndIndex(input, expressionEnd, start) {\n    for (const charIndex of this._forEachUnquotedChar(input, start)) {\n      if (input.startsWith(expressionEnd, charIndex)) {\n        return charIndex;\n      }\n      if (input.startsWith('//', charIndex)) {\n        return input.indexOf(expressionEnd, charIndex);\n      }\n    }\n    return -1;\n  }\n  *_forEachUnquotedChar(input, start) {\n    let currentQuote = null;\n    let escapeCount = 0;\n    for (let i = start; i < input.length; i++) {\n      const char = input[i];\n      if (isQuote(input.charCodeAt(i)) && (currentQuote === null || currentQuote === char) && escapeCount % 2 === 0) {\n        currentQuote = currentQuote === null ? char : null;\n      } else if (currentQuote === null) {\n        yield i;\n      }\n      escapeCount = char === '\\\\' ? escapeCount + 1 : 0;\n    }\n  }\n}\nvar ParseContextFlags;\n(function (ParseContextFlags) {\n  ParseContextFlags[ParseContextFlags[\"None\"] = 0] = \"None\";\n  ParseContextFlags[ParseContextFlags[\"Writable\"] = 1] = \"Writable\";\n})(ParseContextFlags || (ParseContextFlags = {}));\nconst SUPPORTED_REGEX_FLAGS = new Set(['d', 'g', 'i', 'm', 's', 'u', 'v', 'y']);\nclass _ParseAST {\n  input;\n  parseSourceSpan;\n  absoluteOffset;\n  tokens;\n  parseFlags;\n  errors;\n  offset;\n  supportsDirectPipeReferences;\n  rparensExpected = 0;\n  rbracketsExpected = 0;\n  rbracesExpected = 0;\n  context = ParseContextFlags.None;\n  sourceSpanCache = new Map();\n  index = 0;\n  constructor(input, parseSourceSpan, absoluteOffset, tokens, parseFlags, errors, offset, supportsDirectPipeReferences) {\n    this.input = input;\n    this.parseSourceSpan = parseSourceSpan;\n    this.absoluteOffset = absoluteOffset;\n    this.tokens = tokens;\n    this.parseFlags = parseFlags;\n    this.errors = errors;\n    this.offset = offset;\n    this.supportsDirectPipeReferences = supportsDirectPipeReferences;\n  }\n  peek(offset) {\n    const i = this.index + offset;\n    return i < this.tokens.length ? this.tokens[i] : EOF;\n  }\n  get next() {\n    return this.peek(0);\n  }\n  get atEOF() {\n    return this.index >= this.tokens.length;\n  }\n  get inputIndex() {\n    return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;\n  }\n  get currentEndIndex() {\n    if (this.index > 0) {\n      const curToken = this.peek(-1);\n      return curToken.end + this.offset;\n    }\n    if (this.tokens.length === 0) {\n      return this.input.length + this.offset;\n    }\n    return this.next.index + this.offset;\n  }\n  get currentAbsoluteOffset() {\n    return this.absoluteOffset + this.inputIndex;\n  }\n  span(start, artificialEndIndex) {\n    let endIndex = this.currentEndIndex;\n    if (artificialEndIndex !== undefined && artificialEndIndex > this.currentEndIndex) {\n      endIndex = artificialEndIndex;\n    }\n    if (start > endIndex) {\n      const tmp = endIndex;\n      endIndex = start;\n      start = tmp;\n    }\n    return new ParseSpan(start, endIndex);\n  }\n  sourceSpan(start, artificialEndIndex) {\n    const serial = `${start}@${this.inputIndex}:${artificialEndIndex}`;\n    if (!this.sourceSpanCache.has(serial)) {\n      this.sourceSpanCache.set(serial, this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset));\n    }\n    return this.sourceSpanCache.get(serial);\n  }\n  advance() {\n    this.index++;\n  }\n  withContext(context, cb) {\n    this.context |= context;\n    const ret = cb();\n    this.context ^= context;\n    return ret;\n  }\n  consumeOptionalCharacter(code) {\n    if (this.next.isCharacter(code)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n  peekKeywordLet() {\n    return this.next.isKeywordLet();\n  }\n  peekKeywordAs() {\n    return this.next.isKeywordAs();\n  }\n  expectCharacter(code) {\n    if (this.consumeOptionalCharacter(code)) return;\n    this.error(`Missing expected ${String.fromCharCode(code)}`);\n  }\n  consumeOptionalOperator(op) {\n    if (this.next.isOperator(op)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n  isAssignmentOperator(token) {\n    return token.type === TokenType.Operator && Binary.isAssignmentOperation(token.strValue);\n  }\n  expectOperator(operator) {\n    if (this.consumeOptionalOperator(operator)) return;\n    this.error(`Missing expected operator ${operator}`);\n  }\n  prettyPrintToken(tok) {\n    return tok === EOF ? 'end of input' : `token ${tok}`;\n  }\n  expectIdentifierOrKeyword() {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword()) {\n      if (n.isPrivateIdentifier()) {\n        this._reportErrorForPrivateIdentifier(n, 'expected identifier or keyword');\n      } else {\n        this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier or keyword`);\n      }\n      return null;\n    }\n    this.advance();\n    return n.toString();\n  }\n  expectIdentifierOrKeywordOrString() {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n      if (n.isPrivateIdentifier()) {\n        this._reportErrorForPrivateIdentifier(n, 'expected identifier, keyword or string');\n      } else {\n        this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier, keyword, or string`);\n      }\n      return '';\n    }\n    this.advance();\n    return n.toString();\n  }\n  parseChain() {\n    const exprs = [];\n    const start = this.inputIndex;\n    while (this.index < this.tokens.length) {\n      const expr = this.parsePipe();\n      exprs.push(expr);\n      if (this.consumeOptionalCharacter($SEMICOLON)) {\n        if (!(this.parseFlags & 1)) {\n          this.error('Binding expression cannot contain chained expression');\n        }\n        while (this.consumeOptionalCharacter($SEMICOLON)) {}\n      } else if (this.index < this.tokens.length) {\n        const errorIndex = this.index;\n        this.error(`Unexpected token '${this.next}'`);\n        if (this.index === errorIndex) {\n          break;\n        }\n      }\n    }\n    if (exprs.length === 0) {\n      const artificialStart = this.offset;\n      const artificialEnd = this.offset + this.input.length;\n      return new EmptyExpr$1(this.span(artificialStart, artificialEnd), this.sourceSpan(artificialStart, artificialEnd));\n    }\n    if (exprs.length == 1) return exprs[0];\n    return new Chain(this.span(start), this.sourceSpan(start), exprs);\n  }\n  parsePipe() {\n    const start = this.inputIndex;\n    let result = this.parseExpression();\n    if (this.consumeOptionalOperator('|')) {\n      if (this.parseFlags & 1) {\n        this.error(`Cannot have a pipe in an action expression`);\n      }\n      do {\n        const nameStart = this.inputIndex;\n        let nameId = this.expectIdentifierOrKeyword();\n        let nameSpan;\n        let fullSpanEnd = undefined;\n        if (nameId !== null) {\n          nameSpan = this.sourceSpan(nameStart);\n        } else {\n          nameId = '';\n          fullSpanEnd = this.next.index !== -1 ? this.next.index : this.input.length + this.offset;\n          nameSpan = new ParseSpan(fullSpanEnd, fullSpanEnd).toAbsolute(this.absoluteOffset);\n        }\n        const args = [];\n        while (this.consumeOptionalCharacter($COLON)) {\n          args.push(this.parseExpression());\n        }\n        let type;\n        if (this.supportsDirectPipeReferences) {\n          const charCode = nameId.charCodeAt(0);\n          type = charCode === $_ || charCode >= $A && charCode <= $Z ? BindingPipeType.ReferencedDirectly : BindingPipeType.ReferencedByName;\n        } else {\n          type = BindingPipeType.ReferencedByName;\n        }\n        result = new BindingPipe(this.span(start), this.sourceSpan(start, fullSpanEnd), result, nameId, args, type, nameSpan);\n      } while (this.consumeOptionalOperator('|'));\n    }\n    return result;\n  }\n  parseExpression() {\n    return this.parseConditional();\n  }\n  parseConditional() {\n    const start = this.inputIndex;\n    const result = this.parseLogicalOr();\n    if (this.consumeOptionalOperator('?')) {\n      const yes = this.parsePipe();\n      let no;\n      if (!this.consumeOptionalCharacter($COLON)) {\n        const end = this.inputIndex;\n        const expression = this.input.substring(start, end);\n        this.error(`Conditional expression ${expression} requires all 3 expressions`);\n        no = new EmptyExpr$1(this.span(start), this.sourceSpan(start));\n      } else {\n        no = this.parsePipe();\n      }\n      return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);\n    } else {\n      return result;\n    }\n  }\n  parseLogicalOr() {\n    const start = this.inputIndex;\n    let result = this.parseLogicalAnd();\n    while (this.consumeOptionalOperator('||')) {\n      const right = this.parseLogicalAnd();\n      result = new Binary(this.span(start), this.sourceSpan(start), '||', result, right);\n    }\n    return result;\n  }\n  parseLogicalAnd() {\n    const start = this.inputIndex;\n    let result = this.parseNullishCoalescing();\n    while (this.consumeOptionalOperator('&&')) {\n      const right = this.parseNullishCoalescing();\n      result = new Binary(this.span(start), this.sourceSpan(start), '&&', result, right);\n    }\n    return result;\n  }\n  parseNullishCoalescing() {\n    const start = this.inputIndex;\n    let result = this.parseEquality();\n    while (this.consumeOptionalOperator('??')) {\n      const right = this.parseEquality();\n      result = new Binary(this.span(start), this.sourceSpan(start), '??', result, right);\n    }\n    return result;\n  }\n  parseEquality() {\n    const start = this.inputIndex;\n    let result = this.parseRelational();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '==':\n        case '===':\n        case '!=':\n        case '!==':\n          this.advance();\n          const right = this.parseRelational();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n  parseRelational() {\n    const start = this.inputIndex;\n    let result = this.parseAdditive();\n    while (this.next.type == TokenType.Operator || this.next.isKeywordIn) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n        case 'in':\n          this.advance();\n          const right = this.parseAdditive();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n  parseAdditive() {\n    const start = this.inputIndex;\n    let result = this.parseMultiplicative();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '+':\n        case '-':\n          this.advance();\n          let right = this.parseMultiplicative();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n  parseMultiplicative() {\n    const start = this.inputIndex;\n    let result = this.parseExponentiation();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '*':\n        case '%':\n        case '/':\n          this.advance();\n          const right = this.parseExponentiation();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n  parseExponentiation() {\n    const start = this.inputIndex;\n    let result = this.parsePrefix();\n    while (this.next.type == TokenType.Operator && this.next.strValue === '**') {\n      if (result instanceof Unary || result instanceof PrefixNot || result instanceof TypeofExpression || result instanceof VoidExpression) {\n        this.error('Unary operator used immediately before exponentiation expression. Parenthesis must be used to disambiguate operator precedence');\n      }\n      this.advance();\n      const right = this.parseExponentiation();\n      result = new Binary(this.span(start), this.sourceSpan(start), '**', result, right);\n    }\n    return result;\n  }\n  parsePrefix() {\n    if (this.next.type == TokenType.Operator) {\n      const start = this.inputIndex;\n      const operator = this.next.strValue;\n      let result;\n      switch (operator) {\n        case '+':\n          this.advance();\n          result = this.parsePrefix();\n          return Unary.createPlus(this.span(start), this.sourceSpan(start), result);\n        case '-':\n          this.advance();\n          result = this.parsePrefix();\n          return Unary.createMinus(this.span(start), this.sourceSpan(start), result);\n        case '!':\n          this.advance();\n          result = this.parsePrefix();\n          return new PrefixNot(this.span(start), this.sourceSpan(start), result);\n      }\n    } else if (this.next.isKeywordTypeof()) {\n      this.advance();\n      const start = this.inputIndex;\n      let result = this.parsePrefix();\n      return new TypeofExpression(this.span(start), this.sourceSpan(start), result);\n    } else if (this.next.isKeywordVoid()) {\n      this.advance();\n      const start = this.inputIndex;\n      let result = this.parsePrefix();\n      return new VoidExpression(this.span(start), this.sourceSpan(start), result);\n    }\n    return this.parseCallChain();\n  }\n  parseCallChain() {\n    const start = this.inputIndex;\n    let result = this.parsePrimary();\n    while (true) {\n      if (this.consumeOptionalCharacter($PERIOD)) {\n        result = this.parseAccessMember(result, start, false);\n      } else if (this.consumeOptionalOperator('?.')) {\n        if (this.consumeOptionalCharacter($LPAREN)) {\n          result = this.parseCall(result, start, true);\n        } else {\n          result = this.consumeOptionalCharacter($LBRACKET) ? this.parseKeyedReadOrWrite(result, start, true) : this.parseAccessMember(result, start, true);\n        }\n      } else if (this.consumeOptionalCharacter($LBRACKET)) {\n        result = this.parseKeyedReadOrWrite(result, start, false);\n      } else if (this.consumeOptionalCharacter($LPAREN)) {\n        result = this.parseCall(result, start, false);\n      } else if (this.consumeOptionalOperator('!')) {\n        result = new NonNullAssert(this.span(start), this.sourceSpan(start), result);\n      } else if (this.next.isTemplateLiteralEnd()) {\n        result = this.parseNoInterpolationTaggedTemplateLiteral(result, start);\n      } else if (this.next.isTemplateLiteralPart()) {\n        result = this.parseTaggedTemplateLiteral(result, start);\n      } else {\n        return result;\n      }\n    }\n  }\n  parsePrimary() {\n    const start = this.inputIndex;\n    if (this.consumeOptionalCharacter($LPAREN)) {\n      this.rparensExpected++;\n      const result = this.parsePipe();\n      if (!this.consumeOptionalCharacter($RPAREN)) {\n        this.error('Missing closing parentheses');\n        this.consumeOptionalCharacter($RPAREN);\n      }\n      this.rparensExpected--;\n      return new ParenthesizedExpression(this.span(start), this.sourceSpan(start), result);\n    } else if (this.next.isKeywordNull()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);\n    } else if (this.next.isKeywordUndefined()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);\n    } else if (this.next.isKeywordTrue()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);\n    } else if (this.next.isKeywordFalse()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);\n    } else if (this.next.isKeywordIn()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), 'in');\n    } else if (this.next.isKeywordThis()) {\n      this.advance();\n      return new ThisReceiver(this.span(start), this.sourceSpan(start));\n    } else if (this.consumeOptionalCharacter($LBRACKET)) {\n      this.rbracketsExpected++;\n      const elements = this.parseExpressionList($RBRACKET);\n      this.rbracketsExpected--;\n      this.expectCharacter($RBRACKET);\n      return new LiteralArray(this.span(start), this.sourceSpan(start), elements);\n    } else if (this.next.isCharacter($LBRACE)) {\n      return this.parseLiteralMap();\n    } else if (this.next.isIdentifier()) {\n      return this.parseAccessMember(new ImplicitReceiver(this.span(start), this.sourceSpan(start)), start, false);\n    } else if (this.next.isNumber()) {\n      const value = this.next.toNumber();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);\n    } else if (this.next.isTemplateLiteralEnd()) {\n      return this.parseNoInterpolationTemplateLiteral();\n    } else if (this.next.isTemplateLiteralPart()) {\n      return this.parseTemplateLiteral();\n    } else if (this.next.isString() && this.next.kind === StringTokenKind.Plain) {\n      const literalValue = this.next.toString();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);\n    } else if (this.next.isPrivateIdentifier()) {\n      this._reportErrorForPrivateIdentifier(this.next, null);\n      return new EmptyExpr$1(this.span(start), this.sourceSpan(start));\n    } else if (this.next.isRegExpBody()) {\n      return this.parseRegularExpressionLiteral();\n    } else if (this.index >= this.tokens.length) {\n      this.error(`Unexpected end of expression: ${this.input}`);\n      return new EmptyExpr$1(this.span(start), this.sourceSpan(start));\n    } else {\n      this.error(`Unexpected token ${this.next}`);\n      return new EmptyExpr$1(this.span(start), this.sourceSpan(start));\n    }\n  }\n  parseExpressionList(terminator) {\n    const result = [];\n    do {\n      if (!this.next.isCharacter(terminator)) {\n        result.push(this.parsePipe());\n      } else {\n        break;\n      }\n    } while (this.consumeOptionalCharacter($COMMA));\n    return result;\n  }\n  parseLiteralMap() {\n    const keys = [];\n    const values = [];\n    const start = this.inputIndex;\n    this.expectCharacter($LBRACE);\n    if (!this.consumeOptionalCharacter($RBRACE)) {\n      this.rbracesExpected++;\n      do {\n        const keyStart = this.inputIndex;\n        const quoted = this.next.isString();\n        const key = this.expectIdentifierOrKeywordOrString();\n        const literalMapKey = {\n          key,\n          quoted\n        };\n        keys.push(literalMapKey);\n        if (quoted) {\n          this.expectCharacter($COLON);\n          values.push(this.parsePipe());\n        } else if (this.consumeOptionalCharacter($COLON)) {\n          values.push(this.parsePipe());\n        } else {\n          literalMapKey.isShorthandInitialized = true;\n          const span = this.span(keyStart);\n          const sourceSpan = this.sourceSpan(keyStart);\n          values.push(new PropertyRead(span, sourceSpan, sourceSpan, new ImplicitReceiver(span, sourceSpan), key));\n        }\n      } while (this.consumeOptionalCharacter($COMMA) && !this.next.isCharacter($RBRACE));\n      this.rbracesExpected--;\n      this.expectCharacter($RBRACE);\n    }\n    return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);\n  }\n  parseAccessMember(readReceiver, start, isSafe) {\n    const nameStart = this.inputIndex;\n    const id = this.withContext(ParseContextFlags.Writable, () => {\n      const id = this.expectIdentifierOrKeyword() ?? '';\n      if (id.length === 0) {\n        this.error(`Expected identifier for property access`, readReceiver.span.end);\n      }\n      return id;\n    });\n    const nameSpan = this.sourceSpan(nameStart);\n    if (isSafe) {\n      if (this.isAssignmentOperator(this.next)) {\n        this.advance();\n        this.error(\"The '?.' operator cannot be used in the assignment\");\n        return new EmptyExpr$1(this.span(start), this.sourceSpan(start));\n      } else {\n        return new SafePropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);\n      }\n    } else {\n      if (this.isAssignmentOperator(this.next)) {\n        const operation = this.next.strValue;\n        if (!(this.parseFlags & 1)) {\n          this.advance();\n          this.error('Bindings cannot contain assignments');\n          return new EmptyExpr$1(this.span(start), this.sourceSpan(start));\n        }\n        const receiver = new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);\n        this.advance();\n        const value = this.parseConditional();\n        return new Binary(this.span(start), this.sourceSpan(start), operation, receiver, value);\n      } else {\n        return new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);\n      }\n    }\n  }\n  parseCall(receiver, start, isSafe) {\n    const argumentStart = this.inputIndex;\n    this.rparensExpected++;\n    const args = this.parseCallArguments();\n    const argumentSpan = this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);\n    this.expectCharacter($RPAREN);\n    this.rparensExpected--;\n    const span = this.span(start);\n    const sourceSpan = this.sourceSpan(start);\n    return isSafe ? new SafeCall(span, sourceSpan, receiver, args, argumentSpan) : new Call(span, sourceSpan, receiver, args, argumentSpan);\n  }\n  parseCallArguments() {\n    if (this.next.isCharacter($RPAREN)) return [];\n    const positionals = [];\n    do {\n      positionals.push(this.parsePipe());\n    } while (this.consumeOptionalCharacter($COMMA));\n    return positionals;\n  }\n  expectTemplateBindingKey() {\n    let result = '';\n    let operatorFound = false;\n    const start = this.currentAbsoluteOffset;\n    do {\n      result += this.expectIdentifierOrKeywordOrString();\n      operatorFound = this.consumeOptionalOperator('-');\n      if (operatorFound) {\n        result += '-';\n      }\n    } while (operatorFound);\n    return {\n      source: result,\n      span: new AbsoluteSourceSpan(start, start + result.length)\n    };\n  }\n  parseTemplateBindings(templateKey) {\n    const bindings = [];\n    bindings.push(...this.parseDirectiveKeywordBindings(templateKey));\n    while (this.index < this.tokens.length) {\n      const letBinding = this.parseLetBinding();\n      if (letBinding) {\n        bindings.push(letBinding);\n      } else {\n        const key = this.expectTemplateBindingKey();\n        const binding = this.parseAsBinding(key);\n        if (binding) {\n          bindings.push(binding);\n        } else {\n          key.source = templateKey.source + key.source.charAt(0).toUpperCase() + key.source.substring(1);\n          bindings.push(...this.parseDirectiveKeywordBindings(key));\n        }\n      }\n      this.consumeStatementTerminator();\n    }\n    return new TemplateBindingParseResult(bindings, [], this.errors);\n  }\n  parseKeyedReadOrWrite(receiver, start, isSafe) {\n    return this.withContext(ParseContextFlags.Writable, () => {\n      this.rbracketsExpected++;\n      const key = this.parsePipe();\n      if (key instanceof EmptyExpr$1) {\n        this.error(`Key access cannot be empty`);\n      }\n      this.rbracketsExpected--;\n      this.expectCharacter($RBRACKET);\n      if (this.isAssignmentOperator(this.next)) {\n        const operation = this.next.strValue;\n        if (isSafe) {\n          this.advance();\n          this.error(\"The '?.' operator cannot be used in the assignment\");\n        } else {\n          const binaryReceiver = new KeyedRead(this.span(start), this.sourceSpan(start), receiver, key);\n          this.advance();\n          const value = this.parseConditional();\n          return new Binary(this.span(start), this.sourceSpan(start), operation, binaryReceiver, value);\n        }\n      } else {\n        return isSafe ? new SafeKeyedRead(this.span(start), this.sourceSpan(start), receiver, key) : new KeyedRead(this.span(start), this.sourceSpan(start), receiver, key);\n      }\n      return new EmptyExpr$1(this.span(start), this.sourceSpan(start));\n    });\n  }\n  parseDirectiveKeywordBindings(key) {\n    const bindings = [];\n    this.consumeOptionalCharacter($COLON);\n    const value = this.getDirectiveBoundTarget();\n    let spanEnd = this.currentAbsoluteOffset;\n    const asBinding = this.parseAsBinding(key);\n    if (!asBinding) {\n      this.consumeStatementTerminator();\n      spanEnd = this.currentAbsoluteOffset;\n    }\n    const sourceSpan = new AbsoluteSourceSpan(key.span.start, spanEnd);\n    bindings.push(new ExpressionBinding(sourceSpan, key, value));\n    if (asBinding) {\n      bindings.push(asBinding);\n    }\n    return bindings;\n  }\n  getDirectiveBoundTarget() {\n    if (this.next === EOF || this.peekKeywordAs() || this.peekKeywordLet()) {\n      return null;\n    }\n    const ast = this.parsePipe();\n    const {\n      start,\n      end\n    } = ast.span;\n    const value = this.input.substring(start, end);\n    return new ASTWithSource(ast, value, getLocation(this.parseSourceSpan), this.absoluteOffset + start, this.errors);\n  }\n  parseAsBinding(value) {\n    if (!this.peekKeywordAs()) {\n      return null;\n    }\n    this.advance();\n    const key = this.expectTemplateBindingKey();\n    this.consumeStatementTerminator();\n    const sourceSpan = new AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);\n    return new VariableBinding(sourceSpan, key, value);\n  }\n  parseLetBinding() {\n    if (!this.peekKeywordLet()) {\n      return null;\n    }\n    const spanStart = this.currentAbsoluteOffset;\n    this.advance();\n    const key = this.expectTemplateBindingKey();\n    let value = null;\n    if (this.consumeOptionalOperator('=')) {\n      value = this.expectTemplateBindingKey();\n    }\n    this.consumeStatementTerminator();\n    const sourceSpan = new AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);\n    return new VariableBinding(sourceSpan, key, value);\n  }\n  parseNoInterpolationTaggedTemplateLiteral(tag, start) {\n    const template = this.parseNoInterpolationTemplateLiteral();\n    return new TaggedTemplateLiteral(this.span(start), this.sourceSpan(start), tag, template);\n  }\n  parseNoInterpolationTemplateLiteral() {\n    const text = this.next.strValue;\n    const start = this.inputIndex;\n    this.advance();\n    const span = this.span(start);\n    const sourceSpan = this.sourceSpan(start);\n    return new TemplateLiteral(span, sourceSpan, [new TemplateLiteralElement(span, sourceSpan, text)], []);\n  }\n  parseTaggedTemplateLiteral(tag, start) {\n    const template = this.parseTemplateLiteral();\n    return new TaggedTemplateLiteral(this.span(start), this.sourceSpan(start), tag, template);\n  }\n  parseTemplateLiteral() {\n    const elements = [];\n    const expressions = [];\n    const start = this.inputIndex;\n    while (this.next !== EOF) {\n      const token = this.next;\n      if (token.isTemplateLiteralPart() || token.isTemplateLiteralEnd()) {\n        const partStart = this.inputIndex;\n        this.advance();\n        elements.push(new TemplateLiteralElement(this.span(partStart), this.sourceSpan(partStart), token.strValue));\n        if (token.isTemplateLiteralEnd()) {\n          break;\n        }\n      } else if (token.isTemplateLiteralInterpolationStart()) {\n        this.advance();\n        this.rbracesExpected++;\n        const expression = this.parsePipe();\n        if (expression instanceof EmptyExpr$1) {\n          this.error('Template literal interpolation cannot be empty');\n        } else {\n          expressions.push(expression);\n        }\n        this.rbracesExpected--;\n      } else {\n        this.advance();\n      }\n    }\n    return new TemplateLiteral(this.span(start), this.sourceSpan(start), elements, expressions);\n  }\n  parseRegularExpressionLiteral() {\n    const bodyToken = this.next;\n    this.advance();\n    if (!bodyToken.isRegExpBody()) {\n      return new EmptyExpr$1(this.span(this.inputIndex), this.sourceSpan(this.inputIndex));\n    }\n    let flagsToken = null;\n    if (this.next.isRegExpFlags()) {\n      flagsToken = this.next;\n      this.advance();\n      const seenFlags = new Set();\n      for (let i = 0; i < flagsToken.strValue.length; i++) {\n        const char = flagsToken.strValue[i];\n        if (!SUPPORTED_REGEX_FLAGS.has(char)) {\n          this.error(`Unsupported regular expression flag \"${char}\". The supported flags are: ` + Array.from(SUPPORTED_REGEX_FLAGS, f => `\"${f}\"`).join(', '), flagsToken.index + i);\n        } else if (seenFlags.has(char)) {\n          this.error(`Duplicate regular expression flag \"${char}\"`, flagsToken.index + i);\n        } else {\n          seenFlags.add(char);\n        }\n      }\n    }\n    const start = bodyToken.index;\n    const end = flagsToken ? flagsToken.end : bodyToken.end;\n    return new RegularExpressionLiteral(this.span(start, end), this.sourceSpan(start, end), bodyToken.strValue, flagsToken ? flagsToken.strValue : null);\n  }\n  consumeStatementTerminator() {\n    this.consumeOptionalCharacter($SEMICOLON) || this.consumeOptionalCharacter($COMMA);\n  }\n  error(message, index = this.index) {\n    this.errors.push(getParseError(message, this.input, this.getErrorLocationText(index), this.parseSourceSpan));\n    this.skip();\n  }\n  getErrorLocationText(index) {\n    return index < this.tokens.length ? `at column ${this.tokens[index].index + 1} in` : `at the end of the expression`;\n  }\n  _reportErrorForPrivateIdentifier(token, extraMessage) {\n    let errorMessage = `Private identifiers are not supported. Unexpected private identifier: ${token}`;\n    if (extraMessage !== null) {\n      errorMessage += `, ${extraMessage}`;\n    }\n    this.error(errorMessage);\n  }\n  skip() {\n    let n = this.next;\n    while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) && !n.isOperator('|') && (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) && (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) && (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET)) && (!(this.context & ParseContextFlags.Writable) || !this.isAssignmentOperator(n))) {\n      if (this.next.isError()) {\n        this.errors.push(getParseError(this.next.toString(), this.input, this.getErrorLocationText(this.next.index), this.parseSourceSpan));\n      }\n      this.advance();\n      n = this.next;\n    }\n  }\n}\nfunction getParseError(message, input, locationText, parseSourceSpan) {\n  if (locationText.length > 0) {\n    locationText = ` ${locationText} `;\n  }\n  const location = getLocation(parseSourceSpan);\n  const error = `Parser Error: ${message}${locationText}[${input}] in ${location}`;\n  return new ParseError(parseSourceSpan, error);\n}\nclass SimpleExpressionChecker extends RecursiveAstVisitor {\n  errors = [];\n  visitPipe() {\n    this.errors.push('pipes');\n  }\n}\nfunction getIndexMapForOriginalTemplate(interpolatedTokens) {\n  let offsetMap = new Map();\n  let consumedInOriginalTemplate = 0;\n  let consumedInInput = 0;\n  let tokenIndex = 0;\n  while (tokenIndex < interpolatedTokens.length) {\n    const currentToken = interpolatedTokens[tokenIndex];\n    if (currentToken.type === 9) {\n      const [decoded, encoded] = currentToken.parts;\n      consumedInOriginalTemplate += encoded.length;\n      consumedInInput += decoded.length;\n    } else {\n      const lengthOfParts = currentToken.parts.reduce((sum, current) => sum + current.length, 0);\n      consumedInInput += lengthOfParts;\n      consumedInOriginalTemplate += lengthOfParts;\n    }\n    offsetMap.set(consumedInInput, consumedInOriginalTemplate);\n    tokenIndex++;\n  }\n  return offsetMap;\n}\n\nfunction serialize(expression) {\n  return expression.visit(new SerializeExpressionVisitor());\n}\nclass SerializeExpressionVisitor {\n  visitUnary(ast, context) {\n    return `${ast.operator}${ast.expr.visit(this, context)}`;\n  }\n  visitBinary(ast, context) {\n    return `${ast.left.visit(this, context)} ${ast.operation} ${ast.right.visit(this, context)}`;\n  }\n  visitChain(ast, context) {\n    return ast.expressions.map(e => e.visit(this, context)).join('; ');\n  }\n  visitConditional(ast, context) {\n    return `${ast.condition.visit(this, context)} ? ${ast.trueExp.visit(this, context)} : ${ast.falseExp.visit(this, context)}`;\n  }\n  visitThisReceiver() {\n    return 'this';\n  }\n  visitImplicitReceiver() {\n    return '';\n  }\n  visitInterpolation(ast, context) {\n    return interleave(ast.strings, ast.expressions.map(e => e.visit(this, context))).join('');\n  }\n  visitKeyedRead(ast, context) {\n    return `${ast.receiver.visit(this, context)}[${ast.key.visit(this, context)}]`;\n  }\n  visitLiteralArray(ast, context) {\n    return `[${ast.expressions.map(e => e.visit(this, context)).join(', ')}]`;\n  }\n  visitLiteralMap(ast, context) {\n    return `{${zip(ast.keys.map(literal => literal.quoted ? `'${literal.key}'` : literal.key), ast.values.map(value => value.visit(this, context))).map(([key, value]) => `${key}: ${value}`).join(', ')}}`;\n  }\n  visitLiteralPrimitive(ast) {\n    if (ast.value === null) return 'null';\n    switch (typeof ast.value) {\n      case 'number':\n      case 'boolean':\n        return ast.value.toString();\n      case 'undefined':\n        return 'undefined';\n      case 'string':\n        return `'${ast.value.replace(/'/g, `\\\\'`)}'`;\n      default:\n        throw new Error(`Unsupported primitive type: ${ast.value}`);\n    }\n  }\n  visitPipe(ast, context) {\n    return `${ast.exp.visit(this, context)} | ${ast.name}`;\n  }\n  visitPrefixNot(ast, context) {\n    return `!${ast.expression.visit(this, context)}`;\n  }\n  visitNonNullAssert(ast, context) {\n    return `${ast.expression.visit(this, context)}!`;\n  }\n  visitPropertyRead(ast, context) {\n    if (ast.receiver instanceof ImplicitReceiver) {\n      return ast.name;\n    } else {\n      return `${ast.receiver.visit(this, context)}.${ast.name}`;\n    }\n  }\n  visitSafePropertyRead(ast, context) {\n    return `${ast.receiver.visit(this, context)}?.${ast.name}`;\n  }\n  visitSafeKeyedRead(ast, context) {\n    return `${ast.receiver.visit(this, context)}?.[${ast.key.visit(this, context)}]`;\n  }\n  visitCall(ast, context) {\n    return `${ast.receiver.visit(this, context)}(${ast.args.map(e => e.visit(this, context)).join(', ')})`;\n  }\n  visitSafeCall(ast, context) {\n    return `${ast.receiver.visit(this, context)}?.(${ast.args.map(e => e.visit(this, context)).join(', ')})`;\n  }\n  visitTypeofExpression(ast, context) {\n    return `typeof ${ast.expression.visit(this, context)}`;\n  }\n  visitVoidExpression(ast, context) {\n    return `void ${ast.expression.visit(this, context)}`;\n  }\n  visitRegularExpressionLiteral(ast, context) {\n    return `/${ast.body}/${ast.flags || ''}`;\n  }\n  visitASTWithSource(ast, context) {\n    return ast.ast.visit(this, context);\n  }\n  visitTemplateLiteral(ast, context) {\n    let result = '';\n    for (let i = 0; i < ast.elements.length; i++) {\n      result += ast.elements[i].visit(this, context);\n      const expression = i < ast.expressions.length ? ast.expressions[i] : null;\n      if (expression !== null) {\n        result += '${' + expression.visit(this, context) + '}';\n      }\n    }\n    return '`' + result + '`';\n  }\n  visitTemplateLiteralElement(ast, context) {\n    return ast.text;\n  }\n  visitTaggedTemplateLiteral(ast, context) {\n    return ast.tag.visit(this, context) + ast.template.visit(this, context);\n  }\n  visitParenthesizedExpression(ast, context) {\n    return '(' + ast.expression.visit(this, context) + ')';\n  }\n}\nfunction zip(left, right) {\n  if (left.length !== right.length) throw new Error('Array lengths must match');\n  return left.map((l, i) => [l, right[i]]);\n}\nfunction interleave(left, right) {\n  const result = [];\n  for (let index = 0; index < Math.max(left.length, right.length); index++) {\n    if (index < left.length) result.push(left[index]);\n    if (index < right.length) result.push(right[index]);\n  }\n  return result;\n}\n\nlet _SECURITY_SCHEMA;\nfunction SECURITY_SCHEMA() {\n  if (!_SECURITY_SCHEMA) {\n    _SECURITY_SCHEMA = {};\n    registerContext(SecurityContext.HTML, ['iframe|srcdoc', '*|innerHTML', '*|outerHTML']);\n    registerContext(SecurityContext.STYLE, ['*|style']);\n    registerContext(SecurityContext.URL, ['*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href', 'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action', 'img|src', 'input|src', 'ins|cite', 'q|cite', 'source|src', 'track|src', 'video|poster', 'video|src']);\n    registerContext(SecurityContext.RESOURCE_URL, ['applet|code', 'applet|codebase', 'base|href', 'embed|src', 'frame|src', 'head|profile', 'html|manifest', 'iframe|src', 'link|href', 'media|src', 'object|codebase', 'object|data', 'script|src']);\n  }\n  return _SECURITY_SCHEMA;\n}\nfunction registerContext(ctx, specs) {\n  for (const spec of specs) _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;\n}\nconst IFRAME_SECURITY_SENSITIVE_ATTRS = new Set(['sandbox', 'allow', 'allowfullscreen', 'referrerpolicy', 'csp', 'fetchpriority']);\nfunction isIframeSecuritySensitiveAttr(attrName) {\n  return IFRAME_SECURITY_SENSITIVE_ATTRS.has(attrName.toLowerCase());\n}\n\nclass ElementSchemaRegistry {}\n\nconst BOOLEAN = 'boolean';\nconst NUMBER = 'number';\nconst STRING = 'string';\nconst OBJECT = 'object';\nconst SCHEMA = ['[Element]|textContent,%ariaActiveDescendantElement,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColIndexText,%ariaColSpan,%ariaControlsElements,%ariaCurrent,%ariaDescribedByElements,%ariaDescription,%ariaDetailsElements,%ariaDisabled,%ariaErrorMessageElements,%ariaExpanded,%ariaFlowToElements,%ariaHasPopup,%ariaHidden,%ariaInvalid,%ariaKeyShortcuts,%ariaLabel,%ariaLabelledByElements,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaOwnsElements,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowIndexText,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot' + ',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored', '[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,!inert,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy', 'abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,search,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy', 'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume', ':svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex', ':svg:graphics^:svg:|', ':svg:animation^:svg:|*begin,*end,*repeat', ':svg:geometry^:svg:|', ':svg:componentTransferFunction^:svg:|', ':svg:gradient^:svg:|', ':svg:textContent^:svg:graphics|', ':svg:textPositioning^:svg:textContent|', 'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username', 'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username', 'audio^media|', 'br^[HTMLElement]|clear', 'base^[HTMLElement]|href,target', 'body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink', 'button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value', 'canvas^[HTMLElement]|#height,#width', 'content^[HTMLElement]|select', 'dl^[HTMLElement]|!compact', 'data^[HTMLElement]|value', 'datalist^[HTMLElement]|', 'details^[HTMLElement]|!open', 'dialog^[HTMLElement]|!open,returnValue', 'dir^[HTMLElement]|!compact', 'div^[HTMLElement]|align', 'embed^[HTMLElement]|align,height,name,src,type,width', 'fieldset^[HTMLElement]|!disabled,name', 'font^[HTMLElement]|color,face,size', 'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target', 'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src', 'frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows', 'hr^[HTMLElement]|align,color,!noShade,size,width', 'head^[HTMLElement]|', 'h1,h2,h3,h4,h5,h6^[HTMLElement]|align', 'html^[HTMLElement]|version', 'iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width', 'img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width', 'input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width', 'li^[HTMLElement]|type,#value', 'label^[HTMLElement]|htmlFor', 'legend^[HTMLElement]|align', 'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type', 'map^[HTMLElement]|name', 'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width', 'menu^[HTMLElement]|!compact', 'meta^[HTMLElement]|content,httpEquiv,media,name,scheme', 'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value', 'ins,del^[HTMLElement]|cite,dateTime', 'ol^[HTMLElement]|!compact,!reversed,#start,type', 'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width', 'optgroup^[HTMLElement]|!disabled,label', 'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value', 'output^[HTMLElement]|defaultValue,%htmlFor,name,value', 'p^[HTMLElement]|align', 'param^[HTMLElement]|name,type,value,valueType', 'picture^[HTMLElement]|', 'pre^[HTMLElement]|#width', 'progress^[HTMLElement]|#max,#value', 'q,blockquote,cite^[HTMLElement]|', 'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type', 'select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value', 'selectedcontent^[HTMLElement]|', 'slot^[HTMLElement]|name', 'source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width', 'span^[HTMLElement]|', 'style^[HTMLElement]|!disabled,media,type', 'search^[HTMLELement]|', 'caption^[HTMLElement]|align', 'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width', 'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width', 'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width', 'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign', 'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign', 'template^[HTMLElement]|', 'textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap', 'time^[HTMLElement]|dateTime', 'title^[HTMLElement]|text', 'track^[HTMLElement]|!default,kind,label,src,srclang', 'ul^[HTMLElement]|!compact,type', 'unknown^[HTMLElement]|', 'video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width', ':svg:a^:svg:graphics|', ':svg:animate^:svg:animation|', ':svg:animateMotion^:svg:animation|', ':svg:animateTransform^:svg:animation|', ':svg:circle^:svg:geometry|', ':svg:clipPath^:svg:graphics|', ':svg:defs^:svg:graphics|', ':svg:desc^:svg:|', ':svg:discard^:svg:|', ':svg:ellipse^:svg:geometry|', ':svg:feBlend^:svg:|', ':svg:feColorMatrix^:svg:|', ':svg:feComponentTransfer^:svg:|', ':svg:feComposite^:svg:|', ':svg:feConvolveMatrix^:svg:|', ':svg:feDiffuseLighting^:svg:|', ':svg:feDisplacementMap^:svg:|', ':svg:feDistantLight^:svg:|', ':svg:feDropShadow^:svg:|', ':svg:feFlood^:svg:|', ':svg:feFuncA^:svg:componentTransferFunction|', ':svg:feFuncB^:svg:componentTransferFunction|', ':svg:feFuncG^:svg:componentTransferFunction|', ':svg:feFuncR^:svg:componentTransferFunction|', ':svg:feGaussianBlur^:svg:|', ':svg:feImage^:svg:|', ':svg:feMerge^:svg:|', ':svg:feMergeNode^:svg:|', ':svg:feMorphology^:svg:|', ':svg:feOffset^:svg:|', ':svg:fePointLight^:svg:|', ':svg:feSpecularLighting^:svg:|', ':svg:feSpotLight^:svg:|', ':svg:feTile^:svg:|', ':svg:feTurbulence^:svg:|', ':svg:filter^:svg:|', ':svg:foreignObject^:svg:graphics|', ':svg:g^:svg:graphics|', ':svg:image^:svg:graphics|decoding', ':svg:line^:svg:geometry|', ':svg:linearGradient^:svg:gradient|', ':svg:mpath^:svg:|', ':svg:marker^:svg:|', ':svg:mask^:svg:|', ':svg:metadata^:svg:|', ':svg:path^:svg:geometry|', ':svg:pattern^:svg:|', ':svg:polygon^:svg:geometry|', ':svg:polyline^:svg:geometry|', ':svg:radialGradient^:svg:gradient|', ':svg:rect^:svg:geometry|', ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan', ':svg:script^:svg:|type', ':svg:set^:svg:animation|', ':svg:stop^:svg:|', ':svg:style^:svg:|!disabled,media,title,type', ':svg:switch^:svg:graphics|', ':svg:symbol^:svg:|', ':svg:tspan^:svg:textPositioning|', ':svg:text^:svg:textPositioning|', ':svg:textPath^:svg:textContent|', ':svg:title^:svg:|', ':svg:use^:svg:graphics|', ':svg:view^:svg:|#zoomAndPan', 'data^[HTMLElement]|value', 'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name', 'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default', 'summary^[HTMLElement]|', 'time^[HTMLElement]|dateTime', ':svg:cursor^:svg:|', ':math:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforeinput,*beforematch,*beforetoggle,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contentvisibilityautostatechange,*contextlost,*contextmenu,*contextrestored,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*scrollend,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex', ':math:math^:math:|', ':math:maction^:math:|', ':math:menclose^:math:|', ':math:merror^:math:|', ':math:mfenced^:math:|', ':math:mfrac^:math:|', ':math:mi^:math:|', ':math:mmultiscripts^:math:|', ':math:mn^:math:|', ':math:mo^:math:|', ':math:mover^:math:|', ':math:mpadded^:math:|', ':math:mphantom^:math:|', ':math:mroot^:math:|', ':math:mrow^:math:|', ':math:ms^:math:|', ':math:mspace^:math:|', ':math:msqrt^:math:|', ':math:mstyle^:math:|', ':math:msub^:math:|', ':math:msubsup^:math:|', ':math:msup^:math:|', ':math:mtable^:math:|', ':math:mtd^:math:|', ':math:mtext^:math:|', ':math:mtr^:math:|', ':math:munder^:math:|', ':math:munderover^:math:|', ':math:semantics^:math:|'];\nconst _ATTR_TO_PROP = new Map(Object.entries({\n  'class': 'className',\n  'for': 'htmlFor',\n  'formaction': 'formAction',\n  'innerHtml': 'innerHTML',\n  'readonly': 'readOnly',\n  'tabindex': 'tabIndex',\n  'aria-activedescendant': 'ariaActiveDescendantElement',\n  'aria-atomic': 'ariaAtomic',\n  'aria-autocomplete': 'ariaAutoComplete',\n  'aria-busy': 'ariaBusy',\n  'aria-checked': 'ariaChecked',\n  'aria-colcount': 'ariaColCount',\n  'aria-colindex': 'ariaColIndex',\n  'aria-colindextext': 'ariaColIndexText',\n  'aria-colspan': 'ariaColSpan',\n  'aria-controls': 'ariaControlsElements',\n  'aria-current': 'ariaCurrent',\n  'aria-describedby': 'ariaDescribedByElements',\n  'aria-description': 'ariaDescription',\n  'aria-details': 'ariaDetailsElements',\n  'aria-disabled': 'ariaDisabled',\n  'aria-errormessage': 'ariaErrorMessageElements',\n  'aria-expanded': 'ariaExpanded',\n  'aria-flowto': 'ariaFlowToElements',\n  'aria-haspopup': 'ariaHasPopup',\n  'aria-hidden': 'ariaHidden',\n  'aria-invalid': 'ariaInvalid',\n  'aria-keyshortcuts': 'ariaKeyShortcuts',\n  'aria-label': 'ariaLabel',\n  'aria-labelledby': 'ariaLabelledByElements',\n  'aria-level': 'ariaLevel',\n  'aria-live': 'ariaLive',\n  'aria-modal': 'ariaModal',\n  'aria-multiline': 'ariaMultiLine',\n  'aria-multiselectable': 'ariaMultiSelectable',\n  'aria-orientation': 'ariaOrientation',\n  'aria-owns': 'ariaOwnsElements',\n  'aria-placeholder': 'ariaPlaceholder',\n  'aria-posinset': 'ariaPosInSet',\n  'aria-pressed': 'ariaPressed',\n  'aria-readonly': 'ariaReadOnly',\n  'aria-required': 'ariaRequired',\n  'aria-roledescription': 'ariaRoleDescription',\n  'aria-rowcount': 'ariaRowCount',\n  'aria-rowindex': 'ariaRowIndex',\n  'aria-rowindextext': 'ariaRowIndexText',\n  'aria-rowspan': 'ariaRowSpan',\n  'aria-selected': 'ariaSelected',\n  'aria-setsize': 'ariaSetSize',\n  'aria-sort': 'ariaSort',\n  'aria-valuemax': 'ariaValueMax',\n  'aria-valuemin': 'ariaValueMin',\n  'aria-valuenow': 'ariaValueNow',\n  'aria-valuetext': 'ariaValueText'\n}));\nconst _PROP_TO_ATTR = Array.from(_ATTR_TO_PROP).reduce((inverted, [propertyName, attributeName]) => {\n  inverted.set(propertyName, attributeName);\n  return inverted;\n}, new Map());\nclass DomElementSchemaRegistry extends ElementSchemaRegistry {\n  _schema = new Map();\n  _eventSchema = new Map();\n  constructor() {\n    super();\n    SCHEMA.forEach(encodedType => {\n      const type = new Map();\n      const events = new Set();\n      const [strType, strProperties] = encodedType.split('|');\n      const properties = strProperties.split(',');\n      const [typeNames, superName] = strType.split('^');\n      typeNames.split(',').forEach(tag => {\n        this._schema.set(tag.toLowerCase(), type);\n        this._eventSchema.set(tag.toLowerCase(), events);\n      });\n      const superType = superName && this._schema.get(superName.toLowerCase());\n      if (superType) {\n        for (const [prop, value] of superType) {\n          type.set(prop, value);\n        }\n        for (const superEvent of this._eventSchema.get(superName.toLowerCase())) {\n          events.add(superEvent);\n        }\n      }\n      properties.forEach(property => {\n        if (property.length > 0) {\n          switch (property[0]) {\n            case '*':\n              events.add(property.substring(1));\n              break;\n            case '!':\n              type.set(property.substring(1), BOOLEAN);\n              break;\n            case '#':\n              type.set(property.substring(1), NUMBER);\n              break;\n            case '%':\n              type.set(property.substring(1), OBJECT);\n              break;\n            default:\n              type.set(property, STRING);\n          }\n        }\n      });\n    });\n  }\n  hasProperty(tagName, propName, schemaMetas) {\n    if (schemaMetas.some(schema => schema.name === NO_ERRORS_SCHEMA.name)) {\n      return true;\n    }\n    if (tagName.indexOf('-') > -1) {\n      if (isNgContainer(tagName) || isNgContent(tagName)) {\n        return false;\n      }\n      if (schemaMetas.some(schema => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {\n        return true;\n      }\n    }\n    const elementProperties = this._schema.get(tagName.toLowerCase()) || this._schema.get('unknown');\n    return elementProperties.has(propName);\n  }\n  hasElement(tagName, schemaMetas) {\n    if (schemaMetas.some(schema => schema.name === NO_ERRORS_SCHEMA.name)) {\n      return true;\n    }\n    if (tagName.indexOf('-') > -1) {\n      if (isNgContainer(tagName) || isNgContent(tagName)) {\n        return true;\n      }\n      if (schemaMetas.some(schema => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {\n        return true;\n      }\n    }\n    return this._schema.has(tagName.toLowerCase());\n  }\n  securityContext(tagName, propName, isAttribute) {\n    if (isAttribute) {\n      propName = this.getMappedPropName(propName);\n    }\n    tagName = tagName.toLowerCase();\n    propName = propName.toLowerCase();\n    let ctx = SECURITY_SCHEMA()[tagName + '|' + propName];\n    if (ctx) {\n      return ctx;\n    }\n    ctx = SECURITY_SCHEMA()['*|' + propName];\n    return ctx ? ctx : SecurityContext.NONE;\n  }\n  getMappedPropName(propName) {\n    return _ATTR_TO_PROP.get(propName) ?? propName;\n  }\n  getDefaultComponentElementName() {\n    return 'ng-component';\n  }\n  validateProperty(name) {\n    if (name.toLowerCase().startsWith('on')) {\n      const msg = `Binding to event property '${name}' is disallowed for security reasons, ` + `please use (${name.slice(2)})=...` + `\\nIf '${name}' is a directive input, make sure the directive is imported by the` + ` current module.`;\n      return {\n        error: true,\n        msg: msg\n      };\n    } else {\n      return {\n        error: false\n      };\n    }\n  }\n  validateAttribute(name) {\n    if (name.toLowerCase().startsWith('on')) {\n      const msg = `Binding to event attribute '${name}' is disallowed for security reasons, ` + `please use (${name.slice(2)})=...`;\n      return {\n        error: true,\n        msg: msg\n      };\n    } else {\n      return {\n        error: false\n      };\n    }\n  }\n  allKnownElementNames() {\n    return Array.from(this._schema.keys());\n  }\n  allKnownAttributesOfElement(tagName) {\n    const elementProperties = this._schema.get(tagName.toLowerCase()) || this._schema.get('unknown');\n    return Array.from(elementProperties.keys()).map(prop => _PROP_TO_ATTR.get(prop) ?? prop);\n  }\n  allKnownEventsOfElement(tagName) {\n    return Array.from(this._eventSchema.get(tagName.toLowerCase()) ?? []);\n  }\n  normalizeAnimationStyleProperty(propName) {\n    return dashCaseToCamelCase(propName);\n  }\n  normalizeAnimationStyleValue(camelCaseProp, userProvidedProp, val) {\n    let unit = '';\n    const strVal = val.toString().trim();\n    let errorMsg = null;\n    if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {\n      if (typeof val === 'number') {\n        unit = 'px';\n      } else {\n        const valAndSuffixMatch = val.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n        if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n          errorMsg = `Please provide a CSS unit value for ${userProvidedProp}:${val}`;\n        }\n      }\n    }\n    return {\n      error: errorMsg,\n      value: strVal + unit\n    };\n  }\n}\nfunction _isPixelDimensionStyle(prop) {\n  switch (prop) {\n    case 'width':\n    case 'height':\n    case 'minWidth':\n    case 'minHeight':\n    case 'maxWidth':\n    case 'maxHeight':\n    case 'left':\n    case 'top':\n    case 'bottom':\n    case 'right':\n    case 'fontSize':\n    case 'outlineWidth':\n    case 'outlineOffset':\n    case 'paddingTop':\n    case 'paddingLeft':\n    case 'paddingBottom':\n    case 'paddingRight':\n    case 'marginTop':\n    case 'marginLeft':\n    case 'marginBottom':\n    case 'marginRight':\n    case 'borderRadius':\n    case 'borderWidth':\n    case 'borderTopWidth':\n    case 'borderLeftWidth':\n    case 'borderRightWidth':\n    case 'borderBottomWidth':\n    case 'textIndent':\n      return true;\n    default:\n      return false;\n  }\n}\n\nclass HtmlTagDefinition {\n  closedByChildren = {};\n  contentType;\n  closedByParent = false;\n  implicitNamespacePrefix;\n  isVoid;\n  ignoreFirstLf;\n  canSelfClose;\n  preventNamespaceInheritance;\n  constructor({\n    closedByChildren,\n    implicitNamespacePrefix,\n    contentType = TagContentType.PARSABLE_DATA,\n    closedByParent = false,\n    isVoid = false,\n    ignoreFirstLf = false,\n    preventNamespaceInheritance = false,\n    canSelfClose = false\n  } = {}) {\n    if (closedByChildren && closedByChildren.length > 0) {\n      closedByChildren.forEach(tagName => this.closedByChildren[tagName] = true);\n    }\n    this.isVoid = isVoid;\n    this.closedByParent = closedByParent || isVoid;\n    this.implicitNamespacePrefix = implicitNamespacePrefix || null;\n    this.contentType = contentType;\n    this.ignoreFirstLf = ignoreFirstLf;\n    this.preventNamespaceInheritance = preventNamespaceInheritance;\n    this.canSelfClose = canSelfClose ?? isVoid;\n  }\n  isClosedByChild(name) {\n    return this.isVoid || name.toLowerCase() in this.closedByChildren;\n  }\n  getContentType(prefix) {\n    if (typeof this.contentType === 'object') {\n      const overrideType = prefix === undefined ? undefined : this.contentType[prefix];\n      return overrideType ?? this.contentType.default;\n    }\n    return this.contentType;\n  }\n}\nlet DEFAULT_TAG_DEFINITION;\nlet TAG_DEFINITIONS;\nfunction getHtmlTagDefinition(tagName) {\n  if (!TAG_DEFINITIONS) {\n    DEFAULT_TAG_DEFINITION = new HtmlTagDefinition({\n      canSelfClose: true\n    });\n    TAG_DEFINITIONS = Object.assign(Object.create(null), {\n      'base': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'meta': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'area': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'embed': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'link': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'img': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'input': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'param': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'hr': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'br': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'source': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'track': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'wbr': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'p': new HtmlTagDefinition({\n        closedByChildren: ['address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'],\n        closedByParent: true\n      }),\n      'thead': new HtmlTagDefinition({\n        closedByChildren: ['tbody', 'tfoot']\n      }),\n      'tbody': new HtmlTagDefinition({\n        closedByChildren: ['tbody', 'tfoot'],\n        closedByParent: true\n      }),\n      'tfoot': new HtmlTagDefinition({\n        closedByChildren: ['tbody'],\n        closedByParent: true\n      }),\n      'tr': new HtmlTagDefinition({\n        closedByChildren: ['tr'],\n        closedByParent: true\n      }),\n      'td': new HtmlTagDefinition({\n        closedByChildren: ['td', 'th'],\n        closedByParent: true\n      }),\n      'th': new HtmlTagDefinition({\n        closedByChildren: ['td', 'th'],\n        closedByParent: true\n      }),\n      'col': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'svg': new HtmlTagDefinition({\n        implicitNamespacePrefix: 'svg'\n      }),\n      'foreignObject': new HtmlTagDefinition({\n        implicitNamespacePrefix: 'svg',\n        preventNamespaceInheritance: true\n      }),\n      'math': new HtmlTagDefinition({\n        implicitNamespacePrefix: 'math'\n      }),\n      'li': new HtmlTagDefinition({\n        closedByChildren: ['li'],\n        closedByParent: true\n      }),\n      'dt': new HtmlTagDefinition({\n        closedByChildren: ['dt', 'dd']\n      }),\n      'dd': new HtmlTagDefinition({\n        closedByChildren: ['dt', 'dd'],\n        closedByParent: true\n      }),\n      'rb': new HtmlTagDefinition({\n        closedByChildren: ['rb', 'rt', 'rtc', 'rp'],\n        closedByParent: true\n      }),\n      'rt': new HtmlTagDefinition({\n        closedByChildren: ['rb', 'rt', 'rtc', 'rp'],\n        closedByParent: true\n      }),\n      'rtc': new HtmlTagDefinition({\n        closedByChildren: ['rb', 'rtc', 'rp'],\n        closedByParent: true\n      }),\n      'rp': new HtmlTagDefinition({\n        closedByChildren: ['rb', 'rt', 'rtc', 'rp'],\n        closedByParent: true\n      }),\n      'optgroup': new HtmlTagDefinition({\n        closedByChildren: ['optgroup'],\n        closedByParent: true\n      }),\n      'option': new HtmlTagDefinition({\n        closedByChildren: ['option', 'optgroup'],\n        closedByParent: true\n      }),\n      'pre': new HtmlTagDefinition({\n        ignoreFirstLf: true\n      }),\n      'listing': new HtmlTagDefinition({\n        ignoreFirstLf: true\n      }),\n      'style': new HtmlTagDefinition({\n        contentType: TagContentType.RAW_TEXT\n      }),\n      'script': new HtmlTagDefinition({\n        contentType: TagContentType.RAW_TEXT\n      }),\n      'title': new HtmlTagDefinition({\n        contentType: {\n          default: TagContentType.ESCAPABLE_RAW_TEXT,\n          svg: TagContentType.PARSABLE_DATA\n        }\n      }),\n      'textarea': new HtmlTagDefinition({\n        contentType: TagContentType.ESCAPABLE_RAW_TEXT,\n        ignoreFirstLf: true\n      })\n    });\n    new DomElementSchemaRegistry().allKnownElementNames().forEach(knownTagName => {\n      if (!TAG_DEFINITIONS[knownTagName] && getNsPrefix(knownTagName) === null) {\n        TAG_DEFINITIONS[knownTagName] = new HtmlTagDefinition({\n          canSelfClose: false\n        });\n      }\n    });\n  }\n  return TAG_DEFINITIONS[tagName] ?? TAG_DEFINITIONS[tagName.toLowerCase()] ?? DEFAULT_TAG_DEFINITION;\n}\n\nconst TAG_TO_PLACEHOLDER_NAMES = {\n  'A': 'LINK',\n  'B': 'BOLD_TEXT',\n  'BR': 'LINE_BREAK',\n  'EM': 'EMPHASISED_TEXT',\n  'H1': 'HEADING_LEVEL1',\n  'H2': 'HEADING_LEVEL2',\n  'H3': 'HEADING_LEVEL3',\n  'H4': 'HEADING_LEVEL4',\n  'H5': 'HEADING_LEVEL5',\n  'H6': 'HEADING_LEVEL6',\n  'HR': 'HORIZONTAL_RULE',\n  'I': 'ITALIC_TEXT',\n  'LI': 'LIST_ITEM',\n  'LINK': 'MEDIA_LINK',\n  'OL': 'ORDERED_LIST',\n  'P': 'PARAGRAPH',\n  'Q': 'QUOTATION',\n  'S': 'STRIKETHROUGH_TEXT',\n  'SMALL': 'SMALL_TEXT',\n  'SUB': 'SUBSTRIPT',\n  'SUP': 'SUPERSCRIPT',\n  'TBODY': 'TABLE_BODY',\n  'TD': 'TABLE_CELL',\n  'TFOOT': 'TABLE_FOOTER',\n  'TH': 'TABLE_HEADER_CELL',\n  'THEAD': 'TABLE_HEADER',\n  'TR': 'TABLE_ROW',\n  'TT': 'MONOSPACED_TEXT',\n  'U': 'UNDERLINED_TEXT',\n  'UL': 'UNORDERED_LIST'\n};\nclass PlaceholderRegistry {\n  _placeHolderNameCounts = {};\n  _signatureToName = {};\n  getStartTagPlaceholderName(tag, attrs, isVoid) {\n    const signature = this._hashTag(tag, attrs, isVoid);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n    const upperTag = tag.toUpperCase();\n    const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n    const name = this._generateUniqueName(isVoid ? baseName : `START_${baseName}`);\n    this._signatureToName[signature] = name;\n    return name;\n  }\n  getCloseTagPlaceholderName(tag) {\n    const signature = this._hashClosingTag(tag);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n    const upperTag = tag.toUpperCase();\n    const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n    const name = this._generateUniqueName(`CLOSE_${baseName}`);\n    this._signatureToName[signature] = name;\n    return name;\n  }\n  getPlaceholderName(name, content) {\n    const upperName = name.toUpperCase();\n    const signature = `PH: ${upperName}=${content}`;\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n    const uniqueName = this._generateUniqueName(upperName);\n    this._signatureToName[signature] = uniqueName;\n    return uniqueName;\n  }\n  getUniquePlaceholder(name) {\n    return this._generateUniqueName(name.toUpperCase());\n  }\n  getStartBlockPlaceholderName(name, parameters) {\n    const signature = this._hashBlock(name, parameters);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n    const placeholder = this._generateUniqueName(`START_BLOCK_${this._toSnakeCase(name)}`);\n    this._signatureToName[signature] = placeholder;\n    return placeholder;\n  }\n  getCloseBlockPlaceholderName(name) {\n    const signature = this._hashClosingBlock(name);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n    const placeholder = this._generateUniqueName(`CLOSE_BLOCK_${this._toSnakeCase(name)}`);\n    this._signatureToName[signature] = placeholder;\n    return placeholder;\n  }\n  _hashTag(tag, attrs, isVoid) {\n    const start = `<${tag}`;\n    const strAttrs = Object.keys(attrs).sort().map(name => ` ${name}=${attrs[name]}`).join('');\n    const end = isVoid ? '/>' : `></${tag}>`;\n    return start + strAttrs + end;\n  }\n  _hashClosingTag(tag) {\n    return this._hashTag(`/${tag}`, {}, false);\n  }\n  _hashBlock(name, parameters) {\n    const params = parameters.length === 0 ? '' : ` (${parameters.sort().join('; ')})`;\n    return `@${name}${params} {}`;\n  }\n  _hashClosingBlock(name) {\n    return this._hashBlock(`close_${name}`, []);\n  }\n  _toSnakeCase(name) {\n    return name.toUpperCase().replace(/[^A-Z0-9]/g, '_');\n  }\n  _generateUniqueName(base) {\n    const seen = this._placeHolderNameCounts.hasOwnProperty(base);\n    if (!seen) {\n      this._placeHolderNameCounts[base] = 1;\n      return base;\n    }\n    const id = this._placeHolderNameCounts[base];\n    this._placeHolderNameCounts[base] = id + 1;\n    return `${base}_${id}`;\n  }\n}\n\nconst _expParser = new Parser(new Lexer());\nfunction createI18nMessageFactory(containerBlocks, retainEmptyTokens, preserveExpressionWhitespace) {\n  const visitor = new _I18nVisitor(_expParser, containerBlocks, retainEmptyTokens, preserveExpressionWhitespace);\n  return (nodes, meaning, description, customId, visitNodeFn) => visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n}\nfunction noopVisitNodeFn(_html, i18n) {\n  return i18n;\n}\nclass _I18nVisitor {\n  _expressionParser;\n  _containerBlocks;\n  _retainEmptyTokens;\n  _preserveExpressionWhitespace;\n  constructor(_expressionParser, _containerBlocks, _retainEmptyTokens, _preserveExpressionWhitespace) {\n    this._expressionParser = _expressionParser;\n    this._containerBlocks = _containerBlocks;\n    this._retainEmptyTokens = _retainEmptyTokens;\n    this._preserveExpressionWhitespace = _preserveExpressionWhitespace;\n  }\n  toI18nMessage(nodes, meaning = '', description = '', customId = '', visitNodeFn) {\n    const context = {\n      isIcu: nodes.length == 1 && nodes[0] instanceof Expansion,\n      icuDepth: 0,\n      placeholderRegistry: new PlaceholderRegistry(),\n      placeholderToContent: {},\n      placeholderToMessage: {},\n      visitNodeFn: visitNodeFn || noopVisitNodeFn\n    };\n    const i18nodes = visitAll(this, nodes, context);\n    return new Message(i18nodes, context.placeholderToContent, context.placeholderToMessage, meaning, description, customId);\n  }\n  visitElement(el, context) {\n    return this._visitElementLike(el, context);\n  }\n  visitComponent(component, context) {\n    return this._visitElementLike(component, context);\n  }\n  visitDirective(directive, context) {\n    throw new Error('Unreachable code');\n  }\n  visitAttribute(attribute, context) {\n    const node = attribute.valueTokens === undefined || attribute.valueTokens.length === 1 ? new Text$2(attribute.value, attribute.valueSpan || attribute.sourceSpan) : this._visitTextWithInterpolation(attribute.valueTokens, attribute.valueSpan || attribute.sourceSpan, context, attribute.i18n);\n    return context.visitNodeFn(attribute, node);\n  }\n  visitText(text, context) {\n    const node = text.tokens.length === 1 ? new Text$2(text.value, text.sourceSpan) : this._visitTextWithInterpolation(text.tokens, text.sourceSpan, context, text.i18n);\n    return context.visitNodeFn(text, node);\n  }\n  visitComment(comment, context) {\n    return null;\n  }\n  visitExpansion(icu, context) {\n    context.icuDepth++;\n    const i18nIcuCases = {};\n    const i18nIcu = new Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n    icu.cases.forEach(caze => {\n      i18nIcuCases[caze.value] = new Container(caze.expression.map(node => node.visit(this, context)), caze.expSourceSpan);\n    });\n    context.icuDepth--;\n    if (context.isIcu || context.icuDepth > 0) {\n      const expPh = context.placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);\n      i18nIcu.expressionPlaceholder = expPh;\n      context.placeholderToContent[expPh] = {\n        text: icu.switchValue,\n        sourceSpan: icu.switchValueSourceSpan\n      };\n      return context.visitNodeFn(icu, i18nIcu);\n    }\n    const phName = context.placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\n    context.placeholderToMessage[phName] = this.toI18nMessage([icu], '', '', '', undefined);\n    const node = new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n    return context.visitNodeFn(icu, node);\n  }\n  visitExpansionCase(_icuCase, _context) {\n    throw new Error('Unreachable code');\n  }\n  visitBlock(block, context) {\n    const children = visitAll(this, block.children, context);\n    if (this._containerBlocks.has(block.name)) {\n      return new Container(children, block.sourceSpan);\n    }\n    const parameters = block.parameters.map(param => param.expression);\n    const startPhName = context.placeholderRegistry.getStartBlockPlaceholderName(block.name, parameters);\n    const closePhName = context.placeholderRegistry.getCloseBlockPlaceholderName(block.name);\n    context.placeholderToContent[startPhName] = {\n      text: block.startSourceSpan.toString(),\n      sourceSpan: block.startSourceSpan\n    };\n    context.placeholderToContent[closePhName] = {\n      text: block.endSourceSpan ? block.endSourceSpan.toString() : '}',\n      sourceSpan: block.endSourceSpan ?? block.sourceSpan\n    };\n    const node = new BlockPlaceholder(block.name, parameters, startPhName, closePhName, children, block.sourceSpan, block.startSourceSpan, block.endSourceSpan);\n    return context.visitNodeFn(block, node);\n  }\n  visitBlockParameter(_parameter, _context) {\n    throw new Error('Unreachable code');\n  }\n  visitLetDeclaration(decl, context) {\n    return null;\n  }\n  _visitElementLike(node, context) {\n    const children = visitAll(this, node.children, context);\n    const attrs = {};\n    const visitAttribute = attr => {\n      attrs[attr.name] = attr.value;\n    };\n    let nodeName;\n    let isVoid;\n    if (node instanceof Element) {\n      nodeName = node.name;\n      isVoid = getHtmlTagDefinition(node.name).isVoid;\n    } else {\n      nodeName = node.fullName;\n      isVoid = node.tagName ? getHtmlTagDefinition(node.tagName).isVoid : false;\n    }\n    node.attrs.forEach(visitAttribute);\n    node.directives.forEach(dir => dir.attrs.forEach(visitAttribute));\n    const startPhName = context.placeholderRegistry.getStartTagPlaceholderName(nodeName, attrs, isVoid);\n    context.placeholderToContent[startPhName] = {\n      text: node.startSourceSpan.toString(),\n      sourceSpan: node.startSourceSpan\n    };\n    let closePhName = '';\n    if (!isVoid) {\n      closePhName = context.placeholderRegistry.getCloseTagPlaceholderName(nodeName);\n      context.placeholderToContent[closePhName] = {\n        text: `</${nodeName}>`,\n        sourceSpan: node.endSourceSpan ?? node.sourceSpan\n      };\n    }\n    const i18nNode = new TagPlaceholder(nodeName, attrs, startPhName, closePhName, children, isVoid, node.sourceSpan, node.startSourceSpan, node.endSourceSpan);\n    return context.visitNodeFn(node, i18nNode);\n  }\n  _visitTextWithInterpolation(tokens, sourceSpan, context, previousI18n) {\n    const nodes = [];\n    let hasInterpolation = false;\n    for (const token of tokens) {\n      switch (token.type) {\n        case 8:\n        case 17:\n          hasInterpolation = true;\n          const [startMarker, expression, endMarker] = token.parts;\n          const baseName = extractPlaceholderName(expression) || 'INTERPOLATION';\n          const phName = context.placeholderRegistry.getPlaceholderName(baseName, expression);\n          if (this._preserveExpressionWhitespace) {\n            context.placeholderToContent[phName] = {\n              text: token.parts.join(''),\n              sourceSpan: token.sourceSpan\n            };\n            nodes.push(new Placeholder(expression, phName, token.sourceSpan));\n          } else {\n            const normalized = this.normalizeExpression(token);\n            context.placeholderToContent[phName] = {\n              text: `${startMarker}${normalized}${endMarker}`,\n              sourceSpan: token.sourceSpan\n            };\n            nodes.push(new Placeholder(normalized, phName, token.sourceSpan));\n          }\n          break;\n        default:\n          if (token.parts[0].length > 0 || this._retainEmptyTokens) {\n            const previous = nodes[nodes.length - 1];\n            if (previous instanceof Text$2) {\n              previous.value += token.parts[0];\n              previous.sourceSpan = new ParseSourceSpan(previous.sourceSpan.start, token.sourceSpan.end, previous.sourceSpan.fullStart, previous.sourceSpan.details);\n            } else {\n              nodes.push(new Text$2(token.parts[0], token.sourceSpan));\n            }\n          } else {\n            if (this._retainEmptyTokens) {\n              nodes.push(new Text$2(token.parts[0], token.sourceSpan));\n            }\n          }\n          break;\n      }\n    }\n    if (hasInterpolation) {\n      reusePreviousSourceSpans(nodes, previousI18n);\n      return new Container(nodes, sourceSpan);\n    } else {\n      return nodes[0];\n    }\n  }\n  normalizeExpression(token) {\n    const expression = token.parts[1];\n    const expr = this._expressionParser.parseBinding(expression, token.sourceSpan, token.sourceSpan.start.offset);\n    return serialize(expr);\n  }\n}\nfunction reusePreviousSourceSpans(nodes, previousI18n) {\n  if (previousI18n instanceof Message) {\n    assertSingleContainerMessage(previousI18n);\n    previousI18n = previousI18n.nodes[0];\n  }\n  if (previousI18n instanceof Container) {\n    assertEquivalentNodes(previousI18n.children, nodes);\n    for (let i = 0; i < nodes.length; i++) {\n      nodes[i].sourceSpan = previousI18n.children[i].sourceSpan;\n    }\n  }\n}\nfunction assertSingleContainerMessage(message) {\n  const nodes = message.nodes;\n  if (nodes.length !== 1 || !(nodes[0] instanceof Container)) {\n    throw new Error('Unexpected previous i18n message - expected it to consist of only a single `Container` node.');\n  }\n}\nfunction assertEquivalentNodes(previousNodes, nodes) {\n  if (previousNodes.length !== nodes.length) {\n    throw new Error(`\nThe number of i18n message children changed between first and second pass.\n\nFirst pass (${previousNodes.length} tokens):\n${previousNodes.map(node => `\"${node.sourceSpan.toString()}\"`).join('\\n')}\n\nSecond pass (${nodes.length} tokens):\n${nodes.map(node => `\"${node.sourceSpan.toString()}\"`).join('\\n')}\n    `.trim());\n  }\n  if (previousNodes.some((node, i) => nodes[i].constructor !== node.constructor)) {\n    throw new Error('The types of the i18n message children changed between first and second pass.');\n  }\n}\nconst _CUSTOM_PH_EXP = /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\nfunction extractPlaceholderName(input) {\n  return input.split(_CUSTOM_PH_EXP)[2];\n}\n\nconst UNUSABLE_INTERPOLATION_REGEXPS = [/@/, /^\\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\\/\\//];\nfunction assertInterpolationSymbols(identifier, value) {\n  if (value != null && !(Array.isArray(value) && value.length == 2)) {\n    throw new Error(`Expected '${identifier}' to be an array, [start, end].`);\n  } else if (value != null) {\n    const start = value[0];\n    const end = value[1];\n    UNUSABLE_INTERPOLATION_REGEXPS.forEach(regexp => {\n      if (regexp.test(start) || regexp.test(end)) {\n        throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);\n      }\n    });\n  }\n}\n\nclass InterpolationConfig {\n  start;\n  end;\n  static fromArray(markers) {\n    if (!markers) {\n      return DEFAULT_INTERPOLATION_CONFIG;\n    }\n    assertInterpolationSymbols('interpolation', markers);\n    return new InterpolationConfig(markers[0], markers[1]);\n  }\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n}\nconst DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');\nconst DEFAULT_CONTAINER_BLOCKS = new Set(['switch']);\n\nconst TRUSTED_TYPES_SINKS = new Set(['iframe|srcdoc', '*|innerhtml', '*|outerhtml', 'embed|src', 'object|codebase', 'object|data']);\nfunction isTrustedTypesSink(tagName, propName) {\n  tagName = tagName.toLowerCase();\n  propName = propName.toLowerCase();\n  return TRUSTED_TYPES_SINKS.has(tagName + '|' + propName) || TRUSTED_TYPES_SINKS.has('*|' + propName);\n}\n\nconst setI18nRefs = originalNodeMap => {\n  return (trimmedNode, i18nNode) => {\n    const originalNode = originalNodeMap.get(trimmedNode) ?? trimmedNode;\n    if (originalNode instanceof NodeWithI18n) {\n      if (i18nNode instanceof IcuPlaceholder && originalNode.i18n instanceof Message) {\n        i18nNode.previousMessage = originalNode.i18n;\n      }\n      originalNode.i18n = i18nNode;\n    }\n    return i18nNode;\n  };\n};\nclass I18nMetaVisitor {\n  keepI18nAttrs;\n  enableI18nLegacyMessageIdFormat;\n  containerBlocks;\n  preserveSignificantWhitespace;\n  retainEmptyTokens;\n  hasI18nMeta = false;\n  _errors = [];\n  constructor(keepI18nAttrs = false, enableI18nLegacyMessageIdFormat = false, containerBlocks = DEFAULT_CONTAINER_BLOCKS, preserveSignificantWhitespace = true, retainEmptyTokens = !preserveSignificantWhitespace) {\n    this.keepI18nAttrs = keepI18nAttrs;\n    this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat;\n    this.containerBlocks = containerBlocks;\n    this.preserveSignificantWhitespace = preserveSignificantWhitespace;\n    this.retainEmptyTokens = retainEmptyTokens;\n  }\n  _generateI18nMessage(nodes, meta = '', visitNodeFn) {\n    const {\n      meaning,\n      description,\n      customId\n    } = this._parseMetadata(meta);\n    const createI18nMessage = createI18nMessageFactory(this.containerBlocks, this.retainEmptyTokens, this.preserveSignificantWhitespace);\n    const message = createI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n    this._setMessageId(message, meta);\n    this._setLegacyIds(message, meta);\n    return message;\n  }\n  visitAllWithErrors(nodes) {\n    const result = nodes.map(node => node.visit(this, null));\n    return new ParseTreeResult(result, this._errors);\n  }\n  visitElement(element) {\n    this._visitElementLike(element);\n    return element;\n  }\n  visitComponent(component, context) {\n    this._visitElementLike(component);\n    return component;\n  }\n  visitExpansion(expansion, currentMessage) {\n    let message;\n    const meta = expansion.i18n;\n    this.hasI18nMeta = true;\n    if (meta instanceof IcuPlaceholder) {\n      const name = meta.name;\n      message = this._generateI18nMessage([expansion], meta);\n      const icu = icuFromI18nMessage(message);\n      icu.name = name;\n      if (currentMessage !== null) {\n        currentMessage.placeholderToMessage[name] = message;\n      }\n    } else {\n      message = this._generateI18nMessage([expansion], currentMessage || meta);\n    }\n    expansion.i18n = message;\n    return expansion;\n  }\n  visitText(text) {\n    return text;\n  }\n  visitAttribute(attribute) {\n    return attribute;\n  }\n  visitComment(comment) {\n    return comment;\n  }\n  visitExpansionCase(expansionCase) {\n    return expansionCase;\n  }\n  visitBlock(block, context) {\n    visitAll(this, block.children, context);\n    return block;\n  }\n  visitBlockParameter(parameter, context) {\n    return parameter;\n  }\n  visitLetDeclaration(decl, context) {\n    return decl;\n  }\n  visitDirective(directive, context) {\n    return directive;\n  }\n  _visitElementLike(node) {\n    let message = undefined;\n    if (hasI18nAttrs(node)) {\n      this.hasI18nMeta = true;\n      const attrs = [];\n      const attrsMeta = {};\n      for (const attr of node.attrs) {\n        if (attr.name === I18N_ATTR) {\n          const i18n = node.i18n || attr.value;\n          const originalNodeMap = new Map();\n          const trimmedNodes = this.preserveSignificantWhitespace ? node.children : visitAllWithSiblings(new WhitespaceVisitor(false, originalNodeMap), node.children);\n          message = this._generateI18nMessage(trimmedNodes, i18n, setI18nRefs(originalNodeMap));\n          if (message.nodes.length === 0) {\n            message = undefined;\n          }\n          node.i18n = message;\n        } else if (attr.name.startsWith(I18N_ATTR_PREFIX)) {\n          const name = attr.name.slice(I18N_ATTR_PREFIX.length);\n          let isTrustedType;\n          if (node instanceof Component) {\n            isTrustedType = node.tagName === null ? false : isTrustedTypesSink(node.tagName, name);\n          } else {\n            isTrustedType = isTrustedTypesSink(node.name, name);\n          }\n          if (isTrustedType) {\n            this._reportError(attr, `Translating attribute '${name}' is disallowed for security reasons.`);\n          } else {\n            attrsMeta[name] = attr.value;\n          }\n        } else {\n          attrs.push(attr);\n        }\n      }\n      if (Object.keys(attrsMeta).length) {\n        for (const attr of attrs) {\n          const meta = attrsMeta[attr.name];\n          if (meta !== undefined && attr.value) {\n            attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);\n          }\n        }\n      }\n      if (!this.keepI18nAttrs) {\n        node.attrs = attrs;\n      }\n    }\n    visitAll(this, node.children, message);\n  }\n  _parseMetadata(meta) {\n    return typeof meta === 'string' ? parseI18nMeta(meta) : meta instanceof Message ? meta : {};\n  }\n  _setMessageId(message, meta) {\n    if (!message.id) {\n      message.id = meta instanceof Message && meta.id || decimalDigest(message);\n    }\n  }\n  _setLegacyIds(message, meta) {\n    if (this.enableI18nLegacyMessageIdFormat) {\n      message.legacyIds = [computeDigest(message), computeDecimalDigest(message)];\n    } else if (typeof meta !== 'string') {\n      const previousMessage = meta instanceof Message ? meta : meta instanceof IcuPlaceholder ? meta.previousMessage : undefined;\n      message.legacyIds = previousMessage ? previousMessage.legacyIds : [];\n    }\n  }\n  _reportError(node, msg) {\n    this._errors.push(new ParseError(node.sourceSpan, msg));\n  }\n}\nconst I18N_MEANING_SEPARATOR = '|';\nconst I18N_ID_SEPARATOR = '@@';\nfunction parseI18nMeta(meta = '') {\n  let customId;\n  let meaning;\n  let description;\n  meta = meta.trim();\n  if (meta) {\n    const idIndex = meta.indexOf(I18N_ID_SEPARATOR);\n    const descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);\n    let meaningAndDesc;\n    [meaningAndDesc, customId] = idIndex > -1 ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ''];\n    [meaning, description] = descIndex > -1 ? [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] : ['', meaningAndDesc];\n  }\n  return {\n    customId,\n    meaning,\n    description\n  };\n}\nfunction i18nMetaToJSDoc(meta) {\n  const tags = [];\n  if (meta.description) {\n    tags.push({\n      tagName: \"desc\",\n      text: meta.description\n    });\n  } else {\n    tags.push({\n      tagName: \"suppress\",\n      text: '{msgDescriptions}'\n    });\n  }\n  if (meta.meaning) {\n    tags.push({\n      tagName: \"meaning\",\n      text: meta.meaning\n    });\n  }\n  return jsDocComment(tags);\n}\n\nconst GOOG_GET_MSG = 'goog.getMsg';\nfunction createGoogleGetMsgStatements(variable$1, message, closureVar, placeholderValues) {\n  const messageString = serializeI18nMessageForGetMsg(message);\n  const args = [literal(messageString)];\n  if (Object.keys(placeholderValues).length) {\n    args.push(mapLiteral(formatI18nPlaceholderNamesInMap(placeholderValues, true), true));\n    args.push(mapLiteral({\n      original_code: literalMap(Object.keys(placeholderValues).map(param => ({\n        key: formatI18nPlaceholderName(param),\n        quoted: true,\n        value: message.placeholders[param] ? literal(message.placeholders[param].sourceSpan.toString()) : literal(message.placeholderToMessage[param].nodes.map(node => node.sourceSpan.toString()).join(''))\n      })))\n    }));\n  }\n  const googGetMsgStmt = new DeclareVarStmt(closureVar.name, variable(GOOG_GET_MSG).callFn(args), INFERRED_TYPE, StmtModifier.Final);\n  googGetMsgStmt.addLeadingComment(i18nMetaToJSDoc(message));\n  const i18nAssignmentStmt = new ExpressionStatement(variable$1.set(closureVar));\n  return [googGetMsgStmt, i18nAssignmentStmt];\n}\nclass GetMsgSerializerVisitor {\n  formatPh(value) {\n    return `{$${formatI18nPlaceholderName(value)}}`;\n  }\n  visitText(text) {\n    return text.value;\n  }\n  visitContainer(container) {\n    return container.children.map(child => child.visit(this)).join('');\n  }\n  visitIcu(icu) {\n    return serializeIcuNode(icu);\n  }\n  visitTagPlaceholder(ph) {\n    return ph.isVoid ? this.formatPh(ph.startName) : `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;\n  }\n  visitPlaceholder(ph) {\n    return this.formatPh(ph.name);\n  }\n  visitBlockPlaceholder(ph) {\n    return `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;\n  }\n  visitIcuPlaceholder(ph, context) {\n    return this.formatPh(ph.name);\n  }\n}\nconst serializerVisitor = new GetMsgSerializerVisitor();\nfunction serializeI18nMessageForGetMsg(message) {\n  return message.nodes.map(node => node.visit(serializerVisitor, null)).join('');\n}\n\nfunction createLocalizeStatements(variable, message, params) {\n  const {\n    messageParts,\n    placeHolders\n  } = serializeI18nMessageForLocalize(message);\n  const sourceSpan = getSourceSpan(message);\n  const expressions = placeHolders.map(ph => params[ph.text]);\n  const localizedString$1 = localizedString(message, messageParts, placeHolders, expressions, sourceSpan);\n  const variableInitialization = variable.set(localizedString$1);\n  return [new ExpressionStatement(variableInitialization)];\n}\nclass LocalizeSerializerVisitor {\n  placeholderToMessage;\n  pieces;\n  constructor(placeholderToMessage, pieces) {\n    this.placeholderToMessage = placeholderToMessage;\n    this.pieces = pieces;\n  }\n  visitText(text) {\n    if (this.pieces[this.pieces.length - 1] instanceof LiteralPiece) {\n      this.pieces[this.pieces.length - 1].text += text.value;\n    } else {\n      const sourceSpan = new ParseSourceSpan(text.sourceSpan.fullStart, text.sourceSpan.end, text.sourceSpan.fullStart, text.sourceSpan.details);\n      this.pieces.push(new LiteralPiece(text.value, sourceSpan));\n    }\n  }\n  visitContainer(container) {\n    container.children.forEach(child => child.visit(this));\n  }\n  visitIcu(icu) {\n    this.pieces.push(new LiteralPiece(serializeIcuNode(icu), icu.sourceSpan));\n  }\n  visitTagPlaceholder(ph) {\n    this.pieces.push(this.createPlaceholderPiece(ph.startName, ph.startSourceSpan ?? ph.sourceSpan));\n    if (!ph.isVoid) {\n      ph.children.forEach(child => child.visit(this));\n      this.pieces.push(this.createPlaceholderPiece(ph.closeName, ph.endSourceSpan ?? ph.sourceSpan));\n    }\n  }\n  visitPlaceholder(ph) {\n    this.pieces.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));\n  }\n  visitBlockPlaceholder(ph) {\n    this.pieces.push(this.createPlaceholderPiece(ph.startName, ph.startSourceSpan ?? ph.sourceSpan));\n    ph.children.forEach(child => child.visit(this));\n    this.pieces.push(this.createPlaceholderPiece(ph.closeName, ph.endSourceSpan ?? ph.sourceSpan));\n  }\n  visitIcuPlaceholder(ph) {\n    this.pieces.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan, this.placeholderToMessage[ph.name]));\n  }\n  createPlaceholderPiece(name, sourceSpan, associatedMessage) {\n    return new PlaceholderPiece(formatI18nPlaceholderName(name, false), sourceSpan, associatedMessage);\n  }\n}\nfunction serializeI18nMessageForLocalize(message) {\n  const pieces = [];\n  const serializerVisitor = new LocalizeSerializerVisitor(message.placeholderToMessage, pieces);\n  message.nodes.forEach(node => node.visit(serializerVisitor));\n  return processMessagePieces(pieces);\n}\nfunction getSourceSpan(message) {\n  const startNode = message.nodes[0];\n  const endNode = message.nodes[message.nodes.length - 1];\n  return new ParseSourceSpan(startNode.sourceSpan.fullStart, endNode.sourceSpan.end, startNode.sourceSpan.fullStart, startNode.sourceSpan.details);\n}\nfunction processMessagePieces(pieces) {\n  const messageParts = [];\n  const placeHolders = [];\n  if (pieces[0] instanceof PlaceholderPiece) {\n    messageParts.push(createEmptyMessagePart(pieces[0].sourceSpan.start));\n  }\n  for (let i = 0; i < pieces.length; i++) {\n    const part = pieces[i];\n    if (part instanceof LiteralPiece) {\n      messageParts.push(part);\n    } else {\n      placeHolders.push(part);\n      if (pieces[i - 1] instanceof PlaceholderPiece) {\n        messageParts.push(createEmptyMessagePart(pieces[i - 1].sourceSpan.end));\n      }\n    }\n  }\n  if (pieces[pieces.length - 1] instanceof PlaceholderPiece) {\n    messageParts.push(createEmptyMessagePart(pieces[pieces.length - 1].sourceSpan.end));\n  }\n  return {\n    messageParts,\n    placeHolders\n  };\n}\nfunction createEmptyMessagePart(location) {\n  return new LiteralPiece('', new ParseSourceSpan(location, location));\n}\n\nconst NG_I18N_CLOSURE_MODE = 'ngI18nClosureMode';\nconst TRANSLATION_VAR_PREFIX = 'i18n_';\nconst I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';\nconst ESCAPE = '\\uFFFD';\nconst CLOSURE_TRANSLATION_VAR_PREFIX = 'MSG_';\nfunction getTranslationConstPrefix(extra) {\n  return `${CLOSURE_TRANSLATION_VAR_PREFIX}${extra}`.toUpperCase();\n}\nfunction declareI18nVariable(variable) {\n  return new DeclareVarStmt(variable.name, undefined, INFERRED_TYPE, undefined, variable.sourceSpan);\n}\nfunction collectI18nConsts(job) {\n  const fileBasedI18nSuffix = job.relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_').toUpperCase() + '_';\n  const extractedAttributesByI18nContext = new Map();\n  const i18nAttributesByElement = new Map();\n  const i18nExpressionsByElement = new Map();\n  const messages = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind === OpKind.ExtractedAttribute && op.i18nContext !== null) {\n        const attributes = extractedAttributesByI18nContext.get(op.i18nContext) ?? [];\n        attributes.push(op);\n        extractedAttributesByI18nContext.set(op.i18nContext, attributes);\n      } else if (op.kind === OpKind.I18nAttributes) {\n        i18nAttributesByElement.set(op.target, op);\n      } else if (op.kind === OpKind.I18nExpression && op.usage === I18nExpressionFor.I18nAttribute) {\n        const expressions = i18nExpressionsByElement.get(op.target) ?? [];\n        expressions.push(op);\n        i18nExpressionsByElement.set(op.target, expressions);\n      } else if (op.kind === OpKind.I18nMessage) {\n        messages.set(op.xref, op);\n      }\n    }\n  }\n  const i18nValuesByContext = new Map();\n  const messageConstIndices = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.I18nMessage) {\n        if (op.messagePlaceholder === null) {\n          const {\n            mainVar,\n            statements\n          } = collectMessage(job, fileBasedI18nSuffix, messages, op);\n          if (op.i18nBlock !== null) {\n            const i18nConst = job.addConst(mainVar, statements);\n            messageConstIndices.set(op.i18nBlock, i18nConst);\n          } else {\n            job.constsInitializers.push(...statements);\n            i18nValuesByContext.set(op.i18nContext, mainVar);\n            const attributesForMessage = extractedAttributesByI18nContext.get(op.i18nContext);\n            if (attributesForMessage !== undefined) {\n              for (const attr of attributesForMessage) {\n                attr.expression = mainVar.clone();\n              }\n            }\n          }\n        }\n        OpList.remove(op);\n      }\n    }\n  }\n  for (const unit of job.units) {\n    for (const elem of unit.create) {\n      if (isElementOrContainerOp(elem)) {\n        const i18nAttributes = i18nAttributesByElement.get(elem.xref);\n        if (i18nAttributes === undefined) {\n          continue;\n        }\n        let i18nExpressions = i18nExpressionsByElement.get(elem.xref);\n        if (i18nExpressions === undefined) {\n          throw new Error('AssertionError: Could not find any i18n expressions associated with an I18nAttributes instruction');\n        }\n        const seenPropertyNames = new Set();\n        i18nExpressions = i18nExpressions.filter(i18nExpr => {\n          const seen = seenPropertyNames.has(i18nExpr.name);\n          seenPropertyNames.add(i18nExpr.name);\n          return !seen;\n        });\n        const i18nAttributeConfig = i18nExpressions.flatMap(i18nExpr => {\n          const i18nExprValue = i18nValuesByContext.get(i18nExpr.context);\n          if (i18nExprValue === undefined) {\n            throw new Error(\"AssertionError: Could not find i18n expression's value\");\n          }\n          return [literal(i18nExpr.name), i18nExprValue];\n        });\n        i18nAttributes.i18nAttributesConfig = job.addConst(new LiteralArrayExpr(i18nAttributeConfig));\n      }\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.I18nStart) {\n        const msgIndex = messageConstIndices.get(op.root);\n        if (msgIndex === undefined) {\n          throw new Error('AssertionError: Could not find corresponding i18n block index for an i18n message op; was an i18n message incorrectly assumed to correspond to an attribute?');\n        }\n        op.messageIndex = msgIndex;\n      }\n    }\n  }\n}\nfunction collectMessage(job, fileBasedI18nSuffix, messages, messageOp) {\n  const statements = [];\n  const subMessagePlaceholders = new Map();\n  for (const subMessageId of messageOp.subMessages) {\n    const subMessage = messages.get(subMessageId);\n    const {\n      mainVar: subMessageVar,\n      statements: subMessageStatements\n    } = collectMessage(job, fileBasedI18nSuffix, messages, subMessage);\n    statements.push(...subMessageStatements);\n    const subMessages = subMessagePlaceholders.get(subMessage.messagePlaceholder) ?? [];\n    subMessages.push(subMessageVar);\n    subMessagePlaceholders.set(subMessage.messagePlaceholder, subMessages);\n  }\n  addSubMessageParams(messageOp, subMessagePlaceholders);\n  messageOp.params = new Map([...messageOp.params.entries()].sort());\n  const mainVar = variable(job.pool.uniqueName(TRANSLATION_VAR_PREFIX));\n  const closureVar = i18nGenerateClosureVar(job.pool, messageOp.message.id, fileBasedI18nSuffix, job.i18nUseExternalIds);\n  let transformFn = undefined;\n  if (messageOp.needsPostprocessing || messageOp.postprocessingParams.size > 0) {\n    const postprocessingParams = Object.fromEntries([...messageOp.postprocessingParams.entries()].sort());\n    const formattedPostprocessingParams = formatI18nPlaceholderNamesInMap(postprocessingParams, false);\n    const extraTransformFnParams = [];\n    if (messageOp.postprocessingParams.size > 0) {\n      extraTransformFnParams.push(mapLiteral(formattedPostprocessingParams, true));\n    }\n    transformFn = expr => importExpr(Identifiers.i18nPostprocess).callFn([expr, ...extraTransformFnParams]);\n  }\n  statements.push(...getTranslationDeclStmts(messageOp.message, mainVar, closureVar, messageOp.params, transformFn));\n  return {\n    mainVar,\n    statements\n  };\n}\nfunction addSubMessageParams(messageOp, subMessagePlaceholders) {\n  for (const [placeholder, subMessages] of subMessagePlaceholders) {\n    if (subMessages.length === 1) {\n      messageOp.params.set(placeholder, subMessages[0]);\n    } else {\n      messageOp.params.set(placeholder, literal(`${ESCAPE}${I18N_ICU_MAPPING_PREFIX}${placeholder}${ESCAPE}`));\n      messageOp.postprocessingParams.set(placeholder, literalArr(subMessages));\n    }\n  }\n}\nfunction getTranslationDeclStmts(message, variable, closureVar, params, transformFn) {\n  const paramsObject = Object.fromEntries(params);\n  const statements = [declareI18nVariable(variable), ifStmt(createClosureModeGuard(), createGoogleGetMsgStatements(variable, message, closureVar, paramsObject), createLocalizeStatements(variable, message, formatI18nPlaceholderNamesInMap(paramsObject, false)))];\n  if (transformFn) {\n    statements.push(new ExpressionStatement(variable.set(transformFn(variable))));\n  }\n  return statements;\n}\nfunction createClosureModeGuard() {\n  return typeofExpr(variable(NG_I18N_CLOSURE_MODE)).notIdentical(literal('undefined', STRING_TYPE)).and(variable(NG_I18N_CLOSURE_MODE));\n}\nfunction i18nGenerateClosureVar(pool, messageId, fileBasedI18nSuffix, useExternalIds) {\n  let name;\n  const suffix = fileBasedI18nSuffix;\n  if (useExternalIds) {\n    const prefix = getTranslationConstPrefix(`EXTERNAL_`);\n    const uniqueSuffix = pool.uniqueName(suffix);\n    name = `${prefix}${sanitizeIdentifier(messageId)}$$${uniqueSuffix}`;\n  } else {\n    const prefix = getTranslationConstPrefix(suffix);\n    name = pool.uniqueName(prefix);\n  }\n  return variable(name);\n}\n\nfunction convertI18nText(job) {\n  for (const unit of job.units) {\n    let currentI18n = null;\n    let currentIcu = null;\n    const textNodeI18nBlocks = new Map();\n    const textNodeIcus = new Map();\n    const icuPlaceholderByText = new Map();\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nStart:\n          if (op.context === null) {\n            throw Error('I18n op should have its context set.');\n          }\n          currentI18n = op;\n          break;\n        case OpKind.I18nEnd:\n          currentI18n = null;\n          break;\n        case OpKind.IcuStart:\n          if (op.context === null) {\n            throw Error('Icu op should have its context set.');\n          }\n          currentIcu = op;\n          break;\n        case OpKind.IcuEnd:\n          currentIcu = null;\n          break;\n        case OpKind.Text:\n          if (currentI18n !== null) {\n            textNodeI18nBlocks.set(op.xref, currentI18n);\n            textNodeIcus.set(op.xref, currentIcu);\n            if (op.icuPlaceholder !== null) {\n              const icuPlaceholderOp = createIcuPlaceholderOp(job.allocateXrefId(), op.icuPlaceholder, [op.initialValue]);\n              OpList.replace(op, icuPlaceholderOp);\n              icuPlaceholderByText.set(op.xref, icuPlaceholderOp);\n            } else {\n              OpList.remove(op);\n            }\n          }\n          break;\n      }\n    }\n    for (const op of unit.update) {\n      switch (op.kind) {\n        case OpKind.InterpolateText:\n          if (!textNodeI18nBlocks.has(op.target)) {\n            continue;\n          }\n          const i18nOp = textNodeI18nBlocks.get(op.target);\n          const icuOp = textNodeIcus.get(op.target);\n          const icuPlaceholder = icuPlaceholderByText.get(op.target);\n          const contextId = icuOp ? icuOp.context : i18nOp.context;\n          const resolutionTime = icuOp ? I18nParamResolutionTime.Postproccessing : I18nParamResolutionTime.Creation;\n          const ops = [];\n          for (let i = 0; i < op.interpolation.expressions.length; i++) {\n            const expr = op.interpolation.expressions[i];\n            ops.push(createI18nExpressionOp(contextId, i18nOp.xref, i18nOp.xref, i18nOp.handle, expr, icuPlaceholder?.xref ?? null, op.interpolation.i18nPlaceholders[i] ?? null, resolutionTime, I18nExpressionFor.I18nText, '', expr.sourceSpan ?? op.sourceSpan));\n          }\n          OpList.replaceWithMany(op, ops);\n          if (icuPlaceholder !== undefined) {\n            icuPlaceholder.strings = op.interpolation.strings;\n          }\n          break;\n      }\n    }\n  }\n}\n\nfunction liftLocalRefs(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.ElementStart:\n        case OpKind.ConditionalCreate:\n        case OpKind.ConditionalBranchCreate:\n        case OpKind.Template:\n          if (!Array.isArray(op.localRefs)) {\n            throw new Error(`AssertionError: expected localRefs to be an array still`);\n          }\n          op.numSlotsUsed += op.localRefs.length;\n          if (op.localRefs.length > 0) {\n            const localRefs = serializeLocalRefs(op.localRefs);\n            op.localRefs = job.addConst(localRefs);\n          } else {\n            op.localRefs = null;\n          }\n          break;\n      }\n    }\n  }\n}\nfunction serializeLocalRefs(refs) {\n  const constRefs = [];\n  for (const ref of refs) {\n    constRefs.push(literal(ref.name), literal(ref.target));\n  }\n  return literalArr(constRefs);\n}\n\nfunction emitNamespaceChanges(job) {\n  for (const unit of job.units) {\n    let activeNamespace = Namespace.HTML;\n    for (const op of unit.create) {\n      if (op.kind !== OpKind.ElementStart) {\n        continue;\n      }\n      if (op.namespace !== activeNamespace) {\n        OpList.insertBefore(createNamespaceOp(op.namespace), op);\n        activeNamespace = op.namespace;\n      }\n    }\n  }\n}\n\nfunction parse(value) {\n  const styles = [];\n  let i = 0;\n  let parenDepth = 0;\n  let quote = 0;\n  let valueStart = 0;\n  let propStart = 0;\n  let currentProp = null;\n  while (i < value.length) {\n    const token = value.charCodeAt(i++);\n    switch (token) {\n      case 40:\n        parenDepth++;\n        break;\n      case 41:\n        parenDepth--;\n        break;\n      case 39:\n        if (quote === 0) {\n          quote = 39;\n        } else if (quote === 39 && value.charCodeAt(i - 1) !== 92) {\n          quote = 0;\n        }\n        break;\n      case 34:\n        if (quote === 0) {\n          quote = 34;\n        } else if (quote === 34 && value.charCodeAt(i - 1) !== 92) {\n          quote = 0;\n        }\n        break;\n      case 58:\n        if (!currentProp && parenDepth === 0 && quote === 0) {\n          currentProp = hyphenate(value.substring(propStart, i - 1).trim());\n          valueStart = i;\n        }\n        break;\n      case 59:\n        if (currentProp && valueStart > 0 && parenDepth === 0 && quote === 0) {\n          const styleVal = value.substring(valueStart, i - 1).trim();\n          styles.push(currentProp, styleVal);\n          propStart = i;\n          valueStart = 0;\n          currentProp = null;\n        }\n        break;\n    }\n  }\n  if (currentProp && valueStart) {\n    const styleVal = value.slice(valueStart).trim();\n    styles.push(currentProp, styleVal);\n  }\n  return styles;\n}\nfunction hyphenate(value) {\n  return value.replace(/[a-z][A-Z]/g, v => {\n    return v.charAt(0) + '-' + v.charAt(1);\n  }).toLowerCase();\n}\nfunction parseExtractedStyles(job) {\n  const elements = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (isElementOrContainerOp(op)) {\n        elements.set(op.xref, op);\n      }\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.ExtractedAttribute && op.bindingKind === BindingKind.Attribute && isStringLiteral(op.expression)) {\n        const target = elements.get(op.target);\n        if (target !== undefined && (target.kind === OpKind.Template || target.kind === OpKind.ConditionalCreate || target.kind === OpKind.ConditionalBranchCreate) && target.templateKind === TemplateKind.Structural) {\n          continue;\n        }\n        if (op.name === 'style') {\n          const parsedStyles = parse(op.expression.value);\n          for (let i = 0; i < parsedStyles.length - 1; i += 2) {\n            OpList.insertBefore(createExtractedAttributeOp(op.target, BindingKind.StyleProperty, null, parsedStyles[i], literal(parsedStyles[i + 1]), null, null, SecurityContext.STYLE), op);\n          }\n          OpList.remove(op);\n        } else if (op.name === 'class') {\n          const parsedClasses = op.expression.value.trim().split(/\\s+/g);\n          for (const parsedClass of parsedClasses) {\n            OpList.insertBefore(createExtractedAttributeOp(op.target, BindingKind.ClassName, null, parsedClass, null, null, null, SecurityContext.NONE), op);\n          }\n          OpList.remove(op);\n        }\n      }\n    }\n  }\n}\n\nfunction nameFunctionsAndVariables(job) {\n  addNamesToView(job.root, job.componentName, {\n    index: 0\n  }, job.compatibility === CompatibilityMode.TemplateDefinitionBuilder);\n}\nfunction addNamesToView(unit, baseName, state, compatibility) {\n  if (unit.fnName === null) {\n    unit.fnName = unit.job.pool.uniqueName(sanitizeIdentifier(`${baseName}_${unit.job.fnSuffix}`), false);\n  }\n  const varNames = new Map();\n  for (const op of unit.ops()) {\n    switch (op.kind) {\n      case OpKind.Property:\n      case OpKind.DomProperty:\n        if (op.bindingKind === BindingKind.LegacyAnimation) {\n          op.name = '@' + op.name;\n        }\n        break;\n      case OpKind.Animation:\n        if (op.handlerFnName === null) {\n          const animationKind = op.name.replace('.', '');\n          op.handlerFnName = `${unit.fnName}_${animationKind}_cb`;\n          op.handlerFnName = sanitizeIdentifier(op.handlerFnName);\n        }\n        break;\n      case OpKind.AnimationListener:\n        if (op.handlerFnName !== null) {\n          break;\n        }\n        if (!op.hostListener && op.targetSlot.slot === null) {\n          throw new Error(`Expected a slot to be assigned`);\n        }\n        const animationKind = op.name.replace('.', '');\n        if (op.hostListener) {\n          op.handlerFnName = `${baseName}_${animationKind}_HostBindingHandler`;\n        } else {\n          op.handlerFnName = `${unit.fnName}_${op.tag.replace('-', '_')}_${animationKind}_${op.targetSlot.slot}_listener`;\n        }\n        op.handlerFnName = sanitizeIdentifier(op.handlerFnName);\n        break;\n      case OpKind.Listener:\n        if (op.handlerFnName !== null) {\n          break;\n        }\n        if (!op.hostListener && op.targetSlot.slot === null) {\n          throw new Error(`Expected a slot to be assigned`);\n        }\n        let animation = '';\n        if (op.isLegacyAnimationListener) {\n          op.name = `@${op.name}.${op.legacyAnimationPhase}`;\n          animation = 'animation';\n        }\n        if (op.hostListener) {\n          op.handlerFnName = `${baseName}_${animation}${op.name}_HostBindingHandler`;\n        } else {\n          op.handlerFnName = `${unit.fnName}_${op.tag.replace('-', '_')}_${animation}${op.name}_${op.targetSlot.slot}_listener`;\n        }\n        op.handlerFnName = sanitizeIdentifier(op.handlerFnName);\n        break;\n      case OpKind.TwoWayListener:\n        if (op.handlerFnName !== null) {\n          break;\n        }\n        if (op.targetSlot.slot === null) {\n          throw new Error(`Expected a slot to be assigned`);\n        }\n        op.handlerFnName = sanitizeIdentifier(`${unit.fnName}_${op.tag.replace('-', '_')}_${op.name}_${op.targetSlot.slot}_listener`);\n        break;\n      case OpKind.Variable:\n        varNames.set(op.xref, getVariableName(unit, op.variable, state));\n        break;\n      case OpKind.RepeaterCreate:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        if (op.handle.slot === null) {\n          throw new Error(`Expected slot to be assigned`);\n        }\n        if (op.emptyView !== null) {\n          const emptyView = unit.job.views.get(op.emptyView);\n          addNamesToView(emptyView, `${baseName}_${op.functionNameSuffix}Empty_${op.handle.slot + 2}`, state, compatibility);\n        }\n        addNamesToView(unit.job.views.get(op.xref), `${baseName}_${op.functionNameSuffix}_${op.handle.slot + 1}`, state, compatibility);\n        break;\n      case OpKind.Projection:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        if (op.handle.slot === null) {\n          throw new Error(`Expected slot to be assigned`);\n        }\n        if (op.fallbackView !== null) {\n          const fallbackView = unit.job.views.get(op.fallbackView);\n          addNamesToView(fallbackView, `${baseName}_ProjectionFallback_${op.handle.slot}`, state, compatibility);\n        }\n        break;\n      case OpKind.ConditionalCreate:\n      case OpKind.ConditionalBranchCreate:\n      case OpKind.Template:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        const childView = unit.job.views.get(op.xref);\n        if (op.handle.slot === null) {\n          throw new Error(`Expected slot to be assigned`);\n        }\n        const suffix = op.functionNameSuffix.length === 0 ? '' : `_${op.functionNameSuffix}`;\n        addNamesToView(childView, `${baseName}${suffix}_${op.handle.slot}`, state, compatibility);\n        break;\n      case OpKind.StyleProp:\n        op.name = normalizeStylePropName(op.name);\n        if (compatibility) {\n          op.name = stripImportant(op.name);\n        }\n        break;\n      case OpKind.ClassProp:\n        if (compatibility) {\n          op.name = stripImportant(op.name);\n        }\n        break;\n    }\n  }\n  for (const op of unit.ops()) {\n    visitExpressionsInOp(op, expr => {\n      if (!(expr instanceof ReadVariableExpr) || expr.name !== null) {\n        return;\n      }\n      if (!varNames.has(expr.xref)) {\n        throw new Error(`Variable ${expr.xref} not yet named`);\n      }\n      expr.name = varNames.get(expr.xref);\n    });\n  }\n}\nfunction getVariableName(unit, variable, state) {\n  if (variable.name === null) {\n    switch (variable.kind) {\n      case SemanticVariableKind.Context:\n        variable.name = `ctx_r${state.index++}`;\n        break;\n      case SemanticVariableKind.Identifier:\n        if (unit.job.compatibility === CompatibilityMode.TemplateDefinitionBuilder) {\n          const compatPrefix = variable.identifier === 'ctx' ? 'i' : '';\n          variable.name = `${variable.identifier}_${compatPrefix}r${++state.index}`;\n        } else {\n          variable.name = `${variable.identifier}_i${state.index++}`;\n        }\n        break;\n      default:\n        variable.name = `_r${++state.index}`;\n        break;\n    }\n  }\n  return variable.name;\n}\nfunction normalizeStylePropName(name) {\n  return name.startsWith('--') ? name : hyphenate(name);\n}\nfunction stripImportant(name) {\n  const importantIndex = name.indexOf('!important');\n  if (importantIndex > -1) {\n    return name.substring(0, importantIndex);\n  }\n  return name;\n}\n\nfunction mergeNextContextExpressions(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.Listener || op.kind === OpKind.Animation || op.kind === OpKind.AnimationListener || op.kind === OpKind.TwoWayListener) {\n        mergeNextContextsInOps(op.handlerOps);\n      }\n    }\n    mergeNextContextsInOps(unit.update);\n  }\n}\nfunction mergeNextContextsInOps(ops) {\n  for (const op of ops) {\n    if (op.kind !== OpKind.Statement || !(op.statement instanceof ExpressionStatement) || !(op.statement.expr instanceof NextContextExpr)) {\n      continue;\n    }\n    const mergeSteps = op.statement.expr.steps;\n    let tryToMerge = true;\n    for (let candidate = op.next; candidate.kind !== OpKind.ListEnd && tryToMerge; candidate = candidate.next) {\n      visitExpressionsInOp(candidate, (expr, flags) => {\n        if (!isIrExpression(expr)) {\n          return expr;\n        }\n        if (!tryToMerge) {\n          return;\n        }\n        if (flags & VisitorContextFlag.InChildOperation) {\n          return;\n        }\n        switch (expr.kind) {\n          case ExpressionKind.NextContext:\n            expr.steps += mergeSteps;\n            OpList.remove(op);\n            tryToMerge = false;\n            break;\n          case ExpressionKind.GetCurrentView:\n          case ExpressionKind.Reference:\n          case ExpressionKind.ContextLetReference:\n            tryToMerge = false;\n            break;\n        }\n        return;\n      });\n    }\n  }\n}\n\nconst CONTAINER_TAG = 'ng-container';\nfunction generateNgContainerOps(job) {\n  for (const unit of job.units) {\n    const updatedElementXrefs = new Set();\n    for (const op of unit.create) {\n      if (op.kind === OpKind.ElementStart && op.tag === CONTAINER_TAG) {\n        op.kind = OpKind.ContainerStart;\n        updatedElementXrefs.add(op.xref);\n      }\n      if (op.kind === OpKind.ElementEnd && updatedElementXrefs.has(op.xref)) {\n        op.kind = OpKind.ContainerEnd;\n      }\n    }\n  }\n}\n\nfunction lookupElement(elements, xref) {\n  const el = elements.get(xref);\n  if (el === undefined) {\n    throw new Error('All attributes should have an element-like target.');\n  }\n  return el;\n}\nfunction disableBindings$1(job) {\n  const elements = new Map();\n  for (const view of job.units) {\n    for (const op of view.create) {\n      if (!isElementOrContainerOp(op)) {\n        continue;\n      }\n      elements.set(op.xref, op);\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if ((op.kind === OpKind.ElementStart || op.kind === OpKind.ContainerStart) && op.nonBindable) {\n        OpList.insertAfter(createDisableBindingsOp(op.xref), op);\n      }\n      if ((op.kind === OpKind.ElementEnd || op.kind === OpKind.ContainerEnd) && lookupElement(elements, op.xref).nonBindable) {\n        OpList.insertBefore(createEnableBindingsOp(op.xref), op);\n      }\n    }\n  }\n}\n\nfunction kindTest(kind) {\n  return op => op.kind === kind;\n}\nfunction kindWithInterpolationTest(kind, interpolation) {\n  return op => {\n    return op.kind === kind && interpolation === op.expression instanceof Interpolation;\n  };\n}\nfunction basicListenerKindTest(op) {\n  return op.kind === OpKind.Listener && !(op.hostListener && op.isLegacyAnimationListener) || op.kind === OpKind.TwoWayListener || op.kind === OpKind.Animation || op.kind === OpKind.AnimationListener;\n}\nfunction nonInterpolationPropertyKindTest(op) {\n  return (op.kind === OpKind.Property || op.kind === OpKind.TwoWayProperty) && !(op.expression instanceof Interpolation);\n}\nconst CREATE_ORDERING = [{\n  test: op => op.kind === OpKind.Listener && op.hostListener && op.isLegacyAnimationListener\n}, {\n  test: basicListenerKindTest\n}];\nconst UPDATE_ORDERING = [{\n  test: kindTest(OpKind.StyleMap),\n  transform: keepLast\n}, {\n  test: kindTest(OpKind.ClassMap),\n  transform: keepLast\n}, {\n  test: kindTest(OpKind.StyleProp)\n}, {\n  test: kindTest(OpKind.ClassProp)\n}, {\n  test: kindWithInterpolationTest(OpKind.Attribute, true)\n}, {\n  test: kindWithInterpolationTest(OpKind.Property, true)\n}, {\n  test: nonInterpolationPropertyKindTest\n}, {\n  test: kindWithInterpolationTest(OpKind.Attribute, false)\n}];\nconst UPDATE_HOST_ORDERING = [{\n  test: kindWithInterpolationTest(OpKind.DomProperty, true)\n}, {\n  test: kindWithInterpolationTest(OpKind.DomProperty, false)\n}, {\n  test: kindTest(OpKind.Attribute)\n}, {\n  test: kindTest(OpKind.StyleMap),\n  transform: keepLast\n}, {\n  test: kindTest(OpKind.ClassMap),\n  transform: keepLast\n}, {\n  test: kindTest(OpKind.StyleProp)\n}, {\n  test: kindTest(OpKind.ClassProp)\n}];\nconst handledOpKinds = new Set([OpKind.Listener, OpKind.TwoWayListener, OpKind.AnimationListener, OpKind.StyleMap, OpKind.ClassMap, OpKind.StyleProp, OpKind.ClassProp, OpKind.Property, OpKind.TwoWayProperty, OpKind.DomProperty, OpKind.Attribute, OpKind.Animation]);\nfunction orderOps(job) {\n  for (const unit of job.units) {\n    orderWithin(unit.create, CREATE_ORDERING);\n    const ordering = unit.job.kind === CompilationJobKind.Host ? UPDATE_HOST_ORDERING : UPDATE_ORDERING;\n    orderWithin(unit.update, ordering);\n  }\n}\nfunction orderWithin(opList, ordering) {\n  let opsToOrder = [];\n  let firstTargetInGroup = null;\n  for (const op of opList) {\n    const currentTarget = hasDependsOnSlotContextTrait(op) ? op.target : null;\n    if (!handledOpKinds.has(op.kind) || currentTarget !== firstTargetInGroup && firstTargetInGroup !== null && currentTarget !== null) {\n      OpList.insertBefore(reorder(opsToOrder, ordering), op);\n      opsToOrder = [];\n      firstTargetInGroup = null;\n    }\n    if (handledOpKinds.has(op.kind)) {\n      opsToOrder.push(op);\n      OpList.remove(op);\n      firstTargetInGroup = currentTarget ?? firstTargetInGroup;\n    }\n  }\n  opList.push(reorder(opsToOrder, ordering));\n}\nfunction reorder(ops, ordering) {\n  const groups = Array.from(ordering, () => new Array());\n  for (const op of ops) {\n    const groupIndex = ordering.findIndex(o => o.test(op));\n    groups[groupIndex].push(op);\n  }\n  return groups.flatMap((group, i) => {\n    const transform = ordering[i].transform;\n    return transform ? transform(group) : group;\n  });\n}\nfunction keepLast(ops) {\n  return ops.slice(ops.length - 1);\n}\n\nfunction removeContentSelectors(job) {\n  for (const unit of job.units) {\n    const elements = createOpXrefMap(unit);\n    for (const op of unit.ops()) {\n      switch (op.kind) {\n        case OpKind.Binding:\n          const target = lookupInXrefMap(elements, op.target);\n          if (isSelectAttribute(op.name) && target.kind === OpKind.Projection) {\n            OpList.remove(op);\n          }\n          break;\n      }\n    }\n  }\n}\nfunction isSelectAttribute(name) {\n  return name.toLowerCase() === 'select';\n}\nfunction lookupInXrefMap(map, xref) {\n  const el = map.get(xref);\n  if (el === undefined) {\n    throw new Error('All attributes should have an slottable target.');\n  }\n  return el;\n}\n\nfunction createPipes(job) {\n  for (const unit of job.units) {\n    processPipeBindingsInView(unit);\n  }\n}\nfunction processPipeBindingsInView(unit) {\n  for (const updateOp of unit.update) {\n    visitExpressionsInOp(updateOp, (expr, flags) => {\n      if (!isIrExpression(expr)) {\n        return;\n      }\n      if (expr.kind !== ExpressionKind.PipeBinding) {\n        return;\n      }\n      if (flags & VisitorContextFlag.InChildOperation) {\n        throw new Error(`AssertionError: pipe bindings should not appear in child expressions`);\n      }\n      if (unit.job.compatibility) {\n        const slotHandle = updateOp.target;\n        if (slotHandle == undefined) {\n          throw new Error(`AssertionError: expected slot handle to be assigned for pipe creation`);\n        }\n        addPipeToCreationBlock(unit, updateOp.target, expr);\n      } else {\n        unit.create.push(createPipeOp(expr.target, expr.targetSlot, expr.name));\n      }\n    });\n  }\n}\nfunction addPipeToCreationBlock(unit, afterTargetXref, binding) {\n  for (let op = unit.create.head.next; op.kind !== OpKind.ListEnd; op = op.next) {\n    if (!hasConsumesSlotTrait(op)) {\n      continue;\n    }\n    if (op.xref !== afterTargetXref) {\n      continue;\n    }\n    while (op.next.kind === OpKind.Pipe) {\n      op = op.next;\n    }\n    const pipe = createPipeOp(binding.target, binding.targetSlot, binding.name);\n    OpList.insertBefore(pipe, op.next);\n    return;\n  }\n  throw new Error(`AssertionError: unable to find insertion point for pipe ${binding.name}`);\n}\n\nfunction createVariadicPipes(job) {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      transformExpressionsInOp(op, expr => {\n        if (!(expr instanceof PipeBindingExpr)) {\n          return expr;\n        }\n        if (expr.args.length <= 4) {\n          return expr;\n        }\n        return new PipeBindingVariadicExpr(expr.target, expr.targetSlot, expr.name, literalArr(expr.args), expr.args.length);\n      }, VisitorContextFlag.None);\n    }\n  }\n}\n\nfunction propagateI18nBlocks(job) {\n  propagateI18nBlocksToTemplates(job.root, 0);\n}\nfunction propagateI18nBlocksToTemplates(unit, subTemplateIndex) {\n  let i18nBlock = null;\n  for (const op of unit.create) {\n    switch (op.kind) {\n      case OpKind.I18nStart:\n        op.subTemplateIndex = subTemplateIndex === 0 ? null : subTemplateIndex;\n        i18nBlock = op;\n        break;\n      case OpKind.I18nEnd:\n        if (i18nBlock.subTemplateIndex === null) {\n          subTemplateIndex = 0;\n        }\n        i18nBlock = null;\n        break;\n      case OpKind.ConditionalCreate:\n      case OpKind.ConditionalBranchCreate:\n      case OpKind.Template:\n        subTemplateIndex = propagateI18nBlocksForView(unit.job.views.get(op.xref), i18nBlock, op.i18nPlaceholder, subTemplateIndex);\n        break;\n      case OpKind.RepeaterCreate:\n        const forView = unit.job.views.get(op.xref);\n        subTemplateIndex = propagateI18nBlocksForView(forView, i18nBlock, op.i18nPlaceholder, subTemplateIndex);\n        if (op.emptyView !== null) {\n          subTemplateIndex = propagateI18nBlocksForView(unit.job.views.get(op.emptyView), i18nBlock, op.emptyI18nPlaceholder, subTemplateIndex);\n        }\n        break;\n      case OpKind.Projection:\n        if (op.fallbackView !== null) {\n          subTemplateIndex = propagateI18nBlocksForView(unit.job.views.get(op.fallbackView), i18nBlock, op.fallbackViewI18nPlaceholder, subTemplateIndex);\n        }\n        break;\n    }\n  }\n  return subTemplateIndex;\n}\nfunction propagateI18nBlocksForView(view, i18nBlock, i18nPlaceholder, subTemplateIndex) {\n  if (i18nPlaceholder !== undefined) {\n    if (i18nBlock === null) {\n      throw Error('Expected template with i18n placeholder to be in an i18n block.');\n    }\n    subTemplateIndex++;\n    wrapTemplateWithI18n(view, i18nBlock);\n  }\n  return propagateI18nBlocksToTemplates(view, subTemplateIndex);\n}\nfunction wrapTemplateWithI18n(unit, parentI18n) {\n  if (unit.create.head.next?.kind !== OpKind.I18nStart) {\n    const id = unit.job.allocateXrefId();\n    OpList.insertAfter(createI18nStartOp(id, parentI18n.message, parentI18n.root, null), unit.create.head);\n    OpList.insertBefore(createI18nEndOp(id, null), unit.create.tail);\n  }\n}\n\nfunction extractPureFunctions(job) {\n  for (const view of job.units) {\n    for (const op of view.ops()) {\n      visitExpressionsInOp(op, expr => {\n        if (!(expr instanceof PureFunctionExpr) || expr.body === null) {\n          return;\n        }\n        const constantDef = new PureFunctionConstant(expr.args.length);\n        expr.fn = job.pool.getSharedConstant(constantDef, expr.body);\n        expr.body = null;\n      });\n    }\n  }\n}\nclass PureFunctionConstant extends GenericKeyFn {\n  numArgs;\n  constructor(numArgs) {\n    super();\n    this.numArgs = numArgs;\n  }\n  keyOf(expr) {\n    if (expr instanceof PureFunctionParameterExpr) {\n      return `param(${expr.index})`;\n    } else {\n      return super.keyOf(expr);\n    }\n  }\n  toSharedConstantDeclaration(declName, keyExpr) {\n    const fnParams = [];\n    for (let idx = 0; idx < this.numArgs; idx++) {\n      fnParams.push(new FnParam('a' + idx));\n    }\n    const returnExpr = transformExpressionsInExpression(keyExpr, expr => {\n      if (!(expr instanceof PureFunctionParameterExpr)) {\n        return expr;\n      }\n      return variable('a' + expr.index);\n    }, VisitorContextFlag.None);\n    return new DeclareVarStmt(declName, new ArrowFunctionExpr(fnParams, returnExpr), undefined, StmtModifier.Final);\n  }\n}\n\nfunction generatePureLiteralStructures(job) {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      transformExpressionsInOp(op, (expr, flags) => {\n        if (flags & VisitorContextFlag.InChildOperation) {\n          return expr;\n        }\n        if (expr instanceof LiteralArrayExpr) {\n          return transformLiteralArray(expr);\n        } else if (expr instanceof LiteralMapExpr) {\n          return transformLiteralMap(expr);\n        }\n        return expr;\n      }, VisitorContextFlag.None);\n    }\n  }\n}\nfunction transformLiteralArray(expr) {\n  const derivedEntries = [];\n  const nonConstantArgs = [];\n  for (const entry of expr.entries) {\n    if (entry.isConstant()) {\n      derivedEntries.push(entry);\n    } else {\n      const idx = nonConstantArgs.length;\n      nonConstantArgs.push(entry);\n      derivedEntries.push(new PureFunctionParameterExpr(idx));\n    }\n  }\n  return new PureFunctionExpr(literalArr(derivedEntries), nonConstantArgs);\n}\nfunction transformLiteralMap(expr) {\n  let derivedEntries = [];\n  const nonConstantArgs = [];\n  for (const entry of expr.entries) {\n    if (entry.value.isConstant()) {\n      derivedEntries.push(entry);\n    } else {\n      const idx = nonConstantArgs.length;\n      nonConstantArgs.push(entry.value);\n      derivedEntries.push(new LiteralMapEntry(entry.key, new PureFunctionParameterExpr(idx), entry.quoted));\n    }\n  }\n  return new PureFunctionExpr(literalMap(derivedEntries), nonConstantArgs);\n}\n\nfunction optimizeRegularExpressions(job) {\n  for (const view of job.units) {\n    for (const op of view.ops()) {\n      transformExpressionsInOp(op, expr => {\n        if (expr instanceof RegularExpressionLiteralExpr && (expr.flags === null || !expr.flags.includes('g'))) {\n          return job.pool.getSharedConstant(new RegularExpressionConstant(), expr);\n        }\n        return expr;\n      }, VisitorContextFlag.None);\n    }\n  }\n}\nclass RegularExpressionConstant extends GenericKeyFn {\n  toSharedConstantDeclaration(declName, keyExpr) {\n    return new DeclareVarStmt(declName, keyExpr, undefined, StmtModifier.Final);\n  }\n}\n\nfunction element(slot, tag, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.element, slot, tag, constIndex, localRefIndex, sourceSpan);\n}\nfunction elementStart(slot, tag, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.elementStart, slot, tag, constIndex, localRefIndex, sourceSpan);\n}\nfunction elementOrContainerBase(instruction, slot, tag, constIndex, localRefIndex, sourceSpan) {\n  const args = [literal(slot)];\n  if (tag !== null) {\n    args.push(literal(tag));\n  }\n  if (localRefIndex !== null) {\n    args.push(literal(constIndex), literal(localRefIndex));\n  } else if (constIndex !== null) {\n    args.push(literal(constIndex));\n  }\n  return call(instruction, args, sourceSpan);\n}\nfunction templateBase(instruction, slot, templateFnRef, decls, vars, tag, constIndex, localRefs, sourceSpan) {\n  const args = [literal(slot), templateFnRef, literal(decls), literal(vars), literal(tag), literal(constIndex)];\n  if (localRefs !== null) {\n    args.push(literal(localRefs));\n    args.push(importExpr(Identifiers.templateRefExtractor));\n  }\n  while (args[args.length - 1].isEquivalent(NULL_EXPR)) {\n    args.pop();\n  }\n  return call(instruction, args, sourceSpan);\n}\nfunction propertyBase(instruction, name, expression, sanitizer, sourceSpan) {\n  const args = [literal(name)];\n  if (expression instanceof Interpolation) {\n    args.push(interpolationToExpression(expression, sourceSpan));\n  } else {\n    args.push(expression);\n  }\n  if (sanitizer !== null) {\n    args.push(sanitizer);\n  }\n  return call(instruction, args, sourceSpan);\n}\nfunction elementEnd(sourceSpan) {\n  return call(Identifiers.elementEnd, [], sourceSpan);\n}\nfunction elementContainerStart(slot, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.elementContainerStart, slot, null, constIndex, localRefIndex, sourceSpan);\n}\nfunction elementContainer(slot, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.elementContainer, slot, null, constIndex, localRefIndex, sourceSpan);\n}\nfunction elementContainerEnd() {\n  return call(Identifiers.elementContainerEnd, [], null);\n}\nfunction template(slot, templateFnRef, decls, vars, tag, constIndex, localRefs, sourceSpan) {\n  return templateBase(Identifiers.templateCreate, slot, templateFnRef, decls, vars, tag, constIndex, localRefs, sourceSpan);\n}\nfunction disableBindings() {\n  return call(Identifiers.disableBindings, [], null);\n}\nfunction enableBindings() {\n  return call(Identifiers.enableBindings, [], null);\n}\nfunction listener(name, handlerFn, eventTargetResolver, syntheticHost, sourceSpan) {\n  const args = [literal(name), handlerFn];\n  if (eventTargetResolver !== null) {\n    args.push(importExpr(eventTargetResolver));\n  }\n  return call(syntheticHost ? Identifiers.syntheticHostListener : Identifiers.listener, args, sourceSpan);\n}\nfunction twoWayBindingSet(target, value) {\n  return importExpr(Identifiers.twoWayBindingSet).callFn([target, value]);\n}\nfunction twoWayListener(name, handlerFn, sourceSpan) {\n  return call(Identifiers.twoWayListener, [literal(name), handlerFn], sourceSpan);\n}\nfunction pipe(slot, name) {\n  return call(Identifiers.pipe, [literal(slot), literal(name)], null);\n}\nfunction namespaceHTML() {\n  return call(Identifiers.namespaceHTML, [], null);\n}\nfunction namespaceSVG() {\n  return call(Identifiers.namespaceSVG, [], null);\n}\nfunction namespaceMath() {\n  return call(Identifiers.namespaceMathML, [], null);\n}\nfunction advance(delta, sourceSpan) {\n  return call(Identifiers.advance, delta > 1 ? [literal(delta)] : [], sourceSpan);\n}\nfunction reference(slot) {\n  return importExpr(Identifiers.reference).callFn([literal(slot)]);\n}\nfunction nextContext(steps) {\n  return importExpr(Identifiers.nextContext).callFn(steps === 1 ? [] : [literal(steps)]);\n}\nfunction getCurrentView() {\n  return importExpr(Identifiers.getCurrentView).callFn([]);\n}\nfunction restoreView(savedView) {\n  return importExpr(Identifiers.restoreView).callFn([savedView]);\n}\nfunction resetView(returnValue) {\n  return importExpr(Identifiers.resetView).callFn([returnValue]);\n}\nfunction text(slot, initialValue, sourceSpan) {\n  const args = [literal(slot, null)];\n  if (initialValue !== '') {\n    args.push(literal(initialValue));\n  }\n  return call(Identifiers.text, args, sourceSpan);\n}\nfunction defer(selfSlot, primarySlot, dependencyResolverFn, loadingSlot, placeholderSlot, errorSlot, loadingConfig, placeholderConfig, enableTimerScheduling, sourceSpan, flags) {\n  const args = [literal(selfSlot), literal(primarySlot), dependencyResolverFn ?? literal(null), literal(loadingSlot), literal(placeholderSlot), literal(errorSlot), loadingConfig ?? literal(null), placeholderConfig ?? literal(null), enableTimerScheduling ? importExpr(Identifiers.deferEnableTimerScheduling) : literal(null), literal(flags)];\n  let expr;\n  while ((expr = args[args.length - 1]) !== null && expr instanceof LiteralExpr && expr.value === null) {\n    args.pop();\n  }\n  return call(Identifiers.defer, args, sourceSpan);\n}\nconst deferTriggerToR3TriggerInstructionsMap = new Map([[DeferTriggerKind.Idle, {\n  [\"none\"]: Identifiers.deferOnIdle,\n  [\"prefetch\"]: Identifiers.deferPrefetchOnIdle,\n  [\"hydrate\"]: Identifiers.deferHydrateOnIdle\n}], [DeferTriggerKind.Immediate, {\n  [\"none\"]: Identifiers.deferOnImmediate,\n  [\"prefetch\"]: Identifiers.deferPrefetchOnImmediate,\n  [\"hydrate\"]: Identifiers.deferHydrateOnImmediate\n}], [DeferTriggerKind.Timer, {\n  [\"none\"]: Identifiers.deferOnTimer,\n  [\"prefetch\"]: Identifiers.deferPrefetchOnTimer,\n  [\"hydrate\"]: Identifiers.deferHydrateOnTimer\n}], [DeferTriggerKind.Hover, {\n  [\"none\"]: Identifiers.deferOnHover,\n  [\"prefetch\"]: Identifiers.deferPrefetchOnHover,\n  [\"hydrate\"]: Identifiers.deferHydrateOnHover\n}], [DeferTriggerKind.Interaction, {\n  [\"none\"]: Identifiers.deferOnInteraction,\n  [\"prefetch\"]: Identifiers.deferPrefetchOnInteraction,\n  [\"hydrate\"]: Identifiers.deferHydrateOnInteraction\n}], [DeferTriggerKind.Viewport, {\n  [\"none\"]: Identifiers.deferOnViewport,\n  [\"prefetch\"]: Identifiers.deferPrefetchOnViewport,\n  [\"hydrate\"]: Identifiers.deferHydrateOnViewport\n}], [DeferTriggerKind.Never, {\n  [\"none\"]: Identifiers.deferHydrateNever,\n  [\"prefetch\"]: Identifiers.deferHydrateNever,\n  [\"hydrate\"]: Identifiers.deferHydrateNever\n}]]);\nfunction deferOn(trigger, args, modifier, sourceSpan) {\n  const instructionToCall = deferTriggerToR3TriggerInstructionsMap.get(trigger)?.[modifier];\n  if (instructionToCall === undefined) {\n    throw new Error(`Unable to determine instruction for trigger ${trigger}`);\n  }\n  return call(instructionToCall, args, sourceSpan);\n}\nfunction projectionDef(def) {\n  return call(Identifiers.projectionDef, def ? [def] : [], null);\n}\nfunction projection(slot, projectionSlotIndex, attributes, fallbackFnName, fallbackDecls, fallbackVars, sourceSpan) {\n  const args = [literal(slot)];\n  if (projectionSlotIndex !== 0 || attributes !== null || fallbackFnName !== null) {\n    args.push(literal(projectionSlotIndex));\n    if (attributes !== null) {\n      args.push(attributes);\n    }\n    if (fallbackFnName !== null) {\n      if (attributes === null) {\n        args.push(literal(null));\n      }\n      args.push(variable(fallbackFnName), literal(fallbackDecls), literal(fallbackVars));\n    }\n  }\n  return call(Identifiers.projection, args, sourceSpan);\n}\nfunction i18nStart(slot, constIndex, subTemplateIndex, sourceSpan) {\n  const args = [literal(slot), literal(constIndex)];\n  if (subTemplateIndex !== null) {\n    args.push(literal(subTemplateIndex));\n  }\n  return call(Identifiers.i18nStart, args, sourceSpan);\n}\nfunction conditionalCreate(slot, templateFnRef, decls, vars, tag, constIndex, localRefs, sourceSpan) {\n  const args = [literal(slot), templateFnRef, literal(decls), literal(vars), literal(tag), literal(constIndex)];\n  if (localRefs !== null) {\n    args.push(literal(localRefs));\n    args.push(importExpr(Identifiers.templateRefExtractor));\n  }\n  while (args[args.length - 1].isEquivalent(NULL_EXPR)) {\n    args.pop();\n  }\n  return call(Identifiers.conditionalCreate, args, sourceSpan);\n}\nfunction conditionalBranchCreate(slot, templateFnRef, decls, vars, tag, constIndex, localRefs, sourceSpan) {\n  const args = [literal(slot), templateFnRef, literal(decls), literal(vars), literal(tag), literal(constIndex)];\n  if (localRefs !== null) {\n    args.push(literal(localRefs));\n    args.push(importExpr(Identifiers.templateRefExtractor));\n  }\n  while (args[args.length - 1].isEquivalent(NULL_EXPR)) {\n    args.pop();\n  }\n  return call(Identifiers.conditionalBranchCreate, args, sourceSpan);\n}\nfunction repeaterCreate(slot, viewFnName, decls, vars, tag, constIndex, trackByFn, trackByUsesComponentInstance, emptyViewFnName, emptyDecls, emptyVars, emptyTag, emptyConstIndex, sourceSpan) {\n  const args = [literal(slot), variable(viewFnName), literal(decls), literal(vars), literal(tag), literal(constIndex), trackByFn];\n  if (trackByUsesComponentInstance || emptyViewFnName !== null) {\n    args.push(literal(trackByUsesComponentInstance));\n    if (emptyViewFnName !== null) {\n      args.push(variable(emptyViewFnName), literal(emptyDecls), literal(emptyVars));\n      if (emptyTag !== null || emptyConstIndex !== null) {\n        args.push(literal(emptyTag));\n      }\n      if (emptyConstIndex !== null) {\n        args.push(literal(emptyConstIndex));\n      }\n    }\n  }\n  return call(Identifiers.repeaterCreate, args, sourceSpan);\n}\nfunction repeater(collection, sourceSpan) {\n  return call(Identifiers.repeater, [collection], sourceSpan);\n}\nfunction deferWhen(modifier, expr, sourceSpan) {\n  if (modifier === \"prefetch\") {\n    return call(Identifiers.deferPrefetchWhen, [expr], sourceSpan);\n  } else if (modifier === \"hydrate\") {\n    return call(Identifiers.deferHydrateWhen, [expr], sourceSpan);\n  }\n  return call(Identifiers.deferWhen, [expr], sourceSpan);\n}\nfunction declareLet(slot, sourceSpan) {\n  return call(Identifiers.declareLet, [literal(slot)], sourceSpan);\n}\nfunction storeLet(value, sourceSpan) {\n  return importExpr(Identifiers.storeLet).callFn([value], sourceSpan);\n}\nfunction readContextLet(slot) {\n  return importExpr(Identifiers.readContextLet).callFn([literal(slot)]);\n}\nfunction i18n(slot, constIndex, subTemplateIndex, sourceSpan) {\n  const args = [literal(slot), literal(constIndex)];\n  if (subTemplateIndex) {\n    args.push(literal(subTemplateIndex));\n  }\n  return call(Identifiers.i18n, args, sourceSpan);\n}\nfunction i18nEnd(endSourceSpan) {\n  return call(Identifiers.i18nEnd, [], endSourceSpan);\n}\nfunction i18nAttributes(slot, i18nAttributesConfig) {\n  const args = [literal(slot), literal(i18nAttributesConfig)];\n  return call(Identifiers.i18nAttributes, args, null);\n}\nfunction ariaProperty(name, expression, sourceSpan) {\n  return propertyBase(Identifiers.ariaProperty, name, expression, null, sourceSpan);\n}\nfunction property(name, expression, sanitizer, sourceSpan) {\n  return propertyBase(Identifiers.property, name, expression, sanitizer, sourceSpan);\n}\nfunction control(expression, sanitizer, sourceSpan) {\n  const args = [];\n  if (expression instanceof Interpolation) {\n    args.push(interpolationToExpression(expression, sourceSpan));\n  } else {\n    args.push(expression);\n  }\n  if (sanitizer !== null) {\n    args.push(sanitizer);\n  }\n  return call(Identifiers.control, args, sourceSpan);\n}\nfunction controlCreate(sourceSpan) {\n  return call(Identifiers.controlCreate, [], sourceSpan);\n}\nfunction twoWayProperty(name, expression, sanitizer, sourceSpan) {\n  const args = [literal(name), expression];\n  if (sanitizer !== null) {\n    args.push(sanitizer);\n  }\n  return call(Identifiers.twoWayProperty, args, sourceSpan);\n}\nfunction attribute(name, expression, sanitizer, namespace, sourceSpan) {\n  const args = [literal(name)];\n  if (expression instanceof Interpolation) {\n    args.push(interpolationToExpression(expression, sourceSpan));\n  } else {\n    args.push(expression);\n  }\n  if (sanitizer !== null || namespace !== null) {\n    args.push(sanitizer ?? literal(null));\n  }\n  if (namespace !== null) {\n    args.push(literal(namespace));\n  }\n  return call(Identifiers.attribute, args, null);\n}\nfunction styleProp(name, expression, unit, sourceSpan) {\n  const args = [literal(name)];\n  if (expression instanceof Interpolation) {\n    args.push(interpolationToExpression(expression, sourceSpan));\n  } else {\n    args.push(expression);\n  }\n  if (unit !== null) {\n    args.push(literal(unit));\n  }\n  return call(Identifiers.styleProp, args, sourceSpan);\n}\nfunction classProp(name, expression, sourceSpan) {\n  return call(Identifiers.classProp, [literal(name), expression], sourceSpan);\n}\nfunction styleMap(expression, sourceSpan) {\n  const value = expression instanceof Interpolation ? interpolationToExpression(expression, sourceSpan) : expression;\n  return call(Identifiers.styleMap, [value], sourceSpan);\n}\nfunction classMap(expression, sourceSpan) {\n  const value = expression instanceof Interpolation ? interpolationToExpression(expression, sourceSpan) : expression;\n  return call(Identifiers.classMap, [value], sourceSpan);\n}\nfunction domElement(slot, tag, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.domElement, slot, tag, constIndex, localRefIndex, sourceSpan);\n}\nfunction domElementStart(slot, tag, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.domElementStart, slot, tag, constIndex, localRefIndex, sourceSpan);\n}\nfunction domElementEnd(sourceSpan) {\n  return call(Identifiers.domElementEnd, [], sourceSpan);\n}\nfunction domElementContainerStart(slot, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.domElementContainerStart, slot, null, constIndex, localRefIndex, sourceSpan);\n}\nfunction domElementContainer(slot, constIndex, localRefIndex, sourceSpan) {\n  return elementOrContainerBase(Identifiers.domElementContainer, slot, null, constIndex, localRefIndex, sourceSpan);\n}\nfunction domElementContainerEnd() {\n  return call(Identifiers.domElementContainerEnd, [], null);\n}\nfunction domListener(name, handlerFn, eventTargetResolver, sourceSpan) {\n  const args = [literal(name), handlerFn];\n  if (eventTargetResolver !== null) {\n    args.push(importExpr(eventTargetResolver));\n  }\n  return call(Identifiers.domListener, args, sourceSpan);\n}\nfunction domTemplate(slot, templateFnRef, decls, vars, tag, constIndex, localRefs, sourceSpan) {\n  return templateBase(Identifiers.domTemplate, slot, templateFnRef, decls, vars, tag, constIndex, localRefs, sourceSpan);\n}\nconst PIPE_BINDINGS = [Identifiers.pipeBind1, Identifiers.pipeBind2, Identifiers.pipeBind3, Identifiers.pipeBind4];\nfunction pipeBind(slot, varOffset, args) {\n  if (args.length < 1 || args.length > PIPE_BINDINGS.length) {\n    throw new Error(`pipeBind() argument count out of bounds`);\n  }\n  const instruction = PIPE_BINDINGS[args.length - 1];\n  return importExpr(instruction).callFn([literal(slot), literal(varOffset), ...args]);\n}\nfunction pipeBindV(slot, varOffset, args) {\n  return importExpr(Identifiers.pipeBindV).callFn([literal(slot), literal(varOffset), args]);\n}\nfunction textInterpolate(strings, expressions, sourceSpan) {\n  const interpolationArgs = collateInterpolationArgs(strings, expressions);\n  return callVariadicInstruction(TEXT_INTERPOLATE_CONFIG, [], interpolationArgs, [], sourceSpan);\n}\nfunction i18nExp(expr, sourceSpan) {\n  return call(Identifiers.i18nExp, [expr], sourceSpan);\n}\nfunction i18nApply(slot, sourceSpan) {\n  return call(Identifiers.i18nApply, [literal(slot)], sourceSpan);\n}\nfunction domProperty(name, expression, sanitizer, sourceSpan) {\n  return propertyBase(Identifiers.domProperty, name, expression, sanitizer, sourceSpan);\n}\nfunction animation(animationKind, handlerFn, sanitizer, sourceSpan) {\n  const args = [handlerFn];\n  if (sanitizer !== null) {\n    args.push(sanitizer);\n  }\n  const identifier = animationKind === \"enter\" ? Identifiers.animationEnter : Identifiers.animationLeave;\n  return call(identifier, args, sourceSpan);\n}\nfunction animationString(animationKind, expression, sanitizer, sourceSpan) {\n  const value = expression instanceof Interpolation ? interpolationToExpression(expression, sourceSpan) : expression;\n  const args = [value];\n  if (sanitizer !== null) {\n    args.push(sanitizer);\n  }\n  const identifier = animationKind === \"enter\" ? Identifiers.animationEnter : Identifiers.animationLeave;\n  return call(identifier, args, sourceSpan);\n}\nfunction animationListener(animationKind, handlerFn, eventTargetResolver, sourceSpan) {\n  const args = [handlerFn];\n  const identifier = animationKind === \"enter\" ? Identifiers.animationEnterListener : Identifiers.animationLeaveListener;\n  return call(identifier, args, sourceSpan);\n}\nfunction syntheticHostProperty(name, expression, sourceSpan) {\n  return call(Identifiers.syntheticHostProperty, [literal(name), expression], sourceSpan);\n}\nfunction pureFunction(varOffset, fn, args) {\n  return callVariadicInstructionExpr(PURE_FUNCTION_CONFIG, [literal(varOffset), fn], args, [], null);\n}\nfunction attachSourceLocation(templatePath, locations) {\n  return call(Identifiers.attachSourceLocations, [literal(templatePath), locations], null);\n}\nfunction collateInterpolationArgs(strings, expressions) {\n  if (strings.length < 1 || expressions.length !== strings.length - 1) {\n    throw new Error(`AssertionError: expected specific shape of args for strings/expressions in interpolation`);\n  }\n  const interpolationArgs = [];\n  if (expressions.length === 1 && strings[0] === '' && strings[1] === '') {\n    interpolationArgs.push(expressions[0]);\n  } else {\n    let idx;\n    for (idx = 0; idx < expressions.length; idx++) {\n      interpolationArgs.push(literal(strings[idx]), expressions[idx]);\n    }\n    interpolationArgs.push(literal(strings[idx]));\n  }\n  return interpolationArgs;\n}\nfunction interpolationToExpression(interpolation, sourceSpan) {\n  const interpolationArgs = collateInterpolationArgs(interpolation.strings, interpolation.expressions);\n  return callVariadicInstructionExpr(VALUE_INTERPOLATE_CONFIG, [], interpolationArgs, [], sourceSpan);\n}\nfunction call(instruction, args, sourceSpan) {\n  const expr = importExpr(instruction).callFn(args, sourceSpan);\n  return createStatementOp(new ExpressionStatement(expr, sourceSpan));\n}\nfunction conditional(condition, contextValue, sourceSpan) {\n  const args = [condition];\n  if (contextValue !== null) {\n    args.push(contextValue);\n  }\n  return call(Identifiers.conditional, args, sourceSpan);\n}\nconst TEXT_INTERPOLATE_CONFIG = {\n  constant: [Identifiers.textInterpolate, Identifiers.textInterpolate1, Identifiers.textInterpolate2, Identifiers.textInterpolate3, Identifiers.textInterpolate4, Identifiers.textInterpolate5, Identifiers.textInterpolate6, Identifiers.textInterpolate7, Identifiers.textInterpolate8],\n  variable: Identifiers.textInterpolateV,\n  mapping: n => {\n    if (n % 2 === 0) {\n      throw new Error(`Expected odd number of arguments`);\n    }\n    return (n - 1) / 2;\n  }\n};\nconst VALUE_INTERPOLATE_CONFIG = {\n  constant: [Identifiers.interpolate, Identifiers.interpolate1, Identifiers.interpolate2, Identifiers.interpolate3, Identifiers.interpolate4, Identifiers.interpolate5, Identifiers.interpolate6, Identifiers.interpolate7, Identifiers.interpolate8],\n  variable: Identifiers.interpolateV,\n  mapping: n => {\n    if (n % 2 === 0) {\n      throw new Error(`Expected odd number of arguments`);\n    }\n    return (n - 1) / 2;\n  }\n};\nconst PURE_FUNCTION_CONFIG = {\n  constant: [Identifiers.pureFunction0, Identifiers.pureFunction1, Identifiers.pureFunction2, Identifiers.pureFunction3, Identifiers.pureFunction4, Identifiers.pureFunction5, Identifiers.pureFunction6, Identifiers.pureFunction7, Identifiers.pureFunction8],\n  variable: Identifiers.pureFunctionV,\n  mapping: n => n\n};\nfunction callVariadicInstructionExpr(config, baseArgs, interpolationArgs, extraArgs, sourceSpan) {\n  const n = config.mapping(interpolationArgs.length);\n  const lastInterpolationArg = interpolationArgs.at(-1);\n  if (extraArgs.length === 0 && interpolationArgs.length > 1 && lastInterpolationArg instanceof LiteralExpr && lastInterpolationArg.value === '') {\n    interpolationArgs.pop();\n  }\n  if (n < config.constant.length) {\n    return importExpr(config.constant[n]).callFn([...baseArgs, ...interpolationArgs, ...extraArgs], sourceSpan);\n  } else if (config.variable !== null) {\n    return importExpr(config.variable).callFn([...baseArgs, literalArr(interpolationArgs), ...extraArgs], sourceSpan);\n  } else {\n    throw new Error(`AssertionError: unable to call variadic function`);\n  }\n}\nfunction callVariadicInstruction(config, baseArgs, interpolationArgs, extraArgs, sourceSpan) {\n  return createStatementOp(callVariadicInstructionExpr(config, baseArgs, interpolationArgs, extraArgs, sourceSpan).toStmt());\n}\n\nconst GLOBAL_TARGET_RESOLVERS = new Map([['window', Identifiers.resolveWindow], ['document', Identifiers.resolveDocument], ['body', Identifiers.resolveBody]]);\nconst DOM_PROPERTY_REMAPPING = new Map([['class', 'className'], ['for', 'htmlFor'], ['formaction', 'formAction'], ['innerHtml', 'innerHTML'], ['readonly', 'readOnly'], ['tabindex', 'tabIndex']]);\nfunction reify(job) {\n  for (const unit of job.units) {\n    reifyCreateOperations(unit, unit.create);\n    reifyUpdateOperations(unit, unit.update);\n  }\n}\nfunction reifyCreateOperations(unit, ops) {\n  for (const op of ops) {\n    transformExpressionsInOp(op, reifyIrExpression, VisitorContextFlag.None);\n    switch (op.kind) {\n      case OpKind.Text:\n        OpList.replace(op, text(op.handle.slot, op.initialValue, op.sourceSpan));\n        break;\n      case OpKind.ElementStart:\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly ? domElementStart(op.handle.slot, op.tag, op.attributes, op.localRefs, op.startSourceSpan) : elementStart(op.handle.slot, op.tag, op.attributes, op.localRefs, op.startSourceSpan));\n        break;\n      case OpKind.Element:\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly ? domElement(op.handle.slot, op.tag, op.attributes, op.localRefs, op.wholeSourceSpan) : element(op.handle.slot, op.tag, op.attributes, op.localRefs, op.wholeSourceSpan));\n        break;\n      case OpKind.ElementEnd:\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly ? domElementEnd(op.sourceSpan) : elementEnd(op.sourceSpan));\n        break;\n      case OpKind.ContainerStart:\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly ? domElementContainerStart(op.handle.slot, op.attributes, op.localRefs, op.startSourceSpan) : elementContainerStart(op.handle.slot, op.attributes, op.localRefs, op.startSourceSpan));\n        break;\n      case OpKind.Container:\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly ? domElementContainer(op.handle.slot, op.attributes, op.localRefs, op.wholeSourceSpan) : elementContainer(op.handle.slot, op.attributes, op.localRefs, op.wholeSourceSpan));\n        break;\n      case OpKind.ContainerEnd:\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly ? domElementContainerEnd() : elementContainerEnd());\n        break;\n      case OpKind.I18nStart:\n        OpList.replace(op, i18nStart(op.handle.slot, op.messageIndex, op.subTemplateIndex, op.sourceSpan));\n        break;\n      case OpKind.I18nEnd:\n        OpList.replace(op, i18nEnd(op.sourceSpan));\n        break;\n      case OpKind.I18n:\n        OpList.replace(op, i18n(op.handle.slot, op.messageIndex, op.subTemplateIndex, op.sourceSpan));\n        break;\n      case OpKind.I18nAttributes:\n        if (op.i18nAttributesConfig === null) {\n          throw new Error(`AssertionError: i18nAttributesConfig was not set`);\n        }\n        OpList.replace(op, i18nAttributes(op.handle.slot, op.i18nAttributesConfig));\n        break;\n      case OpKind.Template:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        if (Array.isArray(op.localRefs)) {\n          throw new Error(`AssertionError: local refs array should have been extracted into a constant`);\n        }\n        const childView = unit.job.views.get(op.xref);\n        OpList.replace(op, op.templateKind === TemplateKind.Block || unit.job.mode === TemplateCompilationMode.DomOnly ? domTemplate(op.handle.slot, variable(childView.fnName), childView.decls, childView.vars, op.tag, op.attributes, op.localRefs, op.startSourceSpan) : template(op.handle.slot, variable(childView.fnName), childView.decls, childView.vars, op.tag, op.attributes, op.localRefs, op.startSourceSpan));\n        break;\n      case OpKind.DisableBindings:\n        OpList.replace(op, disableBindings());\n        break;\n      case OpKind.EnableBindings:\n        OpList.replace(op, enableBindings());\n        break;\n      case OpKind.Pipe:\n        OpList.replace(op, pipe(op.handle.slot, op.name));\n        break;\n      case OpKind.DeclareLet:\n        OpList.replace(op, declareLet(op.handle.slot, op.sourceSpan));\n        break;\n      case OpKind.AnimationString:\n        OpList.replace(op, animationString(op.animationKind, op.expression, op.sanitizer, op.sourceSpan));\n        break;\n      case OpKind.Animation:\n        const animationCallbackFn = reifyListenerHandler(unit, op.handlerFnName, op.handlerOps, false);\n        OpList.replace(op, animation(op.animationKind, animationCallbackFn, op.sanitizer, op.sourceSpan));\n        break;\n      case OpKind.AnimationListener:\n        const animationListenerFn = reifyListenerHandler(unit, op.handlerFnName, op.handlerOps, op.consumesDollarEvent);\n        OpList.replace(op, animationListener(op.animationKind, animationListenerFn, null, op.sourceSpan));\n        break;\n      case OpKind.Listener:\n        const listenerFn = reifyListenerHandler(unit, op.handlerFnName, op.handlerOps, op.consumesDollarEvent);\n        const eventTargetResolver = op.eventTarget ? GLOBAL_TARGET_RESOLVERS.get(op.eventTarget) : null;\n        if (eventTargetResolver === undefined) {\n          throw new Error(`Unexpected global target '${op.eventTarget}' defined for '${op.name}' event. Supported list of global targets: window,document,body.`);\n        }\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly && !op.hostListener && !op.isLegacyAnimationListener ? domListener(op.name, listenerFn, eventTargetResolver, op.sourceSpan) : listener(op.name, listenerFn, eventTargetResolver, op.hostListener && op.isLegacyAnimationListener, op.sourceSpan));\n        break;\n      case OpKind.TwoWayListener:\n        OpList.replace(op, twoWayListener(op.name, reifyListenerHandler(unit, op.handlerFnName, op.handlerOps, true), op.sourceSpan));\n        break;\n      case OpKind.Variable:\n        if (op.variable.name === null) {\n          throw new Error(`AssertionError: unnamed variable ${op.xref}`);\n        }\n        OpList.replace(op, createStatementOp(new DeclareVarStmt(op.variable.name, op.initializer, undefined, StmtModifier.Final)));\n        break;\n      case OpKind.Namespace:\n        switch (op.active) {\n          case Namespace.HTML:\n            OpList.replace(op, namespaceHTML());\n            break;\n          case Namespace.SVG:\n            OpList.replace(op, namespaceSVG());\n            break;\n          case Namespace.Math:\n            OpList.replace(op, namespaceMath());\n            break;\n        }\n        break;\n      case OpKind.Defer:\n        const timerScheduling = !!op.loadingMinimumTime || !!op.loadingAfterTime || !!op.placeholderMinimumTime;\n        OpList.replace(op, defer(op.handle.slot, op.mainSlot.slot, op.resolverFn, op.loadingSlot?.slot ?? null, op.placeholderSlot?.slot ?? null, op.errorSlot?.slot ?? null, op.loadingConfig, op.placeholderConfig, timerScheduling, op.sourceSpan, op.flags));\n        break;\n      case OpKind.DeferOn:\n        let args = [];\n        switch (op.trigger.kind) {\n          case DeferTriggerKind.Never:\n          case DeferTriggerKind.Idle:\n          case DeferTriggerKind.Immediate:\n            break;\n          case DeferTriggerKind.Timer:\n            args = [literal(op.trigger.delay)];\n            break;\n          case DeferTriggerKind.Viewport:\n            if (op.modifier === \"hydrate\") {\n              args = op.trigger.options ? [op.trigger.options] : [];\n            } else {\n              args = [literal(op.trigger.targetSlot?.slot ?? null)];\n              if (op.trigger.targetSlotViewSteps !== 0) {\n                args.push(literal(op.trigger.targetSlotViewSteps));\n              } else if (op.trigger.options) {\n                args.push(literal(null));\n              }\n              if (op.trigger.options) {\n                args.push(op.trigger.options);\n              }\n            }\n            break;\n          case DeferTriggerKind.Interaction:\n          case DeferTriggerKind.Hover:\n            if (op.modifier === \"hydrate\") {\n              args = [];\n            } else {\n              args = [literal(op.trigger.targetSlot?.slot ?? null)];\n              if (op.trigger.targetSlotViewSteps !== 0) {\n                args.push(literal(op.trigger.targetSlotViewSteps));\n              }\n            }\n            break;\n          default:\n            throw new Error(`AssertionError: Unsupported reification of defer trigger kind ${op.trigger.kind}`);\n        }\n        OpList.replace(op, deferOn(op.trigger.kind, args, op.modifier, op.sourceSpan));\n        break;\n      case OpKind.ProjectionDef:\n        OpList.replace(op, projectionDef(op.def));\n        break;\n      case OpKind.Projection:\n        if (op.handle.slot === null) {\n          throw new Error('No slot was assigned for project instruction');\n        }\n        let fallbackViewFnName = null;\n        let fallbackDecls = null;\n        let fallbackVars = null;\n        if (op.fallbackView !== null) {\n          if (!(unit instanceof ViewCompilationUnit)) {\n            throw new Error(`AssertionError: must be compiling a component`);\n          }\n          const fallbackView = unit.job.views.get(op.fallbackView);\n          if (fallbackView === undefined) {\n            throw new Error('AssertionError: projection had fallback view xref, but fallback view was not found');\n          }\n          if (fallbackView.fnName === null || fallbackView.decls === null || fallbackView.vars === null) {\n            throw new Error(`AssertionError: expected projection fallback view to have been named and counted`);\n          }\n          fallbackViewFnName = fallbackView.fnName;\n          fallbackDecls = fallbackView.decls;\n          fallbackVars = fallbackView.vars;\n        }\n        OpList.replace(op, projection(op.handle.slot, op.projectionSlotIndex, op.attributes, fallbackViewFnName, fallbackDecls, fallbackVars, op.sourceSpan));\n        break;\n      case OpKind.ConditionalCreate:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        if (Array.isArray(op.localRefs)) {\n          throw new Error(`AssertionError: local refs array should have been extracted into a constant`);\n        }\n        const conditionalCreateChildView = unit.job.views.get(op.xref);\n        OpList.replace(op, conditionalCreate(op.handle.slot, variable(conditionalCreateChildView.fnName), conditionalCreateChildView.decls, conditionalCreateChildView.vars, op.tag, op.attributes, op.localRefs, op.startSourceSpan));\n        break;\n      case OpKind.ConditionalBranchCreate:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        if (Array.isArray(op.localRefs)) {\n          throw new Error(`AssertionError: local refs array should have been extracted into a constant`);\n        }\n        const conditionalBranchCreateChildView = unit.job.views.get(op.xref);\n        OpList.replace(op, conditionalBranchCreate(op.handle.slot, variable(conditionalBranchCreateChildView.fnName), conditionalBranchCreateChildView.decls, conditionalBranchCreateChildView.vars, op.tag, op.attributes, op.localRefs, op.startSourceSpan));\n        break;\n      case OpKind.RepeaterCreate:\n        if (op.handle.slot === null) {\n          throw new Error('No slot was assigned for repeater instruction');\n        }\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        const repeaterView = unit.job.views.get(op.xref);\n        if (repeaterView.fnName === null) {\n          throw new Error(`AssertionError: expected repeater primary view to have been named`);\n        }\n        let emptyViewFnName = null;\n        let emptyDecls = null;\n        let emptyVars = null;\n        if (op.emptyView !== null) {\n          const emptyView = unit.job.views.get(op.emptyView);\n          if (emptyView === undefined) {\n            throw new Error('AssertionError: repeater had empty view xref, but empty view was not found');\n          }\n          if (emptyView.fnName === null || emptyView.decls === null || emptyView.vars === null) {\n            throw new Error(`AssertionError: expected repeater empty view to have been named and counted`);\n          }\n          emptyViewFnName = emptyView.fnName;\n          emptyDecls = emptyView.decls;\n          emptyVars = emptyView.vars;\n        }\n        OpList.replace(op, repeaterCreate(op.handle.slot, repeaterView.fnName, op.decls, op.vars, op.tag, op.attributes, reifyTrackBy(unit, op), op.usesComponentInstance, emptyViewFnName, emptyDecls, emptyVars, op.emptyTag, op.emptyAttributes, op.wholeSourceSpan));\n        break;\n      case OpKind.SourceLocation:\n        const locationsLiteral = literalArr(op.locations.map(({\n          targetSlot,\n          offset,\n          line,\n          column\n        }) => {\n          if (targetSlot.slot === null) {\n            throw new Error('No slot was assigned for source location');\n          }\n          return literalArr([literal(targetSlot.slot), literal(offset), literal(line), literal(column)]);\n        }));\n        OpList.replace(op, attachSourceLocation(op.templatePath, locationsLiteral));\n        break;\n      case OpKind.ControlCreate:\n        OpList.replace(op, controlCreate(op.sourceSpan));\n        break;\n      case OpKind.Statement:\n        break;\n      default:\n        throw new Error(`AssertionError: Unsupported reification of create op ${OpKind[op.kind]}`);\n    }\n  }\n}\nfunction reifyUpdateOperations(unit, ops) {\n  for (const op of ops) {\n    transformExpressionsInOp(op, reifyIrExpression, VisitorContextFlag.None);\n    switch (op.kind) {\n      case OpKind.Advance:\n        OpList.replace(op, advance(op.delta, op.sourceSpan));\n        break;\n      case OpKind.Property:\n        OpList.replace(op, unit.job.mode === TemplateCompilationMode.DomOnly && op.bindingKind !== BindingKind.LegacyAnimation && op.bindingKind !== BindingKind.Animation ? reifyDomProperty(op) : reifyProperty(op));\n        break;\n      case OpKind.Control:\n        OpList.replace(op, reifyControl(op));\n        break;\n      case OpKind.TwoWayProperty:\n        OpList.replace(op, twoWayProperty(op.name, op.expression, op.sanitizer, op.sourceSpan));\n        break;\n      case OpKind.StyleProp:\n        OpList.replace(op, styleProp(op.name, op.expression, op.unit, op.sourceSpan));\n        break;\n      case OpKind.ClassProp:\n        OpList.replace(op, classProp(op.name, op.expression, op.sourceSpan));\n        break;\n      case OpKind.StyleMap:\n        OpList.replace(op, styleMap(op.expression, op.sourceSpan));\n        break;\n      case OpKind.ClassMap:\n        OpList.replace(op, classMap(op.expression, op.sourceSpan));\n        break;\n      case OpKind.I18nExpression:\n        OpList.replace(op, i18nExp(op.expression, op.sourceSpan));\n        break;\n      case OpKind.I18nApply:\n        OpList.replace(op, i18nApply(op.handle.slot, op.sourceSpan));\n        break;\n      case OpKind.InterpolateText:\n        OpList.replace(op, textInterpolate(op.interpolation.strings, op.interpolation.expressions, op.sourceSpan));\n        break;\n      case OpKind.Attribute:\n        OpList.replace(op, attribute(op.name, op.expression, op.sanitizer, op.namespace, op.sourceSpan));\n        break;\n      case OpKind.DomProperty:\n        if (op.expression instanceof Interpolation) {\n          throw new Error('not yet handled');\n        } else {\n          if (op.bindingKind === BindingKind.LegacyAnimation || op.bindingKind === BindingKind.Animation) {\n            OpList.replace(op, syntheticHostProperty(op.name, op.expression, op.sourceSpan));\n          } else {\n            OpList.replace(op, reifyDomProperty(op));\n          }\n        }\n        break;\n      case OpKind.Variable:\n        if (op.variable.name === null) {\n          throw new Error(`AssertionError: unnamed variable ${op.xref}`);\n        }\n        OpList.replace(op, createStatementOp(new DeclareVarStmt(op.variable.name, op.initializer, undefined, StmtModifier.Final)));\n        break;\n      case OpKind.Conditional:\n        if (op.processed === null) {\n          throw new Error(`Conditional test was not set.`);\n        }\n        OpList.replace(op, conditional(op.processed, op.contextValue, op.sourceSpan));\n        break;\n      case OpKind.Repeater:\n        OpList.replace(op, repeater(op.collection, op.sourceSpan));\n        break;\n      case OpKind.DeferWhen:\n        OpList.replace(op, deferWhen(op.modifier, op.expr, op.sourceSpan));\n        break;\n      case OpKind.StoreLet:\n        throw new Error(`AssertionError: unexpected storeLet ${op.declaredName}`);\n      case OpKind.Statement:\n        break;\n      default:\n        throw new Error(`AssertionError: Unsupported reification of update op ${OpKind[op.kind]}`);\n    }\n  }\n}\nfunction reifyDomProperty(op) {\n  return domProperty(DOM_PROPERTY_REMAPPING.get(op.name) ?? op.name, op.expression, op.sanitizer, op.sourceSpan);\n}\nfunction reifyProperty(op) {\n  return isAriaAttribute(op.name) ? ariaProperty(op.name, op.expression, op.sourceSpan) : property(op.name, op.expression, op.sanitizer, op.sourceSpan);\n}\nfunction reifyControl(op) {\n  return control(op.expression, op.sanitizer, op.sourceSpan);\n}\nfunction reifyIrExpression(expr) {\n  if (!isIrExpression(expr)) {\n    return expr;\n  }\n  switch (expr.kind) {\n    case ExpressionKind.NextContext:\n      return nextContext(expr.steps);\n    case ExpressionKind.Reference:\n      return reference(expr.targetSlot.slot + 1 + expr.offset);\n    case ExpressionKind.LexicalRead:\n      throw new Error(`AssertionError: unresolved LexicalRead of ${expr.name}`);\n    case ExpressionKind.TwoWayBindingSet:\n      throw new Error(`AssertionError: unresolved TwoWayBindingSet`);\n    case ExpressionKind.RestoreView:\n      if (typeof expr.view === 'number') {\n        throw new Error(`AssertionError: unresolved RestoreView`);\n      }\n      return restoreView(expr.view);\n    case ExpressionKind.ResetView:\n      return resetView(expr.expr);\n    case ExpressionKind.GetCurrentView:\n      return getCurrentView();\n    case ExpressionKind.ReadVariable:\n      if (expr.name === null) {\n        throw new Error(`Read of unnamed variable ${expr.xref}`);\n      }\n      return variable(expr.name);\n    case ExpressionKind.ReadTemporaryExpr:\n      if (expr.name === null) {\n        throw new Error(`Read of unnamed temporary ${expr.xref}`);\n      }\n      return variable(expr.name);\n    case ExpressionKind.AssignTemporaryExpr:\n      if (expr.name === null) {\n        throw new Error(`Assign of unnamed temporary ${expr.xref}`);\n      }\n      return variable(expr.name).set(expr.expr);\n    case ExpressionKind.PureFunctionExpr:\n      if (expr.fn === null) {\n        throw new Error(`AssertionError: expected PureFunctions to have been extracted`);\n      }\n      return pureFunction(expr.varOffset, expr.fn, expr.args);\n    case ExpressionKind.PureFunctionParameterExpr:\n      throw new Error(`AssertionError: expected PureFunctionParameterExpr to have been extracted`);\n    case ExpressionKind.PipeBinding:\n      return pipeBind(expr.targetSlot.slot, expr.varOffset, expr.args);\n    case ExpressionKind.PipeBindingVariadic:\n      return pipeBindV(expr.targetSlot.slot, expr.varOffset, expr.args);\n    case ExpressionKind.SlotLiteralExpr:\n      return literal(expr.slot.slot);\n    case ExpressionKind.ContextLetReference:\n      return readContextLet(expr.targetSlot.slot);\n    case ExpressionKind.StoreLet:\n      return storeLet(expr.value, expr.sourceSpan);\n    case ExpressionKind.TrackContext:\n      return variable('this');\n    default:\n      throw new Error(`AssertionError: Unsupported reification of ir.Expression kind: ${ExpressionKind[expr.kind]}`);\n  }\n}\nfunction reifyListenerHandler(unit, name, handlerOps, consumesDollarEvent) {\n  reifyUpdateOperations(unit, handlerOps);\n  const handlerStmts = [];\n  for (const op of handlerOps) {\n    if (op.kind !== OpKind.Statement) {\n      throw new Error(`AssertionError: expected reified statements, but found op ${OpKind[op.kind]}`);\n    }\n    handlerStmts.push(op.statement);\n  }\n  const params = [];\n  if (consumesDollarEvent) {\n    params.push(new FnParam('$event'));\n  }\n  return fn(params, handlerStmts, undefined, undefined, name);\n}\nfunction reifyTrackBy(unit, op) {\n  if (op.trackByFn !== null) {\n    return op.trackByFn;\n  }\n  const params = [new FnParam('$index'), new FnParam('$item')];\n  let fn$1;\n  if (op.trackByOps === null) {\n    fn$1 = op.usesComponentInstance ? fn(params, [new ReturnStatement(op.track)]) : arrowFn(params, op.track);\n  } else {\n    reifyUpdateOperations(unit, op.trackByOps);\n    const statements = [];\n    for (const trackOp of op.trackByOps) {\n      if (trackOp.kind !== OpKind.Statement) {\n        throw new Error(`AssertionError: expected reified statements, but found op ${OpKind[trackOp.kind]}`);\n      }\n      statements.push(trackOp.statement);\n    }\n    fn$1 = op.usesComponentInstance || statements.length !== 1 || !(statements[0] instanceof ReturnStatement) ? fn(params, statements) : arrowFn(params, statements[0].value);\n  }\n  op.trackByFn = unit.job.pool.getSharedFunctionReference(fn$1, '_forTrack');\n  return op.trackByFn;\n}\n\nfunction removeEmptyBindings(job) {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      switch (op.kind) {\n        case OpKind.Attribute:\n        case OpKind.Binding:\n        case OpKind.ClassProp:\n        case OpKind.ClassMap:\n        case OpKind.Property:\n        case OpKind.StyleProp:\n        case OpKind.StyleMap:\n          if (op.expression instanceof EmptyExpr) {\n            OpList.remove(op);\n          }\n          break;\n      }\n    }\n  }\n}\n\nfunction removeI18nContexts(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nContext:\n          OpList.remove(op);\n          break;\n        case OpKind.I18nStart:\n          op.context = null;\n          break;\n      }\n    }\n  }\n}\n\nfunction removeIllegalLetReferences(job) {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      if (op.kind !== OpKind.Variable || op.variable.kind !== SemanticVariableKind.Identifier || !(op.initializer instanceof StoreLetExpr)) {\n        continue;\n      }\n      const name = op.variable.identifier;\n      let current = op;\n      while (current && current.kind !== OpKind.ListEnd) {\n        transformExpressionsInOp(current, expr => expr instanceof LexicalReadExpr && expr.name === name ? literal(undefined) : expr, VisitorContextFlag.None);\n        current = current.prev;\n      }\n    }\n  }\n}\n\nfunction removeUnusedI18nAttributesOps(job) {\n  for (const unit of job.units) {\n    const ownersWithI18nExpressions = new Set();\n    for (const op of unit.update) {\n      switch (op.kind) {\n        case OpKind.I18nExpression:\n          ownersWithI18nExpressions.add(op.i18nOwner);\n      }\n    }\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nAttributes:\n          if (ownersWithI18nExpressions.has(op.xref)) {\n            continue;\n          }\n          OpList.remove(op);\n      }\n    }\n  }\n}\n\nfunction resolveContexts(job) {\n  for (const unit of job.units) {\n    processLexicalScope$1(unit, unit.create);\n    processLexicalScope$1(unit, unit.update);\n  }\n}\nfunction processLexicalScope$1(view, ops) {\n  const scope = new Map();\n  scope.set(view.xref, variable('ctx'));\n  for (const op of ops) {\n    switch (op.kind) {\n      case OpKind.Variable:\n        switch (op.variable.kind) {\n          case SemanticVariableKind.Context:\n            scope.set(op.variable.view, new ReadVariableExpr(op.xref));\n            break;\n        }\n        break;\n      case OpKind.Animation:\n      case OpKind.AnimationListener:\n      case OpKind.Listener:\n      case OpKind.TwoWayListener:\n        processLexicalScope$1(view, op.handlerOps);\n        break;\n      case OpKind.RepeaterCreate:\n        if (op.trackByOps !== null) {\n          processLexicalScope$1(view, op.trackByOps);\n        }\n        break;\n    }\n  }\n  if (view === view.job.root) {\n    scope.set(view.xref, variable('ctx'));\n  }\n  for (const op of ops) {\n    transformExpressionsInOp(op, expr => {\n      if (expr instanceof ContextExpr) {\n        if (!scope.has(expr.view)) {\n          throw new Error(`No context found for reference to view ${expr.view} from view ${view.xref}`);\n        }\n        return scope.get(expr.view);\n      } else {\n        return expr;\n      }\n    }, VisitorContextFlag.None);\n  }\n}\n\nfunction resolveDeferDepsFns(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.Defer) {\n        if (op.resolverFn !== null) {\n          continue;\n        }\n        if (op.ownResolverFn !== null) {\n          if (op.handle.slot === null) {\n            throw new Error('AssertionError: slot must be assigned before extracting defer deps functions');\n          }\n          const fullPathName = unit.fnName?.replace('_Template', '');\n          op.resolverFn = job.pool.getSharedFunctionReference(op.ownResolverFn, `${fullPathName}_Defer_${op.handle.slot}_DepsFn`, false);\n        }\n      }\n    }\n  }\n}\n\nfunction resolveDollarEvent(job) {\n  for (const unit of job.units) {\n    transformDollarEvent(unit.create);\n    transformDollarEvent(unit.update);\n  }\n}\nfunction transformDollarEvent(ops) {\n  for (const op of ops) {\n    if (op.kind === OpKind.Listener || op.kind === OpKind.TwoWayListener || op.kind === OpKind.AnimationListener) {\n      transformExpressionsInOp(op, expr => {\n        if (expr instanceof LexicalReadExpr && expr.name === '$event') {\n          if (op.kind === OpKind.Listener || op.kind === OpKind.AnimationListener) {\n            op.consumesDollarEvent = true;\n          }\n          return new ReadVarExpr(expr.name);\n        }\n        return expr;\n      }, VisitorContextFlag.InChildOperation);\n    }\n  }\n}\n\nfunction resolveI18nElementPlaceholders(job) {\n  const i18nContexts = new Map();\n  const elements = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nContext:\n          i18nContexts.set(op.xref, op);\n          break;\n        case OpKind.ElementStart:\n          elements.set(op.xref, op);\n          break;\n      }\n    }\n  }\n  resolvePlaceholdersForView(job, job.root, i18nContexts, elements);\n}\nfunction resolvePlaceholdersForView(job, unit, i18nContexts, elements, pendingStructuralDirective) {\n  let currentOps = null;\n  let pendingStructuralDirectiveCloses = new Map();\n  for (const op of unit.create) {\n    switch (op.kind) {\n      case OpKind.I18nStart:\n        if (!op.context) {\n          throw Error('Could not find i18n context for i18n op');\n        }\n        currentOps = {\n          i18nBlock: op,\n          i18nContext: i18nContexts.get(op.context)\n        };\n        break;\n      case OpKind.I18nEnd:\n        currentOps = null;\n        break;\n      case OpKind.ElementStart:\n        if (op.i18nPlaceholder !== undefined) {\n          if (currentOps === null) {\n            throw Error('i18n tag placeholder should only occur inside an i18n block');\n          }\n          recordElementStart(op, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n          if (pendingStructuralDirective && op.i18nPlaceholder.closeName) {\n            pendingStructuralDirectiveCloses.set(op.xref, pendingStructuralDirective);\n          }\n          pendingStructuralDirective = undefined;\n        }\n        break;\n      case OpKind.ElementEnd:\n        const startOp = elements.get(op.xref);\n        if (startOp && startOp.i18nPlaceholder !== undefined) {\n          if (currentOps === null) {\n            throw Error('AssertionError: i18n tag placeholder should only occur inside an i18n block');\n          }\n          recordElementClose(startOp, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirectiveCloses.get(op.xref));\n          pendingStructuralDirectiveCloses.delete(op.xref);\n        }\n        break;\n      case OpKind.Projection:\n        if (op.i18nPlaceholder !== undefined) {\n          if (currentOps === null) {\n            throw Error('i18n tag placeholder should only occur inside an i18n block');\n          }\n          recordElementStart(op, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n          recordElementClose(op, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n          pendingStructuralDirective = undefined;\n        }\n        if (op.fallbackView !== null) {\n          const view = job.views.get(op.fallbackView);\n          if (op.fallbackViewI18nPlaceholder === undefined) {\n            resolvePlaceholdersForView(job, view, i18nContexts, elements);\n          } else {\n            if (currentOps === null) {\n              throw Error('i18n tag placeholder should only occur inside an i18n block');\n            }\n            recordTemplateStart(job, view, op.handle.slot, op.fallbackViewI18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n            resolvePlaceholdersForView(job, view, i18nContexts, elements);\n            recordTemplateClose(job, view, op.handle.slot, op.fallbackViewI18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n            pendingStructuralDirective = undefined;\n          }\n        }\n        break;\n      case OpKind.ConditionalCreate:\n      case OpKind.ConditionalBranchCreate:\n      case OpKind.Template:\n        const view = job.views.get(op.xref);\n        if (op.i18nPlaceholder === undefined) {\n          resolvePlaceholdersForView(job, view, i18nContexts, elements);\n        } else {\n          if (currentOps === null) {\n            throw Error('i18n tag placeholder should only occur inside an i18n block');\n          }\n          if (op.templateKind === TemplateKind.Structural) {\n            resolvePlaceholdersForView(job, view, i18nContexts, elements, op);\n          } else {\n            recordTemplateStart(job, view, op.handle.slot, op.i18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n            resolvePlaceholdersForView(job, view, i18nContexts, elements);\n            recordTemplateClose(job, view, op.handle.slot, op.i18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n            pendingStructuralDirective = undefined;\n          }\n        }\n        break;\n      case OpKind.RepeaterCreate:\n        if (pendingStructuralDirective !== undefined) {\n          throw Error('AssertionError: Unexpected structural directive associated with @for block');\n        }\n        const forSlot = op.handle.slot + 1;\n        const forView = job.views.get(op.xref);\n        if (op.i18nPlaceholder === undefined) {\n          resolvePlaceholdersForView(job, forView, i18nContexts, elements);\n        } else {\n          if (currentOps === null) {\n            throw Error('i18n tag placeholder should only occur inside an i18n block');\n          }\n          recordTemplateStart(job, forView, forSlot, op.i18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n          resolvePlaceholdersForView(job, forView, i18nContexts, elements);\n          recordTemplateClose(job, forView, forSlot, op.i18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n          pendingStructuralDirective = undefined;\n        }\n        if (op.emptyView !== null) {\n          const emptySlot = op.handle.slot + 2;\n          const emptyView = job.views.get(op.emptyView);\n          if (op.emptyI18nPlaceholder === undefined) {\n            resolvePlaceholdersForView(job, emptyView, i18nContexts, elements);\n          } else {\n            if (currentOps === null) {\n              throw Error('i18n tag placeholder should only occur inside an i18n block');\n            }\n            recordTemplateStart(job, emptyView, emptySlot, op.emptyI18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n            resolvePlaceholdersForView(job, emptyView, i18nContexts, elements);\n            recordTemplateClose(job, emptyView, emptySlot, op.emptyI18nPlaceholder, currentOps.i18nContext, currentOps.i18nBlock, pendingStructuralDirective);\n            pendingStructuralDirective = undefined;\n          }\n        }\n        break;\n    }\n  }\n}\nfunction recordElementStart(op, i18nContext, i18nBlock, structuralDirective) {\n  const {\n    startName,\n    closeName\n  } = op.i18nPlaceholder;\n  let flags = I18nParamValueFlags.ElementTag | I18nParamValueFlags.OpenTag;\n  let value = op.handle.slot;\n  if (structuralDirective !== undefined) {\n    flags |= I18nParamValueFlags.TemplateTag;\n    value = {\n      element: value,\n      template: structuralDirective.handle.slot\n    };\n  }\n  if (!closeName) {\n    flags |= I18nParamValueFlags.CloseTag;\n  }\n  addParam(i18nContext.params, startName, value, i18nBlock.subTemplateIndex, flags);\n}\nfunction recordElementClose(op, i18nContext, i18nBlock, structuralDirective) {\n  const {\n    closeName\n  } = op.i18nPlaceholder;\n  if (closeName) {\n    let flags = I18nParamValueFlags.ElementTag | I18nParamValueFlags.CloseTag;\n    let value = op.handle.slot;\n    if (structuralDirective !== undefined) {\n      flags |= I18nParamValueFlags.TemplateTag;\n      value = {\n        element: value,\n        template: structuralDirective.handle.slot\n      };\n    }\n    addParam(i18nContext.params, closeName, value, i18nBlock.subTemplateIndex, flags);\n  }\n}\nfunction recordTemplateStart(job, view, slot, i18nPlaceholder, i18nContext, i18nBlock, structuralDirective) {\n  let {\n    startName,\n    closeName\n  } = i18nPlaceholder;\n  let flags = I18nParamValueFlags.TemplateTag | I18nParamValueFlags.OpenTag;\n  if (!closeName) {\n    flags |= I18nParamValueFlags.CloseTag;\n  }\n  if (structuralDirective !== undefined) {\n    addParam(i18nContext.params, startName, structuralDirective.handle.slot, i18nBlock.subTemplateIndex, flags);\n  }\n  addParam(i18nContext.params, startName, slot, getSubTemplateIndexForTemplateTag(job, i18nBlock, view), flags);\n}\nfunction recordTemplateClose(job, view, slot, i18nPlaceholder, i18nContext, i18nBlock, structuralDirective) {\n  const {\n    closeName\n  } = i18nPlaceholder;\n  const flags = I18nParamValueFlags.TemplateTag | I18nParamValueFlags.CloseTag;\n  if (closeName) {\n    addParam(i18nContext.params, closeName, slot, getSubTemplateIndexForTemplateTag(job, i18nBlock, view), flags);\n    if (structuralDirective !== undefined) {\n      addParam(i18nContext.params, closeName, structuralDirective.handle.slot, i18nBlock.subTemplateIndex, flags);\n    }\n  }\n}\nfunction getSubTemplateIndexForTemplateTag(job, i18nOp, view) {\n  for (const childOp of view.create) {\n    if (childOp.kind === OpKind.I18nStart) {\n      return childOp.subTemplateIndex;\n    }\n  }\n  return i18nOp.subTemplateIndex;\n}\nfunction addParam(params, placeholder, value, subTemplateIndex, flags) {\n  const values = params.get(placeholder) ?? [];\n  values.push({\n    value,\n    subTemplateIndex,\n    flags\n  });\n  params.set(placeholder, values);\n}\n\nfunction resolveI18nExpressionPlaceholders(job) {\n  const subTemplateIndices = new Map();\n  const i18nContexts = new Map();\n  const icuPlaceholders = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nStart:\n          subTemplateIndices.set(op.xref, op.subTemplateIndex);\n          break;\n        case OpKind.I18nContext:\n          i18nContexts.set(op.xref, op);\n          break;\n        case OpKind.IcuPlaceholder:\n          icuPlaceholders.set(op.xref, op);\n          break;\n      }\n    }\n  }\n  const expressionIndices = new Map();\n  const referenceIndex = op => op.usage === I18nExpressionFor.I18nText ? op.i18nOwner : op.context;\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      if (op.kind === OpKind.I18nExpression) {\n        const index = expressionIndices.get(referenceIndex(op)) || 0;\n        const subTemplateIndex = subTemplateIndices.get(op.i18nOwner) ?? null;\n        const value = {\n          value: index,\n          subTemplateIndex: subTemplateIndex,\n          flags: I18nParamValueFlags.ExpressionIndex\n        };\n        updatePlaceholder(op, value, i18nContexts, icuPlaceholders);\n        expressionIndices.set(referenceIndex(op), index + 1);\n      }\n    }\n  }\n}\nfunction updatePlaceholder(op, value, i18nContexts, icuPlaceholders) {\n  if (op.i18nPlaceholder !== null) {\n    const i18nContext = i18nContexts.get(op.context);\n    const params = op.resolutionTime === I18nParamResolutionTime.Creation ? i18nContext.params : i18nContext.postprocessingParams;\n    const values = params.get(op.i18nPlaceholder) || [];\n    values.push(value);\n    params.set(op.i18nPlaceholder, values);\n  }\n  if (op.icuPlaceholder !== null) {\n    const icuPlaceholderOp = icuPlaceholders.get(op.icuPlaceholder);\n    icuPlaceholderOp?.expressionPlaceholders.push(value);\n  }\n}\n\nfunction resolveNames(job) {\n  for (const unit of job.units) {\n    processLexicalScope(unit, unit.create, null);\n    processLexicalScope(unit, unit.update, null);\n  }\n}\nfunction processLexicalScope(unit, ops, savedView) {\n  const scope = new Map();\n  const localDefinitions = new Map();\n  for (const op of ops) {\n    switch (op.kind) {\n      case OpKind.Variable:\n        switch (op.variable.kind) {\n          case SemanticVariableKind.Identifier:\n            if (op.variable.local) {\n              if (localDefinitions.has(op.variable.identifier)) {\n                continue;\n              }\n              localDefinitions.set(op.variable.identifier, op.xref);\n            } else if (scope.has(op.variable.identifier)) {\n              continue;\n            }\n            scope.set(op.variable.identifier, op.xref);\n            break;\n          case SemanticVariableKind.Alias:\n            if (scope.has(op.variable.identifier)) {\n              continue;\n            }\n            scope.set(op.variable.identifier, op.xref);\n            break;\n          case SemanticVariableKind.SavedView:\n            savedView = {\n              view: op.variable.view,\n              variable: op.xref\n            };\n            break;\n        }\n        break;\n      case OpKind.Animation:\n      case OpKind.AnimationListener:\n      case OpKind.Listener:\n      case OpKind.TwoWayListener:\n        processLexicalScope(unit, op.handlerOps, savedView);\n        break;\n      case OpKind.RepeaterCreate:\n        if (op.trackByOps !== null) {\n          processLexicalScope(unit, op.trackByOps, savedView);\n        }\n        break;\n    }\n  }\n  for (const op of ops) {\n    if (op.kind == OpKind.Listener || op.kind === OpKind.TwoWayListener || op.kind === OpKind.Animation || op.kind === OpKind.AnimationListener) {\n      continue;\n    }\n    transformExpressionsInOp(op, expr => {\n      if (expr instanceof LexicalReadExpr) {\n        if (localDefinitions.has(expr.name)) {\n          return new ReadVariableExpr(localDefinitions.get(expr.name));\n        } else if (scope.has(expr.name)) {\n          return new ReadVariableExpr(scope.get(expr.name));\n        } else {\n          return new ReadPropExpr(new ContextExpr(unit.job.root.xref), expr.name);\n        }\n      } else if (expr instanceof RestoreViewExpr && typeof expr.view === 'number') {\n        if (savedView === null || savedView.view !== expr.view) {\n          throw new Error(`AssertionError: no saved view ${expr.view} from view ${unit.xref}`);\n        }\n        expr.view = new ReadVariableExpr(savedView.variable);\n        return expr;\n      } else {\n        return expr;\n      }\n    }, VisitorContextFlag.None);\n  }\n  for (const op of ops) {\n    visitExpressionsInOp(op, expr => {\n      if (expr instanceof LexicalReadExpr) {\n        throw new Error(`AssertionError: no lexical reads should remain, but found read of ${expr.name}`);\n      }\n    });\n  }\n}\n\nconst sanitizerFns = new Map([[SecurityContext.HTML, Identifiers.sanitizeHtml], [SecurityContext.RESOURCE_URL, Identifiers.sanitizeResourceUrl], [SecurityContext.SCRIPT, Identifiers.sanitizeScript], [SecurityContext.STYLE, Identifiers.sanitizeStyle], [SecurityContext.URL, Identifiers.sanitizeUrl]]);\nconst trustedValueFns = new Map([[SecurityContext.HTML, Identifiers.trustConstantHtml], [SecurityContext.RESOURCE_URL, Identifiers.trustConstantResourceUrl]]);\nfunction resolveSanitizers(job) {\n  for (const unit of job.units) {\n    const elements = createOpXrefMap(unit);\n    if (job.kind !== CompilationJobKind.Host) {\n      for (const op of unit.create) {\n        if (op.kind === OpKind.ExtractedAttribute) {\n          const trustedValueFn = trustedValueFns.get(getOnlySecurityContext(op.securityContext)) ?? null;\n          op.trustedValueFn = trustedValueFn !== null ? importExpr(trustedValueFn) : null;\n        }\n      }\n    }\n    for (const op of unit.update) {\n      switch (op.kind) {\n        case OpKind.Property:\n        case OpKind.Attribute:\n        case OpKind.DomProperty:\n          let sanitizerFn = null;\n          if (Array.isArray(op.securityContext) && op.securityContext.length === 2 && op.securityContext.indexOf(SecurityContext.URL) > -1 && op.securityContext.indexOf(SecurityContext.RESOURCE_URL) > -1) {\n            sanitizerFn = Identifiers.sanitizeUrlOrResourceUrl;\n          } else {\n            sanitizerFn = sanitizerFns.get(getOnlySecurityContext(op.securityContext)) ?? null;\n          }\n          op.sanitizer = sanitizerFn !== null ? importExpr(sanitizerFn) : null;\n          if (op.sanitizer === null) {\n            let isIframe = false;\n            if (job.kind === CompilationJobKind.Host || op.kind === OpKind.DomProperty) {\n              isIframe = true;\n            } else {\n              const ownerOp = elements.get(op.target);\n              if (ownerOp === undefined || !isElementOrContainerOp(ownerOp)) {\n                throw Error('Property should have an element-like owner');\n              }\n              isIframe = isIframeElement(ownerOp);\n            }\n            if (isIframe && isIframeSecuritySensitiveAttr(op.name)) {\n              op.sanitizer = importExpr(Identifiers.validateIframeAttribute);\n            }\n          }\n          break;\n      }\n    }\n  }\n}\nfunction isIframeElement(op) {\n  return op.kind === OpKind.ElementStart && op.tag?.toLowerCase() === 'iframe';\n}\nfunction getOnlySecurityContext(securityContext) {\n  if (Array.isArray(securityContext)) {\n    if (securityContext.length > 1) {\n      throw Error(`AssertionError: Ambiguous security context`);\n    }\n    return securityContext[0] || SecurityContext.NONE;\n  }\n  return securityContext;\n}\n\nfunction saveAndRestoreView(job) {\n  for (const unit of job.units) {\n    unit.create.prepend([createVariableOp(unit.job.allocateXrefId(), {\n      kind: SemanticVariableKind.SavedView,\n      name: null,\n      view: unit.xref\n    }, new GetCurrentViewExpr(), VariableFlags.None)]);\n    for (const op of unit.create) {\n      if (op.kind !== OpKind.Listener && op.kind !== OpKind.TwoWayListener && op.kind !== OpKind.Animation && op.kind !== OpKind.AnimationListener) {\n        continue;\n      }\n      let needsRestoreView = unit !== job.root;\n      if (!needsRestoreView) {\n        for (const handlerOp of op.handlerOps) {\n          visitExpressionsInOp(handlerOp, expr => {\n            if (expr instanceof ReferenceExpr || expr instanceof ContextLetReferenceExpr) {\n              needsRestoreView = true;\n            }\n          });\n        }\n      }\n      if (needsRestoreView) {\n        addSaveRestoreViewOperationToListener(unit, op);\n      }\n    }\n  }\n}\nfunction addSaveRestoreViewOperationToListener(unit, op) {\n  op.handlerOps.prepend([createVariableOp(unit.job.allocateXrefId(), {\n    kind: SemanticVariableKind.Context,\n    name: null,\n    view: unit.xref\n  }, new RestoreViewExpr(unit.xref), VariableFlags.None)]);\n  for (const handlerOp of op.handlerOps) {\n    if (handlerOp.kind === OpKind.Statement && handlerOp.statement instanceof ReturnStatement) {\n      handlerOp.statement.value = new ResetViewExpr(handlerOp.statement.value);\n    }\n  }\n}\n\nfunction allocateSlots(job) {\n  const slotMap = new Map();\n  for (const unit of job.units) {\n    let slotCount = 0;\n    for (const op of unit.create) {\n      if (!hasConsumesSlotTrait(op)) {\n        continue;\n      }\n      op.handle.slot = slotCount;\n      slotMap.set(op.xref, op.handle.slot);\n      slotCount += op.numSlotsUsed;\n    }\n    unit.decls = slotCount;\n  }\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind === OpKind.Template || op.kind === OpKind.ConditionalCreate || op.kind === OpKind.ConditionalBranchCreate || op.kind === OpKind.RepeaterCreate) {\n        const childView = job.views.get(op.xref);\n        op.decls = childView.decls;\n      }\n    }\n  }\n}\n\nfunction optimizeStoreLet(job) {\n  const letUsedExternally = new Set();\n  const declareLetOps = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind === OpKind.DeclareLet) {\n        declareLetOps.set(op.xref, op);\n      }\n      visitExpressionsInOp(op, expr => {\n        if (expr instanceof ContextLetReferenceExpr) {\n          letUsedExternally.add(expr.target);\n        }\n      });\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      transformExpressionsInOp(op, expr => {\n        if (expr instanceof StoreLetExpr && !letUsedExternally.has(expr.target)) {\n          if (!hasPipe(expr)) {\n            OpList.remove(declareLetOps.get(expr.target));\n          }\n          return expr.value;\n        }\n        return expr;\n      }, VisitorContextFlag.None);\n    }\n  }\n}\nfunction hasPipe(root) {\n  let result = false;\n  transformExpressionsInExpression(root, expr => {\n    if (expr instanceof PipeBindingExpr || expr instanceof PipeBindingVariadicExpr) {\n      result = true;\n    }\n    return expr;\n  }, VisitorContextFlag.None);\n  return result;\n}\n\nfunction stripNonrequiredParentheses(job) {\n  const requiredParens = new Set();\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      visitExpressionsInOp(op, expr => {\n        if (expr instanceof BinaryOperatorExpr) {\n          switch (expr.operator) {\n            case BinaryOperator.Exponentiation:\n              checkExponentiationParens(expr, requiredParens);\n              break;\n            case BinaryOperator.NullishCoalesce:\n              checkNullishCoalescingParens(expr, requiredParens);\n              break;\n            case BinaryOperator.And:\n            case BinaryOperator.Or:\n              checkAndOrParens(expr, requiredParens);\n          }\n        }\n      });\n    }\n  }\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      transformExpressionsInOp(op, expr => {\n        if (expr instanceof ParenthesizedExpr) {\n          return requiredParens.has(expr) ? expr : expr.expr;\n        }\n        return expr;\n      }, VisitorContextFlag.None);\n    }\n  }\n}\nfunction checkExponentiationParens(expr, requiredParens) {\n  if (expr.lhs instanceof ParenthesizedExpr && expr.lhs.expr instanceof UnaryOperatorExpr) {\n    requiredParens.add(expr.lhs);\n  }\n}\nfunction checkNullishCoalescingParens(expr, requiredParens) {\n  if (expr.lhs instanceof ParenthesizedExpr && (isLogicalAndOr(expr.lhs.expr) || expr.lhs.expr instanceof ConditionalExpr)) {\n    requiredParens.add(expr.lhs);\n  }\n  if (expr.rhs instanceof ParenthesizedExpr && (isLogicalAndOr(expr.rhs.expr) || expr.rhs.expr instanceof ConditionalExpr)) {\n    requiredParens.add(expr.rhs);\n  }\n}\nfunction checkAndOrParens(expr, requiredParens) {\n  if (expr.lhs instanceof ParenthesizedExpr && expr.lhs.expr instanceof BinaryOperatorExpr && expr.lhs.expr.operator === BinaryOperator.NullishCoalesce) {\n    requiredParens.add(expr.lhs);\n  }\n}\nfunction isLogicalAndOr(expr) {\n  return expr instanceof BinaryOperatorExpr && (expr.operator === BinaryOperator.And || expr.operator === BinaryOperator.Or);\n}\n\nfunction specializeStyleBindings(job) {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      if (op.kind !== OpKind.Binding) {\n        continue;\n      }\n      switch (op.bindingKind) {\n        case BindingKind.ClassName:\n          if (op.expression instanceof Interpolation) {\n            throw new Error(`Unexpected interpolation in ClassName binding`);\n          }\n          OpList.replace(op, createClassPropOp(op.target, op.name, op.expression, op.sourceSpan));\n          break;\n        case BindingKind.StyleProperty:\n          OpList.replace(op, createStylePropOp(op.target, op.name, op.expression, op.unit, op.sourceSpan));\n          break;\n        case BindingKind.Property:\n        case BindingKind.Template:\n          if (op.name === 'style') {\n            OpList.replace(op, createStyleMapOp(op.target, op.expression, op.sourceSpan));\n          } else if (op.name === 'class') {\n            OpList.replace(op, createClassMapOp(op.target, op.expression, op.sourceSpan));\n          }\n          break;\n      }\n    }\n  }\n}\n\nfunction generateTemporaryVariables(job) {\n  for (const unit of job.units) {\n    unit.create.prepend(generateTemporaries(unit.create));\n    unit.update.prepend(generateTemporaries(unit.update));\n  }\n}\nfunction generateTemporaries(ops) {\n  let opCount = 0;\n  let generatedStatements = [];\n  for (const op of ops) {\n    const finalReads = new Map();\n    visitExpressionsInOp(op, (expr, flag) => {\n      if (flag & VisitorContextFlag.InChildOperation) {\n        return;\n      }\n      if (expr instanceof ReadTemporaryExpr) {\n        finalReads.set(expr.xref, expr);\n      }\n    });\n    let count = 0;\n    const assigned = new Set();\n    const released = new Set();\n    const defs = new Map();\n    visitExpressionsInOp(op, (expr, flag) => {\n      if (flag & VisitorContextFlag.InChildOperation) {\n        return;\n      }\n      if (expr instanceof AssignTemporaryExpr) {\n        if (!assigned.has(expr.xref)) {\n          assigned.add(expr.xref);\n          defs.set(expr.xref, `tmp_${opCount}_${count++}`);\n        }\n        assignName(defs, expr);\n      } else if (expr instanceof ReadTemporaryExpr) {\n        if (finalReads.get(expr.xref) === expr) {\n          released.add(expr.xref);\n          count--;\n        }\n        assignName(defs, expr);\n      }\n    });\n    generatedStatements.push(...Array.from(new Set(defs.values())).map(name => createStatementOp(new DeclareVarStmt(name))));\n    opCount++;\n    if (op.kind === OpKind.Listener || op.kind === OpKind.Animation || op.kind === OpKind.AnimationListener || op.kind === OpKind.TwoWayListener) {\n      op.handlerOps.prepend(generateTemporaries(op.handlerOps));\n    } else if (op.kind === OpKind.RepeaterCreate && op.trackByOps !== null) {\n      op.trackByOps.prepend(generateTemporaries(op.trackByOps));\n    }\n  }\n  return generatedStatements;\n}\nfunction assignName(names, expr) {\n  const name = names.get(expr.xref);\n  if (name === undefined) {\n    throw new Error(`Found xref with unassigned name: ${expr.xref}`);\n  }\n  expr.name = name;\n}\n\nfunction optimizeTrackFns(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind !== OpKind.RepeaterCreate) {\n        continue;\n      }\n      if (op.track instanceof ReadVarExpr && op.track.name === '$index') {\n        op.trackByFn = importExpr(Identifiers.repeaterTrackByIndex);\n      } else if (op.track instanceof ReadVarExpr && op.track.name === '$item') {\n        op.trackByFn = importExpr(Identifiers.repeaterTrackByIdentity);\n      } else if (isTrackByFunctionCall(job.root.xref, op.track)) {\n        op.usesComponentInstance = true;\n        if (op.track.receiver.receiver.view === unit.xref) {\n          op.trackByFn = op.track.receiver;\n        } else {\n          op.trackByFn = importExpr(Identifiers.componentInstance).callFn([]).prop(op.track.receiver.name);\n          op.track = op.trackByFn;\n        }\n      } else {\n        op.track = transformExpressionsInExpression(op.track, expr => {\n          if (expr instanceof PipeBindingExpr || expr instanceof PipeBindingVariadicExpr) {\n            throw new Error(`Illegal State: Pipes are not allowed in this context`);\n          } else if (expr instanceof ContextExpr) {\n            op.usesComponentInstance = true;\n            return new TrackContextExpr(expr.view);\n          }\n          return expr;\n        }, VisitorContextFlag.None);\n        const trackOpList = new OpList();\n        trackOpList.push(createStatementOp(new ReturnStatement(op.track, op.track.sourceSpan)));\n        op.trackByOps = trackOpList;\n      }\n    }\n  }\n}\nfunction isTrackByFunctionCall(rootView, expr) {\n  if (!(expr instanceof InvokeFunctionExpr) || expr.args.length === 0 || expr.args.length > 2) {\n    return false;\n  }\n  if (!(expr.receiver instanceof ReadPropExpr && expr.receiver.receiver instanceof ContextExpr) || expr.receiver.receiver.view !== rootView) {\n    return false;\n  }\n  const [arg0, arg1] = expr.args;\n  if (!(arg0 instanceof ReadVarExpr) || arg0.name !== '$index') {\n    return false;\n  } else if (expr.args.length === 1) {\n    return true;\n  }\n  if (!(arg1 instanceof ReadVarExpr) || arg1.name !== '$item') {\n    return false;\n  }\n  return true;\n}\n\nfunction generateTrackVariables(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind !== OpKind.RepeaterCreate) {\n        continue;\n      }\n      op.track = transformExpressionsInExpression(op.track, expr => {\n        if (expr instanceof LexicalReadExpr) {\n          if (op.varNames.$index.has(expr.name)) {\n            return variable('$index');\n          } else if (expr.name === op.varNames.$implicit) {\n            return variable('$item');\n          }\n        }\n        return expr;\n      }, VisitorContextFlag.None);\n    }\n  }\n}\n\nfunction transformTwoWayBindingSet(job) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === OpKind.TwoWayListener) {\n        transformExpressionsInOp(op, expr => {\n          if (!(expr instanceof TwoWayBindingSetExpr)) {\n            return expr;\n          }\n          const {\n            target,\n            value\n          } = expr;\n          if (target instanceof ReadPropExpr || target instanceof ReadKeyExpr) {\n            return twoWayBindingSet(target, value).or(target.set(value));\n          }\n          if (target instanceof ReadVariableExpr) {\n            return twoWayBindingSet(target, value);\n          }\n          throw new Error(`Unsupported expression in two-way action binding.`);\n        }, VisitorContextFlag.InChildOperation);\n      }\n    }\n  }\n}\n\nfunction countVariables(job) {\n  for (const unit of job.units) {\n    let varCount = 0;\n    for (const op of unit.ops()) {\n      if (hasConsumesVarsTrait(op)) {\n        varCount += varsUsedByOp(op);\n      }\n    }\n    for (const op of unit.ops()) {\n      visitExpressionsInOp(op, expr => {\n        if (!isIrExpression(expr)) {\n          return;\n        }\n        if (job.compatibility === CompatibilityMode.TemplateDefinitionBuilder && expr instanceof PureFunctionExpr) {\n          return;\n        }\n        if (hasUsesVarOffsetTrait(expr)) {\n          expr.varOffset = varCount;\n        }\n        if (hasConsumesVarsTrait(expr)) {\n          varCount += varsUsedByIrExpression(expr);\n        }\n      });\n    }\n    if (job.compatibility === CompatibilityMode.TemplateDefinitionBuilder) {\n      for (const op of unit.ops()) {\n        visitExpressionsInOp(op, expr => {\n          if (!isIrExpression(expr) || !(expr instanceof PureFunctionExpr)) {\n            return;\n          }\n          if (hasUsesVarOffsetTrait(expr)) {\n            expr.varOffset = varCount;\n          }\n          if (hasConsumesVarsTrait(expr)) {\n            varCount += varsUsedByIrExpression(expr);\n          }\n        });\n      }\n    }\n    unit.vars = varCount;\n  }\n  if (job instanceof ComponentCompilationJob) {\n    for (const unit of job.units) {\n      for (const op of unit.create) {\n        if (op.kind !== OpKind.Template && op.kind !== OpKind.RepeaterCreate && op.kind !== OpKind.ConditionalCreate && op.kind !== OpKind.ConditionalBranchCreate) {\n          continue;\n        }\n        const childView = job.views.get(op.xref);\n        op.vars = childView.vars;\n      }\n    }\n  }\n}\nfunction varsUsedByOp(op) {\n  let slots;\n  switch (op.kind) {\n    case OpKind.Attribute:\n      slots = 1;\n      if (op.expression instanceof Interpolation && !isSingletonInterpolation(op.expression)) {\n        slots += op.expression.expressions.length;\n      }\n      return slots;\n    case OpKind.Property:\n    case OpKind.DomProperty:\n      slots = 1;\n      if (op.expression instanceof Interpolation) {\n        slots += op.expression.expressions.length;\n      }\n      return slots;\n    case OpKind.Control:\n      return 2;\n    case OpKind.TwoWayProperty:\n      return 1;\n    case OpKind.StyleProp:\n    case OpKind.ClassProp:\n    case OpKind.StyleMap:\n    case OpKind.ClassMap:\n      slots = 2;\n      if (op.expression instanceof Interpolation) {\n        slots += op.expression.expressions.length;\n      }\n      return slots;\n    case OpKind.InterpolateText:\n      return op.interpolation.expressions.length;\n    case OpKind.I18nExpression:\n    case OpKind.Conditional:\n    case OpKind.DeferWhen:\n    case OpKind.StoreLet:\n      return 1;\n    case OpKind.RepeaterCreate:\n      return op.emptyView ? 1 : 0;\n    default:\n      throw new Error(`Unhandled op: ${OpKind[op.kind]}`);\n  }\n}\nfunction varsUsedByIrExpression(expr) {\n  switch (expr.kind) {\n    case ExpressionKind.PureFunctionExpr:\n      return 1 + expr.args.length;\n    case ExpressionKind.PipeBinding:\n      return 1 + expr.args.length;\n    case ExpressionKind.PipeBindingVariadic:\n      return 1 + expr.numArgs;\n    case ExpressionKind.StoreLet:\n      return 1;\n    default:\n      throw new Error(`AssertionError: unhandled ConsumesVarsTrait expression ${expr.constructor.name}`);\n  }\n}\nfunction isSingletonInterpolation(expr) {\n  if (expr.expressions.length !== 1 || expr.strings.length !== 2) {\n    return false;\n  }\n  if (expr.strings[0] !== '' || expr.strings[1] !== '') {\n    return false;\n  }\n  return true;\n}\n\nfunction optimizeVariables(job) {\n  for (const unit of job.units) {\n    inlineAlwaysInlineVariables(unit.create);\n    inlineAlwaysInlineVariables(unit.update);\n    for (const op of unit.create) {\n      if (op.kind === OpKind.Listener || op.kind === OpKind.Animation || op.kind === OpKind.AnimationListener || op.kind === OpKind.TwoWayListener) {\n        inlineAlwaysInlineVariables(op.handlerOps);\n      } else if (op.kind === OpKind.RepeaterCreate && op.trackByOps !== null) {\n        inlineAlwaysInlineVariables(op.trackByOps);\n      }\n    }\n    optimizeVariablesInOpList(unit.create, job.compatibility);\n    optimizeVariablesInOpList(unit.update, job.compatibility);\n    for (const op of unit.create) {\n      if (op.kind === OpKind.Listener || op.kind === OpKind.Animation || op.kind === OpKind.AnimationListener || op.kind === OpKind.TwoWayListener) {\n        optimizeVariablesInOpList(op.handlerOps, job.compatibility);\n      } else if (op.kind === OpKind.RepeaterCreate && op.trackByOps !== null) {\n        optimizeVariablesInOpList(op.trackByOps, job.compatibility);\n      }\n    }\n  }\n}\nvar Fence;\n(function (Fence) {\n  Fence[Fence[\"None\"] = 0] = \"None\";\n  Fence[Fence[\"ViewContextRead\"] = 1] = \"ViewContextRead\";\n  Fence[Fence[\"ViewContextWrite\"] = 2] = \"ViewContextWrite\";\n  Fence[Fence[\"SideEffectful\"] = 4] = \"SideEffectful\";\n})(Fence || (Fence = {}));\nfunction inlineAlwaysInlineVariables(ops) {\n  const vars = new Map();\n  for (const op of ops) {\n    if (op.kind === OpKind.Variable && op.flags & VariableFlags.AlwaysInline) {\n      visitExpressionsInOp(op, expr => {\n        if (isIrExpression(expr) && fencesForIrExpression(expr) !== Fence.None) {\n          throw new Error(`AssertionError: A context-sensitive variable was marked AlwaysInline`);\n        }\n      });\n      vars.set(op.xref, op);\n    }\n    transformExpressionsInOp(op, expr => {\n      if (expr instanceof ReadVariableExpr && vars.has(expr.xref)) {\n        const varOp = vars.get(expr.xref);\n        return varOp.initializer.clone();\n      }\n      return expr;\n    }, VisitorContextFlag.None);\n  }\n  for (const op of vars.values()) {\n    OpList.remove(op);\n  }\n}\nfunction optimizeVariablesInOpList(ops, compatibility) {\n  const varDecls = new Map();\n  const varUsages = new Map();\n  const varRemoteUsages = new Set();\n  const opMap = new Map();\n  for (const op of ops) {\n    if (op.kind === OpKind.Variable) {\n      if (varDecls.has(op.xref) || varUsages.has(op.xref)) {\n        throw new Error(`Should not see two declarations of the same variable: ${op.xref}`);\n      }\n      varDecls.set(op.xref, op);\n      varUsages.set(op.xref, 0);\n    }\n    opMap.set(op, collectOpInfo(op));\n    countVariableUsages(op, varUsages, varRemoteUsages);\n  }\n  let contextIsUsed = false;\n  for (const op of ops.reversed()) {\n    const opInfo = opMap.get(op);\n    if (op.kind === OpKind.Variable && varUsages.get(op.xref) === 0) {\n      if (contextIsUsed && opInfo.fences & Fence.ViewContextWrite || opInfo.fences & Fence.SideEffectful) {\n        const stmtOp = createStatementOp(op.initializer.toStmt());\n        opMap.set(stmtOp, opInfo);\n        OpList.replace(op, stmtOp);\n      } else {\n        uncountVariableUsages(op, varUsages);\n        OpList.remove(op);\n      }\n      opMap.delete(op);\n      varDecls.delete(op.xref);\n      varUsages.delete(op.xref);\n      continue;\n    }\n    if (opInfo.fences & Fence.ViewContextRead) {\n      contextIsUsed = true;\n    }\n  }\n  const toInline = [];\n  for (const [id, count] of varUsages) {\n    const decl = varDecls.get(id);\n    const isAlwaysInline = !!(decl.flags & VariableFlags.AlwaysInline);\n    if (count !== 1 || isAlwaysInline) {\n      continue;\n    }\n    if (varRemoteUsages.has(id)) {\n      continue;\n    }\n    toInline.push(id);\n  }\n  let candidate;\n  while (candidate = toInline.pop()) {\n    const decl = varDecls.get(candidate);\n    const varInfo = opMap.get(decl);\n    const isAlwaysInline = !!(decl.flags & VariableFlags.AlwaysInline);\n    if (isAlwaysInline) {\n      throw new Error(`AssertionError: Found an 'AlwaysInline' variable after the always inlining pass.`);\n    }\n    for (let targetOp = decl.next; targetOp.kind !== OpKind.ListEnd; targetOp = targetOp.next) {\n      const opInfo = opMap.get(targetOp);\n      if (opInfo.variablesUsed.has(candidate)) {\n        if (compatibility === CompatibilityMode.TemplateDefinitionBuilder && !allowConservativeInlining(decl, targetOp)) {\n          break;\n        }\n        if (tryInlineVariableInitializer(candidate, decl.initializer, targetOp, varInfo.fences)) {\n          opInfo.variablesUsed.delete(candidate);\n          for (const id of varInfo.variablesUsed) {\n            opInfo.variablesUsed.add(id);\n          }\n          opInfo.fences |= varInfo.fences;\n          varDecls.delete(candidate);\n          varUsages.delete(candidate);\n          opMap.delete(decl);\n          OpList.remove(decl);\n        }\n        break;\n      }\n      if (!safeToInlinePastFences(opInfo.fences, varInfo.fences)) {\n        break;\n      }\n    }\n  }\n}\nfunction fencesForIrExpression(expr) {\n  switch (expr.kind) {\n    case ExpressionKind.NextContext:\n      return Fence.ViewContextRead | Fence.ViewContextWrite;\n    case ExpressionKind.RestoreView:\n      return Fence.ViewContextRead | Fence.ViewContextWrite | Fence.SideEffectful;\n    case ExpressionKind.StoreLet:\n      return Fence.SideEffectful;\n    case ExpressionKind.Reference:\n    case ExpressionKind.ContextLetReference:\n      return Fence.ViewContextRead;\n    default:\n      return Fence.None;\n  }\n}\nfunction collectOpInfo(op) {\n  let fences = Fence.None;\n  const variablesUsed = new Set();\n  visitExpressionsInOp(op, expr => {\n    if (!isIrExpression(expr)) {\n      return;\n    }\n    switch (expr.kind) {\n      case ExpressionKind.ReadVariable:\n        variablesUsed.add(expr.xref);\n        break;\n      default:\n        fences |= fencesForIrExpression(expr);\n    }\n  });\n  return {\n    fences,\n    variablesUsed\n  };\n}\nfunction countVariableUsages(op, varUsages, varRemoteUsage) {\n  visitExpressionsInOp(op, (expr, flags) => {\n    if (!isIrExpression(expr)) {\n      return;\n    }\n    if (expr.kind !== ExpressionKind.ReadVariable) {\n      return;\n    }\n    const count = varUsages.get(expr.xref);\n    if (count === undefined) {\n      return;\n    }\n    varUsages.set(expr.xref, count + 1);\n    if (flags & VisitorContextFlag.InChildOperation) {\n      varRemoteUsage.add(expr.xref);\n    }\n  });\n}\nfunction uncountVariableUsages(op, varUsages) {\n  visitExpressionsInOp(op, expr => {\n    if (!isIrExpression(expr)) {\n      return;\n    }\n    if (expr.kind !== ExpressionKind.ReadVariable) {\n      return;\n    }\n    const count = varUsages.get(expr.xref);\n    if (count === undefined) {\n      return;\n    } else if (count === 0) {\n      throw new Error(`Inaccurate variable count: ${expr.xref} - found another read but count is already 0`);\n    }\n    varUsages.set(expr.xref, count - 1);\n  });\n}\nfunction safeToInlinePastFences(fences, declFences) {\n  if (fences & Fence.ViewContextWrite) {\n    if (declFences & Fence.ViewContextRead) {\n      return false;\n    }\n  } else if (fences & Fence.ViewContextRead) {\n    if (declFences & Fence.ViewContextWrite) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction tryInlineVariableInitializer(id, initializer, target, declFences) {\n  let inlined = false;\n  let inliningAllowed = true;\n  transformExpressionsInOp(target, (expr, flags) => {\n    if (!isIrExpression(expr)) {\n      return expr;\n    }\n    if (inlined || !inliningAllowed) {\n      return expr;\n    } else if (flags & VisitorContextFlag.InChildOperation && declFences & Fence.ViewContextRead) {\n      return expr;\n    }\n    switch (expr.kind) {\n      case ExpressionKind.ReadVariable:\n        if (expr.xref === id) {\n          inlined = true;\n          return initializer;\n        }\n        break;\n      default:\n        const exprFences = fencesForIrExpression(expr);\n        inliningAllowed = inliningAllowed && safeToInlinePastFences(exprFences, declFences);\n        break;\n    }\n    return expr;\n  }, VisitorContextFlag.None);\n  return inlined;\n}\nfunction allowConservativeInlining(decl, target) {\n  switch (decl.variable.kind) {\n    case SemanticVariableKind.Identifier:\n      if (decl.initializer instanceof ReadVarExpr && decl.initializer.name === 'ctx') {\n        return true;\n      }\n      return false;\n    case SemanticVariableKind.Context:\n      return target.kind === OpKind.Variable;\n    default:\n      return true;\n  }\n}\n\nfunction wrapI18nIcus(job) {\n  for (const unit of job.units) {\n    let currentI18nOp = null;\n    let addedI18nId = null;\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case OpKind.I18nStart:\n          currentI18nOp = op;\n          break;\n        case OpKind.I18nEnd:\n          currentI18nOp = null;\n          break;\n        case OpKind.IcuStart:\n          if (currentI18nOp === null) {\n            addedI18nId = job.allocateXrefId();\n            OpList.insertBefore(createI18nStartOp(addedI18nId, op.message, undefined, null), op);\n          }\n          break;\n        case OpKind.IcuEnd:\n          if (addedI18nId !== null) {\n            OpList.insertAfter(createI18nEndOp(addedI18nId, null), op);\n            addedI18nId = null;\n          }\n          break;\n      }\n    }\n  }\n}\n\n/**\n *\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nconst phases = [{\n  kind: CompilationJobKind.Tmpl,\n  fn: removeContentSelectors\n}, {\n  kind: CompilationJobKind.Both,\n  fn: optimizeRegularExpressions\n}, {\n  kind: CompilationJobKind.Host,\n  fn: parseHostStyleProperties\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: emitNamespaceChanges\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: propagateI18nBlocks\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: wrapI18nIcus\n}, {\n  kind: CompilationJobKind.Both,\n  fn: deduplicateTextBindings\n}, {\n  kind: CompilationJobKind.Both,\n  fn: specializeStyleBindings\n}, {\n  kind: CompilationJobKind.Both,\n  fn: specializeBindings\n}, {\n  kind: CompilationJobKind.Both,\n  fn: convertAnimations\n}, {\n  kind: CompilationJobKind.Both,\n  fn: extractAttributes\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: createI18nContexts\n}, {\n  kind: CompilationJobKind.Both,\n  fn: parseExtractedStyles\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: removeEmptyBindings\n}, {\n  kind: CompilationJobKind.Both,\n  fn: collapseSingletonInterpolations\n}, {\n  kind: CompilationJobKind.Both,\n  fn: orderOps\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: generateConditionalExpressions\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: createPipes\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: configureDeferInstructions\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: createVariadicPipes\n}, {\n  kind: CompilationJobKind.Both,\n  fn: generatePureLiteralStructures\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: generateProjectionDefs\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: generateLocalLetReferences\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: generateVariables\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: saveAndRestoreView\n}, {\n  kind: CompilationJobKind.Both,\n  fn: deleteAnyCasts\n}, {\n  kind: CompilationJobKind.Both,\n  fn: resolveDollarEvent\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: generateTrackVariables\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: removeIllegalLetReferences\n}, {\n  kind: CompilationJobKind.Both,\n  fn: resolveNames\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: resolveDeferTargetNames\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: transformTwoWayBindingSet\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: optimizeTrackFns\n}, {\n  kind: CompilationJobKind.Both,\n  fn: resolveContexts\n}, {\n  kind: CompilationJobKind.Both,\n  fn: resolveSanitizers\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: liftLocalRefs\n}, {\n  kind: CompilationJobKind.Both,\n  fn: expandSafeReads\n}, {\n  kind: CompilationJobKind.Both,\n  fn: stripNonrequiredParentheses\n}, {\n  kind: CompilationJobKind.Both,\n  fn: generateTemporaryVariables\n}, {\n  kind: CompilationJobKind.Both,\n  fn: optimizeVariables\n}, {\n  kind: CompilationJobKind.Both,\n  fn: optimizeStoreLet\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: convertI18nText\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: convertI18nBindings\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: removeUnusedI18nAttributesOps\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: assignI18nSlotDependencies\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: applyI18nExpressions\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: allocateSlots\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: resolveI18nElementPlaceholders\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: resolveI18nExpressionPlaceholders\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: extractI18nMessages\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: collectI18nConsts\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: collectConstExpressions\n}, {\n  kind: CompilationJobKind.Both,\n  fn: collectElementConsts\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: removeI18nContexts\n}, {\n  kind: CompilationJobKind.Both,\n  fn: countVariables\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: generateAdvance\n}, {\n  kind: CompilationJobKind.Both,\n  fn: nameFunctionsAndVariables\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: resolveDeferDepsFns\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: mergeNextContextExpressions\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: generateNgContainerOps\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: collapseEmptyInstructions\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: attachSourceLocations\n}, {\n  kind: CompilationJobKind.Tmpl,\n  fn: disableBindings$1\n}, {\n  kind: CompilationJobKind.Both,\n  fn: extractPureFunctions\n}, {\n  kind: CompilationJobKind.Both,\n  fn: reify\n}, {\n  kind: CompilationJobKind.Both,\n  fn: chain\n}];\nfunction transform(job, kind) {\n  for (const phase of phases) {\n    if (phase.kind === kind || phase.kind === CompilationJobKind.Both) {\n      phase.fn(job);\n    }\n  }\n}\nfunction emitTemplateFn(tpl, pool) {\n  const rootFn = emitView(tpl.root);\n  emitChildViews(tpl.root, pool);\n  return rootFn;\n}\nfunction emitChildViews(parent, pool) {\n  for (const unit of parent.job.units) {\n    if (unit.parent !== parent.xref) {\n      continue;\n    }\n    emitChildViews(unit, pool);\n    const viewFn = emitView(unit);\n    pool.statements.push(viewFn.toDeclStmt(viewFn.name));\n  }\n}\nfunction emitView(view) {\n  if (view.fnName === null) {\n    throw new Error(`AssertionError: view ${view.xref} is unnamed`);\n  }\n  const createStatements = [];\n  for (const op of view.create) {\n    if (op.kind !== OpKind.Statement) {\n      throw new Error(`AssertionError: expected all create ops to have been compiled, but got ${OpKind[op.kind]}`);\n    }\n    createStatements.push(op.statement);\n  }\n  const updateStatements = [];\n  for (const op of view.update) {\n    if (op.kind !== OpKind.Statement) {\n      throw new Error(`AssertionError: expected all update ops to have been compiled, but got ${OpKind[op.kind]}`);\n    }\n    updateStatements.push(op.statement);\n  }\n  const createCond = maybeGenerateRfBlock(1, createStatements);\n  const updateCond = maybeGenerateRfBlock(2, updateStatements);\n  return fn([new FnParam('rf'), new FnParam('ctx')], [...createCond, ...updateCond], undefined, undefined, view.fnName);\n}\nfunction maybeGenerateRfBlock(flag, statements) {\n  if (statements.length === 0) {\n    return [];\n  }\n  return [ifStmt(new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, variable('rf'), literal(flag)), statements)];\n}\nfunction emitHostBindingFunction(job) {\n  if (job.root.fnName === null) {\n    throw new Error(`AssertionError: host binding function is unnamed`);\n  }\n  const createStatements = [];\n  for (const op of job.root.create) {\n    if (op.kind !== OpKind.Statement) {\n      throw new Error(`AssertionError: expected all create ops to have been compiled, but got ${OpKind[op.kind]}`);\n    }\n    createStatements.push(op.statement);\n  }\n  const updateStatements = [];\n  for (const op of job.root.update) {\n    if (op.kind !== OpKind.Statement) {\n      throw new Error(`AssertionError: expected all update ops to have been compiled, but got ${OpKind[op.kind]}`);\n    }\n    updateStatements.push(op.statement);\n  }\n  if (createStatements.length === 0 && updateStatements.length === 0) {\n    return null;\n  }\n  const createCond = maybeGenerateRfBlock(1, createStatements);\n  const updateCond = maybeGenerateRfBlock(2, updateStatements);\n  return fn([new FnParam('rf'), new FnParam('ctx')], [...createCond, ...updateCond], undefined, undefined, job.root.fnName);\n}\n\nconst compatibilityMode = CompatibilityMode.TemplateDefinitionBuilder;\nconst domSchema = new DomElementSchemaRegistry();\nconst NG_TEMPLATE_TAG_NAME = 'ng-template';\nconst ANIMATE_PREFIX$1 = 'animate.';\nfunction isI18nRootNode(meta) {\n  return meta instanceof Message;\n}\nfunction isSingleI18nIcu(meta) {\n  return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof Icu;\n}\nfunction ingestComponent(componentName, template, constantPool, compilationMode, relativeContextFilePath, i18nUseExternalIds, deferMeta, allDeferrableDepsFn, relativeTemplatePath, enableDebugLocations) {\n  const job = new ComponentCompilationJob(componentName, constantPool, compatibilityMode, compilationMode, relativeContextFilePath, i18nUseExternalIds, deferMeta, allDeferrableDepsFn, relativeTemplatePath, enableDebugLocations);\n  ingestNodes(job.root, template);\n  return job;\n}\nfunction ingestHostBinding(input, bindingParser, constantPool) {\n  const job = new HostBindingCompilationJob(input.componentName, constantPool, compatibilityMode, TemplateCompilationMode.DomOnly);\n  for (const property of input.properties ?? []) {\n    let bindingKind = BindingKind.Property;\n    if (property.name.startsWith('attr.')) {\n      property.name = property.name.substring('attr.'.length);\n      bindingKind = BindingKind.Attribute;\n    }\n    if (property.isLegacyAnimation) {\n      bindingKind = BindingKind.LegacyAnimation;\n    }\n    if (property.isAnimation) {\n      bindingKind = BindingKind.Animation;\n    }\n    const securityContexts = bindingParser.calcPossibleSecurityContexts(input.componentSelector, property.name, bindingKind === BindingKind.Attribute).filter(context => context !== SecurityContext.NONE);\n    ingestDomProperty(job, property, bindingKind, securityContexts);\n  }\n  for (const [name, expr] of Object.entries(input.attributes) ?? []) {\n    const securityContexts = bindingParser.calcPossibleSecurityContexts(input.componentSelector, name, true).filter(context => context !== SecurityContext.NONE);\n    ingestHostAttribute(job, name, expr, securityContexts);\n  }\n  for (const event of input.events ?? []) {\n    ingestHostEvent(job, event);\n  }\n  return job;\n}\nfunction ingestDomProperty(job, property, bindingKind, securityContexts) {\n  let expression;\n  const ast = property.expression.ast;\n  if (ast instanceof Interpolation$1) {\n    expression = new Interpolation(ast.strings, ast.expressions.map(expr => convertAst(expr, job, property.sourceSpan)), []);\n  } else {\n    expression = convertAst(ast, job, property.sourceSpan);\n  }\n  job.root.update.push(createBindingOp(job.root.xref, bindingKind, property.name, expression, null, securityContexts, false, false, null, null, property.sourceSpan));\n}\nfunction ingestHostAttribute(job, name, value, securityContexts) {\n  const attrBinding = createBindingOp(job.root.xref, BindingKind.Attribute, name, value, null, securityContexts, true, false, null, null, value.sourceSpan);\n  job.root.update.push(attrBinding);\n}\nfunction ingestHostEvent(job, event) {\n  let eventBinding;\n  if (event.type === ParsedEventType.Animation) {\n    eventBinding = createAnimationListenerOp(job.root.xref, new SlotHandle(), event.name, null, makeListenerHandlerOps(job.root, event.handler, event.handlerSpan), event.name.endsWith('enter') ? \"enter\" : \"leave\", event.targetOrPhase, true, event.sourceSpan);\n  } else {\n    const [phase, target] = event.type !== ParsedEventType.LegacyAnimation ? [null, event.targetOrPhase] : [event.targetOrPhase, null];\n    eventBinding = createListenerOp(job.root.xref, new SlotHandle(), event.name, null, makeListenerHandlerOps(job.root, event.handler, event.handlerSpan), phase, target, true, event.sourceSpan);\n  }\n  job.root.create.push(eventBinding);\n}\nfunction ingestNodes(unit, template) {\n  for (const node of template) {\n    if (node instanceof Element$1) {\n      ingestElement(unit, node);\n    } else if (node instanceof Template) {\n      ingestTemplate(unit, node);\n    } else if (node instanceof Content) {\n      ingestContent(unit, node);\n    } else if (node instanceof Text$3) {\n      ingestText(unit, node, null);\n    } else if (node instanceof BoundText) {\n      ingestBoundText(unit, node, null);\n    } else if (node instanceof IfBlock) {\n      ingestIfBlock(unit, node);\n    } else if (node instanceof SwitchBlock) {\n      ingestSwitchBlock(unit, node);\n    } else if (node instanceof DeferredBlock) {\n      ingestDeferBlock(unit, node);\n    } else if (node instanceof Icu$1) {\n      ingestIcu(unit, node);\n    } else if (node instanceof ForLoopBlock) {\n      ingestForBlock(unit, node);\n    } else if (node instanceof LetDeclaration$1) {\n      ingestLetDeclaration(unit, node);\n    } else if (node instanceof Component$1) ; else {\n      throw new Error(`Unsupported template node: ${node.constructor.name}`);\n    }\n  }\n}\nfunction ingestElement(unit, element) {\n  if (element.i18n !== undefined && !(element.i18n instanceof Message || element.i18n instanceof TagPlaceholder)) {\n    throw Error(`Unhandled i18n metadata type for element: ${element.i18n.constructor.name}`);\n  }\n  const id = unit.job.allocateXrefId();\n  const [namespaceKey, elementName] = splitNsName(element.name);\n  const startOp = createElementStartOp(elementName, id, namespaceForKey(namespaceKey), element.i18n instanceof TagPlaceholder ? element.i18n : undefined, element.startSourceSpan, element.sourceSpan);\n  unit.create.push(startOp);\n  ingestElementBindings(unit, startOp, element);\n  ingestReferences(startOp, element);\n  let i18nBlockId = null;\n  if (element.i18n instanceof Message) {\n    i18nBlockId = unit.job.allocateXrefId();\n    unit.create.push(createI18nStartOp(i18nBlockId, element.i18n, undefined, element.startSourceSpan));\n  }\n  ingestNodes(unit, element.children);\n  const endOp = createElementEndOp(id, element.endSourceSpan ?? element.startSourceSpan);\n  unit.create.push(endOp);\n  if (i18nBlockId !== null) {\n    OpList.insertBefore(createI18nEndOp(i18nBlockId, element.endSourceSpan ?? element.startSourceSpan), endOp);\n  }\n}\nfunction ingestTemplate(unit, tmpl) {\n  if (tmpl.i18n !== undefined && !(tmpl.i18n instanceof Message || tmpl.i18n instanceof TagPlaceholder)) {\n    throw Error(`Unhandled i18n metadata type for template: ${tmpl.i18n.constructor.name}`);\n  }\n  const childView = unit.job.allocateView(unit.xref);\n  let tagNameWithoutNamespace = tmpl.tagName;\n  let namespacePrefix = '';\n  if (tmpl.tagName) {\n    [namespacePrefix, tagNameWithoutNamespace] = splitNsName(tmpl.tagName);\n  }\n  const i18nPlaceholder = tmpl.i18n instanceof TagPlaceholder ? tmpl.i18n : undefined;\n  const namespace = namespaceForKey(namespacePrefix);\n  const functionNameSuffix = tagNameWithoutNamespace === null ? '' : prefixWithNamespace(tagNameWithoutNamespace, namespace);\n  const templateKind = isPlainTemplate(tmpl) ? TemplateKind.NgTemplate : TemplateKind.Structural;\n  const templateOp = createTemplateOp(childView.xref, templateKind, tagNameWithoutNamespace, functionNameSuffix, namespace, i18nPlaceholder, tmpl.startSourceSpan, tmpl.sourceSpan);\n  unit.create.push(templateOp);\n  ingestTemplateBindings(unit, templateOp, tmpl, templateKind);\n  ingestReferences(templateOp, tmpl);\n  ingestNodes(childView, tmpl.children);\n  for (const {\n    name,\n    value\n  } of tmpl.variables) {\n    childView.contextVariables.set(name, value !== '' ? value : '$implicit');\n  }\n  if (templateKind === TemplateKind.NgTemplate && tmpl.i18n instanceof Message) {\n    const id = unit.job.allocateXrefId();\n    OpList.insertAfter(createI18nStartOp(id, tmpl.i18n, undefined, tmpl.startSourceSpan), childView.create.head);\n    OpList.insertBefore(createI18nEndOp(id, tmpl.endSourceSpan ?? tmpl.startSourceSpan), childView.create.tail);\n  }\n}\nfunction ingestContent(unit, content) {\n  if (content.i18n !== undefined && !(content.i18n instanceof TagPlaceholder)) {\n    throw Error(`Unhandled i18n metadata type for element: ${content.i18n.constructor.name}`);\n  }\n  let fallbackView = null;\n  if (content.children.some(child => !(child instanceof Comment$1) && (!(child instanceof Text$3) || child.value.trim().length > 0))) {\n    fallbackView = unit.job.allocateView(unit.xref);\n    ingestNodes(fallbackView, content.children);\n  }\n  const id = unit.job.allocateXrefId();\n  const op = createProjectionOp(id, content.selector, content.i18n, fallbackView?.xref ?? null, content.sourceSpan);\n  for (const attr of content.attributes) {\n    const securityContext = domSchema.securityContext(content.name, attr.name, true);\n    unit.update.push(createBindingOp(op.xref, BindingKind.Attribute, attr.name, literal(attr.value), null, securityContext, true, false, null, asMessage(attr.i18n), attr.sourceSpan));\n  }\n  unit.create.push(op);\n}\nfunction ingestText(unit, text, icuPlaceholder) {\n  unit.create.push(createTextOp(unit.job.allocateXrefId(), text.value, icuPlaceholder, text.sourceSpan));\n}\nfunction ingestBoundText(unit, text, icuPlaceholder) {\n  let value = text.value;\n  if (value instanceof ASTWithSource) {\n    value = value.ast;\n  }\n  if (!(value instanceof Interpolation$1)) {\n    throw new Error(`AssertionError: expected Interpolation for BoundText node, got ${value.constructor.name}`);\n  }\n  if (text.i18n !== undefined && !(text.i18n instanceof Container)) {\n    throw Error(`Unhandled i18n metadata type for text interpolation: ${text.i18n?.constructor.name}`);\n  }\n  const i18nPlaceholders = text.i18n instanceof Container ? text.i18n.children.filter(node => node instanceof Placeholder).map(placeholder => placeholder.name) : [];\n  if (i18nPlaceholders.length > 0 && i18nPlaceholders.length !== value.expressions.length) {\n    throw Error(`Unexpected number of i18n placeholders (${value.expressions.length}) for BoundText with ${value.expressions.length} expressions`);\n  }\n  const textXref = unit.job.allocateXrefId();\n  unit.create.push(createTextOp(textXref, '', icuPlaceholder, text.sourceSpan));\n  const baseSourceSpan = unit.job.compatibility ? null : text.sourceSpan;\n  unit.update.push(createInterpolateTextOp(textXref, new Interpolation(value.strings, value.expressions.map(expr => convertAst(expr, unit.job, baseSourceSpan)), i18nPlaceholders), text.sourceSpan));\n}\nfunction ingestIfBlock(unit, ifBlock) {\n  let firstXref = null;\n  let conditions = [];\n  for (let i = 0; i < ifBlock.branches.length; i++) {\n    const ifCase = ifBlock.branches[i];\n    const cView = unit.job.allocateView(unit.xref);\n    const tagName = ingestControlFlowInsertionPoint(unit, cView.xref, ifCase);\n    if (ifCase.expressionAlias !== null) {\n      cView.contextVariables.set(ifCase.expressionAlias.name, CTX_REF);\n    }\n    let ifCaseI18nMeta = undefined;\n    if (ifCase.i18n !== undefined) {\n      if (!(ifCase.i18n instanceof BlockPlaceholder)) {\n        throw Error(`Unhandled i18n metadata type for if block: ${ifCase.i18n?.constructor.name}`);\n      }\n      ifCaseI18nMeta = ifCase.i18n;\n    }\n    const createOp = i === 0 ? createConditionalCreateOp : createConditionalBranchCreateOp;\n    const conditionalCreateOp = createOp(cView.xref, TemplateKind.Block, tagName, 'Conditional', Namespace.HTML, ifCaseI18nMeta, ifCase.startSourceSpan, ifCase.sourceSpan);\n    unit.create.push(conditionalCreateOp);\n    if (firstXref === null) {\n      firstXref = cView.xref;\n    }\n    const caseExpr = ifCase.expression ? convertAst(ifCase.expression, unit.job, null) : null;\n    const conditionalCaseExpr = new ConditionalCaseExpr(caseExpr, conditionalCreateOp.xref, conditionalCreateOp.handle, ifCase.expressionAlias);\n    conditions.push(conditionalCaseExpr);\n    ingestNodes(cView, ifCase.children);\n  }\n  unit.update.push(createConditionalOp(firstXref, null, conditions, ifBlock.sourceSpan));\n}\nfunction ingestSwitchBlock(unit, switchBlock) {\n  if (switchBlock.cases.length === 0) {\n    return;\n  }\n  let firstXref = null;\n  let conditions = [];\n  for (let i = 0; i < switchBlock.cases.length; i++) {\n    const switchCase = switchBlock.cases[i];\n    const cView = unit.job.allocateView(unit.xref);\n    const tagName = ingestControlFlowInsertionPoint(unit, cView.xref, switchCase);\n    let switchCaseI18nMeta = undefined;\n    if (switchCase.i18n !== undefined) {\n      if (!(switchCase.i18n instanceof BlockPlaceholder)) {\n        throw Error(`Unhandled i18n metadata type for switch block: ${switchCase.i18n?.constructor.name}`);\n      }\n      switchCaseI18nMeta = switchCase.i18n;\n    }\n    const createOp = i === 0 ? createConditionalCreateOp : createConditionalBranchCreateOp;\n    const conditionalCreateOp = createOp(cView.xref, TemplateKind.Block, tagName, 'Case', Namespace.HTML, switchCaseI18nMeta, switchCase.startSourceSpan, switchCase.sourceSpan);\n    unit.create.push(conditionalCreateOp);\n    if (firstXref === null) {\n      firstXref = cView.xref;\n    }\n    const caseExpr = switchCase.expression ? convertAst(switchCase.expression, unit.job, switchBlock.startSourceSpan) : null;\n    const conditionalCaseExpr = new ConditionalCaseExpr(caseExpr, conditionalCreateOp.xref, conditionalCreateOp.handle);\n    conditions.push(conditionalCaseExpr);\n    ingestNodes(cView, switchCase.children);\n  }\n  unit.update.push(createConditionalOp(firstXref, convertAst(switchBlock.expression, unit.job, null), conditions, switchBlock.sourceSpan));\n}\nfunction ingestDeferView(unit, suffix, i18nMeta, children, sourceSpan) {\n  if (i18nMeta !== undefined && !(i18nMeta instanceof BlockPlaceholder)) {\n    throw Error('Unhandled i18n metadata type for defer block');\n  }\n  if (children === undefined) {\n    return null;\n  }\n  const secondaryView = unit.job.allocateView(unit.xref);\n  ingestNodes(secondaryView, children);\n  const templateOp = createTemplateOp(secondaryView.xref, TemplateKind.Block, null, `Defer${suffix}`, Namespace.HTML, i18nMeta, sourceSpan, sourceSpan);\n  unit.create.push(templateOp);\n  return templateOp;\n}\nfunction ingestDeferBlock(unit, deferBlock) {\n  let ownResolverFn = null;\n  if (unit.job.deferMeta.mode === 0) {\n    if (!unit.job.deferMeta.blocks.has(deferBlock)) {\n      throw new Error(`AssertionError: unable to find a dependency function for this deferred block`);\n    }\n    ownResolverFn = unit.job.deferMeta.blocks.get(deferBlock) ?? null;\n  }\n  const main = ingestDeferView(unit, '', deferBlock.i18n, deferBlock.children, deferBlock.sourceSpan);\n  const loading = ingestDeferView(unit, 'Loading', deferBlock.loading?.i18n, deferBlock.loading?.children, deferBlock.loading?.sourceSpan);\n  const placeholder = ingestDeferView(unit, 'Placeholder', deferBlock.placeholder?.i18n, deferBlock.placeholder?.children, deferBlock.placeholder?.sourceSpan);\n  const error = ingestDeferView(unit, 'Error', deferBlock.error?.i18n, deferBlock.error?.children, deferBlock.error?.sourceSpan);\n  const deferXref = unit.job.allocateXrefId();\n  const deferOp = createDeferOp(deferXref, main.xref, main.handle, ownResolverFn, unit.job.allDeferrableDepsFn, deferBlock.sourceSpan);\n  deferOp.placeholderView = placeholder?.xref ?? null;\n  deferOp.placeholderSlot = placeholder?.handle ?? null;\n  deferOp.loadingSlot = loading?.handle ?? null;\n  deferOp.errorSlot = error?.handle ?? null;\n  deferOp.placeholderMinimumTime = deferBlock.placeholder?.minimumTime ?? null;\n  deferOp.loadingMinimumTime = deferBlock.loading?.minimumTime ?? null;\n  deferOp.loadingAfterTime = deferBlock.loading?.afterTime ?? null;\n  deferOp.flags = calcDeferBlockFlags(deferBlock);\n  unit.create.push(deferOp);\n  const deferOnOps = [];\n  const deferWhenOps = [];\n  ingestDeferTriggers(\"hydrate\", deferBlock.hydrateTriggers, deferOnOps, deferWhenOps, unit, deferXref);\n  ingestDeferTriggers(\"none\", deferBlock.triggers, deferOnOps, deferWhenOps, unit, deferXref);\n  ingestDeferTriggers(\"prefetch\", deferBlock.prefetchTriggers, deferOnOps, deferWhenOps, unit, deferXref);\n  const hasConcreteTrigger = deferOnOps.some(op => op.modifier === \"none\") || deferWhenOps.some(op => op.modifier === \"none\");\n  if (!hasConcreteTrigger) {\n    deferOnOps.push(createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Idle\n    }, \"none\", null));\n  }\n  unit.create.push(deferOnOps);\n  unit.update.push(deferWhenOps);\n}\nfunction calcDeferBlockFlags(deferBlockDetails) {\n  if (Object.keys(deferBlockDetails.hydrateTriggers).length > 0) {\n    return 1;\n  }\n  return null;\n}\nfunction ingestDeferTriggers(modifier, triggers, onOps, whenOps, unit, deferXref) {\n  if (triggers.idle !== undefined) {\n    const deferOnOp = createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Idle\n    }, modifier, triggers.idle.sourceSpan);\n    onOps.push(deferOnOp);\n  }\n  if (triggers.immediate !== undefined) {\n    const deferOnOp = createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Immediate\n    }, modifier, triggers.immediate.sourceSpan);\n    onOps.push(deferOnOp);\n  }\n  if (triggers.timer !== undefined) {\n    const deferOnOp = createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Timer,\n      delay: triggers.timer.delay\n    }, modifier, triggers.timer.sourceSpan);\n    onOps.push(deferOnOp);\n  }\n  if (triggers.hover !== undefined) {\n    const deferOnOp = createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Hover,\n      targetName: triggers.hover.reference,\n      targetXref: null,\n      targetSlot: null,\n      targetView: null,\n      targetSlotViewSteps: null\n    }, modifier, triggers.hover.sourceSpan);\n    onOps.push(deferOnOp);\n  }\n  if (triggers.interaction !== undefined) {\n    const deferOnOp = createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Interaction,\n      targetName: triggers.interaction.reference,\n      targetXref: null,\n      targetSlot: null,\n      targetView: null,\n      targetSlotViewSteps: null\n    }, modifier, triggers.interaction.sourceSpan);\n    onOps.push(deferOnOp);\n  }\n  if (triggers.viewport !== undefined) {\n    const deferOnOp = createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Viewport,\n      targetName: triggers.viewport.reference,\n      targetXref: null,\n      targetSlot: null,\n      targetView: null,\n      targetSlotViewSteps: null,\n      options: triggers.viewport.options ? convertAst(triggers.viewport.options, unit.job, triggers.viewport.sourceSpan) : null\n    }, modifier, triggers.viewport.sourceSpan);\n    onOps.push(deferOnOp);\n  }\n  if (triggers.never !== undefined) {\n    const deferOnOp = createDeferOnOp(deferXref, {\n      kind: DeferTriggerKind.Never\n    }, modifier, triggers.never.sourceSpan);\n    onOps.push(deferOnOp);\n  }\n  if (triggers.when !== undefined) {\n    if (triggers.when.value instanceof Interpolation$1) {\n      throw new Error(`Unexpected interpolation in defer block when trigger`);\n    }\n    const deferOnOp = createDeferWhenOp(deferXref, convertAst(triggers.when.value, unit.job, triggers.when.sourceSpan), modifier, triggers.when.sourceSpan);\n    whenOps.push(deferOnOp);\n  }\n}\nfunction ingestIcu(unit, icu) {\n  if (icu.i18n instanceof Message && isSingleI18nIcu(icu.i18n)) {\n    const xref = unit.job.allocateXrefId();\n    unit.create.push(createIcuStartOp(xref, icu.i18n, icuFromI18nMessage(icu.i18n).name, null));\n    for (const [placeholder, text] of Object.entries({\n      ...icu.vars,\n      ...icu.placeholders\n    })) {\n      if (text instanceof BoundText) {\n        ingestBoundText(unit, text, placeholder);\n      } else {\n        ingestText(unit, text, placeholder);\n      }\n    }\n    unit.create.push(createIcuEndOp(xref));\n  } else {\n    throw Error(`Unhandled i18n metadata type for ICU: ${icu.i18n?.constructor.name}`);\n  }\n}\nfunction ingestForBlock(unit, forBlock) {\n  const repeaterView = unit.job.allocateView(unit.xref);\n  const indexName = `Éµ$index_${repeaterView.xref}`;\n  const countName = `Éµ$count_${repeaterView.xref}`;\n  const indexVarNames = new Set();\n  repeaterView.contextVariables.set(forBlock.item.name, forBlock.item.value);\n  for (const variable of forBlock.contextVariables) {\n    if (variable.value === '$index') {\n      indexVarNames.add(variable.name);\n    }\n    if (variable.name === '$index') {\n      repeaterView.contextVariables.set('$index', variable.value).set(indexName, variable.value);\n    } else if (variable.name === '$count') {\n      repeaterView.contextVariables.set('$count', variable.value).set(countName, variable.value);\n    } else {\n      repeaterView.aliases.add({\n        kind: SemanticVariableKind.Alias,\n        name: null,\n        identifier: variable.name,\n        expression: getComputedForLoopVariableExpression(variable, indexName, countName)\n      });\n    }\n  }\n  const sourceSpan = convertSourceSpan(forBlock.trackBy.span, forBlock.sourceSpan);\n  const track = convertAst(forBlock.trackBy, unit.job, sourceSpan);\n  ingestNodes(repeaterView, forBlock.children);\n  let emptyView = null;\n  let emptyTagName = null;\n  if (forBlock.empty !== null) {\n    emptyView = unit.job.allocateView(unit.xref);\n    ingestNodes(emptyView, forBlock.empty.children);\n    emptyTagName = ingestControlFlowInsertionPoint(unit, emptyView.xref, forBlock.empty);\n  }\n  const varNames = {\n    $index: indexVarNames,\n    $implicit: forBlock.item.name\n  };\n  if (forBlock.i18n !== undefined && !(forBlock.i18n instanceof BlockPlaceholder)) {\n    throw Error('AssertionError: Unhandled i18n metadata type or @for');\n  }\n  if (forBlock.empty?.i18n !== undefined && !(forBlock.empty.i18n instanceof BlockPlaceholder)) {\n    throw Error('AssertionError: Unhandled i18n metadata type or @empty');\n  }\n  const i18nPlaceholder = forBlock.i18n;\n  const emptyI18nPlaceholder = forBlock.empty?.i18n;\n  const tagName = ingestControlFlowInsertionPoint(unit, repeaterView.xref, forBlock);\n  const repeaterCreate = createRepeaterCreateOp(repeaterView.xref, emptyView?.xref ?? null, tagName, track, varNames, emptyTagName, i18nPlaceholder, emptyI18nPlaceholder, forBlock.startSourceSpan, forBlock.sourceSpan);\n  unit.create.push(repeaterCreate);\n  const expression = convertAst(forBlock.expression, unit.job, convertSourceSpan(forBlock.expression.span, forBlock.sourceSpan));\n  const repeater = createRepeaterOp(repeaterCreate.xref, repeaterCreate.handle, expression, forBlock.sourceSpan);\n  unit.update.push(repeater);\n}\nfunction getComputedForLoopVariableExpression(variable, indexName, countName) {\n  switch (variable.value) {\n    case '$index':\n      return new LexicalReadExpr(indexName);\n    case '$count':\n      return new LexicalReadExpr(countName);\n    case '$first':\n      return new LexicalReadExpr(indexName).identical(literal(0));\n    case '$last':\n      return new LexicalReadExpr(indexName).identical(new LexicalReadExpr(countName).minus(literal(1)));\n    case '$even':\n      return new LexicalReadExpr(indexName).modulo(literal(2)).identical(literal(0));\n    case '$odd':\n      return new LexicalReadExpr(indexName).modulo(literal(2)).notIdentical(literal(0));\n    default:\n      throw new Error(`AssertionError: unknown @for loop variable ${variable.value}`);\n  }\n}\nfunction ingestLetDeclaration(unit, node) {\n  const target = unit.job.allocateXrefId();\n  unit.create.push(createDeclareLetOp(target, node.name, node.sourceSpan));\n  unit.update.push(createStoreLetOp(target, node.name, convertAst(node.value, unit.job, node.valueSpan), node.sourceSpan));\n}\nfunction convertAst(ast, job, baseSourceSpan) {\n  if (ast instanceof ASTWithSource) {\n    return convertAst(ast.ast, job, baseSourceSpan);\n  } else if (ast instanceof PropertyRead) {\n    const isImplicitReceiver = ast.receiver instanceof ImplicitReceiver && !(ast.receiver instanceof ThisReceiver);\n    if (isImplicitReceiver) {\n      return new LexicalReadExpr(ast.name);\n    } else {\n      return new ReadPropExpr(convertAst(ast.receiver, job, baseSourceSpan), ast.name, null, convertSourceSpan(ast.span, baseSourceSpan));\n    }\n  } else if (ast instanceof Call) {\n    if (ast.receiver instanceof ImplicitReceiver) {\n      throw new Error(`Unexpected ImplicitReceiver`);\n    } else {\n      return new InvokeFunctionExpr(convertAst(ast.receiver, job, baseSourceSpan), ast.args.map(arg => convertAst(arg, job, baseSourceSpan)), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n    }\n  } else if (ast instanceof LiteralPrimitive) {\n    return literal(ast.value, undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof Unary) {\n    switch (ast.operator) {\n      case '+':\n        return new UnaryOperatorExpr(UnaryOperator.Plus, convertAst(ast.expr, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n      case '-':\n        return new UnaryOperatorExpr(UnaryOperator.Minus, convertAst(ast.expr, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n      default:\n        throw new Error(`AssertionError: unknown unary operator ${ast.operator}`);\n    }\n  } else if (ast instanceof Binary) {\n    const operator = BINARY_OPERATORS.get(ast.operation);\n    if (operator === undefined) {\n      throw new Error(`AssertionError: unknown binary operator ${ast.operation}`);\n    }\n    return new BinaryOperatorExpr(operator, convertAst(ast.left, job, baseSourceSpan), convertAst(ast.right, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof ThisReceiver) {\n    return new ContextExpr(job.root.xref);\n  } else if (ast instanceof KeyedRead) {\n    return new ReadKeyExpr(convertAst(ast.receiver, job, baseSourceSpan), convertAst(ast.key, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof Chain) {\n    throw new Error(`AssertionError: Chain in unknown context`);\n  } else if (ast instanceof LiteralMap) {\n    const entries = ast.keys.map((key, idx) => {\n      const value = ast.values[idx];\n      return new LiteralMapEntry(key.key, convertAst(value, job, baseSourceSpan), key.quoted);\n    });\n    return new LiteralMapExpr(entries, undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof LiteralArray) {\n    return new LiteralArrayExpr(ast.expressions.map(expr => convertAst(expr, job, baseSourceSpan)));\n  } else if (ast instanceof Conditional) {\n    return new ConditionalExpr(convertAst(ast.condition, job, baseSourceSpan), convertAst(ast.trueExp, job, baseSourceSpan), convertAst(ast.falseExp, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof NonNullAssert) {\n    return convertAst(ast.expression, job, baseSourceSpan);\n  } else if (ast instanceof BindingPipe) {\n    return new PipeBindingExpr(job.allocateXrefId(), new SlotHandle(), ast.name, [convertAst(ast.exp, job, baseSourceSpan), ...ast.args.map(arg => convertAst(arg, job, baseSourceSpan))]);\n  } else if (ast instanceof SafeKeyedRead) {\n    return new SafeKeyedReadExpr(convertAst(ast.receiver, job, baseSourceSpan), convertAst(ast.key, job, baseSourceSpan), convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof SafePropertyRead) {\n    return new SafePropertyReadExpr(convertAst(ast.receiver, job, baseSourceSpan), ast.name);\n  } else if (ast instanceof SafeCall) {\n    return new SafeInvokeFunctionExpr(convertAst(ast.receiver, job, baseSourceSpan), ast.args.map(a => convertAst(a, job, baseSourceSpan)));\n  } else if (ast instanceof EmptyExpr$1) {\n    return new EmptyExpr(convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof PrefixNot) {\n    return not(convertAst(ast.expression, job, baseSourceSpan), convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof TypeofExpression) {\n    return typeofExpr(convertAst(ast.expression, job, baseSourceSpan));\n  } else if (ast instanceof VoidExpression) {\n    return new VoidExpr(convertAst(ast.expression, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof TemplateLiteral) {\n    return convertTemplateLiteral(ast, job, baseSourceSpan);\n  } else if (ast instanceof TaggedTemplateLiteral) {\n    return new TaggedTemplateLiteralExpr(convertAst(ast.tag, job, baseSourceSpan), convertTemplateLiteral(ast.template, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof ParenthesizedExpression) {\n    return new ParenthesizedExpr(convertAst(ast.expression, job, baseSourceSpan), undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof RegularExpressionLiteral) {\n    return new RegularExpressionLiteralExpr(ast.body, ast.flags, baseSourceSpan);\n  } else {\n    throw new Error(`Unhandled expression type \"${ast.constructor.name}\" in file \"${baseSourceSpan?.start.file.url}\"`);\n  }\n}\nfunction convertTemplateLiteral(ast, job, baseSourceSpan) {\n  return new TemplateLiteralExpr(ast.elements.map(el => {\n    return new TemplateLiteralElementExpr(el.text, convertSourceSpan(el.span, baseSourceSpan));\n  }), ast.expressions.map(expr => convertAst(expr, job, baseSourceSpan)), convertSourceSpan(ast.span, baseSourceSpan));\n}\nfunction convertAstWithInterpolation(job, value, i18nMeta, sourceSpan) {\n  let expression;\n  if (value instanceof Interpolation$1) {\n    expression = new Interpolation(value.strings, value.expressions.map(e => convertAst(e, job, null)), Object.keys(asMessage(i18nMeta)?.placeholders ?? {}));\n  } else if (value instanceof AST) {\n    expression = convertAst(value, job, null);\n  } else {\n    expression = literal(value);\n  }\n  return expression;\n}\nconst BINDING_KINDS = new Map([[BindingType.Property, BindingKind.Property], [BindingType.TwoWay, BindingKind.TwoWayProperty], [BindingType.Attribute, BindingKind.Attribute], [BindingType.Class, BindingKind.ClassName], [BindingType.Style, BindingKind.StyleProperty], [BindingType.LegacyAnimation, BindingKind.LegacyAnimation], [BindingType.Animation, BindingKind.Animation]]);\nfunction isPlainTemplate(tmpl) {\n  return splitNsName(tmpl.tagName ?? '')[1] === NG_TEMPLATE_TAG_NAME;\n}\nfunction asMessage(i18nMeta) {\n  if (i18nMeta == null) {\n    return null;\n  }\n  if (!(i18nMeta instanceof Message)) {\n    throw Error(`Expected i18n meta to be a Message, but got: ${i18nMeta.constructor.name}`);\n  }\n  return i18nMeta;\n}\nfunction ingestElementBindings(unit, op, element) {\n  let bindings = new Array();\n  let i18nAttributeBindingNames = new Set();\n  for (const attr of element.attributes) {\n    const securityContext = domSchema.securityContext(element.name, attr.name, true);\n    bindings.push(createBindingOp(op.xref, BindingKind.Attribute, attr.name, convertAstWithInterpolation(unit.job, attr.value, attr.i18n), null, securityContext, true, false, null, asMessage(attr.i18n), attr.sourceSpan));\n    if (attr.i18n) {\n      i18nAttributeBindingNames.add(attr.name);\n    }\n  }\n  for (const input of element.inputs) {\n    if (i18nAttributeBindingNames.has(input.name)) {\n      console.error(`On component ${unit.job.componentName}, the binding ${input.name} is both an i18n attribute and a property. You may want to remove the property binding. This will become a compilation error in future versions of Angular.`);\n    }\n    bindings.push(createBindingOp(op.xref, BINDING_KINDS.get(input.type), input.name, convertAstWithInterpolation(unit.job, astOf(input.value), input.i18n), input.unit, input.securityContext, false, false, null, asMessage(input.i18n) ?? null, input.sourceSpan));\n    if (input.type === BindingType.Property && input.name === 'field') {\n      unit.create.push(createControlCreateOp(input.sourceSpan));\n    }\n  }\n  unit.create.push(bindings.filter(b => b?.kind === OpKind.ExtractedAttribute));\n  unit.update.push(bindings.filter(b => b?.kind === OpKind.Binding));\n  for (const output of element.outputs) {\n    if (output.type === ParsedEventType.LegacyAnimation && output.phase === null) {\n      throw Error('Animation listener should have a phase');\n    }\n    if (output.type === ParsedEventType.TwoWay) {\n      unit.create.push(createTwoWayListenerOp(op.xref, op.handle, output.name, op.tag, makeTwoWayListenerHandlerOps(unit, output.handler, output.handlerSpan), output.sourceSpan));\n    } else if (output.type === ParsedEventType.Animation) {\n      unit.create.push(createAnimationListenerOp(op.xref, op.handle, output.name, op.tag, makeListenerHandlerOps(unit, output.handler, output.handlerSpan), output.name.endsWith('enter') ? \"enter\" : \"leave\", output.target, false, output.sourceSpan));\n    } else {\n      unit.create.push(createListenerOp(op.xref, op.handle, output.name, op.tag, makeListenerHandlerOps(unit, output.handler, output.handlerSpan), output.phase, output.target, false, output.sourceSpan));\n    }\n  }\n  if (bindings.some(b => b?.i18nMessage) !== null) {\n    unit.create.push(createI18nAttributesOp(unit.job.allocateXrefId(), new SlotHandle(), op.xref));\n  }\n}\nfunction ingestTemplateBindings(unit, op, template, templateKind) {\n  let bindings = new Array();\n  for (const attr of template.templateAttrs) {\n    if (attr instanceof TextAttribute) {\n      const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, attr.name, true);\n      bindings.push(createTemplateBinding(unit, op.xref, BindingType.Attribute, attr.name, attr.value, null, securityContext, true, templateKind, asMessage(attr.i18n), attr.sourceSpan));\n    } else {\n      bindings.push(createTemplateBinding(unit, op.xref, attr.type, attr.name, astOf(attr.value), attr.unit, attr.securityContext, true, templateKind, asMessage(attr.i18n), attr.sourceSpan));\n    }\n  }\n  for (const attr of template.attributes) {\n    const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, attr.name, true);\n    bindings.push(createTemplateBinding(unit, op.xref, BindingType.Attribute, attr.name, attr.value, null, securityContext, false, templateKind, asMessage(attr.i18n), attr.sourceSpan));\n  }\n  for (const input of template.inputs) {\n    bindings.push(createTemplateBinding(unit, op.xref, input.type, input.name, astOf(input.value), input.unit, input.securityContext, false, templateKind, asMessage(input.i18n), input.sourceSpan));\n  }\n  unit.create.push(bindings.filter(b => b?.kind === OpKind.ExtractedAttribute));\n  unit.update.push(bindings.filter(b => b?.kind === OpKind.Binding));\n  for (const output of template.outputs) {\n    if (output.type === ParsedEventType.LegacyAnimation && output.phase === null) {\n      throw Error('Animation listener should have a phase');\n    }\n    if (templateKind === TemplateKind.NgTemplate) {\n      if (output.type === ParsedEventType.TwoWay) {\n        unit.create.push(createTwoWayListenerOp(op.xref, op.handle, output.name, op.tag, makeTwoWayListenerHandlerOps(unit, output.handler, output.handlerSpan), output.sourceSpan));\n      } else {\n        unit.create.push(createListenerOp(op.xref, op.handle, output.name, op.tag, makeListenerHandlerOps(unit, output.handler, output.handlerSpan), output.phase, output.target, false, output.sourceSpan));\n      }\n    }\n    if (templateKind === TemplateKind.Structural && output.type !== ParsedEventType.LegacyAnimation) {\n      const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, output.name, false);\n      unit.create.push(createExtractedAttributeOp(op.xref, BindingKind.Property, null, output.name, null, null, null, securityContext));\n    }\n  }\n  if (bindings.some(b => b?.i18nMessage) !== null) {\n    unit.create.push(createI18nAttributesOp(unit.job.allocateXrefId(), new SlotHandle(), op.xref));\n  }\n}\nfunction createTemplateBinding(view, xref, type, name, value, unit, securityContext, isStructuralTemplateAttribute, templateKind, i18nMessage, sourceSpan) {\n  const isTextBinding = typeof value === 'string';\n  if (templateKind === TemplateKind.Structural) {\n    if (!isStructuralTemplateAttribute) {\n      switch (type) {\n        case BindingType.Property:\n        case BindingType.Class:\n        case BindingType.Style:\n          return createExtractedAttributeOp(xref, BindingKind.Property, null, name, null, null, i18nMessage, securityContext);\n        case BindingType.TwoWay:\n          return createExtractedAttributeOp(xref, BindingKind.TwoWayProperty, null, name, null, null, i18nMessage, securityContext);\n      }\n    }\n    if (!isTextBinding && (type === BindingType.Attribute || type === BindingType.LegacyAnimation || type === BindingType.Animation)) {\n      return null;\n    }\n  }\n  let bindingType = BINDING_KINDS.get(type);\n  if (templateKind === TemplateKind.NgTemplate) {\n    if (type === BindingType.Class || type === BindingType.Style || type === BindingType.Attribute && !isTextBinding) {\n      bindingType = BindingKind.Property;\n    }\n  }\n  return createBindingOp(xref, bindingType, name, convertAstWithInterpolation(view.job, value, i18nMessage), unit, securityContext, isTextBinding, isStructuralTemplateAttribute, templateKind, i18nMessage, sourceSpan);\n}\nfunction makeListenerHandlerOps(unit, handler, handlerSpan) {\n  handler = astOf(handler);\n  const handlerOps = new Array();\n  let handlerExprs = handler instanceof Chain ? handler.expressions : [handler];\n  if (handlerExprs.length === 0) {\n    throw new Error('Expected listener to have non-empty expression list.');\n  }\n  const expressions = handlerExprs.map(expr => convertAst(expr, unit.job, handlerSpan));\n  const returnExpr = expressions.pop();\n  handlerOps.push(...expressions.map(e => createStatementOp(new ExpressionStatement(e, e.sourceSpan))));\n  handlerOps.push(createStatementOp(new ReturnStatement(returnExpr, returnExpr.sourceSpan)));\n  return handlerOps;\n}\nfunction makeTwoWayListenerHandlerOps(unit, handler, handlerSpan) {\n  handler = astOf(handler);\n  const handlerOps = new Array();\n  if (handler instanceof Chain) {\n    if (handler.expressions.length === 1) {\n      handler = handler.expressions[0];\n    } else {\n      throw new Error('Expected two-way listener to have a single expression.');\n    }\n  }\n  const handlerExpr = convertAst(handler, unit.job, handlerSpan);\n  const eventReference = new LexicalReadExpr('$event');\n  const twoWaySetExpr = new TwoWayBindingSetExpr(handlerExpr, eventReference);\n  handlerOps.push(createStatementOp(new ExpressionStatement(twoWaySetExpr)));\n  handlerOps.push(createStatementOp(new ReturnStatement(eventReference)));\n  return handlerOps;\n}\nfunction astOf(ast) {\n  return ast instanceof ASTWithSource ? ast.ast : ast;\n}\nfunction ingestReferences(op, element) {\n  assertIsArray(op.localRefs);\n  for (const {\n    name,\n    value\n  } of element.references) {\n    op.localRefs.push({\n      name,\n      target: value\n    });\n  }\n}\nfunction assertIsArray(value) {\n  if (!Array.isArray(value)) {\n    throw new Error(`AssertionError: expected an array`);\n  }\n}\nfunction convertSourceSpan(span, baseSourceSpan) {\n  if (baseSourceSpan === null) {\n    return null;\n  }\n  const start = baseSourceSpan.start.moveBy(span.start);\n  const end = baseSourceSpan.start.moveBy(span.end);\n  const fullStart = baseSourceSpan.fullStart.moveBy(span.start);\n  return new ParseSourceSpan(start, end, fullStart);\n}\nfunction ingestControlFlowInsertionPoint(unit, xref, node) {\n  let root = null;\n  for (const child of node.children) {\n    if (child instanceof Comment$1 || child instanceof LetDeclaration$1) {\n      continue;\n    }\n    if (root !== null) {\n      return null;\n    }\n    if (child instanceof Element$1 || child instanceof Template && child.tagName !== null) {\n      root = child;\n    } else {\n      return null;\n    }\n  }\n  if (root !== null) {\n    for (const attr of root.attributes) {\n      if (!attr.name.startsWith(ANIMATE_PREFIX$1)) {\n        const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, attr.name, true);\n        unit.update.push(createBindingOp(xref, BindingKind.Attribute, attr.name, literal(attr.value), null, securityContext, true, false, null, asMessage(attr.i18n), attr.sourceSpan));\n      }\n    }\n    for (const attr of root.inputs) {\n      if (attr.type !== BindingType.LegacyAnimation && attr.type !== BindingType.Animation && attr.type !== BindingType.Attribute) {\n        const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, attr.name, true);\n        unit.create.push(createExtractedAttributeOp(xref, BindingKind.Property, null, attr.name, null, null, null, securityContext));\n      }\n    }\n    const tagName = root instanceof Element$1 ? root.name : root.tagName;\n    return tagName === NG_TEMPLATE_TAG_NAME ? null : tagName;\n  }\n  return null;\n}\n\nlet ENABLE_TEMPLATE_SOURCE_LOCATIONS = false;\nfunction setEnableTemplateSourceLocations(value) {\n  ENABLE_TEMPLATE_SOURCE_LOCATIONS = value;\n}\nfunction getTemplateSourceLocationsEnabled() {\n  return ENABLE_TEMPLATE_SOURCE_LOCATIONS;\n}\n\nfunction renderFlagCheckIfStmt(flags, statements) {\n  return ifStmt(variable(RENDER_FLAGS).bitwiseAnd(literal(flags), null), statements);\n}\nfunction toQueryFlags(query) {\n  return (query.descendants ? 1 : 0) | (query.static ? 2 : 0) | (query.emitDistinctChangesOnly ? 4 : 0);\n}\nfunction getQueryPredicate(query, constantPool) {\n  if (Array.isArray(query.predicate)) {\n    let predicate = [];\n    query.predicate.forEach(selector => {\n      const selectors = selector.split(',').map(token => literal(token.trim()));\n      predicate.push(...selectors);\n    });\n    return constantPool.getConstLiteral(literalArr(predicate), true);\n  } else {\n    switch (query.predicate.forwardRef) {\n      case 0:\n      case 2:\n        return query.predicate.expression;\n      case 1:\n        return importExpr(Identifiers.resolveForwardRef).callFn([query.predicate.expression]);\n    }\n  }\n}\nfunction createQueryCreateCall(query, constantPool, queryTypeFns, prependParams) {\n  const parameters = [];\n  if (prependParams !== undefined) {\n    parameters.push(...prependParams);\n  }\n  if (query.isSignal) {\n    parameters.push(new ReadPropExpr(variable(CONTEXT_NAME), query.propertyName));\n  }\n  parameters.push(getQueryPredicate(query, constantPool), literal(toQueryFlags(query)));\n  if (query.read) {\n    parameters.push(query.read);\n  }\n  const queryCreateFn = query.isSignal ? queryTypeFns.signalBased : queryTypeFns.nonSignal;\n  return importExpr(queryCreateFn).callFn(parameters);\n}\nconst queryAdvancePlaceholder = Symbol('queryAdvancePlaceholder');\nfunction collapseAdvanceStatements(statements) {\n  const result = [];\n  let advanceCollapseCount = 0;\n  const flushAdvanceCount = () => {\n    if (advanceCollapseCount > 0) {\n      result.unshift(importExpr(Identifiers.queryAdvance).callFn(advanceCollapseCount === 1 ? [] : [literal(advanceCollapseCount)]).toStmt());\n      advanceCollapseCount = 0;\n    }\n  };\n  for (let i = statements.length - 1; i >= 0; i--) {\n    const st = statements[i];\n    if (st === queryAdvancePlaceholder) {\n      advanceCollapseCount++;\n    } else {\n      flushAdvanceCount();\n      result.unshift(st);\n    }\n  }\n  flushAdvanceCount();\n  return result;\n}\nfunction createViewQueriesFunction(viewQueries, constantPool, name) {\n  const createStatements = [];\n  const updateStatements = [];\n  const tempAllocator = temporaryAllocator(st => updateStatements.push(st), TEMPORARY_NAME);\n  viewQueries.forEach(query => {\n    const queryDefinitionCall = createQueryCreateCall(query, constantPool, {\n      signalBased: Identifiers.viewQuerySignal,\n      nonSignal: Identifiers.viewQuery\n    });\n    createStatements.push(queryDefinitionCall.toStmt());\n    if (query.isSignal) {\n      updateStatements.push(queryAdvancePlaceholder);\n      return;\n    }\n    const temporary = tempAllocator();\n    const getQueryList = importExpr(Identifiers.loadQuery).callFn([]);\n    const refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);\n    const updateDirective = variable(CONTEXT_NAME).prop(query.propertyName).set(query.first ? temporary.prop('first') : temporary);\n    updateStatements.push(refresh.and(updateDirective).toStmt());\n  });\n  const viewQueryFnName = name ? `${name}_Query` : null;\n  return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [renderFlagCheckIfStmt(1, createStatements), renderFlagCheckIfStmt(2, collapseAdvanceStatements(updateStatements))], INFERRED_TYPE, null, viewQueryFnName);\n}\nfunction createContentQueriesFunction(queries, constantPool, name) {\n  const createStatements = [];\n  const updateStatements = [];\n  const tempAllocator = temporaryAllocator(st => updateStatements.push(st), TEMPORARY_NAME);\n  for (const query of queries) {\n    createStatements.push(createQueryCreateCall(query, constantPool, {\n      nonSignal: Identifiers.contentQuery,\n      signalBased: Identifiers.contentQuerySignal\n    }, [variable('dirIndex')]).toStmt());\n    if (query.isSignal) {\n      updateStatements.push(queryAdvancePlaceholder);\n      continue;\n    }\n    const temporary = tempAllocator();\n    const getQueryList = importExpr(Identifiers.loadQuery).callFn([]);\n    const refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);\n    const updateDirective = variable(CONTEXT_NAME).prop(query.propertyName).set(query.first ? temporary.prop('first') : temporary);\n    updateStatements.push(refresh.and(updateDirective).toStmt());\n  }\n  const contentQueriesFnName = name ? `${name}_ContentQueries` : null;\n  return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null), new FnParam('dirIndex', null)], [renderFlagCheckIfStmt(1, createStatements), renderFlagCheckIfStmt(2, collapseAdvanceStatements(updateStatements))], INFERRED_TYPE, null, contentQueriesFnName);\n}\n\nclass HtmlParser extends Parser$1 {\n  constructor() {\n    super(getHtmlTagDefinition);\n  }\n  parse(source, url, options) {\n    return super.parse(source, url, options);\n  }\n}\n\nconst PROPERTY_PARTS_SEPARATOR = '.';\nconst ATTRIBUTE_PREFIX = 'attr';\nconst ANIMATE_PREFIX = 'animate';\nconst CLASS_PREFIX = 'class';\nconst STYLE_PREFIX = 'style';\nconst TEMPLATE_ATTR_PREFIX$1 = '*';\nconst LEGACY_ANIMATE_PROP_PREFIX = 'animate-';\nclass BindingParser {\n  _exprParser;\n  _schemaRegistry;\n  errors;\n  constructor(_exprParser, _schemaRegistry, errors) {\n    this._exprParser = _exprParser;\n    this._schemaRegistry = _schemaRegistry;\n    this.errors = errors;\n  }\n  createBoundHostProperties(properties, sourceSpan) {\n    const boundProps = [];\n    for (const propName of Object.keys(properties)) {\n      const expression = properties[propName];\n      if (typeof expression === 'string') {\n        this.parsePropertyBinding(propName, expression, true, false, sourceSpan, sourceSpan.start.offset, undefined, [], boundProps, sourceSpan);\n      } else {\n        this._reportError(`Value of the host property binding \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`, sourceSpan);\n      }\n    }\n    return boundProps;\n  }\n  createDirectiveHostEventAsts(hostListeners, sourceSpan) {\n    const targetEvents = [];\n    for (const propName of Object.keys(hostListeners)) {\n      const expression = hostListeners[propName];\n      if (typeof expression === 'string') {\n        this.parseEvent(propName, expression, false, sourceSpan, sourceSpan, [], targetEvents, sourceSpan);\n      } else {\n        this._reportError(`Value of the host listener \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`, sourceSpan);\n      }\n    }\n    return targetEvents;\n  }\n  parseInterpolation(value, sourceSpan, interpolatedTokens) {\n    const absoluteOffset = sourceSpan.fullStart.offset;\n    try {\n      const ast = this._exprParser.parseInterpolation(value, sourceSpan, absoluteOffset, interpolatedTokens);\n      if (ast) {\n        this.errors.push(...ast.errors);\n      }\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n    }\n  }\n  parseInterpolationExpression(expression, sourceSpan) {\n    const absoluteOffset = sourceSpan.start.offset;\n    try {\n      const ast = this._exprParser.parseInterpolationExpression(expression, sourceSpan, absoluteOffset);\n      if (ast) {\n        this.errors.push(...ast.errors);\n      }\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n    }\n  }\n  parseInlineTemplateBinding(tplKey, tplValue, sourceSpan, absoluteValueOffset, targetMatchableAttrs, targetProps, targetVars, isIvyAst) {\n    const absoluteKeyOffset = sourceSpan.start.offset + TEMPLATE_ATTR_PREFIX$1.length;\n    const bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);\n    for (const binding of bindings) {\n      const bindingSpan = moveParseSourceSpan(sourceSpan, binding.sourceSpan);\n      const key = binding.key.source;\n      const keySpan = moveParseSourceSpan(sourceSpan, binding.key.span);\n      if (binding instanceof VariableBinding) {\n        const value = binding.value ? binding.value.source : '$implicit';\n        const valueSpan = binding.value ? moveParseSourceSpan(sourceSpan, binding.value.span) : undefined;\n        targetVars.push(new ParsedVariable(key, value, bindingSpan, keySpan, valueSpan));\n      } else if (binding.value) {\n        const srcSpan = isIvyAst ? bindingSpan : sourceSpan;\n        const valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);\n        this._parsePropertyAst(key, binding.value, false, srcSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n      } else {\n        targetMatchableAttrs.push([key, '']);\n        this.parseLiteralAttr(key, null, keySpan, absoluteValueOffset, undefined, targetMatchableAttrs, targetProps, keySpan);\n      }\n    }\n  }\n  _parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset) {\n    try {\n      const bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);\n      bindingsResult.errors.forEach(e => this.errors.push(e));\n      bindingsResult.warnings.forEach(warning => {\n        this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);\n      });\n      return bindingsResult.templateBindings;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return [];\n    }\n  }\n  parseLiteralAttr(name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps, keySpan) {\n    if (isLegacyAnimationLabel(name)) {\n      name = name.substring(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n      }\n      if (value) {\n        this._reportError(`Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid.` + ` Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.`, sourceSpan, ParseErrorLevel.ERROR);\n      }\n      this._parseLegacyAnimation(name, value, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n    } else {\n      targetProps.push(new ParsedProperty(name, this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset), ParsedPropertyType.LITERAL_ATTR, sourceSpan, keySpan, valueSpan));\n    }\n  }\n  parsePropertyBinding(name, expression, isHost, isPartOfAssignmentBinding, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps, keySpan) {\n    if (name.length === 0) {\n      this._reportError(`Property name is missing in binding`, sourceSpan);\n    }\n    let isLegacyAnimationProp = false;\n    if (name.startsWith(LEGACY_ANIMATE_PROP_PREFIX)) {\n      isLegacyAnimationProp = true;\n      name = name.substring(LEGACY_ANIMATE_PROP_PREFIX.length);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + LEGACY_ANIMATE_PROP_PREFIX.length, keySpan.end.offset));\n      }\n    } else if (isLegacyAnimationLabel(name)) {\n      isLegacyAnimationProp = true;\n      name = name.substring(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n      }\n    }\n    if (isLegacyAnimationProp) {\n      this._parseLegacyAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n    } else if (name.startsWith(`${ANIMATE_PREFIX}${PROPERTY_PARTS_SEPARATOR}`)) {\n      this._parseAnimation(name, this.parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset), sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n    } else {\n      this._parsePropertyAst(name, this.parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset), isPartOfAssignmentBinding, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n    }\n  }\n  parsePropertyInterpolation(name, value, sourceSpan, valueSpan, targetMatchableAttrs, targetProps, keySpan, interpolatedTokens) {\n    const expr = this.parseInterpolation(value, valueSpan || sourceSpan, interpolatedTokens);\n    if (expr) {\n      this._parsePropertyAst(name, expr, false, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n      return true;\n    }\n    return false;\n  }\n  _parsePropertyAst(name, ast, isPartOfAssignmentBinding, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps) {\n    targetMatchableAttrs.push([name, ast.source]);\n    targetProps.push(new ParsedProperty(name, ast, isPartOfAssignmentBinding ? ParsedPropertyType.TWO_WAY : ParsedPropertyType.DEFAULT, sourceSpan, keySpan, valueSpan));\n  }\n  _parseAnimation(name, ast, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps) {\n    targetMatchableAttrs.push([name, ast.source]);\n    targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan, keySpan, valueSpan));\n  }\n  _parseLegacyAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps) {\n    if (name.length === 0) {\n      this._reportError('Animation trigger is missing', sourceSpan);\n    }\n    const ast = this.parseBinding(expression || 'undefined', false, valueSpan || sourceSpan, absoluteOffset);\n    targetMatchableAttrs.push([name, ast.source]);\n    targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.LEGACY_ANIMATION, sourceSpan, keySpan, valueSpan));\n  }\n  parseBinding(value, isHostBinding, sourceSpan, absoluteOffset) {\n    try {\n      const ast = isHostBinding ? this._exprParser.parseSimpleBinding(value, sourceSpan, absoluteOffset) : this._exprParser.parseBinding(value, sourceSpan, absoluteOffset);\n      if (ast) {\n        this.errors.push(...ast.errors);\n      }\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n    }\n  }\n  createBoundElementProperty(elementSelector, boundProp, skipValidation = false, mapPropertyName = true) {\n    if (boundProp.isLegacyAnimation) {\n      return new BoundElementProperty(boundProp.name, BindingType.LegacyAnimation, SecurityContext.NONE, boundProp.expression, null, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n    }\n    let unit = null;\n    let bindingType = undefined;\n    let boundPropertyName = null;\n    const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n    let securityContexts = undefined;\n    if (parts.length > 1) {\n      if (parts[0] == ATTRIBUTE_PREFIX) {\n        boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);\n        if (!skipValidation) {\n          this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n        }\n        securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);\n        const nsSeparatorIdx = boundPropertyName.indexOf(':');\n        if (nsSeparatorIdx > -1) {\n          const ns = boundPropertyName.substring(0, nsSeparatorIdx);\n          const name = boundPropertyName.substring(nsSeparatorIdx + 1);\n          boundPropertyName = mergeNsAndName(ns, name);\n        }\n        bindingType = BindingType.Attribute;\n      } else if (parts[0] == CLASS_PREFIX) {\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Class;\n        securityContexts = [SecurityContext.NONE];\n      } else if (parts[0] == STYLE_PREFIX) {\n        unit = parts.length > 2 ? parts[2] : null;\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Style;\n        securityContexts = [SecurityContext.STYLE];\n      } else if (parts[0] == ANIMATE_PREFIX) {\n        boundPropertyName = boundProp.name;\n        bindingType = BindingType.Animation;\n        securityContexts = [SecurityContext.NONE];\n      }\n    }\n    if (boundPropertyName === null) {\n      const mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);\n      boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;\n      securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, mappedPropName, false);\n      bindingType = boundProp.type === ParsedPropertyType.TWO_WAY ? BindingType.TwoWay : BindingType.Property;\n      if (!skipValidation) {\n        this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);\n      }\n    }\n    return new BoundElementProperty(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n  }\n  parseEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {\n    if (name.length === 0) {\n      this._reportError(`Event name is missing in binding`, sourceSpan);\n    }\n    if (isLegacyAnimationLabel(name)) {\n      name = name.slice(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n      }\n      this._parseLegacyAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents, keySpan);\n    } else {\n      this._parseRegularEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan);\n    }\n  }\n  calcPossibleSecurityContexts(selector, propName, isAttribute) {\n    const prop = this._schemaRegistry.getMappedPropName(propName);\n    return calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);\n  }\n  parseEventListenerName(rawName) {\n    const [target, eventName] = splitAtColon(rawName, [null, rawName]);\n    return {\n      eventName: eventName,\n      target\n    };\n  }\n  parseLegacyAnimationEventName(rawName) {\n    const matches = splitAtPeriod(rawName, [rawName, null]);\n    return {\n      eventName: matches[0],\n      phase: matches[1] === null ? null : matches[1].toLowerCase()\n    };\n  }\n  _parseLegacyAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents, keySpan) {\n    const {\n      eventName,\n      phase\n    } = this.parseLegacyAnimationEventName(name);\n    const ast = this._parseAction(expression, handlerSpan);\n    targetEvents.push(new ParsedEvent(eventName, phase, ParsedEventType.LegacyAnimation, ast, sourceSpan, handlerSpan, keySpan));\n    if (eventName.length === 0) {\n      this._reportError(`Animation event name is missing in binding`, sourceSpan);\n    }\n    if (phase) {\n      if (phase !== 'start' && phase !== 'done') {\n        this._reportError(`The provided animation output phase value \"${phase}\" for \"@${eventName}\" is not supported (use start or done)`, sourceSpan);\n      }\n    } else {\n      this._reportError(`The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`, sourceSpan);\n    }\n  }\n  _parseRegularEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {\n    const {\n      eventName,\n      target\n    } = this.parseEventListenerName(name);\n    const prevErrorCount = this.errors.length;\n    const ast = this._parseAction(expression, handlerSpan);\n    const isValid = this.errors.length === prevErrorCount;\n    targetMatchableAttrs.push([name, ast.source]);\n    if (isAssignmentEvent && isValid && !this._isAllowedAssignmentEvent(ast)) {\n      this._reportError('Unsupported expression in a two-way binding', sourceSpan);\n    }\n    let eventType = ParsedEventType.Regular;\n    if (isAssignmentEvent) {\n      eventType = ParsedEventType.TwoWay;\n    }\n    if (name.startsWith(`${ANIMATE_PREFIX}${PROPERTY_PARTS_SEPARATOR}`)) {\n      eventType = ParsedEventType.Animation;\n    }\n    targetEvents.push(new ParsedEvent(eventName, target, eventType, ast, sourceSpan, handlerSpan, keySpan));\n  }\n  _parseAction(value, sourceSpan) {\n    const absoluteOffset = sourceSpan && sourceSpan.start ? sourceSpan.start.offset : 0;\n    try {\n      const ast = this._exprParser.parseAction(value, sourceSpan, absoluteOffset);\n      if (ast) {\n        this.errors.push(...ast.errors);\n      }\n      if (!ast || ast.ast instanceof EmptyExpr$1) {\n        this._reportError(`Empty expressions are not allowed`, sourceSpan);\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n      }\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n    }\n  }\n  _reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {\n    this.errors.push(new ParseError(sourceSpan, message, level));\n  }\n  _validatePropertyOrAttributeName(propName, sourceSpan, isAttr) {\n    const report = isAttr ? this._schemaRegistry.validateAttribute(propName) : this._schemaRegistry.validateProperty(propName);\n    if (report.error) {\n      this._reportError(report.msg, sourceSpan, ParseErrorLevel.ERROR);\n    }\n  }\n  _isAllowedAssignmentEvent(ast) {\n    if (ast instanceof ASTWithSource) {\n      return this._isAllowedAssignmentEvent(ast.ast);\n    }\n    if (ast instanceof NonNullAssert) {\n      return this._isAllowedAssignmentEvent(ast.expression);\n    }\n    if (ast instanceof Call && ast.args.length === 1 && ast.receiver instanceof PropertyRead && ast.receiver.name === '$any' && ast.receiver.receiver instanceof ImplicitReceiver && !(ast.receiver.receiver instanceof ThisReceiver)) {\n      return this._isAllowedAssignmentEvent(ast.args[0]);\n    }\n    if (ast instanceof PropertyRead || ast instanceof KeyedRead) {\n      if (!hasRecursiveSafeReceiver(ast)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\nfunction hasRecursiveSafeReceiver(ast) {\n  if (ast instanceof SafePropertyRead || ast instanceof SafeKeyedRead) {\n    return true;\n  }\n  if (ast instanceof ParenthesizedExpression) {\n    return hasRecursiveSafeReceiver(ast.expression);\n  }\n  if (ast instanceof PropertyRead || ast instanceof KeyedRead || ast instanceof Call) {\n    return hasRecursiveSafeReceiver(ast.receiver);\n  }\n  return false;\n}\nfunction isLegacyAnimationLabel(name) {\n  return name[0] == '@';\n}\nfunction calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {\n  let ctxs;\n  const nameToContext = elName => registry.securityContext(elName, propName, isAttribute);\n  if (selector === null) {\n    ctxs = registry.allKnownElementNames().map(nameToContext);\n  } else {\n    ctxs = [];\n    CssSelector.parse(selector).forEach(selector => {\n      const elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n      const notElementNames = new Set(selector.notSelectors.filter(selector => selector.isElementSelector()).map(selector => selector.element));\n      const possibleElementNames = elementNames.filter(elName => !notElementNames.has(elName));\n      ctxs.push(...possibleElementNames.map(nameToContext));\n    });\n  }\n  return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n}\nfunction moveParseSourceSpan(sourceSpan, absoluteSpan) {\n  const startDiff = absoluteSpan.start - sourceSpan.start.offset;\n  const endDiff = absoluteSpan.end - sourceSpan.end.offset;\n  return new ParseSourceSpan(sourceSpan.start.moveBy(startDiff), sourceSpan.end.moveBy(endDiff), sourceSpan.fullStart.moveBy(startDiff), sourceSpan.details);\n}\n\nfunction isStyleUrlResolvable(url) {\n  if (url == null || url.length === 0 || url[0] == '/') return false;\n  const schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);\n  return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';\n}\nconst URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;\n\nconst NG_CONTENT_SELECT_ATTR = 'select';\nconst LINK_ELEMENT = 'link';\nconst LINK_STYLE_REL_ATTR = 'rel';\nconst LINK_STYLE_HREF_ATTR = 'href';\nconst LINK_STYLE_REL_VALUE = 'stylesheet';\nconst STYLE_ELEMENT = 'style';\nconst SCRIPT_ELEMENT = 'script';\nconst NG_NON_BINDABLE_ATTR = 'ngNonBindable';\nconst NG_PROJECT_AS = 'ngProjectAs';\nfunction preparseElement(ast) {\n  let selectAttr = null;\n  let hrefAttr = null;\n  let relAttr = null;\n  let nonBindable = false;\n  let projectAs = '';\n  ast.attrs.forEach(attr => {\n    const lcAttrName = attr.name.toLowerCase();\n    if (lcAttrName == NG_CONTENT_SELECT_ATTR) {\n      selectAttr = attr.value;\n    } else if (lcAttrName == LINK_STYLE_HREF_ATTR) {\n      hrefAttr = attr.value;\n    } else if (lcAttrName == LINK_STYLE_REL_ATTR) {\n      relAttr = attr.value;\n    } else if (attr.name == NG_NON_BINDABLE_ATTR) {\n      nonBindable = true;\n    } else if (attr.name == NG_PROJECT_AS) {\n      if (attr.value.length > 0) {\n        projectAs = attr.value;\n      }\n    }\n  });\n  selectAttr = normalizeNgContentSelect(selectAttr);\n  const nodeName = ast.name.toLowerCase();\n  let type = PreparsedElementType.OTHER;\n  if (isNgContent(nodeName)) {\n    type = PreparsedElementType.NG_CONTENT;\n  } else if (nodeName == STYLE_ELEMENT) {\n    type = PreparsedElementType.STYLE;\n  } else if (nodeName == SCRIPT_ELEMENT) {\n    type = PreparsedElementType.SCRIPT;\n  } else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {\n    type = PreparsedElementType.STYLESHEET;\n  }\n  return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);\n}\nvar PreparsedElementType;\n(function (PreparsedElementType) {\n  PreparsedElementType[PreparsedElementType[\"NG_CONTENT\"] = 0] = \"NG_CONTENT\";\n  PreparsedElementType[PreparsedElementType[\"STYLE\"] = 1] = \"STYLE\";\n  PreparsedElementType[PreparsedElementType[\"STYLESHEET\"] = 2] = \"STYLESHEET\";\n  PreparsedElementType[PreparsedElementType[\"SCRIPT\"] = 3] = \"SCRIPT\";\n  PreparsedElementType[PreparsedElementType[\"OTHER\"] = 4] = \"OTHER\";\n})(PreparsedElementType || (PreparsedElementType = {}));\nclass PreparsedElement {\n  type;\n  selectAttr;\n  hrefAttr;\n  nonBindable;\n  projectAs;\n  constructor(type, selectAttr, hrefAttr, nonBindable, projectAs) {\n    this.type = type;\n    this.selectAttr = selectAttr;\n    this.hrefAttr = hrefAttr;\n    this.nonBindable = nonBindable;\n    this.projectAs = projectAs;\n  }\n}\nfunction normalizeNgContentSelect(selectAttr) {\n  if (selectAttr === null || selectAttr.length === 0) {\n    return '*';\n  }\n  return selectAttr;\n}\n\nconst FOR_LOOP_EXPRESSION_PATTERN = /^\\s*([0-9A-Za-z_$]*)\\s+of\\s+([\\S\\s]*)/;\nconst FOR_LOOP_TRACK_PATTERN = /^track\\s+([\\S\\s]*)/;\nconst CONDITIONAL_ALIAS_PATTERN = /^(as\\s+)(.*)/;\nconst ELSE_IF_PATTERN = /^else[^\\S\\r\\n]+if/;\nconst FOR_LOOP_LET_PATTERN = /^let\\s+([\\S\\s]*)/;\nconst IDENTIFIER_PATTERN = /^[$A-Z_][0-9A-Z_$]*$/i;\nconst CHARACTERS_IN_SURROUNDING_WHITESPACE_PATTERN = /(\\s*)(\\S+)(\\s*)/;\nconst ALLOWED_FOR_LOOP_LET_VARIABLES = new Set(['$index', '$first', '$last', '$even', '$odd', '$count']);\nfunction isConnectedForLoopBlock(name) {\n  return name === 'empty';\n}\nfunction isConnectedIfLoopBlock(name) {\n  return name === 'else' || ELSE_IF_PATTERN.test(name);\n}\nfunction createIfBlock(ast, connectedBlocks, visitor, bindingParser) {\n  const errors = validateIfConnectedBlocks(connectedBlocks);\n  const branches = [];\n  const mainBlockParams = parseConditionalBlockParameters(ast, errors, bindingParser);\n  if (mainBlockParams !== null) {\n    branches.push(new IfBlockBranch(mainBlockParams.expression, visitAll(visitor, ast.children, ast.children), mainBlockParams.expressionAlias, ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan, ast.nameSpan, ast.i18n));\n  }\n  for (const block of connectedBlocks) {\n    if (ELSE_IF_PATTERN.test(block.name)) {\n      const params = parseConditionalBlockParameters(block, errors, bindingParser);\n      if (params !== null) {\n        const children = visitAll(visitor, block.children, block.children);\n        branches.push(new IfBlockBranch(params.expression, children, params.expressionAlias, block.sourceSpan, block.startSourceSpan, block.endSourceSpan, block.nameSpan, block.i18n));\n      }\n    } else if (block.name === 'else') {\n      const children = visitAll(visitor, block.children, block.children);\n      branches.push(new IfBlockBranch(null, children, null, block.sourceSpan, block.startSourceSpan, block.endSourceSpan, block.nameSpan, block.i18n));\n    }\n  }\n  const ifBlockStartSourceSpan = branches.length > 0 ? branches[0].startSourceSpan : ast.startSourceSpan;\n  const ifBlockEndSourceSpan = branches.length > 0 ? branches[branches.length - 1].endSourceSpan : ast.endSourceSpan;\n  let wholeSourceSpan = ast.sourceSpan;\n  const lastBranch = branches[branches.length - 1];\n  if (lastBranch !== undefined) {\n    wholeSourceSpan = new ParseSourceSpan(ifBlockStartSourceSpan.start, lastBranch.sourceSpan.end);\n  }\n  return {\n    node: new IfBlock(branches, wholeSourceSpan, ast.startSourceSpan, ifBlockEndSourceSpan, ast.nameSpan),\n    errors\n  };\n}\nfunction createForLoop(ast, connectedBlocks, visitor, bindingParser) {\n  const errors = [];\n  const params = parseForLoopParameters(ast, errors, bindingParser);\n  let node = null;\n  let empty = null;\n  for (const block of connectedBlocks) {\n    if (block.name === 'empty') {\n      if (empty !== null) {\n        errors.push(new ParseError(block.sourceSpan, '@for loop can only have one @empty block'));\n      } else if (block.parameters.length > 0) {\n        errors.push(new ParseError(block.sourceSpan, '@empty block cannot have parameters'));\n      } else {\n        empty = new ForLoopBlockEmpty(visitAll(visitor, block.children, block.children), block.sourceSpan, block.startSourceSpan, block.endSourceSpan, block.nameSpan, block.i18n);\n      }\n    } else {\n      errors.push(new ParseError(block.sourceSpan, `Unrecognized @for loop block \"${block.name}\"`));\n    }\n  }\n  if (params !== null) {\n    if (params.trackBy === null) {\n      errors.push(new ParseError(ast.startSourceSpan, '@for loop must have a \"track\" expression'));\n    } else {\n      const endSpan = empty?.endSourceSpan ?? ast.endSourceSpan;\n      const sourceSpan = new ParseSourceSpan(ast.sourceSpan.start, endSpan?.end ?? ast.sourceSpan.end);\n      validateTrackByExpression(params.trackBy.expression, params.trackBy.keywordSpan, errors);\n      node = new ForLoopBlock(params.itemName, params.expression, params.trackBy.expression, params.trackBy.keywordSpan, params.context, visitAll(visitor, ast.children, ast.children), empty, sourceSpan, ast.sourceSpan, ast.startSourceSpan, endSpan, ast.nameSpan, ast.i18n);\n    }\n  }\n  return {\n    node,\n    errors\n  };\n}\nfunction createSwitchBlock(ast, visitor, bindingParser) {\n  const errors = validateSwitchBlock(ast);\n  const primaryExpression = ast.parameters.length > 0 ? parseBlockParameterToBinding(ast.parameters[0], bindingParser) : bindingParser.parseBinding('', false, ast.sourceSpan, 0);\n  const cases = [];\n  const unknownBlocks = [];\n  let defaultCase = null;\n  for (const node of ast.children) {\n    if (!(node instanceof Block)) {\n      continue;\n    }\n    if ((node.name !== 'case' || node.parameters.length === 0) && node.name !== 'default') {\n      unknownBlocks.push(new UnknownBlock(node.name, node.sourceSpan, node.nameSpan));\n      continue;\n    }\n    const expression = node.name === 'case' ? parseBlockParameterToBinding(node.parameters[0], bindingParser) : null;\n    const ast = new SwitchBlockCase(expression, visitAll(visitor, node.children, node.children), node.sourceSpan, node.startSourceSpan, node.endSourceSpan, node.nameSpan, node.i18n);\n    if (expression === null) {\n      defaultCase = ast;\n    } else {\n      cases.push(ast);\n    }\n  }\n  if (defaultCase !== null) {\n    cases.push(defaultCase);\n  }\n  return {\n    node: new SwitchBlock(primaryExpression, cases, unknownBlocks, ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan, ast.nameSpan),\n    errors\n  };\n}\nfunction parseForLoopParameters(block, errors, bindingParser) {\n  if (block.parameters.length === 0) {\n    errors.push(new ParseError(block.startSourceSpan, '@for loop does not have an expression'));\n    return null;\n  }\n  const [expressionParam, ...secondaryParams] = block.parameters;\n  const match = stripOptionalParentheses(expressionParam, errors)?.match(FOR_LOOP_EXPRESSION_PATTERN);\n  if (!match || match[2].trim().length === 0) {\n    errors.push(new ParseError(expressionParam.sourceSpan, 'Cannot parse expression. @for loop expression must match the pattern \"<identifier> of <expression>\"'));\n    return null;\n  }\n  const [, itemName, rawExpression] = match;\n  if (ALLOWED_FOR_LOOP_LET_VARIABLES.has(itemName)) {\n    errors.push(new ParseError(expressionParam.sourceSpan, `@for loop item name cannot be one of ${Array.from(ALLOWED_FOR_LOOP_LET_VARIABLES).join(', ')}.`));\n  }\n  const variableName = expressionParam.expression.split(' ')[0];\n  const variableSpan = new ParseSourceSpan(expressionParam.sourceSpan.start, expressionParam.sourceSpan.start.moveBy(variableName.length));\n  const result = {\n    itemName: new Variable(itemName, '$implicit', variableSpan, variableSpan),\n    trackBy: null,\n    expression: parseBlockParameterToBinding(expressionParam, bindingParser, rawExpression),\n    context: Array.from(ALLOWED_FOR_LOOP_LET_VARIABLES, variableName => {\n      const emptySpanAfterForBlockStart = new ParseSourceSpan(block.startSourceSpan.end, block.startSourceSpan.end);\n      return new Variable(variableName, variableName, emptySpanAfterForBlockStart, emptySpanAfterForBlockStart);\n    })\n  };\n  for (const param of secondaryParams) {\n    const letMatch = param.expression.match(FOR_LOOP_LET_PATTERN);\n    if (letMatch !== null) {\n      const variablesSpan = new ParseSourceSpan(param.sourceSpan.start.moveBy(letMatch[0].length - letMatch[1].length), param.sourceSpan.end);\n      parseLetParameter(param.sourceSpan, letMatch[1], variablesSpan, itemName, result.context, errors);\n      continue;\n    }\n    const trackMatch = param.expression.match(FOR_LOOP_TRACK_PATTERN);\n    if (trackMatch !== null) {\n      if (result.trackBy !== null) {\n        errors.push(new ParseError(param.sourceSpan, '@for loop can only have one \"track\" expression'));\n      } else {\n        const expression = parseBlockParameterToBinding(param, bindingParser, trackMatch[1]);\n        if (expression.ast instanceof EmptyExpr$1) {\n          errors.push(new ParseError(block.startSourceSpan, '@for loop must have a \"track\" expression'));\n        }\n        const keywordSpan = new ParseSourceSpan(param.sourceSpan.start, param.sourceSpan.start.moveBy('track'.length));\n        result.trackBy = {\n          expression,\n          keywordSpan\n        };\n      }\n      continue;\n    }\n    errors.push(new ParseError(param.sourceSpan, `Unrecognized @for loop parameter \"${param.expression}\"`));\n  }\n  return result;\n}\nfunction validateTrackByExpression(expression, parseSourceSpan, errors) {\n  const visitor = new PipeVisitor();\n  expression.ast.visit(visitor);\n  if (visitor.hasPipe) {\n    errors.push(new ParseError(parseSourceSpan, 'Cannot use pipes in track expressions'));\n  }\n}\nfunction parseLetParameter(sourceSpan, expression, span, loopItemName, context, errors) {\n  const parts = expression.split(',');\n  let startSpan = span.start;\n  for (const part of parts) {\n    const expressionParts = part.split('=');\n    const name = expressionParts.length === 2 ? expressionParts[0].trim() : '';\n    const variableName = expressionParts.length === 2 ? expressionParts[1].trim() : '';\n    if (name.length === 0 || variableName.length === 0) {\n      errors.push(new ParseError(sourceSpan, `Invalid @for loop \"let\" parameter. Parameter should match the pattern \"<name> = <variable name>\"`));\n    } else if (!ALLOWED_FOR_LOOP_LET_VARIABLES.has(variableName)) {\n      errors.push(new ParseError(sourceSpan, `Unknown \"let\" parameter variable \"${variableName}\". The allowed variables are: ${Array.from(ALLOWED_FOR_LOOP_LET_VARIABLES).join(', ')}`));\n    } else if (name === loopItemName) {\n      errors.push(new ParseError(sourceSpan, `Invalid @for loop \"let\" parameter. Variable cannot be called \"${loopItemName}\"`));\n    } else if (context.some(v => v.name === name)) {\n      errors.push(new ParseError(sourceSpan, `Duplicate \"let\" parameter variable \"${variableName}\"`));\n    } else {\n      const [, keyLeadingWhitespace, keyName] = expressionParts[0].match(CHARACTERS_IN_SURROUNDING_WHITESPACE_PATTERN) ?? [];\n      const keySpan = keyLeadingWhitespace !== undefined && expressionParts.length === 2 ? new ParseSourceSpan(startSpan.moveBy(keyLeadingWhitespace.length), startSpan.moveBy(keyLeadingWhitespace.length + keyName.length)) : span;\n      let valueSpan = undefined;\n      if (expressionParts.length === 2) {\n        const [, valueLeadingWhitespace, implicit] = expressionParts[1].match(CHARACTERS_IN_SURROUNDING_WHITESPACE_PATTERN) ?? [];\n        valueSpan = valueLeadingWhitespace !== undefined ? new ParseSourceSpan(startSpan.moveBy(expressionParts[0].length + 1 + valueLeadingWhitespace.length), startSpan.moveBy(expressionParts[0].length + 1 + valueLeadingWhitespace.length + implicit.length)) : undefined;\n      }\n      const sourceSpan = new ParseSourceSpan(keySpan.start, valueSpan?.end ?? keySpan.end);\n      context.push(new Variable(name, variableName, sourceSpan, keySpan, valueSpan));\n    }\n    startSpan = startSpan.moveBy(part.length + 1);\n  }\n}\nfunction validateIfConnectedBlocks(connectedBlocks) {\n  const errors = [];\n  let hasElse = false;\n  for (let i = 0; i < connectedBlocks.length; i++) {\n    const block = connectedBlocks[i];\n    if (block.name === 'else') {\n      if (hasElse) {\n        errors.push(new ParseError(block.startSourceSpan, 'Conditional can only have one @else block'));\n      } else if (connectedBlocks.length > 1 && i < connectedBlocks.length - 1) {\n        errors.push(new ParseError(block.startSourceSpan, '@else block must be last inside the conditional'));\n      } else if (block.parameters.length > 0) {\n        errors.push(new ParseError(block.startSourceSpan, '@else block cannot have parameters'));\n      }\n      hasElse = true;\n    } else if (!ELSE_IF_PATTERN.test(block.name)) {\n      errors.push(new ParseError(block.startSourceSpan, `Unrecognized conditional block @${block.name}`));\n    }\n  }\n  return errors;\n}\nfunction validateSwitchBlock(ast) {\n  const errors = [];\n  let hasDefault = false;\n  if (ast.parameters.length !== 1) {\n    errors.push(new ParseError(ast.startSourceSpan, '@switch block must have exactly one parameter'));\n    return errors;\n  }\n  for (const node of ast.children) {\n    if (node instanceof Comment || node instanceof Text && node.value.trim().length === 0) {\n      continue;\n    }\n    if (!(node instanceof Block) || node.name !== 'case' && node.name !== 'default') {\n      errors.push(new ParseError(node.sourceSpan, '@switch block can only contain @case and @default blocks'));\n      continue;\n    }\n    if (node.name === 'default') {\n      if (hasDefault) {\n        errors.push(new ParseError(node.startSourceSpan, '@switch block can only have one @default block'));\n      } else if (node.parameters.length > 0) {\n        errors.push(new ParseError(node.startSourceSpan, '@default block cannot have parameters'));\n      }\n      hasDefault = true;\n    } else if (node.name === 'case' && node.parameters.length !== 1) {\n      errors.push(new ParseError(node.startSourceSpan, '@case block must have exactly one parameter'));\n    }\n  }\n  return errors;\n}\nfunction parseBlockParameterToBinding(ast, bindingParser, part) {\n  let start;\n  let end;\n  if (typeof part === 'string') {\n    start = Math.max(0, ast.expression.lastIndexOf(part));\n    end = start + part.length;\n  } else {\n    start = 0;\n    end = ast.expression.length;\n  }\n  return bindingParser.parseBinding(ast.expression.slice(start, end), false, ast.sourceSpan, ast.sourceSpan.start.offset + start);\n}\nfunction parseConditionalBlockParameters(block, errors, bindingParser) {\n  if (block.parameters.length === 0) {\n    errors.push(new ParseError(block.startSourceSpan, 'Conditional block does not have an expression'));\n    return null;\n  }\n  const expression = parseBlockParameterToBinding(block.parameters[0], bindingParser);\n  let expressionAlias = null;\n  for (let i = 1; i < block.parameters.length; i++) {\n    const param = block.parameters[i];\n    const aliasMatch = param.expression.match(CONDITIONAL_ALIAS_PATTERN);\n    if (aliasMatch === null) {\n      errors.push(new ParseError(param.sourceSpan, `Unrecognized conditional parameter \"${param.expression}\"`));\n    } else if (block.name !== 'if' && !ELSE_IF_PATTERN.test(block.name)) {\n      errors.push(new ParseError(param.sourceSpan, '\"as\" expression is only allowed on `@if` and `@else if` blocks'));\n    } else if (expressionAlias !== null) {\n      errors.push(new ParseError(param.sourceSpan, 'Conditional can only have one \"as\" expression'));\n    } else {\n      const name = aliasMatch[2].trim();\n      if (IDENTIFIER_PATTERN.test(name)) {\n        const variableStart = param.sourceSpan.start.moveBy(aliasMatch[1].length);\n        const variableSpan = new ParseSourceSpan(variableStart, variableStart.moveBy(name.length));\n        expressionAlias = new Variable(name, name, variableSpan, variableSpan);\n      } else {\n        errors.push(new ParseError(param.sourceSpan, '\"as\" expression must be a valid JavaScript identifier'));\n      }\n    }\n  }\n  return {\n    expression,\n    expressionAlias\n  };\n}\nfunction stripOptionalParentheses(param, errors) {\n  const expression = param.expression;\n  const spaceRegex = /^\\s$/;\n  let openParens = 0;\n  let start = 0;\n  let end = expression.length - 1;\n  for (let i = 0; i < expression.length; i++) {\n    const char = expression[i];\n    if (char === '(') {\n      start = i + 1;\n      openParens++;\n    } else if (spaceRegex.test(char)) {\n      continue;\n    } else {\n      break;\n    }\n  }\n  if (openParens === 0) {\n    return expression;\n  }\n  for (let i = expression.length - 1; i > -1; i--) {\n    const char = expression[i];\n    if (char === ')') {\n      end = i;\n      openParens--;\n      if (openParens === 0) {\n        break;\n      }\n    } else if (spaceRegex.test(char)) {\n      continue;\n    } else {\n      break;\n    }\n  }\n  if (openParens !== 0) {\n    errors.push(new ParseError(param.sourceSpan, 'Unclosed parentheses in expression'));\n    return null;\n  }\n  return expression.slice(start, end);\n}\nclass PipeVisitor extends RecursiveAstVisitor {\n  hasPipe = false;\n  visitPipe() {\n    this.hasPipe = true;\n  }\n}\n\nconst TIME_PATTERN = /^\\d+\\.?\\d*(ms|s)?$/;\nconst SEPARATOR_PATTERN = /^\\s$/;\nconst COMMA_DELIMITED_SYNTAX = new Map([[$LBRACE, $RBRACE], [$LBRACKET, $RBRACKET], [$LPAREN, $RPAREN]]);\nvar OnTriggerType;\n(function (OnTriggerType) {\n  OnTriggerType[\"IDLE\"] = \"idle\";\n  OnTriggerType[\"TIMER\"] = \"timer\";\n  OnTriggerType[\"INTERACTION\"] = \"interaction\";\n  OnTriggerType[\"IMMEDIATE\"] = \"immediate\";\n  OnTriggerType[\"HOVER\"] = \"hover\";\n  OnTriggerType[\"VIEWPORT\"] = \"viewport\";\n  OnTriggerType[\"NEVER\"] = \"never\";\n})(OnTriggerType || (OnTriggerType = {}));\nfunction parseNeverTrigger({\n  expression,\n  sourceSpan\n}, triggers, errors) {\n  const neverIndex = expression.indexOf('never');\n  const neverSourceSpan = new ParseSourceSpan(sourceSpan.start.moveBy(neverIndex), sourceSpan.start.moveBy(neverIndex + 'never'.length));\n  const prefetchSpan = getPrefetchSpan(expression, sourceSpan);\n  const hydrateSpan = getHydrateSpan(expression, sourceSpan);\n  if (neverIndex === -1) {\n    errors.push(new ParseError(sourceSpan, `Could not find \"never\" keyword in expression`));\n  } else {\n    trackTrigger('never', triggers, errors, new NeverDeferredTrigger(neverSourceSpan, sourceSpan, prefetchSpan, null, hydrateSpan));\n  }\n}\nfunction parseWhenTrigger({\n  expression,\n  sourceSpan\n}, bindingParser, triggers, errors) {\n  const whenIndex = expression.indexOf('when');\n  const whenSourceSpan = new ParseSourceSpan(sourceSpan.start.moveBy(whenIndex), sourceSpan.start.moveBy(whenIndex + 'when'.length));\n  const prefetchSpan = getPrefetchSpan(expression, sourceSpan);\n  const hydrateSpan = getHydrateSpan(expression, sourceSpan);\n  if (whenIndex === -1) {\n    errors.push(new ParseError(sourceSpan, `Could not find \"when\" keyword in expression`));\n  } else {\n    const start = getTriggerParametersStart(expression, whenIndex + 1);\n    const parsed = bindingParser.parseBinding(expression.slice(start), false, sourceSpan, sourceSpan.start.offset + start);\n    trackTrigger('when', triggers, errors, new BoundDeferredTrigger(parsed, sourceSpan, prefetchSpan, whenSourceSpan, hydrateSpan));\n  }\n}\nfunction parseOnTrigger({\n  expression,\n  sourceSpan\n}, bindingParser, triggers, errors, placeholder) {\n  const onIndex = expression.indexOf('on');\n  const onSourceSpan = new ParseSourceSpan(sourceSpan.start.moveBy(onIndex), sourceSpan.start.moveBy(onIndex + 'on'.length));\n  const prefetchSpan = getPrefetchSpan(expression, sourceSpan);\n  const hydrateSpan = getHydrateSpan(expression, sourceSpan);\n  if (onIndex === -1) {\n    errors.push(new ParseError(sourceSpan, `Could not find \"on\" keyword in expression`));\n  } else {\n    const start = getTriggerParametersStart(expression, onIndex + 1);\n    const isHydrationTrigger = expression.startsWith('hydrate');\n    const parser = new OnTriggerParser(expression, bindingParser, start, sourceSpan, triggers, errors, isHydrationTrigger ? validateHydrateReferenceBasedTrigger : validatePlainReferenceBasedTrigger, isHydrationTrigger, prefetchSpan, onSourceSpan, hydrateSpan);\n    parser.parse();\n  }\n}\nfunction getPrefetchSpan(expression, sourceSpan) {\n  if (!expression.startsWith('prefetch')) {\n    return null;\n  }\n  return new ParseSourceSpan(sourceSpan.start, sourceSpan.start.moveBy('prefetch'.length));\n}\nfunction getHydrateSpan(expression, sourceSpan) {\n  if (!expression.startsWith('hydrate')) {\n    return null;\n  }\n  return new ParseSourceSpan(sourceSpan.start, sourceSpan.start.moveBy('hydrate'.length));\n}\nclass OnTriggerParser {\n  expression;\n  bindingParser;\n  start;\n  span;\n  triggers;\n  errors;\n  validator;\n  isHydrationTrigger;\n  prefetchSpan;\n  onSourceSpan;\n  hydrateSpan;\n  index = 0;\n  tokens;\n  constructor(expression, bindingParser, start, span, triggers, errors, validator, isHydrationTrigger, prefetchSpan, onSourceSpan, hydrateSpan) {\n    this.expression = expression;\n    this.bindingParser = bindingParser;\n    this.start = start;\n    this.span = span;\n    this.triggers = triggers;\n    this.errors = errors;\n    this.validator = validator;\n    this.isHydrationTrigger = isHydrationTrigger;\n    this.prefetchSpan = prefetchSpan;\n    this.onSourceSpan = onSourceSpan;\n    this.hydrateSpan = hydrateSpan;\n    this.tokens = new Lexer().tokenize(expression.slice(start));\n  }\n  parse() {\n    while (this.tokens.length > 0 && this.index < this.tokens.length) {\n      const token = this.token();\n      if (!token.isIdentifier()) {\n        this.unexpectedToken(token);\n        break;\n      }\n      if (this.isFollowedByOrLast($COMMA)) {\n        this.consumeTrigger(token, []);\n        this.advance();\n      } else if (this.isFollowedByOrLast($LPAREN)) {\n        this.advance();\n        const prevErrors = this.errors.length;\n        const parameters = this.consumeParameters();\n        if (this.errors.length !== prevErrors) {\n          break;\n        }\n        this.consumeTrigger(token, parameters);\n        this.advance();\n      } else if (this.index < this.tokens.length - 1) {\n        this.unexpectedToken(this.tokens[this.index + 1]);\n      }\n      this.advance();\n    }\n  }\n  advance() {\n    this.index++;\n  }\n  isFollowedByOrLast(char) {\n    if (this.index === this.tokens.length - 1) {\n      return true;\n    }\n    return this.tokens[this.index + 1].isCharacter(char);\n  }\n  token() {\n    return this.tokens[Math.min(this.index, this.tokens.length - 1)];\n  }\n  consumeTrigger(identifier, parameters) {\n    const triggerNameStartSpan = this.span.start.moveBy(this.start + identifier.index - this.tokens[0].index);\n    const nameSpan = new ParseSourceSpan(triggerNameStartSpan, triggerNameStartSpan.moveBy(identifier.strValue.length));\n    const endSpan = triggerNameStartSpan.moveBy(this.token().end - identifier.index);\n    const isFirstTrigger = identifier.index === 0;\n    const onSourceSpan = isFirstTrigger ? this.onSourceSpan : null;\n    const prefetchSourceSpan = isFirstTrigger ? this.prefetchSpan : null;\n    const hydrateSourceSpan = isFirstTrigger ? this.hydrateSpan : null;\n    const sourceSpan = new ParseSourceSpan(isFirstTrigger ? this.span.start : triggerNameStartSpan, endSpan);\n    try {\n      switch (identifier.toString()) {\n        case OnTriggerType.IDLE:\n          this.trackTrigger('idle', createIdleTrigger(parameters, nameSpan, sourceSpan, prefetchSourceSpan, onSourceSpan, hydrateSourceSpan));\n          break;\n        case OnTriggerType.TIMER:\n          this.trackTrigger('timer', createTimerTrigger(parameters, nameSpan, sourceSpan, this.prefetchSpan, this.onSourceSpan, this.hydrateSpan));\n          break;\n        case OnTriggerType.INTERACTION:\n          this.trackTrigger('interaction', createInteractionTrigger(parameters, nameSpan, sourceSpan, this.prefetchSpan, this.onSourceSpan, this.hydrateSpan, this.validator));\n          break;\n        case OnTriggerType.IMMEDIATE:\n          this.trackTrigger('immediate', createImmediateTrigger(parameters, nameSpan, sourceSpan, this.prefetchSpan, this.onSourceSpan, this.hydrateSpan));\n          break;\n        case OnTriggerType.HOVER:\n          this.trackTrigger('hover', createHoverTrigger(parameters, nameSpan, sourceSpan, this.prefetchSpan, this.onSourceSpan, this.hydrateSpan, this.validator));\n          break;\n        case OnTriggerType.VIEWPORT:\n          this.trackTrigger('viewport', createViewportTrigger(this.start, this.isHydrationTrigger, this.bindingParser, parameters, nameSpan, sourceSpan, this.prefetchSpan, this.onSourceSpan, this.hydrateSpan, this.validator));\n          break;\n        default:\n          throw new Error(`Unrecognized trigger type \"${identifier}\"`);\n      }\n    } catch (e) {\n      this.error(identifier, e.message);\n    }\n  }\n  consumeParameters() {\n    const parameters = [];\n    if (!this.token().isCharacter($LPAREN)) {\n      this.unexpectedToken(this.token());\n      return parameters;\n    }\n    this.advance();\n    const commaDelimStack = [];\n    let tokens = [];\n    while (this.index < this.tokens.length) {\n      const token = this.token();\n      if (token.isCharacter($RPAREN) && commaDelimStack.length === 0) {\n        if (tokens.length) {\n          parameters.push({\n            expression: this.tokenRangeText(tokens),\n            start: tokens[0].index\n          });\n        }\n        break;\n      }\n      if (token.type === TokenType.Character && COMMA_DELIMITED_SYNTAX.has(token.numValue)) {\n        commaDelimStack.push(COMMA_DELIMITED_SYNTAX.get(token.numValue));\n      }\n      if (commaDelimStack.length > 0 && token.isCharacter(commaDelimStack[commaDelimStack.length - 1])) {\n        commaDelimStack.pop();\n      }\n      if (commaDelimStack.length === 0 && token.isCharacter($COMMA) && tokens.length > 0) {\n        parameters.push({\n          expression: this.tokenRangeText(tokens),\n          start: tokens[0].index\n        });\n        this.advance();\n        tokens = [];\n        continue;\n      }\n      tokens.push(token);\n      this.advance();\n    }\n    if (!this.token().isCharacter($RPAREN) || commaDelimStack.length > 0) {\n      this.error(this.token(), 'Unexpected end of expression');\n    }\n    if (this.index < this.tokens.length - 1 && !this.tokens[this.index + 1].isCharacter($COMMA)) {\n      this.unexpectedToken(this.tokens[this.index + 1]);\n    }\n    return parameters;\n  }\n  tokenRangeText(tokens) {\n    if (tokens.length === 0) {\n      return '';\n    }\n    return this.expression.slice(this.start + tokens[0].index, this.start + tokens[tokens.length - 1].end);\n  }\n  trackTrigger(name, trigger) {\n    trackTrigger(name, this.triggers, this.errors, trigger);\n  }\n  error(token, message) {\n    const newStart = this.span.start.moveBy(this.start + token.index);\n    const newEnd = newStart.moveBy(token.end - token.index);\n    this.errors.push(new ParseError(new ParseSourceSpan(newStart, newEnd), message));\n  }\n  unexpectedToken(token) {\n    this.error(token, `Unexpected token \"${token}\"`);\n  }\n}\nfunction trackTrigger(name, allTriggers, errors, trigger) {\n  if (allTriggers[name]) {\n    errors.push(new ParseError(trigger.sourceSpan, `Duplicate \"${name}\" trigger is not allowed`));\n  } else {\n    allTriggers[name] = trigger;\n  }\n}\nfunction createIdleTrigger(parameters, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan) {\n  if (parameters.length > 0) {\n    throw new Error(`\"${OnTriggerType.IDLE}\" trigger cannot have parameters`);\n  }\n  return new IdleDeferredTrigger(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n}\nfunction createTimerTrigger(parameters, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan) {\n  if (parameters.length !== 1) {\n    throw new Error(`\"${OnTriggerType.TIMER}\" trigger must have exactly one parameter`);\n  }\n  const delay = parseDeferredTime(parameters[0].expression);\n  if (delay === null) {\n    throw new Error(`Could not parse time value of trigger \"${OnTriggerType.TIMER}\"`);\n  }\n  return new TimerDeferredTrigger(delay, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n}\nfunction createImmediateTrigger(parameters, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan) {\n  if (parameters.length > 0) {\n    throw new Error(`\"${OnTriggerType.IMMEDIATE}\" trigger cannot have parameters`);\n  }\n  return new ImmediateDeferredTrigger(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n}\nfunction createHoverTrigger(parameters, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan, validator) {\n  validator(OnTriggerType.HOVER, parameters);\n  return new HoverDeferredTrigger(parameters[0]?.expression ?? null, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n}\nfunction createInteractionTrigger(parameters, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan, validator) {\n  validator(OnTriggerType.INTERACTION, parameters);\n  return new InteractionDeferredTrigger(parameters[0]?.expression ?? null, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n}\nfunction createViewportTrigger(start, isHydrationTrigger, bindingParser, parameters, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan, validator) {\n  validator(OnTriggerType.VIEWPORT, parameters);\n  let reference;\n  let options;\n  if (parameters.length === 0) {\n    reference = options = null;\n  } else if (!parameters[0].expression.startsWith('{')) {\n    reference = parameters[0].expression;\n    options = null;\n  } else {\n    const parsed = bindingParser.parseBinding(parameters[0].expression, false, sourceSpan, sourceSpan.start.offset + start + parameters[0].start);\n    if (!(parsed.ast instanceof LiteralMap)) {\n      throw new Error('Options parameter of the \"viewport\" trigger must be an object literal');\n    } else if (parsed.ast.keys.some(key => key.key === 'root')) {\n      throw new Error('The \"root\" option is not supported in the options parameter of the \"viewport\" trigger');\n    }\n    const triggerIndex = parsed.ast.keys.findIndex(key => key.key === 'trigger');\n    if (triggerIndex === -1) {\n      reference = null;\n      options = parsed.ast;\n    } else {\n      const value = parsed.ast.values[triggerIndex];\n      const triggerFilter = (_, index) => index !== triggerIndex;\n      if (!(value instanceof PropertyRead) || !(value.receiver instanceof ImplicitReceiver) || value.receiver instanceof ThisReceiver) {\n        throw new Error(`\"trigger\" option of the \"viewport\" trigger must be an identifier`);\n      }\n      reference = value.name;\n      options = new LiteralMap(parsed.ast.span, parsed.ast.sourceSpan, parsed.ast.keys.filter(triggerFilter), parsed.ast.values.filter(triggerFilter));\n    }\n  }\n  if (isHydrationTrigger && reference !== null) {\n    throw new Error(`\"viewport\" hydration trigger cannot have a \"trigger\"`);\n  } else if (options) {\n    const dynamicNode = DynamicAstValidator.findDynamicNode(options);\n    if (dynamicNode !== null) {\n      throw new Error(`Options of the \"viewport\" trigger must be an object ` + `literal containing only literal values, but \"${dynamicNode.constructor.name}\" was found`);\n    }\n  }\n  return new ViewportDeferredTrigger(reference, options, nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n}\nfunction validatePlainReferenceBasedTrigger(type, parameters) {\n  if (parameters.length > 1) {\n    throw new Error(`\"${type}\" trigger can only have zero or one parameters`);\n  }\n}\nfunction validateHydrateReferenceBasedTrigger(type, parameters) {\n  if (type === OnTriggerType.VIEWPORT) {\n    if (parameters.length > 1) {\n      throw new Error(`Hydration trigger \"${type}\" cannot have more than one parameter`);\n    }\n    return;\n  }\n  if (parameters.length > 0) {\n    throw new Error(`Hydration trigger \"${type}\" cannot have parameters`);\n  }\n}\nfunction getTriggerParametersStart(value, startPosition = 0) {\n  let hasFoundSeparator = false;\n  for (let i = startPosition; i < value.length; i++) {\n    if (SEPARATOR_PATTERN.test(value[i])) {\n      hasFoundSeparator = true;\n    } else if (hasFoundSeparator) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction parseDeferredTime(value) {\n  const match = value.match(TIME_PATTERN);\n  if (!match) {\n    return null;\n  }\n  const [time, units] = match;\n  return parseFloat(time) * (units === 's' ? 1000 : 1);\n}\nclass DynamicAstValidator extends RecursiveAstVisitor {\n  dynamicNode = null;\n  static findDynamicNode(ast) {\n    const visitor = new DynamicAstValidator();\n    visitor.visit(ast);\n    return visitor.dynamicNode;\n  }\n  visit(ast) {\n    if (!(ast instanceof ASTWithSource) && !(ast instanceof LiteralPrimitive) && !(ast instanceof LiteralArray) && !(ast instanceof LiteralMap)) {\n      this.dynamicNode = ast;\n    } else {\n      super.visit(ast);\n    }\n  }\n}\n\nconst PREFETCH_WHEN_PATTERN = /^prefetch\\s+when\\s/;\nconst PREFETCH_ON_PATTERN = /^prefetch\\s+on\\s/;\nconst HYDRATE_WHEN_PATTERN = /^hydrate\\s+when\\s/;\nconst HYDRATE_ON_PATTERN = /^hydrate\\s+on\\s/;\nconst HYDRATE_NEVER_PATTERN = /^hydrate\\s+never(\\s*)$/;\nconst MINIMUM_PARAMETER_PATTERN = /^minimum\\s/;\nconst AFTER_PARAMETER_PATTERN = /^after\\s/;\nconst WHEN_PARAMETER_PATTERN = /^when\\s/;\nconst ON_PARAMETER_PATTERN = /^on\\s/;\nfunction isConnectedDeferLoopBlock(name) {\n  return name === 'placeholder' || name === 'loading' || name === 'error';\n}\nfunction createDeferredBlock(ast, connectedBlocks, visitor, bindingParser) {\n  const errors = [];\n  const {\n    placeholder,\n    loading,\n    error\n  } = parseConnectedBlocks(connectedBlocks, errors, visitor);\n  const {\n    triggers,\n    prefetchTriggers,\n    hydrateTriggers\n  } = parsePrimaryTriggers(ast, bindingParser, errors);\n  let lastEndSourceSpan = ast.endSourceSpan;\n  let endOfLastSourceSpan = ast.sourceSpan.end;\n  if (connectedBlocks.length > 0) {\n    const lastConnectedBlock = connectedBlocks[connectedBlocks.length - 1];\n    lastEndSourceSpan = lastConnectedBlock.endSourceSpan;\n    endOfLastSourceSpan = lastConnectedBlock.sourceSpan.end;\n  }\n  const sourceSpanWithConnectedBlocks = new ParseSourceSpan(ast.sourceSpan.start, endOfLastSourceSpan);\n  const node = new DeferredBlock(visitAll(visitor, ast.children, ast.children), triggers, prefetchTriggers, hydrateTriggers, placeholder, loading, error, ast.nameSpan, sourceSpanWithConnectedBlocks, ast.sourceSpan, ast.startSourceSpan, lastEndSourceSpan, ast.i18n);\n  return {\n    node,\n    errors\n  };\n}\nfunction parseConnectedBlocks(connectedBlocks, errors, visitor) {\n  let placeholder = null;\n  let loading = null;\n  let error = null;\n  for (const block of connectedBlocks) {\n    try {\n      if (!isConnectedDeferLoopBlock(block.name)) {\n        errors.push(new ParseError(block.startSourceSpan, `Unrecognized block \"@${block.name}\"`));\n        break;\n      }\n      switch (block.name) {\n        case 'placeholder':\n          if (placeholder !== null) {\n            errors.push(new ParseError(block.startSourceSpan, `@defer block can only have one @placeholder block`));\n          } else {\n            placeholder = parsePlaceholderBlock(block, visitor);\n          }\n          break;\n        case 'loading':\n          if (loading !== null) {\n            errors.push(new ParseError(block.startSourceSpan, `@defer block can only have one @loading block`));\n          } else {\n            loading = parseLoadingBlock(block, visitor);\n          }\n          break;\n        case 'error':\n          if (error !== null) {\n            errors.push(new ParseError(block.startSourceSpan, `@defer block can only have one @error block`));\n          } else {\n            error = parseErrorBlock(block, visitor);\n          }\n          break;\n      }\n    } catch (e) {\n      errors.push(new ParseError(block.startSourceSpan, e.message));\n    }\n  }\n  return {\n    placeholder,\n    loading,\n    error\n  };\n}\nfunction parsePlaceholderBlock(ast, visitor) {\n  let minimumTime = null;\n  for (const param of ast.parameters) {\n    if (MINIMUM_PARAMETER_PATTERN.test(param.expression)) {\n      if (minimumTime != null) {\n        throw new Error(`@placeholder block can only have one \"minimum\" parameter`);\n      }\n      const parsedTime = parseDeferredTime(param.expression.slice(getTriggerParametersStart(param.expression)));\n      if (parsedTime === null) {\n        throw new Error(`Could not parse time value of parameter \"minimum\"`);\n      }\n      minimumTime = parsedTime;\n    } else {\n      throw new Error(`Unrecognized parameter in @placeholder block: \"${param.expression}\"`);\n    }\n  }\n  return new DeferredBlockPlaceholder(visitAll(visitor, ast.children, ast.children), minimumTime, ast.nameSpan, ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan, ast.i18n);\n}\nfunction parseLoadingBlock(ast, visitor) {\n  let afterTime = null;\n  let minimumTime = null;\n  for (const param of ast.parameters) {\n    if (AFTER_PARAMETER_PATTERN.test(param.expression)) {\n      if (afterTime != null) {\n        throw new Error(`@loading block can only have one \"after\" parameter`);\n      }\n      const parsedTime = parseDeferredTime(param.expression.slice(getTriggerParametersStart(param.expression)));\n      if (parsedTime === null) {\n        throw new Error(`Could not parse time value of parameter \"after\"`);\n      }\n      afterTime = parsedTime;\n    } else if (MINIMUM_PARAMETER_PATTERN.test(param.expression)) {\n      if (minimumTime != null) {\n        throw new Error(`@loading block can only have one \"minimum\" parameter`);\n      }\n      const parsedTime = parseDeferredTime(param.expression.slice(getTriggerParametersStart(param.expression)));\n      if (parsedTime === null) {\n        throw new Error(`Could not parse time value of parameter \"minimum\"`);\n      }\n      minimumTime = parsedTime;\n    } else {\n      throw new Error(`Unrecognized parameter in @loading block: \"${param.expression}\"`);\n    }\n  }\n  return new DeferredBlockLoading(visitAll(visitor, ast.children, ast.children), afterTime, minimumTime, ast.nameSpan, ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan, ast.i18n);\n}\nfunction parseErrorBlock(ast, visitor) {\n  if (ast.parameters.length > 0) {\n    throw new Error(`@error block cannot have parameters`);\n  }\n  return new DeferredBlockError(visitAll(visitor, ast.children, ast.children), ast.nameSpan, ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan, ast.i18n);\n}\nfunction parsePrimaryTriggers(ast, bindingParser, errors, placeholder) {\n  const triggers = {};\n  const prefetchTriggers = {};\n  const hydrateTriggers = {};\n  for (const param of ast.parameters) {\n    if (WHEN_PARAMETER_PATTERN.test(param.expression)) {\n      parseWhenTrigger(param, bindingParser, triggers, errors);\n    } else if (ON_PARAMETER_PATTERN.test(param.expression)) {\n      parseOnTrigger(param, bindingParser, triggers, errors);\n    } else if (PREFETCH_WHEN_PATTERN.test(param.expression)) {\n      parseWhenTrigger(param, bindingParser, prefetchTriggers, errors);\n    } else if (PREFETCH_ON_PATTERN.test(param.expression)) {\n      parseOnTrigger(param, bindingParser, prefetchTriggers, errors);\n    } else if (HYDRATE_WHEN_PATTERN.test(param.expression)) {\n      parseWhenTrigger(param, bindingParser, hydrateTriggers, errors);\n    } else if (HYDRATE_ON_PATTERN.test(param.expression)) {\n      parseOnTrigger(param, bindingParser, hydrateTriggers, errors);\n    } else if (HYDRATE_NEVER_PATTERN.test(param.expression)) {\n      parseNeverTrigger(param, hydrateTriggers, errors);\n    } else {\n      errors.push(new ParseError(param.sourceSpan, 'Unrecognized trigger'));\n    }\n  }\n  if (hydrateTriggers.never && Object.keys(hydrateTriggers).length > 1) {\n    errors.push(new ParseError(ast.startSourceSpan, 'Cannot specify additional `hydrate` triggers if `hydrate never` is present'));\n  }\n  return {\n    triggers,\n    prefetchTriggers,\n    hydrateTriggers\n  };\n}\n\nconst BIND_NAME_REGEXP = /^(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*)$/;\nconst KW_BIND_IDX = 1;\nconst KW_LET_IDX = 2;\nconst KW_REF_IDX = 3;\nconst KW_ON_IDX = 4;\nconst KW_BINDON_IDX = 5;\nconst KW_AT_IDX = 6;\nconst IDENT_KW_IDX = 7;\nconst BINDING_DELIMS = {\n  BANANA_BOX: {\n    start: '[(',\n    end: ')]'\n  },\n  PROPERTY: {\n    start: '[',\n    end: ']'\n  },\n  EVENT: {\n    start: '(',\n    end: ')'\n  }\n};\nconst TEMPLATE_ATTR_PREFIX = '*';\nconst UNSUPPORTED_SELECTORLESS_TAGS = new Set(['link', 'style', 'script', 'ng-template', 'ng-container', 'ng-content']);\nconst UNSUPPORTED_SELECTORLESS_DIRECTIVE_ATTRS = new Set(['ngProjectAs', 'ngNonBindable']);\nfunction htmlAstToRender3Ast(htmlNodes, bindingParser, options) {\n  const transformer = new HtmlAstToIvyAst(bindingParser, options);\n  const ivyNodes = visitAll(transformer, htmlNodes, htmlNodes);\n  const allErrors = bindingParser.errors.concat(transformer.errors);\n  const result = {\n    nodes: ivyNodes,\n    errors: allErrors,\n    styleUrls: transformer.styleUrls,\n    styles: transformer.styles,\n    ngContentSelectors: transformer.ngContentSelectors\n  };\n  if (options.collectCommentNodes) {\n    result.commentNodes = transformer.commentNodes;\n  }\n  return result;\n}\nclass HtmlAstToIvyAst {\n  bindingParser;\n  options;\n  errors = [];\n  styles = [];\n  styleUrls = [];\n  ngContentSelectors = [];\n  commentNodes = [];\n  inI18nBlock = false;\n  processedNodes = new Set();\n  constructor(bindingParser, options) {\n    this.bindingParser = bindingParser;\n    this.options = options;\n  }\n  visitElement(element) {\n    const isI18nRootElement = isI18nRootNode(element.i18n);\n    if (isI18nRootElement) {\n      if (this.inI18nBlock) {\n        this.reportError('Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.', element.sourceSpan);\n      }\n      this.inI18nBlock = true;\n    }\n    const preparsedElement = preparseElement(element);\n    if (preparsedElement.type === PreparsedElementType.SCRIPT) {\n      return null;\n    } else if (preparsedElement.type === PreparsedElementType.STYLE) {\n      const contents = textContents(element);\n      if (contents !== null) {\n        this.styles.push(contents);\n      }\n      return null;\n    } else if (preparsedElement.type === PreparsedElementType.STYLESHEET && isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n      this.styleUrls.push(preparsedElement.hrefAttr);\n      return null;\n    }\n    const isTemplateElement = isNgTemplate(element.name);\n    const {\n      attributes,\n      boundEvents,\n      references,\n      variables,\n      templateVariables,\n      elementHasInlineTemplate,\n      parsedProperties,\n      templateParsedProperties,\n      i18nAttrsMeta\n    } = this.prepareAttributes(element.attrs, isTemplateElement);\n    const directives = this.extractDirectives(element);\n    let children;\n    if (preparsedElement.nonBindable) {\n      children = visitAll(NON_BINDABLE_VISITOR, element.children).flat(Infinity);\n    } else {\n      children = visitAll(this, element.children, element.children);\n    }\n    let parsedElement;\n    if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n      const selector = preparsedElement.selectAttr;\n      const attrs = element.attrs.map(attr => this.visitAttribute(attr));\n      parsedElement = new Content(selector, attrs, children, element.isSelfClosing, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n      this.ngContentSelectors.push(selector);\n    } else if (isTemplateElement) {\n      const attrs = this.categorizePropertyAttributes(element.name, parsedProperties, i18nAttrsMeta);\n      parsedElement = new Template(element.name, attributes, attrs.bound, boundEvents, directives, [], children, references, variables, element.isSelfClosing, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n    } else {\n      const attrs = this.categorizePropertyAttributes(element.name, parsedProperties, i18nAttrsMeta);\n      if (element.name === 'ng-container') {\n        for (const bound of attrs.bound) {\n          if (bound.type === BindingType.Attribute) {\n            this.reportError(`Attribute bindings are not supported on ng-container. Use property bindings instead.`, bound.sourceSpan);\n          }\n        }\n      }\n      parsedElement = new Element$1(element.name, attributes, attrs.bound, boundEvents, directives, children, references, element.isSelfClosing, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.isVoid, element.i18n);\n    }\n    if (elementHasInlineTemplate) {\n      parsedElement = this.wrapInTemplate(parsedElement, templateParsedProperties, templateVariables, i18nAttrsMeta, isTemplateElement, isI18nRootElement);\n    }\n    if (isI18nRootElement) {\n      this.inI18nBlock = false;\n    }\n    return parsedElement;\n  }\n  visitAttribute(attribute) {\n    return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);\n  }\n  visitText(text) {\n    return this.processedNodes.has(text) ? null : this._visitTextWithInterpolation(text.value, text.sourceSpan, text.tokens, text.i18n);\n  }\n  visitExpansion(expansion) {\n    if (!expansion.i18n) {\n      return null;\n    }\n    if (!isI18nRootNode(expansion.i18n)) {\n      throw new Error(`Invalid type \"${expansion.i18n.constructor}\" for \"i18n\" property of ${expansion.sourceSpan.toString()}. Expected a \"Message\"`);\n    }\n    const message = expansion.i18n;\n    const vars = {};\n    const placeholders = {};\n    Object.keys(message.placeholders).forEach(key => {\n      const value = message.placeholders[key];\n      if (key.startsWith(I18N_ICU_VAR_PREFIX)) {\n        const formattedKey = key.trim();\n        const ast = this.bindingParser.parseInterpolationExpression(value.text, value.sourceSpan);\n        vars[formattedKey] = new BoundText(ast, value.sourceSpan);\n      } else {\n        placeholders[key] = this._visitTextWithInterpolation(value.text, value.sourceSpan, null);\n      }\n    });\n    return new Icu$1(vars, placeholders, expansion.sourceSpan, message);\n  }\n  visitExpansionCase(expansionCase) {\n    return null;\n  }\n  visitComment(comment) {\n    if (this.options.collectCommentNodes) {\n      this.commentNodes.push(new Comment$1(comment.value || '', comment.sourceSpan));\n    }\n    return null;\n  }\n  visitLetDeclaration(decl, context) {\n    const value = this.bindingParser.parseBinding(decl.value, false, decl.valueSpan, decl.valueSpan.start.offset);\n    if (value.errors.length === 0 && value.ast instanceof EmptyExpr$1) {\n      this.reportError('@let declaration value cannot be empty', decl.valueSpan);\n    }\n    return new LetDeclaration$1(decl.name, value, decl.sourceSpan, decl.nameSpan, decl.valueSpan);\n  }\n  visitComponent(component) {\n    const isI18nRootElement = isI18nRootNode(component.i18n);\n    if (isI18nRootElement) {\n      if (this.inI18nBlock) {\n        this.reportError('Cannot mark a component as translatable inside of a translatable section. Please remove the nested i18n marker.', component.sourceSpan);\n      }\n      this.inI18nBlock = true;\n    }\n    if (component.tagName !== null && UNSUPPORTED_SELECTORLESS_TAGS.has(component.tagName)) {\n      this.reportError(`Tag name \"${component.tagName}\" cannot be used as a component tag`, component.startSourceSpan);\n      return null;\n    }\n    const {\n      attributes,\n      boundEvents,\n      references,\n      templateVariables,\n      elementHasInlineTemplate,\n      parsedProperties,\n      templateParsedProperties,\n      i18nAttrsMeta\n    } = this.prepareAttributes(component.attrs, false);\n    this.validateSelectorlessReferences(references);\n    const directives = this.extractDirectives(component);\n    let children;\n    if (component.attrs.find(attr => attr.name === 'ngNonBindable')) {\n      children = visitAll(NON_BINDABLE_VISITOR, component.children).flat(Infinity);\n    } else {\n      children = visitAll(this, component.children, component.children);\n    }\n    const attrs = this.categorizePropertyAttributes(component.tagName, parsedProperties, i18nAttrsMeta);\n    let node = new Component$1(component.componentName, component.tagName, component.fullName, attributes, attrs.bound, boundEvents, directives, children, references, component.isSelfClosing, component.sourceSpan, component.startSourceSpan, component.endSourceSpan, component.i18n);\n    if (elementHasInlineTemplate) {\n      node = this.wrapInTemplate(node, templateParsedProperties, templateVariables, i18nAttrsMeta, false, isI18nRootElement);\n    }\n    if (isI18nRootElement) {\n      this.inI18nBlock = false;\n    }\n    return node;\n  }\n  visitDirective() {\n    return null;\n  }\n  visitBlockParameter() {\n    return null;\n  }\n  visitBlock(block, context) {\n    const index = Array.isArray(context) ? context.indexOf(block) : -1;\n    if (index === -1) {\n      throw new Error('Visitor invoked incorrectly. Expecting visitBlock to be invoked siblings array as its context');\n    }\n    if (this.processedNodes.has(block)) {\n      return null;\n    }\n    let result = null;\n    switch (block.name) {\n      case 'defer':\n        result = createDeferredBlock(block, this.findConnectedBlocks(index, context, isConnectedDeferLoopBlock), this, this.bindingParser);\n        break;\n      case 'switch':\n        result = createSwitchBlock(block, this, this.bindingParser);\n        break;\n      case 'for':\n        result = createForLoop(block, this.findConnectedBlocks(index, context, isConnectedForLoopBlock), this, this.bindingParser);\n        break;\n      case 'if':\n        result = createIfBlock(block, this.findConnectedBlocks(index, context, isConnectedIfLoopBlock), this, this.bindingParser);\n        break;\n      default:\n        let errorMessage;\n        if (isConnectedDeferLoopBlock(block.name)) {\n          errorMessage = `@${block.name} block can only be used after an @defer block.`;\n          this.processedNodes.add(block);\n        } else if (isConnectedForLoopBlock(block.name)) {\n          errorMessage = `@${block.name} block can only be used after an @for block.`;\n          this.processedNodes.add(block);\n        } else if (isConnectedIfLoopBlock(block.name)) {\n          errorMessage = `@${block.name} block can only be used after an @if or @else if block.`;\n          this.processedNodes.add(block);\n        } else {\n          errorMessage = `Unrecognized block @${block.name}.`;\n        }\n        result = {\n          node: new UnknownBlock(block.name, block.sourceSpan, block.nameSpan),\n          errors: [new ParseError(block.sourceSpan, errorMessage)]\n        };\n        break;\n    }\n    this.errors.push(...result.errors);\n    return result.node;\n  }\n  findConnectedBlocks(primaryBlockIndex, siblings, predicate) {\n    const relatedBlocks = [];\n    for (let i = primaryBlockIndex + 1; i < siblings.length; i++) {\n      const node = siblings[i];\n      if (node instanceof Comment) {\n        continue;\n      }\n      if (node instanceof Text && node.value.trim().length === 0) {\n        this.processedNodes.add(node);\n        continue;\n      }\n      if (!(node instanceof Block) || !predicate(node.name)) {\n        break;\n      }\n      relatedBlocks.push(node);\n      this.processedNodes.add(node);\n    }\n    return relatedBlocks;\n  }\n  categorizePropertyAttributes(elementName, properties, i18nPropsMeta) {\n    const bound = [];\n    const literal = [];\n    properties.forEach(prop => {\n      const i18n = i18nPropsMeta[prop.name];\n      if (prop.isLiteral) {\n        literal.push(new TextAttribute(prop.name, prop.expression.source || '', prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n));\n      } else {\n        const bep = this.bindingParser.createBoundElementProperty(elementName, prop, true, false);\n        bound.push(BoundAttribute.fromBoundElementProperty(bep, i18n));\n      }\n    });\n    return {\n      bound,\n      literal\n    };\n  }\n  prepareAttributes(attrs, isTemplateElement) {\n    const parsedProperties = [];\n    const boundEvents = [];\n    const variables = [];\n    const references = [];\n    const attributes = [];\n    const i18nAttrsMeta = {};\n    const templateParsedProperties = [];\n    const templateVariables = [];\n    let elementHasInlineTemplate = false;\n    for (const attribute of attrs) {\n      let hasBinding = false;\n      const normalizedName = normalizeAttributeName(attribute.name);\n      let isTemplateBinding = false;\n      if (attribute.i18n) {\n        i18nAttrsMeta[attribute.name] = attribute.i18n;\n      }\n      if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {\n        if (elementHasInlineTemplate) {\n          this.reportError(`Can't have multiple template bindings on one element. Use only one attribute prefixed with *`, attribute.sourceSpan);\n        }\n        isTemplateBinding = true;\n        elementHasInlineTemplate = true;\n        const templateValue = attribute.value;\n        const templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);\n        const parsedVariables = [];\n        const absoluteValueOffset = attribute.valueSpan ? attribute.valueSpan.fullStart.offset : attribute.sourceSpan.fullStart.offset + attribute.name.length;\n        this.bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attribute.sourceSpan, absoluteValueOffset, [], templateParsedProperties, parsedVariables, true);\n        templateVariables.push(...parsedVariables.map(v => new Variable(v.name, v.value, v.sourceSpan, v.keySpan, v.valueSpan)));\n      } else {\n        hasBinding = this.parseAttribute(isTemplateElement, attribute, [], parsedProperties, boundEvents, variables, references);\n      }\n      if (!hasBinding && !isTemplateBinding) {\n        attributes.push(this.visitAttribute(attribute));\n      }\n    }\n    return {\n      attributes,\n      boundEvents,\n      references,\n      variables,\n      templateVariables,\n      elementHasInlineTemplate,\n      parsedProperties,\n      templateParsedProperties,\n      i18nAttrsMeta\n    };\n  }\n  parseAttribute(isTemplateElement, attribute, matchableAttributes, parsedProperties, boundEvents, variables, references) {\n    const name = normalizeAttributeName(attribute.name);\n    const value = attribute.value;\n    const srcSpan = attribute.sourceSpan;\n    const absoluteOffset = attribute.valueSpan ? attribute.valueSpan.fullStart.offset : srcSpan.fullStart.offset;\n    function createKeySpan(srcSpan, prefix, identifier) {\n      const normalizationAdjustment = attribute.name.length - name.length;\n      const keySpanStart = srcSpan.start.moveBy(prefix.length + normalizationAdjustment);\n      const keySpanEnd = keySpanStart.moveBy(identifier.length);\n      return new ParseSourceSpan(keySpanStart, keySpanEnd, keySpanStart, identifier);\n    }\n    const bindParts = name.match(BIND_NAME_REGEXP);\n    if (bindParts) {\n      if (bindParts[KW_BIND_IDX] != null) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_BIND_IDX], identifier);\n        this.bindingParser.parsePropertyBinding(identifier, value, false, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n      } else if (bindParts[KW_LET_IDX]) {\n        if (isTemplateElement) {\n          const identifier = bindParts[IDENT_KW_IDX];\n          const keySpan = createKeySpan(srcSpan, bindParts[KW_LET_IDX], identifier);\n          this.parseVariable(identifier, value, srcSpan, keySpan, attribute.valueSpan, variables);\n        } else {\n          this.reportError(`\"let-\" is only supported on ng-template elements.`, srcSpan);\n        }\n      } else if (bindParts[KW_REF_IDX]) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_REF_IDX], identifier);\n        this.parseReference(identifier, value, srcSpan, keySpan, attribute.valueSpan, references);\n      } else if (bindParts[KW_ON_IDX]) {\n        const events = [];\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_ON_IDX], identifier);\n        this.bindingParser.parseEvent(identifier, value, false, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan);\n        addEvents(events, boundEvents);\n      } else if (bindParts[KW_BINDON_IDX]) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_BINDON_IDX], identifier);\n        this.bindingParser.parsePropertyBinding(identifier, value, false, true, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n        this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan, absoluteOffset);\n      } else if (bindParts[KW_AT_IDX]) {\n        const keySpan = createKeySpan(srcSpan, '', name);\n        this.bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n      }\n      return true;\n    }\n    let delims = null;\n    if (name.startsWith(BINDING_DELIMS.BANANA_BOX.start)) {\n      delims = BINDING_DELIMS.BANANA_BOX;\n    } else if (name.startsWith(BINDING_DELIMS.PROPERTY.start)) {\n      delims = BINDING_DELIMS.PROPERTY;\n    } else if (name.startsWith(BINDING_DELIMS.EVENT.start)) {\n      delims = BINDING_DELIMS.EVENT;\n    }\n    if (delims !== null && name.endsWith(delims.end) && name.length > delims.start.length + delims.end.length) {\n      const identifier = name.substring(delims.start.length, name.length - delims.end.length);\n      const keySpan = createKeySpan(srcSpan, delims.start, identifier);\n      if (delims.start === BINDING_DELIMS.BANANA_BOX.start) {\n        this.bindingParser.parsePropertyBinding(identifier, value, false, true, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n        this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan, absoluteOffset);\n      } else if (delims.start === BINDING_DELIMS.PROPERTY.start) {\n        this.bindingParser.parsePropertyBinding(identifier, value, false, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n      } else {\n        const events = [];\n        this.bindingParser.parseEvent(identifier, value, false, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan);\n        addEvents(events, boundEvents);\n      }\n      return true;\n    }\n    const keySpan = createKeySpan(srcSpan, '', name);\n    const hasBinding = this.bindingParser.parsePropertyInterpolation(name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan, attribute.valueTokens ?? null);\n    return hasBinding;\n  }\n  extractDirectives(node) {\n    const elementName = node instanceof Component ? node.tagName : node.name;\n    const directives = [];\n    const seenDirectives = new Set();\n    for (const directive of node.directives) {\n      let invalid = false;\n      for (const attr of directive.attrs) {\n        if (attr.name.startsWith(TEMPLATE_ATTR_PREFIX)) {\n          invalid = true;\n          this.reportError(`Shorthand template syntax \"${attr.name}\" is not supported inside a directive context`, attr.sourceSpan);\n        } else if (UNSUPPORTED_SELECTORLESS_DIRECTIVE_ATTRS.has(attr.name)) {\n          invalid = true;\n          this.reportError(`Attribute \"${attr.name}\" is not supported in a directive context`, attr.sourceSpan);\n        }\n      }\n      if (!invalid && seenDirectives.has(directive.name)) {\n        invalid = true;\n        this.reportError(`Cannot apply directive \"${directive.name}\" multiple times on the same element`, directive.sourceSpan);\n      }\n      if (invalid) {\n        continue;\n      }\n      const {\n        attributes,\n        parsedProperties,\n        boundEvents,\n        references,\n        i18nAttrsMeta\n      } = this.prepareAttributes(directive.attrs, false);\n      this.validateSelectorlessReferences(references);\n      const {\n        bound: inputs\n      } = this.categorizePropertyAttributes(elementName, parsedProperties, i18nAttrsMeta);\n      for (const input of inputs) {\n        if (input.type !== BindingType.Property && input.type !== BindingType.TwoWay) {\n          invalid = true;\n          this.reportError('Binding is not supported in a directive context', input.sourceSpan);\n        }\n      }\n      if (invalid) {\n        continue;\n      }\n      seenDirectives.add(directive.name);\n      directives.push(new Directive$1(directive.name, attributes, inputs, boundEvents, references, directive.sourceSpan, directive.startSourceSpan, directive.endSourceSpan, undefined));\n    }\n    return directives;\n  }\n  filterAnimationAttributes(attributes) {\n    return attributes.filter(a => !a.name.startsWith('animate.'));\n  }\n  filterAnimationInputs(attributes) {\n    return attributes.filter(a => a.type !== BindingType.Animation);\n  }\n  wrapInTemplate(node, templateProperties, templateVariables, i18nAttrsMeta, isTemplateElement, isI18nRootElement) {\n    const attrs = this.categorizePropertyAttributes('ng-template', templateProperties, i18nAttrsMeta);\n    const templateAttrs = [];\n    attrs.literal.forEach(attr => templateAttrs.push(attr));\n    attrs.bound.forEach(attr => templateAttrs.push(attr));\n    const hoistedAttrs = {\n      attributes: [],\n      inputs: [],\n      outputs: []\n    };\n    if (node instanceof Element$1 || node instanceof Component$1) {\n      hoistedAttrs.attributes.push(...this.filterAnimationAttributes(node.attributes));\n      hoistedAttrs.inputs.push(...this.filterAnimationInputs(node.inputs));\n      hoistedAttrs.outputs.push(...node.outputs);\n    }\n    const i18n = isTemplateElement && isI18nRootElement ? undefined : node.i18n;\n    let name;\n    if (node instanceof Component$1) {\n      name = node.tagName;\n    } else if (node instanceof Template) {\n      name = null;\n    } else {\n      name = node.name;\n    }\n    return new Template(name, hoistedAttrs.attributes, hoistedAttrs.inputs, hoistedAttrs.outputs, [], templateAttrs, [node], [], templateVariables, false, node.sourceSpan, node.startSourceSpan, node.endSourceSpan, i18n);\n  }\n  _visitTextWithInterpolation(value, sourceSpan, interpolatedTokens, i18n) {\n    const valueNoNgsp = replaceNgsp(value);\n    const expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan, interpolatedTokens);\n    return expr ? new BoundText(expr, sourceSpan, i18n) : new Text$3(valueNoNgsp, sourceSpan);\n  }\n  parseVariable(identifier, value, sourceSpan, keySpan, valueSpan, variables) {\n    if (identifier.indexOf('-') > -1) {\n      this.reportError(`\"-\" is not allowed in variable names`, sourceSpan);\n    } else if (identifier.length === 0) {\n      this.reportError(`Variable does not have a name`, sourceSpan);\n    }\n    variables.push(new Variable(identifier, value, sourceSpan, keySpan, valueSpan));\n  }\n  parseReference(identifier, value, sourceSpan, keySpan, valueSpan, references) {\n    if (identifier.indexOf('-') > -1) {\n      this.reportError(`\"-\" is not allowed in reference names`, sourceSpan);\n    } else if (identifier.length === 0) {\n      this.reportError(`Reference does not have a name`, sourceSpan);\n    } else if (references.some(reference => reference.name === identifier)) {\n      this.reportError(`Reference \"#${identifier}\" is defined more than once`, sourceSpan);\n    }\n    references.push(new Reference(identifier, value, sourceSpan, keySpan, valueSpan));\n  }\n  parseAssignmentEvent(name, expression, sourceSpan, valueSpan, targetMatchableAttrs, boundEvents, keySpan, absoluteOffset) {\n    const events = [];\n    this.bindingParser.parseEvent(`${name}Change`, expression, true, sourceSpan, valueSpan || sourceSpan, targetMatchableAttrs, events, keySpan);\n    addEvents(events, boundEvents);\n  }\n  validateSelectorlessReferences(references) {\n    if (references.length === 0) {\n      return;\n    }\n    const seenNames = new Set();\n    for (const ref of references) {\n      if (ref.value.length > 0) {\n        this.reportError('Cannot specify a value for a local reference in this context', ref.valueSpan || ref.sourceSpan);\n      } else if (seenNames.has(ref.name)) {\n        this.reportError('Duplicate reference names are not allowed', ref.sourceSpan);\n      } else {\n        seenNames.add(ref.name);\n      }\n    }\n  }\n  reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {\n    this.errors.push(new ParseError(sourceSpan, message, level));\n  }\n}\nclass NonBindableVisitor {\n  visitElement(ast) {\n    const preparsedElement = preparseElement(ast);\n    if (preparsedElement.type === PreparsedElementType.SCRIPT || preparsedElement.type === PreparsedElementType.STYLE || preparsedElement.type === PreparsedElementType.STYLESHEET) {\n      return null;\n    }\n    const children = visitAll(this, ast.children, null);\n    return new Element$1(ast.name, visitAll(this, ast.attrs), [], [], [], children, [], ast.isSelfClosing, ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan, ast.isVoid);\n  }\n  visitComment(comment) {\n    return null;\n  }\n  visitAttribute(attribute) {\n    return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);\n  }\n  visitText(text) {\n    return new Text$3(text.value, text.sourceSpan);\n  }\n  visitExpansion(expansion) {\n    return null;\n  }\n  visitExpansionCase(expansionCase) {\n    return null;\n  }\n  visitBlock(block, context) {\n    const nodes = [new Text$3(block.startSourceSpan.toString(), block.startSourceSpan), ...visitAll(this, block.children)];\n    if (block.endSourceSpan !== null) {\n      nodes.push(new Text$3(block.endSourceSpan.toString(), block.endSourceSpan));\n    }\n    return nodes;\n  }\n  visitBlockParameter(parameter, context) {\n    return null;\n  }\n  visitLetDeclaration(decl, context) {\n    return new Text$3(`@let ${decl.name} = ${decl.value};`, decl.sourceSpan);\n  }\n  visitComponent(ast, context) {\n    const children = visitAll(this, ast.children, null);\n    return new Element$1(ast.fullName, visitAll(this, ast.attrs), [], [], [], children, [], ast.isSelfClosing, ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan, false);\n  }\n  visitDirective(directive, context) {\n    return null;\n  }\n}\nconst NON_BINDABLE_VISITOR = new NonBindableVisitor();\nfunction normalizeAttributeName(attrName) {\n  return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n}\nfunction addEvents(events, boundEvents) {\n  boundEvents.push(...events.map(e => BoundEvent.fromParsedEvent(e)));\n}\nfunction textContents(node) {\n  if (node.children.length !== 1 || !(node.children[0] instanceof Text)) {\n    return null;\n  } else {\n    return node.children[0].value;\n  }\n}\n\nconst LEADING_TRIVIA_CHARS = [' ', '\\n', '\\r', '\\t'];\nfunction parseTemplate(template, templateUrl, options = {}) {\n  const {\n    preserveWhitespaces,\n    enableI18nLegacyMessageIdFormat\n  } = options;\n  const selectorlessEnabled = options.enableSelectorless ?? false;\n  const bindingParser = makeBindingParser(selectorlessEnabled);\n  const htmlParser = new HtmlParser();\n  const parseResult = htmlParser.parse(template, templateUrl, {\n    leadingTriviaChars: LEADING_TRIVIA_CHARS,\n    ...options,\n    tokenizeExpansionForms: true,\n    tokenizeBlocks: options.enableBlockSyntax ?? true,\n    tokenizeLet: options.enableLetSyntax ?? true,\n    selectorlessEnabled\n  });\n  if (!options.alwaysAttemptHtmlToR3AstConversion && parseResult.errors && parseResult.errors.length > 0) {\n    const parsedTemplate = {\n      preserveWhitespaces,\n      errors: parseResult.errors,\n      nodes: [],\n      styleUrls: [],\n      styles: [],\n      ngContentSelectors: []\n    };\n    if (options.collectCommentNodes) {\n      parsedTemplate.commentNodes = [];\n    }\n    return parsedTemplate;\n  }\n  let rootNodes = parseResult.rootNodes;\n  const retainEmptyTokens = !(options.preserveSignificantWhitespace ?? true);\n  const i18nMetaVisitor = new I18nMetaVisitor(!preserveWhitespaces, enableI18nLegacyMessageIdFormat, undefined, options.preserveSignificantWhitespace, retainEmptyTokens);\n  const i18nMetaResult = i18nMetaVisitor.visitAllWithErrors(rootNodes);\n  if (!options.alwaysAttemptHtmlToR3AstConversion && i18nMetaResult.errors && i18nMetaResult.errors.length > 0) {\n    const parsedTemplate = {\n      preserveWhitespaces,\n      errors: i18nMetaResult.errors,\n      nodes: [],\n      styleUrls: [],\n      styles: [],\n      ngContentSelectors: []\n    };\n    if (options.collectCommentNodes) {\n      parsedTemplate.commentNodes = [];\n    }\n    return parsedTemplate;\n  }\n  rootNodes = i18nMetaResult.rootNodes;\n  if (!preserveWhitespaces) {\n    rootNodes = visitAll(new WhitespaceVisitor(true, undefined, false), rootNodes);\n    if (i18nMetaVisitor.hasI18nMeta) {\n      rootNodes = visitAll(new I18nMetaVisitor(false, undefined, undefined, true, retainEmptyTokens), rootNodes);\n    }\n  }\n  const {\n    nodes,\n    errors,\n    styleUrls,\n    styles,\n    ngContentSelectors,\n    commentNodes\n  } = htmlAstToRender3Ast(rootNodes, bindingParser, {\n    collectCommentNodes: !!options.collectCommentNodes\n  });\n  errors.push(...parseResult.errors, ...i18nMetaResult.errors);\n  const parsedTemplate = {\n    preserveWhitespaces,\n    errors: errors.length > 0 ? errors : null,\n    nodes,\n    styleUrls,\n    styles,\n    ngContentSelectors\n  };\n  if (options.collectCommentNodes) {\n    parsedTemplate.commentNodes = commentNodes;\n  }\n  return parsedTemplate;\n}\nconst elementRegistry = new DomElementSchemaRegistry();\nfunction makeBindingParser(selectorlessEnabled = false) {\n  return new BindingParser(new Parser(new Lexer(), selectorlessEnabled), elementRegistry, []);\n}\n\nconst COMPONENT_VARIABLE = '%COMP%';\nconst HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\nconst CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\nfunction baseDirectiveFields(meta, constantPool, bindingParser) {\n  const definitionMap = new DefinitionMap();\n  const selectors = parseSelectorToR3Selector(meta.selector);\n  definitionMap.set('type', meta.type.value);\n  if (selectors.length > 0) {\n    definitionMap.set('selectors', asLiteral(selectors));\n  }\n  if (meta.queries.length > 0) {\n    definitionMap.set('contentQueries', createContentQueriesFunction(meta.queries, constantPool, meta.name));\n  }\n  if (meta.viewQueries.length) {\n    definitionMap.set('viewQuery', createViewQueriesFunction(meta.viewQueries, constantPool, meta.name));\n  }\n  definitionMap.set('hostBindings', createHostBindingsFunction(meta.host, meta.typeSourceSpan, bindingParser, constantPool, meta.selector || '', meta.name, definitionMap));\n  definitionMap.set('inputs', conditionallyCreateDirectiveBindingLiteral(meta.inputs, true));\n  definitionMap.set('outputs', conditionallyCreateDirectiveBindingLiteral(meta.outputs));\n  if (meta.exportAs !== null) {\n    definitionMap.set('exportAs', literalArr(meta.exportAs.map(e => literal(e))));\n  }\n  if (meta.isStandalone === false) {\n    definitionMap.set('standalone', literal(false));\n  }\n  if (meta.isSignal) {\n    definitionMap.set('signals', literal(true));\n  }\n  return definitionMap;\n}\nfunction addFeatures(definitionMap, meta) {\n  const features = [];\n  const providers = meta.providers;\n  const viewProviders = meta.viewProviders;\n  if (providers || viewProviders) {\n    const args = [providers || new LiteralArrayExpr([])];\n    if (viewProviders) {\n      args.push(viewProviders);\n    }\n    features.push(importExpr(Identifiers.ProvidersFeature).callFn(args));\n  }\n  if (meta.hostDirectives?.length) {\n    features.push(importExpr(Identifiers.HostDirectivesFeature).callFn([createHostDirectivesFeatureArg(meta.hostDirectives)]));\n  }\n  if (meta.usesInheritance) {\n    features.push(importExpr(Identifiers.InheritDefinitionFeature));\n  }\n  if (meta.lifecycle.usesOnChanges) {\n    features.push(importExpr(Identifiers.NgOnChangesFeature));\n  }\n  if ('externalStyles' in meta && meta.externalStyles?.length) {\n    const externalStyleNodes = meta.externalStyles.map(externalStyle => literal(externalStyle));\n    features.push(importExpr(Identifiers.ExternalStylesFeature).callFn([literalArr(externalStyleNodes)]));\n  }\n  if (features.length) {\n    definitionMap.set('features', literalArr(features));\n  }\n}\nfunction compileDirectiveFromMetadata(meta, constantPool, bindingParser) {\n  const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n  addFeatures(definitionMap, meta);\n  const expression = importExpr(Identifiers.defineDirective).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createDirectiveType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction compileComponentFromMetadata(meta, constantPool, bindingParser) {\n  const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n  addFeatures(definitionMap, meta);\n  const selector = meta.selector && CssSelector.parse(meta.selector);\n  const firstSelector = selector && selector[0];\n  if (firstSelector) {\n    const selectorAttributes = firstSelector.getAttrs();\n    if (selectorAttributes.length) {\n      definitionMap.set('attrs', constantPool.getConstLiteral(literalArr(selectorAttributes.map(value => value != null ? literal(value) : literal(undefined))), true));\n    }\n  }\n  const templateTypeName = meta.name;\n  let allDeferrableDepsFn = null;\n  if (meta.defer.mode === 1 && meta.defer.dependenciesFn !== null) {\n    const fnName = `${templateTypeName}_DeferFn`;\n    constantPool.statements.push(new DeclareVarStmt(fnName, meta.defer.dependenciesFn, undefined, StmtModifier.Final));\n    allDeferrableDepsFn = variable(fnName);\n  }\n  const compilationMode = meta.isStandalone && !meta.hasDirectiveDependencies ? TemplateCompilationMode.DomOnly : TemplateCompilationMode.Full;\n  const tpl = ingestComponent(meta.name, meta.template.nodes, constantPool, compilationMode, meta.relativeContextFilePath, meta.i18nUseExternalIds, meta.defer, allDeferrableDepsFn, meta.relativeTemplatePath, getTemplateSourceLocationsEnabled());\n  transform(tpl, CompilationJobKind.Tmpl);\n  const templateFn = emitTemplateFn(tpl, constantPool);\n  if (tpl.contentSelectors !== null) {\n    definitionMap.set('ngContentSelectors', tpl.contentSelectors);\n  }\n  definitionMap.set('decls', literal(tpl.root.decls));\n  definitionMap.set('vars', literal(tpl.root.vars));\n  if (tpl.consts.length > 0) {\n    if (tpl.constsInitializers.length > 0) {\n      definitionMap.set('consts', arrowFn([], [...tpl.constsInitializers, new ReturnStatement(literalArr(tpl.consts))]));\n    } else {\n      definitionMap.set('consts', literalArr(tpl.consts));\n    }\n  }\n  definitionMap.set('template', templateFn);\n  if (meta.declarationListEmitMode !== 3 && meta.declarations.length > 0) {\n    definitionMap.set('dependencies', compileDeclarationList(literalArr(meta.declarations.map(decl => decl.type)), meta.declarationListEmitMode));\n  } else if (meta.declarationListEmitMode === 3) {\n    const args = [meta.type.value];\n    if (meta.rawImports) {\n      args.push(meta.rawImports);\n    }\n    definitionMap.set('dependencies', importExpr(Identifiers.getComponentDepsFactory).callFn(args));\n  }\n  if (meta.encapsulation === null) {\n    meta.encapsulation = ViewEncapsulation$1.Emulated;\n  }\n  let hasStyles = !!meta.externalStyles?.length;\n  if (meta.styles && meta.styles.length) {\n    const styleValues = meta.encapsulation == ViewEncapsulation$1.Emulated ? compileStyles(meta.styles, CONTENT_ATTR, HOST_ATTR) : meta.styles;\n    const styleNodes = styleValues.reduce((result, style) => {\n      if (style.trim().length > 0) {\n        result.push(constantPool.getConstLiteral(literal(style)));\n      }\n      return result;\n    }, []);\n    if (styleNodes.length > 0) {\n      hasStyles = true;\n      definitionMap.set('styles', literalArr(styleNodes));\n    }\n  }\n  if (!hasStyles && meta.encapsulation === ViewEncapsulation$1.Emulated) {\n    meta.encapsulation = ViewEncapsulation$1.None;\n  }\n  if (meta.encapsulation !== ViewEncapsulation$1.Emulated) {\n    definitionMap.set('encapsulation', literal(meta.encapsulation));\n  }\n  if (meta.animations !== null) {\n    definitionMap.set('data', literalMap([{\n      key: 'animation',\n      value: meta.animations,\n      quoted: false\n    }]));\n  }\n  if (meta.changeDetection !== null) {\n    if (typeof meta.changeDetection === 'number' && meta.changeDetection !== ChangeDetectionStrategy.Default) {\n      definitionMap.set('changeDetection', literal(meta.changeDetection));\n    } else if (typeof meta.changeDetection === 'object') {\n      definitionMap.set('changeDetection', meta.changeDetection);\n    }\n  }\n  const expression = importExpr(Identifiers.defineComponent).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createComponentType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createComponentType(meta) {\n  const typeParams = createBaseDirectiveTypeParams(meta);\n  typeParams.push(stringArrayAsType(meta.template.ngContentSelectors));\n  typeParams.push(expressionType(literal(meta.isStandalone)));\n  typeParams.push(createHostDirectivesType(meta));\n  if (meta.isSignal) {\n    typeParams.push(expressionType(literal(meta.isSignal)));\n  }\n  return expressionType(importExpr(Identifiers.ComponentDeclaration, typeParams));\n}\nfunction compileDeclarationList(list, mode) {\n  switch (mode) {\n    case 0:\n      return list;\n    case 1:\n      return arrowFn([], list);\n    case 2:\n      const resolvedList = list.prop('map').callFn([importExpr(Identifiers.resolveForwardRef)]);\n      return arrowFn([], resolvedList);\n    case 3:\n      throw new Error(`Unsupported with an array of pre-resolved dependencies`);\n  }\n}\nfunction stringAsType(str) {\n  return expressionType(literal(str));\n}\nfunction stringMapAsLiteralExpression(map) {\n  const mapValues = Object.keys(map).map(key => {\n    const value = Array.isArray(map[key]) ? map[key][0] : map[key];\n    return {\n      key,\n      value: literal(value),\n      quoted: true\n    };\n  });\n  return literalMap(mapValues);\n}\nfunction stringArrayAsType(arr) {\n  return arr.length > 0 ? expressionType(literalArr(arr.map(value => literal(value)))) : NONE_TYPE;\n}\nfunction createBaseDirectiveTypeParams(meta) {\n  const selectorForType = meta.selector !== null ? meta.selector.replace(/\\n/g, '') : null;\n  return [typeWithParameters(meta.type.type, meta.typeArgumentCount), selectorForType !== null ? stringAsType(selectorForType) : NONE_TYPE, meta.exportAs !== null ? stringArrayAsType(meta.exportAs) : NONE_TYPE, expressionType(getInputsTypeExpression(meta)), expressionType(stringMapAsLiteralExpression(meta.outputs)), stringArrayAsType(meta.queries.map(q => q.propertyName))];\n}\nfunction getInputsTypeExpression(meta) {\n  return literalMap(Object.keys(meta.inputs).map(key => {\n    const value = meta.inputs[key];\n    const values = [{\n      key: 'alias',\n      value: literal(value.bindingPropertyName),\n      quoted: true\n    }, {\n      key: 'required',\n      value: literal(value.required),\n      quoted: true\n    }];\n    if (value.isSignal) {\n      values.push({\n        key: 'isSignal',\n        value: literal(value.isSignal),\n        quoted: true\n      });\n    }\n    return {\n      key,\n      value: literalMap(values),\n      quoted: true\n    };\n  }));\n}\nfunction createDirectiveType(meta) {\n  const typeParams = createBaseDirectiveTypeParams(meta);\n  typeParams.push(NONE_TYPE);\n  typeParams.push(expressionType(literal(meta.isStandalone)));\n  typeParams.push(createHostDirectivesType(meta));\n  if (meta.isSignal) {\n    typeParams.push(expressionType(literal(meta.isSignal)));\n  }\n  return expressionType(importExpr(Identifiers.DirectiveDeclaration, typeParams));\n}\nfunction createHostBindingsFunction(hostBindingsMetadata, typeSourceSpan, bindingParser, constantPool, selector, name, definitionMap) {\n  const bindings = bindingParser.createBoundHostProperties(hostBindingsMetadata.properties, typeSourceSpan);\n  const eventBindings = bindingParser.createDirectiveHostEventAsts(hostBindingsMetadata.listeners, typeSourceSpan);\n  if (hostBindingsMetadata.specialAttributes.styleAttr) {\n    hostBindingsMetadata.attributes['style'] = literal(hostBindingsMetadata.specialAttributes.styleAttr);\n  }\n  if (hostBindingsMetadata.specialAttributes.classAttr) {\n    hostBindingsMetadata.attributes['class'] = literal(hostBindingsMetadata.specialAttributes.classAttr);\n  }\n  const hostJob = ingestHostBinding({\n    componentName: name,\n    componentSelector: selector,\n    properties: bindings,\n    events: eventBindings,\n    attributes: hostBindingsMetadata.attributes\n  }, bindingParser, constantPool);\n  transform(hostJob, CompilationJobKind.Host);\n  definitionMap.set('hostAttrs', hostJob.root.attributes);\n  const varCount = hostJob.root.vars;\n  if (varCount !== null && varCount > 0) {\n    definitionMap.set('hostVars', literal(varCount));\n  }\n  return emitHostBindingFunction(hostJob);\n}\nconst HOST_REG_EXP = /^(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\))$/;\nfunction parseHostBindings(host) {\n  const attributes = {};\n  const listeners = {};\n  const properties = {};\n  const specialAttributes = {};\n  for (const key of Object.keys(host)) {\n    const value = host[key];\n    const matches = key.match(HOST_REG_EXP);\n    if (matches === null) {\n      switch (key) {\n        case 'class':\n          if (typeof value !== 'string') {\n            throw new Error(`Class binding must be string`);\n          }\n          specialAttributes.classAttr = value;\n          break;\n        case 'style':\n          if (typeof value !== 'string') {\n            throw new Error(`Style binding must be string`);\n          }\n          specialAttributes.styleAttr = value;\n          break;\n        default:\n          if (typeof value === 'string') {\n            attributes[key] = literal(value);\n          } else {\n            attributes[key] = value;\n          }\n      }\n    } else if (matches[1] != null) {\n      if (typeof value !== 'string') {\n        throw new Error(`Property binding must be string`);\n      }\n      properties[matches[1]] = value;\n    } else if (matches[2] != null) {\n      if (typeof value !== 'string') {\n        throw new Error(`Event binding must be string`);\n      }\n      listeners[matches[2]] = value;\n    }\n  }\n  return {\n    attributes,\n    listeners,\n    properties,\n    specialAttributes\n  };\n}\nfunction verifyHostBindings(bindings, sourceSpan) {\n  const bindingParser = makeBindingParser();\n  bindingParser.createDirectiveHostEventAsts(bindings.listeners, sourceSpan);\n  bindingParser.createBoundHostProperties(bindings.properties, sourceSpan);\n  return bindingParser.errors;\n}\nfunction compileStyles(styles, selector, hostSelector) {\n  const shadowCss = new ShadowCss();\n  return styles.map(style => {\n    return shadowCss.shimCssText(style, selector, hostSelector);\n  });\n}\nfunction encapsulateStyle(style, componentIdentifier) {\n  const shadowCss = new ShadowCss();\n  const selector = componentIdentifier ? CONTENT_ATTR.replace(COMPONENT_VARIABLE, componentIdentifier) : CONTENT_ATTR;\n  const hostSelector = componentIdentifier ? HOST_ATTR.replace(COMPONENT_VARIABLE, componentIdentifier) : HOST_ATTR;\n  return shadowCss.shimCssText(style, selector, hostSelector);\n}\nfunction createHostDirectivesType(meta) {\n  if (!meta.hostDirectives?.length) {\n    return NONE_TYPE;\n  }\n  return expressionType(literalArr(meta.hostDirectives.map(hostMeta => literalMap([{\n    key: 'directive',\n    value: typeofExpr(hostMeta.directive.type),\n    quoted: false\n  }, {\n    key: 'inputs',\n    value: stringMapAsLiteralExpression(hostMeta.inputs || {}),\n    quoted: false\n  }, {\n    key: 'outputs',\n    value: stringMapAsLiteralExpression(hostMeta.outputs || {}),\n    quoted: false\n  }]))));\n}\nfunction createHostDirectivesFeatureArg(hostDirectives) {\n  const expressions = [];\n  let hasForwardRef = false;\n  for (const current of hostDirectives) {\n    if (!current.inputs && !current.outputs) {\n      expressions.push(current.directive.type);\n    } else {\n      const keys = [{\n        key: 'directive',\n        value: current.directive.type,\n        quoted: false\n      }];\n      if (current.inputs) {\n        const inputsLiteral = createHostDirectivesMappingArray(current.inputs);\n        if (inputsLiteral) {\n          keys.push({\n            key: 'inputs',\n            value: inputsLiteral,\n            quoted: false\n          });\n        }\n      }\n      if (current.outputs) {\n        const outputsLiteral = createHostDirectivesMappingArray(current.outputs);\n        if (outputsLiteral) {\n          keys.push({\n            key: 'outputs',\n            value: outputsLiteral,\n            quoted: false\n          });\n        }\n      }\n      expressions.push(literalMap(keys));\n    }\n    if (current.isForwardReference) {\n      hasForwardRef = true;\n    }\n  }\n  return hasForwardRef ? new FunctionExpr([], [new ReturnStatement(literalArr(expressions))]) : literalArr(expressions);\n}\nfunction createHostDirectivesMappingArray(mapping) {\n  const elements = [];\n  for (const publicName in mapping) {\n    if (mapping.hasOwnProperty(publicName)) {\n      elements.push(literal(publicName), literal(mapping[publicName]));\n    }\n  }\n  return elements.length > 0 ? literalArr(elements) : null;\n}\nfunction compileDeferResolverFunction(meta) {\n  const depExpressions = [];\n  if (meta.mode === 0) {\n    for (const dep of meta.dependencies) {\n      if (dep.isDeferrable) {\n        const innerFn = arrowFn([new FnParam('m', DYNAMIC_TYPE)], variable('m').prop(dep.isDefaultImport ? 'default' : dep.symbolName));\n        const importExpr = new DynamicImportExpr(dep.importPath).prop('then').callFn([innerFn]);\n        depExpressions.push(importExpr);\n      } else {\n        depExpressions.push(dep.typeReference);\n      }\n    }\n  } else {\n    for (const {\n      symbolName,\n      importPath,\n      isDefaultImport\n    } of meta.dependencies) {\n      const innerFn = arrowFn([new FnParam('m', DYNAMIC_TYPE)], variable('m').prop(isDefaultImport ? 'default' : symbolName));\n      const importExpr = new DynamicImportExpr(importPath).prop('then').callFn([innerFn]);\n      depExpressions.push(importExpr);\n    }\n  }\n  return arrowFn([], literalArr(depExpressions));\n}\n\nclass CombinedRecursiveAstVisitor extends RecursiveAstVisitor {\n  visit(node) {\n    if (node instanceof ASTWithSource) {\n      this.visit(node.ast);\n    } else {\n      node.visit(this);\n    }\n  }\n  visitElement(element) {\n    this.visitAllTemplateNodes(element.attributes);\n    this.visitAllTemplateNodes(element.inputs);\n    this.visitAllTemplateNodes(element.outputs);\n    this.visitAllTemplateNodes(element.directives);\n    this.visitAllTemplateNodes(element.references);\n    this.visitAllTemplateNodes(element.children);\n  }\n  visitTemplate(template) {\n    this.visitAllTemplateNodes(template.attributes);\n    this.visitAllTemplateNodes(template.inputs);\n    this.visitAllTemplateNodes(template.outputs);\n    this.visitAllTemplateNodes(template.directives);\n    this.visitAllTemplateNodes(template.templateAttrs);\n    this.visitAllTemplateNodes(template.variables);\n    this.visitAllTemplateNodes(template.references);\n    this.visitAllTemplateNodes(template.children);\n  }\n  visitContent(content) {\n    this.visitAllTemplateNodes(content.children);\n  }\n  visitBoundAttribute(attribute) {\n    this.visit(attribute.value);\n  }\n  visitBoundEvent(attribute) {\n    this.visit(attribute.handler);\n  }\n  visitBoundText(text) {\n    this.visit(text.value);\n  }\n  visitIcu(icu) {\n    Object.keys(icu.vars).forEach(key => this.visit(icu.vars[key]));\n    Object.keys(icu.placeholders).forEach(key => this.visit(icu.placeholders[key]));\n  }\n  visitDeferredBlock(deferred) {\n    deferred.visitAll(this);\n  }\n  visitDeferredTrigger(trigger) {\n    if (trigger instanceof BoundDeferredTrigger) {\n      this.visit(trigger.value);\n    } else if (trigger instanceof ViewportDeferredTrigger && trigger.options !== null) {\n      this.visit(trigger.options);\n    }\n  }\n  visitDeferredBlockPlaceholder(block) {\n    this.visitAllTemplateNodes(block.children);\n  }\n  visitDeferredBlockError(block) {\n    this.visitAllTemplateNodes(block.children);\n  }\n  visitDeferredBlockLoading(block) {\n    this.visitAllTemplateNodes(block.children);\n  }\n  visitSwitchBlock(block) {\n    this.visit(block.expression);\n    this.visitAllTemplateNodes(block.cases);\n  }\n  visitSwitchBlockCase(block) {\n    block.expression && this.visit(block.expression);\n    this.visitAllTemplateNodes(block.children);\n  }\n  visitForLoopBlock(block) {\n    block.item.visit(this);\n    this.visitAllTemplateNodes(block.contextVariables);\n    this.visit(block.expression);\n    this.visitAllTemplateNodes(block.children);\n    block.empty?.visit(this);\n  }\n  visitForLoopBlockEmpty(block) {\n    this.visitAllTemplateNodes(block.children);\n  }\n  visitIfBlock(block) {\n    this.visitAllTemplateNodes(block.branches);\n  }\n  visitIfBlockBranch(block) {\n    block.expression && this.visit(block.expression);\n    block.expressionAlias?.visit(this);\n    this.visitAllTemplateNodes(block.children);\n  }\n  visitLetDeclaration(decl) {\n    this.visit(decl.value);\n  }\n  visitComponent(component) {\n    this.visitAllTemplateNodes(component.attributes);\n    this.visitAllTemplateNodes(component.inputs);\n    this.visitAllTemplateNodes(component.outputs);\n    this.visitAllTemplateNodes(component.directives);\n    this.visitAllTemplateNodes(component.references);\n    this.visitAllTemplateNodes(component.children);\n  }\n  visitDirective(directive) {\n    this.visitAllTemplateNodes(directive.attributes);\n    this.visitAllTemplateNodes(directive.inputs);\n    this.visitAllTemplateNodes(directive.outputs);\n    this.visitAllTemplateNodes(directive.references);\n  }\n  visitVariable(variable) {}\n  visitReference(reference) {}\n  visitTextAttribute(attribute) {}\n  visitText(text) {}\n  visitUnknownBlock(block) {}\n  visitAllTemplateNodes(nodes) {\n    for (const node of nodes) {\n      this.visit(node);\n    }\n  }\n}\n\nfunction diff(fullList, itemsToExclude) {\n  const exclude = new Set(itemsToExclude);\n  return fullList.filter(item => !exclude.has(item));\n}\nfunction findMatchingDirectivesAndPipes(template, directiveSelectors) {\n  const matcher = new SelectorMatcher();\n  for (const selector of directiveSelectors) {\n    const fakeDirective = {\n      selector,\n      exportAs: null,\n      inputs: {\n        hasBindingPropertyName() {\n          return false;\n        }\n      },\n      outputs: {\n        hasBindingPropertyName() {\n          return false;\n        }\n      }\n    };\n    matcher.addSelectables(CssSelector.parse(selector), [fakeDirective]);\n  }\n  const parsedTemplate = parseTemplate(template, '');\n  const binder = new R3TargetBinder(matcher);\n  const bound = binder.bind({\n    template: parsedTemplate.nodes\n  });\n  const eagerDirectiveSelectors = bound.getEagerlyUsedDirectives().map(dir => dir.selector);\n  const allMatchedDirectiveSelectors = bound.getUsedDirectives().map(dir => dir.selector);\n  const eagerPipes = bound.getEagerlyUsedPipes();\n  return {\n    directives: {\n      regular: eagerDirectiveSelectors,\n      deferCandidates: diff(allMatchedDirectiveSelectors, eagerDirectiveSelectors)\n    },\n    pipes: {\n      regular: eagerPipes,\n      deferCandidates: diff(bound.getUsedPipes(), eagerPipes)\n    }\n  };\n}\nclass R3TargetBinder {\n  directiveMatcher;\n  constructor(directiveMatcher) {\n    this.directiveMatcher = directiveMatcher;\n  }\n  bind(target) {\n    if (!target.template && !target.host) {\n      throw new Error('Empty bound targets are not supported');\n    }\n    const directives = new Map();\n    const eagerDirectives = [];\n    const missingDirectives = new Set();\n    const bindings = new Map();\n    const references = new Map();\n    const scopedNodeEntities = new Map();\n    const expressions = new Map();\n    const symbols = new Map();\n    const nestingLevel = new Map();\n    const usedPipes = new Set();\n    const eagerPipes = new Set();\n    const deferBlocks = [];\n    if (target.template) {\n      const scope = Scope.apply(target.template);\n      extractScopedNodeEntities(scope, scopedNodeEntities);\n      DirectiveBinder.apply(target.template, this.directiveMatcher, directives, eagerDirectives, missingDirectives, bindings, references);\n      TemplateBinder.applyWithScope(target.template, scope, expressions, symbols, nestingLevel, usedPipes, eagerPipes, deferBlocks);\n    }\n    if (target.host) {\n      directives.set(target.host.node, target.host.directives);\n      TemplateBinder.applyWithScope(target.host.node, Scope.apply(target.host.node), expressions, symbols, nestingLevel, usedPipes, eagerPipes, deferBlocks);\n    }\n    return new R3BoundTarget(target, directives, eagerDirectives, missingDirectives, bindings, references, expressions, symbols, nestingLevel, scopedNodeEntities, usedPipes, eagerPipes, deferBlocks);\n  }\n}\nclass Scope {\n  parentScope;\n  rootNode;\n  namedEntities = new Map();\n  elementLikeInScope = new Set();\n  childScopes = new Map();\n  isDeferred;\n  constructor(parentScope, rootNode) {\n    this.parentScope = parentScope;\n    this.rootNode = rootNode;\n    this.isDeferred = parentScope !== null && parentScope.isDeferred ? true : rootNode instanceof DeferredBlock;\n  }\n  static newRootScope() {\n    return new Scope(null, null);\n  }\n  static apply(template) {\n    const scope = Scope.newRootScope();\n    scope.ingest(template);\n    return scope;\n  }\n  ingest(nodeOrNodes) {\n    if (nodeOrNodes instanceof Template) {\n      nodeOrNodes.variables.forEach(node => this.visitVariable(node));\n      nodeOrNodes.children.forEach(node => node.visit(this));\n    } else if (nodeOrNodes instanceof IfBlockBranch) {\n      if (nodeOrNodes.expressionAlias !== null) {\n        this.visitVariable(nodeOrNodes.expressionAlias);\n      }\n      nodeOrNodes.children.forEach(node => node.visit(this));\n    } else if (nodeOrNodes instanceof ForLoopBlock) {\n      this.visitVariable(nodeOrNodes.item);\n      nodeOrNodes.contextVariables.forEach(v => this.visitVariable(v));\n      nodeOrNodes.children.forEach(node => node.visit(this));\n    } else if (nodeOrNodes instanceof SwitchBlockCase || nodeOrNodes instanceof ForLoopBlockEmpty || nodeOrNodes instanceof DeferredBlock || nodeOrNodes instanceof DeferredBlockError || nodeOrNodes instanceof DeferredBlockPlaceholder || nodeOrNodes instanceof DeferredBlockLoading || nodeOrNodes instanceof Content) {\n      nodeOrNodes.children.forEach(node => node.visit(this));\n    } else if (!(nodeOrNodes instanceof HostElement)) {\n      nodeOrNodes.forEach(node => node.visit(this));\n    }\n  }\n  visitElement(element) {\n    this.visitElementLike(element);\n  }\n  visitTemplate(template) {\n    template.directives.forEach(node => node.visit(this));\n    template.references.forEach(node => this.visitReference(node));\n    this.ingestScopedNode(template);\n  }\n  visitVariable(variable) {\n    this.maybeDeclare(variable);\n  }\n  visitReference(reference) {\n    this.maybeDeclare(reference);\n  }\n  visitDeferredBlock(deferred) {\n    this.ingestScopedNode(deferred);\n    deferred.placeholder?.visit(this);\n    deferred.loading?.visit(this);\n    deferred.error?.visit(this);\n  }\n  visitDeferredBlockPlaceholder(block) {\n    this.ingestScopedNode(block);\n  }\n  visitDeferredBlockError(block) {\n    this.ingestScopedNode(block);\n  }\n  visitDeferredBlockLoading(block) {\n    this.ingestScopedNode(block);\n  }\n  visitSwitchBlock(block) {\n    block.cases.forEach(node => node.visit(this));\n  }\n  visitSwitchBlockCase(block) {\n    this.ingestScopedNode(block);\n  }\n  visitForLoopBlock(block) {\n    this.ingestScopedNode(block);\n    block.empty?.visit(this);\n  }\n  visitForLoopBlockEmpty(block) {\n    this.ingestScopedNode(block);\n  }\n  visitIfBlock(block) {\n    block.branches.forEach(node => node.visit(this));\n  }\n  visitIfBlockBranch(block) {\n    this.ingestScopedNode(block);\n  }\n  visitContent(content) {\n    this.ingestScopedNode(content);\n  }\n  visitLetDeclaration(decl) {\n    this.maybeDeclare(decl);\n  }\n  visitComponent(component) {\n    this.visitElementLike(component);\n  }\n  visitDirective(directive) {\n    directive.references.forEach(current => this.visitReference(current));\n  }\n  visitBoundAttribute(attr) {}\n  visitBoundEvent(event) {}\n  visitBoundText(text) {}\n  visitText(text) {}\n  visitTextAttribute(attr) {}\n  visitIcu(icu) {}\n  visitDeferredTrigger(trigger) {}\n  visitUnknownBlock(block) {}\n  visitElementLike(node) {\n    node.directives.forEach(current => current.visit(this));\n    node.references.forEach(current => this.visitReference(current));\n    node.children.forEach(current => current.visit(this));\n    this.elementLikeInScope.add(node);\n  }\n  maybeDeclare(thing) {\n    if (!this.namedEntities.has(thing.name)) {\n      this.namedEntities.set(thing.name, thing);\n    }\n  }\n  lookup(name) {\n    if (this.namedEntities.has(name)) {\n      return this.namedEntities.get(name);\n    } else if (this.parentScope !== null) {\n      return this.parentScope.lookup(name);\n    } else {\n      return null;\n    }\n  }\n  getChildScope(node) {\n    const res = this.childScopes.get(node);\n    if (res === undefined) {\n      throw new Error(`Assertion error: child scope for ${node} not found`);\n    }\n    return res;\n  }\n  ingestScopedNode(node) {\n    const scope = new Scope(this, node);\n    scope.ingest(node);\n    this.childScopes.set(node, scope);\n  }\n}\nclass DirectiveBinder {\n  directiveMatcher;\n  directives;\n  eagerDirectives;\n  missingDirectives;\n  bindings;\n  references;\n  isInDeferBlock = false;\n  constructor(directiveMatcher, directives, eagerDirectives, missingDirectives, bindings, references) {\n    this.directiveMatcher = directiveMatcher;\n    this.directives = directives;\n    this.eagerDirectives = eagerDirectives;\n    this.missingDirectives = missingDirectives;\n    this.bindings = bindings;\n    this.references = references;\n  }\n  static apply(template, directiveMatcher, directives, eagerDirectives, missingDirectives, bindings, references) {\n    const matcher = new DirectiveBinder(directiveMatcher, directives, eagerDirectives, missingDirectives, bindings, references);\n    matcher.ingest(template);\n  }\n  ingest(template) {\n    template.forEach(node => node.visit(this));\n  }\n  visitElement(element) {\n    this.visitElementOrTemplate(element);\n  }\n  visitTemplate(template) {\n    this.visitElementOrTemplate(template);\n  }\n  visitDeferredBlock(deferred) {\n    const wasInDeferBlock = this.isInDeferBlock;\n    this.isInDeferBlock = true;\n    deferred.children.forEach(child => child.visit(this));\n    this.isInDeferBlock = wasInDeferBlock;\n    deferred.placeholder?.visit(this);\n    deferred.loading?.visit(this);\n    deferred.error?.visit(this);\n  }\n  visitDeferredBlockPlaceholder(block) {\n    block.children.forEach(child => child.visit(this));\n  }\n  visitDeferredBlockError(block) {\n    block.children.forEach(child => child.visit(this));\n  }\n  visitDeferredBlockLoading(block) {\n    block.children.forEach(child => child.visit(this));\n  }\n  visitSwitchBlock(block) {\n    block.cases.forEach(node => node.visit(this));\n  }\n  visitSwitchBlockCase(block) {\n    block.children.forEach(node => node.visit(this));\n  }\n  visitForLoopBlock(block) {\n    block.item.visit(this);\n    block.contextVariables.forEach(v => v.visit(this));\n    block.children.forEach(node => node.visit(this));\n    block.empty?.visit(this);\n  }\n  visitForLoopBlockEmpty(block) {\n    block.children.forEach(node => node.visit(this));\n  }\n  visitIfBlock(block) {\n    block.branches.forEach(node => node.visit(this));\n  }\n  visitIfBlockBranch(block) {\n    block.expressionAlias?.visit(this);\n    block.children.forEach(node => node.visit(this));\n  }\n  visitContent(content) {\n    content.children.forEach(child => child.visit(this));\n  }\n  visitComponent(node) {\n    if (this.directiveMatcher instanceof SelectorlessMatcher) {\n      const componentMatches = this.directiveMatcher.match(node.componentName);\n      if (componentMatches.length > 0) {\n        this.trackSelectorlessMatchesAndDirectives(node, componentMatches);\n      } else {\n        this.missingDirectives.add(node.componentName);\n      }\n    }\n    node.directives.forEach(directive => directive.visit(this));\n    node.children.forEach(child => child.visit(this));\n  }\n  visitDirective(node) {\n    if (this.directiveMatcher instanceof SelectorlessMatcher) {\n      const directives = this.directiveMatcher.match(node.name);\n      if (directives.length > 0) {\n        this.trackSelectorlessMatchesAndDirectives(node, directives);\n      } else {\n        this.missingDirectives.add(node.name);\n      }\n    }\n  }\n  visitElementOrTemplate(node) {\n    if (this.directiveMatcher instanceof SelectorMatcher) {\n      const directives = [];\n      const cssSelector = createCssSelectorFromNode(node);\n      this.directiveMatcher.match(cssSelector, (_, results) => directives.push(...results));\n      this.trackSelectorBasedBindingsAndDirectives(node, directives);\n    } else {\n      node.references.forEach(ref => {\n        if (ref.value.trim() === '') {\n          this.references.set(ref, node);\n        }\n      });\n    }\n    node.directives.forEach(directive => directive.visit(this));\n    node.children.forEach(child => child.visit(this));\n  }\n  trackMatchedDirectives(node, directives) {\n    if (directives.length > 0) {\n      this.directives.set(node, directives);\n      if (!this.isInDeferBlock) {\n        this.eagerDirectives.push(...directives);\n      }\n    }\n  }\n  trackSelectorlessMatchesAndDirectives(node, directives) {\n    if (directives.length === 0) {\n      return;\n    }\n    this.trackMatchedDirectives(node, directives);\n    const setBinding = (meta, attribute, ioType) => {\n      if (meta[ioType].hasBindingPropertyName(attribute.name)) {\n        this.bindings.set(attribute, meta);\n      }\n    };\n    for (const directive of directives) {\n      node.inputs.forEach(input => setBinding(directive, input, 'inputs'));\n      node.attributes.forEach(attr => setBinding(directive, attr, 'inputs'));\n      node.outputs.forEach(output => setBinding(directive, output, 'outputs'));\n    }\n    node.references.forEach(ref => this.references.set(ref, {\n      directive: directives[0],\n      node: node\n    }));\n  }\n  trackSelectorBasedBindingsAndDirectives(node, directives) {\n    this.trackMatchedDirectives(node, directives);\n    node.references.forEach(ref => {\n      let dirTarget = null;\n      if (ref.value.trim() === '') {\n        dirTarget = directives.find(dir => dir.isComponent) || null;\n      } else {\n        dirTarget = directives.find(dir => dir.exportAs !== null && dir.exportAs.some(value => value === ref.value)) || null;\n        if (dirTarget === null) {\n          return;\n        }\n      }\n      if (dirTarget !== null) {\n        this.references.set(ref, {\n          directive: dirTarget,\n          node\n        });\n      } else {\n        this.references.set(ref, node);\n      }\n    });\n    const setAttributeBinding = (attribute, ioType) => {\n      const dir = directives.find(dir => dir[ioType].hasBindingPropertyName(attribute.name));\n      const binding = dir !== undefined ? dir : node;\n      this.bindings.set(attribute, binding);\n    };\n    node.inputs.forEach(input => setAttributeBinding(input, 'inputs'));\n    node.attributes.forEach(attr => setAttributeBinding(attr, 'inputs'));\n    if (node instanceof Template) {\n      node.templateAttrs.forEach(attr => setAttributeBinding(attr, 'inputs'));\n    }\n    node.outputs.forEach(output => setAttributeBinding(output, 'outputs'));\n  }\n  visitVariable(variable) {}\n  visitReference(reference) {}\n  visitTextAttribute(attribute) {}\n  visitBoundAttribute(attribute) {}\n  visitBoundEvent(attribute) {}\n  visitBoundAttributeOrEvent(node) {}\n  visitText(text) {}\n  visitBoundText(text) {}\n  visitIcu(icu) {}\n  visitDeferredTrigger(trigger) {}\n  visitUnknownBlock(block) {}\n  visitLetDeclaration(decl) {}\n}\nclass TemplateBinder extends CombinedRecursiveAstVisitor {\n  bindings;\n  symbols;\n  usedPipes;\n  eagerPipes;\n  deferBlocks;\n  nestingLevel;\n  scope;\n  rootNode;\n  level;\n  visitNode = node => node.visit(this);\n  constructor(bindings, symbols, usedPipes, eagerPipes, deferBlocks, nestingLevel, scope, rootNode, level) {\n    super();\n    this.bindings = bindings;\n    this.symbols = symbols;\n    this.usedPipes = usedPipes;\n    this.eagerPipes = eagerPipes;\n    this.deferBlocks = deferBlocks;\n    this.nestingLevel = nestingLevel;\n    this.scope = scope;\n    this.rootNode = rootNode;\n    this.level = level;\n  }\n  static applyWithScope(nodeOrNodes, scope, expressions, symbols, nestingLevel, usedPipes, eagerPipes, deferBlocks) {\n    const template = nodeOrNodes instanceof Template ? nodeOrNodes : null;\n    const binder = new TemplateBinder(expressions, symbols, usedPipes, eagerPipes, deferBlocks, nestingLevel, scope, template, 0);\n    binder.ingest(nodeOrNodes);\n  }\n  ingest(nodeOrNodes) {\n    if (nodeOrNodes instanceof Template) {\n      nodeOrNodes.variables.forEach(this.visitNode);\n      nodeOrNodes.children.forEach(this.visitNode);\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (nodeOrNodes instanceof IfBlockBranch) {\n      if (nodeOrNodes.expressionAlias !== null) {\n        this.visitNode(nodeOrNodes.expressionAlias);\n      }\n      nodeOrNodes.children.forEach(this.visitNode);\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (nodeOrNodes instanceof ForLoopBlock) {\n      this.visitNode(nodeOrNodes.item);\n      nodeOrNodes.contextVariables.forEach(v => this.visitNode(v));\n      nodeOrNodes.trackBy.visit(this);\n      nodeOrNodes.children.forEach(this.visitNode);\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (nodeOrNodes instanceof DeferredBlock) {\n      if (this.scope.rootNode !== nodeOrNodes) {\n        throw new Error(`Assertion error: resolved incorrect scope for deferred block ${nodeOrNodes}`);\n      }\n      this.deferBlocks.push([nodeOrNodes, this.scope]);\n      nodeOrNodes.children.forEach(node => node.visit(this));\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (nodeOrNodes instanceof SwitchBlockCase || nodeOrNodes instanceof ForLoopBlockEmpty || nodeOrNodes instanceof DeferredBlockError || nodeOrNodes instanceof DeferredBlockPlaceholder || nodeOrNodes instanceof DeferredBlockLoading || nodeOrNodes instanceof Content) {\n      nodeOrNodes.children.forEach(node => node.visit(this));\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (nodeOrNodes instanceof HostElement) {\n      this.nestingLevel.set(nodeOrNodes, 0);\n    } else {\n      nodeOrNodes.forEach(this.visitNode);\n    }\n  }\n  visitTemplate(template) {\n    template.inputs.forEach(this.visitNode);\n    template.outputs.forEach(this.visitNode);\n    template.directives.forEach(this.visitNode);\n    template.templateAttrs.forEach(this.visitNode);\n    template.references.forEach(this.visitNode);\n    this.ingestScopedNode(template);\n  }\n  visitVariable(variable) {\n    if (this.rootNode !== null) {\n      this.symbols.set(variable, this.rootNode);\n    }\n  }\n  visitReference(reference) {\n    if (this.rootNode !== null) {\n      this.symbols.set(reference, this.rootNode);\n    }\n  }\n  visitDeferredBlock(deferred) {\n    this.ingestScopedNode(deferred);\n    deferred.triggers.when?.value.visit(this);\n    deferred.prefetchTriggers.when?.value.visit(this);\n    deferred.hydrateTriggers.when?.value.visit(this);\n    deferred.hydrateTriggers.never?.visit(this);\n    deferred.placeholder && this.visitNode(deferred.placeholder);\n    deferred.loading && this.visitNode(deferred.loading);\n    deferred.error && this.visitNode(deferred.error);\n  }\n  visitDeferredBlockPlaceholder(block) {\n    this.ingestScopedNode(block);\n  }\n  visitDeferredBlockError(block) {\n    this.ingestScopedNode(block);\n  }\n  visitDeferredBlockLoading(block) {\n    this.ingestScopedNode(block);\n  }\n  visitSwitchBlockCase(block) {\n    block.expression?.visit(this);\n    this.ingestScopedNode(block);\n  }\n  visitForLoopBlock(block) {\n    block.expression.visit(this);\n    this.ingestScopedNode(block);\n    block.empty?.visit(this);\n  }\n  visitForLoopBlockEmpty(block) {\n    this.ingestScopedNode(block);\n  }\n  visitIfBlockBranch(block) {\n    block.expression?.visit(this);\n    this.ingestScopedNode(block);\n  }\n  visitContent(content) {\n    this.ingestScopedNode(content);\n  }\n  visitLetDeclaration(decl) {\n    super.visitLetDeclaration(decl);\n    if (this.rootNode !== null) {\n      this.symbols.set(decl, this.rootNode);\n    }\n  }\n  visitPipe(ast, context) {\n    this.usedPipes.add(ast.name);\n    if (!this.scope.isDeferred) {\n      this.eagerPipes.add(ast.name);\n    }\n    return super.visitPipe(ast, context);\n  }\n  visitPropertyRead(ast, context) {\n    this.maybeMap(ast, ast.name);\n    return super.visitPropertyRead(ast, context);\n  }\n  visitSafePropertyRead(ast, context) {\n    this.maybeMap(ast, ast.name);\n    return super.visitSafePropertyRead(ast, context);\n  }\n  ingestScopedNode(node) {\n    const childScope = this.scope.getChildScope(node);\n    const binder = new TemplateBinder(this.bindings, this.symbols, this.usedPipes, this.eagerPipes, this.deferBlocks, this.nestingLevel, childScope, node, this.level + 1);\n    binder.ingest(node);\n  }\n  maybeMap(ast, name) {\n    if (!(ast.receiver instanceof ImplicitReceiver) || ast.receiver instanceof ThisReceiver) {\n      return;\n    }\n    const target = this.scope.lookup(name);\n    if (target !== null) {\n      this.bindings.set(ast, target);\n    }\n  }\n}\nclass R3BoundTarget {\n  target;\n  directives;\n  eagerDirectives;\n  missingDirectives;\n  bindings;\n  references;\n  exprTargets;\n  symbols;\n  nestingLevel;\n  scopedNodeEntities;\n  usedPipes;\n  eagerPipes;\n  deferredBlocks;\n  deferredScopes;\n  constructor(target, directives, eagerDirectives, missingDirectives, bindings, references, exprTargets, symbols, nestingLevel, scopedNodeEntities, usedPipes, eagerPipes, rawDeferred) {\n    this.target = target;\n    this.directives = directives;\n    this.eagerDirectives = eagerDirectives;\n    this.missingDirectives = missingDirectives;\n    this.bindings = bindings;\n    this.references = references;\n    this.exprTargets = exprTargets;\n    this.symbols = symbols;\n    this.nestingLevel = nestingLevel;\n    this.scopedNodeEntities = scopedNodeEntities;\n    this.usedPipes = usedPipes;\n    this.eagerPipes = eagerPipes;\n    this.deferredBlocks = rawDeferred.map(current => current[0]);\n    this.deferredScopes = new Map(rawDeferred);\n  }\n  getEntitiesInScope(node) {\n    return this.scopedNodeEntities.get(node) ?? new Set();\n  }\n  getDirectivesOfNode(node) {\n    return this.directives.get(node) || null;\n  }\n  getReferenceTarget(ref) {\n    return this.references.get(ref) || null;\n  }\n  getConsumerOfBinding(binding) {\n    return this.bindings.get(binding) || null;\n  }\n  getExpressionTarget(expr) {\n    return this.exprTargets.get(expr) || null;\n  }\n  getDefinitionNodeOfSymbol(symbol) {\n    return this.symbols.get(symbol) || null;\n  }\n  getNestingLevel(node) {\n    return this.nestingLevel.get(node) || 0;\n  }\n  getUsedDirectives() {\n    const set = new Set();\n    this.directives.forEach(dirs => dirs.forEach(dir => set.add(dir)));\n    return Array.from(set.values());\n  }\n  getEagerlyUsedDirectives() {\n    const set = new Set(this.eagerDirectives);\n    return Array.from(set.values());\n  }\n  getUsedPipes() {\n    return Array.from(this.usedPipes);\n  }\n  getEagerlyUsedPipes() {\n    return Array.from(this.eagerPipes);\n  }\n  getDeferBlocks() {\n    return this.deferredBlocks;\n  }\n  getDeferredTriggerTarget(block, trigger) {\n    if (!(trigger instanceof InteractionDeferredTrigger) && !(trigger instanceof ViewportDeferredTrigger) && !(trigger instanceof HoverDeferredTrigger)) {\n      return null;\n    }\n    const name = trigger.reference;\n    if (name === null) {\n      let target = null;\n      if (block.placeholder !== null) {\n        for (const child of block.placeholder.children) {\n          if (child instanceof Comment$1) {\n            continue;\n          }\n          if (target !== null) {\n            return null;\n          }\n          if (child instanceof Element$1) {\n            target = child;\n          }\n        }\n      }\n      return target;\n    }\n    const outsideRef = this.findEntityInScope(block, name);\n    if (outsideRef instanceof Reference && this.getDefinitionNodeOfSymbol(outsideRef) !== block) {\n      const target = this.getReferenceTarget(outsideRef);\n      if (target !== null) {\n        return this.referenceTargetToElement(target);\n      }\n    }\n    if (block.placeholder !== null) {\n      const refInPlaceholder = this.findEntityInScope(block.placeholder, name);\n      const targetInPlaceholder = refInPlaceholder instanceof Reference ? this.getReferenceTarget(refInPlaceholder) : null;\n      if (targetInPlaceholder !== null) {\n        return this.referenceTargetToElement(targetInPlaceholder);\n      }\n    }\n    return null;\n  }\n  isDeferred(element) {\n    for (const block of this.deferredBlocks) {\n      if (!this.deferredScopes.has(block)) {\n        continue;\n      }\n      const stack = [this.deferredScopes.get(block)];\n      while (stack.length > 0) {\n        const current = stack.pop();\n        if (current.elementLikeInScope.has(element)) {\n          return true;\n        }\n        stack.push(...current.childScopes.values());\n      }\n    }\n    return false;\n  }\n  referencedDirectiveExists(name) {\n    return !this.missingDirectives.has(name);\n  }\n  findEntityInScope(rootNode, name) {\n    const entities = this.getEntitiesInScope(rootNode);\n    for (const entity of entities) {\n      if (entity.name === name) {\n        return entity;\n      }\n    }\n    return null;\n  }\n  referenceTargetToElement(target) {\n    if (target instanceof Element$1) {\n      return target;\n    }\n    if (target instanceof Template || target.node instanceof Component$1 || target.node instanceof Directive$1 || target.node instanceof HostElement) {\n      return null;\n    }\n    return this.referenceTargetToElement(target.node);\n  }\n}\nfunction extractScopedNodeEntities(rootScope, templateEntities) {\n  const entityMap = new Map();\n  function extractScopeEntities(scope) {\n    if (entityMap.has(scope.rootNode)) {\n      return entityMap.get(scope.rootNode);\n    }\n    const currentEntities = scope.namedEntities;\n    let entities;\n    if (scope.parentScope !== null) {\n      entities = new Map([...extractScopeEntities(scope.parentScope), ...currentEntities]);\n    } else {\n      entities = new Map(currentEntities);\n    }\n    entityMap.set(scope.rootNode, entities);\n    return entities;\n  }\n  const scopesToProcess = [rootScope];\n  while (scopesToProcess.length > 0) {\n    const scope = scopesToProcess.pop();\n    for (const childScope of scope.childScopes.values()) {\n      scopesToProcess.push(childScope);\n    }\n    extractScopeEntities(scope);\n  }\n  for (const [template, entities] of entityMap) {\n    templateEntities.set(template, new Set(entities.values()));\n  }\n}\n\nclass ResourceLoader {}\n\nclass CompilerFacadeImpl {\n  jitEvaluator;\n  FactoryTarget = FactoryTarget;\n  ResourceLoader = ResourceLoader;\n  elementSchemaRegistry = new DomElementSchemaRegistry();\n  constructor(jitEvaluator = new JitEvaluator()) {\n    this.jitEvaluator = jitEvaluator;\n  }\n  compilePipe(angularCoreEnv, sourceMapUrl, facade) {\n    const metadata = {\n      name: facade.name,\n      type: wrapReference(facade.type),\n      typeArgumentCount: 0,\n      deps: null,\n      pipeName: facade.pipeName,\n      pure: facade.pure,\n      isStandalone: facade.isStandalone\n    };\n    const res = compilePipeFromMetadata(metadata);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n  compilePipeDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n    const meta = convertDeclarePipeFacadeToMetadata(declaration);\n    const res = compilePipeFromMetadata(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n  compileInjectable(angularCoreEnv, sourceMapUrl, facade) {\n    const {\n      expression,\n      statements\n    } = compileInjectable({\n      name: facade.name,\n      type: wrapReference(facade.type),\n      typeArgumentCount: facade.typeArgumentCount,\n      providedIn: computeProvidedIn(facade.providedIn),\n      useClass: convertToProviderExpression(facade, 'useClass'),\n      useFactory: wrapExpression(facade, 'useFactory'),\n      useValue: convertToProviderExpression(facade, 'useValue'),\n      useExisting: convertToProviderExpression(facade, 'useExisting'),\n      deps: facade.deps?.map(convertR3DependencyMetadata)\n    }, true);\n    return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n  }\n  compileInjectableDeclaration(angularCoreEnv, sourceMapUrl, facade) {\n    const {\n      expression,\n      statements\n    } = compileInjectable({\n      name: facade.type.name,\n      type: wrapReference(facade.type),\n      typeArgumentCount: 0,\n      providedIn: computeProvidedIn(facade.providedIn),\n      useClass: convertToProviderExpression(facade, 'useClass'),\n      useFactory: wrapExpression(facade, 'useFactory'),\n      useValue: convertToProviderExpression(facade, 'useValue'),\n      useExisting: convertToProviderExpression(facade, 'useExisting'),\n      deps: facade.deps?.map(convertR3DeclareDependencyMetadata)\n    }, true);\n    return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n  }\n  compileInjector(angularCoreEnv, sourceMapUrl, facade) {\n    const meta = {\n      name: facade.name,\n      type: wrapReference(facade.type),\n      providers: facade.providers && facade.providers.length > 0 ? new WrappedNodeExpr(facade.providers) : null,\n      imports: facade.imports.map(i => new WrappedNodeExpr(i))\n    };\n    const res = compileInjector(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n  compileInjectorDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n    const meta = convertDeclareInjectorFacadeToMetadata(declaration);\n    const res = compileInjector(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n  compileNgModule(angularCoreEnv, sourceMapUrl, facade) {\n    const meta = {\n      kind: R3NgModuleMetadataKind.Global,\n      type: wrapReference(facade.type),\n      bootstrap: facade.bootstrap.map(wrapReference),\n      declarations: facade.declarations.map(wrapReference),\n      publicDeclarationTypes: null,\n      imports: facade.imports.map(wrapReference),\n      includeImportTypes: true,\n      exports: facade.exports.map(wrapReference),\n      selectorScopeMode: R3SelectorScopeMode.Inline,\n      containsForwardDecls: false,\n      schemas: facade.schemas ? facade.schemas.map(wrapReference) : null,\n      id: facade.id ? new WrappedNodeExpr(facade.id) : null\n    };\n    const res = compileNgModule(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n  compileNgModuleDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n    const expression = compileNgModuleDeclarationExpression(declaration);\n    return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, []);\n  }\n  compileDirective(angularCoreEnv, sourceMapUrl, facade) {\n    const meta = convertDirectiveFacadeToMetadata(facade);\n    return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n  }\n  compileDirectiveDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n    const typeSourceSpan = this.createParseSourceSpan('Directive', declaration.type.name, sourceMapUrl);\n    const meta = convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan);\n    return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n  }\n  compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta) {\n    const constantPool = new ConstantPool();\n    const bindingParser = makeBindingParser();\n    const res = compileDirectiveFromMetadata(meta, constantPool, bindingParser);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n  }\n  compileComponent(angularCoreEnv, sourceMapUrl, facade) {\n    const {\n      template,\n      defer\n    } = parseJitTemplate(facade.template, facade.name, sourceMapUrl, facade.preserveWhitespaces, undefined);\n    const meta = {\n      ...facade,\n      ...convertDirectiveFacadeToMetadata(facade),\n      selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(),\n      template,\n      declarations: facade.declarations.map(convertDeclarationFacadeToMetadata),\n      declarationListEmitMode: 0,\n      defer,\n      styles: [...facade.styles, ...template.styles],\n      encapsulation: facade.encapsulation,\n      changeDetection: facade.changeDetection ?? null,\n      animations: facade.animations != null ? new WrappedNodeExpr(facade.animations) : null,\n      viewProviders: facade.viewProviders != null ? new WrappedNodeExpr(facade.viewProviders) : null,\n      relativeContextFilePath: '',\n      i18nUseExternalIds: true,\n      relativeTemplatePath: null\n    };\n    const jitExpressionSourceMap = `ng:///${facade.name}.js`;\n    return this.compileComponentFromMeta(angularCoreEnv, jitExpressionSourceMap, meta);\n  }\n  compileComponentDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n    const typeSourceSpan = this.createParseSourceSpan('Component', declaration.type.name, sourceMapUrl);\n    const meta = convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl);\n    return this.compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta);\n  }\n  compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta) {\n    const constantPool = new ConstantPool();\n    const bindingParser = makeBindingParser();\n    const res = compileComponentFromMetadata(meta, constantPool, bindingParser);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n  }\n  compileFactory(angularCoreEnv, sourceMapUrl, meta) {\n    const factoryRes = compileFactoryFunction({\n      name: meta.name,\n      type: wrapReference(meta.type),\n      typeArgumentCount: meta.typeArgumentCount,\n      deps: convertR3DependencyMetadataArray(meta.deps),\n      target: meta.target\n    });\n    return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);\n  }\n  compileFactoryDeclaration(angularCoreEnv, sourceMapUrl, meta) {\n    const factoryRes = compileFactoryFunction({\n      name: meta.type.name,\n      type: wrapReference(meta.type),\n      typeArgumentCount: 0,\n      deps: Array.isArray(meta.deps) ? meta.deps.map(convertR3DeclareDependencyMetadata) : meta.deps,\n      target: meta.target\n    });\n    return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);\n  }\n  createParseSourceSpan(kind, typeName, sourceUrl) {\n    return r3JitTypeSourceSpan(kind, typeName, sourceUrl);\n  }\n  jitExpression(def, context, sourceUrl, preStatements) {\n    const statements = [...preStatements, new DeclareVarStmt('$def', def, undefined, StmtModifier.Exported)];\n    const res = this.jitEvaluator.evaluateStatements(sourceUrl, statements, new R3JitReflector(context), true);\n    return res['$def'];\n  }\n}\nfunction convertToR3QueryMetadata(facade) {\n  return {\n    ...facade,\n    isSignal: facade.isSignal,\n    predicate: convertQueryPredicate(facade.predicate),\n    read: facade.read ? new WrappedNodeExpr(facade.read) : null,\n    static: facade.static,\n    emitDistinctChangesOnly: facade.emitDistinctChangesOnly\n  };\n}\nfunction convertQueryDeclarationToMetadata(declaration) {\n  return {\n    propertyName: declaration.propertyName,\n    first: declaration.first ?? false,\n    predicate: convertQueryPredicate(declaration.predicate),\n    descendants: declaration.descendants ?? false,\n    read: declaration.read ? new WrappedNodeExpr(declaration.read) : null,\n    static: declaration.static ?? false,\n    emitDistinctChangesOnly: declaration.emitDistinctChangesOnly ?? true,\n    isSignal: !!declaration.isSignal\n  };\n}\nfunction convertQueryPredicate(predicate) {\n  return Array.isArray(predicate) ? predicate : createMayBeForwardRefExpression(new WrappedNodeExpr(predicate), 1);\n}\nfunction convertDirectiveFacadeToMetadata(facade) {\n  const inputsFromMetadata = parseInputsArray(facade.inputs || []);\n  const outputsFromMetadata = parseMappingStringArray(facade.outputs || []);\n  const propMetadata = facade.propMetadata;\n  const inputsFromType = {};\n  const outputsFromType = {};\n  for (const field in propMetadata) {\n    if (propMetadata.hasOwnProperty(field)) {\n      propMetadata[field].forEach(ann => {\n        if (isInput(ann)) {\n          inputsFromType[field] = {\n            bindingPropertyName: ann.alias || field,\n            classPropertyName: field,\n            required: ann.required || false,\n            isSignal: !!ann.isSignal,\n            transformFunction: ann.transform != null ? new WrappedNodeExpr(ann.transform) : null\n          };\n        } else if (isOutput(ann)) {\n          outputsFromType[field] = ann.alias || field;\n        }\n      });\n    }\n  }\n  const hostDirectives = facade.hostDirectives?.length ? facade.hostDirectives.map(hostDirective => {\n    return typeof hostDirective === 'function' ? {\n      directive: wrapReference(hostDirective),\n      inputs: null,\n      outputs: null,\n      isForwardReference: false\n    } : {\n      directive: wrapReference(hostDirective.directive),\n      isForwardReference: false,\n      inputs: hostDirective.inputs ? parseMappingStringArray(hostDirective.inputs) : null,\n      outputs: hostDirective.outputs ? parseMappingStringArray(hostDirective.outputs) : null\n    };\n  }) : null;\n  return {\n    ...facade,\n    typeArgumentCount: 0,\n    typeSourceSpan: facade.typeSourceSpan,\n    type: wrapReference(facade.type),\n    deps: null,\n    host: {\n      ...extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host)\n    },\n    inputs: {\n      ...inputsFromMetadata,\n      ...inputsFromType\n    },\n    outputs: {\n      ...outputsFromMetadata,\n      ...outputsFromType\n    },\n    queries: facade.queries.map(convertToR3QueryMetadata),\n    providers: facade.providers != null ? new WrappedNodeExpr(facade.providers) : null,\n    viewQueries: facade.viewQueries.map(convertToR3QueryMetadata),\n    hostDirectives\n  };\n}\nfunction convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan) {\n  const hostDirectives = declaration.hostDirectives?.length ? declaration.hostDirectives.map(dir => ({\n    directive: wrapReference(dir.directive),\n    isForwardReference: false,\n    inputs: dir.inputs ? getHostDirectiveBindingMapping(dir.inputs) : null,\n    outputs: dir.outputs ? getHostDirectiveBindingMapping(dir.outputs) : null\n  })) : null;\n  return {\n    name: declaration.type.name,\n    type: wrapReference(declaration.type),\n    typeSourceSpan,\n    selector: declaration.selector ?? null,\n    inputs: declaration.inputs ? inputsPartialMetadataToInputMetadata(declaration.inputs) : {},\n    outputs: declaration.outputs ?? {},\n    host: convertHostDeclarationToMetadata(declaration.host),\n    queries: (declaration.queries ?? []).map(convertQueryDeclarationToMetadata),\n    viewQueries: (declaration.viewQueries ?? []).map(convertQueryDeclarationToMetadata),\n    providers: declaration.providers !== undefined ? new WrappedNodeExpr(declaration.providers) : null,\n    exportAs: declaration.exportAs ?? null,\n    usesInheritance: declaration.usesInheritance ?? false,\n    lifecycle: {\n      usesOnChanges: declaration.usesOnChanges ?? false\n    },\n    deps: null,\n    typeArgumentCount: 0,\n    isStandalone: declaration.isStandalone ?? getJitStandaloneDefaultForVersion(declaration.version),\n    isSignal: declaration.isSignal ?? false,\n    hostDirectives\n  };\n}\nfunction convertHostDeclarationToMetadata(host = {}) {\n  return {\n    attributes: convertOpaqueValuesToExpressions(host.attributes ?? {}),\n    listeners: host.listeners ?? {},\n    properties: host.properties ?? {},\n    specialAttributes: {\n      classAttr: host.classAttribute,\n      styleAttr: host.styleAttribute\n    }\n  };\n}\nfunction getHostDirectiveBindingMapping(array) {\n  let result = null;\n  for (let i = 1; i < array.length; i += 2) {\n    result = result || {};\n    result[array[i - 1]] = array[i];\n  }\n  return result;\n}\nfunction convertOpaqueValuesToExpressions(obj) {\n  const result = {};\n  for (const key of Object.keys(obj)) {\n    result[key] = new WrappedNodeExpr(obj[key]);\n  }\n  return result;\n}\nfunction convertDeclareComponentFacadeToMetadata(decl, typeSourceSpan, sourceMapUrl) {\n  const {\n    template,\n    defer\n  } = parseJitTemplate(decl.template, decl.type.name, sourceMapUrl, decl.preserveWhitespaces ?? false, decl.deferBlockDependencies);\n  const declarations = [];\n  if (decl.dependencies) {\n    for (const innerDep of decl.dependencies) {\n      switch (innerDep.kind) {\n        case 'directive':\n        case 'component':\n          declarations.push(convertDirectiveDeclarationToMetadata(innerDep));\n          break;\n        case 'pipe':\n          declarations.push(convertPipeDeclarationToMetadata(innerDep));\n          break;\n      }\n    }\n  } else if (decl.components || decl.directives || decl.pipes) {\n    decl.components && declarations.push(...decl.components.map(dir => convertDirectiveDeclarationToMetadata(dir, true)));\n    decl.directives && declarations.push(...decl.directives.map(dir => convertDirectiveDeclarationToMetadata(dir)));\n    decl.pipes && declarations.push(...convertPipeMapToMetadata(decl.pipes));\n  }\n  const hasDirectiveDependencies = declarations.some(({\n    kind\n  }) => kind === R3TemplateDependencyKind.Directive || kind === R3TemplateDependencyKind.NgModule);\n  return {\n    ...convertDeclareDirectiveFacadeToMetadata(decl, typeSourceSpan),\n    template,\n    styles: decl.styles ?? [],\n    declarations,\n    viewProviders: decl.viewProviders !== undefined ? new WrappedNodeExpr(decl.viewProviders) : null,\n    animations: decl.animations !== undefined ? new WrappedNodeExpr(decl.animations) : null,\n    defer,\n    changeDetection: decl.changeDetection ?? ChangeDetectionStrategy.Default,\n    encapsulation: decl.encapsulation ?? ViewEncapsulation$1.Emulated,\n    declarationListEmitMode: 2,\n    relativeContextFilePath: '',\n    i18nUseExternalIds: true,\n    relativeTemplatePath: null,\n    hasDirectiveDependencies\n  };\n}\nfunction convertDeclarationFacadeToMetadata(declaration) {\n  return {\n    ...declaration,\n    type: new WrappedNodeExpr(declaration.type)\n  };\n}\nfunction convertDirectiveDeclarationToMetadata(declaration, isComponent = null) {\n  return {\n    kind: R3TemplateDependencyKind.Directive,\n    isComponent: isComponent || declaration.kind === 'component',\n    selector: declaration.selector,\n    type: new WrappedNodeExpr(declaration.type),\n    inputs: declaration.inputs ?? [],\n    outputs: declaration.outputs ?? [],\n    exportAs: declaration.exportAs ?? null\n  };\n}\nfunction convertPipeMapToMetadata(pipes) {\n  if (!pipes) {\n    return [];\n  }\n  return Object.keys(pipes).map(name => {\n    return {\n      kind: R3TemplateDependencyKind.Pipe,\n      name,\n      type: new WrappedNodeExpr(pipes[name])\n    };\n  });\n}\nfunction convertPipeDeclarationToMetadata(pipe) {\n  return {\n    kind: R3TemplateDependencyKind.Pipe,\n    name: pipe.name,\n    type: new WrappedNodeExpr(pipe.type)\n  };\n}\nfunction parseJitTemplate(template, typeName, sourceMapUrl, preserveWhitespaces, deferBlockDependencies) {\n  const parsed = parseTemplate(template, sourceMapUrl, {\n    preserveWhitespaces\n  });\n  if (parsed.errors !== null) {\n    const errors = parsed.errors.map(err => err.toString()).join(', ');\n    throw new Error(`Errors during JIT compilation of template for ${typeName}: ${errors}`);\n  }\n  const binder = new R3TargetBinder(null);\n  const boundTarget = binder.bind({\n    template: parsed.nodes\n  });\n  return {\n    template: parsed,\n    defer: createR3ComponentDeferMetadata(boundTarget, deferBlockDependencies)\n  };\n}\nfunction convertToProviderExpression(obj, property) {\n  if (obj.hasOwnProperty(property)) {\n    return createMayBeForwardRefExpression(new WrappedNodeExpr(obj[property]), 0);\n  } else {\n    return undefined;\n  }\n}\nfunction wrapExpression(obj, property) {\n  if (obj.hasOwnProperty(property)) {\n    return new WrappedNodeExpr(obj[property]);\n  } else {\n    return undefined;\n  }\n}\nfunction computeProvidedIn(providedIn) {\n  const expression = typeof providedIn === 'function' ? new WrappedNodeExpr(providedIn) : new LiteralExpr(providedIn ?? null);\n  return createMayBeForwardRefExpression(expression, 0);\n}\nfunction convertR3DependencyMetadataArray(facades) {\n  return facades == null ? null : facades.map(convertR3DependencyMetadata);\n}\nfunction convertR3DependencyMetadata(facade) {\n  const isAttributeDep = facade.attribute != null;\n  const rawToken = facade.token === null ? null : new WrappedNodeExpr(facade.token);\n  const token = isAttributeDep ? new WrappedNodeExpr(facade.attribute) : rawToken;\n  return createR3DependencyMetadata(token, isAttributeDep, facade.host, facade.optional, facade.self, facade.skipSelf);\n}\nfunction convertR3DeclareDependencyMetadata(facade) {\n  const isAttributeDep = facade.attribute ?? false;\n  const token = facade.token === null ? null : new WrappedNodeExpr(facade.token);\n  return createR3DependencyMetadata(token, isAttributeDep, facade.host ?? false, facade.optional ?? false, facade.self ?? false, facade.skipSelf ?? false);\n}\nfunction createR3DependencyMetadata(token, isAttributeDep, host, optional, self, skipSelf) {\n  const attributeNameType = isAttributeDep ? literal('unknown') : null;\n  return {\n    token,\n    attributeNameType,\n    host,\n    optional,\n    self,\n    skipSelf\n  };\n}\nfunction createR3ComponentDeferMetadata(boundTarget, deferBlockDependencies) {\n  const deferredBlocks = boundTarget.getDeferBlocks();\n  const blocks = new Map();\n  for (let i = 0; i < deferredBlocks.length; i++) {\n    const dependencyFn = deferBlockDependencies?.[i];\n    blocks.set(deferredBlocks[i], dependencyFn ? new WrappedNodeExpr(dependencyFn) : null);\n  }\n  return {\n    mode: 0,\n    blocks\n  };\n}\nfunction extractHostBindings(propMetadata, sourceSpan, host) {\n  const bindings = parseHostBindings(host || {});\n  const errors = verifyHostBindings(bindings, sourceSpan);\n  if (errors.length) {\n    throw new Error(errors.map(error => error.msg).join('\\n'));\n  }\n  for (const field in propMetadata) {\n    if (propMetadata.hasOwnProperty(field)) {\n      propMetadata[field].forEach(ann => {\n        if (isHostBinding(ann)) {\n          bindings.properties[ann.hostPropertyName || field] = getSafePropertyAccessString('this', field);\n        } else if (isHostListener(ann)) {\n          bindings.listeners[ann.eventName || field] = `${field}(${(ann.args || []).join(',')})`;\n        }\n      });\n    }\n  }\n  return bindings;\n}\nfunction isHostBinding(value) {\n  return value.ngMetadataName === 'HostBinding';\n}\nfunction isHostListener(value) {\n  return value.ngMetadataName === 'HostListener';\n}\nfunction isInput(value) {\n  return value.ngMetadataName === 'Input';\n}\nfunction isOutput(value) {\n  return value.ngMetadataName === 'Output';\n}\nfunction inputsPartialMetadataToInputMetadata(inputs) {\n  return Object.keys(inputs).reduce((result, minifiedClassName) => {\n    const value = inputs[minifiedClassName];\n    if (typeof value === 'string' || Array.isArray(value)) {\n      result[minifiedClassName] = parseLegacyInputPartialOutput(value);\n    } else {\n      result[minifiedClassName] = {\n        bindingPropertyName: value.publicName,\n        classPropertyName: minifiedClassName,\n        transformFunction: value.transformFunction !== null ? new WrappedNodeExpr(value.transformFunction) : null,\n        required: value.isRequired,\n        isSignal: value.isSignal\n      };\n    }\n    return result;\n  }, {});\n}\nfunction parseLegacyInputPartialOutput(value) {\n  if (typeof value === 'string') {\n    return {\n      bindingPropertyName: value,\n      classPropertyName: value,\n      transformFunction: null,\n      required: false,\n      isSignal: false\n    };\n  }\n  return {\n    bindingPropertyName: value[0],\n    classPropertyName: value[1],\n    transformFunction: value[2] ? new WrappedNodeExpr(value[2]) : null,\n    required: false,\n    isSignal: false\n  };\n}\nfunction parseInputsArray(values) {\n  return values.reduce((results, value) => {\n    if (typeof value === 'string') {\n      const [bindingPropertyName, classPropertyName] = parseMappingString(value);\n      results[classPropertyName] = {\n        bindingPropertyName,\n        classPropertyName,\n        required: false,\n        isSignal: false,\n        transformFunction: null\n      };\n    } else {\n      results[value.name] = {\n        bindingPropertyName: value.alias || value.name,\n        classPropertyName: value.name,\n        required: value.required || false,\n        isSignal: false,\n        transformFunction: value.transform != null ? new WrappedNodeExpr(value.transform) : null\n      };\n    }\n    return results;\n  }, {});\n}\nfunction parseMappingStringArray(values) {\n  return values.reduce((results, value) => {\n    const [alias, fieldName] = parseMappingString(value);\n    results[fieldName] = alias;\n    return results;\n  }, {});\n}\nfunction parseMappingString(value) {\n  const [fieldName, bindingPropertyName] = value.split(':', 2).map(str => str.trim());\n  return [bindingPropertyName ?? fieldName, fieldName];\n}\nfunction convertDeclarePipeFacadeToMetadata(declaration) {\n  return {\n    name: declaration.type.name,\n    type: wrapReference(declaration.type),\n    typeArgumentCount: 0,\n    pipeName: declaration.name,\n    deps: null,\n    pure: declaration.pure ?? true,\n    isStandalone: declaration.isStandalone ?? getJitStandaloneDefaultForVersion(declaration.version)\n  };\n}\nfunction convertDeclareInjectorFacadeToMetadata(declaration) {\n  return {\n    name: declaration.type.name,\n    type: wrapReference(declaration.type),\n    providers: declaration.providers !== undefined && declaration.providers.length > 0 ? new WrappedNodeExpr(declaration.providers) : null,\n    imports: declaration.imports !== undefined ? declaration.imports.map(i => new WrappedNodeExpr(i)) : []\n  };\n}\nfunction publishFacade(global) {\n  const ng = global.ng || (global.ng = {});\n  ng.ÉµcompilerFacade = new CompilerFacadeImpl();\n}\n\nclass CompilerConfig {\n  defaultEncapsulation;\n  preserveWhitespaces;\n  strictInjectionParameters;\n  constructor({\n    defaultEncapsulation = ViewEncapsulation$1.Emulated,\n    preserveWhitespaces,\n    strictInjectionParameters\n  } = {}) {\n    this.defaultEncapsulation = defaultEncapsulation;\n    this.preserveWhitespaces = preserveWhitespacesDefault(noUndefined(preserveWhitespaces));\n    this.strictInjectionParameters = strictInjectionParameters === true;\n  }\n}\nfunction preserveWhitespacesDefault(preserveWhitespacesOption, defaultSetting = false) {\n  return preserveWhitespacesOption === null ? defaultSetting : preserveWhitespacesOption;\n}\n\nconst _I18N_ATTR = 'i18n';\nconst _I18N_ATTR_PREFIX = 'i18n-';\nconst _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;\nconst MEANING_SEPARATOR = '|';\nconst ID_SEPARATOR = '@@';\nlet i18nCommentsWarned = false;\nfunction extractMessages(nodes, implicitTags, implicitAttrs, preserveSignificantWhitespace) {\n  const visitor = new _Visitor(implicitTags, implicitAttrs, preserveSignificantWhitespace);\n  return visitor.extract(nodes);\n}\nfunction mergeTranslations(nodes, translations, implicitTags, implicitAttrs) {\n  const visitor = new _Visitor(implicitTags, implicitAttrs);\n  return visitor.merge(nodes, translations);\n}\nclass ExtractionResult {\n  messages;\n  errors;\n  constructor(messages, errors) {\n    this.messages = messages;\n    this.errors = errors;\n  }\n}\nvar _VisitorMode;\n(function (_VisitorMode) {\n  _VisitorMode[_VisitorMode[\"Extract\"] = 0] = \"Extract\";\n  _VisitorMode[_VisitorMode[\"Merge\"] = 1] = \"Merge\";\n})(_VisitorMode || (_VisitorMode = {}));\nclass _Visitor {\n  _implicitTags;\n  _implicitAttrs;\n  _preserveSignificantWhitespace;\n  _depth;\n  _inI18nNode;\n  _inImplicitNode;\n  _inI18nBlock;\n  _blockMeaningAndDesc;\n  _blockChildren;\n  _blockStartDepth;\n  _inIcu;\n  _msgCountAtSectionStart;\n  _errors;\n  _mode;\n  _messages;\n  _translations;\n  _createI18nMessage;\n  constructor(_implicitTags, _implicitAttrs, _preserveSignificantWhitespace = true) {\n    this._implicitTags = _implicitTags;\n    this._implicitAttrs = _implicitAttrs;\n    this._preserveSignificantWhitespace = _preserveSignificantWhitespace;\n  }\n  extract(nodes) {\n    this._init(_VisitorMode.Extract);\n    nodes.forEach(node => node.visit(this, null));\n    if (this._inI18nBlock) {\n      this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n    }\n    return new ExtractionResult(this._messages, this._errors);\n  }\n  merge(nodes, translations) {\n    this._init(_VisitorMode.Merge);\n    this._translations = translations;\n    const wrapper = new Element('wrapper', [], [], nodes, false, undefined, undefined, undefined, false);\n    const translatedNode = wrapper.visit(this, null);\n    if (this._inI18nBlock) {\n      this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n    }\n    return new ParseTreeResult(translatedNode.children, this._errors);\n  }\n  visitExpansionCase(icuCase, context) {\n    const expression = visitAll(this, icuCase.expression, context);\n    if (this._mode === _VisitorMode.Merge) {\n      return new ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);\n    }\n  }\n  visitExpansion(icu, context) {\n    this._mayBeAddBlockChildren(icu);\n    const wasInIcu = this._inIcu;\n    if (!this._inIcu) {\n      if (this._isInTranslatableSection) {\n        this._addMessage([icu]);\n      }\n      this._inIcu = true;\n    }\n    const cases = visitAll(this, icu.cases, context);\n    if (this._mode === _VisitorMode.Merge) {\n      icu = new Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);\n    }\n    this._inIcu = wasInIcu;\n    return icu;\n  }\n  visitComment(comment, context) {\n    const isOpening = _isOpeningComment(comment);\n    if (isOpening && this._isInTranslatableSection) {\n      this._reportError(comment, 'Could not start a block inside a translatable section');\n      return;\n    }\n    const isClosing = _isClosingComment(comment);\n    if (isClosing && !this._inI18nBlock) {\n      this._reportError(comment, 'Trying to close an unopened block');\n      return;\n    }\n    if (!this._inI18nNode && !this._inIcu) {\n      if (!this._inI18nBlock) {\n        if (isOpening) {\n          if (!i18nCommentsWarned && console && console.warn) {\n            i18nCommentsWarned = true;\n            const details = comment.sourceSpan.details ? `, ${comment.sourceSpan.details}` : '';\n            console.warn(`I18n comments are deprecated, use an <ng-container> element instead (${comment.sourceSpan.start}${details})`);\n          }\n          this._inI18nBlock = true;\n          this._blockStartDepth = this._depth;\n          this._blockChildren = [];\n          this._blockMeaningAndDesc = comment.value.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();\n          this._openTranslatableSection(comment);\n        }\n      } else {\n        if (isClosing) {\n          if (this._depth == this._blockStartDepth) {\n            this._closeTranslatableSection(comment, this._blockChildren);\n            this._inI18nBlock = false;\n            const message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc);\n            const nodes = this._translateMessage(comment, message);\n            return visitAll(this, nodes);\n          } else {\n            this._reportError(comment, 'I18N blocks should not cross element boundaries');\n            return;\n          }\n        }\n      }\n    }\n  }\n  visitText(text, context) {\n    if (this._isInTranslatableSection) {\n      this._mayBeAddBlockChildren(text);\n    }\n    return text;\n  }\n  visitElement(el, context) {\n    return this._visitElementLike(el, context);\n  }\n  visitAttribute(attribute, context) {\n    throw new Error('unreachable code');\n  }\n  visitBlock(block, context) {\n    visitAll(this, block.children, context);\n  }\n  visitBlockParameter(parameter, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {\n    return this._visitElementLike(component, context);\n  }\n  visitDirective(directive, context) {\n    throw new Error('unreachable code');\n  }\n  _init(mode) {\n    this._mode = mode;\n    this._inI18nBlock = false;\n    this._inI18nNode = false;\n    this._depth = 0;\n    this._inIcu = false;\n    this._msgCountAtSectionStart = undefined;\n    this._errors = [];\n    this._messages = [];\n    this._inImplicitNode = false;\n    this._createI18nMessage = createI18nMessageFactory(DEFAULT_CONTAINER_BLOCKS, !this._preserveSignificantWhitespace, this._preserveSignificantWhitespace);\n  }\n  _visitElementLike(node, context) {\n    this._mayBeAddBlockChildren(node);\n    this._depth++;\n    const wasInI18nNode = this._inI18nNode;\n    const wasInImplicitNode = this._inImplicitNode;\n    let childNodes = [];\n    let translatedChildNodes = undefined;\n    const nodeName = node instanceof Component ? node.tagName : node.name;\n    const i18nAttr = _getI18nAttr(node);\n    const i18nMeta = i18nAttr ? i18nAttr.value : '';\n    const isImplicit = this._implicitTags.some(tag => nodeName === tag) && !this._inIcu && !this._isInTranslatableSection;\n    const isTopLevelImplicit = !wasInImplicitNode && isImplicit;\n    this._inImplicitNode = wasInImplicitNode || isImplicit;\n    if (!this._isInTranslatableSection && !this._inIcu) {\n      if (i18nAttr || isTopLevelImplicit) {\n        this._inI18nNode = true;\n        const message = this._addMessage(node.children, i18nMeta);\n        translatedChildNodes = this._translateMessage(node, message);\n      }\n      if (this._mode == _VisitorMode.Extract) {\n        const isTranslatable = i18nAttr || isTopLevelImplicit;\n        if (isTranslatable) this._openTranslatableSection(node);\n        visitAll(this, node.children);\n        if (isTranslatable) this._closeTranslatableSection(node, node.children);\n      }\n    } else {\n      if (i18nAttr || isTopLevelImplicit) {\n        this._reportError(node, 'Could not mark an element as translatable inside a translatable section');\n      }\n      if (this._mode == _VisitorMode.Extract) {\n        visitAll(this, node.children);\n      }\n    }\n    if (this._mode === _VisitorMode.Merge) {\n      const visitNodes = translatedChildNodes || node.children;\n      visitNodes.forEach(child => {\n        const visited = child.visit(this, context);\n        if (visited && !this._isInTranslatableSection) {\n          childNodes = childNodes.concat(visited);\n        }\n      });\n    }\n    this._visitAttributesOf(node);\n    this._depth--;\n    this._inI18nNode = wasInI18nNode;\n    this._inImplicitNode = wasInImplicitNode;\n    if (this._mode === _VisitorMode.Merge) {\n      if (node instanceof Element) {\n        return new Element(node.name, this._translateAttributes(node), this._translateDirectives(node), childNodes, node.isSelfClosing, node.sourceSpan, node.startSourceSpan, node.endSourceSpan, node.isVoid);\n      } else {\n        return new Component(node.componentName, node.tagName, node.fullName, this._translateAttributes(node), this._translateDirectives(node), childNodes, node.isSelfClosing, node.sourceSpan, node.startSourceSpan, node.endSourceSpan);\n      }\n    }\n    return null;\n  }\n  _visitAttributesOf(el) {\n    const explicitAttrNameToValue = {};\n    const implicitAttrNames = this._implicitAttrs[el instanceof Component ? el.tagName || '' : el.name] || [];\n    el.attrs.filter(attr => attr instanceof Attribute && attr.name.startsWith(_I18N_ATTR_PREFIX)).forEach(attr => {\n      explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] = attr.value;\n    });\n    el.attrs.forEach(attr => {\n      if (attr.name in explicitAttrNameToValue) {\n        this._addMessage([attr], explicitAttrNameToValue[attr.name]);\n      } else if (implicitAttrNames.some(name => attr.name === name)) {\n        this._addMessage([attr]);\n      }\n    });\n  }\n  _addMessage(ast, msgMeta) {\n    if (ast.length == 0 || this._isEmptyAttributeValue(ast) || this._isPlaceholderOnlyAttributeValue(ast) || this._isPlaceholderOnlyMessage(ast)) {\n      return null;\n    }\n    const {\n      meaning,\n      description,\n      id\n    } = _parseMessageMeta(msgMeta);\n    const message = this._createI18nMessage(ast, meaning, description, id);\n    this._messages.push(message);\n    return message;\n  }\n  _isEmptyAttributeValue(ast) {\n    if (!isAttrNode(ast)) return false;\n    const node = ast[0];\n    return node.value.trim() === '';\n  }\n  _isPlaceholderOnlyAttributeValue(ast) {\n    if (!isAttrNode(ast)) return false;\n    const tokens = ast[0].valueTokens ?? [];\n    const interpolations = tokens.filter(token => token.type === 17);\n    const plainText = tokens.filter(token => token.type === 16).map(token => token.parts[0].trim()).join('');\n    return interpolations.length === 1 && plainText === '';\n  }\n  _isPlaceholderOnlyMessage(ast) {\n    if (!isTextNode(ast)) return false;\n    const tokens = ast[0].tokens;\n    const interpolations = tokens.filter(token => token.type === 8);\n    const plainText = tokens.filter(token => token.type === 5).map(token => token.parts[0].trim()).join('');\n    return interpolations.length === 1 && plainText === '';\n  }\n  _translateMessage(el, message) {\n    if (message && this._mode === _VisitorMode.Merge) {\n      const nodes = this._translations.get(message);\n      if (nodes) {\n        return nodes;\n      }\n      this._reportError(el, `Translation unavailable for message id=\"${this._translations.digest(message)}\"`);\n    }\n    return [];\n  }\n  _translateAttributes(node) {\n    const i18nParsedMessageMeta = {};\n    const translatedAttributes = [];\n    node.attrs.forEach(attr => {\n      if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n        i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] = _parseMessageMeta(attr.value);\n      }\n    });\n    node.attrs.forEach(attr => {\n      if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n        return;\n      }\n      if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {\n        const {\n          meaning,\n          description,\n          id\n        } = i18nParsedMessageMeta[attr.name];\n        const message = this._createI18nMessage([attr], meaning, description, id);\n        const nodes = this._translations.get(message);\n        if (nodes) {\n          if (nodes.length == 0) {\n            translatedAttributes.push(new Attribute(attr.name, '', attr.sourceSpan, undefined, undefined, undefined, undefined));\n          } else if (nodes[0] instanceof Text) {\n            const value = nodes[0].value;\n            translatedAttributes.push(new Attribute(attr.name, value, attr.sourceSpan, undefined, undefined, undefined, undefined));\n          } else {\n            this._reportError(node, `Unexpected translation for attribute \"${attr.name}\" (id=\"${id || this._translations.digest(message)}\")`);\n          }\n        } else {\n          this._reportError(node, `Translation unavailable for attribute \"${attr.name}\" (id=\"${id || this._translations.digest(message)}\")`);\n        }\n      } else {\n        translatedAttributes.push(attr);\n      }\n    });\n    return translatedAttributes;\n  }\n  _translateDirectives(node) {\n    return node.directives.map(dir => new Directive(dir.name, this._translateAttributes(dir), dir.sourceSpan, dir.startSourceSpan, dir.endSourceSpan));\n  }\n  _mayBeAddBlockChildren(node) {\n    if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {\n      this._blockChildren.push(node);\n    }\n  }\n  _openTranslatableSection(node) {\n    if (this._isInTranslatableSection) {\n      this._reportError(node, 'Unexpected section start');\n    } else {\n      this._msgCountAtSectionStart = this._messages.length;\n    }\n  }\n  get _isInTranslatableSection() {\n    return this._msgCountAtSectionStart !== void 0;\n  }\n  _closeTranslatableSection(node, directChildren) {\n    if (!this._isInTranslatableSection) {\n      this._reportError(node, 'Unexpected section end');\n      return;\n    }\n    const startIndex = this._msgCountAtSectionStart;\n    const significantChildren = directChildren.reduce((count, node) => count + (node instanceof Comment ? 0 : 1), 0);\n    if (significantChildren == 1) {\n      for (let i = this._messages.length - 1; i >= startIndex; i--) {\n        const ast = this._messages[i].nodes;\n        if (!(ast.length == 1 && ast[0] instanceof Text$2)) {\n          this._messages.splice(i, 1);\n          break;\n        }\n      }\n    }\n    this._msgCountAtSectionStart = undefined;\n  }\n  _reportError(node, msg) {\n    this._errors.push(new ParseError(node.sourceSpan, msg));\n  }\n}\nfunction _isOpeningComment(n) {\n  return !!(n instanceof Comment && n.value && n.value.startsWith('i18n'));\n}\nfunction _isClosingComment(n) {\n  return !!(n instanceof Comment && n.value && n.value === '/i18n');\n}\nfunction _getI18nAttr(p) {\n  return p.attrs.find(attr => attr instanceof Attribute && attr.name === _I18N_ATTR) || null;\n}\nfunction _parseMessageMeta(i18n) {\n  if (!i18n) return {\n    meaning: '',\n    description: '',\n    id: ''\n  };\n  const idIndex = i18n.indexOf(ID_SEPARATOR);\n  const descIndex = i18n.indexOf(MEANING_SEPARATOR);\n  const [meaningAndDesc, id] = idIndex > -1 ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''];\n  const [meaning, description] = descIndex > -1 ? [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] : ['', meaningAndDesc];\n  return {\n    meaning,\n    description,\n    id: id.trim()\n  };\n}\nfunction isTextNode(ast) {\n  return ast.length === 1 && ast[0] instanceof Text;\n}\nfunction isAttrNode(ast) {\n  return ast.length === 1 && ast[0] instanceof Attribute;\n}\n\nclass XmlTagDefinition {\n  closedByParent = false;\n  implicitNamespacePrefix = null;\n  isVoid = false;\n  ignoreFirstLf = false;\n  canSelfClose = true;\n  preventNamespaceInheritance = false;\n  requireExtraParent(currentParent) {\n    return false;\n  }\n  isClosedByChild(name) {\n    return false;\n  }\n  getContentType() {\n    return TagContentType.PARSABLE_DATA;\n  }\n}\nconst _TAG_DEFINITION = new XmlTagDefinition();\nfunction getXmlTagDefinition(tagName) {\n  return _TAG_DEFINITION;\n}\n\nclass XmlParser extends Parser$1 {\n  constructor() {\n    super(getXmlTagDefinition);\n  }\n  parse(source, url, options = {}) {\n    return super.parse(source, url, {\n      ...options,\n      tokenizeBlocks: false,\n      tokenizeLet: false,\n      selectorlessEnabled: false\n    });\n  }\n}\n\nconst _VERSION$1 = '1.2';\nconst _XMLNS$1 = 'urn:oasis:names:tc:xliff:document:1.2';\nconst _DEFAULT_SOURCE_LANG$1 = 'en';\nconst _PLACEHOLDER_TAG$2 = 'x';\nconst _MARKER_TAG$1 = 'mrk';\nconst _FILE_TAG = 'file';\nconst _SOURCE_TAG$1 = 'source';\nconst _SEGMENT_SOURCE_TAG = 'seg-source';\nconst _ALT_TRANS_TAG = 'alt-trans';\nconst _TARGET_TAG$1 = 'target';\nconst _UNIT_TAG$1 = 'trans-unit';\nconst _CONTEXT_GROUP_TAG = 'context-group';\nconst _CONTEXT_TAG = 'context';\nclass Xliff extends Serializer {\n  write(messages, locale) {\n    const visitor = new _WriteVisitor$1();\n    const transUnits = [];\n    messages.forEach(message => {\n      let contextTags = [];\n      message.sources.forEach(source => {\n        let contextGroupTag = new Tag(_CONTEXT_GROUP_TAG, {\n          purpose: 'location'\n        });\n        contextGroupTag.children.push(new CR(10), new Tag(_CONTEXT_TAG, {\n          'context-type': 'sourcefile'\n        }, [new Text$1(source.filePath)]), new CR(10), new Tag(_CONTEXT_TAG, {\n          'context-type': 'linenumber'\n        }, [new Text$1(`${source.startLine}`)]), new CR(8));\n        contextTags.push(new CR(8), contextGroupTag);\n      });\n      const transUnit = new Tag(_UNIT_TAG$1, {\n        id: message.id,\n        datatype: 'html'\n      });\n      transUnit.children.push(new CR(8), new Tag(_SOURCE_TAG$1, {}, visitor.serialize(message.nodes)), ...contextTags);\n      if (message.description) {\n        transUnit.children.push(new CR(8), new Tag('note', {\n          priority: '1',\n          from: 'description'\n        }, [new Text$1(message.description)]));\n      }\n      if (message.meaning) {\n        transUnit.children.push(new CR(8), new Tag('note', {\n          priority: '1',\n          from: 'meaning'\n        }, [new Text$1(message.meaning)]));\n      }\n      transUnit.children.push(new CR(6));\n      transUnits.push(new CR(6), transUnit);\n    });\n    const body = new Tag('body', {}, [...transUnits, new CR(4)]);\n    const file = new Tag('file', {\n      'source-language': locale || _DEFAULT_SOURCE_LANG$1,\n      datatype: 'plaintext',\n      original: 'ng2.template'\n    }, [new CR(4), body, new CR(2)]);\n    const xliff = new Tag('xliff', {\n      version: _VERSION$1,\n      xmlns: _XMLNS$1\n    }, [new CR(2), file, new CR()]);\n    return serialize$1([new Declaration({\n      version: '1.0',\n      encoding: 'UTF-8'\n    }), new CR(), xliff, new CR()]);\n  }\n  load(content, url) {\n    const xliffParser = new XliffParser();\n    const {\n      locale,\n      msgIdToHtml,\n      errors\n    } = xliffParser.parse(content, url);\n    const i18nNodesByMsgId = {};\n    const converter = new XmlToI18n$2();\n    Object.keys(msgIdToHtml).forEach(msgId => {\n      const {\n        i18nNodes,\n        errors: e\n      } = converter.convert(msgIdToHtml[msgId], url);\n      errors.push(...e);\n      i18nNodesByMsgId[msgId] = i18nNodes;\n    });\n    if (errors.length) {\n      throw new Error(`xliff parse errors:\\n${errors.join('\\n')}`);\n    }\n    return {\n      locale: locale,\n      i18nNodesByMsgId\n    };\n  }\n  digest(message) {\n    return digest$1(message);\n  }\n}\nlet _WriteVisitor$1 = class _WriteVisitor {\n  visitText(text, context) {\n    return [new Text$1(text.value)];\n  }\n  visitContainer(container, context) {\n    const nodes = [];\n    container.children.forEach(node => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n  visitIcu(icu, context) {\n    const nodes = [new Text$1(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n    Object.keys(icu.cases).forEach(c => {\n      nodes.push(new Text$1(`${c} {`), ...icu.cases[c].visit(this), new Text$1(`} `));\n    });\n    nodes.push(new Text$1(`}`));\n    return nodes;\n  }\n  visitTagPlaceholder(ph, context) {\n    const ctype = getCtypeForTag(ph.tag);\n    if (ph.isVoid) {\n      return [new Tag(_PLACEHOLDER_TAG$2, {\n        id: ph.startName,\n        ctype,\n        'equiv-text': `<${ph.tag}/>`\n      })];\n    }\n    const startTagPh = new Tag(_PLACEHOLDER_TAG$2, {\n      id: ph.startName,\n      ctype,\n      'equiv-text': `<${ph.tag}>`\n    });\n    const closeTagPh = new Tag(_PLACEHOLDER_TAG$2, {\n      id: ph.closeName,\n      ctype,\n      'equiv-text': `</${ph.tag}>`\n    });\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n  visitPlaceholder(ph, context) {\n    return [new Tag(_PLACEHOLDER_TAG$2, {\n      id: ph.name,\n      'equiv-text': `{{${ph.value}}}`\n    })];\n  }\n  visitBlockPlaceholder(ph, context) {\n    const ctype = `x-${ph.name.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;\n    const startTagPh = new Tag(_PLACEHOLDER_TAG$2, {\n      id: ph.startName,\n      ctype,\n      'equiv-text': `@${ph.name}`\n    });\n    const closeTagPh = new Tag(_PLACEHOLDER_TAG$2, {\n      id: ph.closeName,\n      ctype,\n      'equiv-text': `}`\n    });\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n  visitIcuPlaceholder(ph, context) {\n    const equivText = `{${ph.value.expression}, ${ph.value.type}, ${Object.keys(ph.value.cases).map(value => value + ' {...}').join(' ')}}`;\n    return [new Tag(_PLACEHOLDER_TAG$2, {\n      id: ph.name,\n      'equiv-text': equivText\n    })];\n  }\n  serialize(nodes) {\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n};\nclass XliffParser {\n  _unitMlString;\n  _errors;\n  _msgIdToHtml;\n  _locale = null;\n  parse(xliff, url) {\n    this._unitMlString = null;\n    this._msgIdToHtml = {};\n    const xml = new XmlParser().parse(xliff, url);\n    this._errors = xml.errors;\n    visitAll(this, xml.rootNodes, null);\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors,\n      locale: this._locale\n    };\n  }\n  visitElement(element, context) {\n    switch (element.name) {\n      case _UNIT_TAG$1:\n        this._unitMlString = null;\n        const idAttr = element.attrs.find(attr => attr.name === 'id');\n        if (!idAttr) {\n          this._addError(element, `<${_UNIT_TAG$1}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            visitAll(this, element.children, null);\n            if (typeof this._unitMlString === 'string') {\n              this._msgIdToHtml[id] = this._unitMlString;\n            } else {\n              this._addError(element, `Message ${id} misses a translation`);\n            }\n          }\n        }\n        break;\n      case _SOURCE_TAG$1:\n      case _SEGMENT_SOURCE_TAG:\n      case _ALT_TRANS_TAG:\n        break;\n      case _TARGET_TAG$1:\n        const innerTextStart = element.startSourceSpan.end.offset;\n        const innerTextEnd = element.endSourceSpan.start.offset;\n        const content = element.startSourceSpan.start.file.content;\n        const innerText = content.slice(innerTextStart, innerTextEnd);\n        this._unitMlString = innerText;\n        break;\n      case _FILE_TAG:\n        const localeAttr = element.attrs.find(attr => attr.name === 'target-language');\n        if (localeAttr) {\n          this._locale = localeAttr.value;\n        }\n        visitAll(this, element.children, null);\n        break;\n      default:\n        visitAll(this, element.children, null);\n    }\n  }\n  visitAttribute(attribute, context) {}\n  visitText(text, context) {}\n  visitComment(comment, context) {}\n  visitExpansion(expansion, context) {}\n  visitExpansionCase(expansionCase, context) {}\n  visitBlock(block, context) {}\n  visitBlockParameter(parameter, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {}\n  visitDirective(directive, context) {}\n  _addError(node, message) {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n}\nlet XmlToI18n$2 = class XmlToI18n {\n  _errors;\n  convert(message, url) {\n    const xmlIcu = new XmlParser().parse(message, url, {\n      tokenizeExpansionForms: true\n    });\n    this._errors = xmlIcu.errors;\n    const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ? [] : [].concat(...visitAll(this, xmlIcu.rootNodes));\n    return {\n      i18nNodes: i18nNodes,\n      errors: this._errors\n    };\n  }\n  visitText(text, context) {\n    return new Text$2(text.value, text.sourceSpan);\n  }\n  visitElement(el, context) {\n    if (el.name === _PLACEHOLDER_TAG$2) {\n      const nameAttr = el.attrs.find(attr => attr.name === 'id');\n      if (nameAttr) {\n        return new Placeholder('', nameAttr.value, el.sourceSpan);\n      }\n      this._addError(el, `<${_PLACEHOLDER_TAG$2}> misses the \"id\" attribute`);\n      return null;\n    }\n    if (el.name === _MARKER_TAG$1) {\n      return [].concat(...visitAll(this, el.children));\n    }\n    this._addError(el, `Unexpected tag`);\n    return null;\n  }\n  visitExpansion(icu, context) {\n    const caseMap = {};\n    visitAll(this, icu.cases).forEach(c => {\n      caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n    });\n    return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n  visitExpansionCase(icuCase, context) {\n    return {\n      value: icuCase.value,\n      nodes: visitAll(this, icuCase.expression)\n    };\n  }\n  visitComment(comment, context) {}\n  visitAttribute(attribute, context) {}\n  visitBlock(block, context) {}\n  visitBlockParameter(parameter, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {\n    this._addError(component, 'Unexpected node');\n  }\n  visitDirective(directive, context) {\n    this._addError(directive, 'Unexpected node');\n  }\n  _addError(node, message) {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n};\nfunction getCtypeForTag(tag) {\n  switch (tag.toLowerCase()) {\n    case 'br':\n      return 'lb';\n    case 'img':\n      return 'image';\n    default:\n      return `x-${tag}`;\n  }\n}\n\nconst _VERSION = '2.0';\nconst _XMLNS = 'urn:oasis:names:tc:xliff:document:2.0';\nconst _DEFAULT_SOURCE_LANG = 'en';\nconst _PLACEHOLDER_TAG$1 = 'ph';\nconst _PLACEHOLDER_SPANNING_TAG = 'pc';\nconst _MARKER_TAG = 'mrk';\nconst _XLIFF_TAG = 'xliff';\nconst _SOURCE_TAG = 'source';\nconst _TARGET_TAG = 'target';\nconst _UNIT_TAG = 'unit';\nclass Xliff2 extends Serializer {\n  write(messages, locale) {\n    const visitor = new _WriteVisitor();\n    const units = [];\n    messages.forEach(message => {\n      const unit = new Tag(_UNIT_TAG, {\n        id: message.id\n      });\n      const notes = new Tag('notes');\n      if (message.description || message.meaning) {\n        if (message.description) {\n          notes.children.push(new CR(8), new Tag('note', {\n            category: 'description'\n          }, [new Text$1(message.description)]));\n        }\n        if (message.meaning) {\n          notes.children.push(new CR(8), new Tag('note', {\n            category: 'meaning'\n          }, [new Text$1(message.meaning)]));\n        }\n      }\n      message.sources.forEach(source => {\n        notes.children.push(new CR(8), new Tag('note', {\n          category: 'location'\n        }, [new Text$1(`${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? ',' + source.endLine : ''}`)]));\n      });\n      notes.children.push(new CR(6));\n      unit.children.push(new CR(6), notes);\n      const segment = new Tag('segment');\n      segment.children.push(new CR(8), new Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)), new CR(6));\n      unit.children.push(new CR(6), segment, new CR(4));\n      units.push(new CR(4), unit);\n    });\n    const file = new Tag('file', {\n      'original': 'ng.template',\n      id: 'ngi18n'\n    }, [...units, new CR(2)]);\n    const xliff = new Tag(_XLIFF_TAG, {\n      version: _VERSION,\n      xmlns: _XMLNS,\n      srcLang: locale || _DEFAULT_SOURCE_LANG\n    }, [new CR(2), file, new CR()]);\n    return serialize$1([new Declaration({\n      version: '1.0',\n      encoding: 'UTF-8'\n    }), new CR(), xliff, new CR()]);\n  }\n  load(content, url) {\n    const xliff2Parser = new Xliff2Parser();\n    const {\n      locale,\n      msgIdToHtml,\n      errors\n    } = xliff2Parser.parse(content, url);\n    const i18nNodesByMsgId = {};\n    const converter = new XmlToI18n$1();\n    Object.keys(msgIdToHtml).forEach(msgId => {\n      const {\n        i18nNodes,\n        errors: e\n      } = converter.convert(msgIdToHtml[msgId], url);\n      errors.push(...e);\n      i18nNodesByMsgId[msgId] = i18nNodes;\n    });\n    if (errors.length) {\n      throw new Error(`xliff2 parse errors:\\n${errors.join('\\n')}`);\n    }\n    return {\n      locale: locale,\n      i18nNodesByMsgId\n    };\n  }\n  digest(message) {\n    return decimalDigest(message);\n  }\n}\nclass _WriteVisitor {\n  _nextPlaceholderId = 0;\n  visitText(text, context) {\n    return [new Text$1(text.value)];\n  }\n  visitContainer(container, context) {\n    const nodes = [];\n    container.children.forEach(node => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n  visitIcu(icu, context) {\n    const nodes = [new Text$1(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n    Object.keys(icu.cases).forEach(c => {\n      nodes.push(new Text$1(`${c} {`), ...icu.cases[c].visit(this), new Text$1(`} `));\n    });\n    nodes.push(new Text$1(`}`));\n    return nodes;\n  }\n  visitTagPlaceholder(ph, context) {\n    const type = getTypeForTag(ph.tag);\n    if (ph.isVoid) {\n      const tagPh = new Tag(_PLACEHOLDER_TAG$1, {\n        id: (this._nextPlaceholderId++).toString(),\n        equiv: ph.startName,\n        type: type,\n        disp: `<${ph.tag}/>`\n      });\n      return [tagPh];\n    }\n    const tagPc = new Tag(_PLACEHOLDER_SPANNING_TAG, {\n      id: (this._nextPlaceholderId++).toString(),\n      equivStart: ph.startName,\n      equivEnd: ph.closeName,\n      type: type,\n      dispStart: `<${ph.tag}>`,\n      dispEnd: `</${ph.tag}>`\n    });\n    const nodes = [].concat(...ph.children.map(node => node.visit(this)));\n    if (nodes.length) {\n      nodes.forEach(node => tagPc.children.push(node));\n    } else {\n      tagPc.children.push(new Text$1(''));\n    }\n    return [tagPc];\n  }\n  visitPlaceholder(ph, context) {\n    const idStr = (this._nextPlaceholderId++).toString();\n    return [new Tag(_PLACEHOLDER_TAG$1, {\n      id: idStr,\n      equiv: ph.name,\n      disp: `{{${ph.value}}}`\n    })];\n  }\n  visitBlockPlaceholder(ph, context) {\n    const tagPc = new Tag(_PLACEHOLDER_SPANNING_TAG, {\n      id: (this._nextPlaceholderId++).toString(),\n      equivStart: ph.startName,\n      equivEnd: ph.closeName,\n      type: 'other',\n      dispStart: `@${ph.name}`,\n      dispEnd: `}`\n    });\n    const nodes = [].concat(...ph.children.map(node => node.visit(this)));\n    if (nodes.length) {\n      nodes.forEach(node => tagPc.children.push(node));\n    } else {\n      tagPc.children.push(new Text$1(''));\n    }\n    return [tagPc];\n  }\n  visitIcuPlaceholder(ph, context) {\n    const cases = Object.keys(ph.value.cases).map(value => value + ' {...}').join(' ');\n    const idStr = (this._nextPlaceholderId++).toString();\n    return [new Tag(_PLACEHOLDER_TAG$1, {\n      id: idStr,\n      equiv: ph.name,\n      disp: `{${ph.value.expression}, ${ph.value.type}, ${cases}}`\n    })];\n  }\n  serialize(nodes) {\n    this._nextPlaceholderId = 0;\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n}\nclass Xliff2Parser {\n  _unitMlString;\n  _errors;\n  _msgIdToHtml;\n  _locale = null;\n  parse(xliff, url) {\n    this._unitMlString = null;\n    this._msgIdToHtml = {};\n    const xml = new XmlParser().parse(xliff, url);\n    this._errors = xml.errors;\n    visitAll(this, xml.rootNodes, null);\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors,\n      locale: this._locale\n    };\n  }\n  visitElement(element, context) {\n    switch (element.name) {\n      case _UNIT_TAG:\n        this._unitMlString = null;\n        const idAttr = element.attrs.find(attr => attr.name === 'id');\n        if (!idAttr) {\n          this._addError(element, `<${_UNIT_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            visitAll(this, element.children, null);\n            if (typeof this._unitMlString === 'string') {\n              this._msgIdToHtml[id] = this._unitMlString;\n            } else {\n              this._addError(element, `Message ${id} misses a translation`);\n            }\n          }\n        }\n        break;\n      case _SOURCE_TAG:\n        break;\n      case _TARGET_TAG:\n        const innerTextStart = element.startSourceSpan.end.offset;\n        const innerTextEnd = element.endSourceSpan.start.offset;\n        const content = element.startSourceSpan.start.file.content;\n        const innerText = content.slice(innerTextStart, innerTextEnd);\n        this._unitMlString = innerText;\n        break;\n      case _XLIFF_TAG:\n        const localeAttr = element.attrs.find(attr => attr.name === 'trgLang');\n        if (localeAttr) {\n          this._locale = localeAttr.value;\n        }\n        const versionAttr = element.attrs.find(attr => attr.name === 'version');\n        if (versionAttr) {\n          const version = versionAttr.value;\n          if (version !== '2.0') {\n            this._addError(element, `The XLIFF file version ${version} is not compatible with XLIFF 2.0 serializer`);\n          } else {\n            visitAll(this, element.children, null);\n          }\n        }\n        break;\n      default:\n        visitAll(this, element.children, null);\n    }\n  }\n  visitAttribute(attribute, context) {}\n  visitText(text, context) {}\n  visitComment(comment, context) {}\n  visitExpansion(expansion, context) {}\n  visitExpansionCase(expansionCase, context) {}\n  visitBlock(block, context) {}\n  visitBlockParameter(parameter, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {}\n  visitDirective(directive, context) {}\n  _addError(node, message) {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n}\nlet XmlToI18n$1 = class XmlToI18n {\n  _errors;\n  convert(message, url) {\n    const xmlIcu = new XmlParser().parse(message, url, {\n      tokenizeExpansionForms: true\n    });\n    this._errors = xmlIcu.errors;\n    const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ? [] : [].concat(...visitAll(this, xmlIcu.rootNodes));\n    return {\n      i18nNodes,\n      errors: this._errors\n    };\n  }\n  visitText(text, context) {\n    return new Text$2(text.value, text.sourceSpan);\n  }\n  visitElement(el, context) {\n    switch (el.name) {\n      case _PLACEHOLDER_TAG$1:\n        const nameAttr = el.attrs.find(attr => attr.name === 'equiv');\n        if (nameAttr) {\n          return [new Placeholder('', nameAttr.value, el.sourceSpan)];\n        }\n        this._addError(el, `<${_PLACEHOLDER_TAG$1}> misses the \"equiv\" attribute`);\n        break;\n      case _PLACEHOLDER_SPANNING_TAG:\n        const startAttr = el.attrs.find(attr => attr.name === 'equivStart');\n        const endAttr = el.attrs.find(attr => attr.name === 'equivEnd');\n        if (!startAttr) {\n          this._addError(el, `<${_PLACEHOLDER_TAG$1}> misses the \"equivStart\" attribute`);\n        } else if (!endAttr) {\n          this._addError(el, `<${_PLACEHOLDER_TAG$1}> misses the \"equivEnd\" attribute`);\n        } else {\n          const startId = startAttr.value;\n          const endId = endAttr.value;\n          const nodes = [];\n          return nodes.concat(new Placeholder('', startId, el.sourceSpan), ...el.children.map(node => node.visit(this, null)), new Placeholder('', endId, el.sourceSpan));\n        }\n        break;\n      case _MARKER_TAG:\n        return [].concat(...visitAll(this, el.children));\n      default:\n        this._addError(el, `Unexpected tag`);\n    }\n    return null;\n  }\n  visitExpansion(icu, context) {\n    const caseMap = {};\n    visitAll(this, icu.cases).forEach(c => {\n      caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n    });\n    return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n  visitExpansionCase(icuCase, context) {\n    return {\n      value: icuCase.value,\n      nodes: [].concat(...visitAll(this, icuCase.expression))\n    };\n  }\n  visitComment(comment, context) {}\n  visitAttribute(attribute, context) {}\n  visitBlock(block, context) {}\n  visitBlockParameter(parameter, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {\n    this._addError(component, 'Unexpected node');\n  }\n  visitDirective(directive, context) {\n    this._addError(directive, 'Unexpected node');\n  }\n  _addError(node, message) {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n};\nfunction getTypeForTag(tag) {\n  switch (tag.toLowerCase()) {\n    case 'br':\n    case 'b':\n    case 'i':\n    case 'u':\n      return 'fmt';\n    case 'img':\n      return 'image';\n    case 'a':\n      return 'link';\n    default:\n      return 'other';\n  }\n}\n\nconst _TRANSLATIONS_TAG = 'translationbundle';\nconst _TRANSLATION_TAG = 'translation';\nconst _PLACEHOLDER_TAG = 'ph';\nclass Xtb extends Serializer {\n  write(messages, locale) {\n    throw new Error('Unsupported');\n  }\n  load(content, url) {\n    const xtbParser = new XtbParser();\n    const {\n      locale,\n      msgIdToHtml,\n      errors\n    } = xtbParser.parse(content, url);\n    const i18nNodesByMsgId = {};\n    const converter = new XmlToI18n();\n    Object.keys(msgIdToHtml).forEach(msgId => {\n      const valueFn = function () {\n        const {\n          i18nNodes,\n          errors\n        } = converter.convert(msgIdToHtml[msgId], url);\n        if (errors.length) {\n          throw new Error(`xtb parse errors:\\n${errors.join('\\n')}`);\n        }\n        return i18nNodes;\n      };\n      createLazyProperty(i18nNodesByMsgId, msgId, valueFn);\n    });\n    if (errors.length) {\n      throw new Error(`xtb parse errors:\\n${errors.join('\\n')}`);\n    }\n    return {\n      locale: locale,\n      i18nNodesByMsgId\n    };\n  }\n  digest(message) {\n    return digest(message);\n  }\n  createNameMapper(message) {\n    return new SimplePlaceholderMapper(message, toPublicName);\n  }\n}\nfunction createLazyProperty(messages, id, valueFn) {\n  Object.defineProperty(messages, id, {\n    configurable: true,\n    enumerable: true,\n    get: function () {\n      const value = valueFn();\n      Object.defineProperty(messages, id, {\n        enumerable: true,\n        value\n      });\n      return value;\n    },\n    set: _ => {\n      throw new Error('Could not overwrite an XTB translation');\n    }\n  });\n}\nclass XtbParser {\n  _bundleDepth;\n  _errors;\n  _msgIdToHtml;\n  _locale = null;\n  parse(xtb, url) {\n    this._bundleDepth = 0;\n    this._msgIdToHtml = {};\n    const xml = new XmlParser().parse(xtb, url);\n    this._errors = xml.errors;\n    visitAll(this, xml.rootNodes);\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors,\n      locale: this._locale\n    };\n  }\n  visitElement(element, context) {\n    switch (element.name) {\n      case _TRANSLATIONS_TAG:\n        this._bundleDepth++;\n        if (this._bundleDepth > 1) {\n          this._addError(element, `<${_TRANSLATIONS_TAG}> elements can not be nested`);\n        }\n        const langAttr = element.attrs.find(attr => attr.name === 'lang');\n        if (langAttr) {\n          this._locale = langAttr.value;\n        }\n        visitAll(this, element.children, null);\n        this._bundleDepth--;\n        break;\n      case _TRANSLATION_TAG:\n        const idAttr = element.attrs.find(attr => attr.name === 'id');\n        if (!idAttr) {\n          this._addError(element, `<${_TRANSLATION_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            const innerTextStart = element.startSourceSpan.end.offset;\n            const innerTextEnd = element.endSourceSpan.start.offset;\n            const content = element.startSourceSpan.start.file.content;\n            const innerText = content.slice(innerTextStart, innerTextEnd);\n            this._msgIdToHtml[id] = innerText;\n          }\n        }\n        break;\n      default:\n        this._addError(element, 'Unexpected tag');\n    }\n  }\n  visitAttribute(attribute, context) {}\n  visitText(text, context) {}\n  visitComment(comment, context) {}\n  visitExpansion(expansion, context) {}\n  visitExpansionCase(expansionCase, context) {}\n  visitBlock(block, context) {}\n  visitBlockParameter(block, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {\n    this._addError(component, 'Unexpected node');\n  }\n  visitDirective(directive, context) {\n    this._addError(directive, 'Unexpected node');\n  }\n  _addError(node, message) {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n}\nclass XmlToI18n {\n  _errors;\n  convert(message, url) {\n    const xmlIcu = new XmlParser().parse(message, url, {\n      tokenizeExpansionForms: true\n    });\n    this._errors = xmlIcu.errors;\n    const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ? [] : visitAll(this, xmlIcu.rootNodes);\n    return {\n      i18nNodes,\n      errors: this._errors\n    };\n  }\n  visitText(text, context) {\n    return new Text$2(text.value, text.sourceSpan);\n  }\n  visitExpansion(icu, context) {\n    const caseMap = {};\n    visitAll(this, icu.cases).forEach(c => {\n      caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n    });\n    return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n  visitExpansionCase(icuCase, context) {\n    return {\n      value: icuCase.value,\n      nodes: visitAll(this, icuCase.expression)\n    };\n  }\n  visitElement(el, context) {\n    if (el.name === _PLACEHOLDER_TAG) {\n      const nameAttr = el.attrs.find(attr => attr.name === 'name');\n      if (nameAttr) {\n        return new Placeholder('', nameAttr.value, el.sourceSpan);\n      }\n      this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"name\" attribute`);\n    } else {\n      this._addError(el, `Unexpected tag`);\n    }\n    return null;\n  }\n  visitComment(comment, context) {}\n  visitAttribute(attribute, context) {}\n  visitBlock(block, context) {}\n  visitBlockParameter(block, context) {}\n  visitLetDeclaration(decl, context) {}\n  visitComponent(component, context) {\n    this._addError(component, 'Unexpected node');\n  }\n  visitDirective(directive, context) {\n    this._addError(directive, 'Unexpected node');\n  }\n  _addError(node, message) {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n}\n\nclass TranslationBundle {\n  _i18nNodesByMsgId;\n  digest;\n  mapperFactory;\n  _i18nToHtml;\n  constructor(_i18nNodesByMsgId = {}, locale, digest, mapperFactory, missingTranslationStrategy = MissingTranslationStrategy.Warning, console) {\n    this._i18nNodesByMsgId = _i18nNodesByMsgId;\n    this.digest = digest;\n    this.mapperFactory = mapperFactory;\n    this._i18nToHtml = new I18nToHtmlVisitor(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console);\n  }\n  static load(content, url, serializer, missingTranslationStrategy, console) {\n    const {\n      locale,\n      i18nNodesByMsgId\n    } = serializer.load(content, url);\n    const digestFn = m => serializer.digest(m);\n    const mapperFactory = m => serializer.createNameMapper(m);\n    return new TranslationBundle(i18nNodesByMsgId, locale, digestFn, mapperFactory, missingTranslationStrategy, console);\n  }\n  get(srcMsg) {\n    const html = this._i18nToHtml.convert(srcMsg);\n    if (html.errors.length) {\n      throw new Error(html.errors.join('\\n'));\n    }\n    return html.nodes;\n  }\n  has(srcMsg) {\n    return this.digest(srcMsg) in this._i18nNodesByMsgId;\n  }\n}\nclass I18nToHtmlVisitor {\n  _i18nNodesByMsgId;\n  _locale;\n  _digest;\n  _mapperFactory;\n  _missingTranslationStrategy;\n  _console;\n  _srcMsg;\n  _errors = [];\n  _contextStack = [];\n  _mapper;\n  constructor(_i18nNodesByMsgId = {}, _locale, _digest, _mapperFactory, _missingTranslationStrategy, _console) {\n    this._i18nNodesByMsgId = _i18nNodesByMsgId;\n    this._locale = _locale;\n    this._digest = _digest;\n    this._mapperFactory = _mapperFactory;\n    this._missingTranslationStrategy = _missingTranslationStrategy;\n    this._console = _console;\n  }\n  convert(srcMsg) {\n    this._contextStack.length = 0;\n    this._errors.length = 0;\n    const text = this._convertToText(srcMsg);\n    const url = srcMsg.nodes[0].sourceSpan.start.file.url;\n    const html = new HtmlParser().parse(text, url, {\n      tokenizeExpansionForms: true\n    });\n    return {\n      nodes: html.rootNodes,\n      errors: [...this._errors, ...html.errors]\n    };\n  }\n  visitText(text, context) {\n    return escapeXml(text.value);\n  }\n  visitContainer(container, context) {\n    return container.children.map(n => n.visit(this)).join('');\n  }\n  visitIcu(icu, context) {\n    const cases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n    const exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression) ? this._srcMsg.placeholders[icu.expression].text : icu.expression;\n    return `{${exp}, ${icu.type}, ${cases.join(' ')}}`;\n  }\n  visitPlaceholder(ph, context) {\n    const phName = this._mapper(ph.name);\n    if (this._srcMsg.placeholders.hasOwnProperty(phName)) {\n      return this._srcMsg.placeholders[phName].text;\n    }\n    if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {\n      return this._convertToText(this._srcMsg.placeholderToMessage[phName]);\n    }\n    this._addError(ph, `Unknown placeholder \"${ph.name}\"`);\n    return '';\n  }\n  visitTagPlaceholder(ph, context) {\n    const tag = `${ph.tag}`;\n    const attrs = Object.keys(ph.attrs).map(name => `${name}=\"${ph.attrs[name]}\"`).join(' ');\n    if (ph.isVoid) {\n      return `<${tag} ${attrs}/>`;\n    }\n    const children = ph.children.map(c => c.visit(this)).join('');\n    return `<${tag} ${attrs}>${children}</${tag}>`;\n  }\n  visitIcuPlaceholder(ph, context) {\n    return this._convertToText(this._srcMsg.placeholderToMessage[ph.name]);\n  }\n  visitBlockPlaceholder(ph, context) {\n    const params = ph.parameters.length === 0 ? '' : ` (${ph.parameters.join('; ')})`;\n    const children = ph.children.map(c => c.visit(this)).join('');\n    return `@${ph.name}${params} {${children}}`;\n  }\n  _convertToText(srcMsg) {\n    const id = this._digest(srcMsg);\n    const mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;\n    let nodes;\n    this._contextStack.push({\n      msg: this._srcMsg,\n      mapper: this._mapper\n    });\n    this._srcMsg = srcMsg;\n    if (this._i18nNodesByMsgId.hasOwnProperty(id)) {\n      nodes = this._i18nNodesByMsgId[id];\n      this._mapper = name => mapper ? mapper.toInternalName(name) : name;\n    } else {\n      if (this._missingTranslationStrategy === MissingTranslationStrategy.Error) {\n        const ctx = this._locale ? ` for locale \"${this._locale}\"` : '';\n        this._addError(srcMsg.nodes[0], `Missing translation for message \"${id}\"${ctx}`);\n      } else if (this._console && this._missingTranslationStrategy === MissingTranslationStrategy.Warning) {\n        const ctx = this._locale ? ` for locale \"${this._locale}\"` : '';\n        this._console.warn(`Missing translation for message \"${id}\"${ctx}`);\n      }\n      nodes = srcMsg.nodes;\n      this._mapper = name => name;\n    }\n    const text = nodes.map(node => node.visit(this)).join('');\n    const context = this._contextStack.pop();\n    this._srcMsg = context.msg;\n    this._mapper = context.mapper;\n    return text;\n  }\n  _addError(el, msg) {\n    this._errors.push(new ParseError(el.sourceSpan, msg));\n  }\n}\n\nclass I18NHtmlParser {\n  _htmlParser;\n  getTagDefinition;\n  _translationBundle;\n  constructor(_htmlParser, translations, translationsFormat, missingTranslation = MissingTranslationStrategy.Warning, console) {\n    this._htmlParser = _htmlParser;\n    if (translations) {\n      const serializer = createSerializer(translationsFormat);\n      this._translationBundle = TranslationBundle.load(translations, 'i18n', serializer, missingTranslation, console);\n    } else {\n      this._translationBundle = new TranslationBundle({}, null, digest$1, undefined, missingTranslation, console);\n    }\n  }\n  parse(source, url, options = {}) {\n    const parseResult = this._htmlParser.parse(source, url, {\n      ...options\n    });\n    if (parseResult.errors.length) {\n      return new ParseTreeResult(parseResult.rootNodes, parseResult.errors);\n    }\n    return mergeTranslations(parseResult.rootNodes, this._translationBundle, [], {});\n  }\n}\nfunction createSerializer(format) {\n  format = (format || 'xlf').toLowerCase();\n  switch (format) {\n    case 'xmb':\n      return new Xmb();\n    case 'xtb':\n      return new Xtb();\n    case 'xliff2':\n    case 'xlf2':\n      return new Xliff2();\n    case 'xliff':\n    case 'xlf':\n    default:\n      return new Xliff();\n  }\n}\n\nclass MessageBundle {\n  _htmlParser;\n  _implicitTags;\n  _implicitAttrs;\n  _locale;\n  _preserveWhitespace;\n  _messages = [];\n  constructor(_htmlParser, _implicitTags, _implicitAttrs, _locale = null, _preserveWhitespace = true) {\n    this._htmlParser = _htmlParser;\n    this._implicitTags = _implicitTags;\n    this._implicitAttrs = _implicitAttrs;\n    this._locale = _locale;\n    this._preserveWhitespace = _preserveWhitespace;\n  }\n  updateFromTemplate(source, url) {\n    const htmlParserResult = this._htmlParser.parse(source, url, {\n      tokenizeExpansionForms: true\n    });\n    if (htmlParserResult.errors.length) {\n      return htmlParserResult.errors;\n    }\n    const rootNodes = this._preserveWhitespace ? htmlParserResult.rootNodes : visitAllWithSiblings(new WhitespaceVisitor(false), htmlParserResult.rootNodes);\n    const i18nParserResult = extractMessages(rootNodes, this._implicitTags, this._implicitAttrs, this._preserveWhitespace);\n    if (i18nParserResult.errors.length) {\n      return i18nParserResult.errors;\n    }\n    this._messages.push(...i18nParserResult.messages);\n    return [];\n  }\n  getMessages() {\n    return this._messages;\n  }\n  write(serializer, filterSources) {\n    const messages = {};\n    const mapperVisitor = new MapPlaceholderNames();\n    this._messages.forEach(message => {\n      const id = serializer.digest(message);\n      if (!messages.hasOwnProperty(id)) {\n        messages[id] = message;\n      } else {\n        messages[id].sources.push(...message.sources);\n      }\n    });\n    const msgList = Object.keys(messages).map(id => {\n      const mapper = serializer.createNameMapper(messages[id]);\n      const src = messages[id];\n      const nodes = mapper ? mapperVisitor.convert(src.nodes, mapper) : src.nodes;\n      let transformedMessage = new Message(nodes, {}, {}, src.meaning, src.description, id);\n      transformedMessage.sources = src.sources;\n      if (filterSources) {\n        transformedMessage.sources.forEach(source => source.filePath = filterSources(source.filePath));\n      }\n      return transformedMessage;\n    });\n    return serializer.write(msgList, this._locale);\n  }\n}\nclass MapPlaceholderNames extends CloneVisitor {\n  convert(nodes, mapper) {\n    return mapper ? nodes.map(n => n.visit(this, mapper)) : nodes;\n  }\n  visitTagPlaceholder(ph, mapper) {\n    const startName = mapper.toPublicName(ph.startName);\n    const closeName = ph.closeName ? mapper.toPublicName(ph.closeName) : ph.closeName;\n    const children = ph.children.map(n => n.visit(this, mapper));\n    return new TagPlaceholder(ph.tag, ph.attrs, startName, closeName, children, ph.isVoid, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);\n  }\n  visitBlockPlaceholder(ph, mapper) {\n    const startName = mapper.toPublicName(ph.startName);\n    const closeName = ph.closeName ? mapper.toPublicName(ph.closeName) : ph.closeName;\n    const children = ph.children.map(n => n.visit(this, mapper));\n    return new BlockPlaceholder(ph.name, ph.parameters, startName, closeName, children, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);\n  }\n  visitPlaceholder(ph, mapper) {\n    return new Placeholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\n  }\n  visitIcuPlaceholder(ph, mapper) {\n    return new IcuPlaceholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\n  }\n}\n\nfunction compileClassMetadata(metadata) {\n  const fnCall = internalCompileClassMetadata(metadata);\n  return arrowFn([], [devOnlyGuardedExpression(fnCall).toStmt()]).callFn([]);\n}\nfunction internalCompileClassMetadata(metadata) {\n  return importExpr(Identifiers.setClassMetadata).callFn([metadata.type, metadata.decorators, metadata.ctorParameters ?? literal(null), metadata.propDecorators ?? literal(null)]);\n}\nfunction compileComponentClassMetadata(metadata, dependencies) {\n  if (dependencies === null || dependencies.length === 0) {\n    return compileClassMetadata(metadata);\n  }\n  return internalCompileSetClassMetadataAsync(metadata, dependencies.map(dep => new FnParam(dep.symbolName, DYNAMIC_TYPE)), compileComponentMetadataAsyncResolver(dependencies));\n}\nfunction compileOpaqueAsyncClassMetadata(metadata, deferResolver, deferredDependencyNames) {\n  return internalCompileSetClassMetadataAsync(metadata, deferredDependencyNames.map(name => new FnParam(name, DYNAMIC_TYPE)), deferResolver);\n}\nfunction internalCompileSetClassMetadataAsync(metadata, wrapperParams, dependencyResolverFn) {\n  const setClassMetadataCall = internalCompileClassMetadata(metadata);\n  const setClassMetaWrapper = arrowFn(wrapperParams, [setClassMetadataCall.toStmt()]);\n  const setClassMetaAsync = importExpr(Identifiers.setClassMetadataAsync).callFn([metadata.type, dependencyResolverFn, setClassMetaWrapper]);\n  return arrowFn([], [devOnlyGuardedExpression(setClassMetaAsync).toStmt()]).callFn([]);\n}\nfunction compileComponentMetadataAsyncResolver(dependencies) {\n  const dynamicImports = dependencies.map(({\n    symbolName,\n    importPath,\n    isDefaultImport\n  }) => {\n    const innerFn = arrowFn([new FnParam('m', DYNAMIC_TYPE)], variable('m').prop(isDefaultImport ? 'default' : symbolName));\n    return new DynamicImportExpr(importPath).prop('then').callFn([innerFn]);\n  });\n  return arrowFn([], literalArr(dynamicImports));\n}\n\nconst MINIMUM_PARTIAL_LINKER_VERSION$5 = '12.0.0';\nconst MINIMUM_PARTIAL_LINKER_DEFER_SUPPORT_VERSION = '18.0.0';\nfunction compileDeclareClassMetadata(metadata) {\n  const definitionMap = new DefinitionMap();\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$5));\n  definitionMap.set('version', literal('21.0.0'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', metadata.type);\n  definitionMap.set('decorators', metadata.decorators);\n  definitionMap.set('ctorParameters', metadata.ctorParameters);\n  definitionMap.set('propDecorators', metadata.propDecorators);\n  return importExpr(Identifiers.declareClassMetadata).callFn([definitionMap.toLiteralMap()]);\n}\nfunction compileComponentDeclareClassMetadata(metadata, dependencies) {\n  if (dependencies === null || dependencies.length === 0) {\n    return compileDeclareClassMetadata(metadata);\n  }\n  const definitionMap = new DefinitionMap();\n  const callbackReturnDefinitionMap = new DefinitionMap();\n  callbackReturnDefinitionMap.set('decorators', metadata.decorators);\n  callbackReturnDefinitionMap.set('ctorParameters', metadata.ctorParameters ?? literal(null));\n  callbackReturnDefinitionMap.set('propDecorators', metadata.propDecorators ?? literal(null));\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_DEFER_SUPPORT_VERSION));\n  definitionMap.set('version', literal('21.0.0'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', metadata.type);\n  definitionMap.set('resolveDeferredDeps', compileComponentMetadataAsyncResolver(dependencies));\n  definitionMap.set('resolveMetadata', arrowFn(dependencies.map(dep => new FnParam(dep.symbolName, DYNAMIC_TYPE)), callbackReturnDefinitionMap.toLiteralMap()));\n  return importExpr(Identifiers.declareClassMetadataAsync).callFn([definitionMap.toLiteralMap()]);\n}\n\nfunction toOptionalLiteralArray(values, mapper) {\n  if (values === null || values.length === 0) {\n    return null;\n  }\n  return literalArr(values.map(value => mapper(value)));\n}\nfunction toOptionalLiteralMap(object, mapper) {\n  const entries = Object.keys(object).map(key => {\n    const value = object[key];\n    return {\n      key,\n      value: mapper(value),\n      quoted: true\n    };\n  });\n  if (entries.length > 0) {\n    return literalMap(entries);\n  } else {\n    return null;\n  }\n}\nfunction compileDependencies(deps) {\n  if (deps === 'invalid') {\n    return literal('invalid');\n  } else if (deps === null) {\n    return literal(null);\n  } else {\n    return literalArr(deps.map(compileDependency));\n  }\n}\nfunction compileDependency(dep) {\n  const depMeta = new DefinitionMap();\n  depMeta.set('token', dep.token);\n  if (dep.attributeNameType !== null) {\n    depMeta.set('attribute', literal(true));\n  }\n  if (dep.host) {\n    depMeta.set('host', literal(true));\n  }\n  if (dep.optional) {\n    depMeta.set('optional', literal(true));\n  }\n  if (dep.self) {\n    depMeta.set('self', literal(true));\n  }\n  if (dep.skipSelf) {\n    depMeta.set('skipSelf', literal(true));\n  }\n  return depMeta.toLiteralMap();\n}\n\nfunction compileDeclareDirectiveFromMetadata(meta) {\n  const definitionMap = createDirectiveDefinitionMap(meta);\n  const expression = importExpr(Identifiers.declareDirective).callFn([definitionMap.toLiteralMap()]);\n  const type = createDirectiveType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createDirectiveDefinitionMap(meta) {\n  const definitionMap = new DefinitionMap();\n  const minVersion = getMinimumVersionForPartialOutput(meta);\n  definitionMap.set('minVersion', literal(minVersion));\n  definitionMap.set('version', literal('21.0.0'));\n  definitionMap.set('type', meta.type.value);\n  if (meta.isStandalone !== undefined) {\n    definitionMap.set('isStandalone', literal(meta.isStandalone));\n  }\n  if (meta.isSignal) {\n    definitionMap.set('isSignal', literal(meta.isSignal));\n  }\n  if (meta.selector !== null) {\n    definitionMap.set('selector', literal(meta.selector));\n  }\n  definitionMap.set('inputs', needsNewInputPartialOutput(meta) ? createInputsPartialMetadata(meta.inputs) : legacyInputsPartialMetadata(meta.inputs));\n  definitionMap.set('outputs', conditionallyCreateDirectiveBindingLiteral(meta.outputs));\n  definitionMap.set('host', compileHostMetadata(meta.host));\n  definitionMap.set('providers', meta.providers);\n  if (meta.queries.length > 0) {\n    definitionMap.set('queries', literalArr(meta.queries.map(compileQuery)));\n  }\n  if (meta.viewQueries.length > 0) {\n    definitionMap.set('viewQueries', literalArr(meta.viewQueries.map(compileQuery)));\n  }\n  if (meta.exportAs !== null) {\n    definitionMap.set('exportAs', asLiteral(meta.exportAs));\n  }\n  if (meta.usesInheritance) {\n    definitionMap.set('usesInheritance', literal(true));\n  }\n  if (meta.lifecycle.usesOnChanges) {\n    definitionMap.set('usesOnChanges', literal(true));\n  }\n  if (meta.hostDirectives?.length) {\n    definitionMap.set('hostDirectives', createHostDirectives(meta.hostDirectives));\n  }\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  return definitionMap;\n}\nfunction getMinimumVersionForPartialOutput(meta) {\n  let minVersion = '14.0.0';\n  const hasDecoratorTransformFunctions = Object.values(meta.inputs).some(input => input.transformFunction !== null);\n  if (hasDecoratorTransformFunctions) {\n    minVersion = '16.1.0';\n  }\n  if (needsNewInputPartialOutput(meta)) {\n    minVersion = '17.1.0';\n  }\n  if (meta.queries.some(q => q.isSignal) || meta.viewQueries.some(q => q.isSignal)) {\n    minVersion = '17.2.0';\n  }\n  return minVersion;\n}\nfunction needsNewInputPartialOutput(meta) {\n  return Object.values(meta.inputs).some(input => input.isSignal);\n}\nfunction compileQuery(query) {\n  const meta = new DefinitionMap();\n  meta.set('propertyName', literal(query.propertyName));\n  if (query.first) {\n    meta.set('first', literal(true));\n  }\n  meta.set('predicate', Array.isArray(query.predicate) ? asLiteral(query.predicate) : convertFromMaybeForwardRefExpression(query.predicate));\n  if (!query.emitDistinctChangesOnly) {\n    meta.set('emitDistinctChangesOnly', literal(false));\n  }\n  if (query.descendants) {\n    meta.set('descendants', literal(true));\n  }\n  meta.set('read', query.read);\n  if (query.static) {\n    meta.set('static', literal(true));\n  }\n  if (query.isSignal) {\n    meta.set('isSignal', literal(true));\n  }\n  return meta.toLiteralMap();\n}\nfunction compileHostMetadata(meta) {\n  const hostMetadata = new DefinitionMap();\n  hostMetadata.set('attributes', toOptionalLiteralMap(meta.attributes, expression => expression));\n  hostMetadata.set('listeners', toOptionalLiteralMap(meta.listeners, literal));\n  hostMetadata.set('properties', toOptionalLiteralMap(meta.properties, literal));\n  if (meta.specialAttributes.styleAttr) {\n    hostMetadata.set('styleAttribute', literal(meta.specialAttributes.styleAttr));\n  }\n  if (meta.specialAttributes.classAttr) {\n    hostMetadata.set('classAttribute', literal(meta.specialAttributes.classAttr));\n  }\n  if (hostMetadata.values.length > 0) {\n    return hostMetadata.toLiteralMap();\n  } else {\n    return null;\n  }\n}\nfunction createHostDirectives(hostDirectives) {\n  const expressions = hostDirectives.map(current => {\n    const keys = [{\n      key: 'directive',\n      value: current.isForwardReference ? generateForwardRef(current.directive.type) : current.directive.type,\n      quoted: false\n    }];\n    const inputsLiteral = current.inputs ? createHostDirectivesMappingArray(current.inputs) : null;\n    const outputsLiteral = current.outputs ? createHostDirectivesMappingArray(current.outputs) : null;\n    if (inputsLiteral) {\n      keys.push({\n        key: 'inputs',\n        value: inputsLiteral,\n        quoted: false\n      });\n    }\n    if (outputsLiteral) {\n      keys.push({\n        key: 'outputs',\n        value: outputsLiteral,\n        quoted: false\n      });\n    }\n    return literalMap(keys);\n  });\n  return literalArr(expressions);\n}\nfunction createInputsPartialMetadata(inputs) {\n  const keys = Object.getOwnPropertyNames(inputs);\n  if (keys.length === 0) {\n    return null;\n  }\n  return literalMap(keys.map(declaredName => {\n    const value = inputs[declaredName];\n    return {\n      key: declaredName,\n      quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(declaredName),\n      value: literalMap([{\n        key: 'classPropertyName',\n        quoted: false,\n        value: asLiteral(value.classPropertyName)\n      }, {\n        key: 'publicName',\n        quoted: false,\n        value: asLiteral(value.bindingPropertyName)\n      }, {\n        key: 'isSignal',\n        quoted: false,\n        value: asLiteral(value.isSignal)\n      }, {\n        key: 'isRequired',\n        quoted: false,\n        value: asLiteral(value.required)\n      }, {\n        key: 'transformFunction',\n        quoted: false,\n        value: value.transformFunction ?? NULL_EXPR\n      }])\n    };\n  }));\n}\nfunction legacyInputsPartialMetadata(inputs) {\n  const keys = Object.getOwnPropertyNames(inputs);\n  if (keys.length === 0) {\n    return null;\n  }\n  return literalMap(keys.map(declaredName => {\n    const value = inputs[declaredName];\n    const publicName = value.bindingPropertyName;\n    const differentDeclaringName = publicName !== declaredName;\n    let result;\n    if (differentDeclaringName || value.transformFunction !== null) {\n      const values = [asLiteral(publicName), asLiteral(declaredName)];\n      if (value.transformFunction !== null) {\n        values.push(value.transformFunction);\n      }\n      result = literalArr(values);\n    } else {\n      result = asLiteral(publicName);\n    }\n    return {\n      key: declaredName,\n      quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(declaredName),\n      value: result\n    };\n  }));\n}\n\nfunction compileDeclareComponentFromMetadata(meta, template, additionalTemplateInfo) {\n  const definitionMap = createComponentDefinitionMap(meta, template, additionalTemplateInfo);\n  const expression = importExpr(Identifiers.declareComponent).callFn([definitionMap.toLiteralMap()]);\n  const type = createComponentType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createComponentDefinitionMap(meta, template, templateInfo) {\n  const definitionMap = createDirectiveDefinitionMap(meta);\n  const blockVisitor = new BlockPresenceVisitor();\n  visitAll$1(blockVisitor, template.nodes);\n  definitionMap.set('template', getTemplateExpression(template, templateInfo));\n  if (templateInfo.isInline) {\n    definitionMap.set('isInline', literal(true));\n  }\n  if (blockVisitor.hasBlocks) {\n    definitionMap.set('minVersion', literal('17.0.0'));\n  }\n  definitionMap.set('styles', toOptionalLiteralArray(meta.styles, literal));\n  definitionMap.set('dependencies', compileUsedDependenciesMetadata(meta));\n  definitionMap.set('viewProviders', meta.viewProviders);\n  definitionMap.set('animations', meta.animations);\n  if (meta.changeDetection !== null) {\n    if (typeof meta.changeDetection === 'object') {\n      throw new Error('Impossible state! Change detection flag is not resolved!');\n    }\n    definitionMap.set('changeDetection', importExpr(Identifiers.ChangeDetectionStrategy).prop(ChangeDetectionStrategy[meta.changeDetection]));\n  }\n  if (meta.encapsulation !== ViewEncapsulation$1.Emulated) {\n    definitionMap.set('encapsulation', importExpr(Identifiers.ViewEncapsulation).prop(ViewEncapsulation$1[meta.encapsulation]));\n  }\n  if (template.preserveWhitespaces === true) {\n    definitionMap.set('preserveWhitespaces', literal(true));\n  }\n  if (meta.defer.mode === 0) {\n    const resolvers = [];\n    let hasResolvers = false;\n    for (const deps of meta.defer.blocks.values()) {\n      if (deps === null) {\n        resolvers.push(literal(null));\n      } else {\n        resolvers.push(deps);\n        hasResolvers = true;\n      }\n    }\n    if (hasResolvers) {\n      definitionMap.set('deferBlockDependencies', literalArr(resolvers));\n    }\n  } else {\n    throw new Error('Unsupported defer function emit mode in partial compilation');\n  }\n  return definitionMap;\n}\nfunction getTemplateExpression(template, templateInfo) {\n  if (templateInfo.inlineTemplateLiteralExpression !== null) {\n    return templateInfo.inlineTemplateLiteralExpression;\n  }\n  if (templateInfo.isInline) {\n    return literal(templateInfo.content, null, null);\n  }\n  const contents = templateInfo.content;\n  const file = new ParseSourceFile(contents, templateInfo.sourceUrl);\n  const start = new ParseLocation(file, 0, 0, 0);\n  const end = computeEndLocation(file, contents);\n  const span = new ParseSourceSpan(start, end);\n  return literal(contents, null, span);\n}\nfunction computeEndLocation(file, contents) {\n  const length = contents.length;\n  let lineStart = 0;\n  let lastLineStart = 0;\n  let line = 0;\n  do {\n    lineStart = contents.indexOf('\\n', lastLineStart);\n    if (lineStart !== -1) {\n      lastLineStart = lineStart + 1;\n      line++;\n    }\n  } while (lineStart !== -1);\n  return new ParseLocation(file, length, line, length - lastLineStart);\n}\nfunction compileUsedDependenciesMetadata(meta) {\n  const wrapType = meta.declarationListEmitMode !== 0 ? generateForwardRef : expr => expr;\n  if (meta.declarationListEmitMode === 3) {\n    throw new Error(`Unsupported emit mode`);\n  }\n  return toOptionalLiteralArray(meta.declarations, decl => {\n    switch (decl.kind) {\n      case R3TemplateDependencyKind.Directive:\n        const dirMeta = new DefinitionMap();\n        dirMeta.set('kind', literal(decl.isComponent ? 'component' : 'directive'));\n        dirMeta.set('type', wrapType(decl.type));\n        dirMeta.set('selector', literal(decl.selector));\n        dirMeta.set('inputs', toOptionalLiteralArray(decl.inputs, literal));\n        dirMeta.set('outputs', toOptionalLiteralArray(decl.outputs, literal));\n        dirMeta.set('exportAs', toOptionalLiteralArray(decl.exportAs, literal));\n        return dirMeta.toLiteralMap();\n      case R3TemplateDependencyKind.Pipe:\n        const pipeMeta = new DefinitionMap();\n        pipeMeta.set('kind', literal('pipe'));\n        pipeMeta.set('type', wrapType(decl.type));\n        pipeMeta.set('name', literal(decl.name));\n        return pipeMeta.toLiteralMap();\n      case R3TemplateDependencyKind.NgModule:\n        const ngModuleMeta = new DefinitionMap();\n        ngModuleMeta.set('kind', literal('ngmodule'));\n        ngModuleMeta.set('type', wrapType(decl.type));\n        return ngModuleMeta.toLiteralMap();\n    }\n  });\n}\nclass BlockPresenceVisitor extends RecursiveVisitor$1 {\n  hasBlocks = false;\n  visitDeferredBlock() {\n    this.hasBlocks = true;\n  }\n  visitDeferredBlockPlaceholder() {\n    this.hasBlocks = true;\n  }\n  visitDeferredBlockLoading() {\n    this.hasBlocks = true;\n  }\n  visitDeferredBlockError() {\n    this.hasBlocks = true;\n  }\n  visitIfBlock() {\n    this.hasBlocks = true;\n  }\n  visitIfBlockBranch() {\n    this.hasBlocks = true;\n  }\n  visitForLoopBlock() {\n    this.hasBlocks = true;\n  }\n  visitForLoopBlockEmpty() {\n    this.hasBlocks = true;\n  }\n  visitSwitchBlock() {\n    this.hasBlocks = true;\n  }\n  visitSwitchBlockCase() {\n    this.hasBlocks = true;\n  }\n}\n\nconst MINIMUM_PARTIAL_LINKER_VERSION$4 = '12.0.0';\nfunction compileDeclareFactoryFunction(meta) {\n  const definitionMap = new DefinitionMap();\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$4));\n  definitionMap.set('version', literal('21.0.0'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', meta.type.value);\n  definitionMap.set('deps', compileDependencies(meta.deps));\n  definitionMap.set('target', importExpr(Identifiers.FactoryTarget).prop(FactoryTarget[meta.target]));\n  return {\n    expression: importExpr(Identifiers.declareFactory).callFn([definitionMap.toLiteralMap()]),\n    statements: [],\n    type: createFactoryType(meta)\n  };\n}\n\nconst MINIMUM_PARTIAL_LINKER_VERSION$3 = '12.0.0';\nfunction compileDeclareInjectableFromMetadata(meta) {\n  const definitionMap = createInjectableDefinitionMap(meta);\n  const expression = importExpr(Identifiers.declareInjectable).callFn([definitionMap.toLiteralMap()]);\n  const type = createInjectableType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createInjectableDefinitionMap(meta) {\n  const definitionMap = new DefinitionMap();\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$3));\n  definitionMap.set('version', literal('21.0.0'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', meta.type.value);\n  if (meta.providedIn !== undefined) {\n    const providedIn = convertFromMaybeForwardRefExpression(meta.providedIn);\n    if (providedIn.value !== null) {\n      definitionMap.set('providedIn', providedIn);\n    }\n  }\n  if (meta.useClass !== undefined) {\n    definitionMap.set('useClass', convertFromMaybeForwardRefExpression(meta.useClass));\n  }\n  if (meta.useExisting !== undefined) {\n    definitionMap.set('useExisting', convertFromMaybeForwardRefExpression(meta.useExisting));\n  }\n  if (meta.useValue !== undefined) {\n    definitionMap.set('useValue', convertFromMaybeForwardRefExpression(meta.useValue));\n  }\n  if (meta.useFactory !== undefined) {\n    definitionMap.set('useFactory', meta.useFactory);\n  }\n  if (meta.deps !== undefined) {\n    definitionMap.set('deps', literalArr(meta.deps.map(compileDependency)));\n  }\n  return definitionMap;\n}\n\nconst MINIMUM_PARTIAL_LINKER_VERSION$2 = '12.0.0';\nfunction compileDeclareInjectorFromMetadata(meta) {\n  const definitionMap = createInjectorDefinitionMap(meta);\n  const expression = importExpr(Identifiers.declareInjector).callFn([definitionMap.toLiteralMap()]);\n  const type = createInjectorType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createInjectorDefinitionMap(meta) {\n  const definitionMap = new DefinitionMap();\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$2));\n  definitionMap.set('version', literal('21.0.0'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', meta.type.value);\n  definitionMap.set('providers', meta.providers);\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', literalArr(meta.imports));\n  }\n  return definitionMap;\n}\n\nconst MINIMUM_PARTIAL_LINKER_VERSION$1 = '14.0.0';\nfunction compileDeclareNgModuleFromMetadata(meta) {\n  const definitionMap = createNgModuleDefinitionMap(meta);\n  const expression = importExpr(Identifiers.declareNgModule).callFn([definitionMap.toLiteralMap()]);\n  const type = createNgModuleType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createNgModuleDefinitionMap(meta) {\n  const definitionMap = new DefinitionMap();\n  if (meta.kind === R3NgModuleMetadataKind.Local) {\n    throw new Error('Invalid path! Local compilation mode should not get into the partial compilation path');\n  }\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$1));\n  definitionMap.set('version', literal('21.0.0'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', meta.type.value);\n  if (meta.bootstrap.length > 0) {\n    definitionMap.set('bootstrap', refsToArray(meta.bootstrap, meta.containsForwardDecls));\n  }\n  if (meta.declarations.length > 0) {\n    definitionMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\n  }\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\n  }\n  if (meta.exports.length > 0) {\n    definitionMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\n  }\n  if (meta.schemas !== null && meta.schemas.length > 0) {\n    definitionMap.set('schemas', literalArr(meta.schemas.map(ref => ref.value)));\n  }\n  if (meta.id !== null) {\n    definitionMap.set('id', meta.id);\n  }\n  return definitionMap;\n}\n\nconst MINIMUM_PARTIAL_LINKER_VERSION = '14.0.0';\nfunction compileDeclarePipeFromMetadata(meta) {\n  const definitionMap = createPipeDefinitionMap(meta);\n  const expression = importExpr(Identifiers.declarePipe).callFn([definitionMap.toLiteralMap()]);\n  const type = createPipeType(meta);\n  return {\n    expression,\n    type,\n    statements: []\n  };\n}\nfunction createPipeDefinitionMap(meta) {\n  const definitionMap = new DefinitionMap();\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', literal('21.0.0'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', meta.type.value);\n  if (meta.isStandalone !== undefined) {\n    definitionMap.set('isStandalone', literal(meta.isStandalone));\n  }\n  definitionMap.set('name', literal(meta.pipeName ?? meta.name));\n  if (meta.pure === false) {\n    definitionMap.set('pure', literal(meta.pure));\n  }\n  return definitionMap;\n}\n\nfunction compileClassDebugInfo(debugInfo) {\n  const debugInfoObject = {\n    className: debugInfo.className\n  };\n  if (debugInfo.filePath) {\n    debugInfoObject.filePath = debugInfo.filePath;\n    debugInfoObject.lineNumber = debugInfo.lineNumber;\n  }\n  if (debugInfo.forbidOrphanRendering) {\n    debugInfoObject.forbidOrphanRendering = literal(true);\n  }\n  const fnCall = importExpr(Identifiers.setClassDebugInfo).callFn([debugInfo.type, mapLiteral(debugInfoObject)]);\n  const iife = arrowFn([], [devOnlyGuardedExpression(fnCall).toStmt()]);\n  return iife.callFn([]);\n}\n\nfunction compileHmrInitializer(meta) {\n  const moduleName = 'm';\n  const dataName = 'd';\n  const timestampName = 't';\n  const idName = 'id';\n  const importCallbackName = `${meta.className}_HmrLoad`;\n  const namespaces = meta.namespaceDependencies.map(dep => {\n    return new ExternalExpr({\n      moduleName: dep.moduleName,\n      name: null\n    });\n  });\n  const defaultRead = variable(moduleName).prop('default');\n  const replaceCall = importExpr(Identifiers.replaceMetadata).callFn([meta.type, defaultRead, literalArr(namespaces), literalArr(meta.localDependencies.map(l => l.runtimeRepresentation)), variable('import').prop('meta'), variable(idName)]);\n  const replaceCallback = arrowFn([new FnParam(moduleName)], defaultRead.and(replaceCall));\n  const url = importExpr(Identifiers.getReplaceMetadataURL).callFn([variable(idName), variable(timestampName), variable('import').prop('meta').prop('url')]);\n  const importCallback = new DeclareFunctionStmt(importCallbackName, [new FnParam(timestampName)], [new DynamicImportExpr(url, null, '@vite-ignore').prop('then').callFn([replaceCallback]).toStmt()], null, StmtModifier.Final);\n  const updateCallback = arrowFn([new FnParam(dataName)], variable(dataName).prop('id').identical(variable(idName)).and(variable(importCallbackName).callFn([variable(dataName).prop('timestamp')])));\n  const initialCall = variable(importCallbackName).callFn([variable('Date').prop('now').callFn([])]);\n  const hotRead = variable('import').prop('meta').prop('hot');\n  const hotListener = hotRead.clone().prop('on').callFn([literal('angular:component-update'), updateCallback]);\n  return arrowFn([], [new DeclareVarStmt(idName, literal(encodeURIComponent(`${meta.filePath}@${meta.className}`)), null, StmtModifier.Final), importCallback, devOnlyGuardedExpression(initialCall).toStmt(), devOnlyGuardedExpression(hotRead.and(hotListener)).toStmt()]).callFn([]);\n}\nfunction compileHmrUpdateCallback(definitions, constantStatements, meta) {\n  const namespaces = 'ÉµÉµnamespaces';\n  const params = [meta.className, namespaces].map(name => new FnParam(name, DYNAMIC_TYPE));\n  const body = [];\n  for (const local of meta.localDependencies) {\n    params.push(new FnParam(local.name));\n  }\n  for (let i = 0; i < meta.namespaceDependencies.length; i++) {\n    body.push(new DeclareVarStmt(meta.namespaceDependencies[i].assignedName, variable(namespaces).key(literal(i)), DYNAMIC_TYPE, StmtModifier.Final));\n  }\n  body.push(...constantStatements);\n  for (const field of definitions) {\n    if (field.initializer !== null) {\n      body.push(variable(meta.className).prop(field.name).set(field.initializer).toStmt());\n      for (const stmt of field.statements) {\n        body.push(stmt);\n      }\n    }\n  }\n  return new DeclareFunctionStmt(`${meta.className}_UpdateMetadata`, params, body, null, StmtModifier.Final);\n}\n\nconst VERSION = new Version('21.0.0');\n\npublishFacade(_global);\n\nexport { AST, ASTWithName, ASTWithSource, AbsoluteSourceSpan, ArrayType, ArrowFunctionExpr, Attribute, Binary, BinaryOperator, BinaryOperatorExpr, BindingPipe, BindingPipeType, BindingType, Block, BlockParameter, BoundElementProperty, BuiltinType, BuiltinTypeName, CUSTOM_ELEMENTS_SCHEMA, Call, Chain, ChangeDetectionStrategy, CombinedRecursiveAstVisitor, CommaExpr, Comment, CompilerConfig, CompilerFacadeImpl, Component, Conditional, ConditionalExpr, ConstantPool, CssSelector, DEFAULT_INTERPOLATION_CONFIG, DYNAMIC_TYPE, DeclareFunctionStmt, DeclareVarStmt, Directive, DomElementSchemaRegistry, DynamicImportExpr, EOF, Element, ElementSchemaRegistry, EmitterVisitorContext, EmptyExpr$1 as EmptyExpr, Expansion, ExpansionCase, Expression, ExpressionBinding, ExpressionStatement, ExpressionType, ExternalExpr, ExternalReference, FactoryTarget, FunctionExpr, HtmlParser, HtmlTagDefinition, I18NHtmlParser, IfStmt, ImplicitReceiver, InstantiateExpr, Interpolation$1 as Interpolation, InterpolationConfig, InvokeFunctionExpr, JSDocComment, JitEvaluator, KeyedRead, LeadingComment, LetDeclaration, Lexer, LiteralArray, LiteralArrayExpr, LiteralExpr, LiteralMap, LiteralMapExpr, LiteralPrimitive, LocalizedString, MapType, MessageBundle, NONE_TYPE, NO_ERRORS_SCHEMA, NodeWithI18n, NonNullAssert, NotExpr, ParenthesizedExpr, ParenthesizedExpression, ParseError, ParseErrorLevel, ParseLocation, ParseSourceFile, ParseSourceSpan, ParseSpan, ParseTreeResult, ParsedEvent, ParsedEventType, ParsedProperty, ParsedPropertyType, ParsedVariable, Parser, PrefixNot, PropertyRead, Identifiers as R3Identifiers, R3NgModuleMetadataKind, R3SelectorScopeMode, R3TargetBinder, R3TemplateDependencyKind, ReadKeyExpr, ReadPropExpr, ReadVarExpr, RecursiveAstVisitor, RecursiveVisitor, RegularExpressionLiteral, RegularExpressionLiteralExpr, ResourceLoader, ReturnStatement, SCHEMA, SECURITY_SCHEMA, STRING_TYPE, SafeCall, SafeKeyedRead, SafePropertyRead, SelectorContext, SelectorListContext, SelectorMatcher, SelectorlessMatcher, Serializer, SplitInterpolation, Statement, StmtModifier, StringToken, StringTokenKind, TagContentType, TaggedTemplateLiteral, TaggedTemplateLiteralExpr, TemplateBindingParseResult, TemplateLiteral, TemplateLiteralElement, TemplateLiteralElementExpr, TemplateLiteralExpr, Text, ThisReceiver, BlockNode as TmplAstBlockNode, BoundAttribute as TmplAstBoundAttribute, BoundDeferredTrigger as TmplAstBoundDeferredTrigger, BoundEvent as TmplAstBoundEvent, BoundText as TmplAstBoundText, Component$1 as TmplAstComponent, Content as TmplAstContent, DeferredBlock as TmplAstDeferredBlock, DeferredBlockError as TmplAstDeferredBlockError, DeferredBlockLoading as TmplAstDeferredBlockLoading, DeferredBlockPlaceholder as TmplAstDeferredBlockPlaceholder, DeferredTrigger as TmplAstDeferredTrigger, Directive$1 as TmplAstDirective, Element$1 as TmplAstElement, ForLoopBlock as TmplAstForLoopBlock, ForLoopBlockEmpty as TmplAstForLoopBlockEmpty, HostElement as TmplAstHostElement, HoverDeferredTrigger as TmplAstHoverDeferredTrigger, Icu$1 as TmplAstIcu, IdleDeferredTrigger as TmplAstIdleDeferredTrigger, IfBlock as TmplAstIfBlock, IfBlockBranch as TmplAstIfBlockBranch, ImmediateDeferredTrigger as TmplAstImmediateDeferredTrigger, InteractionDeferredTrigger as TmplAstInteractionDeferredTrigger, LetDeclaration$1 as TmplAstLetDeclaration, NeverDeferredTrigger as TmplAstNeverDeferredTrigger, RecursiveVisitor$1 as TmplAstRecursiveVisitor, Reference as TmplAstReference, SwitchBlock as TmplAstSwitchBlock, SwitchBlockCase as TmplAstSwitchBlockCase, Template as TmplAstTemplate, Text$3 as TmplAstText, TextAttribute as TmplAstTextAttribute, TimerDeferredTrigger as TmplAstTimerDeferredTrigger, UnknownBlock as TmplAstUnknownBlock, Variable as TmplAstVariable, ViewportDeferredTrigger as TmplAstViewportDeferredTrigger, Token, TokenType, TransplantedType, TreeError, Type, TypeModifier, TypeofExpr, TypeofExpression, Unary, UnaryOperator, UnaryOperatorExpr, VERSION, VariableBinding, Version, ViewEncapsulation$1 as ViewEncapsulation, VoidExpr, VoidExpression, WrappedNodeExpr, Xliff, Xliff2, Xmb, XmlParser, Xtb, _ATTR_TO_PROP, compileClassDebugInfo, compileClassMetadata, compileComponentClassMetadata, compileComponentDeclareClassMetadata, compileComponentFromMetadata, compileDeclareClassMetadata, compileDeclareComponentFromMetadata, compileDeclareDirectiveFromMetadata, compileDeclareFactoryFunction, compileDeclareInjectableFromMetadata, compileDeclareInjectorFromMetadata, compileDeclareNgModuleFromMetadata, compileDeclarePipeFromMetadata, compileDeferResolverFunction, compileDirectiveFromMetadata, compileFactoryFunction, compileHmrInitializer, compileHmrUpdateCallback, compileInjectable, compileInjector, compileNgModule, compileOpaqueAsyncClassMetadata, compilePipeFromMetadata, computeMsgId, core, createCssSelectorFromNode, createInjectableType, createMayBeForwardRefExpression, devOnlyGuardedExpression, emitDistinctChangesOnlyDefaultValue, encapsulateStyle, escapeRegExp, findMatchingDirectivesAndPipes, getHtmlTagDefinition, getNsPrefix, getSafePropertyAccessString, identifierName, isNgContainer, isNgContent, isNgTemplate, jsDocComment, leadingComment, literal, literalMap, makeBindingParser, mergeNsAndName, output_ast as outputAst, parseHostBindings, parseTemplate, preserveWhitespacesDefault, publishFacade, r3JitTypeSourceSpan, sanitizeIdentifier, setEnableTemplateSourceLocations, splitNsName, visitAll$1 as tmplAstVisitAll, verifyHostBindings, visitAll };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,gBAAgB,GAAG,IAAIC,MAAM,CAAC,cAAc,GAAG,uBAAuB,GAAG,0DAA0D,GAAG,QAAQ,GAAG,aAAa,EAAE,GAAG,CAAC;AAC1K,MAAMC,WAAW,CAAC;EAChBC,OAAO,GAAG,IAAI;EACdC,UAAU,GAAG,EAAE;EACfC,KAAK,GAAG,EAAE;EACVC,YAAY,GAAG,EAAE;EACjB,OAAOC,KAAKA,CAACC,QAAQ,EAAE;IACrB,MAAMC,OAAO,GAAG,EAAE;IAClB,MAAMC,UAAU,GAAGA,CAACC,GAAG,EAAEC,MAAM,KAAK;MAClC,IAAIA,MAAM,CAACN,YAAY,CAACO,MAAM,GAAG,CAAC,IAAI,CAACD,MAAM,CAACT,OAAO,IAAIS,MAAM,CAACR,UAAU,CAACS,MAAM,IAAI,CAAC,IAAID,MAAM,CAACP,KAAK,CAACQ,MAAM,IAAI,CAAC,EAAE;QAClHD,MAAM,CAACT,OAAO,GAAG,GAAG;MACtB;MACAQ,GAAG,CAACG,IAAI,CAACF,MAAM,CAAC;IAClB,CAAC;IACD,IAAIG,WAAW,GAAG,IAAIb,WAAW,CAAC,CAAC;IACnC,IAAIc,KAAK;IACT,IAAIC,OAAO,GAAGF,WAAW;IACzB,IAAIG,KAAK,GAAG,KAAK;IACjBlB,gBAAgB,CAACmB,SAAS,GAAG,CAAC;IAC9B,OAAOH,KAAK,GAAGhB,gBAAgB,CAACoB,IAAI,CAACZ,QAAQ,CAAC,EAAE;MAC9C,IAAIQ,KAAK,CAAC,CAAC,CAAC,EAAE;QACZ,IAAIE,KAAK,EAAE;UACT,MAAM,IAAIG,KAAK,CAAC,2CAA2C,CAAC;QAC9D;QACAH,KAAK,GAAG,IAAI;QACZD,OAAO,GAAG,IAAIf,WAAW,CAAC,CAAC;QAC3Ba,WAAW,CAACT,YAAY,CAACQ,IAAI,CAACG,OAAO,CAAC;MACxC;MACA,MAAMK,GAAG,GAAGN,KAAK,CAAC,CAAC,CAAC;MACpB,IAAIM,GAAG,EAAE;QACP,MAAMC,MAAM,GAAGP,KAAK,CAAC,CAAC,CAAC;QACvB,IAAIO,MAAM,KAAK,GAAG,EAAE;UAClBN,OAAO,CAACO,YAAY,CAAC,IAAI,EAAEF,GAAG,CAACG,KAAK,CAAC,CAAC,CAAC,CAAC;QAC1C,CAAC,MAAM,IAAIF,MAAM,KAAK,GAAG,EAAE;UACzBN,OAAO,CAACS,YAAY,CAACJ,GAAG,CAACG,KAAK,CAAC,CAAC,CAAC,CAAC;QACpC,CAAC,MAAM;UACLR,OAAO,CAACU,UAAU,CAACL,GAAG,CAAC;QACzB;MACF;MACA,MAAMM,SAAS,GAAGZ,KAAK,CAAC,CAAC,CAAC;MAC1B,IAAIY,SAAS,EAAE;QACbX,OAAO,CAACO,YAAY,CAACP,OAAO,CAACY,iBAAiB,CAACD,SAAS,CAAC,EAAEZ,KAAK,CAAC,CAAC,CAAC,CAAC;MACtE;MACA,IAAIA,KAAK,CAAC,CAAC,CAAC,EAAE;QACZE,KAAK,GAAG,KAAK;QACbD,OAAO,GAAGF,WAAW;MACvB;MACA,IAAIC,KAAK,CAAC,CAAC,CAAC,EAAE;QACZ,IAAIE,KAAK,EAAE;UACT,MAAM,IAAIG,KAAK,CAAC,8CAA8C,CAAC;QACjE;QACAX,UAAU,CAACD,OAAO,EAAEM,WAAW,CAAC;QAChCA,WAAW,GAAGE,OAAO,GAAG,IAAIf,WAAW,CAAC,CAAC;MAC3C;IACF;IACAQ,UAAU,CAACD,OAAO,EAAEM,WAAW,CAAC;IAChC,OAAON,OAAO;EAChB;EACAoB,iBAAiBA,CAACC,IAAI,EAAE;IACtB,IAAIC,MAAM,GAAG,EAAE;IACf,IAAIC,QAAQ,GAAG,KAAK;IACpB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,IAAI,CAACjB,MAAM,EAAEoB,CAAC,EAAE,EAAE;MACpC,MAAMC,IAAI,GAAGJ,IAAI,CAACK,MAAM,CAACF,CAAC,CAAC;MAC3B,IAAIC,IAAI,KAAK,IAAI,EAAE;QACjBF,QAAQ,GAAG,IAAI;QACf;MACF;MACA,IAAIE,IAAI,KAAK,GAAG,IAAI,CAACF,QAAQ,EAAE;QAC7B,MAAM,IAAIX,KAAK,CAAC,gCAAgCS,IAAI,KAAK,GAAG,2DAA2D,CAAC;MAC1H;MACAE,QAAQ,GAAG,KAAK;MAChBD,MAAM,IAAIG,IAAI;IAChB;IACA,OAAOH,MAAM;EACf;EACAK,eAAeA,CAACN,IAAI,EAAE;IACpB,OAAOA,IAAI,CAACO,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC,CAACA,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC;EAC1D;EACAC,iBAAiBA,CAAA,EAAG;IAClB,OAAO,IAAI,CAACC,kBAAkB,CAAC,CAAC,IAAI,IAAI,CAACnC,UAAU,CAACS,MAAM,IAAI,CAAC,IAAI,IAAI,CAACR,KAAK,CAACQ,MAAM,IAAI,CAAC,IAAI,IAAI,CAACP,YAAY,CAACO,MAAM,KAAK,CAAC;EAC7H;EACA0B,kBAAkBA,CAAA,EAAG;IACnB,OAAO,CAAC,CAAC,IAAI,CAACpC,OAAO;EACvB;EACAwB,UAAUA,CAACxB,OAAO,GAAG,IAAI,EAAE;IACzB,IAAI,CAACA,OAAO,GAAGA,OAAO;EACxB;EACAqC,QAAQA,CAAA,EAAG;IACT,MAAMT,MAAM,GAAG,EAAE;IACjB,IAAI,IAAI,CAAC3B,UAAU,CAACS,MAAM,GAAG,CAAC,EAAE;MAC9BkB,MAAM,CAACjB,IAAI,CAAC,OAAO,EAAE,IAAI,CAACV,UAAU,CAACqC,IAAI,CAAC,GAAG,CAAC,CAAC;IACjD;IACA,OAAOV,MAAM,CAACW,MAAM,CAAC,IAAI,CAACrC,KAAK,CAAC;EAClC;EACAmB,YAAYA,CAACmB,IAAI,EAAEC,KAAK,GAAG,EAAE,EAAE;IAC7B,IAAI,CAACvC,KAAK,CAACS,IAAI,CAAC6B,IAAI,EAAEC,KAAK,IAAIA,KAAK,CAACC,WAAW,CAAC,CAAC,IAAI,EAAE,CAAC;EAC3D;EACAnB,YAAYA,CAACiB,IAAI,EAAE;IACjB,IAAI,CAACvC,UAAU,CAACU,IAAI,CAAC6B,IAAI,CAACE,WAAW,CAAC,CAAC,CAAC;EAC1C;EACAC,QAAQA,CAAA,EAAG;IACT,IAAInC,GAAG,GAAG,IAAI,CAACR,OAAO,IAAI,EAAE;IAC5B,IAAI,IAAI,CAACC,UAAU,EAAE;MACnB,IAAI,CAACA,UAAU,CAAC2C,OAAO,CAACC,KAAK,IAAIrC,GAAG,IAAI,IAAIqC,KAAK,EAAE,CAAC;IACtD;IACA,IAAI,IAAI,CAAC3C,KAAK,EAAE;MACd,KAAK,IAAI4B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC5B,KAAK,CAACQ,MAAM,EAAEoB,CAAC,IAAI,CAAC,EAAE;QAC7C,MAAMU,IAAI,GAAG,IAAI,CAACP,eAAe,CAAC,IAAI,CAAC/B,KAAK,CAAC4B,CAAC,CAAC,CAAC;QAChD,MAAMW,KAAK,GAAG,IAAI,CAACvC,KAAK,CAAC4B,CAAC,GAAG,CAAC,CAAC;QAC/BtB,GAAG,IAAI,IAAIgC,IAAI,GAAGC,KAAK,GAAG,GAAG,GAAGA,KAAK,GAAG,EAAE,GAAG;MAC/C;IACF;IACA,IAAI,CAACtC,YAAY,CAACyC,OAAO,CAACE,WAAW,IAAItC,GAAG,IAAI,QAAQsC,WAAW,GAAG,CAAC;IACvE,OAAOtC,GAAG;EACZ;AACF;AACA,MAAMuC,eAAe,CAAC;EACpB,OAAOC,gBAAgBA,CAAC7C,YAAY,EAAE;IACpC,MAAM8C,UAAU,GAAG,IAAIF,eAAe,CAAC,CAAC;IACxCE,UAAU,CAACC,cAAc,CAAC/C,YAAY,EAAE,IAAI,CAAC;IAC7C,OAAO8C,UAAU;EACnB;EACAE,WAAW,GAAG,IAAIC,GAAG,CAAC,CAAC;EACvBC,kBAAkB,GAAG,IAAID,GAAG,CAAC,CAAC;EAC9BE,SAAS,GAAG,IAAIF,GAAG,CAAC,CAAC;EACrBG,gBAAgB,GAAG,IAAIH,GAAG,CAAC,CAAC;EAC5BI,aAAa,GAAG,IAAIJ,GAAG,CAAC,CAAC;EACzBK,oBAAoB,GAAG,IAAIL,GAAG,CAAC,CAAC;EAChCM,aAAa,GAAG,EAAE;EAClBR,cAAcA,CAACS,YAAY,EAAEC,YAAY,EAAE;IACzC,IAAIC,WAAW,GAAG,IAAI;IACtB,IAAIF,YAAY,CAACjD,MAAM,GAAG,CAAC,EAAE;MAC3BmD,WAAW,GAAG,IAAIC,mBAAmB,CAACH,YAAY,CAAC;MACnD,IAAI,CAACD,aAAa,CAAC/C,IAAI,CAACkD,WAAW,CAAC;IACtC;IACA,KAAK,IAAI/B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6B,YAAY,CAACjD,MAAM,EAAEoB,CAAC,EAAE,EAAE;MAC5C,IAAI,CAACiC,cAAc,CAACJ,YAAY,CAAC7B,CAAC,CAAC,EAAE8B,YAAY,EAAEC,WAAW,CAAC;IACjE;EACF;EACAE,cAAcA,CAACnD,WAAW,EAAEgD,YAAY,EAAEC,WAAW,EAAE;IACrD,IAAIG,OAAO,GAAG,IAAI;IAClB,MAAMhE,OAAO,GAAGY,WAAW,CAACZ,OAAO;IACnC,MAAMC,UAAU,GAAGW,WAAW,CAACX,UAAU;IACzC,MAAMC,KAAK,GAAGU,WAAW,CAACV,KAAK;IAC/B,MAAM+D,UAAU,GAAG,IAAIC,eAAe,CAACtD,WAAW,EAAEgD,YAAY,EAAEC,WAAW,CAAC;IAC9E,IAAI7D,OAAO,EAAE;MACX,MAAMmE,UAAU,GAAGjE,KAAK,CAACQ,MAAM,KAAK,CAAC,IAAIT,UAAU,CAACS,MAAM,KAAK,CAAC;MAChE,IAAIyD,UAAU,EAAE;QACd,IAAI,CAACC,YAAY,CAACJ,OAAO,CAACb,WAAW,EAAEnD,OAAO,EAAEiE,UAAU,CAAC;MAC7D,CAAC,MAAM;QACLD,OAAO,GAAG,IAAI,CAACK,WAAW,CAACL,OAAO,CAACX,kBAAkB,EAAErD,OAAO,CAAC;MACjE;IACF;IACA,IAAIC,UAAU,EAAE;MACd,KAAK,IAAI6B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,UAAU,CAACS,MAAM,EAAEoB,CAAC,EAAE,EAAE;QAC1C,MAAMqC,UAAU,GAAGjE,KAAK,CAACQ,MAAM,KAAK,CAAC,IAAIoB,CAAC,KAAK7B,UAAU,CAACS,MAAM,GAAG,CAAC;QACpE,MAAM4D,SAAS,GAAGrE,UAAU,CAAC6B,CAAC,CAAC;QAC/B,IAAIqC,UAAU,EAAE;UACd,IAAI,CAACC,YAAY,CAACJ,OAAO,CAACV,SAAS,EAAEgB,SAAS,EAAEL,UAAU,CAAC;QAC7D,CAAC,MAAM;UACLD,OAAO,GAAG,IAAI,CAACK,WAAW,CAACL,OAAO,CAACT,gBAAgB,EAAEe,SAAS,CAAC;QACjE;MACF;IACF;IACA,IAAIpE,KAAK,EAAE;MACT,KAAK,IAAI4B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5B,KAAK,CAACQ,MAAM,EAAEoB,CAAC,IAAI,CAAC,EAAE;QACxC,MAAMqC,UAAU,GAAGrC,CAAC,KAAK5B,KAAK,CAACQ,MAAM,GAAG,CAAC;QACzC,MAAM8B,IAAI,GAAGtC,KAAK,CAAC4B,CAAC,CAAC;QACrB,MAAMW,KAAK,GAAGvC,KAAK,CAAC4B,CAAC,GAAG,CAAC,CAAC;QAC1B,IAAIqC,UAAU,EAAE;UACd,MAAMI,WAAW,GAAGP,OAAO,CAACR,aAAa;UACzC,IAAIgB,iBAAiB,GAAGD,WAAW,CAACE,GAAG,CAACjC,IAAI,CAAC;UAC7C,IAAI,CAACgC,iBAAiB,EAAE;YACtBA,iBAAiB,GAAG,IAAIpB,GAAG,CAAC,CAAC;YAC7BmB,WAAW,CAACG,GAAG,CAAClC,IAAI,EAAEgC,iBAAiB,CAAC;UAC1C;UACA,IAAI,CAACJ,YAAY,CAACI,iBAAiB,EAAE/B,KAAK,EAAEwB,UAAU,CAAC;QACzD,CAAC,MAAM;UACL,MAAMU,UAAU,GAAGX,OAAO,CAACP,oBAAoB;UAC/C,IAAImB,gBAAgB,GAAGD,UAAU,CAACF,GAAG,CAACjC,IAAI,CAAC;UAC3C,IAAI,CAACoC,gBAAgB,EAAE;YACrBA,gBAAgB,GAAG,IAAIxB,GAAG,CAAC,CAAC;YAC5BuB,UAAU,CAACD,GAAG,CAAClC,IAAI,EAAEoC,gBAAgB,CAAC;UACxC;UACAZ,OAAO,GAAG,IAAI,CAACK,WAAW,CAACO,gBAAgB,EAAEnC,KAAK,CAAC;QACrD;MACF;IACF;EACF;EACA2B,YAAYA,CAACS,GAAG,EAAErC,IAAI,EAAEyB,UAAU,EAAE;IAClC,IAAIa,YAAY,GAAGD,GAAG,CAACJ,GAAG,CAACjC,IAAI,CAAC;IAChC,IAAI,CAACsC,YAAY,EAAE;MACjBA,YAAY,GAAG,EAAE;MACjBD,GAAG,CAACH,GAAG,CAAClC,IAAI,EAAEsC,YAAY,CAAC;IAC7B;IACAA,YAAY,CAACnE,IAAI,CAACsD,UAAU,CAAC;EAC/B;EACAI,WAAWA,CAACQ,GAAG,EAAErC,IAAI,EAAE;IACrB,IAAIwB,OAAO,GAAGa,GAAG,CAACJ,GAAG,CAACjC,IAAI,CAAC;IAC3B,IAAI,CAACwB,OAAO,EAAE;MACZA,OAAO,GAAG,IAAIjB,eAAe,CAAC,CAAC;MAC/B8B,GAAG,CAACH,GAAG,CAAClC,IAAI,EAAEwB,OAAO,CAAC;IACxB;IACA,OAAOA,OAAO;EAChB;EACAnD,KAAKA,CAACD,WAAW,EAAEmE,eAAe,EAAE;IAClC,IAAInD,MAAM,GAAG,KAAK;IAClB,MAAM5B,OAAO,GAAGY,WAAW,CAACZ,OAAO;IACnC,MAAMC,UAAU,GAAGW,WAAW,CAACX,UAAU;IACzC,MAAMC,KAAK,GAAGU,WAAW,CAACV,KAAK;IAC/B,KAAK,IAAI4B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC4B,aAAa,CAAChD,MAAM,EAAEoB,CAAC,EAAE,EAAE;MAClD,IAAI,CAAC4B,aAAa,CAAC5B,CAAC,CAAC,CAACkD,cAAc,GAAG,KAAK;IAC9C;IACApD,MAAM,GAAG,IAAI,CAACqD,cAAc,CAAC,IAAI,CAAC9B,WAAW,EAAEnD,OAAO,EAAEY,WAAW,EAAEmE,eAAe,CAAC,IAAInD,MAAM;IAC/FA,MAAM,GAAG,IAAI,CAACsD,aAAa,CAAC,IAAI,CAAC7B,kBAAkB,EAAErD,OAAO,EAAEY,WAAW,EAAEmE,eAAe,CAAC,IAAInD,MAAM;IACrG,IAAI3B,UAAU,EAAE;MACd,KAAK,IAAI6B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,UAAU,CAACS,MAAM,EAAEoB,CAAC,EAAE,EAAE;QAC1C,MAAMwC,SAAS,GAAGrE,UAAU,CAAC6B,CAAC,CAAC;QAC/BF,MAAM,GAAG,IAAI,CAACqD,cAAc,CAAC,IAAI,CAAC3B,SAAS,EAAEgB,SAAS,EAAE1D,WAAW,EAAEmE,eAAe,CAAC,IAAInD,MAAM;QAC/FA,MAAM,GAAG,IAAI,CAACsD,aAAa,CAAC,IAAI,CAAC3B,gBAAgB,EAAEe,SAAS,EAAE1D,WAAW,EAAEmE,eAAe,CAAC,IAAInD,MAAM;MACvG;IACF;IACA,IAAI1B,KAAK,EAAE;MACT,KAAK,IAAI4B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5B,KAAK,CAACQ,MAAM,EAAEoB,CAAC,IAAI,CAAC,EAAE;QACxC,MAAMU,IAAI,GAAGtC,KAAK,CAAC4B,CAAC,CAAC;QACrB,MAAMW,KAAK,GAAGvC,KAAK,CAAC4B,CAAC,GAAG,CAAC,CAAC;QAC1B,MAAM0C,iBAAiB,GAAG,IAAI,CAAChB,aAAa,CAACiB,GAAG,CAACjC,IAAI,CAAC;QACtD,IAAIC,KAAK,EAAE;UACTb,MAAM,GAAG,IAAI,CAACqD,cAAc,CAACT,iBAAiB,EAAE,EAAE,EAAE5D,WAAW,EAAEmE,eAAe,CAAC,IAAInD,MAAM;QAC7F;QACAA,MAAM,GAAG,IAAI,CAACqD,cAAc,CAACT,iBAAiB,EAAE/B,KAAK,EAAE7B,WAAW,EAAEmE,eAAe,CAAC,IAAInD,MAAM;QAC9F,MAAMgD,gBAAgB,GAAG,IAAI,CAACnB,oBAAoB,CAACgB,GAAG,CAACjC,IAAI,CAAC;QAC5D,IAAIC,KAAK,EAAE;UACTb,MAAM,GAAG,IAAI,CAACsD,aAAa,CAACN,gBAAgB,EAAE,EAAE,EAAEhE,WAAW,EAAEmE,eAAe,CAAC,IAAInD,MAAM;QAC3F;QACAA,MAAM,GAAG,IAAI,CAACsD,aAAa,CAACN,gBAAgB,EAAEnC,KAAK,EAAE7B,WAAW,EAAEmE,eAAe,CAAC,IAAInD,MAAM;MAC9F;IACF;IACA,OAAOA,MAAM;EACf;EACAqD,cAAcA,CAACJ,GAAG,EAAErC,IAAI,EAAE5B,WAAW,EAAEmE,eAAe,EAAE;IACtD,IAAI,CAACF,GAAG,IAAI,OAAOrC,IAAI,KAAK,QAAQ,EAAE;MACpC,OAAO,KAAK;IACd;IACA,IAAI2C,WAAW,GAAGN,GAAG,CAACJ,GAAG,CAACjC,IAAI,CAAC,IAAI,EAAE;IACrC,MAAM4C,eAAe,GAAGP,GAAG,CAACJ,GAAG,CAAC,GAAG,CAAC;IACpC,IAAIW,eAAe,EAAE;MACnBD,WAAW,GAAGA,WAAW,CAAC5C,MAAM,CAAC6C,eAAe,CAAC;IACnD;IACA,IAAID,WAAW,CAACzE,MAAM,KAAK,CAAC,EAAE;MAC5B,OAAO,KAAK;IACd;IACA,IAAIuD,UAAU;IACd,IAAIrC,MAAM,GAAG,KAAK;IAClB,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqD,WAAW,CAACzE,MAAM,EAAEoB,CAAC,EAAE,EAAE;MAC3CmC,UAAU,GAAGkB,WAAW,CAACrD,CAAC,CAAC;MAC3BF,MAAM,GAAGqC,UAAU,CAACoB,QAAQ,CAACzE,WAAW,EAAEmE,eAAe,CAAC,IAAInD,MAAM;IACtE;IACA,OAAOA,MAAM;EACf;EACAsD,aAAaA,CAACL,GAAG,EAAErC,IAAI,EAAE5B,WAAW,EAAEmE,eAAe,EAAE;IACrD,IAAI,CAACF,GAAG,IAAI,OAAOrC,IAAI,KAAK,QAAQ,EAAE;MACpC,OAAO,KAAK;IACd;IACA,MAAM8C,cAAc,GAAGT,GAAG,CAACJ,GAAG,CAACjC,IAAI,CAAC;IACpC,IAAI,CAAC8C,cAAc,EAAE;MACnB,OAAO,KAAK;IACd;IACA,OAAOA,cAAc,CAACzE,KAAK,CAACD,WAAW,EAAEmE,eAAe,CAAC;EAC3D;AACF;AACA,MAAMjB,mBAAmB,CAAC;EACxByB,SAAS;EACTP,cAAc,GAAG,KAAK;EACtBQ,WAAWA,CAACD,SAAS,EAAE;IACrB,IAAI,CAACA,SAAS,GAAGA,SAAS;EAC5B;AACF;AACA,MAAMrB,eAAe,CAAC;EACpB7D,QAAQ;EACRoF,SAAS;EACT5B,WAAW;EACX1D,YAAY;EACZqF,WAAWA,CAACnF,QAAQ,EAAEoF,SAAS,EAAE5B,WAAW,EAAE;IAC5C,IAAI,CAACxD,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACoF,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAAC5B,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAAC1D,YAAY,GAAGE,QAAQ,CAACF,YAAY;EAC3C;EACAkF,QAAQA,CAACzE,WAAW,EAAE8E,QAAQ,EAAE;IAC9B,IAAI9D,MAAM,GAAG,IAAI;IACjB,IAAI,IAAI,CAACzB,YAAY,CAACO,MAAM,GAAG,CAAC,KAAK,CAAC,IAAI,CAACmD,WAAW,IAAI,CAAC,IAAI,CAACA,WAAW,CAACmB,cAAc,CAAC,EAAE;MAC3F,MAAM/B,UAAU,GAAGF,eAAe,CAACC,gBAAgB,CAAC,IAAI,CAAC7C,YAAY,CAAC;MACtEyB,MAAM,GAAG,CAACqB,UAAU,CAACpC,KAAK,CAACD,WAAW,EAAE,IAAI,CAAC;IAC/C;IACA,IAAIgB,MAAM,IAAI8D,QAAQ,KAAK,CAAC,IAAI,CAAC7B,WAAW,IAAI,CAAC,IAAI,CAACA,WAAW,CAACmB,cAAc,CAAC,EAAE;MACjF,IAAI,IAAI,CAACnB,WAAW,EAAE;QACpB,IAAI,CAACA,WAAW,CAACmB,cAAc,GAAG,IAAI;MACxC;MACAU,QAAQ,CAAC,IAAI,CAACrF,QAAQ,EAAE,IAAI,CAACoF,SAAS,CAAC;IACzC;IACA,OAAO7D,MAAM;EACf;AACF;AACA,MAAM+D,mBAAmB,CAAC;EACxBC,QAAQ;EACRJ,WAAWA,CAACI,QAAQ,EAAE;IACpB,IAAI,CAACA,QAAQ,GAAGA,QAAQ;EAC1B;EACA/E,KAAKA,CAAC2B,IAAI,EAAE;IACV,OAAO,IAAI,CAACoD,QAAQ,CAACC,GAAG,CAACrD,IAAI,CAAC,GAAG,IAAI,CAACoD,QAAQ,CAACnB,GAAG,CAACjC,IAAI,CAAC,GAAG,EAAE;EAC/D;AACF;AAEA,MAAMsD,mCAAmC,GAAG,IAAI;AAChD,IAAIC,mBAAmB;AACvB,CAAC,UAAUC,iBAAiB,EAAE;EAC5BA,iBAAiB,CAACA,iBAAiB,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EACjEA,iBAAiB,CAACA,iBAAiB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EACzDA,iBAAiB,CAACA,iBAAiB,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;EACnEA,iBAAiB,CAACA,iBAAiB,CAAC,+BAA+B,CAAC,GAAG,CAAC,CAAC,GAAG,+BAA+B;AAC7G,CAAC,EAAED,mBAAmB,KAAKA,mBAAmB,GAAG,CAAC,CAAC,CAAC,CAAC;AACrD,IAAIE,uBAAuB;AAC3B,CAAC,UAAUA,uBAAuB,EAAE;EAClCA,uBAAuB,CAACA,uBAAuB,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;EACzEA,uBAAuB,CAACA,uBAAuB,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;AAC7E,CAAC,EAAEA,uBAAuB,KAAKA,uBAAuB,GAAG,CAAC,CAAC,CAAC,CAAC;AAC7D,IAAIC,UAAU;AACd,CAAC,UAAUA,UAAU,EAAE;EACrBA,UAAU,CAACA,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EAC3CA,UAAU,CAACA,UAAU,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,GAAG,aAAa;EACzDA,UAAU,CAACA,UAAU,CAAC,4BAA4B,CAAC,GAAG,CAAC,CAAC,GAAG,4BAA4B;AACzF,CAAC,EAAEA,UAAU,KAAKA,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC;AACnC,MAAMC,sBAAsB,GAAG;EAC7B3D,IAAI,EAAE;AACR,CAAC;AACD,MAAM4D,gBAAgB,GAAG;EACvB5D,IAAI,EAAE;AACR,CAAC;AACD,MAAM6D,MAAM,GAAGC,QAAQ;AACvB,IAAIC,eAAe;AACnB,CAAC,UAAUA,eAAe,EAAE;EAC1BA,eAAe,CAACA,eAAe,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EACrDA,eAAe,CAACA,eAAe,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EACrDA,eAAe,CAACA,eAAe,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;EACvDA,eAAe,CAACA,eAAe,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;EACzDA,eAAe,CAACA,eAAe,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK;EACnDA,eAAe,CAACA,eAAe,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,GAAG,cAAc;AACvE,CAAC,EAAEA,eAAe,KAAKA,eAAe,GAAG,CAAC,CAAC,CAAC,CAAC;AAC7C,IAAIC,0BAA0B;AAC9B,CAAC,UAAUA,0BAA0B,EAAE;EACrCA,0BAA0B,CAACA,0BAA0B,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;EAC7EA,0BAA0B,CAACA,0BAA0B,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;EACjFA,0BAA0B,CAACA,0BAA0B,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;AACjF,CAAC,EAAEA,0BAA0B,KAAKA,0BAA0B,GAAG,CAAC,CAAC,CAAC,CAAC;AACnE,SAASC,8BAA8BA,CAACpG,QAAQ,EAAE;EAChD,MAAMqG,OAAO,GAAGrG,QAAQ,CAACJ,UAAU,IAAII,QAAQ,CAACJ,UAAU,CAACS,MAAM,GAAG,CAAC,CAAC,EAAE,GAAGL,QAAQ,CAACJ,UAAU,CAAC,GAAG,EAAE;EACpG,MAAM0G,WAAW,GAAGtG,QAAQ,CAACL,OAAO,IAAIK,QAAQ,CAACL,OAAO,KAAK,GAAG,GAAGK,QAAQ,CAACL,OAAO,GAAG,EAAE;EACxF,OAAO,CAAC2G,WAAW,EAAE,GAAGtG,QAAQ,CAACH,KAAK,EAAE,GAAGwG,OAAO,CAAC;AACrD;AACA,SAASE,gCAAgCA,CAACvG,QAAQ,EAAE;EAClD,MAAMqG,OAAO,GAAGrG,QAAQ,CAACJ,UAAU,IAAII,QAAQ,CAACJ,UAAU,CAACS,MAAM,GAAG,CAAC,CAAC,EAAE,GAAGL,QAAQ,CAACJ,UAAU,CAAC,GAAG,EAAE;EACpG,IAAII,QAAQ,CAACL,OAAO,EAAE;IACpB,OAAO,CAAC,CAAC,GAAG,CAAC,EAAEK,QAAQ,CAACL,OAAO,EAAE,GAAGK,QAAQ,CAACH,KAAK,EAAE,GAAGwG,OAAO,CAAC;EACjE,CAAC,MAAM,IAAIrG,QAAQ,CAACH,KAAK,CAACQ,MAAM,EAAE;IAChC,OAAO,CAAC,CAAC,GAAG,CAAC,EAAE,GAAGL,QAAQ,CAACH,KAAK,EAAE,GAAGwG,OAAO,CAAC;EAC/C,CAAC,MAAM;IACL,OAAOrG,QAAQ,CAACJ,UAAU,IAAII,QAAQ,CAACJ,UAAU,CAACS,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,GAAGL,QAAQ,CAACJ,UAAU,CAAC,GAAG,EAAE;EACjG;AACF;AACA,SAAS4G,0BAA0BA,CAACxG,QAAQ,EAAE;EAC5C,MAAMyG,QAAQ,GAAGL,8BAA8B,CAACpG,QAAQ,CAAC;EACzD,MAAM0G,QAAQ,GAAG1G,QAAQ,CAACF,YAAY,IAAIE,QAAQ,CAACF,YAAY,CAACO,MAAM,GAAGL,QAAQ,CAACF,YAAY,CAAC0E,GAAG,CAAC/B,WAAW,IAAI8D,gCAAgC,CAAC9D,WAAW,CAAC,CAAC,GAAG,EAAE;EACrK,OAAOgE,QAAQ,CAACvE,MAAM,CAAC,GAAGwE,QAAQ,CAAC;AACrC;AACA,SAASC,yBAAyBA,CAAC3G,QAAQ,EAAE;EAC3C,OAAOA,QAAQ,GAAGN,WAAW,CAACK,KAAK,CAACC,QAAQ,CAAC,CAACwE,GAAG,CAACgC,0BAA0B,CAAC,GAAG,EAAE;AACpF;AAEA,IAAII,IAAI,GAAG,aAAaC,MAAM,CAACC,MAAM,CAAC;EAClCC,SAAS,EAAE,IAAI;EACfjB,sBAAsB,EAAEA,sBAAsB;EAC9C,IAAIF,uBAAuBA,CAAA,EAAI;IAAE,OAAOA,uBAAuB;EAAE,CAAC;EAClE,IAAIC,UAAUA,CAAA,EAAI;IAAE,OAAOA,UAAU;EAAE,CAAC;EACxC,IAAIM,0BAA0BA,CAAA,EAAI;IAAE,OAAOA,0BAA0B;EAAE,CAAC;EACxEJ,gBAAgB,EAAEA,gBAAgB;EAClC,IAAIG,eAAeA,CAAA,EAAI;IAAE,OAAOA,eAAe;EAAE,CAAC;EAClDc,IAAI,EAAEhB,MAAM;EACZ,IAAIL,iBAAiBA,CAAA,EAAI;IAAE,OAAOD,mBAAmB;EAAE,CAAC;EACxDD,mCAAmC,EAAEA,mCAAmC;EACxEkB,yBAAyB,EAAEA;AAC/B,CAAC,CAAC;AAEF,IAAIM,aAAa;AACjB,CAAC,UAAUA,aAAa,EAAE;EACxBA,aAAa,CAACA,aAAa,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;EAC3DA,aAAa,CAACA,aAAa,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;EAC3DA,aAAa,CAACA,aAAa,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,GAAG,YAAY;EAC7DA,aAAa,CAACA,aAAa,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EACjDA,aAAa,CAACA,aAAa,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;AAC3D,CAAC,EAAEA,aAAa,KAAKA,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC;AACzC,IAAIC,0BAA0B;AAC9B,CAAC,UAAUC,wBAAwB,EAAE;EACnCA,wBAAwB,CAACA,wBAAwB,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;EACjFA,wBAAwB,CAACA,wBAAwB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EACvEA,wBAAwB,CAACA,wBAAwB,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;AACjF,CAAC,EAAED,0BAA0B,KAAKA,0BAA0B,GAAG,CAAC,CAAC,CAAC,CAAC;AACnE,IAAIvB,iBAAiB;AACrB,CAAC,UAAUA,iBAAiB,EAAE;EAC5BA,iBAAiB,CAACA,iBAAiB,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EACjEA,iBAAiB,CAACA,iBAAiB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EACzDA,iBAAiB,CAACA,iBAAiB,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;EACnEA,iBAAiB,CAACA,iBAAiB,CAAC,+BAA+B,CAAC,GAAG,CAAC,CAAC,GAAG,+BAA+B;AAC7G,CAAC,EAAEA,iBAAiB,KAAKA,iBAAiB,GAAG,CAAC,CAAC,CAAC,CAAC;AAEjD,IAAIyB,WAAW;AACf,SAASC,QAAQA,CAACC,OAAO,EAAE;EACzB,OAAOA,OAAO,CAACC,EAAE,IAAIC,aAAa,CAACF,OAAO,CAAC;AAC7C;AACA,SAASE,aAAaA,CAACF,OAAO,EAAE;EAC9B,OAAOG,IAAI,CAACC,cAAc,CAACJ,OAAO,CAACK,KAAK,CAAC,CAAC1F,IAAI,CAAC,EAAE,CAAC,GAAG,IAAIqF,OAAO,CAACM,OAAO,GAAG,CAAC;AAC9E;AACA,SAASC,aAAaA,CAACP,OAAO,EAAE;EAC9B,OAAOA,OAAO,CAACC,EAAE,IAAIO,oBAAoB,CAACR,OAAO,CAAC;AACpD;AACA,SAASQ,oBAAoBA,CAACR,OAAO,EAAE;EACrC,MAAMS,OAAO,GAAG,IAAIC,8BAA8B,CAAC,CAAC;EACpD,MAAMC,KAAK,GAAGX,OAAO,CAACK,KAAK,CAACnD,GAAG,CAAC0D,CAAC,IAAIA,CAAC,CAACC,KAAK,CAACJ,OAAO,EAAE,IAAI,CAAC,CAAC;EAC5D,OAAOK,YAAY,CAACH,KAAK,CAAChG,IAAI,CAAC,EAAE,CAAC,EAAEqF,OAAO,CAACM,OAAO,CAAC;AACtD;AACA,MAAMS,kBAAkB,CAAC;EACvBC,SAASA,CAACC,IAAI,EAAEC,OAAO,EAAE;IACvB,OAAOD,IAAI,CAACnG,KAAK;EACnB;EACAqG,cAAcA,CAACC,SAAS,EAAEF,OAAO,EAAE;IACjC,OAAO,IAAIE,SAAS,CAACC,QAAQ,CAACnE,GAAG,CAACoE,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC,CAAClG,IAAI,CAAC,IAAI,CAAC,GAAG;EAC7E;EACA4G,QAAQA,CAACC,GAAG,EAAEN,OAAO,EAAE;IACrB,MAAMO,QAAQ,GAAGlC,MAAM,CAACmC,IAAI,CAACF,GAAG,CAACG,KAAK,CAAC,CAACzE,GAAG,CAAC0E,CAAC,IAAI,GAAGA,CAAC,KAAKJ,GAAG,CAACG,KAAK,CAACC,CAAC,CAAC,CAACf,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC;IACtF,OAAO,IAAIW,GAAG,CAACK,UAAU,KAAKL,GAAG,CAACM,IAAI,KAAKL,QAAQ,CAAC9G,IAAI,CAAC,IAAI,CAAC,GAAG;EACnE;EACAoH,mBAAmBA,CAACC,EAAE,EAAEd,OAAO,EAAE;IAC/B,OAAOc,EAAE,CAACC,MAAM,GAAG,iBAAiBD,EAAE,CAACE,SAAS,KAAK,GAAG,iBAAiBF,EAAE,CAACE,SAAS,KAAKF,EAAE,CAACX,QAAQ,CAACnE,GAAG,CAACoE,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC,CAAClG,IAAI,CAAC,IAAI,CAAC,cAAcqH,EAAE,CAACG,SAAS,IAAI;EAChL;EACAC,gBAAgBA,CAACJ,EAAE,EAAEd,OAAO,EAAE;IAC5B,OAAOc,EAAE,CAAClH,KAAK,GAAG,aAAakH,EAAE,CAACnH,IAAI,KAAKmH,EAAE,CAAClH,KAAK,OAAO,GAAG,aAAakH,EAAE,CAACnH,IAAI,KAAK;EACxF;EACAwH,mBAAmBA,CAACL,EAAE,EAAEd,OAAO,EAAE;IAC/B,OAAO,iBAAiBc,EAAE,CAACnH,IAAI,KAAKmH,EAAE,CAAClH,KAAK,CAAC+F,KAAK,CAAC,IAAI,CAAC,OAAO;EACjE;EACAyB,qBAAqBA,CAACN,EAAE,EAAEd,OAAO,EAAE;IACjC,OAAO,mBAAmBc,EAAE,CAACE,SAAS,KAAKF,EAAE,CAACX,QAAQ,CAACnE,GAAG,CAACoE,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC,CAAClG,IAAI,CAAC,IAAI,CAAC,cAAcqH,EAAE,CAACG,SAAS,IAAI;EACjI;AACF;AACA,MAAMI,mBAAmB,GAAG,IAAIxB,kBAAkB,CAAC,CAAC;AACpD,SAASX,cAAcA,CAACC,KAAK,EAAE;EAC7B,OAAOA,KAAK,CAACnD,GAAG,CAAC0D,CAAC,IAAIA,CAAC,CAACC,KAAK,CAAC0B,mBAAmB,EAAE,IAAI,CAAC,CAAC;AAC3D;AACA,MAAM7B,8BAA8B,SAASK,kBAAkB,CAAC;EAC9DQ,QAAQA,CAACC,GAAG,EAAE;IACZ,IAAIC,QAAQ,GAAGlC,MAAM,CAACmC,IAAI,CAACF,GAAG,CAACG,KAAK,CAAC,CAACzE,GAAG,CAAC0E,CAAC,IAAI,GAAGA,CAAC,KAAKJ,GAAG,CAACG,KAAK,CAACC,CAAC,CAAC,CAACf,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC;IACpF,OAAO,IAAIW,GAAG,CAACM,IAAI,KAAKL,QAAQ,CAAC9G,IAAI,CAAC,IAAI,CAAC,GAAG;EAChD;AACF;AACA,SAASwF,IAAIA,CAACqC,GAAG,EAAE;EACjB1C,WAAW,KAAK,IAAI2C,WAAW,CAAC,CAAC;EACjC,MAAMC,IAAI,GAAG,CAAC,GAAG5C,WAAW,CAAC6C,MAAM,CAACH,GAAG,CAAC,CAAC;EACzC,MAAMI,OAAO,GAAGC,cAAc,CAACH,IAAI,EAAEI,MAAM,CAACC,GAAG,CAAC;EAChD,MAAMC,GAAG,GAAGN,IAAI,CAAC3J,MAAM,GAAG,CAAC;EAC3B,MAAMkK,CAAC,GAAG,IAAIC,WAAW,CAAC,EAAE,CAAC;EAC7B,IAAItC,CAAC,GAAG,UAAU;IAChBuC,CAAC,GAAG,UAAU;IACdC,CAAC,GAAG,UAAU;IACdC,CAAC,GAAG,UAAU;IACdC,CAAC,GAAG,UAAU;EAChBV,OAAO,CAACI,GAAG,IAAI,CAAC,CAAC,IAAI,IAAI,IAAI,EAAE,GAAGA,GAAG,GAAG,EAAE;EAC1CJ,OAAO,CAAC,CAACI,GAAG,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,GAAGA,GAAG;EACxC,KAAK,IAAI7I,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyI,OAAO,CAAC7J,MAAM,EAAEoB,CAAC,IAAI,EAAE,EAAE;IAC3C,MAAMoJ,EAAE,GAAG3C,CAAC;MACV4C,EAAE,GAAGL,CAAC;MACNM,EAAE,GAAGL,CAAC;MACNM,EAAE,GAAGL,CAAC;MACNM,EAAE,GAAGL,CAAC;IACR,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAE;MAC3B,IAAIA,CAAC,GAAG,EAAE,EAAE;QACVX,CAAC,CAACW,CAAC,CAAC,GAAGhB,OAAO,CAACzI,CAAC,GAAGyJ,CAAC,CAAC;MACvB,CAAC,MAAM;QACLX,CAAC,CAACW,CAAC,CAAC,GAAGC,KAAK,CAACZ,CAAC,CAACW,CAAC,GAAG,CAAC,CAAC,GAAGX,CAAC,CAACW,CAAC,GAAG,CAAC,CAAC,GAAGX,CAAC,CAACW,CAAC,GAAG,EAAE,CAAC,GAAGX,CAAC,CAACW,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC;MAC9D;MACA,MAAME,KAAK,GAAGC,EAAE,CAACH,CAAC,EAAET,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;MAC5B,MAAMW,CAAC,GAAGF,KAAK,CAAC,CAAC,CAAC;MAClB,MAAMlC,CAAC,GAAGkC,KAAK,CAAC,CAAC,CAAC;MAClB,MAAMG,IAAI,GAAG,CAACJ,KAAK,CAACjD,CAAC,EAAE,CAAC,CAAC,EAAEoD,CAAC,EAAEV,CAAC,EAAE1B,CAAC,EAAEqB,CAAC,CAACW,CAAC,CAAC,CAAC,CAACM,MAAM,CAACC,KAAK,CAAC;MACvDb,CAAC,GAAGD,CAAC;MACLA,CAAC,GAAGD,CAAC;MACLA,CAAC,GAAGS,KAAK,CAACV,CAAC,EAAE,EAAE,CAAC;MAChBA,CAAC,GAAGvC,CAAC;MACLA,CAAC,GAAGqD,IAAI;IACV;IACArD,CAAC,GAAGuD,KAAK,CAACvD,CAAC,EAAE2C,EAAE,CAAC;IAChBJ,CAAC,GAAGgB,KAAK,CAAChB,CAAC,EAAEK,EAAE,CAAC;IAChBJ,CAAC,GAAGe,KAAK,CAACf,CAAC,EAAEK,EAAE,CAAC;IAChBJ,CAAC,GAAGc,KAAK,CAACd,CAAC,EAAEK,EAAE,CAAC;IAChBJ,CAAC,GAAGa,KAAK,CAACb,CAAC,EAAEK,EAAE,CAAC;EAClB;EACA,OAAOS,QAAQ,CAACxD,CAAC,CAAC,GAAGwD,QAAQ,CAACjB,CAAC,CAAC,GAAGiB,QAAQ,CAAChB,CAAC,CAAC,GAAGgB,QAAQ,CAACf,CAAC,CAAC,GAAGe,QAAQ,CAACd,CAAC,CAAC;AAC5E;AACA,SAASc,QAAQA,CAACtJ,KAAK,EAAE;EACvB,OAAO,CAACA,KAAK,KAAK,CAAC,EAAEE,QAAQ,CAAC,EAAE,CAAC,CAACqJ,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;AACpD;AACA,SAASN,EAAEA,CAACO,KAAK,EAAEnB,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;EAC1B,IAAIiB,KAAK,GAAG,EAAE,EAAE;IACd,OAAO,CAACnB,CAAC,GAAGC,CAAC,GAAG,CAACD,CAAC,GAAGE,CAAC,EAAE,UAAU,CAAC;EACrC;EACA,IAAIiB,KAAK,GAAG,EAAE,EAAE;IACd,OAAO,CAACnB,CAAC,GAAGC,CAAC,GAAGC,CAAC,EAAE,UAAU,CAAC;EAChC;EACA,IAAIiB,KAAK,GAAG,EAAE,EAAE;IACd,OAAO,CAACnB,CAAC,GAAGC,CAAC,GAAGD,CAAC,GAAGE,CAAC,GAAGD,CAAC,GAAGC,CAAC,EAAE,UAAU,CAAC;EAC5C;EACA,OAAO,CAACF,CAAC,GAAGC,CAAC,GAAGC,CAAC,EAAE,UAAU,CAAC;AAChC;AACA,SAASkB,WAAWA,CAAC/B,GAAG,EAAE;EACxB1C,WAAW,KAAK,IAAI2C,WAAW,CAAC,CAAC;EACjC,MAAMC,IAAI,GAAG5C,WAAW,CAAC6C,MAAM,CAACH,GAAG,CAAC;EACpC,MAAMgC,IAAI,GAAG,IAAIC,QAAQ,CAAC/B,IAAI,CAACgC,MAAM,EAAEhC,IAAI,CAACiC,UAAU,EAAEjC,IAAI,CAACkC,UAAU,CAAC;EACxE,IAAIC,EAAE,GAAGC,MAAM,CAACN,IAAI,EAAE9B,IAAI,CAAC3J,MAAM,EAAE,CAAC,CAAC;EACrC,IAAIgM,EAAE,GAAGD,MAAM,CAACN,IAAI,EAAE9B,IAAI,CAAC3J,MAAM,EAAE,MAAM,CAAC;EAC1C,IAAI8L,EAAE,IAAI,CAAC,KAAKE,EAAE,IAAI,CAAC,IAAIA,EAAE,IAAI,CAAC,CAAC,EAAE;IACnCF,EAAE,GAAGA,EAAE,GAAG,UAAU;IACpBE,EAAE,GAAGA,EAAE,GAAG,CAAC,UAAU;EACvB;EACA,OAAOC,MAAM,CAACC,OAAO,CAAC,EAAE,EAAED,MAAM,CAACH,EAAE,CAAC,CAAC,IAAIG,MAAM,CAAC,EAAE,CAAC,GAAGA,MAAM,CAACC,OAAO,CAAC,EAAE,EAAED,MAAM,CAACD,EAAE,CAAC,CAAC;AACtF;AACA,SAASjE,YAAYA,CAACoE,GAAG,EAAE5E,OAAO,GAAG,EAAE,EAAE;EACvC,IAAI6E,cAAc,GAAGZ,WAAW,CAACW,GAAG,CAAC;EACrC,IAAI5E,OAAO,EAAE;IACX6E,cAAc,GAAGH,MAAM,CAACC,OAAO,CAAC,EAAE,EAAEE,cAAc,IAAIH,MAAM,CAAC,CAAC,CAAC,CAAC,GAAGG,cAAc,IAAIH,MAAM,CAAC,EAAE,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC;IAC3GG,cAAc,IAAIZ,WAAW,CAACjE,OAAO,CAAC;EACxC;EACA,OAAO0E,MAAM,CAACC,OAAO,CAAC,EAAE,EAAEE,cAAc,CAAC,CAACnK,QAAQ,CAAC,CAAC;AACtD;AACA,SAAS8J,MAAMA,CAACN,IAAI,EAAEzL,MAAM,EAAEqK,CAAC,EAAE;EAC/B,IAAIxC,CAAC,GAAG,UAAU;IAChBuC,CAAC,GAAG,UAAU;EAChB,IAAImB,KAAK,GAAG,CAAC;EACb,MAAMc,GAAG,GAAGrM,MAAM,GAAG,EAAE;EACvB,OAAOuL,KAAK,IAAIc,GAAG,EAAEd,KAAK,IAAI,EAAE,EAAE;IAChC1D,CAAC,IAAI4D,IAAI,CAACa,SAAS,CAACf,KAAK,EAAE,IAAI,CAAC;IAChCnB,CAAC,IAAIqB,IAAI,CAACa,SAAS,CAACf,KAAK,GAAG,CAAC,EAAE,IAAI,CAAC;IACpClB,CAAC,IAAIoB,IAAI,CAACa,SAAS,CAACf,KAAK,GAAG,CAAC,EAAE,IAAI,CAAC;IACpC,MAAMzL,GAAG,GAAGyM,GAAG,CAAC1E,CAAC,EAAEuC,CAAC,EAAEC,CAAC,CAAC;IACxBxC,CAAC,GAAG/H,GAAG,CAAC,CAAC,CAAC,EAAEsK,CAAC,GAAGtK,GAAG,CAAC,CAAC,CAAC,EAAEuK,CAAC,GAAGvK,GAAG,CAAC,CAAC,CAAC;EACpC;EACA,MAAM0M,SAAS,GAAGxM,MAAM,GAAGuL,KAAK;EAChClB,CAAC,IAAIrK,MAAM;EACX,IAAIwM,SAAS,IAAI,CAAC,EAAE;IAClB3E,CAAC,IAAI4D,IAAI,CAACa,SAAS,CAACf,KAAK,EAAE,IAAI,CAAC;IAChCA,KAAK,IAAI,CAAC;IACV,IAAIiB,SAAS,IAAI,CAAC,EAAE;MAClBpC,CAAC,IAAIqB,IAAI,CAACa,SAAS,CAACf,KAAK,EAAE,IAAI,CAAC;MAChCA,KAAK,IAAI,CAAC;MACV,IAAIiB,SAAS,IAAI,CAAC,EAAE;QAClBnC,CAAC,IAAIoB,IAAI,CAACgB,QAAQ,CAAClB,KAAK,EAAE,CAAC,IAAI,CAAC;MAClC;MACA,IAAIiB,SAAS,IAAI,EAAE,EAAE;QACnBnC,CAAC,IAAIoB,IAAI,CAACgB,QAAQ,CAAClB,KAAK,EAAE,CAAC,IAAI,EAAE;MACnC;MACA,IAAIiB,SAAS,KAAK,EAAE,EAAE;QACpBnC,CAAC,IAAIoB,IAAI,CAACgB,QAAQ,CAAClB,KAAK,EAAE,CAAC,IAAI,EAAE;MACnC;IACF,CAAC,MAAM;MACL,IAAIiB,SAAS,IAAI,CAAC,EAAE;QAClBpC,CAAC,IAAIqB,IAAI,CAACgB,QAAQ,CAAClB,KAAK,EAAE,CAAC;MAC7B;MACA,IAAIiB,SAAS,IAAI,CAAC,EAAE;QAClBpC,CAAC,IAAIqB,IAAI,CAACgB,QAAQ,CAAClB,KAAK,EAAE,CAAC,IAAI,CAAC;MAClC;MACA,IAAIiB,SAAS,KAAK,CAAC,EAAE;QACnBpC,CAAC,IAAIqB,IAAI,CAACgB,QAAQ,CAAClB,KAAK,EAAE,CAAC,IAAI,EAAE;MACnC;IACF;EACF,CAAC,MAAM;IACL,IAAIiB,SAAS,IAAI,CAAC,EAAE;MAClB3E,CAAC,IAAI4D,IAAI,CAACgB,QAAQ,CAAClB,KAAK,EAAE,CAAC;IAC7B;IACA,IAAIiB,SAAS,IAAI,CAAC,EAAE;MAClB3E,CAAC,IAAI4D,IAAI,CAACgB,QAAQ,CAAClB,KAAK,EAAE,CAAC,IAAI,CAAC;IAClC;IACA,IAAIiB,SAAS,KAAK,CAAC,EAAE;MACnB3E,CAAC,IAAI4D,IAAI,CAACgB,QAAQ,CAAClB,KAAK,EAAE,CAAC,IAAI,EAAE;IACnC;EACF;EACA,OAAOgB,GAAG,CAAC1E,CAAC,EAAEuC,CAAC,EAAEC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxB;AACA,SAASkC,GAAGA,CAAC1E,CAAC,EAAEuC,CAAC,EAAEC,CAAC,EAAE;EACpBxC,CAAC,IAAIuC,CAAC;EACNvC,CAAC,IAAIwC,CAAC;EACNxC,CAAC,IAAIwC,CAAC,KAAK,EAAE;EACbD,CAAC,IAAIC,CAAC;EACND,CAAC,IAAIvC,CAAC;EACNuC,CAAC,IAAIvC,CAAC,IAAI,CAAC;EACXwC,CAAC,IAAIxC,CAAC;EACNwC,CAAC,IAAID,CAAC;EACNC,CAAC,IAAID,CAAC,KAAK,EAAE;EACbvC,CAAC,IAAIuC,CAAC;EACNvC,CAAC,IAAIwC,CAAC;EACNxC,CAAC,IAAIwC,CAAC,KAAK,EAAE;EACbD,CAAC,IAAIC,CAAC;EACND,CAAC,IAAIvC,CAAC;EACNuC,CAAC,IAAIvC,CAAC,IAAI,EAAE;EACZwC,CAAC,IAAIxC,CAAC;EACNwC,CAAC,IAAID,CAAC;EACNC,CAAC,IAAID,CAAC,KAAK,CAAC;EACZvC,CAAC,IAAIuC,CAAC;EACNvC,CAAC,IAAIwC,CAAC;EACNxC,CAAC,IAAIwC,CAAC,KAAK,CAAC;EACZD,CAAC,IAAIC,CAAC;EACND,CAAC,IAAIvC,CAAC;EACNuC,CAAC,IAAIvC,CAAC,IAAI,EAAE;EACZwC,CAAC,IAAIxC,CAAC;EACNwC,CAAC,IAAID,CAAC;EACNC,CAAC,IAAID,CAAC,KAAK,EAAE;EACb,OAAO,CAACvC,CAAC,EAAEuC,CAAC,EAAEC,CAAC,CAAC;AAClB;AACA,IAAIN,MAAM;AACV,CAAC,UAAUA,MAAM,EAAE;EACjBA,MAAM,CAACA,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;EACvCA,MAAM,CAACA,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK;AACnC,CAAC,EAAEA,MAAM,KAAKA,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;AAC3B,SAASqB,KAAKA,CAACvD,CAAC,EAAEuC,CAAC,EAAE;EACnB,OAAOsC,SAAS,CAAC7E,CAAC,EAAEuC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3B;AACA,SAASsC,SAASA,CAAC7E,CAAC,EAAEuC,CAAC,EAAE;EACvB,MAAMuC,GAAG,GAAG,CAAC9E,CAAC,GAAG,MAAM,KAAKuC,CAAC,GAAG,MAAM,CAAC;EACvC,MAAMwC,IAAI,GAAG,CAAC/E,CAAC,KAAK,EAAE,KAAKuC,CAAC,KAAK,EAAE,CAAC,IAAIuC,GAAG,KAAK,EAAE,CAAC;EACnD,OAAO,CAACC,IAAI,KAAK,EAAE,EAAEA,IAAI,IAAI,EAAE,GAAGD,GAAG,GAAG,MAAM,CAAC;AACjD;AACA,SAAS7B,KAAKA,CAACjD,CAAC,EAAEgF,KAAK,EAAE;EACvB,OAAOhF,CAAC,IAAIgF,KAAK,GAAGhF,CAAC,KAAK,EAAE,GAAGgF,KAAK;AACtC;AACA,SAAS/C,cAAcA,CAACgD,KAAK,EAAEC,MAAM,EAAE;EACrC,MAAMC,IAAI,GAAGF,KAAK,CAAC9M,MAAM,GAAG,CAAC,KAAK,CAAC;EACnC,MAAM6J,OAAO,GAAG,EAAE;EAClB,KAAK,IAAIzI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4L,IAAI,EAAE5L,CAAC,EAAE,EAAE;IAC7ByI,OAAO,CAACzI,CAAC,CAAC,GAAG6L,MAAM,CAACH,KAAK,EAAE1L,CAAC,GAAG,CAAC,EAAE2L,MAAM,CAAC;EAC3C;EACA,OAAOlD,OAAO;AAChB;AACA,SAASqD,MAAMA,CAACJ,KAAK,EAAEvB,KAAK,EAAE;EAC5B,OAAOA,KAAK,IAAIuB,KAAK,CAAC9M,MAAM,GAAG,CAAC,GAAG8M,KAAK,CAACvB,KAAK,CAAC;AACjD;AACA,SAAS0B,MAAMA,CAACH,KAAK,EAAEvB,KAAK,EAAEwB,MAAM,EAAE;EACpC,IAAII,IAAI,GAAG,CAAC;EACZ,IAAIJ,MAAM,KAAKhD,MAAM,CAACC,GAAG,EAAE;IACzB,KAAK,IAAI5I,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC1B+L,IAAI,IAAID,MAAM,CAACJ,KAAK,EAAEvB,KAAK,GAAGnK,CAAC,CAAC,IAAI,EAAE,GAAG,CAAC,GAAGA,CAAC;IAChD;EACF,CAAC,MAAM;IACL,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC1B+L,IAAI,IAAID,MAAM,CAACJ,KAAK,EAAEvB,KAAK,GAAGnK,CAAC,CAAC,IAAI,CAAC,GAAGA,CAAC;IAC3C;EACF;EACA,OAAO+L,IAAI;AACb;AAEA,IAAIC,YAAY;AAChB,CAAC,UAAUA,YAAY,EAAE;EACvBA,YAAY,CAACA,YAAY,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EAC/CA,YAAY,CAACA,YAAY,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;AACnD,CAAC,EAAEA,YAAY,KAAKA,YAAY,GAAG,CAAC,CAAC,CAAC,CAAC;AACvC,MAAMzG,IAAI,CAAC;EACT0G,SAAS;EACTvI,WAAWA,CAACuI,SAAS,GAAGD,YAAY,CAACE,IAAI,EAAE;IACzC,IAAI,CAACD,SAAS,GAAGA,SAAS;EAC5B;EACAE,WAAWA,CAACC,QAAQ,EAAE;IACpB,OAAO,CAAC,IAAI,CAACH,SAAS,GAAGG,QAAQ,MAAM,CAAC;EAC1C;AACF;AACA,IAAIC,eAAe;AACnB,CAAC,UAAUA,eAAe,EAAE;EAC1BA,eAAe,CAACA,eAAe,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;EAC3DA,eAAe,CAACA,eAAe,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EACrDA,eAAe,CAACA,eAAe,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;EACzDA,eAAe,CAACA,eAAe,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK;EACnDA,eAAe,CAACA,eAAe,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;EACzDA,eAAe,CAACA,eAAe,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EAC7DA,eAAe,CAACA,eAAe,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EAC7DA,eAAe,CAACA,eAAe,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;AACvD,CAAC,EAAEA,eAAe,KAAKA,eAAe,GAAG,CAAC,CAAC,CAAC,CAAC;AAC7C,MAAMC,WAAW,SAAS/G,IAAI,CAAC;EAC7B7E,IAAI;EACJgD,WAAWA,CAAChD,IAAI,EAAEuL,SAAS,EAAE;IAC3B,KAAK,CAACA,SAAS,CAAC;IAChB,IAAI,CAACvL,IAAI,GAAGA,IAAI;EAClB;EACA6L,SAASA,CAACjG,OAAO,EAAES,OAAO,EAAE;IAC1B,OAAOT,OAAO,CAACkG,gBAAgB,CAAC,IAAI,EAAEzF,OAAO,CAAC;EAChD;AACF;AACA,MAAM0F,cAAc,SAASlH,IAAI,CAAC;EAChC5E,KAAK;EACL+L,UAAU;EACVhJ,WAAWA,CAAC/C,KAAK,EAAEsL,SAAS,EAAES,UAAU,GAAG,IAAI,EAAE;IAC/C,KAAK,CAACT,SAAS,CAAC;IAChB,IAAI,CAACtL,KAAK,GAAGA,KAAK;IAClB,IAAI,CAAC+L,UAAU,GAAGA,UAAU;EAC9B;EACAH,SAASA,CAACjG,OAAO,EAAES,OAAO,EAAE;IAC1B,OAAOT,OAAO,CAACqG,mBAAmB,CAAC,IAAI,EAAE5F,OAAO,CAAC;EACnD;AACF;AACA,MAAM6F,SAAS,SAASrH,IAAI,CAAC;EAC3BsH,EAAE;EACFnJ,WAAWA,CAACmJ,EAAE,EAAEZ,SAAS,EAAE;IACzB,KAAK,CAACA,SAAS,CAAC;IAChB,IAAI,CAACY,EAAE,GAAGA,EAAE;EACd;EACAN,SAASA,CAACjG,OAAO,EAAES,OAAO,EAAE;IAC1B,OAAOT,OAAO,CAACwG,cAAc,CAAC,IAAI,EAAE/F,OAAO,CAAC;EAC9C;AACF;AACA,MAAMgG,OAAO,SAASxH,IAAI,CAAC;EACzByH,SAAS;EACTtJ,WAAWA,CAACsJ,SAAS,EAAEf,SAAS,EAAE;IAChC,KAAK,CAACA,SAAS,CAAC;IAChB,IAAI,CAACe,SAAS,GAAGA,SAAS,IAAI,IAAI;EACpC;EACAT,SAASA,CAACjG,OAAO,EAAES,OAAO,EAAE;IAC1B,OAAOT,OAAO,CAAC2G,YAAY,CAAC,IAAI,EAAElG,OAAO,CAAC;EAC5C;AACF;AACA,MAAMmG,gBAAgB,SAAS3H,IAAI,CAAC;EAClCoC,IAAI;EACJjE,WAAWA,CAACiE,IAAI,EAAEsE,SAAS,EAAE;IAC3B,KAAK,CAACA,SAAS,CAAC;IAChB,IAAI,CAACtE,IAAI,GAAGA,IAAI;EAClB;EACA4E,SAASA,CAACjG,OAAO,EAAES,OAAO,EAAE;IAC1B,OAAOT,OAAO,CAAC6G,qBAAqB,CAAC,IAAI,EAAEpG,OAAO,CAAC;EACrD;AACF;AACA,MAAMqG,YAAY,GAAG,IAAId,WAAW,CAACD,eAAe,CAACgB,OAAO,CAAC;AAC7D,MAAMC,aAAa,GAAG,IAAIhB,WAAW,CAACD,eAAe,CAACkB,QAAQ,CAAC;AAC/D,MAAMC,SAAS,GAAG,IAAIlB,WAAW,CAACD,eAAe,CAACoB,IAAI,CAAC;AACvD,MAAMC,QAAQ,GAAG,IAAIpB,WAAW,CAACD,eAAe,CAACsB,GAAG,CAAC;AACrD,MAAMC,WAAW,GAAG,IAAItB,WAAW,CAACD,eAAe,CAACwB,MAAM,CAAC;AAC3D,MAAMC,WAAW,GAAG,IAAIxB,WAAW,CAACD,eAAe,CAAC0B,MAAM,CAAC;AAC3D,MAAMC,aAAa,GAAG,IAAI1B,WAAW,CAACD,eAAe,CAAC7H,QAAQ,CAAC;AAC/D,MAAMyJ,SAAS,GAAG,IAAI3B,WAAW,CAACD,eAAe,CAACH,IAAI,CAAC;AACvD,IAAIgC,aAAa;AACjB,CAAC,UAAUA,aAAa,EAAE;EACxBA,aAAa,CAACA,aAAa,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;EACnDA,aAAa,CAACA,aAAa,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;AACnD,CAAC,EAAEA,aAAa,KAAKA,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC;AACzC,IAAIC,cAAc;AAClB,CAAC,UAAUA,cAAc,EAAE;EACzBA,cAAc,CAACA,cAAc,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;EACvDA,cAAc,CAACA,cAAc,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;EAC7DA,cAAc,CAACA,cAAc,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;EACvDA,cAAc,CAACA,cAAc,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;EAC7DA,cAAc,CAACA,cAAc,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,GAAG,cAAc;EACnEA,cAAc,CAACA,cAAc,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;EACrDA,cAAc,CAACA,cAAc,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EACnDA,cAAc,CAACA,cAAc,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;EACvDA,cAAc,CAACA,cAAc,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EAC3DA,cAAc,CAACA,cAAc,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;EACvDA,cAAc,CAACA,cAAc,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,GAAG,KAAK;EAClDA,cAAc,CAACA,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,GAAG,IAAI;EAChDA,cAAc,CAACA,cAAc,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,GAAG,WAAW;EAC9DA,cAAc,CAACA,cAAc,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC,GAAG,YAAY;EAChEA,cAAc,CAACA,cAAc,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,GAAG,OAAO;EACtDA,cAAc,CAACA,cAAc,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC,GAAG,aAAa;EAClEA,cAAc,CAACA,cAAc,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,GAAG,QAAQ;EACxDA,cAAc,CAACA,cAAc,CAAC,cAAc,CAAC,GAAG,EAAE,CAAC,GAAG,cAAc;EACpEA,cAAc,CAACA,cAAc,CAAC,iBAAiB,CAAC,GAAG,EAAE,CAAC,GAAG,iBAAiB;EAC1EA,cAAc,CAACA,cAAc,CAAC,gBAAgB,CAAC,GAAG,EAAE,CAAC,GAAG,gBAAgB;EACxEA,cAAc,CAACA,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,GAAG,IAAI;EAChDA,cAAc,CAACA,cAAc,CAAC,oBAAoB,CAAC,GAAG,EAAE,CAAC,GAAG,oBAAoB;EAChFA,cAAc,CAACA,cAAc,CAAC,uBAAuB,CAAC,GAAG,EAAE,CAAC,GAAG,uBAAuB;EACtFA,cAAc,CAACA,cAAc,CAAC,0BAA0B,CAAC,GAAG,EAAE,CAAC,GAAG,0BAA0B;EAC5FA,cAAc,CAACA,cAAc,CAAC,oBAAoB,CAAC,GAAG,EAAE,CAAC,GAAG,oBAAoB;EAChFA,cAAc,CAACA,cAAc,CAAC,qBAAqB,CAAC,GAAG,EAAE,CAAC,GAAG,qBAAqB;EAClFA,cAAc,CAACA,cAAc,CAAC,0BAA0B,CAAC,GAAG,EAAE,CAAC,GAAG,0BAA0B;EAC5FA,cAAc,CAACA,cAAc,CAAC,eAAe,CAAC,GAAG,EAAE,CAAC,GAAG,eAAe;EACtEA,cAAc,CAACA,cAAc,CAAC,cAAc,CAAC,GAAG,EAAE,CAAC,GAAG,cAAc;EACpEA,cAAc,CAACA,cAAc,CAAC,2BAA2B,CAAC,GAAG,EAAE,CAAC,GAAG,2BAA2B;AAChG,CAAC,EAAEA,cAAc,KAAKA,cAAc,GAAG,CAAC,CAAC,CAAC,CAAC;AAC3C,SAASC,oBAAoBA,CAACC,IAAI,EAAEC,KAAK,EAAE;EACzC,IAAID,IAAI,IAAI,IAAI,IAAIC,KAAK,IAAI,IAAI,EAAE;IACjC,OAAOD,IAAI,IAAIC,KAAK;EACtB;EACA,OAAOD,IAAI,CAACE,YAAY,CAACD,KAAK,CAAC;AACjC;AACA,SAASE,yBAAyBA,CAACH,IAAI,EAAEC,KAAK,EAAEG,mBAAmB,EAAE;EACnE,MAAM5F,GAAG,GAAGwF,IAAI,CAACzP,MAAM;EACvB,IAAIiK,GAAG,KAAKyF,KAAK,CAAC1P,MAAM,EAAE;IACxB,OAAO,KAAK;EACd;EACA,KAAK,IAAIoB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6I,GAAG,EAAE7I,CAAC,EAAE,EAAE;IAC5B,IAAI,CAACyO,mBAAmB,CAACJ,IAAI,CAACrO,CAAC,CAAC,EAAEsO,KAAK,CAACtO,CAAC,CAAC,CAAC,EAAE;MAC3C,OAAO,KAAK;IACd;EACF;EACA,OAAO,IAAI;AACb;AACA,SAAS0O,gBAAgBA,CAACL,IAAI,EAAEC,KAAK,EAAE;EACrC,OAAOE,yBAAyB,CAACH,IAAI,EAAEC,KAAK,EAAE,CAACK,WAAW,EAAEC,YAAY,KAAKD,WAAW,CAACJ,YAAY,CAACK,YAAY,CAAC,CAAC;AACtH;AACA,MAAMC,UAAU,CAAC;EACflH,IAAI;EACJmH,UAAU;EACVpL,WAAWA,CAACiE,IAAI,EAAEmH,UAAU,EAAE;IAC5B,IAAI,CAACnH,IAAI,GAAGA,IAAI,IAAI,IAAI;IACxB,IAAI,CAACmH,UAAU,GAAGA,UAAU,IAAI,IAAI;EACtC;EACAC,IAAIA,CAACrO,IAAI,EAAEoO,UAAU,EAAE;IACrB,OAAO,IAAIE,YAAY,CAAC,IAAI,EAAEtO,IAAI,EAAE,IAAI,EAAEoO,UAAU,CAAC;EACvD;EACAG,GAAGA,CAAC9E,KAAK,EAAExC,IAAI,EAAEmH,UAAU,EAAE;IAC3B,OAAO,IAAII,WAAW,CAAC,IAAI,EAAE/E,KAAK,EAAExC,IAAI,EAAEmH,UAAU,CAAC;EACvD;EACAK,MAAMA,CAACC,MAAM,EAAEN,UAAU,EAAEO,IAAI,EAAE;IAC/B,OAAO,IAAIC,kBAAkB,CAAC,IAAI,EAAEF,MAAM,EAAE,IAAI,EAAEN,UAAU,EAAEO,IAAI,CAAC;EACrE;EACAE,WAAWA,CAACH,MAAM,EAAEzH,IAAI,EAAEmH,UAAU,EAAE;IACpC,OAAO,IAAIU,eAAe,CAAC,IAAI,EAAEJ,MAAM,EAAEzH,IAAI,EAAEmH,UAAU,CAAC;EAC5D;EACAW,WAAWA,CAACC,QAAQ,EAAEC,SAAS,GAAG,IAAI,EAAEb,UAAU,EAAE;IAClD,OAAO,IAAIc,eAAe,CAAC,IAAI,EAAEF,QAAQ,EAAEC,SAAS,EAAE,IAAI,EAAEb,UAAU,CAAC;EACzE;EACAe,MAAMA,CAACC,GAAG,EAAEhB,UAAU,EAAE;IACtB,OAAO,IAAIiB,kBAAkB,CAAC5B,cAAc,CAAC6B,MAAM,EAAE,IAAI,EAAEF,GAAG,EAAE,IAAI,EAAEhB,UAAU,CAAC;EACnF;EACAmB,SAASA,CAACH,GAAG,EAAEhB,UAAU,EAAE;IACzB,OAAO,IAAIiB,kBAAkB,CAAC5B,cAAc,CAAC+B,SAAS,EAAE,IAAI,EAAEJ,GAAG,EAAE,IAAI,EAAEhB,UAAU,CAAC;EACtF;EACAqB,SAASA,CAACL,GAAG,EAAEhB,UAAU,EAAE;IACzB,OAAO,IAAIiB,kBAAkB,CAAC5B,cAAc,CAACiC,SAAS,EAAE,IAAI,EAAEN,GAAG,EAAE,IAAI,EAAEhB,UAAU,CAAC;EACtF;EACAuB,YAAYA,CAACP,GAAG,EAAEhB,UAAU,EAAE;IAC5B,OAAO,IAAIiB,kBAAkB,CAAC5B,cAAc,CAACmC,YAAY,EAAE,IAAI,EAAER,GAAG,EAAE,IAAI,EAAEhB,UAAU,CAAC;EACzF;EACAyB,KAAKA,CAACT,GAAG,EAAEhB,UAAU,EAAE;IACrB,OAAO,IAAIiB,kBAAkB,CAAC5B,cAAc,CAACqC,KAAK,EAAE,IAAI,EAAEV,GAAG,EAAE,IAAI,EAAEhB,UAAU,CAAC;EAClF;EACA2B,IAAIA,CAACX,GAAG,EAAEhB,UAAU,EAAE;IACpB,OAAO,IAAIiB,kBAAkB,CAAC5B,cAAc,CAACuC,IAAI,EAAE,IAAI,EAAEZ,GAAG,EAAE,IAAI,EAAEhB,UAAU,CAAC;EACjF;EACA6B,MAAMA,CAACb,GAAG,EAAEhB,UAAU,EAAE;IACtB,OAAO,IAAIiB,kBAAkB,CAAC5B,cAAc,CAACyC,MAAM,EAAE,IAAI,EAAEd,GAAG,EAAE,IAAI,EAAEhB,UAAU,CAAC;EACnF;EACA+B,QAAQA,CAACf,GAAG,EAAEhB,UAAU,EAAE;IACxB,OAAO,IAAIiB,kBAAkB,CAAC5B,cAAc,CAAC2C,QAAQ,EAAE,IAAI,EAAEhB,GAAG,EAAE,IAAI,EAAEhB,UAAU,CAAC;EACrF;EACAiC,MAAMA,CAACjB,GAAG,EAAEhB,UAAU,EAAE;IACtB,OAAO,IAAIiB,kBAAkB,CAAC5B,cAAc,CAAC6C,MAAM,EAAE,IAAI,EAAElB,GAAG,EAAE,IAAI,EAAEhB,UAAU,CAAC;EACnF;EACAmC,KAAKA,CAACnB,GAAG,EAAEhB,UAAU,EAAE;IACrB,OAAO,IAAIiB,kBAAkB,CAAC5B,cAAc,CAAC+C,cAAc,EAAE,IAAI,EAAEpB,GAAG,EAAE,IAAI,EAAEhB,UAAU,CAAC;EAC3F;EACAqC,GAAGA,CAACrB,GAAG,EAAEhB,UAAU,EAAE;IACnB,OAAO,IAAIiB,kBAAkB,CAAC5B,cAAc,CAACiD,GAAG,EAAE,IAAI,EAAEtB,GAAG,EAAE,IAAI,EAAEhB,UAAU,CAAC;EAChF;EACAuC,SAASA,CAACvB,GAAG,EAAEhB,UAAU,EAAE;IACzB,OAAO,IAAIiB,kBAAkB,CAAC5B,cAAc,CAACmD,SAAS,EAAE,IAAI,EAAExB,GAAG,EAAE,IAAI,EAAEhB,UAAU,CAAC;EACtF;EACAyC,UAAUA,CAACzB,GAAG,EAAEhB,UAAU,EAAE;IAC1B,OAAO,IAAIiB,kBAAkB,CAAC5B,cAAc,CAACqD,UAAU,EAAE,IAAI,EAAE1B,GAAG,EAAE,IAAI,EAAEhB,UAAU,CAAC;EACvF;EACA2C,EAAEA,CAAC3B,GAAG,EAAEhB,UAAU,EAAE;IAClB,OAAO,IAAIiB,kBAAkB,CAAC5B,cAAc,CAACuD,EAAE,EAAE,IAAI,EAAE5B,GAAG,EAAE,IAAI,EAAEhB,UAAU,CAAC;EAC/E;EACA6C,KAAKA,CAAC7B,GAAG,EAAEhB,UAAU,EAAE;IACrB,OAAO,IAAIiB,kBAAkB,CAAC5B,cAAc,CAACyD,KAAK,EAAE,IAAI,EAAE9B,GAAG,EAAE,IAAI,EAAEhB,UAAU,CAAC;EAClF;EACA+C,WAAWA,CAAC/B,GAAG,EAAEhB,UAAU,EAAE;IAC3B,OAAO,IAAIiB,kBAAkB,CAAC5B,cAAc,CAAC2D,WAAW,EAAE,IAAI,EAAEhC,GAAG,EAAE,IAAI,EAAEhB,UAAU,CAAC;EACxF;EACAiD,MAAMA,CAACjC,GAAG,EAAEhB,UAAU,EAAE;IACtB,OAAO,IAAIiB,kBAAkB,CAAC5B,cAAc,CAAC6D,MAAM,EAAE,IAAI,EAAElC,GAAG,EAAE,IAAI,EAAEhB,UAAU,CAAC;EACnF;EACAmD,YAAYA,CAACnC,GAAG,EAAEhB,UAAU,EAAE;IAC5B,OAAO,IAAIiB,kBAAkB,CAAC5B,cAAc,CAAC+D,YAAY,EAAE,IAAI,EAAEpC,GAAG,EAAE,IAAI,EAAEhB,UAAU,CAAC;EACzF;EACAqD,OAAOA,CAACrD,UAAU,EAAE;IAClB,OAAO,IAAI,CAACe,MAAM,CAACuC,eAAe,EAAEtD,UAAU,CAAC;EACjD;EACAuD,eAAeA,CAACvC,GAAG,EAAEhB,UAAU,EAAE;IAC/B,OAAO,IAAIiB,kBAAkB,CAAC5B,cAAc,CAACmE,eAAe,EAAE,IAAI,EAAExC,GAAG,EAAE,IAAI,EAAEhB,UAAU,CAAC;EAC5F;EACAyD,MAAMA,CAAA,EAAG;IACP,OAAO,IAAIC,mBAAmB,CAAC,IAAI,EAAE,IAAI,CAAC;EAC5C;AACF;AACA,MAAMC,WAAW,SAAS5D,UAAU,CAAC;EACnCnO,IAAI;EACJgD,WAAWA,CAAChD,IAAI,EAAEiH,IAAI,EAAEmH,UAAU,EAAE;IAClC,KAAK,CAACnH,IAAI,EAAEmH,UAAU,CAAC;IACvB,IAAI,CAACpO,IAAI,GAAGA,IAAI;EAClB;EACA6N,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAYsJ,WAAW,IAAI,IAAI,CAAC/R,IAAI,KAAKyI,CAAC,CAACzI,IAAI;EACzD;EACAgS,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAC,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAACsM,gBAAgB,CAAC,IAAI,EAAE7L,OAAO,CAAC;EAChD;EACA8L,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIJ,WAAW,CAAC,IAAI,CAAC/R,IAAI,EAAE,IAAI,CAACiH,IAAI,EAAE,IAAI,CAACmH,UAAU,CAAC;EAC/D;EACAlM,GAAGA,CAACjC,KAAK,EAAE;IACT,OAAO,IAAIoP,kBAAkB,CAAC5B,cAAc,CAAC2E,MAAM,EAAE,IAAI,EAAEnS,KAAK,EAAE,IAAI,EAAE,IAAI,CAACmO,UAAU,CAAC;EAC1F;AACF;AACA,MAAMiE,UAAU,SAASlE,UAAU,CAAC;EAClCmE,IAAI;EACJtP,WAAWA,CAACsP,IAAI,EAAErL,IAAI,EAAEmH,UAAU,EAAE;IAClC,KAAK,CAACnH,IAAI,EAAEmH,UAAU,CAAC;IACvB,IAAI,CAACkE,IAAI,GAAGA,IAAI;EAClB;EACAL,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAAC2M,eAAe,CAAC,IAAI,EAAElM,OAAO,CAAC;EAC/C;EACAwH,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAY4J,UAAU,IAAI5J,CAAC,CAAC6J,IAAI,CAACzE,YAAY,CAAC,IAAI,CAACyE,IAAI,CAAC;EAClE;EACAN,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI,CAACM,IAAI,CAACN,UAAU,CAAC,CAAC;EAC/B;EACAG,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIE,UAAU,CAAC,IAAI,CAACC,IAAI,CAACH,KAAK,CAAC,CAAC,CAAC;EAC1C;AACF;AACA,MAAMK,QAAQ,SAASrE,UAAU,CAAC;EAChCmE,IAAI;EACJtP,WAAWA,CAACsP,IAAI,EAAErL,IAAI,EAAEmH,UAAU,EAAE;IAClC,KAAK,CAACnH,IAAI,EAAEmH,UAAU,CAAC;IACvB,IAAI,CAACkE,IAAI,GAAGA,IAAI;EAClB;EACAL,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAAC6M,aAAa,CAAC,IAAI,EAAEpM,OAAO,CAAC;EAC7C;EACAwH,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAY+J,QAAQ,IAAI/J,CAAC,CAAC6J,IAAI,CAACzE,YAAY,CAAC,IAAI,CAACyE,IAAI,CAAC;EAChE;EACAN,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI,CAACM,IAAI,CAACN,UAAU,CAAC,CAAC;EAC/B;EACAG,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIK,QAAQ,CAAC,IAAI,CAACF,IAAI,CAACH,KAAK,CAAC,CAAC,CAAC;EACxC;AACF;AACA,MAAMO,eAAe,SAASvE,UAAU,CAAC;EACvCwE,IAAI;EACJ3P,WAAWA,CAAC2P,IAAI,EAAE1L,IAAI,EAAEmH,UAAU,EAAE;IAClC,KAAK,CAACnH,IAAI,EAAEmH,UAAU,CAAC;IACvB,IAAI,CAACuE,IAAI,GAAGA,IAAI;EAClB;EACA9E,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAYiK,eAAe,IAAI,IAAI,CAACC,IAAI,KAAKlK,CAAC,CAACkK,IAAI;EAC7D;EACAX,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAC,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAACgN,oBAAoB,CAAC,IAAI,EAAEvM,OAAO,CAAC;EACpD;EACA8L,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIO,eAAe,CAAC,IAAI,CAACC,IAAI,EAAE,IAAI,CAAC1L,IAAI,EAAE,IAAI,CAACmH,UAAU,CAAC;EACnE;AACF;AACA,MAAMQ,kBAAkB,SAAST,UAAU,CAAC;EAC1C0E,EAAE;EACFC,IAAI;EACJnE,IAAI;EACJ3L,WAAWA,CAAC6P,EAAE,EAAEC,IAAI,EAAE7L,IAAI,EAAEmH,UAAU,EAAEO,IAAI,GAAG,KAAK,EAAE;IACpD,KAAK,CAAC1H,IAAI,EAAEmH,UAAU,CAAC;IACvB,IAAI,CAACyE,EAAE,GAAGA,EAAE;IACZ,IAAI,CAACC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACnE,IAAI,GAAGA,IAAI;EAClB;EACA,IAAIoE,QAAQA,CAAA,EAAG;IACb,OAAO,IAAI,CAACF,EAAE;EAChB;EACAhF,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAYmG,kBAAkB,IAAI,IAAI,CAACiE,EAAE,CAAChF,YAAY,CAACpF,CAAC,CAACoK,EAAE,CAAC,IAAI7E,gBAAgB,CAAC,IAAI,CAAC8E,IAAI,EAAErK,CAAC,CAACqK,IAAI,CAAC,IAAI,IAAI,CAACnE,IAAI,KAAKlG,CAAC,CAACkG,IAAI;EACrI;EACAqD,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAC,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAACoN,uBAAuB,CAAC,IAAI,EAAE3M,OAAO,CAAC;EACvD;EACA8L,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIvD,kBAAkB,CAAC,IAAI,CAACiE,EAAE,CAACV,KAAK,CAAC,CAAC,EAAE,IAAI,CAACW,IAAI,CAACzQ,GAAG,CAAC4Q,GAAG,IAAIA,GAAG,CAACd,KAAK,CAAC,CAAC,CAAC,EAAE,IAAI,CAAClL,IAAI,EAAE,IAAI,CAACmH,UAAU,EAAE,IAAI,CAACO,IAAI,CAAC;EAC1H;AACF;AACA,MAAMuE,yBAAyB,SAAS/E,UAAU,CAAC;EACjDxP,GAAG;EACHwU,QAAQ;EACRnQ,WAAWA,CAACrE,GAAG,EAAEwU,QAAQ,EAAElM,IAAI,EAAEmH,UAAU,EAAE;IAC3C,KAAK,CAACnH,IAAI,EAAEmH,UAAU,CAAC;IACvB,IAAI,CAACzP,GAAG,GAAGA,GAAG;IACd,IAAI,CAACwU,QAAQ,GAAGA,QAAQ;EAC1B;EACAtF,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAYyK,yBAAyB,IAAI,IAAI,CAACvU,GAAG,CAACkP,YAAY,CAACpF,CAAC,CAAC9J,GAAG,CAAC,IAAI,IAAI,CAACwU,QAAQ,CAACtF,YAAY,CAACpF,CAAC,CAAC0K,QAAQ,CAAC;EACzH;EACAnB,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAC,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAACwN,8BAA8B,CAAC,IAAI,EAAE/M,OAAO,CAAC;EAC9D;EACA8L,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIe,yBAAyB,CAAC,IAAI,CAACvU,GAAG,CAACwT,KAAK,CAAC,CAAC,EAAE,IAAI,CAACgB,QAAQ,CAAChB,KAAK,CAAC,CAAC,EAAE,IAAI,CAAClL,IAAI,EAAE,IAAI,CAACmH,UAAU,CAAC;EAC3G;AACF;AACA,MAAMU,eAAe,SAASX,UAAU,CAAC;EACvCkF,SAAS;EACTP,IAAI;EACJ9P,WAAWA,CAACqQ,SAAS,EAAEP,IAAI,EAAE7L,IAAI,EAAEmH,UAAU,EAAE;IAC7C,KAAK,CAACnH,IAAI,EAAEmH,UAAU,CAAC;IACvB,IAAI,CAACiF,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACP,IAAI,GAAGA,IAAI;EAClB;EACAjF,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAYqG,eAAe,IAAI,IAAI,CAACuE,SAAS,CAACxF,YAAY,CAACpF,CAAC,CAAC4K,SAAS,CAAC,IAAIrF,gBAAgB,CAAC,IAAI,CAAC8E,IAAI,EAAErK,CAAC,CAACqK,IAAI,CAAC;EACxH;EACAd,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAC,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAAC0N,oBAAoB,CAAC,IAAI,EAAEjN,OAAO,CAAC;EACpD;EACA8L,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIrD,eAAe,CAAC,IAAI,CAACuE,SAAS,CAAClB,KAAK,CAAC,CAAC,EAAE,IAAI,CAACW,IAAI,CAACzQ,GAAG,CAAC4Q,GAAG,IAAIA,GAAG,CAACd,KAAK,CAAC,CAAC,CAAC,EAAE,IAAI,CAAClL,IAAI,EAAE,IAAI,CAACmH,UAAU,CAAC;EACnH;AACF;AACA,MAAMmF,4BAA4B,SAASpF,UAAU,CAAC;EACpDqF,IAAI;EACJC,KAAK;EACLzQ,WAAWA,CAACwQ,IAAI,EAAEC,KAAK,EAAErF,UAAU,EAAE;IACnC,KAAK,CAAC,IAAI,EAAEA,UAAU,CAAC;IACvB,IAAI,CAACoF,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,KAAK,GAAGA,KAAK;EACpB;EACA5F,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAY8K,4BAA4B,IAAI,IAAI,CAACC,IAAI,KAAK/K,CAAC,CAAC+K,IAAI,IAAI,IAAI,CAACC,KAAK,KAAKhL,CAAC,CAACgL,KAAK;EACpG;EACAzB,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI;EACb;EACAC,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAAC8N,6BAA6B,CAAC,IAAI,EAAErN,OAAO,CAAC;EAC7D;EACA8L,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIoB,4BAA4B,CAAC,IAAI,CAACC,IAAI,EAAE,IAAI,CAACC,KAAK,EAAE,IAAI,CAACrF,UAAU,CAAC;EACjF;AACF;AACA,MAAMuF,WAAW,SAASxF,UAAU,CAAC;EACnClO,KAAK;EACL+C,WAAWA,CAAC/C,KAAK,EAAEgH,IAAI,EAAEmH,UAAU,EAAE;IACnC,KAAK,CAACnH,IAAI,EAAEmH,UAAU,CAAC;IACvB,IAAI,CAACnO,KAAK,GAAGA,KAAK;EACpB;EACA4N,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAYkL,WAAW,IAAI,IAAI,CAAC1T,KAAK,KAAKwI,CAAC,CAACxI,KAAK;EAC3D;EACA+R,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI;EACb;EACAC,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAACgO,gBAAgB,CAAC,IAAI,EAAEvN,OAAO,CAAC;EAChD;EACA8L,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIwB,WAAW,CAAC,IAAI,CAAC1T,KAAK,EAAE,IAAI,CAACgH,IAAI,EAAE,IAAI,CAACmH,UAAU,CAAC;EAChE;AACF;AACA,MAAMyF,mBAAmB,SAAS1F,UAAU,CAAC;EAC3C2F,QAAQ;EACRC,WAAW;EACX/Q,WAAWA,CAAC8Q,QAAQ,EAAEC,WAAW,EAAE3F,UAAU,EAAE;IAC7C,KAAK,CAAC,IAAI,EAAEA,UAAU,CAAC;IACvB,IAAI,CAAC0F,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,WAAW,GAAGA,WAAW;EAChC;EACAlG,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAYoL,mBAAmB,IAAI/F,yBAAyB,CAAC,IAAI,CAACgG,QAAQ,EAAErL,CAAC,CAACqL,QAAQ,EAAE,CAAC/N,CAAC,EAAEuC,CAAC,KAAKvC,CAAC,CAACK,IAAI,KAAKkC,CAAC,CAAClC,IAAI,CAAC,IAAI4H,gBAAgB,CAAC,IAAI,CAAC+F,WAAW,EAAEtL,CAAC,CAACsL,WAAW,CAAC;EACnL;EACA/B,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAC,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAACoO,wBAAwB,CAAC,IAAI,EAAE3N,OAAO,CAAC;EACxD;EACA8L,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI0B,mBAAmB,CAAC,IAAI,CAACC,QAAQ,CAACzR,GAAG,CAAC4R,EAAE,IAAIA,EAAE,CAAC9B,KAAK,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC4B,WAAW,CAAC1R,GAAG,CAACiQ,IAAI,IAAIA,IAAI,CAACH,KAAK,CAAC,CAAC,CAAC,CAAC;EACjH;AACF;AACA,MAAM+B,0BAA0B,SAAS/F,UAAU,CAAC;EAClD/H,IAAI;EACJ+N,OAAO;EACPnR,WAAWA,CAACoD,IAAI,EAAEgI,UAAU,EAAE+F,OAAO,EAAE;IACrC,KAAK,CAAC/G,WAAW,EAAEgB,UAAU,CAAC;IAC9B,IAAI,CAAChI,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC+N,OAAO,GAAGA,OAAO,IAAIC,wBAAwB,CAACC,aAAa,CAACjO,IAAI,CAAC,CAAC;EACzE;EACA6L,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAAC0O,+BAA+B,CAAC,IAAI,EAAEjO,OAAO,CAAC;EAC/D;EACAwH,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAYyL,0BAA0B,IAAIzL,CAAC,CAACrC,IAAI,KAAK,IAAI,CAACA,IAAI,IAAIqC,CAAC,CAAC0L,OAAO,KAAK,IAAI,CAACA,OAAO;EACtG;EACAnC,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI;EACb;EACAG,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI+B,0BAA0B,CAAC,IAAI,CAAC9N,IAAI,EAAE,IAAI,CAACgI,UAAU,EAAE,IAAI,CAAC+F,OAAO,CAAC;EACjF;AACF;AACA,MAAMI,YAAY,CAAC;EACjBnO,IAAI;EACJgI,UAAU;EACVpL,WAAWA,CAACoD,IAAI,EAAEgI,UAAU,EAAE;IAC5B,IAAI,CAAChI,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACgI,UAAU,GAAGA,UAAU;EAC9B;AACF;AACA,MAAMoG,gBAAgB,CAAC;EACrBpO,IAAI;EACJgI,UAAU;EACVqG,iBAAiB;EACjBzR,WAAWA,CAACoD,IAAI,EAAEgI,UAAU,EAAEqG,iBAAiB,EAAE;IAC/C,IAAI,CAACrO,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACgI,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACqG,iBAAiB,GAAGA,iBAAiB;EAC5C;AACF;AACA,MAAMC,mBAAmB,GAAG,GAAG;AAC/B,MAAMC,cAAc,GAAG,IAAI;AAC3B,MAAMC,mBAAmB,GAAG,GAAG;AAC/B,MAAMC,eAAe,SAAS1G,UAAU,CAAC;EACvC2G,SAAS;EACTC,YAAY;EACZC,gBAAgB;EAChBjB,WAAW;EACX/Q,WAAWA,CAAC8R,SAAS,EAAEC,YAAY,EAAEC,gBAAgB,EAAEjB,WAAW,EAAE3F,UAAU,EAAE;IAC9E,KAAK,CAAChB,WAAW,EAAEgB,UAAU,CAAC;IAC9B,IAAI,CAAC0G,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACjB,WAAW,GAAGA,WAAW;EAChC;EACAlG,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAO,KAAK;EACd;EACAuJ,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAC,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAACqP,oBAAoB,CAAC,IAAI,EAAE5O,OAAO,CAAC;EACpD;EACA8L,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI0C,eAAe,CAAC,IAAI,CAACC,SAAS,EAAE,IAAI,CAACC,YAAY,EAAE,IAAI,CAACC,gBAAgB,EAAE,IAAI,CAACjB,WAAW,CAAC1R,GAAG,CAACiQ,IAAI,IAAIA,IAAI,CAACH,KAAK,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC/D,UAAU,CAAC;EACnJ;EACA8G,iBAAiBA,CAAA,EAAG;IAClB,IAAIJ,SAAS,GAAG,IAAI,CAACA,SAAS,CAACK,WAAW,IAAI,EAAE;IAChD,IAAI,IAAI,CAACL,SAAS,CAACrP,OAAO,EAAE;MAC1BqP,SAAS,GAAG,GAAG,IAAI,CAACA,SAAS,CAACrP,OAAO,GAAGiP,mBAAmB,GAAGI,SAAS,EAAE;IAC3E;IACA,IAAI,IAAI,CAACA,SAAS,CAACM,QAAQ,EAAE;MAC3BN,SAAS,GAAG,GAAGA,SAAS,GAAGH,cAAc,GAAG,IAAI,CAACG,SAAS,CAACM,QAAQ,EAAE;IACvE;IACA,IAAI,IAAI,CAACN,SAAS,CAACO,SAAS,EAAE;MAC5B,IAAI,CAACP,SAAS,CAACO,SAAS,CAACjV,OAAO,CAACkV,QAAQ,IAAI;QAC3CR,SAAS,GAAG,GAAGA,SAAS,GAAGF,mBAAmB,GAAGU,QAAQ,EAAE;MAC7D,CAAC,CAAC;IACJ;IACA,OAAOC,qBAAqB,CAACT,SAAS,EAAE,IAAI,CAACC,YAAY,CAAC,CAAC,CAAC,CAAC3O,IAAI,EAAE,IAAI,CAACoP,wBAAwB,CAAC,CAAC,CAAC,CAAC;EACtG;EACAA,wBAAwBA,CAAClW,CAAC,EAAE;IAC1B,OAAO,IAAI,CAACyV,YAAY,CAACzV,CAAC,CAAC,EAAE8O,UAAU,IAAI,IAAI,CAACA,UAAU;EAC5D;EACAqH,wBAAwBA,CAACnW,CAAC,EAAE;IAC1B,OAAO,IAAI,CAAC0V,gBAAgB,CAAC1V,CAAC,CAAC,EAAE8O,UAAU,IAAI,IAAI,CAAC2F,WAAW,CAACzU,CAAC,CAAC,EAAE8O,UAAU,IAAI,IAAI,CAACA,UAAU;EACnG;EACAsH,yBAAyBA,CAACC,SAAS,EAAE;IACnC,MAAMC,WAAW,GAAG,IAAI,CAACZ,gBAAgB,CAACW,SAAS,GAAG,CAAC,CAAC;IACxD,MAAME,WAAW,GAAG,IAAI,CAACd,YAAY,CAACY,SAAS,CAAC;IAChD,IAAIb,SAAS,GAAGc,WAAW,CAACxP,IAAI;IAChC,IAAIwP,WAAW,CAACnB,iBAAiB,EAAEY,SAAS,CAACnX,MAAM,KAAK,CAAC,EAAE;MACzD4W,SAAS,IAAI,GAAGH,cAAc,GAAG1O,YAAY,CAAC2P,WAAW,CAACnB,iBAAiB,CAACqB,aAAa,EAAEF,WAAW,CAACnB,iBAAiB,CAAChP,OAAO,CAAC,EAAE;IACrI;IACA,OAAO8P,qBAAqB,CAACT,SAAS,EAAEe,WAAW,CAACzP,IAAI,EAAE,IAAI,CAACoP,wBAAwB,CAACG,SAAS,CAAC,CAAC;EACrG;AACF;AACA,MAAMtB,aAAa,GAAG1M,GAAG,IAAIA,GAAG,CAACjI,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC;AACvD,MAAMqW,mBAAmB,GAAGpO,GAAG,IAAIA,GAAG,CAACjI,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC;AAC3D,MAAMsW,YAAY,GAAGrO,GAAG,IAAIA,GAAG,CAACjI,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC;AACpD,MAAM0U,wBAAwB,GAAGzM,GAAG,IAAIA,GAAG,CAACjI,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,CAACA,OAAO,CAAC,MAAM,EAAE,MAAM,CAAC;AACxF,SAAS6V,qBAAqBA,CAACT,SAAS,EAAEe,WAAW,EAAEI,KAAK,EAAE;EAC5D,IAAInB,SAAS,KAAK,EAAE,EAAE;IACpB,OAAO;MACLoB,MAAM,EAAEL,WAAW;MACnBM,GAAG,EAAE/B,wBAAwB,CAAC2B,mBAAmB,CAAC1B,aAAa,CAACwB,WAAW,CAAC,CAAC,CAAC;MAC9EI;IACF,CAAC;EACH,CAAC,MAAM;IACL,OAAO;MACLC,MAAM,EAAE,IAAIpB,SAAS,IAAIe,WAAW,EAAE;MACtCM,GAAG,EAAE/B,wBAAwB,CAAC,IAAI4B,YAAY,CAAC3B,aAAa,CAACS,SAAS,CAAC,CAAC,IAAIT,aAAa,CAACwB,WAAW,CAAC,EAAE,CAAC;MACzGI;IACF,CAAC;EACH;AACF;AACA,MAAMG,YAAY,SAASjI,UAAU,CAAC;EACpClO,KAAK;EACL+L,UAAU;EACVhJ,WAAWA,CAAC/C,KAAK,EAAEgH,IAAI,EAAE+E,UAAU,GAAG,IAAI,EAAEoC,UAAU,EAAE;IACtD,KAAK,CAACnH,IAAI,EAAEmH,UAAU,CAAC;IACvB,IAAI,CAACnO,KAAK,GAAGA,KAAK;IAClB,IAAI,CAAC+L,UAAU,GAAGA,UAAU;EAC9B;EACA6B,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAY2N,YAAY,IAAI,IAAI,CAACnW,KAAK,CAACD,IAAI,KAAKyI,CAAC,CAACxI,KAAK,CAACD,IAAI,IAAI,IAAI,CAACC,KAAK,CAACoW,UAAU,KAAK5N,CAAC,CAACxI,KAAK,CAACoW,UAAU;EACtH;EACArE,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAC,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAAC0Q,iBAAiB,CAAC,IAAI,EAAEjQ,OAAO,CAAC;EACjD;EACA8L,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIiE,YAAY,CAAC,IAAI,CAACnW,KAAK,EAAE,IAAI,CAACgH,IAAI,EAAE,IAAI,CAAC+E,UAAU,EAAE,IAAI,CAACoC,UAAU,CAAC;EAClF;AACF;AACA,MAAMmI,iBAAiB,CAAC;EACtBF,UAAU;EACVrW,IAAI;EACJgD,WAAWA,CAACqT,UAAU,EAAErW,IAAI,EAAE;IAC5B,IAAI,CAACqW,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACrW,IAAI,GAAGA,IAAI;EAClB;AACF;AACA,MAAMkP,eAAe,SAASf,UAAU,CAAC;EACvCqI,SAAS;EACTvH,SAAS;EACTD,QAAQ;EACRhM,WAAWA,CAACwT,SAAS,EAAExH,QAAQ,EAAEC,SAAS,GAAG,IAAI,EAAEhI,IAAI,EAAEmH,UAAU,EAAE;IACnE,KAAK,CAACnH,IAAI,IAAI+H,QAAQ,CAAC/H,IAAI,EAAEmH,UAAU,CAAC;IACxC,IAAI,CAACoI,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACvH,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACD,QAAQ,GAAGA,QAAQ;EAC1B;EACAnB,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAYyG,eAAe,IAAI,IAAI,CAACsH,SAAS,CAAC3I,YAAY,CAACpF,CAAC,CAAC+N,SAAS,CAAC,IAAI,IAAI,CAACxH,QAAQ,CAACnB,YAAY,CAACpF,CAAC,CAACuG,QAAQ,CAAC,IAAItB,oBAAoB,CAAC,IAAI,CAACuB,SAAS,EAAExG,CAAC,CAACwG,SAAS,CAAC;EAChL;EACA+C,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAC,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAAC6Q,oBAAoB,CAAC,IAAI,EAAEpQ,OAAO,CAAC;EACpD;EACA8L,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIjD,eAAe,CAAC,IAAI,CAACsH,SAAS,CAACrE,KAAK,CAAC,CAAC,EAAE,IAAI,CAACnD,QAAQ,CAACmD,KAAK,CAAC,CAAC,EAAE,IAAI,CAAClD,SAAS,EAAEkD,KAAK,CAAC,CAAC,EAAE,IAAI,CAAClL,IAAI,EAAE,IAAI,CAACmH,UAAU,CAAC;EAChI;AACF;AACA,MAAMsI,iBAAiB,SAASvI,UAAU,CAAC;EACzCwI,GAAG;EACHC,UAAU;EACV5T,WAAWA,CAAC2T,GAAG,EAAEvI,UAAU,EAAEwI,UAAU,EAAE;IACvC,KAAK,CAAC,IAAI,EAAExI,UAAU,CAAC;IACvB,IAAI,CAACuI,GAAG,GAAGA,GAAG;IACd,IAAI,CAACC,UAAU,GAAGA,UAAU;EAC9B;EACA/I,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAYiO,iBAAiB,IAAI,IAAI,CAACC,GAAG,KAAKlO,CAAC,CAACkO,GAAG,IAAI,IAAI,CAACC,UAAU,KAAKnO,CAAC,CAACmO,UAAU;EACjG;EACA5E,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAC,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAACiR,sBAAsB,CAAC,IAAI,EAAExQ,OAAO,CAAC;EACtD;EACA8L,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIuE,iBAAiB,CAAC,OAAO,IAAI,CAACC,GAAG,KAAK,QAAQ,GAAG,IAAI,CAACA,GAAG,GAAG,IAAI,CAACA,GAAG,CAACxE,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC/D,UAAU,EAAE,IAAI,CAACwI,UAAU,CAAC;EAC5H;AACF;AACA,MAAME,OAAO,SAAS3I,UAAU,CAAC;EAC/BqI,SAAS;EACTxT,WAAWA,CAACwT,SAAS,EAAEpI,UAAU,EAAE;IACjC,KAAK,CAACtB,SAAS,EAAEsB,UAAU,CAAC;IAC5B,IAAI,CAACoI,SAAS,GAAGA,SAAS;EAC5B;EACA3I,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAYqO,OAAO,IAAI,IAAI,CAACN,SAAS,CAAC3I,YAAY,CAACpF,CAAC,CAAC+N,SAAS,CAAC;EACzE;EACAxE,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAC,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAACmR,YAAY,CAAC,IAAI,EAAE1Q,OAAO,CAAC;EAC5C;EACA8L,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI2E,OAAO,CAAC,IAAI,CAACN,SAAS,CAACrE,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC/D,UAAU,CAAC;EAC7D;AACF;AACA,MAAM4I,OAAO,CAAC;EACZhX,IAAI;EACJiH,IAAI;EACJjE,WAAWA,CAAChD,IAAI,EAAEiH,IAAI,GAAG,IAAI,EAAE;IAC7B,IAAI,CAACjH,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACiH,IAAI,GAAGA,IAAI;EAClB;EACA4G,YAAYA,CAACoJ,KAAK,EAAE;IAClB,OAAO,IAAI,CAACjX,IAAI,KAAKiX,KAAK,CAACjX,IAAI;EACjC;EACAmS,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI6E,OAAO,CAAC,IAAI,CAAChX,IAAI,EAAE,IAAI,CAACiH,IAAI,CAAC;EAC1C;AACF;AACA,MAAMiQ,YAAY,SAAS/I,UAAU,CAAC;EACpCO,MAAM;EACNyI,UAAU;EACVnX,IAAI;EACJgD,WAAWA,CAAC0L,MAAM,EAAEyI,UAAU,EAAElQ,IAAI,EAAEmH,UAAU,EAAEpO,IAAI,EAAE;IACtD,KAAK,CAACiH,IAAI,EAAEmH,UAAU,CAAC;IACvB,IAAI,CAACM,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACyI,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACnX,IAAI,GAAGA,IAAI;EAClB;EACA6N,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAO,CAACA,CAAC,YAAYyO,YAAY,IAAIzO,CAAC,YAAY2O,mBAAmB,KAAKpJ,gBAAgB,CAAC,IAAI,CAACU,MAAM,EAAEjG,CAAC,CAACiG,MAAM,CAAC,IAAIV,gBAAgB,CAAC,IAAI,CAACmJ,UAAU,EAAE1O,CAAC,CAAC0O,UAAU,CAAC;EACtK;EACAnF,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAC,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAACyR,iBAAiB,CAAC,IAAI,EAAEhR,OAAO,CAAC;EACjD;EACAiR,UAAUA,CAACtX,IAAI,EAAEuL,SAAS,EAAE;IAC1B,OAAO,IAAI6L,mBAAmB,CAACpX,IAAI,EAAE,IAAI,CAAC0O,MAAM,EAAE,IAAI,CAACyI,UAAU,EAAE,IAAI,CAAClQ,IAAI,EAAEsE,SAAS,EAAE,IAAI,CAAC6C,UAAU,CAAC;EAC3G;EACA+D,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI+E,YAAY,CAAC,IAAI,CAACxI,MAAM,CAACrM,GAAG,CAACkV,CAAC,IAAIA,CAAC,CAACpF,KAAK,CAAC,CAAC,CAAC,EAAE,IAAI,CAACgF,UAAU,EAAE,IAAI,CAAClQ,IAAI,EAAE,IAAI,CAACmH,UAAU,EAAE,IAAI,CAACpO,IAAI,CAAC;EAClH;AACF;AACA,MAAMwX,iBAAiB,SAASrJ,UAAU,CAAC;EACzCO,MAAM;EACN8E,IAAI;EACJxQ,WAAWA,CAAC0L,MAAM,EAAE8E,IAAI,EAAEvM,IAAI,EAAEmH,UAAU,EAAE;IAC1C,KAAK,CAACnH,IAAI,EAAEmH,UAAU,CAAC;IACvB,IAAI,CAACM,MAAM,GAAGA,MAAM;IACpB,IAAI,CAAC8E,IAAI,GAAGA,IAAI;EAClB;EACA3F,YAAYA,CAACpF,CAAC,EAAE;IACd,IAAI,EAAEA,CAAC,YAAY+O,iBAAiB,CAAC,IAAI,CAACxJ,gBAAgB,CAAC,IAAI,CAACU,MAAM,EAAEjG,CAAC,CAACiG,MAAM,CAAC,EAAE;MACjF,OAAO,KAAK;IACd;IACA,IAAI,IAAI,CAAC8E,IAAI,YAAYrF,UAAU,IAAI1F,CAAC,CAAC+K,IAAI,YAAYrF,UAAU,EAAE;MACnE,OAAO,IAAI,CAACqF,IAAI,CAAC3F,YAAY,CAACpF,CAAC,CAAC+K,IAAI,CAAC;IACvC;IACA,IAAIiE,KAAK,CAACC,OAAO,CAAC,IAAI,CAAClE,IAAI,CAAC,IAAIiE,KAAK,CAACC,OAAO,CAACjP,CAAC,CAAC+K,IAAI,CAAC,EAAE;MACrD,OAAOxF,gBAAgB,CAAC,IAAI,CAACwF,IAAI,EAAE/K,CAAC,CAAC+K,IAAI,CAAC;IAC5C;IACA,OAAO,KAAK;EACd;EACAxB,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAC,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAAC+R,sBAAsB,CAAC,IAAI,EAAEtR,OAAO,CAAC;EACtD;EACA8L,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIqF,iBAAiB,CAAC,IAAI,CAAC9I,MAAM,CAACrM,GAAG,CAACkV,CAAC,IAAIA,CAAC,CAACpF,KAAK,CAAC,CAAC,CAAC,EAAEsF,KAAK,CAACC,OAAO,CAAC,IAAI,CAAClE,IAAI,CAAC,GAAG,IAAI,CAACA,IAAI,GAAG,IAAI,CAACA,IAAI,CAACrB,KAAK,CAAC,CAAC,EAAE,IAAI,CAAClL,IAAI,EAAE,IAAI,CAACmH,UAAU,CAAC;EACrJ;EACAkJ,UAAUA,CAACtX,IAAI,EAAEuL,SAAS,EAAE;IAC1B,OAAO,IAAIqM,cAAc,CAAC5X,IAAI,EAAE,IAAI,EAAE4M,aAAa,EAAErB,SAAS,EAAE,IAAI,CAAC6C,UAAU,CAAC;EAClF;AACF;AACA,MAAMyJ,iBAAiB,SAAS1J,UAAU,CAAC;EACzC2J,QAAQ;EACRxF,IAAI;EACJyF,MAAM;EACN/U,WAAWA,CAAC8U,QAAQ,EAAExF,IAAI,EAAErL,IAAI,EAAEmH,UAAU,EAAE2J,MAAM,GAAG,IAAI,EAAE;IAC3D,KAAK,CAAC9Q,IAAI,IAAIiG,WAAW,EAAEkB,UAAU,CAAC;IACtC,IAAI,CAAC0J,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACxF,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACyF,MAAM,GAAGA,MAAM;EACtB;EACAlK,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAYoP,iBAAiB,IAAI,IAAI,CAACC,QAAQ,KAAKrP,CAAC,CAACqP,QAAQ,IAAI,IAAI,CAACxF,IAAI,CAACzE,YAAY,CAACpF,CAAC,CAAC6J,IAAI,CAAC;EACzG;EACAN,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAC,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAACoS,sBAAsB,CAAC,IAAI,EAAE3R,OAAO,CAAC;EACtD;EACA8L,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI0F,iBAAiB,CAAC,IAAI,CAACC,QAAQ,EAAE,IAAI,CAACxF,IAAI,CAACH,KAAK,CAAC,CAAC,EAAE,IAAI,CAAClL,IAAI,EAAE,IAAI,CAACmH,UAAU,EAAE,IAAI,CAAC2J,MAAM,CAAC;EACzG;AACF;AACA,MAAME,iBAAiB,SAAS9J,UAAU,CAAC;EACzCmE,IAAI;EACJtP,WAAWA,CAACsP,IAAI,EAAErL,IAAI,EAAEmH,UAAU,EAAE;IAClC,KAAK,CAACnH,IAAI,EAAEmH,UAAU,CAAC;IACvB,IAAI,CAACkE,IAAI,GAAGA,IAAI;EAClB;EACAL,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAACsS,sBAAsB,CAAC,IAAI,EAAE7R,OAAO,CAAC;EACtD;EACAwH,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAYwP,iBAAiB,IAAIxP,CAAC,CAAC6J,IAAI,CAACzE,YAAY,CAAC,IAAI,CAACyE,IAAI,CAAC;EACzE;EACAN,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI,CAACM,IAAI,CAACN,UAAU,CAAC,CAAC;EAC/B;EACAG,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI8F,iBAAiB,CAAC,IAAI,CAAC3F,IAAI,CAACH,KAAK,CAAC,CAAC,CAAC;EACjD;AACF;AACA,MAAM9C,kBAAkB,SAASlB,UAAU,CAAC;EAC1C2J,QAAQ;EACR1I,GAAG;EACH+I,GAAG;EACHnV,WAAWA,CAAC8U,QAAQ,EAAEK,GAAG,EAAE/I,GAAG,EAAEnI,IAAI,EAAEmH,UAAU,EAAE;IAChD,KAAK,CAACnH,IAAI,IAAIkR,GAAG,CAAClR,IAAI,EAAEmH,UAAU,CAAC;IACnC,IAAI,CAAC0J,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC1I,GAAG,GAAGA,GAAG;IACd,IAAI,CAAC+I,GAAG,GAAGA,GAAG;EAChB;EACAtK,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAY4G,kBAAkB,IAAI,IAAI,CAACyI,QAAQ,KAAKrP,CAAC,CAACqP,QAAQ,IAAI,IAAI,CAACK,GAAG,CAACtK,YAAY,CAACpF,CAAC,CAAC0P,GAAG,CAAC,IAAI,IAAI,CAAC/I,GAAG,CAACvB,YAAY,CAACpF,CAAC,CAAC2G,GAAG,CAAC;EACxI;EACA4C,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAC,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAACwS,uBAAuB,CAAC,IAAI,EAAE/R,OAAO,CAAC;EACvD;EACA8L,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI9C,kBAAkB,CAAC,IAAI,CAACyI,QAAQ,EAAE,IAAI,CAACK,GAAG,CAAChG,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC/C,GAAG,CAAC+C,KAAK,CAAC,CAAC,EAAE,IAAI,CAAClL,IAAI,EAAE,IAAI,CAACmH,UAAU,CAAC;EAC9G;EACAiK,YAAYA,CAAA,EAAG;IACb,MAAMC,EAAE,GAAG,IAAI,CAACR,QAAQ;IACxB,OAAOQ,EAAE,KAAK7K,cAAc,CAAC2E,MAAM,IAAIkG,EAAE,KAAK7K,cAAc,CAAC8K,kBAAkB,IAAID,EAAE,KAAK7K,cAAc,CAAC+K,qBAAqB,IAAIF,EAAE,KAAK7K,cAAc,CAACgL,wBAAwB,IAAIH,EAAE,KAAK7K,cAAc,CAACiL,kBAAkB,IAAIJ,EAAE,KAAK7K,cAAc,CAACkL,mBAAmB,IAAIL,EAAE,KAAK7K,cAAc,CAACmL,wBAAwB,IAAIN,EAAE,KAAK7K,cAAc,CAACoL,aAAa,IAAIP,EAAE,KAAK7K,cAAc,CAACqL,YAAY,IAAIR,EAAE,KAAK7K,cAAc,CAACsL,yBAAyB;EAC7b;AACF;AACA,MAAMzK,YAAY,SAASH,UAAU,CAAC;EACpC4E,QAAQ;EACR/S,IAAI;EACJgD,WAAWA,CAAC+P,QAAQ,EAAE/S,IAAI,EAAEiH,IAAI,EAAEmH,UAAU,EAAE;IAC5C,KAAK,CAACnH,IAAI,EAAEmH,UAAU,CAAC;IACvB,IAAI,CAAC2E,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC/S,IAAI,GAAGA,IAAI;EAClB;EACA,IAAIyJ,KAAKA,CAAA,EAAG;IACV,OAAO,IAAI,CAACzJ,IAAI;EAClB;EACA6N,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAY6F,YAAY,IAAI,IAAI,CAACyE,QAAQ,CAAClF,YAAY,CAACpF,CAAC,CAACsK,QAAQ,CAAC,IAAI,IAAI,CAAC/S,IAAI,KAAKyI,CAAC,CAACzI,IAAI;EACpG;EACAgS,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAC,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAACoT,iBAAiB,CAAC,IAAI,EAAE3S,OAAO,CAAC;EACjD;EACAnE,GAAGA,CAACjC,KAAK,EAAE;IACT,OAAO,IAAIoP,kBAAkB,CAAC5B,cAAc,CAAC2E,MAAM,EAAE,IAAI,CAACW,QAAQ,CAAC1E,IAAI,CAAC,IAAI,CAACrO,IAAI,CAAC,EAAEC,KAAK,EAAE,IAAI,EAAE,IAAI,CAACmO,UAAU,CAAC;EACnH;EACA+D,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI7D,YAAY,CAAC,IAAI,CAACyE,QAAQ,CAACZ,KAAK,CAAC,CAAC,EAAE,IAAI,CAACnS,IAAI,EAAE,IAAI,CAACiH,IAAI,EAAE,IAAI,CAACmH,UAAU,CAAC;EACvF;AACF;AACA,MAAMI,WAAW,SAASL,UAAU,CAAC;EACnC4E,QAAQ;EACRtJ,KAAK;EACLzG,WAAWA,CAAC+P,QAAQ,EAAEtJ,KAAK,EAAExC,IAAI,EAAEmH,UAAU,EAAE;IAC7C,KAAK,CAACnH,IAAI,EAAEmH,UAAU,CAAC;IACvB,IAAI,CAAC2E,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACtJ,KAAK,GAAGA,KAAK;EACpB;EACAoE,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAY+F,WAAW,IAAI,IAAI,CAACuE,QAAQ,CAAClF,YAAY,CAACpF,CAAC,CAACsK,QAAQ,CAAC,IAAI,IAAI,CAACtJ,KAAK,CAACoE,YAAY,CAACpF,CAAC,CAACgB,KAAK,CAAC;EAC/G;EACAuI,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAC,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAACqT,gBAAgB,CAAC,IAAI,EAAE5S,OAAO,CAAC;EAChD;EACAnE,GAAGA,CAACjC,KAAK,EAAE;IACT,OAAO,IAAIoP,kBAAkB,CAAC5B,cAAc,CAAC2E,MAAM,EAAE,IAAI,CAACW,QAAQ,CAACxE,GAAG,CAAC,IAAI,CAAC9E,KAAK,CAAC,EAAExJ,KAAK,EAAE,IAAI,EAAE,IAAI,CAACmO,UAAU,CAAC;EACnH;EACA+D,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI3D,WAAW,CAAC,IAAI,CAACuE,QAAQ,CAACZ,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC1I,KAAK,CAAC0I,KAAK,CAAC,CAAC,EAAE,IAAI,CAAClL,IAAI,EAAE,IAAI,CAACmH,UAAU,CAAC;EAC/F;AACF;AACA,MAAM8K,gBAAgB,SAAS/K,UAAU,CAAC;EACxCgL,OAAO;EACPnW,WAAWA,CAACmW,OAAO,EAAElS,IAAI,EAAEmH,UAAU,EAAE;IACrC,KAAK,CAACnH,IAAI,EAAEmH,UAAU,CAAC;IACvB,IAAI,CAAC+K,OAAO,GAAGA,OAAO;EACxB;EACAnH,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI,CAACmH,OAAO,CAACC,KAAK,CAAC3Q,CAAC,IAAIA,CAAC,CAACuJ,UAAU,CAAC,CAAC,CAAC;EAChD;EACAnE,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAYyQ,gBAAgB,IAAIlL,gBAAgB,CAAC,IAAI,CAACmL,OAAO,EAAE1Q,CAAC,CAAC0Q,OAAO,CAAC;EACnF;EACAlH,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAACyT,qBAAqB,CAAC,IAAI,EAAEhT,OAAO,CAAC;EACrD;EACA8L,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI+G,gBAAgB,CAAC,IAAI,CAACC,OAAO,CAAC9W,GAAG,CAACoG,CAAC,IAAIA,CAAC,CAAC0J,KAAK,CAAC,CAAC,CAAC,EAAE,IAAI,CAAClL,IAAI,EAAE,IAAI,CAACmH,UAAU,CAAC;EAC3F;AACF;AACA,MAAMkL,eAAe,CAAC;EACpB/K,GAAG;EACHtO,KAAK;EACLsZ,MAAM;EACNvW,WAAWA,CAACuL,GAAG,EAAEtO,KAAK,EAAEsZ,MAAM,EAAE;IAC9B,IAAI,CAAChL,GAAG,GAAGA,GAAG;IACd,IAAI,CAACtO,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACsZ,MAAM,GAAGA,MAAM;EACtB;EACA1L,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAO,IAAI,CAAC8F,GAAG,KAAK9F,CAAC,CAAC8F,GAAG,IAAI,IAAI,CAACtO,KAAK,CAAC4N,YAAY,CAACpF,CAAC,CAACxI,KAAK,CAAC;EAC/D;EACAkS,KAAKA,CAAA,EAAG;IACN,OAAO,IAAImH,eAAe,CAAC,IAAI,CAAC/K,GAAG,EAAE,IAAI,CAACtO,KAAK,CAACkS,KAAK,CAAC,CAAC,EAAE,IAAI,CAACoH,MAAM,CAAC;EACvE;AACF;AACA,MAAMC,cAAc,SAASrL,UAAU,CAAC;EACtCgL,OAAO;EACP7M,SAAS,GAAG,IAAI;EAChBtJ,WAAWA,CAACmW,OAAO,EAAElS,IAAI,EAAEmH,UAAU,EAAE;IACrC,KAAK,CAACnH,IAAI,EAAEmH,UAAU,CAAC;IACvB,IAAI,CAAC+K,OAAO,GAAGA,OAAO;IACtB,IAAIlS,IAAI,EAAE;MACR,IAAI,CAACqF,SAAS,GAAGrF,IAAI,CAACqF,SAAS;IACjC;EACF;EACAuB,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAY+Q,cAAc,IAAIxL,gBAAgB,CAAC,IAAI,CAACmL,OAAO,EAAE1Q,CAAC,CAAC0Q,OAAO,CAAC;EACjF;EACAnH,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI,CAACmH,OAAO,CAACC,KAAK,CAAC3Q,CAAC,IAAIA,CAAC,CAACxI,KAAK,CAAC+R,UAAU,CAAC,CAAC,CAAC;EACtD;EACAC,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAAC6T,mBAAmB,CAAC,IAAI,EAAEpT,OAAO,CAAC;EACnD;EACA8L,KAAKA,CAAA,EAAG;IACN,MAAMuH,YAAY,GAAG,IAAI,CAACP,OAAO,CAAC9W,GAAG,CAACsX,KAAK,IAAIA,KAAK,CAACxH,KAAK,CAAC,CAAC,CAAC;IAC7D,OAAO,IAAIqH,cAAc,CAACE,YAAY,EAAE,IAAI,CAACzS,IAAI,EAAE,IAAI,CAACmH,UAAU,CAAC;EACrE;AACF;AACA,MAAMwL,SAAS,SAASzL,UAAU,CAAC;EACjCrI,KAAK;EACL9C,WAAWA,CAAC8C,KAAK,EAAEsI,UAAU,EAAE;IAC7B,KAAK,CAACtI,KAAK,CAACA,KAAK,CAAC5H,MAAM,GAAG,CAAC,CAAC,CAAC+I,IAAI,EAAEmH,UAAU,CAAC;IAC/C,IAAI,CAACtI,KAAK,GAAGA,KAAK;EACpB;EACA+H,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAYmR,SAAS,IAAI5L,gBAAgB,CAAC,IAAI,CAAClI,KAAK,EAAE2C,CAAC,CAAC3C,KAAK,CAAC;EACxE;EACAkM,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAC,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,OAAOT,OAAO,CAACiU,cAAc,CAAC,IAAI,EAAExT,OAAO,CAAC;EAC9C;EACA8L,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIyH,SAAS,CAAC,IAAI,CAAC9T,KAAK,CAACzD,GAAG,CAACkV,CAAC,IAAIA,CAAC,CAACpF,KAAK,CAAC,CAAC,CAAC,CAAC;EACtD;AACF;AACA,MAAM2H,SAAS,GAAG,IAAInG,WAAW,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;AACnD,MAAMjC,eAAe,GAAG,IAAIiC,WAAW,CAAC,IAAI,EAAE/G,aAAa,EAAE,IAAI,CAAC;AAClE,IAAImN,YAAY;AAChB,CAAC,UAAUA,YAAY,EAAE;EACvBA,YAAY,CAACA,YAAY,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EAC/CA,YAAY,CAACA,YAAY,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;EACjDA,YAAY,CAACA,YAAY,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;EACrDA,YAAY,CAACA,YAAY,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EACvDA,YAAY,CAACA,YAAY,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;AACrD,CAAC,EAAEA,YAAY,KAAKA,YAAY,GAAG,CAAC,CAAC,CAAC,CAAC;AACvC,MAAMC,cAAc,CAAC;EACnB5T,IAAI;EACJ6T,SAAS;EACTC,eAAe;EACflX,WAAWA,CAACoD,IAAI,EAAE6T,SAAS,EAAEC,eAAe,EAAE;IAC5C,IAAI,CAAC9T,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC6T,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,eAAe,GAAGA,eAAe;EACxC;EACA/Z,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI,CAAC8Z,SAAS,GAAG,IAAI,IAAI,CAAC7T,IAAI,GAAG,GAAG,IAAI,CAACA,IAAI;EACtD;AACF;AACA,MAAM+T,YAAY,SAASH,cAAc,CAAC;EACxCI,IAAI;EACJpX,WAAWA,CAACoX,IAAI,EAAE;IAChB,KAAK,CAAC,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC;IACrB,IAAI,CAACA,IAAI,GAAGA,IAAI;EAClB;EACAja,QAAQA,CAAA,EAAG;IACT,OAAOka,aAAa,CAAC,IAAI,CAACD,IAAI,CAAC;EACjC;AACF;AACA,MAAME,SAAS,CAAC;EACd/O,SAAS;EACT6C,UAAU;EACVmM,eAAe;EACfvX,WAAWA,CAACuI,SAAS,GAAGwO,YAAY,CAACvO,IAAI,EAAE4C,UAAU,GAAG,IAAI,EAAEmM,eAAe,EAAE;IAC7E,IAAI,CAAChP,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAAC6C,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACmM,eAAe,GAAGA,eAAe;EACxC;EACA9O,WAAWA,CAACC,QAAQ,EAAE;IACpB,OAAO,CAAC,IAAI,CAACH,SAAS,GAAGG,QAAQ,MAAM,CAAC;EAC1C;EACA8O,iBAAiBA,CAACC,cAAc,EAAE;IAChC,IAAI,CAACF,eAAe,GAAG,IAAI,CAACA,eAAe,IAAI,EAAE;IACjD,IAAI,CAACA,eAAe,CAACpc,IAAI,CAACsc,cAAc,CAAC;EAC3C;AACF;AACA,MAAM7C,cAAc,SAAS0C,SAAS,CAAC;EACrCta,IAAI;EACJC,KAAK;EACLgH,IAAI;EACJjE,WAAWA,CAAChD,IAAI,EAAEC,KAAK,EAAEgH,IAAI,EAAEsE,SAAS,EAAE6C,UAAU,EAAEmM,eAAe,EAAE;IACrE,KAAK,CAAChP,SAAS,EAAE6C,UAAU,EAAEmM,eAAe,CAAC;IAC7C,IAAI,CAACva,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACgH,IAAI,GAAGA,IAAI,IAAIhH,KAAK,IAAIA,KAAK,CAACgH,IAAI,IAAI,IAAI;EACjD;EACA4G,YAAYA,CAAC6M,IAAI,EAAE;IACjB,OAAOA,IAAI,YAAY9C,cAAc,IAAI,IAAI,CAAC5X,IAAI,KAAK0a,IAAI,CAAC1a,IAAI,KAAK,IAAI,CAACC,KAAK,GAAG,CAAC,CAACya,IAAI,CAACza,KAAK,IAAI,IAAI,CAACA,KAAK,CAAC4N,YAAY,CAAC6M,IAAI,CAACza,KAAK,CAAC,GAAG,CAACya,IAAI,CAACza,KAAK,CAAC;EACtJ;EACA0a,cAAcA,CAAC/U,OAAO,EAAES,OAAO,EAAE;IAC/B,OAAOT,OAAO,CAACgV,mBAAmB,CAAC,IAAI,EAAEvU,OAAO,CAAC;EACnD;AACF;AACA,MAAM+Q,mBAAmB,SAASkD,SAAS,CAAC;EAC1Cta,IAAI;EACJ0O,MAAM;EACNyI,UAAU;EACVlQ,IAAI;EACJjE,WAAWA,CAAChD,IAAI,EAAE0O,MAAM,EAAEyI,UAAU,EAAElQ,IAAI,EAAEsE,SAAS,EAAE6C,UAAU,EAAEmM,eAAe,EAAE;IAClF,KAAK,CAAChP,SAAS,EAAE6C,UAAU,EAAEmM,eAAe,CAAC;IAC7C,IAAI,CAACva,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC0O,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACyI,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAClQ,IAAI,GAAGA,IAAI,IAAI,IAAI;EAC1B;EACA4G,YAAYA,CAAC6M,IAAI,EAAE;IACjB,OAAOA,IAAI,YAAYtD,mBAAmB,IAAIpJ,gBAAgB,CAAC,IAAI,CAACU,MAAM,EAAEgM,IAAI,CAAChM,MAAM,CAAC,IAAIV,gBAAgB,CAAC,IAAI,CAACmJ,UAAU,EAAEuD,IAAI,CAACvD,UAAU,CAAC;EAChJ;EACAwD,cAAcA,CAAC/U,OAAO,EAAES,OAAO,EAAE;IAC/B,OAAOT,OAAO,CAACiV,wBAAwB,CAAC,IAAI,EAAExU,OAAO,CAAC;EACxD;AACF;AACA,MAAMyL,mBAAmB,SAASwI,SAAS,CAAC;EAC1ChI,IAAI;EACJtP,WAAWA,CAACsP,IAAI,EAAElE,UAAU,EAAEmM,eAAe,EAAE;IAC7C,KAAK,CAACR,YAAY,CAACvO,IAAI,EAAE4C,UAAU,EAAEmM,eAAe,CAAC;IACrD,IAAI,CAACjI,IAAI,GAAGA,IAAI;EAClB;EACAzE,YAAYA,CAAC6M,IAAI,EAAE;IACjB,OAAOA,IAAI,YAAY5I,mBAAmB,IAAI,IAAI,CAACQ,IAAI,CAACzE,YAAY,CAAC6M,IAAI,CAACpI,IAAI,CAAC;EACjF;EACAqI,cAAcA,CAAC/U,OAAO,EAAES,OAAO,EAAE;IAC/B,OAAOT,OAAO,CAACkV,mBAAmB,CAAC,IAAI,EAAEzU,OAAO,CAAC;EACnD;AACF;AACA,MAAM0U,eAAe,SAAST,SAAS,CAAC;EACtCra,KAAK;EACL+C,WAAWA,CAAC/C,KAAK,EAAEmO,UAAU,GAAG,IAAI,EAAEmM,eAAe,EAAE;IACrD,KAAK,CAACR,YAAY,CAACvO,IAAI,EAAE4C,UAAU,EAAEmM,eAAe,CAAC;IACrD,IAAI,CAACta,KAAK,GAAGA,KAAK;EACpB;EACA4N,YAAYA,CAAC6M,IAAI,EAAE;IACjB,OAAOA,IAAI,YAAYK,eAAe,IAAI,IAAI,CAAC9a,KAAK,CAAC4N,YAAY,CAAC6M,IAAI,CAACza,KAAK,CAAC;EAC/E;EACA0a,cAAcA,CAAC/U,OAAO,EAAES,OAAO,EAAE;IAC/B,OAAOT,OAAO,CAACoV,eAAe,CAAC,IAAI,EAAE3U,OAAO,CAAC;EAC/C;AACF;AACA,MAAM4U,MAAM,SAASX,SAAS,CAAC;EAC7B9D,SAAS;EACTxH,QAAQ;EACRC,SAAS;EACTjM,WAAWA,CAACwT,SAAS,EAAExH,QAAQ,EAAEC,SAAS,GAAG,EAAE,EAAEb,UAAU,EAAEmM,eAAe,EAAE;IAC5E,KAAK,CAACR,YAAY,CAACvO,IAAI,EAAE4C,UAAU,EAAEmM,eAAe,CAAC;IACrD,IAAI,CAAC/D,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACxH,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,SAAS,GAAGA,SAAS;EAC5B;EACApB,YAAYA,CAAC6M,IAAI,EAAE;IACjB,OAAOA,IAAI,YAAYO,MAAM,IAAI,IAAI,CAACzE,SAAS,CAAC3I,YAAY,CAAC6M,IAAI,CAAClE,SAAS,CAAC,IAAIxI,gBAAgB,CAAC,IAAI,CAACgB,QAAQ,EAAE0L,IAAI,CAAC1L,QAAQ,CAAC,IAAIhB,gBAAgB,CAAC,IAAI,CAACiB,SAAS,EAAEyL,IAAI,CAACzL,SAAS,CAAC;EACpL;EACA0L,cAAcA,CAAC/U,OAAO,EAAES,OAAO,EAAE;IAC/B,OAAOT,OAAO,CAACsV,WAAW,CAAC,IAAI,EAAE7U,OAAO,CAAC;EAC3C;AACF;AACA,IAAI8U,qBAAqB,GAAG,MAAMC,mBAAmB,CAAC;EACpDvP,SAASA,CAACwP,GAAG,EAAEhV,OAAO,EAAE;IACtB,OAAOgV,GAAG;EACZ;EACApJ,eAAeA,CAACoJ,GAAG,EAAEhV,OAAO,EAAE;IAC5B,IAAIgV,GAAG,CAACpU,IAAI,EAAE;MACZoU,GAAG,CAACpU,IAAI,CAAC4E,SAAS,CAAC,IAAI,EAAExF,OAAO,CAAC;IACnC;IACA,OAAOgV,GAAG;EACZ;EACAvP,gBAAgBA,CAAC7E,IAAI,EAAEZ,OAAO,EAAE;IAC9B,OAAO,IAAI,CAACwF,SAAS,CAAC5E,IAAI,EAAEZ,OAAO,CAAC;EACtC;EACA4F,mBAAmBA,CAAChF,IAAI,EAAEZ,OAAO,EAAE;IACjCY,IAAI,CAAChH,KAAK,CAACgS,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC;IACzC,IAAIY,IAAI,CAAC+E,UAAU,KAAK,IAAI,EAAE;MAC5B/E,IAAI,CAAC+E,UAAU,CAAC5L,OAAO,CAAC6W,KAAK,IAAI,IAAI,CAACpL,SAAS,CAACoL,KAAK,EAAE5Q,OAAO,CAAC,CAAC;IAClE;IACA,OAAO,IAAI,CAACwF,SAAS,CAAC5E,IAAI,EAAEZ,OAAO,CAAC;EACtC;EACA+F,cAAcA,CAACnF,IAAI,EAAEZ,OAAO,EAAE;IAC5B,OAAO,IAAI,CAACwF,SAAS,CAAC5E,IAAI,EAAEZ,OAAO,CAAC;EACtC;EACAkG,YAAYA,CAACtF,IAAI,EAAEZ,OAAO,EAAE;IAC1B,OAAO,IAAI,CAACwF,SAAS,CAAC5E,IAAI,EAAEZ,OAAO,CAAC;EACtC;EACAoG,qBAAqBA,CAACxF,IAAI,EAAEZ,OAAO,EAAE;IACnC,OAAOY,IAAI;EACb;EACA2L,oBAAoBA,CAACyI,GAAG,EAAEhV,OAAO,EAAE;IACjC,OAAOgV,GAAG;EACZ;EACAnJ,gBAAgBA,CAACmJ,GAAG,EAAEhV,OAAO,EAAE;IAC7B,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACAwQ,sBAAsBA,CAACwE,GAAG,EAAEhV,OAAO,EAAE;IACnC,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACA2M,uBAAuBA,CAACqI,GAAG,EAAEhV,OAAO,EAAE;IACpCgV,GAAG,CAACxI,EAAE,CAACZ,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC;IACrC,IAAI,CAACiV,mBAAmB,CAACD,GAAG,CAACvI,IAAI,EAAEzM,OAAO,CAAC;IAC3C,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACA+M,8BAA8BA,CAACiI,GAAG,EAAEhV,OAAO,EAAE;IAC3CgV,GAAG,CAAC1c,GAAG,CAACsT,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC;IACtCgV,GAAG,CAAClI,QAAQ,CAAClB,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC;IAC3C,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACAiN,oBAAoBA,CAAC+H,GAAG,EAAEhV,OAAO,EAAE;IACjCgV,GAAG,CAAChI,SAAS,CAACpB,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC;IAC5C,IAAI,CAACiV,mBAAmB,CAACD,GAAG,CAACvI,IAAI,EAAEzM,OAAO,CAAC;IAC3C,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACAuN,gBAAgBA,CAACyH,GAAG,EAAEhV,OAAO,EAAE;IAC7B,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACAqN,6BAA6BA,CAAC2H,GAAG,EAAEhV,OAAO,EAAE;IAC1C,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACA4O,oBAAoBA,CAACoG,GAAG,EAAEhV,OAAO,EAAE;IACjC,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACAiQ,iBAAiBA,CAAC+E,GAAG,EAAEhV,OAAO,EAAE;IAC9B,IAAIgV,GAAG,CAACrP,UAAU,EAAE;MAClBqP,GAAG,CAACrP,UAAU,CAAC5L,OAAO,CAAC6G,IAAI,IAAIA,IAAI,CAAC4E,SAAS,CAAC,IAAI,EAAExF,OAAO,CAAC,CAAC;IAC/D;IACA,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACAoQ,oBAAoBA,CAAC4E,GAAG,EAAEhV,OAAO,EAAE;IACjCgV,GAAG,CAAC7E,SAAS,CAACvE,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC;IAC5CgV,GAAG,CAACrM,QAAQ,CAACiD,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC;IAC3CgV,GAAG,CAACpM,SAAS,CAACgD,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC;IAC5C,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACA0Q,YAAYA,CAACsE,GAAG,EAAEhV,OAAO,EAAE;IACzBgV,GAAG,CAAC7E,SAAS,CAACvE,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC;IAC5C,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACAgR,iBAAiBA,CAACgE,GAAG,EAAEhV,OAAO,EAAE;IAC9B,IAAI,CAACkV,kBAAkB,CAACF,GAAG,CAAClE,UAAU,EAAE9Q,OAAO,CAAC;IAChD,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACAsR,sBAAsBA,CAAC0D,GAAG,EAAEhV,OAAO,EAAE;IACnC,IAAIoR,KAAK,CAACC,OAAO,CAAC2D,GAAG,CAAC7H,IAAI,CAAC,EAAE;MAC3B,IAAI,CAAC+H,kBAAkB,CAACF,GAAG,CAAC7H,IAAI,EAAEnN,OAAO,CAAC;IAC5C,CAAC,MAAM;MACLgV,GAAG,CAAC7H,IAAI,CAACvB,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC;IACzC;IACA,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACA2R,sBAAsBA,CAACqD,GAAG,EAAEhV,OAAO,EAAE;IACnCgV,GAAG,CAAC/I,IAAI,CAACL,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC;IACvC,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACAkM,eAAeA,CAAC8I,GAAG,EAAEhV,OAAO,EAAE;IAC5BgV,GAAG,CAAC/I,IAAI,CAACL,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC;IACvC,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACAoM,aAAaA,CAAC4I,GAAG,EAAEhV,OAAO,EAAE;IAC1BgV,GAAG,CAAC/I,IAAI,CAACL,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC;IACvC,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACA+R,uBAAuBA,CAACiD,GAAG,EAAEhV,OAAO,EAAE;IACpCgV,GAAG,CAAClD,GAAG,CAAClG,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC;IACtCgV,GAAG,CAACjM,GAAG,CAAC6C,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC;IACtC,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACA2S,iBAAiBA,CAACqC,GAAG,EAAEhV,OAAO,EAAE;IAC9BgV,GAAG,CAACtI,QAAQ,CAACd,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC;IAC3C,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACA4S,gBAAgBA,CAACoC,GAAG,EAAEhV,OAAO,EAAE;IAC7BgV,GAAG,CAACtI,QAAQ,CAACd,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC;IAC3CgV,GAAG,CAAC5R,KAAK,CAACwI,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC;IACxC,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACAgT,qBAAqBA,CAACgC,GAAG,EAAEhV,OAAO,EAAE;IAClC,IAAI,CAACiV,mBAAmB,CAACD,GAAG,CAAClC,OAAO,EAAE9S,OAAO,CAAC;IAC9C,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACAoT,mBAAmBA,CAAC4B,GAAG,EAAEhV,OAAO,EAAE;IAChCgV,GAAG,CAAClC,OAAO,CAAC/Y,OAAO,CAACuZ,KAAK,IAAIA,KAAK,CAAC1Z,KAAK,CAACgS,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC,CAAC;IACxE,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACAwT,cAAcA,CAACwB,GAAG,EAAEhV,OAAO,EAAE;IAC3B,IAAI,CAACiV,mBAAmB,CAACD,GAAG,CAACvV,KAAK,EAAEO,OAAO,CAAC;IAC5C,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACA2N,wBAAwBA,CAACqH,GAAG,EAAEhV,OAAO,EAAE;IACrC,IAAI,CAACiV,mBAAmB,CAACD,GAAG,CAACvH,QAAQ,EAAEzN,OAAO,CAAC;IAC/C,IAAI,CAACiV,mBAAmB,CAACD,GAAG,CAACtH,WAAW,EAAE1N,OAAO,CAAC;IAClD,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACAiO,+BAA+BA,CAAC+G,GAAG,EAAEhV,OAAO,EAAE;IAC5C,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACA6R,sBAAsBA,CAACmD,GAAG,EAAEhV,OAAO,EAAE;IACnCgV,GAAG,CAAC/I,IAAI,CAACL,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC;IACvC,OAAO,IAAI,CAAC4L,eAAe,CAACoJ,GAAG,EAAEhV,OAAO,CAAC;EAC3C;EACAiV,mBAAmBA,CAACE,KAAK,EAAEnV,OAAO,EAAE;IAClCmV,KAAK,CAACpb,OAAO,CAACkS,IAAI,IAAIA,IAAI,CAACL,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC,CAAC;EAC5D;EACAuU,mBAAmBA,CAACF,IAAI,EAAErU,OAAO,EAAE;IACjC,IAAIqU,IAAI,CAACza,KAAK,EAAE;MACdya,IAAI,CAACza,KAAK,CAACgS,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC;IAC3C;IACA,IAAIqU,IAAI,CAACzT,IAAI,EAAE;MACbyT,IAAI,CAACzT,IAAI,CAAC4E,SAAS,CAAC,IAAI,EAAExF,OAAO,CAAC;IACpC;IACA,OAAOqU,IAAI;EACb;EACAG,wBAAwBA,CAACH,IAAI,EAAErU,OAAO,EAAE;IACtC,IAAI,CAACkV,kBAAkB,CAACb,IAAI,CAACvD,UAAU,EAAE9Q,OAAO,CAAC;IACjD,IAAIqU,IAAI,CAACzT,IAAI,EAAE;MACbyT,IAAI,CAACzT,IAAI,CAAC4E,SAAS,CAAC,IAAI,EAAExF,OAAO,CAAC;IACpC;IACA,OAAOqU,IAAI;EACb;EACAI,mBAAmBA,CAACJ,IAAI,EAAErU,OAAO,EAAE;IACjCqU,IAAI,CAACpI,IAAI,CAACL,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC;IACxC,OAAOqU,IAAI;EACb;EACAM,eAAeA,CAACN,IAAI,EAAErU,OAAO,EAAE;IAC7BqU,IAAI,CAACza,KAAK,CAACgS,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC;IACzC,OAAOqU,IAAI;EACb;EACAQ,WAAWA,CAACR,IAAI,EAAErU,OAAO,EAAE;IACzBqU,IAAI,CAAClE,SAAS,CAACvE,eAAe,CAAC,IAAI,EAAE5L,OAAO,CAAC;IAC7C,IAAI,CAACkV,kBAAkB,CAACb,IAAI,CAAC1L,QAAQ,EAAE3I,OAAO,CAAC;IAC/C,IAAI,CAACkV,kBAAkB,CAACb,IAAI,CAACzL,SAAS,EAAE5I,OAAO,CAAC;IAChD,OAAOqU,IAAI;EACb;EACAa,kBAAkBA,CAACE,KAAK,EAAEpV,OAAO,EAAE;IACjCoV,KAAK,CAACrb,OAAO,CAACsa,IAAI,IAAIA,IAAI,CAACC,cAAc,CAAC,IAAI,EAAEtU,OAAO,CAAC,CAAC;EAC3D;AACF,CAAC;AACD,SAASoU,cAAcA,CAACrU,IAAI,EAAE6T,SAAS,GAAG,KAAK,EAAEC,eAAe,GAAG,IAAI,EAAE;EACvE,OAAO,IAAIF,cAAc,CAAC5T,IAAI,EAAE6T,SAAS,EAAEC,eAAe,CAAC;AAC7D;AACA,SAASwB,YAAYA,CAACtB,IAAI,GAAG,EAAE,EAAE;EAC/B,OAAO,IAAID,YAAY,CAACC,IAAI,CAAC;AAC/B;AACA,SAASuB,QAAQA,CAAC3b,IAAI,EAAEiH,IAAI,EAAEmH,UAAU,EAAE;EACxC,OAAO,IAAI2D,WAAW,CAAC/R,IAAI,EAAEiH,IAAI,EAAEmH,UAAU,CAAC;AAChD;AACA,SAASwN,UAAUA,CAACxW,EAAE,EAAE4G,UAAU,GAAG,IAAI,EAAEoC,UAAU,EAAE;EACrD,OAAO,IAAIgI,YAAY,CAAChR,EAAE,EAAE,IAAI,EAAE4G,UAAU,EAAEoC,UAAU,CAAC;AAC3D;AACA,SAASyN,UAAUA,CAACzW,EAAE,EAAE4G,UAAU,EAAE8P,aAAa,EAAE;EACjD,OAAO1W,EAAE,IAAI,IAAI,GAAG2W,cAAc,CAACH,UAAU,CAACxW,EAAE,EAAE4G,UAAU,EAAE,IAAI,CAAC,EAAE8P,aAAa,CAAC,GAAG,IAAI;AAC5F;AACA,SAASC,cAAcA,CAACzJ,IAAI,EAAEwJ,aAAa,EAAE9P,UAAU,EAAE;EACvD,OAAO,IAAID,cAAc,CAACuG,IAAI,EAAEwJ,aAAa,EAAE9P,UAAU,CAAC;AAC5D;AACA,SAASgQ,gBAAgBA,CAAC/U,IAAI,EAAE6U,aAAa,EAAE;EAC7C,OAAO,IAAItP,gBAAgB,CAACvF,IAAI,EAAE6U,aAAa,CAAC;AAClD;AACA,SAASG,UAAUA,CAAC3J,IAAI,EAAE;EACxB,OAAO,IAAID,UAAU,CAACC,IAAI,CAAC;AAC7B;AACA,SAAS4J,UAAUA,CAACC,MAAM,EAAElV,IAAI,EAAEmH,UAAU,EAAE;EAC5C,OAAO,IAAI8K,gBAAgB,CAACiD,MAAM,EAAElV,IAAI,EAAEmH,UAAU,CAAC;AACvD;AACA,SAASgO,UAAUA,CAACD,MAAM,EAAElV,IAAI,GAAG,IAAI,EAAE;EACvC,OAAO,IAAIuS,cAAc,CAAC2C,MAAM,CAAC9Z,GAAG,CAACoG,CAAC,IAAI,IAAI6Q,eAAe,CAAC7Q,CAAC,CAAC8F,GAAG,EAAE9F,CAAC,CAACxI,KAAK,EAAEwI,CAAC,CAAC8Q,MAAM,CAAC,CAAC,EAAEtS,IAAI,EAAE,IAAI,CAAC;AACvG;AACA,SAASoV,KAAKA,CAACvE,QAAQ,EAAExF,IAAI,EAAErL,IAAI,EAAEmH,UAAU,EAAE;EAC/C,OAAO,IAAIyJ,iBAAiB,CAACC,QAAQ,EAAExF,IAAI,EAAErL,IAAI,EAAEmH,UAAU,CAAC;AAChE;AACA,SAASkO,GAAGA,CAAChK,IAAI,EAAElE,UAAU,EAAE;EAC7B,OAAO,IAAI0I,OAAO,CAACxE,IAAI,EAAElE,UAAU,CAAC;AACtC;AACA,SAASyE,EAAEA,CAACnE,MAAM,EAAE8E,IAAI,EAAEvM,IAAI,EAAEmH,UAAU,EAAEpO,IAAI,EAAE;EAChD,OAAO,IAAIkX,YAAY,CAACxI,MAAM,EAAE8E,IAAI,EAAEvM,IAAI,EAAEmH,UAAU,EAAEpO,IAAI,CAAC;AAC/D;AACA,SAASuc,OAAOA,CAAC7N,MAAM,EAAE8E,IAAI,EAAEvM,IAAI,EAAEmH,UAAU,EAAE;EAC/C,OAAO,IAAIoJ,iBAAiB,CAAC9I,MAAM,EAAE8E,IAAI,EAAEvM,IAAI,EAAEmH,UAAU,CAAC;AAC9D;AACA,SAASoO,MAAMA,CAAChG,SAAS,EAAEiG,UAAU,EAAEC,UAAU,EAAEtO,UAAU,EAAEmM,eAAe,EAAE;EAC9E,OAAO,IAAIU,MAAM,CAACzE,SAAS,EAAEiG,UAAU,EAAEC,UAAU,EAAEtO,UAAU,EAAEmM,eAAe,CAAC;AACnF;AACA,SAASoC,cAAcA,CAAChe,GAAG,EAAEwU,QAAQ,EAAElM,IAAI,EAAEmH,UAAU,EAAE;EACvD,OAAO,IAAI8E,yBAAyB,CAACvU,GAAG,EAAEwU,QAAQ,EAAElM,IAAI,EAAEmH,UAAU,CAAC;AACvE;AACA,SAASwO,OAAOA,CAAC3c,KAAK,EAAEgH,IAAI,EAAEmH,UAAU,EAAE;EACxC,OAAO,IAAIuF,WAAW,CAAC1T,KAAK,EAAEgH,IAAI,EAAEmH,UAAU,CAAC;AACjD;AACA,SAASyO,eAAeA,CAAC/H,SAAS,EAAEC,YAAY,EAAE+H,gBAAgB,EAAE/I,WAAW,EAAE3F,UAAU,EAAE;EAC3F,OAAO,IAAIyG,eAAe,CAACC,SAAS,EAAEC,YAAY,EAAE+H,gBAAgB,EAAE/I,WAAW,EAAE3F,UAAU,CAAC;AAChG;AACA,SAAS2O,MAAMA,CAACC,GAAG,EAAE;EACnB,OAAOA,GAAG,YAAYrJ,WAAW,IAAIqJ,GAAG,CAAC/c,KAAK,KAAK,IAAI;AACzD;AACA,SAASgd,WAAWA,CAACte,GAAG,EAAE;EACxB,IAAIue,GAAG,GAAG,EAAE;EACZ,IAAIve,GAAG,CAACwe,OAAO,EAAE;IACfD,GAAG,IAAI,KAAKve,GAAG,CAACwe,OAAO,EAAE;EAC3B;EACA,IAAIxe,GAAG,CAACyH,IAAI,EAAE;IACZ,IAAIzH,GAAG,CAACyH,IAAI,CAAC/H,KAAK,CAAC,WAAW,CAAC,EAAE;MAC/B,MAAM,IAAIK,KAAK,CAAC,yCAAyC,CAAC;IAC5D;IACAwe,GAAG,IAAI,GAAG,GAAGve,GAAG,CAACyH,IAAI,CAAC1G,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC;EAC5C;EACA,OAAOwd,GAAG;AACZ;AACA,SAAS7C,aAAaA,CAACD,IAAI,EAAE;EAC3B,IAAIA,IAAI,CAAClc,MAAM,KAAK,CAAC,EAAE,OAAO,EAAE;EAChC,IAAIkc,IAAI,CAAClc,MAAM,KAAK,CAAC,IAAIkc,IAAI,CAAC,CAAC,CAAC,CAAC+C,OAAO,IAAI,CAAC/C,IAAI,CAAC,CAAC,CAAC,CAAChU,IAAI,EAAE;IACzD,OAAO,IAAI6W,WAAW,CAAC7C,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG;EACpC;EACA,IAAI8C,GAAG,GAAG,KAAK;EACf,KAAK,MAAMve,GAAG,IAAIyb,IAAI,EAAE;IACtB8C,GAAG,IAAI,IAAI;IACXA,GAAG,IAAID,WAAW,CAACte,GAAG,CAAC,CAACe,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC;IAC/Cwd,GAAG,IAAI,IAAI;EACb;EACAA,GAAG,IAAI,GAAG;EACV,OAAOA,GAAG;AACZ;AAEA,IAAIE,UAAU,GAAG,aAAa1Y,MAAM,CAACC,MAAM,CAAC;EACxCC,SAAS,EAAE,IAAI;EACfsH,SAAS,EAAEA,SAAS;EACpBsL,iBAAiB,EAAEA,iBAAiB;EACpC1K,SAAS,EAAEA,SAAS;EACpB,IAAIW,cAAcA,CAAA,EAAI;IAAE,OAAOA,cAAc;EAAE,CAAC;EAChD4B,kBAAkB,EAAEA,kBAAkB;EACtCzD,WAAW,EAAEA,WAAW;EACxB,IAAID,eAAeA,CAAA,EAAI;IAAE,OAAOA,eAAe;EAAE,CAAC;EAClDiO,SAAS,EAAEA,SAAS;EACpB1K,eAAe,EAAEA,eAAe;EAChCxC,YAAY,EAAEA,YAAY;EAC1B0K,mBAAmB,EAAEA,mBAAmB;EACxCQ,cAAc,EAAEA,cAAc;EAC9BlB,iBAAiB,EAAEA,iBAAiB;EACpCvI,UAAU,EAAEA,UAAU;EACtB2D,mBAAmB,EAAEA,mBAAmB;EACxC/F,cAAc,EAAEA,cAAc;EAC9BqK,YAAY,EAAEA,YAAY;EAC1BG,iBAAiB,EAAEA,iBAAiB;EACpCjJ,aAAa,EAAEA,aAAa;EAC5B0J,OAAO,EAAEA,OAAO;EAChBE,YAAY,EAAEA,YAAY;EAC1BtK,aAAa,EAAEA,aAAa;EAC5BI,QAAQ,EAAEA,QAAQ;EAClBiO,MAAM,EAAEA,MAAM;EACdnM,eAAe,EAAEA,eAAe;EAChCF,kBAAkB,EAAEA,kBAAkB;EACtCuL,YAAY,EAAEA,YAAY;EAC1BH,cAAc,EAAEA,cAAc;EAC9Bd,gBAAgB,EAAEA,gBAAgB;EAClCvF,WAAW,EAAEA,WAAW;EACxB2F,eAAe,EAAEA,eAAe;EAChCE,cAAc,EAAEA,cAAc;EAC9BjF,YAAY,EAAEA,YAAY;EAC1BM,eAAe,EAAEA,eAAe;EAChCxI,OAAO,EAAEA,OAAO;EAChBkB,SAAS,EAAEA,SAAS;EACpBuM,SAAS,EAAEA,SAAS;EACpB5M,WAAW,EAAEA,WAAW;EACxB4J,OAAO,EAAEA,OAAO;EAChBmB,iBAAiB,EAAEA,iBAAiB;EACpCzD,gBAAgB,EAAEA,gBAAgB;EAClChG,WAAW,EAAEA,WAAW;EACxBF,YAAY,EAAEA,YAAY;EAC1ByD,WAAW,EAAEA,WAAW;EACxBqJ,mBAAmB,EAAED,qBAAqB;EAC1C5H,4BAA4B,EAAEA,4BAA4B;EAC1DwH,eAAe,EAAEA,eAAe;EAChC3N,WAAW,EAAEA,WAAW;EACxBkN,SAAS,EAAEA,SAAS;EACpB,IAAIP,YAAYA,CAAA,EAAI;IAAE,OAAOA,YAAY;EAAE,CAAC;EAC5CrI,eAAe,EAAEA,eAAe;EAChCwB,yBAAyB,EAAEA,yBAAyB;EACpDgB,0BAA0B,EAAEA,0BAA0B;EACtDL,mBAAmB,EAAEA,mBAAmB;EACxCrH,gBAAgB,EAAEA,gBAAgB;EAClC3H,IAAI,EAAEA,IAAI;EACV,IAAIyG,YAAYA,CAAA,EAAI;IAAE,OAAOA,YAAY;EAAE,CAAC;EAC5C+G,UAAU,EAAEA,UAAU;EACtB,IAAI7E,aAAaA,CAAA,EAAI;IAAE,OAAOA,aAAa;EAAE,CAAC;EAC9CqK,iBAAiB,EAAEA,iBAAiB;EACpCrF,QAAQ,EAAEA,QAAQ;EAClBE,eAAe,EAAEA,eAAe;EAChC1E,gBAAgB,EAAEA,gBAAgB;EAClCuO,OAAO,EAAEA,OAAO;EAChBR,cAAc,EAAEA,cAAc;EAC9BlJ,EAAE,EAAEA,EAAE;EACN2J,MAAM,EAAEA,MAAM;EACdZ,UAAU,EAAEA,UAAU;EACtBC,UAAU,EAAEA,UAAU;EACtBkB,MAAM,EAAEA,MAAM;EACdrB,YAAY,EAAEA,YAAY;EAC1BjB,cAAc,EAAEA,cAAc;EAC9BmC,OAAO,EAAEA,OAAO;EAChBV,UAAU,EAAEA,UAAU;EACtBE,UAAU,EAAEA,UAAU;EACtBS,eAAe,EAAEA,eAAe;EAChCP,GAAG,EAAEA,GAAG;EACR5O,oBAAoB,EAAEA,oBAAoB;EAC1CiP,cAAc,EAAEA,cAAc;EAC9BX,gBAAgB,EAAEA,gBAAgB;EAClCC,UAAU,EAAEA,UAAU;EACtBI,KAAK,EAAEA,KAAK;EACZV,QAAQ,EAAEA;AACd,CAAC,CAAC;AAEF,MAAM0B,eAAe,GAAG,IAAI;AAC5B,MAAMC,iBAAiB,GAAG3B,QAAQ,CAAC,WAAW,CAAC;AAC/C,MAAM4B,WAAW,GAAG,CAAC,CAAC;AACtB,MAAMC,2CAA2C,GAAG,EAAE;AACtD,MAAMC,eAAe,SAAStP,UAAU,CAAC;EACvCuP,QAAQ;EACRC,QAAQ;EACRC,MAAM,GAAG,KAAK;EACd5a,WAAWA,CAAC0a,QAAQ,EAAE;IACpB,KAAK,CAACA,QAAQ,CAACzW,IAAI,CAAC;IACpB,IAAI,CAACyW,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,QAAQ,GAAGD,QAAQ;EAC1B;EACAzL,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,IAAIA,OAAO,KAAKkX,WAAW,EAAE;MAC3B,OAAO,IAAI,CAACI,QAAQ,CAAC1L,eAAe,CAACrM,OAAO,EAAES,OAAO,CAAC;IACxD,CAAC,MAAM;MACL,OAAO,IAAI,CAACqX,QAAQ,CAACzL,eAAe,CAACrM,OAAO,EAAES,OAAO,CAAC;IACxD;EACF;EACAwH,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAYgV,eAAe,IAAI,IAAI,CAACC,QAAQ,CAAC7P,YAAY,CAACpF,CAAC,CAACiV,QAAQ,CAAC;EAC/E;EACA1L,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI;EACb;EACAG,KAAKA,CAAA,EAAG;IACN,MAAM,IAAIzT,KAAK,CAAC,gBAAgB,CAAC;EACnC;EACAmf,KAAKA,CAAC7W,UAAU,EAAE;IAChB,IAAI,CAAC0W,QAAQ,GAAG1W,UAAU;IAC1B,IAAI,CAAC4W,MAAM,GAAG,IAAI;EACpB;AACF;AACA,MAAME,YAAY,CAAC;EACjBC,wBAAwB;EACxB5G,UAAU,GAAG,EAAE;EACf6G,QAAQ,GAAG,IAAIpd,GAAG,CAAC,CAAC;EACpBqd,gBAAgB,GAAG,IAAIrd,GAAG,CAAC,CAAC;EAC5Bsd,eAAe,GAAG,IAAItd,GAAG,CAAC,CAAC;EAC3Bud,aAAa,GAAG,IAAIvd,GAAG,CAAC,CAAC;EACzBwd,aAAa,GAAG,CAAC;EACjBpb,WAAWA,CAAC+a,wBAAwB,GAAG,KAAK,EAAE;IAC5C,IAAI,CAACA,wBAAwB,GAAGA,wBAAwB;EAC1D;EACAM,eAAeA,CAACzB,OAAO,EAAE0B,WAAW,EAAE;IACpC,IAAI1B,OAAO,YAAYjJ,WAAW,IAAI,CAAC4K,mBAAmB,CAAC3B,OAAO,CAAC,IAAIA,OAAO,YAAYa,eAAe,EAAE;MACzG,OAAOb,OAAO;IAChB;IACA,MAAMrO,GAAG,GAAGiQ,YAAY,CAACC,QAAQ,CAACC,KAAK,CAAC9B,OAAO,CAAC;IAChD,IAAIiB,KAAK,GAAG,IAAI,CAACG,QAAQ,CAAC/b,GAAG,CAACsM,GAAG,CAAC;IAClC,IAAIoQ,QAAQ,GAAG,KAAK;IACpB,IAAI,CAACd,KAAK,EAAE;MACVA,KAAK,GAAG,IAAIJ,eAAe,CAACb,OAAO,CAAC;MACpC,IAAI,CAACoB,QAAQ,CAAC9b,GAAG,CAACqM,GAAG,EAAEsP,KAAK,CAAC;MAC7Bc,QAAQ,GAAG,IAAI;IACjB;IACA,IAAI,CAACA,QAAQ,IAAI,CAACd,KAAK,CAACD,MAAM,IAAIe,QAAQ,IAAIL,WAAW,EAAE;MACzD,MAAMte,IAAI,GAAG,IAAI,CAAC4e,SAAS,CAAC,CAAC;MAC7B,IAAI3e,KAAK;MACT,IAAI4e,KAAK;MACT,IAAI,IAAI,CAACd,wBAAwB,IAAIQ,mBAAmB,CAAC3B,OAAO,CAAC,EAAE;QACjE3c,KAAK,GAAG,IAAIiX,YAAY,CAAC,EAAE,EAAE,CAAC,IAAI6D,eAAe,CAAC6B,OAAO,CAAC,CAAC,CAAC;QAC5DiC,KAAK,GAAGlD,QAAQ,CAAC3b,IAAI,CAAC,CAACyO,MAAM,CAAC,EAAE,CAAC;MACnC,CAAC,MAAM;QACLxO,KAAK,GAAG2c,OAAO;QACfiC,KAAK,GAAGlD,QAAQ,CAAC3b,IAAI,CAAC;MACxB;MACA,IAAI,CAACmX,UAAU,CAAChZ,IAAI,CAAC,IAAIyZ,cAAc,CAAC5X,IAAI,EAAEC,KAAK,EAAE2M,aAAa,EAAEmN,YAAY,CAAC+E,KAAK,CAAC,CAAC;MACxFjB,KAAK,CAACA,KAAK,CAACgB,KAAK,CAAC;IACpB;IACA,OAAOhB,KAAK;EACd;EACAkB,iBAAiBA,CAACC,GAAG,EAAE1M,IAAI,EAAE;IAC3B,MAAM/D,GAAG,GAAGyQ,GAAG,CAACN,KAAK,CAACpM,IAAI,CAAC;IAC3B,IAAI,CAAC,IAAI,CAAC4L,eAAe,CAAC7a,GAAG,CAACkL,GAAG,CAAC,EAAE;MAClC,MAAMnJ,EAAE,GAAG,IAAI,CAACwZ,SAAS,CAAC,CAAC;MAC3B,IAAI,CAACV,eAAe,CAAChc,GAAG,CAACqM,GAAG,EAAEoN,QAAQ,CAACvW,EAAE,CAAC,CAAC;MAC3C,IAAI,CAAC+R,UAAU,CAAChZ,IAAI,CAAC6gB,GAAG,CAACC,2BAA2B,CAAC7Z,EAAE,EAAEkN,IAAI,CAAC,CAAC;IACjE;IACA,OAAO,IAAI,CAAC4L,eAAe,CAACjc,GAAG,CAACsM,GAAG,CAAC;EACtC;EACA2Q,iBAAiBA,CAACtC,OAAO,EAAE;IACzB,IAAIA,OAAO,YAAY1D,gBAAgB,EAAE;MACvC,MAAMiG,eAAe,GAAGvC,OAAO,CAACzD,OAAO,CAAC9W,GAAG,CAACoG,CAAC,IAAIA,CAAC,CAACuJ,UAAU,CAAC,CAAC,GAAGvJ,CAAC,GAAG6U,iBAAiB,CAAC;MACxF,MAAM/O,GAAG,GAAGiQ,YAAY,CAACC,QAAQ,CAACC,KAAK,CAACxC,UAAU,CAACiD,eAAe,CAAC,CAAC;MACpE,OAAO,IAAI,CAACC,kBAAkB,CAAC7Q,GAAG,EAAEqO,OAAO,CAACzD,OAAO,EAAEA,OAAO,IAAI+C,UAAU,CAAC/C,OAAO,CAAC,CAAC;IACtF,CAAC,MAAM;MACL,MAAMkG,gBAAgB,GAAGjD,UAAU,CAACQ,OAAO,CAACzD,OAAO,CAAC9W,GAAG,CAACoG,CAAC,KAAK;QAC5D8F,GAAG,EAAE9F,CAAC,CAAC8F,GAAG;QACVtO,KAAK,EAAEwI,CAAC,CAACxI,KAAK,CAAC+R,UAAU,CAAC,CAAC,GAAGvJ,CAAC,CAACxI,KAAK,GAAGqd,iBAAiB;QACzD/D,MAAM,EAAE9Q,CAAC,CAAC8Q;MACZ,CAAC,CAAC,CAAC,CAAC;MACJ,MAAMhL,GAAG,GAAGiQ,YAAY,CAACC,QAAQ,CAACC,KAAK,CAACW,gBAAgB,CAAC;MACzD,OAAO,IAAI,CAACD,kBAAkB,CAAC7Q,GAAG,EAAEqO,OAAO,CAACzD,OAAO,CAAC9W,GAAG,CAACoG,CAAC,IAAIA,CAAC,CAACxI,KAAK,CAAC,EAAEkZ,OAAO,IAAIiD,UAAU,CAACjD,OAAO,CAAC9W,GAAG,CAAC,CAACpC,KAAK,EAAEwJ,KAAK,MAAM;QAC1H8E,GAAG,EAAEqO,OAAO,CAACzD,OAAO,CAAC1P,KAAK,CAAC,CAAC8E,GAAG;QAC/BtO,KAAK;QACLsZ,MAAM,EAAEqD,OAAO,CAACzD,OAAO,CAAC1P,KAAK,CAAC,CAAC8P;MACjC,CAAC,CAAC,CAAC,CAAC,CAAC;IACP;EACF;EACA+F,0BAA0BA,CAACzM,EAAE,EAAEjU,MAAM,EAAE2gB,aAAa,GAAG,IAAI,EAAE;IAC3D,MAAMC,OAAO,GAAG3M,EAAE,YAAY2E,iBAAiB;IAC/C,KAAK,MAAMlZ,OAAO,IAAI,IAAI,CAAC6Y,UAAU,EAAE;MACrC,IAAIqI,OAAO,IAAIlhB,OAAO,YAAYsZ,cAAc,IAAItZ,OAAO,CAAC2B,KAAK,EAAE4N,YAAY,CAACgF,EAAE,CAAC,EAAE;QACnF,OAAO8I,QAAQ,CAACrd,OAAO,CAAC0B,IAAI,CAAC;MAC/B;MACA,IAAI,CAACwf,OAAO,IAAIlhB,OAAO,YAAY8Y,mBAAmB,IAAIvE,EAAE,YAAYqE,YAAY,IAAIrE,EAAE,CAAChF,YAAY,CAACvP,OAAO,CAAC,EAAE;QAChH,OAAOqd,QAAQ,CAACrd,OAAO,CAAC0B,IAAI,CAAC;MAC/B;IACF;IACA,MAAMA,IAAI,GAAGuf,aAAa,GAAG,IAAI,CAACE,UAAU,CAAC7gB,MAAM,CAAC,GAAGA,MAAM;IAC7D,IAAI,CAACuY,UAAU,CAAChZ,IAAI,CAAC0U,EAAE,YAAYqE,YAAY,GAAGrE,EAAE,CAACyE,UAAU,CAACtX,IAAI,EAAE+Z,YAAY,CAAC+E,KAAK,CAAC,GAAG,IAAIlH,cAAc,CAAC5X,IAAI,EAAE6S,EAAE,EAAEjG,aAAa,EAAEmN,YAAY,CAAC+E,KAAK,EAAEjM,EAAE,CAACzE,UAAU,CAAC,CAAC;IAC3K,OAAOuN,QAAQ,CAAC3b,IAAI,CAAC;EACvB;EACAof,kBAAkBA,CAAC7Q,GAAG,EAAE4N,MAAM,EAAEuD,SAAS,EAAE;IACzC,IAAIC,cAAc,GAAG,IAAI,CAAC1B,gBAAgB,CAAChc,GAAG,CAACsM,GAAG,CAAC;IACnD,MAAMqR,uBAAuB,GAAGzD,MAAM,CAAC0D,MAAM,CAACpX,CAAC,IAAI,CAACA,CAAC,CAACuJ,UAAU,CAAC,CAAC,CAAC;IACnE,IAAI,CAAC2N,cAAc,EAAE;MACnB,MAAMG,iBAAiB,GAAG3D,MAAM,CAAC9Z,GAAG,CAAC,CAACoG,CAAC,EAAEgB,KAAK,KAAKhB,CAAC,CAACuJ,UAAU,CAAC,CAAC,GAAG,IAAI,CAACqM,eAAe,CAAC5V,CAAC,EAAE,IAAI,CAAC,GAAGkT,QAAQ,CAAC,IAAIlS,KAAK,EAAE,CAAC,CAAC;MAC1H,MAAMsW,UAAU,GAAGD,iBAAiB,CAACD,MAAM,CAACG,UAAU,CAAC,CAAC3d,GAAG,CAACoG,CAAC,IAAI,IAAIuO,OAAO,CAACvO,CAAC,CAACzI,IAAI,EAAE0M,YAAY,CAAC,CAAC;MACnG,MAAMuT,uBAAuB,GAAG1D,OAAO,CAACwD,UAAU,EAAEL,SAAS,CAACI,iBAAiB,CAAC,EAAElT,aAAa,CAAC;MAChG,MAAM5M,IAAI,GAAG,IAAI,CAAC4e,SAAS,CAAC,CAAC;MAC7B,IAAI,CAACzH,UAAU,CAAChZ,IAAI,CAAC,IAAIyZ,cAAc,CAAC5X,IAAI,EAAEigB,uBAAuB,EAAErT,aAAa,EAAEmN,YAAY,CAAC+E,KAAK,CAAC,CAAC;MAC1Ga,cAAc,GAAGhE,QAAQ,CAAC3b,IAAI,CAAC;MAC/B,IAAI,CAACie,gBAAgB,CAAC/b,GAAG,CAACqM,GAAG,EAAEoR,cAAc,CAAC;IAChD;IACA,OAAO;MACLA,cAAc;MACdC;IACF,CAAC;EACH;EACAH,UAAUA,CAACzf,IAAI,EAAEkgB,mBAAmB,GAAG,IAAI,EAAE;IAC3C,MAAMnV,KAAK,GAAG,IAAI,CAACoT,aAAa,CAAClc,GAAG,CAACjC,IAAI,CAAC,IAAI,CAAC;IAC/C,MAAMZ,MAAM,GAAG2L,KAAK,KAAK,CAAC,IAAI,CAACmV,mBAAmB,GAAG,GAAGlgB,IAAI,EAAE,GAAG,GAAGA,IAAI,GAAG+K,KAAK,EAAE;IAClF,IAAI,CAACoT,aAAa,CAACjc,GAAG,CAAClC,IAAI,EAAE+K,KAAK,GAAG,CAAC,CAAC;IACvC,OAAO3L,MAAM;EACf;EACAwf,SAASA,CAAA,EAAG;IACV,OAAO,IAAI,CAACa,UAAU,CAACpC,eAAe,CAAC;EACzC;AACF;AACA,MAAMmB,YAAY,CAAC;EACjB,OAAOC,QAAQ,GAAG,IAAID,YAAY,CAAC,CAAC;EACpCE,KAAKA,CAACpM,IAAI,EAAE;IACV,IAAIA,IAAI,YAAYqB,WAAW,IAAI,OAAOrB,IAAI,CAACrS,KAAK,KAAK,QAAQ,EAAE;MACjE,OAAO,IAAIqS,IAAI,CAACrS,KAAK,GAAG;IAC1B,CAAC,MAAM,IAAIqS,IAAI,YAAYqB,WAAW,EAAE;MACtC,OAAOtG,MAAM,CAACiF,IAAI,CAACrS,KAAK,CAAC;IAC3B,CAAC,MAAM,IAAIqS,IAAI,YAAYiB,4BAA4B,EAAE;MACvD,OAAO,IAAIjB,IAAI,CAACkB,IAAI,IAAIlB,IAAI,CAACmB,KAAK,IAAI,EAAE,EAAE;IAC5C,CAAC,MAAM,IAAInB,IAAI,YAAY4G,gBAAgB,EAAE;MAC3C,MAAMC,OAAO,GAAG,EAAE;MAClB,KAAK,MAAMQ,KAAK,IAAIrH,IAAI,CAAC6G,OAAO,EAAE;QAChCA,OAAO,CAAChb,IAAI,CAAC,IAAI,CAACugB,KAAK,CAAC/E,KAAK,CAAC,CAAC;MACjC;MACA,OAAO,IAAIR,OAAO,CAACrZ,IAAI,CAAC,GAAG,CAAC,GAAG;IACjC,CAAC,MAAM,IAAIwS,IAAI,YAAYkH,cAAc,EAAE;MACzC,MAAML,OAAO,GAAG,EAAE;MAClB,KAAK,MAAMQ,KAAK,IAAIrH,IAAI,CAAC6G,OAAO,EAAE;QAChC,IAAI5K,GAAG,GAAGoL,KAAK,CAACpL,GAAG;QACnB,IAAIoL,KAAK,CAACJ,MAAM,EAAE;UAChBhL,GAAG,GAAG,IAAIA,GAAG,GAAG;QAClB;QACA4K,OAAO,CAAChb,IAAI,CAACoQ,GAAG,GAAG,GAAG,GAAG,IAAI,CAACmQ,KAAK,CAAC/E,KAAK,CAAC1Z,KAAK,CAAC,CAAC;MACnD;MACA,OAAO,IAAIkZ,OAAO,CAACrZ,IAAI,CAAC,GAAG,CAAC,GAAG;IACjC,CAAC,MAAM,IAAIwS,IAAI,YAAY8D,YAAY,EAAE;MACvC,OAAO,WAAW9D,IAAI,CAACrS,KAAK,CAACoW,UAAU,MAAM/D,IAAI,CAACrS,KAAK,CAACD,IAAI,GAAG;IACjE,CAAC,MAAM,IAAIsS,IAAI,YAAYP,WAAW,EAAE;MACtC,OAAO,QAAQO,IAAI,CAACtS,IAAI,GAAG;IAC7B,CAAC,MAAM,IAAIsS,IAAI,YAAYD,UAAU,EAAE;MACrC,OAAO,UAAU,IAAI,CAACqM,KAAK,CAACpM,IAAI,CAACA,IAAI,CAAC,GAAG;IAC3C,CAAC,MAAM;MACL,MAAM,IAAI5T,KAAK,CAAC,GAAG,IAAI,CAACsE,WAAW,CAAChD,IAAI,wCAAwCsS,IAAI,CAACtP,WAAW,CAAChD,IAAI,EAAE,CAAC;IAC1G;EACF;AACF;AACA,SAASggB,UAAUA,CAACvX,CAAC,EAAE;EACrB,OAAOA,CAAC,YAAYsJ,WAAW;AACjC;AACA,SAASwM,mBAAmBA,CAACjM,IAAI,EAAE;EACjC,OAAOA,IAAI,YAAYqB,WAAW,IAAI,OAAOrB,IAAI,CAACrS,KAAK,KAAK,QAAQ,IAAIqS,IAAI,CAACrS,KAAK,CAAC/B,MAAM,IAAIsf,2CAA2C;AAC1I;AAEA,MAAM2C,IAAI,GAAG,eAAe;AAC5B,MAAMC,WAAW,CAAC;EAChB,OAAOC,UAAU,GAAG,SAAS;EAC7B,OAAOC,gBAAgB,GAAG,WAAW;EACrC,OAAOC,UAAU,GAAG,aAAa;EACjC,OAAO9b,IAAI,GAAG;IACZzE,IAAI,EAAE,IAAI;IACVqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOK,aAAa,GAAG;IACrBxgB,IAAI,EAAE,iBAAiB;IACvBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOM,eAAe,GAAG;IACvBzgB,IAAI,EAAE,mBAAmB;IACzBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOO,YAAY,GAAG;IACpB1gB,IAAI,EAAE,gBAAgB;IACtBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO3iB,OAAO,GAAG;IACfwC,IAAI,EAAE,WAAW;IACjBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOQ,YAAY,GAAG;IACpB3gB,IAAI,EAAE,gBAAgB;IACtBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOS,UAAU,GAAG;IAClB5gB,IAAI,EAAE,cAAc;IACpBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOU,UAAU,GAAG;IAClB7gB,IAAI,EAAE,cAAc;IACpBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOW,eAAe,GAAG;IACvB9gB,IAAI,EAAE,mBAAmB;IACzBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOY,aAAa,GAAG;IACrB/gB,IAAI,EAAE,iBAAiB;IACvBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOa,mBAAmB,GAAG;IAC3BhhB,IAAI,EAAE,uBAAuB;IAC7BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOc,wBAAwB,GAAG;IAChCjhB,IAAI,EAAE,4BAA4B;IAClCqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOe,sBAAsB,GAAG;IAC9BlhB,IAAI,EAAE,0BAA0B;IAChCqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOgB,WAAW,GAAG;IACnBnhB,IAAI,EAAE,eAAe;IACrBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOiB,WAAW,GAAG;IACnBphB,IAAI,EAAE,eAAe;IACrBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOkB,OAAO,GAAG;IACfrhB,IAAI,EAAE,WAAW;IACjBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOmB,qBAAqB,GAAG;IAC7BthB,IAAI,EAAE,yBAAyB;IAC/BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOoB,qBAAqB,GAAG;IAC7BvhB,IAAI,EAAE,yBAAyB;IAC/BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOlhB,SAAS,GAAG;IACjBe,IAAI,EAAE,aAAa;IACnBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOqB,SAAS,GAAG;IACjBxhB,IAAI,EAAE,aAAa;IACnBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOsB,qBAAqB,GAAG;IAC7BzhB,IAAI,EAAE,yBAAyB;IAC/BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOuB,mBAAmB,GAAG;IAC3B1hB,IAAI,EAAE,uBAAuB;IAC7BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOwB,gBAAgB,GAAG;IACxB3hB,IAAI,EAAE,oBAAoB;IAC1BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOyB,QAAQ,GAAG;IAChB5hB,IAAI,EAAE,YAAY;IAClBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO0B,QAAQ,GAAG;IAChB7hB,IAAI,EAAE,YAAY;IAClBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO2B,SAAS,GAAG;IACjB9hB,IAAI,EAAE,aAAa;IACnBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO4B,WAAW,GAAG;IACnB/hB,IAAI,EAAE,eAAe;IACrBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO6B,YAAY,GAAG;IACpBhiB,IAAI,EAAE,gBAAgB;IACtBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO8B,YAAY,GAAG;IACpBjiB,IAAI,EAAE,gBAAgB;IACtBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO+B,YAAY,GAAG;IACpBliB,IAAI,EAAE,gBAAgB;IACtBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOgC,YAAY,GAAG;IACpBniB,IAAI,EAAE,gBAAgB;IACtBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOiC,YAAY,GAAG;IACpBpiB,IAAI,EAAE,gBAAgB;IACtBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOkC,YAAY,GAAG;IACpBriB,IAAI,EAAE,gBAAgB;IACtBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOmC,YAAY,GAAG;IACpBtiB,IAAI,EAAE,gBAAgB;IACtBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOoC,YAAY,GAAG;IACpBviB,IAAI,EAAE,gBAAgB;IACtBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOqC,YAAY,GAAG;IACpBxiB,IAAI,EAAE,gBAAgB;IACtBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOsC,WAAW,GAAG;IACnBziB,IAAI,EAAE,eAAe;IACrBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOuC,SAAS,GAAG;IACjB1iB,IAAI,EAAE,aAAa;IACnBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOwC,cAAc,GAAG;IACtB3iB,IAAI,EAAE,YAAY;IAClBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOyC,KAAK,GAAG;IACb5iB,IAAI,EAAE,SAAS;IACfqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO0C,SAAS,GAAG;IACjB7iB,IAAI,EAAE,aAAa;IACnBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO2C,WAAW,GAAG;IACnB9iB,IAAI,EAAE,eAAe;IACrBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO4C,gBAAgB,GAAG;IACxB/iB,IAAI,EAAE,oBAAoB;IAC1BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO6C,YAAY,GAAG;IACpBhjB,IAAI,EAAE,gBAAgB;IACtBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO8C,YAAY,GAAG;IACpBjjB,IAAI,EAAE,gBAAgB;IACtBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO+C,kBAAkB,GAAG;IAC1BljB,IAAI,EAAE,sBAAsB;IAC5BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOgD,eAAe,GAAG;IACvBnjB,IAAI,EAAE,mBAAmB;IACzBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOiD,iBAAiB,GAAG;IACzBpjB,IAAI,EAAE,qBAAqB;IAC3BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOkD,mBAAmB,GAAG;IAC3BrjB,IAAI,EAAE,uBAAuB;IAC7BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOmD,wBAAwB,GAAG;IAChCtjB,IAAI,EAAE,4BAA4B;IAClCqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOoD,oBAAoB,GAAG;IAC5BvjB,IAAI,EAAE,wBAAwB;IAC9BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOqD,oBAAoB,GAAG;IAC5BxjB,IAAI,EAAE,wBAAwB;IAC9BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOsD,0BAA0B,GAAG;IAClCzjB,IAAI,EAAE,8BAA8B;IACpCqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOuD,uBAAuB,GAAG;IAC/B1jB,IAAI,EAAE,2BAA2B;IACjCqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOwD,gBAAgB,GAAG;IACxB3jB,IAAI,EAAE,oBAAoB;IAC1BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOyD,iBAAiB,GAAG;IACzB5jB,IAAI,EAAE,qBAAqB;IAC3BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO0D,kBAAkB,GAAG;IAC1B7jB,IAAI,EAAE,sBAAsB;IAC5BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO2D,uBAAuB,GAAG;IAC/B9jB,IAAI,EAAE,2BAA2B;IACjCqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO4D,mBAAmB,GAAG;IAC3B/jB,IAAI,EAAE,uBAAuB;IAC7BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO6D,mBAAmB,GAAG;IAC3BhkB,IAAI,EAAE,uBAAuB;IAC7BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO8D,yBAAyB,GAAG;IACjCjkB,IAAI,EAAE,6BAA6B;IACnCqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO+D,sBAAsB,GAAG;IAC9BlkB,IAAI,EAAE,0BAA0B;IAChCqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOgE,0BAA0B,GAAG;IAClCnkB,IAAI,EAAE,8BAA8B;IACpCqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOiE,iBAAiB,GAAG;IACzBpkB,IAAI,EAAE,qBAAqB;IAC3BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOkE,uBAAuB,GAAG;IAC/BrkB,IAAI,EAAE,2BAA2B;IACjCqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOpR,WAAW,GAAG;IACnB/O,IAAI,EAAE,eAAe;IACrBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOmE,QAAQ,GAAG;IAChBtkB,IAAI,EAAE,YAAY;IAClBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOoE,cAAc,GAAG;IACtBvkB,IAAI,EAAE,kBAAkB;IACxBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOqE,oBAAoB,GAAG;IAC5BxkB,IAAI,EAAE,wBAAwB;IAC9BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOsE,uBAAuB,GAAG;IAC/BzkB,IAAI,EAAE,2BAA2B;IACjCqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOuE,iBAAiB,GAAG;IACzB1kB,IAAI,EAAE,qBAAqB;IAC3BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO/Z,IAAI,GAAG;IACZpG,IAAI,EAAE,QAAQ;IACdqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOwE,cAAc,GAAG;IACtB3kB,IAAI,EAAE,kBAAkB;IACxBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOyE,eAAe,GAAG;IACvB5kB,IAAI,EAAE,mBAAmB;IACzBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO0E,cAAc,GAAG;IACtB7kB,IAAI,EAAE,kBAAkB;IACxBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO2E,eAAe,GAAG;IACvB9kB,IAAI,EAAE,mBAAmB;IACzBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO4E,gBAAgB,GAAG;IACxB/kB,IAAI,EAAE,oBAAoB;IAC1BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO6E,gBAAgB,GAAG;IACxBhlB,IAAI,EAAE,oBAAoB;IAC1BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO8E,gBAAgB,GAAG;IACxBjlB,IAAI,EAAE,oBAAoB;IAC1BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO+E,gBAAgB,GAAG;IACxBllB,IAAI,EAAE,oBAAoB;IAC1BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOgF,gBAAgB,GAAG;IACxBnlB,IAAI,EAAE,oBAAoB;IAC1BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOiF,gBAAgB,GAAG;IACxBplB,IAAI,EAAE,oBAAoB;IAC1BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOkF,gBAAgB,GAAG;IACxBrlB,IAAI,EAAE,oBAAoB;IAC1BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOmF,gBAAgB,GAAG;IACxBtlB,IAAI,EAAE,oBAAoB;IAC1BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOoF,gBAAgB,GAAG;IACxBvlB,IAAI,EAAE,oBAAoB;IAC1BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOqF,WAAW,GAAG;IACnBxlB,IAAI,EAAE,eAAe;IACrBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOsF,aAAa,GAAG;IACrBzlB,IAAI,EAAE,iBAAiB;IACvBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOuF,aAAa,GAAG;IACrB1lB,IAAI,EAAE,iBAAiB;IACvBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOwF,aAAa,GAAG;IACrB3lB,IAAI,EAAE,iBAAiB;IACvBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOyF,aAAa,GAAG;IACrB5lB,IAAI,EAAE,iBAAiB;IACvBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO0F,aAAa,GAAG;IACrB7lB,IAAI,EAAE,iBAAiB;IACvBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO2F,aAAa,GAAG;IACrB9lB,IAAI,EAAE,iBAAiB;IACvBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO4F,aAAa,GAAG;IACrB/lB,IAAI,EAAE,iBAAiB;IACvBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO6F,aAAa,GAAG;IACrBhmB,IAAI,EAAE,iBAAiB;IACvBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO8F,aAAa,GAAG;IACrBjmB,IAAI,EAAE,iBAAiB;IACvBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO+F,aAAa,GAAG;IACrBlmB,IAAI,EAAE,iBAAiB;IACvBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOgG,SAAS,GAAG;IACjBnmB,IAAI,EAAE,aAAa;IACnBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOiG,SAAS,GAAG;IACjBpmB,IAAI,EAAE,aAAa;IACnBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOkG,SAAS,GAAG;IACjBrmB,IAAI,EAAE,aAAa;IACnBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOmG,SAAS,GAAG;IACjBtmB,IAAI,EAAE,aAAa;IACnBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOoG,SAAS,GAAG;IACjBvmB,IAAI,EAAE,aAAa;IACnBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOqG,WAAW,GAAG;IACnBxmB,IAAI,EAAE,eAAe;IACrBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOsG,YAAY,GAAG;IACpBzmB,IAAI,EAAE,gBAAgB;IACtBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOuG,QAAQ,GAAG;IAChB1mB,IAAI,EAAE,YAAY;IAClBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOwG,OAAO,GAAG;IACf3mB,IAAI,EAAE,WAAW;IACjBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOyG,aAAa,GAAG;IACrB5mB,IAAI,EAAE,iBAAiB;IACvBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO0G,sBAAsB,GAAG;IAC9B7mB,IAAI,EAAE,wBAAwB;IAC9BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO2G,sBAAsB,GAAG;IAC9B9mB,IAAI,EAAE,wBAAwB;IAC9BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO4G,cAAc,GAAG;IACtB/mB,IAAI,EAAE,gBAAgB;IACtBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO6G,cAAc,GAAG;IACtBhnB,IAAI,EAAE,gBAAgB;IACtBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO8G,IAAI,GAAG;IACZjnB,IAAI,EAAE,QAAQ;IACdqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO+G,cAAc,GAAG;IACtBlnB,IAAI,EAAE,kBAAkB;IACxBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOgH,OAAO,GAAG;IACfnnB,IAAI,EAAE,WAAW;IACjBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOiH,SAAS,GAAG;IACjBpnB,IAAI,EAAE,aAAa;IACnBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOkH,OAAO,GAAG;IACfrnB,IAAI,EAAE,WAAW;IACjBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOmH,SAAS,GAAG;IACjBtnB,IAAI,EAAE,aAAa;IACnBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOoH,eAAe,GAAG;IACvBvnB,IAAI,EAAE,mBAAmB;IACzBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOqH,IAAI,GAAG;IACZxnB,IAAI,EAAE,QAAQ;IACdqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOsH,UAAU,GAAG;IAClBznB,IAAI,EAAE,cAAc;IACpBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOuH,aAAa,GAAG;IACrB1nB,IAAI,EAAE,iBAAiB;IACvBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOwH,SAAS,GAAG;IACjB3nB,IAAI,EAAE,aAAa;IACnBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOyH,MAAM,GAAG;IACd5nB,IAAI,EAAE,UAAU;IAChBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO0H,eAAe,GAAG;IACvB7nB,IAAI,EAAE,mBAAmB;IACzBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO2H,eAAe,GAAG;IACvB9nB,IAAI,EAAE,mBAAmB;IACzBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO4H,cAAc,GAAG;IACtB/nB,IAAI,EAAE,kBAAkB;IACxBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO6H,iBAAiB,GAAG;IACzBhoB,IAAI,EAAE,qBAAqB;IAC3BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO8H,oBAAoB,GAAG;IAC5BjoB,IAAI,EAAE,wBAAwB;IAC9BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO+H,UAAU,GAAG;IAClBloB,IAAI,EAAE,YAAY;IAClBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOgI,iBAAiB,GAAG;IACzBnoB,IAAI,EAAE,mBAAmB;IACzBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOiI,eAAe,GAAG;IACvBpoB,IAAI,EAAE,mBAAmB;IACzBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOkI,qBAAqB,GAAG;IAC7BroB,IAAI,EAAE,yBAAyB;IAC/BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOmI,kBAAkB,GAAG;IAC1BtoB,IAAI,EAAE,oBAAoB;IAC1BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOoI,iBAAiB,GAAG;IACzBvoB,IAAI,EAAE,uBAAuB;IAC7BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOqI,qBAAqB,GAAG;IAC7BxoB,IAAI,EAAE,yBAAyB;IAC/BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOsI,aAAa,GAAG;IACrBzoB,IAAI,EAAE,iBAAiB;IACvBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOuI,eAAe,GAAG;IACvB1oB,IAAI,EAAE,mBAAmB;IACzBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOwI,WAAW,GAAG;IACnB3oB,IAAI,EAAE,eAAe;IACrBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOyI,uBAAuB,GAAG;IAC/B5oB,IAAI,EAAE,2BAA2B;IACjCqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO0I,eAAe,GAAG;IACvB7oB,IAAI,EAAE,mBAAmB;IACzBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO2I,gBAAgB,GAAG;IACxB9oB,IAAI,EAAE,sBAAsB;IAC5BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO4I,iBAAiB,GAAG;IACzB/oB,IAAI,EAAE,qBAAqB;IAC3BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO1c,uBAAuB,GAAG;IAC/BzD,IAAI,EAAE,yBAAyB;IAC/BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO3c,iBAAiB,GAAG;IACzBxD,IAAI,EAAE,mBAAmB;IACzBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO6I,oBAAoB,GAAG;IAC5BhpB,IAAI,EAAE,wBAAwB;IAC9BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO8I,kBAAkB,GAAG;IAC1BjpB,IAAI,EAAE,sBAAsB;IAC5BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO+I,cAAc,GAAG;IACtBlpB,IAAI,EAAE,oBAAoB;IAC1BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOrb,aAAa,GAAG;IACrB9E,IAAI,EAAE,iBAAiB;IACvBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOgJ,eAAe,GAAG;IACvBnpB,IAAI,EAAE,mBAAmB;IACzBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOiJ,gBAAgB,GAAG;IACxBppB,IAAI,EAAE,sBAAsB;IAC5BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOkJ,oBAAoB,GAAG;IAC5BrpB,IAAI,EAAE,wBAAwB;IAC9BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOmJ,WAAW,GAAG;IACnBtpB,IAAI,EAAE,eAAe;IACrBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOoJ,mBAAmB,GAAG;IAC3BvpB,IAAI,EAAE,uBAAuB;IAC7BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOqJ,cAAc,GAAG;IACtBxpB,IAAI,EAAE,kBAAkB;IACxBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOsJ,eAAe,GAAG;IACvBzpB,IAAI,EAAE,qBAAqB;IAC3BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOuJ,mBAAmB,GAAG;IAC3B1pB,IAAI,EAAE,uBAAuB;IAC7BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOwJ,mBAAmB,GAAG;IAC3B3pB,IAAI,EAAE,qBAAqB;IAC3BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOyJ,cAAc,GAAG;IACtB5pB,IAAI,EAAE,kBAAkB;IACxBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO0J,eAAe,GAAG;IACvB7pB,IAAI,EAAE,qBAAqB;IAC3BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO2J,gBAAgB,GAAG;IACxB9pB,IAAI,EAAE,oBAAoB;IAC1BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO4J,oBAAoB,GAAG;IAC5B/pB,IAAI,EAAE,wBAAwB;IAC9BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO6J,eAAe,GAAG;IACvBhqB,IAAI,EAAE,mBAAmB;IACzBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO8J,UAAU,GAAG;IAClBjqB,IAAI,EAAE,cAAc;IACpBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO+J,WAAW,GAAG;IACnBlqB,IAAI,EAAE,iBAAiB;IACvBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOgK,oBAAoB,GAAG;IAC5BnqB,IAAI,EAAE,0BAA0B;IAChCqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOiK,yBAAyB,GAAG;IACjCpqB,IAAI,EAAE,+BAA+B;IACrCqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOkK,gBAAgB,GAAG;IACxBrqB,IAAI,EAAE,mBAAmB;IACzBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOmK,qBAAqB,GAAG;IAC7BtqB,IAAI,EAAE,wBAAwB;IAC9BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOoK,iBAAiB,GAAG;IACzBvqB,IAAI,EAAE,oBAAoB;IAC1BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOqK,YAAY,GAAG;IACpBxqB,IAAI,EAAE,gBAAgB;IACtBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOsK,SAAS,GAAG;IACjBzqB,IAAI,EAAE,aAAa;IACnBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOuK,SAAS,GAAG;IACjB1qB,IAAI,EAAE,aAAa;IACnBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOwK,YAAY,GAAG;IACpB3qB,IAAI,EAAE,gBAAgB;IACtBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOyK,eAAe,GAAG;IACvB5qB,IAAI,EAAE,mBAAmB;IACzBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO0K,kBAAkB,GAAG;IAC1B7qB,IAAI,EAAE,sBAAsB;IAC5BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO2K,YAAY,GAAG;IACpB9qB,IAAI,EAAE,gBAAgB;IACtBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO4K,cAAc,GAAG;IACtB/qB,IAAI,EAAE,kBAAkB;IACxBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO6K,gBAAgB,GAAG;IACxBhrB,IAAI,EAAE,oBAAoB;IAC1BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO8K,cAAc,GAAG;IACtBjrB,IAAI,EAAE,kBAAkB;IACxBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO+K,UAAU,GAAG;IAClBlrB,IAAI,EAAE,cAAc;IACpBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOgL,QAAQ,GAAG;IAChBnrB,IAAI,EAAE,YAAY;IAClBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOiL,cAAc,GAAG;IACtBprB,IAAI,EAAE,kBAAkB;IACxBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOkL,qBAAqB,GAAG;IAC7BrrB,IAAI,EAAE,yBAAyB;IAC/BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOmL,kBAAkB,GAAG;IAC1BtrB,IAAI,EAAE,sBAAsB;IAC5BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOoL,wBAAwB,GAAG;IAChCvrB,IAAI,EAAE,4BAA4B;IAClCqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOqL,gBAAgB,GAAG;IACxBxrB,IAAI,EAAE,oBAAoB;IAC1BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOsL,qBAAqB,GAAG;IAC7BzrB,IAAI,EAAE,yBAAyB;IAC/BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOuL,qBAAqB,GAAG;IAC7B1rB,IAAI,EAAE,yBAAyB;IAC/BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOwL,QAAQ,GAAG;IAChB3rB,IAAI,EAAE,YAAY;IAClBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOyL,mBAAmB,GAAG;IAC3B5rB,IAAI,EAAE,uBAAuB;IAC7BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO0L,YAAY,GAAG;IACpB7rB,IAAI,EAAE,gBAAgB;IACtBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO2L,aAAa,GAAG;IACrB9rB,IAAI,EAAE,iBAAiB;IACvBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO4L,mBAAmB,GAAG;IAC3B/rB,IAAI,EAAE,uBAAuB;IAC7BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO6L,cAAc,GAAG;IACtBhsB,IAAI,EAAE,kBAAkB;IACxBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO8L,WAAW,GAAG;IACnBjsB,IAAI,EAAE,eAAe;IACrBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO+L,wBAAwB,GAAG;IAChClsB,IAAI,EAAE,4BAA4B;IAClCqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOgM,iBAAiB,GAAG;IACzBnsB,IAAI,EAAE,qBAAqB;IAC3BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOiM,wBAAwB,GAAG;IAChCpsB,IAAI,EAAE,4BAA4B;IAClCqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOkM,uBAAuB,GAAG;IAC/BrsB,IAAI,EAAE,2BAA2B;IACjCqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOmM,cAAc,GAAG;IACtBtsB,IAAI,EAAE,OAAO;IACbqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOoM,eAAe,GAAG;IACvBvsB,IAAI,EAAE,QAAQ;IACdqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOqM,kBAAkB,GAAG;IAC1BxsB,IAAI,EAAE,WAAW;IACjBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOsM,qBAAqB,GAAG;IAC7BzsB,IAAI,EAAE,cAAc;IACpBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOuM,qBAAqB,GAAG;IAC7B1sB,IAAI,EAAE,cAAc;IACpBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOwM,wBAAwB,GAAG;IAChC3sB,IAAI,EAAE,iBAAiB;IACvBqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAOyM,yBAAyB,GAAG;IACjC5sB,IAAI,EAAE,gCAAgC;IACtCqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO0M,2BAA2B,GAAG;IACnC7sB,IAAI,EAAE,8BAA8B;IACpCqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO2M,oBAAoB,GAAG;IAC5B9sB,IAAI,EAAE,uBAAuB;IAC7BqW,UAAU,EAAE8J;EACd,CAAC;EACD,OAAO4M,UAAU,GAAG;IAClB/sB,IAAI,EAAE,aAAa;IACnBqW,UAAU,EAAE8J;EACd,CAAC;AACH;AAEA,MAAM6M,gBAAgB,GAAG,eAAe;AACxC,SAASC,mBAAmBA,CAACC,KAAK,EAAE;EAClC,OAAOA,KAAK,CAACxtB,OAAO,CAACstB,gBAAgB,EAAE,CAAC,GAAGG,CAAC,KAAKA,CAAC,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CAAC;AACtE;AACA,SAASC,YAAYA,CAACH,KAAK,EAAEI,aAAa,EAAE;EAC1C,OAAOC,QAAQ,CAACL,KAAK,EAAE,GAAG,EAAEI,aAAa,CAAC;AAC5C;AACA,SAASE,aAAaA,CAACN,KAAK,EAAEI,aAAa,EAAE;EAC3C,OAAOC,QAAQ,CAACL,KAAK,EAAE,GAAG,EAAEI,aAAa,CAAC;AAC5C;AACA,SAASC,QAAQA,CAACL,KAAK,EAAEO,SAAS,EAAEH,aAAa,EAAE;EACjD,MAAMI,cAAc,GAAGR,KAAK,CAACS,OAAO,CAACF,SAAS,CAAC;EAC/C,IAAIC,cAAc,IAAI,CAAC,CAAC,EAAE,OAAOJ,aAAa;EAC9C,OAAO,CAACJ,KAAK,CAACpuB,KAAK,CAAC,CAAC,EAAE4uB,cAAc,CAAC,CAACE,IAAI,CAAC,CAAC,EAAEV,KAAK,CAACpuB,KAAK,CAAC4uB,cAAc,GAAG,CAAC,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC;AACxF;AACA,SAASC,WAAWA,CAACC,GAAG,EAAE;EACxB,OAAOA,GAAG,KAAKC,SAAS,GAAG,IAAI,GAAGD,GAAG;AACvC;AACA,SAASE,YAAYA,CAACC,CAAC,EAAE;EACvB,OAAOA,CAAC,CAACvuB,OAAO,CAAC,4BAA4B,EAAE,MAAM,CAAC;AACxD;AACA,SAASwuB,UAAUA,CAACvmB,GAAG,EAAE;EACvB,IAAIwmB,OAAO,GAAG,EAAE;EAChB,KAAK,IAAI1kB,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG9B,GAAG,CAACzJ,MAAM,EAAEuL,KAAK,EAAE,EAAE;IAC/C,IAAI2kB,SAAS,GAAGzmB,GAAG,CAAC0mB,UAAU,CAAC5kB,KAAK,CAAC;IACrC,IAAI2kB,SAAS,IAAI,MAAM,IAAIA,SAAS,IAAI,MAAM,IAAIzmB,GAAG,CAACzJ,MAAM,GAAGuL,KAAK,GAAG,CAAC,EAAE;MACxE,MAAMoB,GAAG,GAAGlD,GAAG,CAAC0mB,UAAU,CAAC5kB,KAAK,GAAG,CAAC,CAAC;MACrC,IAAIoB,GAAG,IAAI,MAAM,IAAIA,GAAG,IAAI,MAAM,EAAE;QAClCpB,KAAK,EAAE;QACP2kB,SAAS,GAAG,CAACA,SAAS,GAAG,MAAM,IAAI,EAAE,IAAIvjB,GAAG,GAAG,MAAM,GAAG,OAAO;MACjE;IACF;IACA,IAAIujB,SAAS,IAAI,IAAI,EAAE;MACrBD,OAAO,CAAChwB,IAAI,CAACiwB,SAAS,CAAC;IACzB,CAAC,MAAM,IAAIA,SAAS,IAAI,KAAK,EAAE;MAC7BD,OAAO,CAAChwB,IAAI,CAACiwB,SAAS,IAAI,CAAC,GAAG,IAAI,GAAG,IAAI,EAAEA,SAAS,GAAG,IAAI,GAAG,IAAI,CAAC;IACrE,CAAC,MAAM,IAAIA,SAAS,IAAI,MAAM,EAAE;MAC9BD,OAAO,CAAChwB,IAAI,CAACiwB,SAAS,IAAI,EAAE,GAAG,IAAI,EAAEA,SAAS,IAAI,CAAC,GAAG,IAAI,GAAG,IAAI,EAAEA,SAAS,GAAG,IAAI,GAAG,IAAI,CAAC;IAC7F,CAAC,MAAM,IAAIA,SAAS,IAAI,QAAQ,EAAE;MAChCD,OAAO,CAAChwB,IAAI,CAACiwB,SAAS,IAAI,EAAE,GAAG,IAAI,GAAG,IAAI,EAAEA,SAAS,IAAI,EAAE,GAAG,IAAI,GAAG,IAAI,EAAEA,SAAS,IAAI,CAAC,GAAG,IAAI,GAAG,IAAI,EAAEA,SAAS,GAAG,IAAI,GAAG,IAAI,CAAC;IACnI;EACF;EACA,OAAOD,OAAO;AAChB;AACA,SAASG,SAASA,CAACC,KAAK,EAAE;EACxB,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC7B,OAAOA,KAAK;EACd;EACA,IAAI9W,KAAK,CAACC,OAAO,CAAC6W,KAAK,CAAC,EAAE;IACxB,OAAO,IAAIA,KAAK,CAAClsB,GAAG,CAACisB,SAAS,CAAC,CAACxuB,IAAI,CAAC,IAAI,CAAC,GAAG;EAC/C;EACA,IAAIyuB,KAAK,IAAI,IAAI,EAAE;IACjB,OAAO,EAAE,GAAGA,KAAK;EACnB;EACA,MAAMvuB,IAAI,GAAGuuB,KAAK,CAACC,cAAc,IAAID,KAAK,CAACvuB,IAAI;EAC/C,IAAIA,IAAI,EAAE;IACR,OAAO,GAAGA,IAAI,EAAE;EAClB;EACA,IAAI,CAACuuB,KAAK,CAACpuB,QAAQ,EAAE;IACnB,OAAO,QAAQ;EACjB;EACA,MAAMf,MAAM,GAAGmvB,KAAK,CAACpuB,QAAQ,CAAC,CAAC;EAC/B,IAAIf,MAAM,IAAI,IAAI,EAAE;IAClB,OAAO,EAAE,GAAGA,MAAM;EACpB;EACA,MAAMqvB,YAAY,GAAGrvB,MAAM,CAACuuB,OAAO,CAAC,IAAI,CAAC;EACzC,OAAOc,YAAY,IAAI,CAAC,GAAGrvB,MAAM,CAACN,KAAK,CAAC,CAAC,EAAE2vB,YAAY,CAAC,GAAGrvB,MAAM;AACnE;AACA,MAAMsvB,OAAO,CAAC;EACZC,IAAI;EACJC,KAAK;EACLC,KAAK;EACLC,KAAK;EACL9rB,WAAWA,CAAC2rB,IAAI,EAAE;IAChB,IAAI,CAACA,IAAI,GAAGA,IAAI;IAChB,MAAMI,MAAM,GAAGJ,IAAI,CAACK,KAAK,CAAC,GAAG,CAAC;IAC9B,IAAI,CAACJ,KAAK,GAAGG,MAAM,CAAC,CAAC,CAAC;IACtB,IAAI,CAACF,KAAK,GAAGE,MAAM,CAAC,CAAC,CAAC;IACtB,IAAI,CAACD,KAAK,GAAGC,MAAM,CAACjwB,KAAK,CAAC,CAAC,CAAC,CAACgB,IAAI,CAAC,GAAG,CAAC;EACxC;AACF;AACA,MAAMmvB,OAAO,GAAGC,UAAU;AAC1B,MAAMC,QAAQ,GAAG,mBAAmB;AACpC,SAASC,iCAAiCA,CAACC,OAAO,EAAE;EAClD,IAAIA,OAAO,CAACC,UAAU,CAAC,IAAI,CAAC,EAAE;IAC5B,OAAO,IAAI;EACb;EACA,IAAIH,QAAQ,CAACI,IAAI,CAACF,OAAO,CAAC,EAAE;IAC1B,OAAO,KAAK;EACd;EACA,OAAO,IAAI;AACb;AAEA,MAAMG,SAAS,GAAG,CAAC;AACnB,MAAMC,aAAa,GAAG,kDAAkD;AACxE,MAAMC,kBAAkB,CAAC;EACvBC,IAAI;EACJC,cAAc,GAAG,IAAIhvB,GAAG,CAAC,CAAC;EAC1BivB,KAAK,GAAG,EAAE;EACVC,QAAQ,GAAG,CAAC;EACZC,WAAW,GAAG,KAAK;EACnB/sB,WAAWA,CAAC2sB,IAAI,GAAG,IAAI,EAAE;IACvB,IAAI,CAACA,IAAI,GAAGA,IAAI;EAClB;EACAK,SAASA,CAACrZ,GAAG,EAAEsZ,OAAO,GAAG,IAAI,EAAE;IAC7B,IAAI,CAAC,IAAI,CAACL,cAAc,CAACvsB,GAAG,CAACsT,GAAG,CAAC,EAAE;MACjC,IAAI,CAACiZ,cAAc,CAAC1tB,GAAG,CAACyU,GAAG,EAAEsZ,OAAO,CAAC;IACvC;IACA,OAAO,IAAI;EACb;EACAC,OAAOA,CAAA,EAAG;IACR,IAAI,CAACL,KAAK,CAAC1xB,IAAI,CAAC,EAAE,CAAC;IACnB,IAAI,CAAC2xB,QAAQ,GAAG,CAAC;IACjB,OAAO,IAAI;EACb;EACAK,UAAUA,CAACC,IAAI,EAAEC,SAAS,EAAEC,WAAW,EAAEC,UAAU,EAAE;IACnD,IAAI,CAAC,IAAI,CAACC,WAAW,EAAE;MACrB,MAAM,IAAI9xB,KAAK,CAAC,mDAAmD,CAAC;IACtE;IACA,IAAI2xB,SAAS,IAAI,IAAI,IAAI,CAAC,IAAI,CAACT,cAAc,CAACvsB,GAAG,CAACgtB,SAAS,CAAC,EAAE;MAC5D,MAAM,IAAI3xB,KAAK,CAAC,wBAAwB2xB,SAAS,GAAG,CAAC;IACvD;IACA,IAAID,IAAI,IAAI,IAAI,EAAE;MAChB,MAAM,IAAI1xB,KAAK,CAAC,mDAAmD,CAAC;IACtE;IACA,IAAI0xB,IAAI,GAAG,IAAI,CAACN,QAAQ,EAAE;MACxB,MAAM,IAAIpxB,KAAK,CAAC,yCAAyC,CAAC;IAC5D;IACA,IAAI2xB,SAAS,KAAKC,WAAW,IAAI,IAAI,IAAIC,UAAU,IAAI,IAAI,CAAC,EAAE;MAC5D,MAAM,IAAI7xB,KAAK,CAAC,oEAAoE,CAAC;IACvF;IACA,IAAI,CAACqxB,WAAW,GAAG,IAAI;IACvB,IAAI,CAACD,QAAQ,GAAGM,IAAI;IACpB,IAAI,CAACI,WAAW,CAACryB,IAAI,CAAC;MACpBiyB,IAAI;MACJC,SAAS;MACTC,WAAW;MACXC;IACF,CAAC,CAAC;IACF,OAAO,IAAI;EACb;EACA,IAAIC,WAAWA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACX,KAAK,CAAC/wB,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EAChC;EACA2xB,MAAMA,CAAA,EAAG;IACP,IAAI,CAAC,IAAI,CAACV,WAAW,EAAE;MACrB,OAAO,IAAI;IACb;IACA,MAAMW,YAAY,GAAG,IAAI9vB,GAAG,CAAC,CAAC;IAC9B,MAAM+vB,OAAO,GAAG,EAAE;IAClB,MAAMf,cAAc,GAAG,EAAE;IACzBnY,KAAK,CAACmZ,IAAI,CAAC,IAAI,CAAChB,cAAc,CAAC/oB,IAAI,CAAC,CAAC,CAAC,CAACzG,OAAO,CAAC,CAACuW,GAAG,EAAErX,CAAC,KAAK;MACzDoxB,YAAY,CAACxuB,GAAG,CAACyU,GAAG,EAAErX,CAAC,CAAC;MACxBqxB,OAAO,CAACxyB,IAAI,CAACwY,GAAG,CAAC;MACjBiZ,cAAc,CAACzxB,IAAI,CAAC,IAAI,CAACyxB,cAAc,CAAC3tB,GAAG,CAAC0U,GAAG,CAAC,IAAI,IAAI,CAAC;IAC3D,CAAC,CAAC;IACF,IAAIka,QAAQ,GAAG,EAAE;IACjB,IAAIf,QAAQ,GAAG,CAAC;IAChB,IAAIgB,eAAe,GAAG,CAAC;IACvB,IAAIC,eAAe,GAAG,CAAC;IACvB,IAAIC,cAAc,GAAG,CAAC;IACtB,IAAI,CAACnB,KAAK,CAACzvB,OAAO,CAAC6wB,QAAQ,IAAI;MAC7BnB,QAAQ,GAAG,CAAC;MACZe,QAAQ,IAAII,QAAQ,CAAC5uB,GAAG,CAAC6uB,OAAO,IAAI;QAClC,IAAIC,QAAQ,GAAGC,WAAW,CAACF,OAAO,CAACd,IAAI,GAAGN,QAAQ,CAAC;QACnDA,QAAQ,GAAGoB,OAAO,CAACd,IAAI;QACvB,IAAIc,OAAO,CAACb,SAAS,IAAI,IAAI,EAAE;UAC7Bc,QAAQ,IAAIC,WAAW,CAACV,YAAY,CAACzuB,GAAG,CAACivB,OAAO,CAACb,SAAS,CAAC,GAAGS,eAAe,CAAC;UAC9EA,eAAe,GAAGJ,YAAY,CAACzuB,GAAG,CAACivB,OAAO,CAACb,SAAS,CAAC;UACrDc,QAAQ,IAAIC,WAAW,CAACF,OAAO,CAACZ,WAAW,GAAGS,eAAe,CAAC;UAC9DA,eAAe,GAAGG,OAAO,CAACZ,WAAW;UACrCa,QAAQ,IAAIC,WAAW,CAACF,OAAO,CAACX,UAAU,GAAGS,cAAc,CAAC;UAC5DA,cAAc,GAAGE,OAAO,CAACX,UAAU;QACrC;QACA,OAAOY,QAAQ;MACjB,CAAC,CAAC,CAACrxB,IAAI,CAAC,GAAG,CAAC;MACZ+wB,QAAQ,IAAI,GAAG;IACjB,CAAC,CAAC;IACFA,QAAQ,GAAGA,QAAQ,CAAC/xB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAChC,OAAO;MACL,MAAM,EAAE,IAAI,CAAC6wB,IAAI,IAAI,EAAE;MACvB,SAAS,EAAEH,SAAS;MACpB,YAAY,EAAE,EAAE;MAChB,SAAS,EAAEmB,OAAO;MAClB,gBAAgB,EAAEf,cAAc;MAChC,UAAU,EAAEiB;IACd,CAAC;EACH;EACAQ,WAAWA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACtB,WAAW,GAAG,IAAI,GAAGN,aAAa,GAAG6B,cAAc,CAACC,IAAI,CAACjD,SAAS,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,GAAG,EAAE;EACrG;AACF;AACA,SAASgD,cAAcA,CAACrxB,KAAK,EAAE;EAC7B,IAAIuxB,GAAG,GAAG,EAAE;EACZ,MAAMrD,OAAO,GAAGD,UAAU,CAACjuB,KAAK,CAAC;EACjC,KAAK,IAAIX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6uB,OAAO,CAACjwB,MAAM,GAAG;IACnC,MAAMuzB,EAAE,GAAGtD,OAAO,CAAC7uB,CAAC,EAAE,CAAC;IACvB,MAAMoyB,EAAE,GAAGpyB,CAAC,GAAG6uB,OAAO,CAACjwB,MAAM,GAAGiwB,OAAO,CAAC7uB,CAAC,EAAE,CAAC,GAAG,IAAI;IACnD,MAAMqyB,EAAE,GAAGryB,CAAC,GAAG6uB,OAAO,CAACjwB,MAAM,GAAGiwB,OAAO,CAAC7uB,CAAC,EAAE,CAAC,GAAG,IAAI;IACnDkyB,GAAG,IAAII,aAAa,CAACH,EAAE,IAAI,CAAC,CAAC;IAC7BD,GAAG,IAAII,aAAa,CAAC,CAACH,EAAE,GAAG,CAAC,KAAK,CAAC,IAAIC,EAAE,KAAK,IAAI,GAAG,CAAC,GAAGA,EAAE,IAAI,CAAC,CAAC,CAAC;IACjEF,GAAG,IAAIE,EAAE,KAAK,IAAI,GAAG,GAAG,GAAGE,aAAa,CAAC,CAACF,EAAE,GAAG,EAAE,KAAK,CAAC,IAAIC,EAAE,KAAK,IAAI,GAAG,CAAC,GAAGA,EAAE,IAAI,CAAC,CAAC,CAAC;IACtFH,GAAG,IAAIE,EAAE,KAAK,IAAI,IAAIC,EAAE,KAAK,IAAI,GAAG,GAAG,GAAGC,aAAa,CAACD,EAAE,GAAG,EAAE,CAAC;EAClE;EACA,OAAOH,GAAG;AACZ;AACA,SAASJ,WAAWA,CAACnxB,KAAK,EAAE;EAC1BA,KAAK,GAAGA,KAAK,GAAG,CAAC,GAAG,CAAC,CAACA,KAAK,IAAI,CAAC,IAAI,CAAC,GAAGA,KAAK,IAAI,CAAC;EAClD,IAAIid,GAAG,GAAG,EAAE;EACZ,GAAG;IACD,IAAI2U,KAAK,GAAG5xB,KAAK,GAAG,EAAE;IACtBA,KAAK,GAAGA,KAAK,IAAI,CAAC;IAClB,IAAIA,KAAK,GAAG,CAAC,EAAE;MACb4xB,KAAK,GAAGA,KAAK,GAAG,EAAE;IACpB;IACA3U,GAAG,IAAI0U,aAAa,CAACC,KAAK,CAAC;EAC7B,CAAC,QAAQ5xB,KAAK,GAAG,CAAC;EAClB,OAAOid,GAAG;AACZ;AACA,MAAM4U,UAAU,GAAG,kEAAkE;AACrF,SAASF,aAAaA,CAAC3xB,KAAK,EAAE;EAC5B,IAAIA,KAAK,GAAG,CAAC,IAAIA,KAAK,IAAI,EAAE,EAAE;IAC5B,MAAM,IAAIvB,KAAK,CAAC,4CAA4C,CAAC;EAC/D;EACA,OAAOozB,UAAU,CAAC7xB,KAAK,CAAC;AAC1B;AAEA,MAAM8xB,8BAA8B,GAAG,gBAAgB;AACvD,MAAMC,oBAAoB,GAAG,uBAAuB;AACpD,MAAMC,YAAY,GAAG,IAAI;AACzB,MAAMC,YAAY,CAAC;EACjBC,MAAM;EACNC,WAAW,GAAG,CAAC;EACftsB,KAAK,GAAG,EAAE;EACVusB,QAAQ,GAAG,EAAE;EACbrvB,WAAWA,CAACmvB,MAAM,EAAE;IAClB,IAAI,CAACA,MAAM,GAAGA,MAAM;EACtB;AACF;AACA,MAAMG,kBAAkB,GAAG,IAAI1xB,GAAG,CAAC,CAAC,CAAC6M,cAAc,CAACiD,GAAG,EAAE,IAAI,CAAC,EAAE,CAACjD,cAAc,CAAC6D,MAAM,EAAE,GAAG,CAAC,EAAE,CAAC7D,cAAc,CAAC+D,YAAY,EAAE,IAAI,CAAC,EAAE,CAAC/D,cAAc,CAACmD,SAAS,EAAE,GAAG,CAAC,EAAE,CAACnD,cAAc,CAACqD,UAAU,EAAE,GAAG,CAAC,EAAE,CAACrD,cAAc,CAACyC,MAAM,EAAE,GAAG,CAAC,EAAE,CAACzC,cAAc,CAAC2E,MAAM,EAAE,GAAG,CAAC,EAAE,CAAC3E,cAAc,CAAC6B,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC7B,cAAc,CAACiC,SAAS,EAAE,KAAK,CAAC,EAAE,CAACjC,cAAc,CAACyD,KAAK,EAAE,GAAG,CAAC,EAAE,CAACzD,cAAc,CAAC2D,WAAW,EAAE,IAAI,CAAC,EAAE,CAAC3D,cAAc,CAACqC,KAAK,EAAE,GAAG,CAAC,EAAE,CAACrC,cAAc,CAAC6C,MAAM,EAAE,GAAG,CAAC,EAAE,CAAC7C,cAAc,CAAC+C,cAAc,EAAE,IAAI,CAAC,EAAE,CAAC/C,cAAc,CAAC2C,QAAQ,EAAE,GAAG,CAAC,EAAE,CAAC3C,cAAc,CAAC+B,SAAS,EAAE,IAAI,CAAC,EAAE,CAAC/B,cAAc,CAACmC,YAAY,EAAE,KAAK,CAAC,EAAE,CAACnC,cAAc,CAACmE,eAAe,EAAE,IAAI,CAAC,EAAE,CAACnE,cAAc,CAACuD,EAAE,EAAE,IAAI,CAAC,EAAE,CAACvD,cAAc,CAACuC,IAAI,EAAE,GAAG,CAAC,EAAE,CAACvC,cAAc,CAAC8kB,EAAE,EAAE,IAAI,CAAC,EAAE,CAAC9kB,cAAc,CAAC8K,kBAAkB,EAAE,IAAI,CAAC,EAAE,CAAC9K,cAAc,CAAC+K,qBAAqB,EAAE,IAAI,CAAC,EAAE,CAAC/K,cAAc,CAACgL,wBAAwB,EAAE,IAAI,CAAC,EAAE,CAAChL,cAAc,CAACiL,kBAAkB,EAAE,IAAI,CAAC,EAAE,CAACjL,cAAc,CAACkL,mBAAmB,EAAE,IAAI,CAAC,EAAE,CAAClL,cAAc,CAACmL,wBAAwB,EAAE,KAAK,CAAC,EAAE,CAACnL,cAAc,CAACoL,aAAa,EAAE,KAAK,CAAC,EAAE,CAACpL,cAAc,CAACqL,YAAY,EAAE,KAAK,CAAC,EAAE,CAACrL,cAAc,CAACsL,yBAAyB,EAAE,KAAK,CAAC,CAAC,CAAC;AAC5lC,MAAMyZ,qBAAqB,CAAC;EAC1BC,OAAO;EACP,OAAOC,UAAUA,CAAA,EAAG;IAClB,OAAO,IAAIF,qBAAqB,CAAC,CAAC,CAAC;EACrC;EACAG,MAAM;EACN3vB,WAAWA,CAACyvB,OAAO,EAAE;IACnB,IAAI,CAACA,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACE,MAAM,GAAG,CAAC,IAAIT,YAAY,CAACO,OAAO,CAAC,CAAC;EAC3C;EACA,IAAIG,YAAYA,CAAA,EAAG;IACjB,OAAO,IAAI,CAACD,MAAM,CAAC,IAAI,CAACA,MAAM,CAACz0B,MAAM,GAAG,CAAC,CAAC;EAC5C;EACA20B,OAAOA,CAACjC,IAAI,EAAEkC,QAAQ,GAAG,EAAE,EAAE;IAC3B,IAAI,CAACC,KAAK,CAACnC,IAAI,IAAI,IAAI,EAAEkC,QAAQ,EAAE,IAAI,CAAC;EAC1C;EACAE,WAAWA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACJ,YAAY,CAAC9sB,KAAK,CAAC5H,MAAM,KAAK,CAAC;EAC7C;EACA+0B,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI,CAACL,YAAY,CAACT,MAAM,GAAGF,YAAY,CAAC/zB,MAAM,GAAG,IAAI,CAAC00B,YAAY,CAACR,WAAW;EACvF;EACAW,KAAKA,CAACnC,IAAI,EAAEsC,IAAI,EAAEC,OAAO,GAAG,KAAK,EAAE;IACjC,IAAID,IAAI,CAACh1B,MAAM,GAAG,CAAC,EAAE;MACnB,IAAI,CAAC00B,YAAY,CAAC9sB,KAAK,CAAC3H,IAAI,CAAC+0B,IAAI,CAAC;MAClC,IAAI,CAACN,YAAY,CAACR,WAAW,IAAIc,IAAI,CAACh1B,MAAM;MAC5C,IAAI,CAAC00B,YAAY,CAACP,QAAQ,CAACl0B,IAAI,CAACyyB,IAAI,IAAIA,IAAI,CAACxiB,UAAU,IAAI,IAAI,CAAC;IAClE;IACA,IAAI+kB,OAAO,EAAE;MACX,IAAI,CAACR,MAAM,CAACx0B,IAAI,CAAC,IAAI+zB,YAAY,CAAC,IAAI,CAACO,OAAO,CAAC,CAAC;IAClD;EACF;EACAW,mBAAmBA,CAAA,EAAG;IACpB,IAAI,IAAI,CAACJ,WAAW,CAAC,CAAC,EAAE;MACtB,IAAI,CAACL,MAAM,CAACU,GAAG,CAAC,CAAC;IACnB;EACF;EACAC,SAASA,CAAA,EAAG;IACV,IAAI,CAACb,OAAO,EAAE;IACd,IAAI,IAAI,CAACO,WAAW,CAAC,CAAC,EAAE;MACtB,IAAI,CAACJ,YAAY,CAACT,MAAM,GAAG,IAAI,CAACM,OAAO;IACzC;EACF;EACAc,SAASA,CAAA,EAAG;IACV,IAAI,CAACd,OAAO,EAAE;IACd,IAAI,IAAI,CAACO,WAAW,CAAC,CAAC,EAAE;MACtB,IAAI,CAACJ,YAAY,CAACT,MAAM,GAAG,IAAI,CAACM,OAAO;IACzC;EACF;EACAe,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI,CAACC,WAAW,CAACpxB,GAAG,CAACqxB,CAAC,IAAIA,CAAC,CAAC5tB,KAAK,CAAC5H,MAAM,GAAG,CAAC,GAAGy1B,aAAa,CAACD,CAAC,CAACvB,MAAM,CAAC,GAAGuB,CAAC,CAAC5tB,KAAK,CAAChG,IAAI,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,CAACA,IAAI,CAAC,IAAI,CAAC;EACnH;EACA8zB,oBAAoBA,CAACC,WAAW,EAAEC,YAAY,GAAG,CAAC,EAAE;IAClD,MAAMzxB,GAAG,GAAG,IAAIqtB,kBAAkB,CAACmE,WAAW,CAAC;IAC/C,IAAIE,iBAAiB,GAAG,KAAK;IAC7B,MAAMC,sBAAsB,GAAGA,CAAA,KAAM;MACnC,IAAI,CAACD,iBAAiB,EAAE;QACtB1xB,GAAG,CAAC2tB,SAAS,CAAC6D,WAAW,EAAE,GAAG,CAAC,CAAC1D,UAAU,CAAC,CAAC,EAAE0D,WAAW,EAAE,CAAC,EAAE,CAAC,CAAC;QAChEE,iBAAiB,GAAG,IAAI;MAC1B;IACF,CAAC;IACD,KAAK,IAAIz0B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGw0B,YAAY,EAAEx0B,CAAC,EAAE,EAAE;MACrC+C,GAAG,CAAC6tB,OAAO,CAAC,CAAC;MACb8D,sBAAsB,CAAC,CAAC;IAC1B;IACA,IAAI,CAACP,WAAW,CAACrzB,OAAO,CAAC,CAAC6zB,IAAI,EAAEC,OAAO,KAAK;MAC1C7xB,GAAG,CAAC6tB,OAAO,CAAC,CAAC;MACb,MAAMiE,KAAK,GAAGF,IAAI,CAAC5B,QAAQ;MAC3B,MAAMvsB,KAAK,GAAGmuB,IAAI,CAACnuB,KAAK;MACxB,IAAIsqB,IAAI,GAAG6D,IAAI,CAAC9B,MAAM,GAAGF,YAAY,CAAC/zB,MAAM;MAC5C,IAAIk2B,OAAO,GAAG,CAAC;MACf,OAAOA,OAAO,GAAGD,KAAK,CAACj2B,MAAM,IAAI,CAACi2B,KAAK,CAACC,OAAO,CAAC,EAAE;QAChDhE,IAAI,IAAItqB,KAAK,CAACsuB,OAAO,CAAC,CAACl2B,MAAM;QAC7Bk2B,OAAO,EAAE;MACX;MACA,IAAIA,OAAO,GAAGD,KAAK,CAACj2B,MAAM,IAAIg2B,OAAO,KAAK,CAAC,IAAI9D,IAAI,KAAK,CAAC,EAAE;QACzD2D,iBAAiB,GAAG,IAAI;MAC1B,CAAC,MAAM;QACLC,sBAAsB,CAAC,CAAC;MAC1B;MACA,OAAOI,OAAO,GAAGD,KAAK,CAACj2B,MAAM,EAAE;QAC7B,MAAMm2B,IAAI,GAAGF,KAAK,CAACC,OAAO,CAAC;QAC3B,MAAME,MAAM,GAAGD,IAAI,CAACE,KAAK,CAAC5E,IAAI;QAC9B,MAAM6E,UAAU,GAAGH,IAAI,CAACE,KAAK,CAACN,IAAI;QAClC,MAAMQ,SAAS,GAAGJ,IAAI,CAACE,KAAK,CAACG,GAAG;QAChCryB,GAAG,CAAC2tB,SAAS,CAACsE,MAAM,CAAC3d,GAAG,EAAE2d,MAAM,CAACrE,OAAO,CAAC,CAACE,UAAU,CAACC,IAAI,EAAEkE,MAAM,CAAC3d,GAAG,EAAE6d,UAAU,EAAEC,SAAS,CAAC;QAC7FrE,IAAI,IAAItqB,KAAK,CAACsuB,OAAO,CAAC,CAACl2B,MAAM;QAC7Bk2B,OAAO,EAAE;QACT,OAAOA,OAAO,GAAGD,KAAK,CAACj2B,MAAM,KAAKm2B,IAAI,KAAKF,KAAK,CAACC,OAAO,CAAC,IAAI,CAACD,KAAK,CAACC,OAAO,CAAC,CAAC,EAAE;UAC7EhE,IAAI,IAAItqB,KAAK,CAACsuB,OAAO,CAAC,CAACl2B,MAAM;UAC7Bk2B,OAAO,EAAE;QACX;MACF;IACF,CAAC,CAAC;IACF,OAAO/xB,GAAG;EACZ;EACAsyB,MAAMA,CAACV,IAAI,EAAEW,MAAM,EAAE;IACnB,MAAMC,WAAW,GAAG,IAAI,CAAClC,MAAM,CAACsB,IAAI,CAAC;IACrC,IAAIY,WAAW,EAAE;MACf,IAAIC,WAAW,GAAGF,MAAM,GAAGjB,aAAa,CAACkB,WAAW,CAAC1C,MAAM,CAAC,CAACj0B,MAAM;MACnE,KAAK,IAAIyX,SAAS,GAAG,CAAC,EAAEA,SAAS,GAAGkf,WAAW,CAAC/uB,KAAK,CAAC5H,MAAM,EAAEyX,SAAS,EAAE,EAAE;QACzE,MAAMud,IAAI,GAAG2B,WAAW,CAAC/uB,KAAK,CAAC6P,SAAS,CAAC;QACzC,IAAIud,IAAI,CAACh1B,MAAM,GAAG42B,WAAW,EAAE;UAC7B,OAAOD,WAAW,CAACxC,QAAQ,CAAC1c,SAAS,CAAC;QACxC;QACAmf,WAAW,IAAI5B,IAAI,CAACh1B,MAAM;MAC5B;IACF;IACA,OAAO,IAAI;EACb;EACA,IAAIu1B,WAAWA,CAAA,EAAG;IAChB,IAAI,IAAI,CAACd,MAAM,CAACz0B,MAAM,IAAI,IAAI,CAACy0B,MAAM,CAAC,IAAI,CAACA,MAAM,CAACz0B,MAAM,GAAG,CAAC,CAAC,CAAC4H,KAAK,CAAC5H,MAAM,KAAK,CAAC,EAAE;MAChF,OAAO,IAAI,CAACy0B,MAAM,CAAC7zB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACjC;IACA,OAAO,IAAI,CAAC6zB,MAAM;EACpB;AACF;AACA,MAAMoC,sBAAsB,CAAC;EAC3BC,sBAAsB;EACtBC,eAAe,GAAG,IAAI;EACtBjyB,WAAWA,CAACgyB,sBAAsB,EAAE;IAClC,IAAI,CAACA,sBAAsB,GAAGA,sBAAsB;EACtD;EACAE,oBAAoBA,CAACxa,IAAI,EAAEya,GAAG,EAAE;IAC9B,IAAIza,IAAI,CAACH,eAAe,KAAKwT,SAAS,EAAE;MACtC;IACF;IACA,KAAK,MAAMqH,OAAO,IAAI1a,IAAI,CAACH,eAAe,EAAE;MAC1C,IAAI6a,OAAO,YAAYjb,YAAY,EAAE;QACnCgb,GAAG,CAACpC,KAAK,CAACrY,IAAI,EAAE,KAAK0a,OAAO,CAACj1B,QAAQ,CAAC,CAAC,IAAI,EAAEi1B,OAAO,CAAClb,eAAe,CAAC;MACvE,CAAC,MAAM;QACL,IAAIkb,OAAO,CAACnb,SAAS,EAAE;UACrBkb,GAAG,CAACpC,KAAK,CAACrY,IAAI,EAAE,MAAM0a,OAAO,CAAChvB,IAAI,KAAK,EAAEgvB,OAAO,CAAClb,eAAe,CAAC;QACnE,CAAC,MAAM;UACLkb,OAAO,CAAChvB,IAAI,CAAC4oB,KAAK,CAAC,IAAI,CAAC,CAAC5uB,OAAO,CAAC6zB,IAAI,IAAI;YACvCkB,GAAG,CAACtC,OAAO,CAACnY,IAAI,EAAE,MAAMuZ,IAAI,EAAE,CAAC;UACjC,CAAC,CAAC;QACJ;MACF;IACF;EACF;EACAnZ,mBAAmBA,CAACJ,IAAI,EAAEya,GAAG,EAAE;IAC7B,IAAI,CAACD,oBAAoB,CAACxa,IAAI,EAAEya,GAAG,CAAC;IACpCza,IAAI,CAACpI,IAAI,CAACL,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;IACpCA,GAAG,CAACtC,OAAO,CAACnY,IAAI,EAAE,GAAG,CAAC;IACtB,OAAO,IAAI;EACb;EACAM,eAAeA,CAACN,IAAI,EAAEya,GAAG,EAAE;IACzB,IAAI,CAACD,oBAAoB,CAACxa,IAAI,EAAEya,GAAG,CAAC;IACpCA,GAAG,CAACpC,KAAK,CAACrY,IAAI,EAAE,SAAS,CAAC;IAC1BA,IAAI,CAACza,KAAK,CAACgS,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;IACrCA,GAAG,CAACtC,OAAO,CAACnY,IAAI,EAAE,GAAG,CAAC;IACtB,OAAO,IAAI;EACb;EACAQ,WAAWA,CAACR,IAAI,EAAEya,GAAG,EAAE;IACrB,IAAI,CAACD,oBAAoB,CAACxa,IAAI,EAAEya,GAAG,CAAC;IACpCA,GAAG,CAACpC,KAAK,CAACrY,IAAI,EAAE,MAAM,CAAC;IACvB,IAAI,CAACua,eAAe,GAAGva,IAAI,CAAClE,SAAS;IACrCkE,IAAI,CAAClE,SAAS,CAACvE,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;IACzC,IAAI,CAACF,eAAe,GAAG,IAAI;IAC3BE,GAAG,CAACpC,KAAK,CAACrY,IAAI,EAAE,KAAK,CAAC;IACtB,MAAM2a,WAAW,GAAG3a,IAAI,CAACzL,SAAS,IAAI,IAAI,IAAIyL,IAAI,CAACzL,SAAS,CAAC/Q,MAAM,GAAG,CAAC;IACvE,IAAIwc,IAAI,CAAC1L,QAAQ,CAAC9Q,MAAM,IAAI,CAAC,IAAI,CAACm3B,WAAW,EAAE;MAC7CF,GAAG,CAACpC,KAAK,CAACrY,IAAI,EAAE,GAAG,CAAC;MACpB,IAAI,CAACa,kBAAkB,CAACb,IAAI,CAAC1L,QAAQ,EAAEmmB,GAAG,CAAC;MAC3CA,GAAG,CAAC/B,mBAAmB,CAAC,CAAC;MACzB+B,GAAG,CAACpC,KAAK,CAACrY,IAAI,EAAE,GAAG,CAAC;IACtB,CAAC,MAAM;MACLya,GAAG,CAACtC,OAAO,CAAC,CAAC;MACbsC,GAAG,CAAC7B,SAAS,CAAC,CAAC;MACf,IAAI,CAAC/X,kBAAkB,CAACb,IAAI,CAAC1L,QAAQ,EAAEmmB,GAAG,CAAC;MAC3CA,GAAG,CAAC5B,SAAS,CAAC,CAAC;MACf,IAAI8B,WAAW,EAAE;QACfF,GAAG,CAACtC,OAAO,CAACnY,IAAI,EAAE,UAAU,CAAC;QAC7Bya,GAAG,CAAC7B,SAAS,CAAC,CAAC;QACf,IAAI,CAAC/X,kBAAkB,CAACb,IAAI,CAACzL,SAAS,EAAEkmB,GAAG,CAAC;QAC5CA,GAAG,CAAC5B,SAAS,CAAC,CAAC;MACjB;IACF;IACA4B,GAAG,CAACtC,OAAO,CAACnY,IAAI,EAAE,GAAG,CAAC;IACtB,OAAO,IAAI;EACb;EACA1H,uBAAuBA,CAACV,IAAI,EAAE6iB,GAAG,EAAE;IACjC,MAAMG,kBAAkB,GAAGhjB,IAAI,CAACO,EAAE,YAAY2E,iBAAiB;IAC/D,IAAI8d,kBAAkB,EAAE;MACtBH,GAAG,CAACpC,KAAK,CAACzgB,IAAI,CAACO,EAAE,EAAE,GAAG,CAAC;IACzB;IACAP,IAAI,CAACO,EAAE,CAACZ,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;IAClC,IAAIG,kBAAkB,EAAE;MACtBH,GAAG,CAACpC,KAAK,CAACzgB,IAAI,CAACO,EAAE,EAAE,GAAG,CAAC;IACzB;IACAsiB,GAAG,CAACpC,KAAK,CAACzgB,IAAI,EAAE,GAAG,CAAC;IACpB,IAAI,CAACgJ,mBAAmB,CAAChJ,IAAI,CAACQ,IAAI,EAAEqiB,GAAG,EAAE,GAAG,CAAC;IAC7CA,GAAG,CAACpC,KAAK,CAACzgB,IAAI,EAAE,GAAG,CAAC;IACpB,OAAO,IAAI;EACb;EACAc,8BAA8BA,CAACd,IAAI,EAAE6iB,GAAG,EAAE;IACxC7iB,IAAI,CAAC3T,GAAG,CAACsT,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;IACnC7iB,IAAI,CAACa,QAAQ,CAAClB,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;IACxC,OAAO,IAAI;EACb;EACAnhB,wBAAwBA,CAAC1B,IAAI,EAAE6iB,GAAG,EAAE;IAClCA,GAAG,CAACpC,KAAK,CAACzgB,IAAI,EAAE,GAAG,CAAC;IACpB,KAAK,IAAIhT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgT,IAAI,CAACwB,QAAQ,CAAC5V,MAAM,EAAEoB,CAAC,EAAE,EAAE;MAC7CgT,IAAI,CAACwB,QAAQ,CAACxU,CAAC,CAAC,CAAC2S,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;MAC3C,MAAMnuB,UAAU,GAAG1H,CAAC,GAAGgT,IAAI,CAACyB,WAAW,CAAC7V,MAAM,GAAGoU,IAAI,CAACyB,WAAW,CAACzU,CAAC,CAAC,GAAG,IAAI;MAC3E,IAAI0H,UAAU,KAAK,IAAI,EAAE;QACvBmuB,GAAG,CAACpC,KAAK,CAAC/rB,UAAU,EAAE,IAAI,CAAC;QAC3BA,UAAU,CAACiL,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;QACrCA,GAAG,CAACpC,KAAK,CAAC/rB,UAAU,EAAE,GAAG,CAAC;MAC5B;IACF;IACAmuB,GAAG,CAACpC,KAAK,CAACzgB,IAAI,EAAE,GAAG,CAAC;EACtB;EACAgC,+BAA+BA,CAAChC,IAAI,EAAE6iB,GAAG,EAAE;IACzCA,GAAG,CAACpC,KAAK,CAACzgB,IAAI,EAAEA,IAAI,CAAC6B,OAAO,CAAC;EAC/B;EACAvB,oBAAoBA,CAACyI,GAAG,EAAE8Z,GAAG,EAAE;IAC7B,MAAM,IAAIz2B,KAAK,CAAC,gDAAgD,CAAC;EACnE;EACA6T,eAAeA,CAACD,IAAI,EAAE6iB,GAAG,EAAE;IACzBA,GAAG,CAACpC,KAAK,CAACzgB,IAAI,EAAE,SAAS,CAAC;IAC1BA,IAAI,CAACA,IAAI,CAACL,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;EACtC;EACA1iB,aAAaA,CAACH,IAAI,EAAE6iB,GAAG,EAAE;IACvBA,GAAG,CAACpC,KAAK,CAACzgB,IAAI,EAAE,OAAO,CAAC;IACxBA,IAAI,CAACA,IAAI,CAACL,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;EACtC;EACAjjB,gBAAgBA,CAACmJ,GAAG,EAAE8Z,GAAG,EAAE;IACzBA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAEA,GAAG,CAACrb,IAAI,CAAC;IACxB,OAAO,IAAI;EACb;EACAsT,oBAAoBA,CAAC+H,GAAG,EAAE8Z,GAAG,EAAE;IAC7BA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,MAAM,CAAC;IACtBA,GAAG,CAAChI,SAAS,CAACpB,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;IACxCA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IACnB,IAAI,CAACC,mBAAmB,CAACD,GAAG,CAACvI,IAAI,EAAEqiB,GAAG,EAAE,GAAG,CAAC;IAC5CA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IACnB,OAAO,IAAI;EACb;EACAzH,gBAAgBA,CAACyH,GAAG,EAAE8Z,GAAG,EAAE;IACzB,MAAMl1B,KAAK,GAAGob,GAAG,CAACpb,KAAK;IACvB,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC7Bk1B,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAEka,gBAAgB,CAACt1B,KAAK,EAAE,IAAI,CAAC+0B,sBAAsB,CAAC,CAAC;IACtE,CAAC,MAAM;MACLG,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAGpb,KAAK,EAAE,CAAC;IAC5B;IACA,OAAO,IAAI;EACb;EACAyT,6BAA6BA,CAAC2H,GAAG,EAAE8Z,GAAG,EAAE;IACtCA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,IAAIA,GAAG,CAAC7H,IAAI,IAAI6H,GAAG,CAAC5H,KAAK,IAAI,EAAE,EAAE,CAAC;IACjD,OAAO,IAAI;EACb;EACAwB,oBAAoBA,CAACoG,GAAG,EAAE8Z,GAAG,EAAE;IAC7B,MAAMK,IAAI,GAAGna,GAAG,CAACnG,iBAAiB,CAAC,CAAC;IACpCigB,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,aAAa,GAAGma,IAAI,CAACrf,GAAG,CAAC;IACxC,KAAK,IAAI7W,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+b,GAAG,CAACtG,YAAY,CAAC7W,MAAM,EAAEoB,CAAC,EAAE,EAAE;MAChD61B,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,IAAI,CAAC;MACpBA,GAAG,CAACtH,WAAW,CAACzU,CAAC,GAAG,CAAC,CAAC,CAAC2S,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;MACjDA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,IAAIA,GAAG,CAAC3F,yBAAyB,CAACpW,CAAC,CAAC,CAAC6W,GAAG,EAAE,CAAC;IAC5D;IACAgf,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IACnB,OAAO,IAAI;EACb;EACA5E,oBAAoBA,CAAC4E,GAAG,EAAE8Z,GAAG,EAAE;IAC7BA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IACnBA,GAAG,CAAC7E,SAAS,CAACvE,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;IACxCA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,IAAI,CAAC;IACpBA,GAAG,CAACrM,QAAQ,CAACiD,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;IACvCA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,IAAI,CAAC;IACpBA,GAAG,CAACpM,SAAS,CAACgD,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;IACxCA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IACnB,OAAO,IAAI;EACb;EACAxE,sBAAsBA,CAACwE,GAAG,EAAE8Z,GAAG,EAAE;IAC/BA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,UAAUA,GAAG,CAAC1E,GAAG,GAAG,CAAC;EACtC;EACAI,YAAYA,CAACsE,GAAG,EAAE8Z,GAAG,EAAE;IACrBA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IACnBA,GAAG,CAAC7E,SAAS,CAACvE,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;IACxC,OAAO,IAAI;EACb;EACAnd,sBAAsBA,CAACqD,GAAG,EAAE8Z,GAAG,EAAE;IAC/B,IAAIM,KAAK;IACT,QAAQpa,GAAG,CAACvD,QAAQ;MAClB,KAAKtK,aAAa,CAACwC,IAAI;QACrBylB,KAAK,GAAG,GAAG;QACX;MACF,KAAKjoB,aAAa,CAACsC,KAAK;QACtB2lB,KAAK,GAAG,GAAG;QACX;MACF;QACE,MAAM,IAAI/2B,KAAK,CAAC,oBAAoB2c,GAAG,CAACvD,QAAQ,EAAE,CAAC;IACvD;IACA,MAAMC,MAAM,GAAGsD,GAAG,KAAK,IAAI,CAAC4Z,eAAe;IAC3C,IAAIld,MAAM,EAAEod,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IAC/B8Z,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAEoa,KAAK,CAAC;IACrBpa,GAAG,CAAC/I,IAAI,CAACL,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;IACnC,IAAIpd,MAAM,EAAEod,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IAC/B,OAAO,IAAI;EACb;EACAjD,uBAAuBA,CAACiD,GAAG,EAAE8Z,GAAG,EAAE;IAChC,MAAMrd,QAAQ,GAAGwa,kBAAkB,CAACrwB,GAAG,CAACoZ,GAAG,CAACvD,QAAQ,CAAC;IACrD,IAAI,CAACA,QAAQ,EAAE;MACb,MAAM,IAAIpZ,KAAK,CAAC,oBAAoB2c,GAAG,CAACvD,QAAQ,EAAE,CAAC;IACrD;IACA,MAAMC,MAAM,GAAGsD,GAAG,KAAK,IAAI,CAAC4Z,eAAe;IAC3C,IAAIld,MAAM,EAAEod,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IAC/BA,GAAG,CAAClD,GAAG,CAAClG,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;IAClCA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,IAAIvD,QAAQ,GAAG,CAAC;IAC/BuD,GAAG,CAACjM,GAAG,CAAC6C,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;IAClC,IAAIpd,MAAM,EAAEod,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IAC/B,OAAO,IAAI;EACb;EACArC,iBAAiBA,CAACqC,GAAG,EAAE8Z,GAAG,EAAE;IAC1B9Z,GAAG,CAACtI,QAAQ,CAACd,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;IACvCA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IACnB8Z,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAEA,GAAG,CAACrb,IAAI,CAAC;IACxB,OAAO,IAAI;EACb;EACAiZ,gBAAgBA,CAACoC,GAAG,EAAE8Z,GAAG,EAAE;IACzB9Z,GAAG,CAACtI,QAAQ,CAACd,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;IACvCA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IACnBA,GAAG,CAAC5R,KAAK,CAACwI,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;IACpCA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IACnB,OAAO,IAAI;EACb;EACAhC,qBAAqBA,CAACgC,GAAG,EAAE8Z,GAAG,EAAE;IAC9BA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IACnB,IAAI,CAACC,mBAAmB,CAACD,GAAG,CAAClC,OAAO,EAAEgc,GAAG,EAAE,GAAG,CAAC;IAC/CA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IACnB,OAAO,IAAI;EACb;EACA5B,mBAAmBA,CAAC4B,GAAG,EAAE8Z,GAAG,EAAE;IAC5BA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IACnB,IAAI,CAACqa,eAAe,CAAC/b,KAAK,IAAI;MAC5Bwb,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAGka,gBAAgB,CAAC5b,KAAK,CAACpL,GAAG,EAAE,IAAI,CAACymB,sBAAsB,EAAErb,KAAK,CAACJ,MAAM,CAAC,GAAG,CAAC;MAC5FI,KAAK,CAAC1Z,KAAK,CAACgS,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;IACxC,CAAC,EAAE9Z,GAAG,CAAClC,OAAO,EAAEgc,GAAG,EAAE,GAAG,CAAC;IACzBA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IACnB,OAAO,IAAI;EACb;EACAxB,cAAcA,CAACwB,GAAG,EAAE8Z,GAAG,EAAE;IACvBA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IACnB,IAAI,CAACC,mBAAmB,CAACD,GAAG,CAACvV,KAAK,EAAEqvB,GAAG,EAAE,GAAG,CAAC;IAC7CA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IACnB,OAAO,IAAI;EACb;EACAnD,sBAAsBA,CAACmD,GAAG,EAAE8Z,GAAG,EAAE;IAC/B9Z,GAAG,CAAC/I,IAAI,CAACL,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;EACrC;EACA7Z,mBAAmBA,CAACvH,WAAW,EAAEohB,GAAG,EAAEQ,SAAS,EAAE;IAC/C,IAAI,CAACD,eAAe,CAACpjB,IAAI,IAAIA,IAAI,CAACL,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC,EAAEphB,WAAW,EAAEohB,GAAG,EAAEQ,SAAS,CAAC;EAC5F;EACAD,eAAeA,CAACE,OAAO,EAAE7hB,WAAW,EAAEohB,GAAG,EAAEQ,SAAS,EAAE;IACpD,IAAIE,iBAAiB,GAAG,KAAK;IAC7B,KAAK,IAAIv2B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyU,WAAW,CAAC7V,MAAM,EAAEoB,CAAC,EAAE,EAAE;MAC3C,IAAIA,CAAC,GAAG,CAAC,EAAE;QACT,IAAI61B,GAAG,CAAClC,UAAU,CAAC,CAAC,GAAG,EAAE,EAAE;UACzBkC,GAAG,CAACpC,KAAK,CAAC,IAAI,EAAE4C,SAAS,EAAE,IAAI,CAAC;UAChC,IAAI,CAACE,iBAAiB,EAAE;YACtBV,GAAG,CAAC7B,SAAS,CAAC,CAAC;YACf6B,GAAG,CAAC7B,SAAS,CAAC,CAAC;YACfuC,iBAAiB,GAAG,IAAI;UAC1B;QACF,CAAC,MAAM;UACLV,GAAG,CAACpC,KAAK,CAAC,IAAI,EAAE4C,SAAS,EAAE,KAAK,CAAC;QACnC;MACF;MACAC,OAAO,CAAC7hB,WAAW,CAACzU,CAAC,CAAC,CAAC;IACzB;IACA,IAAIu2B,iBAAiB,EAAE;MACrBV,GAAG,CAAC5B,SAAS,CAAC,CAAC;MACf4B,GAAG,CAAC5B,SAAS,CAAC,CAAC;IACjB;EACF;EACAhY,kBAAkBA,CAACpE,UAAU,EAAEge,GAAG,EAAE;IAClChe,UAAU,CAAC/W,OAAO,CAACsa,IAAI,IAAIA,IAAI,CAACC,cAAc,CAAC,IAAI,EAAEwa,GAAG,CAAC,CAAC;EAC5D;AACF;AACA,SAASI,gBAAgBA,CAACrI,KAAK,EAAE4I,YAAY,EAAEC,WAAW,GAAG,IAAI,EAAE;EACjE,IAAI7I,KAAK,IAAI,IAAI,EAAE;IACjB,OAAO,IAAI;EACb;EACA,MAAM1Z,IAAI,GAAG0Z,KAAK,CAACxtB,OAAO,CAACqyB,8BAA8B,EAAE,CAAC,GAAG1zB,KAAK,KAAK;IACvE,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE;MACnB,OAAOy3B,YAAY,GAAG,KAAK,GAAG,GAAG;IACnC,CAAC,MAAM,IAAIz3B,KAAK,CAAC,CAAC,CAAC,IAAI,IAAI,EAAE;MAC3B,OAAO,KAAK;IACd,CAAC,MAAM,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,IAAI,EAAE;MAC3B,OAAO,KAAK;IACd,CAAC,MAAM;MACL,OAAO,KAAKA,KAAK,CAAC,CAAC,CAAC,EAAE;IACxB;EACF,CAAC,CAAC;EACF,MAAM23B,cAAc,GAAGD,WAAW,IAAI,CAAC/D,oBAAoB,CAACzC,IAAI,CAAC/b,IAAI,CAAC;EACtE,OAAOwiB,cAAc,GAAG,IAAIxiB,IAAI,GAAG,GAAGA,IAAI;AAC5C;AACA,SAASmgB,aAAaA,CAAC5oB,KAAK,EAAE;EAC5B,IAAI/M,GAAG,GAAG,EAAE;EACZ,KAAK,IAAIsB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyL,KAAK,EAAEzL,CAAC,EAAE,EAAE;IAC9BtB,GAAG,IAAIi0B,YAAY;EACrB;EACA,OAAOj0B,GAAG;AACZ;AAEA,SAASi4B,kBAAkBA,CAAChvB,IAAI,EAAEivB,SAAS,EAAE;EAC3C,IAAIA,SAAS,KAAK,CAAC,EAAE;IACnB,OAAOna,cAAc,CAAC9U,IAAI,CAAC;EAC7B;EACA,MAAMyH,MAAM,GAAG,EAAE;EACjB,KAAK,IAAIpP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG42B,SAAS,EAAE52B,CAAC,EAAE,EAAE;IAClCoP,MAAM,CAACvQ,IAAI,CAACuO,YAAY,CAAC;EAC3B;EACA,OAAOqP,cAAc,CAAC9U,IAAI,EAAE8mB,SAAS,EAAErf,MAAM,CAAC;AAChD;AACA,SAASynB,2BAA2BA,CAACC,QAAQ,EAAEp2B,IAAI,EAAE;EACnD,MAAMq2B,WAAW,GAAGd,gBAAgB,CAACv1B,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC;EACxD,OAAOq2B,WAAW,KAAKr2B,IAAI,GAAG,GAAGo2B,QAAQ,IAAIC,WAAW,GAAG,GAAG,GAAGD,QAAQ,IAAIp2B,IAAI,EAAE;AACrF;AACA,SAASs2B,wBAAwBA,CAAChkB,IAAI,EAAE;EACtC,OAAOikB,iBAAiB,CAAC,WAAW,EAAEjkB,IAAI,CAAC;AAC7C;AACA,SAASkkB,wBAAwBA,CAAClkB,IAAI,EAAE;EACtC,OAAOikB,iBAAiB,CAAC,WAAW,EAAEjkB,IAAI,CAAC;AAC7C;AACA,SAASikB,iBAAiBA,CAACE,KAAK,EAAEnkB,IAAI,EAAE;EACtC,MAAMokB,SAAS,GAAG,IAAItgB,YAAY,CAAC;IACjCpW,IAAI,EAAEy2B,KAAK;IACXpgB,UAAU,EAAE;EACd,CAAC,CAAC;EACF,MAAMsgB,eAAe,GAAG,IAAItnB,kBAAkB,CAAC5B,cAAc,CAACiC,SAAS,EAAE,IAAI2C,UAAU,CAACqkB,SAAS,CAAC,EAAE9Z,OAAO,CAAC,WAAW,CAAC,CAAC;EACzH,MAAMga,oBAAoB,GAAG,IAAIvnB,kBAAkB,CAAC5B,cAAc,CAACuD,EAAE,EAAE2lB,eAAe,EAAED,SAAS,EAAE3I,SAAS,EAAEA,SAAS,CAAC;EACxH,OAAO,IAAI1e,kBAAkB,CAAC5B,cAAc,CAACiD,GAAG,EAAEkmB,oBAAoB,EAAEtkB,IAAI,CAAC;AAC/E;AACA,SAASukB,aAAaA,CAAC52B,KAAK,EAAE;EAC5B,MAAM62B,OAAO,GAAG,IAAIpkB,eAAe,CAACzS,KAAK,CAAC;EAC1C,OAAO;IACLA,KAAK,EAAE62B,OAAO;IACd7vB,IAAI,EAAE6vB;EACR,CAAC;AACH;AACA,SAASC,WAAWA,CAACC,IAAI,EAAEC,oBAAoB,EAAE;EAC/C,MAAM9a,MAAM,GAAGD,UAAU,CAAC8a,IAAI,CAAC30B,GAAG,CAAC60B,GAAG,IAAIA,GAAG,CAACj3B,KAAK,CAAC,CAAC;EACrD,OAAOg3B,oBAAoB,GAAG1a,OAAO,CAAC,EAAE,EAAEJ,MAAM,CAAC,GAAGA,MAAM;AAC5D;AACA,SAASgb,+BAA+BA,CAACnwB,UAAU,EAAEkhB,UAAU,EAAE;EAC/D,OAAO;IACLlhB,UAAU;IACVkhB;EACF,CAAC;AACH;AACA,SAASkP,oCAAoCA,CAAC;EAC5CpwB,UAAU;EACVkhB;AACF,CAAC,EAAE;EACD,QAAQA,UAAU;IAChB,KAAK,CAAC;IACN,KAAK,CAAC;MACJ,OAAOlhB,UAAU;IACnB,KAAK,CAAC;MACJ,OAAOqwB,kBAAkB,CAACrwB,UAAU,CAAC;EACzC;AACF;AACA,SAASqwB,kBAAkBA,CAAC/kB,IAAI,EAAE;EAChC,OAAOsJ,UAAU,CAACwE,WAAW,CAAC8H,UAAU,CAAC,CAACzZ,MAAM,CAAC,CAAC8N,OAAO,CAAC,EAAE,EAAEjK,IAAI,CAAC,CAAC,CAAC;AACvE;AAEA,IAAIglB,qBAAqB;AACzB,CAAC,UAAUA,qBAAqB,EAAE;EAChCA,qBAAqB,CAACA,qBAAqB,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;EACnEA,qBAAqB,CAACA,qBAAqB,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;AAC3E,CAAC,EAAEA,qBAAqB,KAAKA,qBAAqB,GAAG,CAAC,CAAC,CAAC,CAAC;AACzD,SAASC,sBAAsBA,CAACC,IAAI,EAAE;EACpC,MAAMC,CAAC,GAAG9b,QAAQ,CAAC,mBAAmB,CAAC;EACvC,IAAI+b,cAAc,GAAG,IAAI;EACzB,MAAMC,WAAW,GAAG,CAACC,0BAA0B,CAACJ,IAAI,CAAC,GAAG,IAAInoB,kBAAkB,CAAC5B,cAAc,CAACuD,EAAE,EAAEymB,CAAC,EAAED,IAAI,CAACvwB,IAAI,CAAChH,KAAK,CAAC,GAAGw3B,CAAC;EACzH,IAAII,QAAQ,GAAG,IAAI;EACnB,IAAIL,IAAI,CAACM,IAAI,KAAK,IAAI,EAAE;IACtB,IAAIN,IAAI,CAACM,IAAI,KAAK,SAAS,EAAE;MAC3BD,QAAQ,GAAG,IAAI/oB,eAAe,CAAC6oB,WAAW,EAAEI,kBAAkB,CAACP,IAAI,CAACM,IAAI,EAAEN,IAAI,CAACQ,MAAM,CAAC,CAAC;IACzF;EACF,CAAC,MAAM;IACLN,cAAc,GAAG/b,QAAQ,CAAC,IAAI6b,IAAI,CAACx3B,IAAI,cAAc,CAAC;IACtD63B,QAAQ,GAAGH,cAAc,CAACjpB,MAAM,CAAC,CAACkpB,WAAW,CAAC,CAAC;EACjD;EACA,MAAMnkB,IAAI,GAAG,EAAE;EACf,IAAIykB,OAAO,GAAG,IAAI;EAClB,SAASC,sBAAsBA,CAACC,WAAW,EAAE;IAC3C,MAAMC,CAAC,GAAGzc,QAAQ,CAAC,0BAA0B,CAAC;IAC9CnI,IAAI,CAACrV,IAAI,CAAC,IAAIyZ,cAAc,CAACwgB,CAAC,CAACp4B,IAAI,EAAE8Z,SAAS,EAAElN,aAAa,CAAC,CAAC;IAC/D,MAAMyrB,QAAQ,GAAGR,QAAQ,KAAK,IAAI,GAAGO,CAAC,CAACl2B,GAAG,CAAC21B,QAAQ,CAAC,CAAChmB,MAAM,CAAC,CAAC,GAAG+J,UAAU,CAACwE,WAAW,CAAC2H,cAAc,CAAC,CAACtZ,MAAM,CAAC,EAAE,CAAC,CAACoD,MAAM,CAAC,CAAC;IAC1H2B,IAAI,CAACrV,IAAI,CAACqe,MAAM,CAACib,CAAC,EAAE,CAACY,QAAQ,CAAC,EAAE,CAACD,CAAC,CAACl2B,GAAG,CAACi2B,WAAW,CAAC,CAACtmB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IAC/D,OAAOumB,CAAC;EACV;EACA,IAAIR,0BAA0B,CAACJ,IAAI,CAAC,EAAE;IACpC,MAAMc,YAAY,GAAGP,kBAAkB,CAACP,IAAI,CAACe,YAAY,EAAEf,IAAI,CAACQ,MAAM,CAAC;IACvE,MAAMQ,WAAW,GAAG,KAAKhB,IAAI,CAACiB,YAAY,KAAKnB,qBAAqB,CAACoB,KAAK,GAAG5pB,eAAe,GAAGF,kBAAkB,EAAE4oB,IAAI,CAACmB,QAAQ,EAAEL,YAAY,CAAC;IAC/IL,OAAO,GAAGC,sBAAsB,CAACM,WAAW,CAAC;EAC/C,CAAC,MAAM,IAAII,2BAA2B,CAACpB,IAAI,CAAC,EAAE;IAC5CS,OAAO,GAAGC,sBAAsB,CAACV,IAAI,CAACxwB,UAAU,CAAC;EACnD,CAAC,MAAM;IACLixB,OAAO,GAAGJ,QAAQ;EACpB;EACA,IAAII,OAAO,KAAK,IAAI,EAAE;IACpBzkB,IAAI,CAACrV,IAAI,CAACyd,UAAU,CAACwE,WAAW,CAAC2H,cAAc,CAAC,CAACtZ,MAAM,CAAC,EAAE,CAAC,CAACoD,MAAM,CAAC,CAAC,CAAC;EACvE,CAAC,MAAM,IAAI6lB,cAAc,KAAK,IAAI,EAAE;IAClC,MAAMmB,uBAAuB,GAAGjd,UAAU,CAACwE,WAAW,CAACwL,mBAAmB,CAAC,CAACnd,MAAM,CAAC,CAAC+oB,IAAI,CAACvwB,IAAI,CAAChH,KAAK,CAAC,CAAC;IACrG,MAAM64B,WAAW,GAAG,IAAIzpB,kBAAkB,CAAC5B,cAAc,CAACuD,EAAE,EAAE0mB,cAAc,EAAEA,cAAc,CAACx1B,GAAG,CAAC22B,uBAAuB,CAAC,CAAC;IAC1HrlB,IAAI,CAACrV,IAAI,CAAC,IAAI4c,eAAe,CAAC+d,WAAW,CAACrqB,MAAM,CAAC,CAACkpB,WAAW,CAAC,CAAC,CAAC,CAAC;EACnE,CAAC,MAAM;IACLnkB,IAAI,CAACrV,IAAI,CAAC,IAAI4c,eAAe,CAACkd,OAAO,CAAC,CAAC;EACzC;EACA,IAAIc,SAAS,GAAGlmB,EAAE,CAAC,CAAC,IAAImE,OAAO,CAACygB,CAAC,CAACz3B,IAAI,EAAE0M,YAAY,CAAC,CAAC,EAAE8G,IAAI,EAAE5G,aAAa,EAAEmhB,SAAS,EAAE,GAAGyJ,IAAI,CAACx3B,IAAI,UAAU,CAAC;EAC/G,IAAI03B,cAAc,KAAK,IAAI,EAAE;IAC3BqB,SAAS,GAAGxc,OAAO,CAAC,EAAE,EAAE,CAAC,IAAI3E,cAAc,CAAC8f,cAAc,CAAC13B,IAAI,CAAC,EAAE,IAAI+a,eAAe,CAACge,SAAS,CAAC,CAAC,CAAC,CAACtqB,MAAM,CAAC,EAAE,EAAEsf,SAAS,EAAE,IAAI,CAAC;EAChI;EACA,OAAO;IACL/mB,UAAU,EAAE+xB,SAAS;IACrB5hB,UAAU,EAAE,EAAE;IACdlQ,IAAI,EAAE+xB,iBAAiB,CAACxB,IAAI;EAC9B,CAAC;AACH;AACA,SAASwB,iBAAiBA,CAACxB,IAAI,EAAE;EAC/B,MAAMyB,YAAY,GAAGzB,IAAI,CAACM,IAAI,KAAK,IAAI,IAAIN,IAAI,CAACM,IAAI,KAAK,SAAS,GAAGoB,kBAAkB,CAAC1B,IAAI,CAACM,IAAI,CAAC,GAAGvqB,SAAS;EAC9G,OAAOwO,cAAc,CAACH,UAAU,CAACwE,WAAW,CAAC6I,kBAAkB,EAAE,CAACgN,kBAAkB,CAACuB,IAAI,CAACvwB,IAAI,CAACA,IAAI,EAAEuwB,IAAI,CAAC2B,iBAAiB,CAAC,EAAEF,YAAY,CAAC,CAAC,CAAC;AAC/I;AACA,SAASlB,kBAAkBA,CAACD,IAAI,EAAEE,MAAM,EAAE;EACxC,OAAOF,IAAI,CAACz1B,GAAG,CAAC,CAAC+2B,GAAG,EAAE3vB,KAAK,KAAK4vB,uBAAuB,CAACD,GAAG,EAAEpB,MAAM,EAAEvuB,KAAK,CAAC,CAAC;AAC9E;AACA,SAAS4vB,uBAAuBA,CAACD,GAAG,EAAEpB,MAAM,EAAEvuB,KAAK,EAAE;EACnD,IAAI2vB,GAAG,CAAC7K,KAAK,KAAK,IAAI,EAAE;IACtB,OAAO3S,UAAU,CAACwE,WAAW,CAAC4H,iBAAiB,CAAC,CAACvZ,MAAM,CAAC,CAACmO,OAAO,CAACnT,KAAK,CAAC,CAAC,CAAC;EAC3E,CAAC,MAAM,IAAI2vB,GAAG,CAACE,iBAAiB,KAAK,IAAI,EAAE;IACzC,MAAM7lB,KAAK,GAAG,CAAC,IAAI2lB,GAAG,CAACG,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,IAAIH,GAAG,CAACI,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC,IAAIJ,GAAG,CAACK,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,IAAIL,GAAG,CAACM,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI1B,MAAM,KAAKlzB,aAAa,CAAC60B,IAAI,GAAG,EAAE,GAAG,CAAC,CAAC;IACtJ,IAAIC,UAAU,GAAGnmB,KAAK,KAAK,CAAC,IAAI2lB,GAAG,CAACM,QAAQ,GAAG9c,OAAO,CAACnJ,KAAK,CAAC,GAAG,IAAI;IACpE,MAAMomB,UAAU,GAAG,CAACT,GAAG,CAAC7K,KAAK,CAAC;IAC9B,IAAIqL,UAAU,EAAE;MACdC,UAAU,CAAC17B,IAAI,CAACy7B,UAAU,CAAC;IAC7B;IACA,MAAME,QAAQ,GAAGC,WAAW,CAAC/B,MAAM,CAAC;IACpC,OAAOpc,UAAU,CAACke,QAAQ,CAAC,CAACrrB,MAAM,CAACorB,UAAU,CAAC;EAChD,CAAC,MAAM;IACL,OAAOje,UAAU,CAACwE,WAAW,CAACyH,eAAe,CAAC,CAACpZ,MAAM,CAAC,CAAC2qB,GAAG,CAAC7K,KAAK,CAAC,CAAC;EACpE;AACF;AACA,SAAS2K,kBAAkBA,CAACpB,IAAI,EAAE;EAChC,IAAIkC,QAAQ,GAAG,KAAK;EACpB,MAAMC,cAAc,GAAGnC,IAAI,CAACz1B,GAAG,CAAC+2B,GAAG,IAAI;IACrC,MAAMnyB,IAAI,GAAGizB,iBAAiB,CAACd,GAAG,CAAC;IACnC,IAAInyB,IAAI,KAAK,IAAI,EAAE;MACjB+yB,QAAQ,GAAG,IAAI;MACf,OAAO/yB,IAAI;IACb,CAAC,MAAM;MACL,OAAO2V,OAAO,CAAC,IAAI,CAAC;IACtB;EACF,CAAC,CAAC;EACF,IAAIod,QAAQ,EAAE;IACZ,OAAOje,cAAc,CAACG,UAAU,CAAC+d,cAAc,CAAC,CAAC;EACnD,CAAC,MAAM;IACL,OAAO1sB,SAAS;EAClB;AACF;AACA,SAAS2sB,iBAAiBA,CAACd,GAAG,EAAE;EAC9B,MAAMjgB,OAAO,GAAG,EAAE;EAClB,IAAIigB,GAAG,CAACE,iBAAiB,KAAK,IAAI,EAAE;IAClCngB,OAAO,CAAChb,IAAI,CAAC;MACXoQ,GAAG,EAAE,WAAW;MAChBtO,KAAK,EAAEm5B,GAAG,CAACE,iBAAiB;MAC5B/f,MAAM,EAAE;IACV,CAAC,CAAC;EACJ;EACA,IAAI6f,GAAG,CAACM,QAAQ,EAAE;IAChBvgB,OAAO,CAAChb,IAAI,CAAC;MACXoQ,GAAG,EAAE,UAAU;MACftO,KAAK,EAAE2c,OAAO,CAAC,IAAI,CAAC;MACpBrD,MAAM,EAAE;IACV,CAAC,CAAC;EACJ;EACA,IAAI6f,GAAG,CAACK,IAAI,EAAE;IACZtgB,OAAO,CAAChb,IAAI,CAAC;MACXoQ,GAAG,EAAE,MAAM;MACXtO,KAAK,EAAE2c,OAAO,CAAC,IAAI,CAAC;MACpBrD,MAAM,EAAE;IACV,CAAC,CAAC;EACJ;EACA,IAAI6f,GAAG,CAACG,IAAI,EAAE;IACZpgB,OAAO,CAAChb,IAAI,CAAC;MACXoQ,GAAG,EAAE,MAAM;MACXtO,KAAK,EAAE2c,OAAO,CAAC,IAAI,CAAC;MACpBrD,MAAM,EAAE;IACV,CAAC,CAAC;EACJ;EACA,IAAI6f,GAAG,CAACI,QAAQ,EAAE;IAChBrgB,OAAO,CAAChb,IAAI,CAAC;MACXoQ,GAAG,EAAE,UAAU;MACftO,KAAK,EAAE2c,OAAO,CAAC,IAAI,CAAC;MACpBrD,MAAM,EAAE;IACV,CAAC,CAAC;EACJ;EACA,OAAOJ,OAAO,CAACjb,MAAM,GAAG,CAAC,GAAGke,UAAU,CAACjD,OAAO,CAAC,GAAG,IAAI;AACxD;AACA,SAASye,0BAA0BA,CAACJ,IAAI,EAAE;EACxC,OAAOA,IAAI,CAACiB,YAAY,KAAK1K,SAAS;AACxC;AACA,SAAS6K,2BAA2BA,CAACpB,IAAI,EAAE;EACzC,OAAOA,IAAI,CAACxwB,UAAU,KAAK+mB,SAAS;AACtC;AACA,SAASgM,WAAWA,CAAC/B,MAAM,EAAE;EAC3B,QAAQA,MAAM;IACZ,KAAKlzB,aAAa,CAACq1B,SAAS;IAC5B,KAAKr1B,aAAa,CAACs1B,SAAS;IAC5B,KAAKt1B,aAAa,CAAC60B,IAAI;MACrB,OAAOvZ,WAAW,CAAC0H,eAAe;IACpC,KAAKhjB,aAAa,CAACu1B,QAAQ;IAC3B,KAAKv1B,aAAa,CAACw1B,UAAU;IAC7B;MACE,OAAOla,WAAW,CAACwH,MAAM;EAC7B;AACF;AAEA,MAAM2S,SAAS,CAAC;EACdhG,KAAK;EACLhqB,GAAG;EACHvH,WAAWA,CAACuxB,KAAK,EAAEhqB,GAAG,EAAE;IACtB,IAAI,CAACgqB,KAAK,GAAGA,KAAK;IAClB,IAAI,CAAChqB,GAAG,GAAGA,GAAG;EAChB;EACAiwB,UAAUA,CAACC,cAAc,EAAE;IACzB,OAAO,IAAIC,kBAAkB,CAACD,cAAc,GAAG,IAAI,CAAClG,KAAK,EAAEkG,cAAc,GAAG,IAAI,CAAClwB,GAAG,CAAC;EACvF;AACF;AACA,MAAMowB,GAAG,CAAC;EACRtG,IAAI;EACJjmB,UAAU;EACVpL,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAE;IAC5B,IAAI,CAACimB,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACjmB,UAAU,GAAGA,UAAU;EAC9B;EACAjO,QAAQA,CAAA,EAAG;IACT,OAAO,KAAK;EACd;AACF;AACA,MAAMy6B,WAAW,SAASD,GAAG,CAAC;EAC5BE,QAAQ;EACR73B,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAEysB,QAAQ,EAAE;IACtC,KAAK,CAACxG,IAAI,EAAEjmB,UAAU,CAAC;IACvB,IAAI,CAACysB,QAAQ,GAAGA,QAAQ;EAC1B;AACF;AACA,IAAIC,WAAW,GAAG,MAAMC,SAAS,SAASJ,GAAG,CAAC;EAC5C30B,KAAKA,CAACJ,OAAO,EAAES,OAAO,GAAG,IAAI,EAAE,CAAC;AAClC,CAAC;AACD,MAAM20B,gBAAgB,SAASL,GAAG,CAAC;EACjC30B,KAAKA,CAACJ,OAAO,EAAES,OAAO,GAAG,IAAI,EAAE;IAC7B,OAAOT,OAAO,CAACq1B,qBAAqB,CAAC,IAAI,EAAE50B,OAAO,CAAC;EACrD;AACF;AACA,MAAM60B,YAAY,SAASF,gBAAgB,CAAC;EAC1Ch1B,KAAKA,CAACJ,OAAO,EAAES,OAAO,GAAG,IAAI,EAAE;IAC7B,OAAOT,OAAO,CAACu1B,iBAAiB,GAAG,IAAI,EAAE90B,OAAO,CAAC;EACnD;AACF;AACA,MAAM+0B,KAAK,SAAST,GAAG,CAAC;EACtB5mB,WAAW;EACX/Q,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAE2F,WAAW,EAAE;IACzC,KAAK,CAACsgB,IAAI,EAAEjmB,UAAU,CAAC;IACvB,IAAI,CAAC2F,WAAW,GAAGA,WAAW;EAChC;EACA/N,KAAKA,CAACJ,OAAO,EAAES,OAAO,GAAG,IAAI,EAAE;IAC7B,OAAOT,OAAO,CAACy1B,UAAU,CAAC,IAAI,EAAEh1B,OAAO,CAAC;EAC1C;AACF;AACA,MAAMi1B,WAAW,SAASX,GAAG,CAAC;EAC5BnkB,SAAS;EACT+kB,OAAO;EACPC,QAAQ;EACRx4B,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAEoI,SAAS,EAAE+kB,OAAO,EAAEC,QAAQ,EAAE;IAC1D,KAAK,CAACnH,IAAI,EAAEjmB,UAAU,CAAC;IACvB,IAAI,CAACoI,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAAC+kB,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;EAC1B;EACAx1B,KAAKA,CAACJ,OAAO,EAAES,OAAO,GAAG,IAAI,EAAE;IAC7B,OAAOT,OAAO,CAAC61B,gBAAgB,CAAC,IAAI,EAAEp1B,OAAO,CAAC;EAChD;AACF;AACA,MAAMq1B,YAAY,SAASd,WAAW,CAAC;EACrC7nB,QAAQ;EACR/S,IAAI;EACJgD,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAEysB,QAAQ,EAAE9nB,QAAQ,EAAE/S,IAAI,EAAE;IACtD,KAAK,CAACq0B,IAAI,EAAEjmB,UAAU,EAAEysB,QAAQ,CAAC;IACjC,IAAI,CAAC9nB,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC/S,IAAI,GAAGA,IAAI;EAClB;EACAgG,KAAKA,CAACJ,OAAO,EAAES,OAAO,GAAG,IAAI,EAAE;IAC7B,OAAOT,OAAO,CAAC+1B,iBAAiB,CAAC,IAAI,EAAEt1B,OAAO,CAAC;EACjD;AACF;AACA,MAAMu1B,gBAAgB,SAAShB,WAAW,CAAC;EACzC7nB,QAAQ;EACR/S,IAAI;EACJgD,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAEysB,QAAQ,EAAE9nB,QAAQ,EAAE/S,IAAI,EAAE;IACtD,KAAK,CAACq0B,IAAI,EAAEjmB,UAAU,EAAEysB,QAAQ,CAAC;IACjC,IAAI,CAAC9nB,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC/S,IAAI,GAAGA,IAAI;EAClB;EACAgG,KAAKA,CAACJ,OAAO,EAAES,OAAO,GAAG,IAAI,EAAE;IAC7B,OAAOT,OAAO,CAACi2B,qBAAqB,CAAC,IAAI,EAAEx1B,OAAO,CAAC;EACrD;AACF;AACA,MAAMy1B,SAAS,SAASnB,GAAG,CAAC;EAC1B5nB,QAAQ;EACRxE,GAAG;EACHvL,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAE2E,QAAQ,EAAExE,GAAG,EAAE;IAC3C,KAAK,CAAC8lB,IAAI,EAAEjmB,UAAU,CAAC;IACvB,IAAI,CAAC2E,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACxE,GAAG,GAAGA,GAAG;EAChB;EACAvI,KAAKA,CAACJ,OAAO,EAAES,OAAO,GAAG,IAAI,EAAE;IAC7B,OAAOT,OAAO,CAACm2B,cAAc,CAAC,IAAI,EAAE11B,OAAO,CAAC;EAC9C;AACF;AACA,MAAM21B,aAAa,SAASrB,GAAG,CAAC;EAC9B5nB,QAAQ;EACRxE,GAAG;EACHvL,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAE2E,QAAQ,EAAExE,GAAG,EAAE;IAC3C,KAAK,CAAC8lB,IAAI,EAAEjmB,UAAU,CAAC;IACvB,IAAI,CAAC2E,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACxE,GAAG,GAAGA,GAAG;EAChB;EACAvI,KAAKA,CAACJ,OAAO,EAAES,OAAO,GAAG,IAAI,EAAE;IAC7B,OAAOT,OAAO,CAACq2B,kBAAkB,CAAC,IAAI,EAAE51B,OAAO,CAAC;EAClD;AACF;AACA,IAAI61B,eAAe;AACnB,CAAC,UAAUA,eAAe,EAAE;EAC1BA,eAAe,CAACA,eAAe,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,GAAG,kBAAkB;EAC7EA,eAAe,CAACA,eAAe,CAAC,oBAAoB,CAAC,GAAG,CAAC,CAAC,GAAG,oBAAoB;AACnF,CAAC,EAAEA,eAAe,KAAKA,eAAe,GAAG,CAAC,CAAC,CAAC,CAAC;AAC7C,MAAMC,WAAW,SAASvB,WAAW,CAAC;EACpC5d,GAAG;EACHhd,IAAI;EACJ8S,IAAI;EACJ7L,IAAI;EACJjE,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAE4O,GAAG,EAAEhd,IAAI,EAAE8S,IAAI,EAAE7L,IAAI,EAAE4zB,QAAQ,EAAE;IAC7D,KAAK,CAACxG,IAAI,EAAEjmB,UAAU,EAAEysB,QAAQ,CAAC;IACjC,IAAI,CAAC7d,GAAG,GAAGA,GAAG;IACd,IAAI,CAAChd,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC8S,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC7L,IAAI,GAAGA,IAAI;EAClB;EACAjB,KAAKA,CAACJ,OAAO,EAAES,OAAO,GAAG,IAAI,EAAE;IAC7B,OAAOT,OAAO,CAACw2B,SAAS,CAAC,IAAI,EAAE/1B,OAAO,CAAC;EACzC;AACF;AACA,MAAMg2B,gBAAgB,SAAS1B,GAAG,CAAC;EACjC16B,KAAK;EACL+C,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAEnO,KAAK,EAAE;IACnC,KAAK,CAACo0B,IAAI,EAAEjmB,UAAU,CAAC;IACvB,IAAI,CAACnO,KAAK,GAAGA,KAAK;EACpB;EACA+F,KAAKA,CAACJ,OAAO,EAAES,OAAO,GAAG,IAAI,EAAE;IAC7B,OAAOT,OAAO,CAAC02B,qBAAqB,CAAC,IAAI,EAAEj2B,OAAO,CAAC;EACrD;AACF;AACA,MAAMk2B,YAAY,SAAS5B,GAAG,CAAC;EAC7B5mB,WAAW;EACX/Q,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAE2F,WAAW,EAAE;IACzC,KAAK,CAACsgB,IAAI,EAAEjmB,UAAU,CAAC;IACvB,IAAI,CAAC2F,WAAW,GAAGA,WAAW;EAChC;EACA/N,KAAKA,CAACJ,OAAO,EAAES,OAAO,GAAG,IAAI,EAAE;IAC7B,OAAOT,OAAO,CAAC42B,iBAAiB,CAAC,IAAI,EAAEn2B,OAAO,CAAC;EACjD;AACF;AACA,MAAMo2B,UAAU,SAAS9B,GAAG,CAAC;EAC3B9zB,IAAI;EACJsV,MAAM;EACNnZ,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAEvH,IAAI,EAAEsV,MAAM,EAAE;IAC1C,KAAK,CAACkY,IAAI,EAAEjmB,UAAU,CAAC;IACvB,IAAI,CAACvH,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACsV,MAAM,GAAGA,MAAM;EACtB;EACAnW,KAAKA,CAACJ,OAAO,EAAES,OAAO,GAAG,IAAI,EAAE;IAC7B,OAAOT,OAAO,CAAC82B,eAAe,CAAC,IAAI,EAAEr2B,OAAO,CAAC;EAC/C;AACF;AACA,IAAIs2B,eAAe,GAAG,MAAMC,aAAa,SAASjC,GAAG,CAAC;EACpDkC,OAAO;EACP9oB,WAAW;EACX/Q,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAEyuB,OAAO,EAAE9oB,WAAW,EAAE;IAClD,KAAK,CAACsgB,IAAI,EAAEjmB,UAAU,CAAC;IACvB,IAAI,CAACyuB,OAAO,GAAGA,OAAO;IACtB,IAAI,CAAC9oB,WAAW,GAAGA,WAAW;EAChC;EACA/N,KAAKA,CAACJ,OAAO,EAAES,OAAO,GAAG,IAAI,EAAE;IAC7B,OAAOT,OAAO,CAACk3B,kBAAkB,CAAC,IAAI,EAAEz2B,OAAO,CAAC;EAClD;AACF,CAAC;AACD,MAAM02B,MAAM,SAASpC,GAAG,CAAC;EACvBqC,SAAS;EACTC,IAAI;EACJC,KAAK;EACLl6B,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAE4uB,SAAS,EAAEC,IAAI,EAAEC,KAAK,EAAE;IACpD,KAAK,CAAC7I,IAAI,EAAEjmB,UAAU,CAAC;IACvB,IAAI,CAAC4uB,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,KAAK,GAAGA,KAAK;EACpB;EACAl3B,KAAKA,CAACJ,OAAO,EAAES,OAAO,GAAG,IAAI,EAAE;IAC7B,OAAOT,OAAO,CAACu3B,WAAW,CAAC,IAAI,EAAE92B,OAAO,CAAC;EAC3C;EACA,OAAO+2B,qBAAqBA,CAAC9kB,EAAE,EAAE;IAC/B,OAAOA,EAAE,KAAK,GAAG,IAAIA,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,KAAK,IAAIA,EAAE,KAAK,KAAK,IAAIA,EAAE,KAAK,KAAK,IAAIA,EAAE,KAAK,KAAK;EAC9J;AACF;AACA,MAAM+kB,KAAK,SAASN,MAAM,CAAC;EACzBjlB,QAAQ;EACRxF,IAAI;EACJ2qB,IAAI,GAAG,IAAI;EACXC,KAAK,GAAG,IAAI;EACZF,SAAS,GAAG,IAAI;EAChB,OAAOM,WAAWA,CAACjJ,IAAI,EAAEjmB,UAAU,EAAEkE,IAAI,EAAE;IACzC,OAAO,IAAI+qB,KAAK,CAAChJ,IAAI,EAAEjmB,UAAU,EAAE,GAAG,EAAEkE,IAAI,EAAE,GAAG,EAAE,IAAI+pB,gBAAgB,CAAChI,IAAI,EAAEjmB,UAAU,EAAE,CAAC,CAAC,EAAEkE,IAAI,CAAC;EACrG;EACA,OAAOirB,UAAUA,CAAClJ,IAAI,EAAEjmB,UAAU,EAAEkE,IAAI,EAAE;IACxC,OAAO,IAAI+qB,KAAK,CAAChJ,IAAI,EAAEjmB,UAAU,EAAE,GAAG,EAAEkE,IAAI,EAAE,GAAG,EAAEA,IAAI,EAAE,IAAI+pB,gBAAgB,CAAChI,IAAI,EAAEjmB,UAAU,EAAE,CAAC,CAAC,CAAC;EACrG;EACApL,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAE0J,QAAQ,EAAExF,IAAI,EAAEkrB,QAAQ,EAAEC,UAAU,EAAEC,WAAW,EAAE;IAC/E,KAAK,CAACrJ,IAAI,EAAEjmB,UAAU,EAAEovB,QAAQ,EAAEC,UAAU,EAAEC,WAAW,CAAC;IAC1D,IAAI,CAAC5lB,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACxF,IAAI,GAAGA,IAAI;EAClB;EACAtM,KAAKA,CAACJ,OAAO,EAAES,OAAO,GAAG,IAAI,EAAE;IAC7B,IAAIT,OAAO,CAAC+3B,UAAU,KAAK5P,SAAS,EAAE;MACpC,OAAOnoB,OAAO,CAAC+3B,UAAU,CAAC,IAAI,EAAEt3B,OAAO,CAAC;IAC1C;IACA,OAAOT,OAAO,CAACu3B,WAAW,CAAC,IAAI,EAAE92B,OAAO,CAAC;EAC3C;AACF;AACA,MAAMu3B,SAAS,SAASjD,GAAG,CAAC;EAC1B3zB,UAAU;EACVhE,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAEpH,UAAU,EAAE;IACxC,KAAK,CAACqtB,IAAI,EAAEjmB,UAAU,CAAC;IACvB,IAAI,CAACpH,UAAU,GAAGA,UAAU;EAC9B;EACAhB,KAAKA,CAACJ,OAAO,EAAES,OAAO,GAAG,IAAI,EAAE;IAC7B,OAAOT,OAAO,CAACi4B,cAAc,CAAC,IAAI,EAAEx3B,OAAO,CAAC;EAC9C;AACF;AACA,MAAMy3B,gBAAgB,SAASnD,GAAG,CAAC;EACjC3zB,UAAU;EACVhE,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAEpH,UAAU,EAAE;IACxC,KAAK,CAACqtB,IAAI,EAAEjmB,UAAU,CAAC;IACvB,IAAI,CAACpH,UAAU,GAAGA,UAAU;EAC9B;EACAhB,KAAKA,CAACJ,OAAO,EAAES,OAAO,GAAG,IAAI,EAAE;IAC7B,OAAOT,OAAO,CAACm4B,qBAAqB,CAAC,IAAI,EAAE13B,OAAO,CAAC;EACrD;AACF;AACA,MAAM23B,cAAc,SAASrD,GAAG,CAAC;EAC/B3zB,UAAU;EACVhE,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAEpH,UAAU,EAAE;IACxC,KAAK,CAACqtB,IAAI,EAAEjmB,UAAU,CAAC;IACvB,IAAI,CAACpH,UAAU,GAAGA,UAAU;EAC9B;EACAhB,KAAKA,CAACJ,OAAO,EAAES,OAAO,GAAG,IAAI,EAAE;IAC7B,OAAOT,OAAO,CAACq4B,mBAAmB,CAAC,IAAI,EAAE53B,OAAO,CAAC;EACnD;AACF;AACA,MAAM63B,aAAa,SAASvD,GAAG,CAAC;EAC9B3zB,UAAU;EACVhE,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAEpH,UAAU,EAAE;IACxC,KAAK,CAACqtB,IAAI,EAAEjmB,UAAU,CAAC;IACvB,IAAI,CAACpH,UAAU,GAAGA,UAAU;EAC9B;EACAhB,KAAKA,CAACJ,OAAO,EAAES,OAAO,GAAG,IAAI,EAAE;IAC7B,OAAOT,OAAO,CAACu4B,kBAAkB,CAAC,IAAI,EAAE93B,OAAO,CAAC;EAClD;AACF;AACA,MAAM+3B,IAAI,SAASzD,GAAG,CAAC;EACrB5nB,QAAQ;EACRD,IAAI;EACJurB,YAAY;EACZr7B,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAE2E,QAAQ,EAAED,IAAI,EAAEurB,YAAY,EAAE;IAC1D,KAAK,CAAChK,IAAI,EAAEjmB,UAAU,CAAC;IACvB,IAAI,CAAC2E,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACD,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACurB,YAAY,GAAGA,YAAY;EAClC;EACAr4B,KAAKA,CAACJ,OAAO,EAAES,OAAO,GAAG,IAAI,EAAE;IAC7B,OAAOT,OAAO,CAAC04B,SAAS,CAAC,IAAI,EAAEj4B,OAAO,CAAC;EACzC;AACF;AACA,MAAMk4B,QAAQ,SAAS5D,GAAG,CAAC;EACzB5nB,QAAQ;EACRD,IAAI;EACJurB,YAAY;EACZr7B,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAE2E,QAAQ,EAAED,IAAI,EAAEurB,YAAY,EAAE;IAC1D,KAAK,CAAChK,IAAI,EAAEjmB,UAAU,CAAC;IACvB,IAAI,CAAC2E,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACD,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACurB,YAAY,GAAGA,YAAY;EAClC;EACAr4B,KAAKA,CAACJ,OAAO,EAAES,OAAO,GAAG,IAAI,EAAE;IAC7B,OAAOT,OAAO,CAAC44B,aAAa,CAAC,IAAI,EAAEn4B,OAAO,CAAC;EAC7C;AACF;AACA,MAAMo4B,qBAAqB,SAAS9D,GAAG,CAAC;EACtCh8B,GAAG;EACHwU,QAAQ;EACRnQ,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAEzP,GAAG,EAAEwU,QAAQ,EAAE;IAC3C,KAAK,CAACkhB,IAAI,EAAEjmB,UAAU,CAAC;IACvB,IAAI,CAACzP,GAAG,GAAGA,GAAG;IACd,IAAI,CAACwU,QAAQ,GAAGA,QAAQ;EAC1B;EACAnN,KAAKA,CAACJ,OAAO,EAAES,OAAO,EAAE;IACtB,OAAOT,OAAO,CAAC84B,0BAA0B,CAAC,IAAI,EAAEr4B,OAAO,CAAC;EAC1D;AACF;AACA,MAAMs4B,eAAe,SAAShE,GAAG,CAAC;EAChC7mB,QAAQ;EACRC,WAAW;EACX/Q,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAE0F,QAAQ,EAAEC,WAAW,EAAE;IACnD,KAAK,CAACsgB,IAAI,EAAEjmB,UAAU,CAAC;IACvB,IAAI,CAAC0F,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,WAAW,GAAGA,WAAW;EAChC;EACA/N,KAAKA,CAACJ,OAAO,EAAES,OAAO,EAAE;IACtB,OAAOT,OAAO,CAACg5B,oBAAoB,CAAC,IAAI,EAAEv4B,OAAO,CAAC;EACpD;AACF;AACA,MAAMw4B,sBAAsB,SAASlE,GAAG,CAAC;EACvCv0B,IAAI;EACJpD,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAEhI,IAAI,EAAE;IAClC,KAAK,CAACiuB,IAAI,EAAEjmB,UAAU,CAAC;IACvB,IAAI,CAAChI,IAAI,GAAGA,IAAI;EAClB;EACAJ,KAAKA,CAACJ,OAAO,EAAES,OAAO,EAAE;IACtB,OAAOT,OAAO,CAACk5B,2BAA2B,CAAC,IAAI,EAAEz4B,OAAO,CAAC;EAC3D;AACF;AACA,MAAM04B,uBAAuB,SAASpE,GAAG,CAAC;EACxC3zB,UAAU;EACVhE,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAEpH,UAAU,EAAE;IACxC,KAAK,CAACqtB,IAAI,EAAEjmB,UAAU,CAAC;IACvB,IAAI,CAACpH,UAAU,GAAGA,UAAU;EAC9B;EACAhB,KAAKA,CAACJ,OAAO,EAAES,OAAO,EAAE;IACtB,OAAOT,OAAO,CAACo5B,4BAA4B,CAAC,IAAI,EAAE34B,OAAO,CAAC;EAC5D;AACF;AACA,MAAM44B,wBAAwB,SAAStE,GAAG,CAAC;EACzCnnB,IAAI;EACJC,KAAK;EACLzQ,WAAWA,CAACqxB,IAAI,EAAEjmB,UAAU,EAAEoF,IAAI,EAAEC,KAAK,EAAE;IACzC,KAAK,CAAC4gB,IAAI,EAAEjmB,UAAU,CAAC;IACvB,IAAI,CAACoF,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,KAAK,GAAGA,KAAK;EACpB;EACAzN,KAAKA,CAACJ,OAAO,EAAES,OAAO,EAAE;IACtB,OAAOT,OAAO,CAAC8N,6BAA6B,CAAC,IAAI,EAAErN,OAAO,CAAC;EAC7D;AACF;AACA,MAAMq0B,kBAAkB,CAAC;EACvBnG,KAAK;EACLhqB,GAAG;EACHvH,WAAWA,CAACuxB,KAAK,EAAEhqB,GAAG,EAAE;IACtB,IAAI,CAACgqB,KAAK,GAAGA,KAAK;IAClB,IAAI,CAAChqB,GAAG,GAAGA,GAAG;EAChB;AACF;AACA,MAAM20B,aAAa,SAASvE,GAAG,CAAC;EAC9Btf,GAAG;EACHiZ,MAAM;EACN6K,QAAQ;EACRC,MAAM;EACNp8B,WAAWA,CAACqY,GAAG,EAAEiZ,MAAM,EAAE6K,QAAQ,EAAE1E,cAAc,EAAE2E,MAAM,EAAE;IACzD,KAAK,CAAC,IAAI7E,SAAS,CAAC,CAAC,EAAEjG,MAAM,KAAK,IAAI,GAAG,CAAC,GAAGA,MAAM,CAACp2B,MAAM,CAAC,EAAE,IAAIw8B,kBAAkB,CAACD,cAAc,EAAEnG,MAAM,KAAK,IAAI,GAAGmG,cAAc,GAAGA,cAAc,GAAGnG,MAAM,CAACp2B,MAAM,CAAC,CAAC;IACvK,IAAI,CAACmd,GAAG,GAAGA,GAAG;IACd,IAAI,CAACiZ,MAAM,GAAGA,MAAM;IACpB,IAAI,CAAC6K,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,MAAM,GAAGA,MAAM;EACtB;EACAp5B,KAAKA,CAACJ,OAAO,EAAES,OAAO,GAAG,IAAI,EAAE;IAC7B,IAAIT,OAAO,CAACy5B,kBAAkB,EAAE;MAC9B,OAAOz5B,OAAO,CAACy5B,kBAAkB,CAAC,IAAI,EAAEh5B,OAAO,CAAC;IAClD;IACA,OAAO,IAAI,CAACgV,GAAG,CAACrV,KAAK,CAACJ,OAAO,EAAES,OAAO,CAAC;EACzC;EACAlG,QAAQA,CAAA,EAAG;IACT,OAAO,GAAG,IAAI,CAACm0B,MAAM,OAAO,IAAI,CAAC6K,QAAQ,EAAE;EAC7C;AACF;AACA,MAAMG,eAAe,CAAC;EACpBlxB,UAAU;EACVG,GAAG;EACHtO,KAAK;EACL+C,WAAWA,CAACoL,UAAU,EAAEG,GAAG,EAAEtO,KAAK,EAAE;IAClC,IAAI,CAACmO,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACG,GAAG,GAAGA,GAAG;IACd,IAAI,CAACtO,KAAK,GAAGA,KAAK;EACpB;AACF;AACA,MAAMs/B,iBAAiB,CAAC;EACtBnxB,UAAU;EACVG,GAAG;EACHtO,KAAK;EACL+C,WAAWA,CAACoL,UAAU,EAAEG,GAAG,EAAEtO,KAAK,EAAE;IAClC,IAAI,CAACmO,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACG,GAAG,GAAGA,GAAG;IACd,IAAI,CAACtO,KAAK,GAAGA,KAAK;EACpB;AACF;AACA,MAAMmb,mBAAmB,CAAC;EACxBpV,KAAKA,CAACqV,GAAG,EAAEhV,OAAO,EAAE;IAClBgV,GAAG,CAACrV,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC;EAC1B;EACAs3B,UAAUA,CAACtiB,GAAG,EAAEhV,OAAO,EAAE;IACvB,IAAI,CAACL,KAAK,CAACqV,GAAG,CAAC/I,IAAI,EAAEjM,OAAO,CAAC;EAC/B;EACA82B,WAAWA,CAAC9hB,GAAG,EAAEhV,OAAO,EAAE;IACxB,IAAI,CAACL,KAAK,CAACqV,GAAG,CAAC4hB,IAAI,EAAE52B,OAAO,CAAC;IAC7B,IAAI,CAACL,KAAK,CAACqV,GAAG,CAAC6hB,KAAK,EAAE72B,OAAO,CAAC;EAChC;EACAg1B,UAAUA,CAAChgB,GAAG,EAAEhV,OAAO,EAAE;IACvB,IAAI,CAACm5B,QAAQ,CAACnkB,GAAG,CAACtH,WAAW,EAAE1N,OAAO,CAAC;EACzC;EACAo1B,gBAAgBA,CAACpgB,GAAG,EAAEhV,OAAO,EAAE;IAC7B,IAAI,CAACL,KAAK,CAACqV,GAAG,CAAC7E,SAAS,EAAEnQ,OAAO,CAAC;IAClC,IAAI,CAACL,KAAK,CAACqV,GAAG,CAACkgB,OAAO,EAAEl1B,OAAO,CAAC;IAChC,IAAI,CAACL,KAAK,CAACqV,GAAG,CAACmgB,QAAQ,EAAEn1B,OAAO,CAAC;EACnC;EACA+1B,SAASA,CAAC/gB,GAAG,EAAEhV,OAAO,EAAE;IACtB,IAAI,CAACL,KAAK,CAACqV,GAAG,CAAC2B,GAAG,EAAE3W,OAAO,CAAC;IAC5B,IAAI,CAACm5B,QAAQ,CAACnkB,GAAG,CAACvI,IAAI,EAAEzM,OAAO,CAAC;EAClC;EACA40B,qBAAqBA,CAAC5f,GAAG,EAAEhV,OAAO,EAAE,CAAC;EACrC80B,iBAAiBA,CAAC9f,GAAG,EAAEhV,OAAO,EAAE,CAAC;EACjCy2B,kBAAkBA,CAACzhB,GAAG,EAAEhV,OAAO,EAAE;IAC/B,IAAI,CAACm5B,QAAQ,CAACnkB,GAAG,CAACtH,WAAW,EAAE1N,OAAO,CAAC;EACzC;EACA01B,cAAcA,CAAC1gB,GAAG,EAAEhV,OAAO,EAAE;IAC3B,IAAI,CAACL,KAAK,CAACqV,GAAG,CAACtI,QAAQ,EAAE1M,OAAO,CAAC;IACjC,IAAI,CAACL,KAAK,CAACqV,GAAG,CAAC9M,GAAG,EAAElI,OAAO,CAAC;EAC9B;EACAm2B,iBAAiBA,CAACnhB,GAAG,EAAEhV,OAAO,EAAE;IAC9B,IAAI,CAACm5B,QAAQ,CAACnkB,GAAG,CAACtH,WAAW,EAAE1N,OAAO,CAAC;EACzC;EACAq2B,eAAeA,CAACrhB,GAAG,EAAEhV,OAAO,EAAE;IAC5B,IAAI,CAACm5B,QAAQ,CAACnkB,GAAG,CAACc,MAAM,EAAE9V,OAAO,CAAC;EACpC;EACAi2B,qBAAqBA,CAACjhB,GAAG,EAAEhV,OAAO,EAAE,CAAC;EACrCw3B,cAAcA,CAACxiB,GAAG,EAAEhV,OAAO,EAAE;IAC3B,IAAI,CAACL,KAAK,CAACqV,GAAG,CAACrU,UAAU,EAAEX,OAAO,CAAC;EACrC;EACA03B,qBAAqBA,CAAC1iB,GAAG,EAAEhV,OAAO,EAAE;IAClC,IAAI,CAACL,KAAK,CAACqV,GAAG,CAACrU,UAAU,EAAEX,OAAO,CAAC;EACrC;EACA43B,mBAAmBA,CAAC5iB,GAAG,EAAEhV,OAAO,EAAE;IAChC,IAAI,CAACL,KAAK,CAACqV,GAAG,CAACrU,UAAU,EAAEX,OAAO,CAAC;EACrC;EACA83B,kBAAkBA,CAAC9iB,GAAG,EAAEhV,OAAO,EAAE;IAC/B,IAAI,CAACL,KAAK,CAACqV,GAAG,CAACrU,UAAU,EAAEX,OAAO,CAAC;EACrC;EACAs1B,iBAAiBA,CAACtgB,GAAG,EAAEhV,OAAO,EAAE;IAC9B,IAAI,CAACL,KAAK,CAACqV,GAAG,CAACtI,QAAQ,EAAE1M,OAAO,CAAC;EACnC;EACAw1B,qBAAqBA,CAACxgB,GAAG,EAAEhV,OAAO,EAAE;IAClC,IAAI,CAACL,KAAK,CAACqV,GAAG,CAACtI,QAAQ,EAAE1M,OAAO,CAAC;EACnC;EACA41B,kBAAkBA,CAAC5gB,GAAG,EAAEhV,OAAO,EAAE;IAC/B,IAAI,CAACL,KAAK,CAACqV,GAAG,CAACtI,QAAQ,EAAE1M,OAAO,CAAC;IACjC,IAAI,CAACL,KAAK,CAACqV,GAAG,CAAC9M,GAAG,EAAElI,OAAO,CAAC;EAC9B;EACAi4B,SAASA,CAACjjB,GAAG,EAAEhV,OAAO,EAAE;IACtB,IAAI,CAACL,KAAK,CAACqV,GAAG,CAACtI,QAAQ,EAAE1M,OAAO,CAAC;IACjC,IAAI,CAACm5B,QAAQ,CAACnkB,GAAG,CAACvI,IAAI,EAAEzM,OAAO,CAAC;EAClC;EACAm4B,aAAaA,CAACnjB,GAAG,EAAEhV,OAAO,EAAE;IAC1B,IAAI,CAACL,KAAK,CAACqV,GAAG,CAACtI,QAAQ,EAAE1M,OAAO,CAAC;IACjC,IAAI,CAACm5B,QAAQ,CAACnkB,GAAG,CAACvI,IAAI,EAAEzM,OAAO,CAAC;EAClC;EACAu4B,oBAAoBA,CAACvjB,GAAG,EAAEhV,OAAO,EAAE;IACjC,KAAK,IAAI/G,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+b,GAAG,CAACvH,QAAQ,CAAC5V,MAAM,EAAEoB,CAAC,EAAE,EAAE;MAC5C,IAAI,CAAC0G,KAAK,CAACqV,GAAG,CAACvH,QAAQ,CAACxU,CAAC,CAAC,EAAE+G,OAAO,CAAC;MACpC,MAAMW,UAAU,GAAG1H,CAAC,GAAG+b,GAAG,CAACtH,WAAW,CAAC7V,MAAM,GAAGmd,GAAG,CAACtH,WAAW,CAACzU,CAAC,CAAC,GAAG,IAAI;MACzE,IAAI0H,UAAU,KAAK,IAAI,EAAE;QACvB,IAAI,CAAChB,KAAK,CAACgB,UAAU,EAAEX,OAAO,CAAC;MACjC;IACF;EACF;EACAy4B,2BAA2BA,CAACzjB,GAAG,EAAEhV,OAAO,EAAE,CAAC;EAC3Cq4B,0BAA0BA,CAACrjB,GAAG,EAAEhV,OAAO,EAAE;IACvC,IAAI,CAACL,KAAK,CAACqV,GAAG,CAAC1c,GAAG,EAAE0H,OAAO,CAAC;IAC5B,IAAI,CAACL,KAAK,CAACqV,GAAG,CAAClI,QAAQ,EAAE9M,OAAO,CAAC;EACnC;EACA24B,4BAA4BA,CAAC3jB,GAAG,EAAEhV,OAAO,EAAE;IACzC,IAAI,CAACL,KAAK,CAACqV,GAAG,CAACrU,UAAU,EAAEX,OAAO,CAAC;EACrC;EACAqN,6BAA6BA,CAAC2H,GAAG,EAAEhV,OAAO,EAAE,CAAC;EAC7Cm5B,QAAQA,CAACC,IAAI,EAAEp5B,OAAO,EAAE;IACtB,KAAK,MAAMgV,GAAG,IAAIokB,IAAI,EAAE;MACtB,IAAI,CAACz5B,KAAK,CAACqV,GAAG,EAAEhV,OAAO,CAAC;IAC1B;EACF;AACF;AACA,MAAMq5B,cAAc,CAAC;EACnB1/B,IAAI;EACJgH,UAAU;EACVC,IAAI;EACJmH,UAAU;EACVuxB,OAAO;EACPC,SAAS;EACTC,SAAS;EACTC,iBAAiB;EACjBC,WAAW;EACX/8B,WAAWA,CAAChD,IAAI,EAAEgH,UAAU,EAAEC,IAAI,EAAEmH,UAAU,EAAEuxB,OAAO,EAAEC,SAAS,EAAE;IAClE,IAAI,CAAC5/B,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACgH,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACmH,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACuxB,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,SAAS,GAAG,IAAI,CAAC54B,IAAI,KAAK+4B,kBAAkB,CAACC,YAAY;IAC9D,IAAI,CAACH,iBAAiB,GAAG,IAAI,CAAC74B,IAAI,KAAK+4B,kBAAkB,CAACE,gBAAgB;IAC1E,IAAI,CAACH,WAAW,GAAG,IAAI,CAAC94B,IAAI,KAAK+4B,kBAAkB,CAACG,SAAS;EAC/D;AACF;AACA,IAAIH,kBAAkB;AACtB,CAAC,UAAUA,kBAAkB,EAAE;EAC7BA,kBAAkB,CAACA,kBAAkB,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;EACjEA,kBAAkB,CAACA,kBAAkB,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,GAAG,cAAc;EAC3EA,kBAAkB,CAACA,kBAAkB,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,GAAG,kBAAkB;EACnFA,kBAAkB,CAACA,kBAAkB,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;EACjEA,kBAAkB,CAACA,kBAAkB,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;AACvE,CAAC,EAAEA,kBAAkB,KAAKA,kBAAkB,GAAG,CAAC,CAAC,CAAC,CAAC;AACnD,IAAII,eAAe;AACnB,CAAC,UAAUA,eAAe,EAAE;EAC1BA,eAAe,CAACA,eAAe,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;EAC3DA,eAAe,CAACA,eAAe,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC,GAAG,iBAAiB;EAC3EA,eAAe,CAACA,eAAe,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;EACzDA,eAAe,CAACA,eAAe,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;AACjE,CAAC,EAAEA,eAAe,KAAKA,eAAe,GAAG,CAAC,CAAC,CAAC,CAAC;AAC7C,MAAMC,WAAW,CAAC;EAChBrgC,IAAI;EACJsgC,aAAa;EACbr5B,IAAI;EACJ2uB,OAAO;EACPxnB,UAAU;EACVmyB,WAAW;EACXZ,OAAO;EACP38B,WAAWA,CAAChD,IAAI,EAAEsgC,aAAa,EAAEr5B,IAAI,EAAE2uB,OAAO,EAAExnB,UAAU,EAAEmyB,WAAW,EAAEZ,OAAO,EAAE;IAChF,IAAI,CAAC3/B,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACsgC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACr5B,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC2uB,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACxnB,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACmyB,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACZ,OAAO,GAAGA,OAAO;EACxB;AACF;AACA,MAAMa,cAAc,CAAC;EACnBxgC,IAAI;EACJC,KAAK;EACLmO,UAAU;EACVuxB,OAAO;EACPC,SAAS;EACT58B,WAAWA,CAAChD,IAAI,EAAEC,KAAK,EAAEmO,UAAU,EAAEuxB,OAAO,EAAEC,SAAS,EAAE;IACvD,IAAI,CAAC5/B,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACmO,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACuxB,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,SAAS,GAAGA,SAAS;EAC5B;AACF;AACA,IAAIa,WAAW;AACf,CAAC,UAAUA,WAAW,EAAE;EACtBA,WAAW,CAACA,WAAW,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EACrDA,WAAW,CAACA,WAAW,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;EACvDA,WAAW,CAACA,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;EAC/CA,WAAW,CAACA,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;EAC/CA,WAAW,CAACA,WAAW,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC,GAAG,iBAAiB;EACnEA,WAAW,CAACA,WAAW,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;EACjDA,WAAW,CAACA,WAAW,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;AACzD,CAAC,EAAEA,WAAW,KAAKA,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC;AACrC,MAAMC,oBAAoB,CAAC;EACzB1gC,IAAI;EACJiH,IAAI;EACJ05B,eAAe;EACf1gC,KAAK;EACL2gC,IAAI;EACJxyB,UAAU;EACVuxB,OAAO;EACPC,SAAS;EACT58B,WAAWA,CAAChD,IAAI,EAAEiH,IAAI,EAAE05B,eAAe,EAAE1gC,KAAK,EAAE2gC,IAAI,EAAExyB,UAAU,EAAEuxB,OAAO,EAAEC,SAAS,EAAE;IACpF,IAAI,CAAC5/B,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACiH,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC05B,eAAe,GAAGA,eAAe;IACtC,IAAI,CAAC1gC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAAC2gC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACxyB,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACuxB,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,SAAS,GAAGA,SAAS;EAC5B;AACF;AAEA,IAAIiB,cAAc;AAClB,CAAC,UAAUA,cAAc,EAAE;EACzBA,cAAc,CAACA,cAAc,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EAC3DA,cAAc,CAACA,cAAc,CAAC,oBAAoB,CAAC,GAAG,CAAC,CAAC,GAAG,oBAAoB;EAC/EA,cAAc,CAACA,cAAc,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,GAAG,eAAe;AACvE,CAAC,EAAEA,cAAc,KAAKA,cAAc,GAAG,CAAC,CAAC,CAAC,CAAC;AAC3C,SAASC,WAAWA,CAAC38B,WAAW,EAAE48B,KAAK,GAAG,IAAI,EAAE;EAC9C,IAAI58B,WAAW,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE;IACzB,OAAO,CAAC,IAAI,EAAEA,WAAW,CAAC;EAC5B;EACA,MAAM68B,UAAU,GAAG78B,WAAW,CAACwpB,OAAO,CAAC,GAAG,EAAE,CAAC,CAAC;EAC9C,IAAIqT,UAAU,KAAK,CAAC,CAAC,EAAE;IACrB,IAAID,KAAK,EAAE;MACT,MAAM,IAAIriC,KAAK,CAAC,uBAAuByF,WAAW,+BAA+B,CAAC;IACpF,CAAC,MAAM;MACL,OAAO,CAAC,IAAI,EAAEA,WAAW,CAAC;IAC5B;EACF;EACA,OAAO,CAACA,WAAW,CAACrF,KAAK,CAAC,CAAC,EAAEkiC,UAAU,CAAC,EAAE78B,WAAW,CAACrF,KAAK,CAACkiC,UAAU,GAAG,CAAC,CAAC,CAAC;AAC9E;AACA,SAASC,aAAaA,CAAC9jB,OAAO,EAAE;EAC9B,OAAO2jB,WAAW,CAAC3jB,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,cAAc;AACnD;AACA,SAAS+jB,WAAWA,CAAC/jB,OAAO,EAAE;EAC5B,OAAO2jB,WAAW,CAAC3jB,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,YAAY;AACjD;AACA,SAASgkB,YAAYA,CAAChkB,OAAO,EAAE;EAC7B,OAAO2jB,WAAW,CAAC3jB,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,aAAa;AAClD;AACA,SAASikB,WAAWA,CAACC,QAAQ,EAAE;EAC7B,OAAOA,QAAQ,KAAK,IAAI,GAAG,IAAI,GAAGP,WAAW,CAACO,QAAQ,CAAC,CAAC,CAAC,CAAC;AAC5D;AACA,SAASC,cAAcA,CAAC1iC,MAAM,EAAE2iC,SAAS,EAAE;EACzC,OAAO3iC,MAAM,GAAG,IAAIA,MAAM,IAAI2iC,SAAS,EAAE,GAAGA,SAAS;AACvD;AAEA,IAAIC,SAAS,GAAG,MAAMC,OAAO,CAAC;EAC5BxhC,KAAK;EACLmO,UAAU;EACVpL,WAAWA,CAAC/C,KAAK,EAAEmO,UAAU,EAAE;IAC7B,IAAI,CAACnO,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACmO,UAAU,GAAGA,UAAU;EAC9B;EACApI,KAAKA,CAAC07B,QAAQ,EAAE;IACd,MAAM,IAAIhjC,KAAK,CAAC,qCAAqC,CAAC;EACxD;AACF,CAAC;AACD,IAAIijC,MAAM,GAAG,MAAMC,IAAI,CAAC;EACtB3hC,KAAK;EACLmO,UAAU;EACVpL,WAAWA,CAAC/C,KAAK,EAAEmO,UAAU,EAAE;IAC7B,IAAI,CAACnO,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACmO,UAAU,GAAGA,UAAU;EAC9B;EACApI,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAACO,SAAS,CAAC,IAAI,CAAC;EAChC;AACF,CAAC;AACD,MAAM07B,SAAS,CAAC;EACd5hC,KAAK;EACLmO,UAAU;EACV6Y,IAAI;EACJjkB,WAAWA,CAAC/C,KAAK,EAAEmO,UAAU,EAAE6Y,IAAI,EAAE;IACnC,IAAI,CAAChnB,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACmO,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAC6Y,IAAI,GAAGA,IAAI;EAClB;EACAjhB,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAACk8B,cAAc,CAAC,IAAI,CAAC;EACrC;AACF;AACA,MAAMC,aAAa,CAAC;EAClB/hC,IAAI;EACJC,KAAK;EACLmO,UAAU;EACVuxB,OAAO;EACPC,SAAS;EACT3Y,IAAI;EACJjkB,WAAWA,CAAChD,IAAI,EAAEC,KAAK,EAAEmO,UAAU,EAAEuxB,OAAO,EAAEC,SAAS,EAAE3Y,IAAI,EAAE;IAC7D,IAAI,CAACjnB,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACmO,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACuxB,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAAC3Y,IAAI,GAAGA,IAAI;EAClB;EACAjhB,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAACo8B,kBAAkB,CAAC,IAAI,CAAC;EACzC;AACF;AACA,MAAMC,cAAc,CAAC;EACnBjiC,IAAI;EACJiH,IAAI;EACJ05B,eAAe;EACf1gC,KAAK;EACL2gC,IAAI;EACJxyB,UAAU;EACVuxB,OAAO;EACPC,SAAS;EACT3Y,IAAI;EACJjkB,WAAWA,CAAChD,IAAI,EAAEiH,IAAI,EAAE05B,eAAe,EAAE1gC,KAAK,EAAE2gC,IAAI,EAAExyB,UAAU,EAAEuxB,OAAO,EAAEC,SAAS,EAAE3Y,IAAI,EAAE;IAC1F,IAAI,CAACjnB,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACiH,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC05B,eAAe,GAAGA,eAAe;IACtC,IAAI,CAAC1gC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAAC2gC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACxyB,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACuxB,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAAC3Y,IAAI,GAAGA,IAAI;EAClB;EACA,OAAOib,wBAAwBA,CAAC7zB,IAAI,EAAE4Y,IAAI,EAAE;IAC1C,IAAI5Y,IAAI,CAACsxB,OAAO,KAAK5R,SAAS,EAAE;MAC9B,MAAM,IAAIrvB,KAAK,CAAC,kFAAkF2P,IAAI,CAACrO,IAAI,KAAKqO,IAAI,CAACD,UAAU,EAAE,CAAC;IACpI;IACA,OAAO,IAAI6zB,cAAc,CAAC5zB,IAAI,CAACrO,IAAI,EAAEqO,IAAI,CAACpH,IAAI,EAAEoH,IAAI,CAACsyB,eAAe,EAAEtyB,IAAI,CAACpO,KAAK,EAAEoO,IAAI,CAACuyB,IAAI,EAAEvyB,IAAI,CAACD,UAAU,EAAEC,IAAI,CAACsxB,OAAO,EAAEtxB,IAAI,CAACuxB,SAAS,EAAE3Y,IAAI,CAAC;EACnJ;EACAjhB,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAACu8B,mBAAmB,CAAC,IAAI,CAAC;EAC1C;AACF;AACA,MAAMC,UAAU,CAAC;EACfpiC,IAAI;EACJiH,IAAI;EACJ2uB,OAAO;EACPoC,MAAM;EACNqK,KAAK;EACLj0B,UAAU;EACVmyB,WAAW;EACXZ,OAAO;EACP38B,WAAWA,CAAChD,IAAI,EAAEiH,IAAI,EAAE2uB,OAAO,EAAEoC,MAAM,EAAEqK,KAAK,EAAEj0B,UAAU,EAAEmyB,WAAW,EAAEZ,OAAO,EAAE;IAChF,IAAI,CAAC3/B,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACiH,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC2uB,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACoC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACqK,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACj0B,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACmyB,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACZ,OAAO,GAAGA,OAAO;EACxB;EACA,OAAO2C,eAAeA,CAACC,KAAK,EAAE;IAC5B,MAAMvK,MAAM,GAAGuK,KAAK,CAACt7B,IAAI,KAAKm5B,eAAe,CAACoC,OAAO,GAAGD,KAAK,CAACjC,aAAa,GAAG,IAAI;IAClF,MAAM+B,KAAK,GAAGE,KAAK,CAACt7B,IAAI,KAAKm5B,eAAe,CAACqC,eAAe,GAAGF,KAAK,CAACjC,aAAa,GAAG,IAAI;IACzF,IAAIiC,KAAK,CAAC5C,OAAO,KAAK5R,SAAS,EAAE;MAC/B,MAAM,IAAIrvB,KAAK,CAAC,6EAA6E6jC,KAAK,CAACviC,IAAI,KAAKuiC,KAAK,CAACn0B,UAAU,EAAE,CAAC;IACjI;IACA,OAAO,IAAIg0B,UAAU,CAACG,KAAK,CAACviC,IAAI,EAAEuiC,KAAK,CAACt7B,IAAI,EAAEs7B,KAAK,CAAC3M,OAAO,EAAEoC,MAAM,EAAEqK,KAAK,EAAEE,KAAK,CAACn0B,UAAU,EAAEm0B,KAAK,CAAChC,WAAW,EAAEgC,KAAK,CAAC5C,OAAO,CAAC;EACjI;EACA35B,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAAC88B,eAAe,CAAC,IAAI,CAAC;EACtC;AACF;AACA,IAAIC,SAAS,GAAG,MAAMC,OAAO,CAAC;EAC5B5iC,IAAI;EACJ6iC,UAAU;EACVC,MAAM;EACNC,OAAO;EACPC,UAAU;EACVx8B,QAAQ;EACRy8B,UAAU;EACVC,aAAa;EACb90B,UAAU;EACV+0B,eAAe;EACfC,aAAa;EACbh8B,MAAM;EACN6f,IAAI;EACJjkB,WAAWA,CAAChD,IAAI,EAAE6iC,UAAU,EAAEC,MAAM,EAAEC,OAAO,EAAEC,UAAU,EAAEx8B,QAAQ,EAAEy8B,UAAU,EAAEC,aAAa,EAAE90B,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,EAAEh8B,MAAM,EAAE6f,IAAI,EAAE;IACxJ,IAAI,CAACjnB,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC6iC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACx8B,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACy8B,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAAC90B,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAC+0B,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACh8B,MAAM,GAAGA,MAAM;IACpB,IAAI,CAAC6f,IAAI,GAAGA,IAAI;EAClB;EACAjhB,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAACy9B,YAAY,CAAC,IAAI,CAAC;EACnC;AACF,CAAC;AACD,MAAMC,eAAe,CAAC;EACpBzI,QAAQ;EACRzsB,UAAU;EACVm1B,YAAY;EACZC,kBAAkB;EAClBC,WAAW;EACXzgC,WAAWA,CAAC63B,QAAQ,EAAEzsB,UAAU,EAAEm1B,YAAY,EAAEC,kBAAkB,EAAEC,WAAW,EAAE;IAC/E,IAAI,CAAC5I,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACzsB,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACm1B,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACC,kBAAkB,GAAGA,kBAAkB;IAC5C,IAAI,CAACC,WAAW,GAAGA,WAAW;EAChC;EACAz9B,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAAC89B,oBAAoB,CAAC,IAAI,CAAC;EAC3C;AACF;AACA,MAAMC,oBAAoB,SAASL,eAAe,CAAC;EACjDrjC,KAAK;EACL+C,WAAWA,CAAC/C,KAAK,EAAEmO,UAAU,EAAEm1B,YAAY,EAAEK,cAAc,EAAEH,WAAW,EAAE;IACxE,KAAK,CAAC,IAAI,EAAEr1B,UAAU,EAAEm1B,YAAY,EAAEK,cAAc,EAAEH,WAAW,CAAC;IAClE,IAAI,CAACxjC,KAAK,GAAGA,KAAK;EACpB;AACF;AACA,MAAM4jC,oBAAoB,SAASP,eAAe,CAAC;AACnD,MAAMQ,mBAAmB,SAASR,eAAe,CAAC;AAClD,MAAMS,wBAAwB,SAAST,eAAe,CAAC;AACvD,MAAMU,oBAAoB,SAASV,eAAe,CAAC;EACjD3b,SAAS;EACT3kB,WAAWA,CAAC2kB,SAAS,EAAEkT,QAAQ,EAAEzsB,UAAU,EAAEm1B,YAAY,EAAEU,YAAY,EAAER,WAAW,EAAE;IACpF,KAAK,CAAC5I,QAAQ,EAAEzsB,UAAU,EAAEm1B,YAAY,EAAEU,YAAY,EAAER,WAAW,CAAC;IACpE,IAAI,CAAC9b,SAAS,GAAGA,SAAS;EAC5B;AACF;AACA,MAAMuc,oBAAoB,SAASZ,eAAe,CAAC;EACjDa,KAAK;EACLnhC,WAAWA,CAACmhC,KAAK,EAAEtJ,QAAQ,EAAEzsB,UAAU,EAAEm1B,YAAY,EAAEU,YAAY,EAAER,WAAW,EAAE;IAChF,KAAK,CAAC5I,QAAQ,EAAEzsB,UAAU,EAAEm1B,YAAY,EAAEU,YAAY,EAAER,WAAW,CAAC;IACpE,IAAI,CAACU,KAAK,GAAGA,KAAK;EACpB;AACF;AACA,MAAMC,0BAA0B,SAASd,eAAe,CAAC;EACvD3b,SAAS;EACT3kB,WAAWA,CAAC2kB,SAAS,EAAEkT,QAAQ,EAAEzsB,UAAU,EAAEm1B,YAAY,EAAEU,YAAY,EAAER,WAAW,EAAE;IACpF,KAAK,CAAC5I,QAAQ,EAAEzsB,UAAU,EAAEm1B,YAAY,EAAEU,YAAY,EAAER,WAAW,CAAC;IACpE,IAAI,CAAC9b,SAAS,GAAGA,SAAS;EAC5B;AACF;AACA,MAAM0c,uBAAuB,SAASf,eAAe,CAAC;EACpD3b,SAAS;EACT2c,OAAO;EACPthC,WAAWA,CAAC2kB,SAAS,EAAE2c,OAAO,EAAEzJ,QAAQ,EAAEzsB,UAAU,EAAEm1B,YAAY,EAAEU,YAAY,EAAER,WAAW,EAAE;IAC7F,KAAK,CAAC5I,QAAQ,EAAEzsB,UAAU,EAAEm1B,YAAY,EAAEU,YAAY,EAAER,WAAW,CAAC;IACpE,IAAI,CAAC9b,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAAC2c,OAAO,GAAGA,OAAO;EACxB;AACF;AACA,MAAMC,SAAS,CAAC;EACd1J,QAAQ;EACRzsB,UAAU;EACV+0B,eAAe;EACfC,aAAa;EACbpgC,WAAWA,CAAC63B,QAAQ,EAAEzsB,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,EAAE;IAChE,IAAI,CAACvI,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACzsB,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAC+0B,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,aAAa,GAAGA,aAAa;EACpC;AACF;AACA,MAAMoB,wBAAwB,SAASD,SAAS,CAAC;EAC/C/9B,QAAQ;EACRi+B,WAAW;EACXxd,IAAI;EACJjkB,WAAWA,CAACwD,QAAQ,EAAEi+B,WAAW,EAAE5J,QAAQ,EAAEzsB,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,EAAEnc,IAAI,EAAE;IAC7F,KAAK,CAAC4T,QAAQ,EAAEzsB,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,CAAC;IAC3D,IAAI,CAAC58B,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACi+B,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACxd,IAAI,GAAGA,IAAI;EAClB;EACAjhB,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAAC8+B,6BAA6B,CAAC,IAAI,CAAC;EACpD;AACF;AACA,MAAMC,oBAAoB,SAASJ,SAAS,CAAC;EAC3C/9B,QAAQ;EACRo+B,SAAS;EACTH,WAAW;EACXxd,IAAI;EACJjkB,WAAWA,CAACwD,QAAQ,EAAEo+B,SAAS,EAAEH,WAAW,EAAE5J,QAAQ,EAAEzsB,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,EAAEnc,IAAI,EAAE;IACxG,KAAK,CAAC4T,QAAQ,EAAEzsB,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,CAAC;IAC3D,IAAI,CAAC58B,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACo+B,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACH,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACxd,IAAI,GAAGA,IAAI;EAClB;EACAjhB,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAACi/B,yBAAyB,CAAC,IAAI,CAAC;EAChD;AACF;AACA,MAAMC,kBAAkB,SAASP,SAAS,CAAC;EACzC/9B,QAAQ;EACRygB,IAAI;EACJjkB,WAAWA,CAACwD,QAAQ,EAAEq0B,QAAQ,EAAEzsB,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,EAAEnc,IAAI,EAAE;IAChF,KAAK,CAAC4T,QAAQ,EAAEzsB,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,CAAC;IAC3D,IAAI,CAAC58B,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACygB,IAAI,GAAGA,IAAI;EAClB;EACAjhB,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAACm/B,uBAAuB,CAAC,IAAI,CAAC;EAC9C;AACF;AACA,MAAMC,aAAa,SAAST,SAAS,CAAC;EACpC/9B,QAAQ;EACRoP,WAAW;EACXqvB,OAAO;EACPC,KAAK;EACLC,aAAa;EACble,IAAI;EACJme,QAAQ;EACRC,gBAAgB;EAChBC,eAAe;EACfC,eAAe;EACfC,uBAAuB;EACvBC,sBAAsB;EACtBziC,WAAWA,CAACwD,QAAQ,EAAE4+B,QAAQ,EAAEC,gBAAgB,EAAEC,eAAe,EAAE1vB,WAAW,EAAEqvB,OAAO,EAAEC,KAAK,EAAErK,QAAQ,EAAEzsB,UAAU,EAAE+2B,aAAa,EAAEhC,eAAe,EAAEC,aAAa,EAAEnc,IAAI,EAAE;IACzK,KAAK,CAAC4T,QAAQ,EAAEzsB,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,CAAC;IAC3D,IAAI,CAAC58B,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACoP,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACqvB,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACle,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACme,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,eAAe,GAAG7gC,MAAM,CAACmC,IAAI,CAACu+B,QAAQ,CAAC;IAC5C,IAAI,CAACI,uBAAuB,GAAG9gC,MAAM,CAACmC,IAAI,CAACw+B,gBAAgB,CAAC;IAC5D,IAAI,CAACI,sBAAsB,GAAG/gC,MAAM,CAACmC,IAAI,CAACy+B,eAAe,CAAC;EAC5D;EACAt/B,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAAC8/B,kBAAkB,CAAC,IAAI,CAAC;EACzC;EACAlG,QAAQA,CAAC55B,OAAO,EAAE;IAChB,IAAI,CAAC+/B,aAAa,CAAC,IAAI,CAACF,sBAAsB,EAAE,IAAI,CAACH,eAAe,EAAE1/B,OAAO,CAAC;IAC9E,IAAI,CAAC+/B,aAAa,CAAC,IAAI,CAACJ,eAAe,EAAE,IAAI,CAACH,QAAQ,EAAEx/B,OAAO,CAAC;IAChE,IAAI,CAAC+/B,aAAa,CAAC,IAAI,CAACH,uBAAuB,EAAE,IAAI,CAACH,gBAAgB,EAAEz/B,OAAO,CAAC;IAChFggC,UAAU,CAAChgC,OAAO,EAAE,IAAI,CAACY,QAAQ,CAAC;IAClC,MAAMq/B,eAAe,GAAG,CAAC,IAAI,CAACjwB,WAAW,EAAE,IAAI,CAACqvB,OAAO,EAAE,IAAI,CAACC,KAAK,CAAC,CAACrlB,MAAM,CAACimB,CAAC,IAAIA,CAAC,KAAK,IAAI,CAAC;IAC5FF,UAAU,CAAChgC,OAAO,EAAEigC,eAAe,CAAC;EACtC;EACAF,aAAaA,CAAC9+B,IAAI,EAAEu+B,QAAQ,EAAEx/B,OAAO,EAAE;IACrCggC,UAAU,CAAChgC,OAAO,EAAEiB,IAAI,CAACxE,GAAG,CAAC0E,CAAC,IAAIq+B,QAAQ,CAACr+B,CAAC,CAAC,CAAC,CAAC;EACjD;AACF;AACA,MAAMg/B,WAAW,SAASxB,SAAS,CAAC;EAClCv9B,UAAU;EACVF,KAAK;EACLk/B,aAAa;EACbhjC,WAAWA,CAACgE,UAAU,EAAEF,KAAK,EAAEk/B,aAAa,EAAE53B,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,EAAEvI,QAAQ,EAAE;IAClG,KAAK,CAACA,QAAQ,EAAEzsB,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,CAAC;IAC3D,IAAI,CAACp8B,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACF,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACk/B,aAAa,GAAGA,aAAa;EACpC;EACAhgC,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAACqgC,gBAAgB,CAAC,IAAI,CAAC;EACvC;AACF;AACA,MAAMC,eAAe,SAAS3B,SAAS,CAAC;EACtCv9B,UAAU;EACVR,QAAQ;EACRygB,IAAI;EACJjkB,WAAWA,CAACgE,UAAU,EAAER,QAAQ,EAAE4H,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,EAAEvI,QAAQ,EAAE5T,IAAI,EAAE;IAC5F,KAAK,CAAC4T,QAAQ,EAAEzsB,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,CAAC;IAC3D,IAAI,CAACp8B,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACR,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACygB,IAAI,GAAGA,IAAI;EAClB;EACAjhB,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAACugC,oBAAoB,CAAC,IAAI,CAAC;EAC3C;AACF;AACA,MAAMC,YAAY,SAAS7B,SAAS,CAAC;EACnC8B,IAAI;EACJr/B,UAAU;EACVs/B,OAAO;EACPC,gBAAgB;EAChBC,gBAAgB;EAChBhgC,QAAQ;EACRigC,KAAK;EACLtB,aAAa;EACble,IAAI;EACJjkB,WAAWA,CAACqjC,IAAI,EAAEr/B,UAAU,EAAEs/B,OAAO,EAAEC,gBAAgB,EAAEC,gBAAgB,EAAEhgC,QAAQ,EAAEigC,KAAK,EAAEr4B,UAAU,EAAE+2B,aAAa,EAAEhC,eAAe,EAAEC,aAAa,EAAEvI,QAAQ,EAAE5T,IAAI,EAAE;IACrK,KAAK,CAAC4T,QAAQ,EAAEzsB,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,CAAC;IAC3D,IAAI,CAACiD,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACr/B,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACs/B,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAAChgC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACigC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACtB,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACle,IAAI,GAAGA,IAAI;EAClB;EACAjhB,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAAC8gC,iBAAiB,CAAC,IAAI,CAAC;EACxC;AACF;AACA,MAAMC,iBAAiB,SAASpC,SAAS,CAAC;EACxC/9B,QAAQ;EACRygB,IAAI;EACJjkB,WAAWA,CAACwD,QAAQ,EAAE4H,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,EAAEvI,QAAQ,EAAE5T,IAAI,EAAE;IAChF,KAAK,CAAC4T,QAAQ,EAAEzsB,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,CAAC;IAC3D,IAAI,CAAC58B,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACygB,IAAI,GAAGA,IAAI;EAClB;EACAjhB,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAACghC,sBAAsB,CAAC,IAAI,CAAC;EAC7C;AACF;AACA,MAAMC,OAAO,SAAStC,SAAS,CAAC;EAC9BuC,QAAQ;EACR9jC,WAAWA,CAAC8jC,QAAQ,EAAE14B,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,EAAEvI,QAAQ,EAAE;IAC1E,KAAK,CAACA,QAAQ,EAAEzsB,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,CAAC;IAC3D,IAAI,CAAC0D,QAAQ,GAAGA,QAAQ;EAC1B;EACA9gC,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAACmhC,YAAY,CAAC,IAAI,CAAC;EACnC;AACF;AACA,MAAMC,aAAa,SAASzC,SAAS,CAAC;EACpCv9B,UAAU;EACVR,QAAQ;EACRygC,eAAe;EACfhgB,IAAI;EACJjkB,WAAWA,CAACgE,UAAU,EAAER,QAAQ,EAAEygC,eAAe,EAAE74B,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,EAAEvI,QAAQ,EAAE5T,IAAI,EAAE;IAC7G,KAAK,CAAC4T,QAAQ,EAAEzsB,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,CAAC;IAC3D,IAAI,CAACp8B,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACR,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACygC,eAAe,GAAGA,eAAe;IACtC,IAAI,CAAChgB,IAAI,GAAGA,IAAI;EAClB;EACAjhB,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAACshC,kBAAkB,CAAC,IAAI,CAAC;EACzC;AACF;AACA,MAAMC,YAAY,CAAC;EACjBnnC,IAAI;EACJoO,UAAU;EACVysB,QAAQ;EACR73B,WAAWA,CAAChD,IAAI,EAAEoO,UAAU,EAAEysB,QAAQ,EAAE;IACtC,IAAI,CAAC76B,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACoO,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACysB,QAAQ,GAAGA,QAAQ;EAC1B;EACA70B,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAACwhC,iBAAiB,CAAC,IAAI,CAAC;EACxC;AACF;AACA,IAAIC,gBAAgB,GAAG,MAAMC,cAAc,CAAC;EAC1CtnC,IAAI;EACJC,KAAK;EACLmO,UAAU;EACVysB,QAAQ;EACR+E,SAAS;EACT58B,WAAWA,CAAChD,IAAI,EAAEC,KAAK,EAAEmO,UAAU,EAAEysB,QAAQ,EAAE+E,SAAS,EAAE;IACxD,IAAI,CAAC5/B,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACmO,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACysB,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC+E,SAAS,GAAGA,SAAS;EAC5B;EACA55B,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAAC2hC,mBAAmB,CAAC,IAAI,CAAC;EAC1C;AACF,CAAC;AACD,IAAIC,WAAW,GAAG,MAAMrN,SAAS,CAAC;EAChCsN,aAAa;EACbtqB,OAAO;EACPkkB,QAAQ;EACRwB,UAAU;EACVC,MAAM;EACNC,OAAO;EACPC,UAAU;EACVx8B,QAAQ;EACRy8B,UAAU;EACVC,aAAa;EACb90B,UAAU;EACV+0B,eAAe;EACfC,aAAa;EACbnc,IAAI;EACJjkB,WAAWA,CAACykC,aAAa,EAAEtqB,OAAO,EAAEkkB,QAAQ,EAAEwB,UAAU,EAAEC,MAAM,EAAEC,OAAO,EAAEC,UAAU,EAAEx8B,QAAQ,EAAEy8B,UAAU,EAAEC,aAAa,EAAE90B,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,EAAEnc,IAAI,EAAE;IAC5K,IAAI,CAACwgB,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACtqB,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACkkB,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACwB,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACx8B,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACy8B,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAAC90B,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAC+0B,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACnc,IAAI,GAAGA,IAAI;EAClB;EACAjhB,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAAC8hC,cAAc,CAAC,IAAI,CAAC;EACrC;AACF,CAAC;AACD,IAAIC,WAAW,GAAG,MAAMvN,SAAS,CAAC;EAChCp6B,IAAI;EACJ6iC,UAAU;EACVC,MAAM;EACNC,OAAO;EACPE,UAAU;EACV70B,UAAU;EACV+0B,eAAe;EACfC,aAAa;EACbnc,IAAI;EACJjkB,WAAWA,CAAChD,IAAI,EAAE6iC,UAAU,EAAEC,MAAM,EAAEC,OAAO,EAAEE,UAAU,EAAE70B,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,EAAEnc,IAAI,EAAE;IAC3G,IAAI,CAACjnB,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC6iC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACE,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAC70B,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAC+0B,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACnc,IAAI,GAAGA,IAAI;EAClB;EACAjhB,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAACgiC,cAAc,CAAC,IAAI,CAAC;EACrC;AACF,CAAC;AACD,MAAMC,QAAQ,CAAC;EACb1qB,OAAO;EACP0lB,UAAU;EACVC,MAAM;EACNC,OAAO;EACPC,UAAU;EACV8E,aAAa;EACbthC,QAAQ;EACRy8B,UAAU;EACV8E,SAAS;EACT7E,aAAa;EACb90B,UAAU;EACV+0B,eAAe;EACfC,aAAa;EACbnc,IAAI;EACJjkB,WAAWA,CAACma,OAAO,EAAE0lB,UAAU,EAAEC,MAAM,EAAEC,OAAO,EAAEC,UAAU,EAAE8E,aAAa,EAAEthC,QAAQ,EAAEy8B,UAAU,EAAE8E,SAAS,EAAE7E,aAAa,EAAE90B,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,EAAEnc,IAAI,EAAE;IAC7K,IAAI,CAAC9J,OAAO,GAAGA,OAAO;IACtB,IAAI,CAAC0lB,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAC8E,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACthC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACy8B,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAC8E,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAAC7E,aAAa,GAAGA,aAAa;IAClC,IAAI,CAAC90B,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAC+0B,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACnc,IAAI,GAAGA,IAAI;EAClB;EACAjhB,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAACoiC,aAAa,CAAC,IAAI,CAAC;EACpC;AACF;AACA,MAAMC,OAAO,CAAC;EACZpqC,QAAQ;EACRglC,UAAU;EACVr8B,QAAQ;EACR08B,aAAa;EACb90B,UAAU;EACV+0B,eAAe;EACfC,aAAa;EACbnc,IAAI;EACJjnB,IAAI,GAAG,YAAY;EACnBgD,WAAWA,CAACnF,QAAQ,EAAEglC,UAAU,EAAEr8B,QAAQ,EAAE08B,aAAa,EAAE90B,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,EAAEnc,IAAI,EAAE;IAC3G,IAAI,CAACppB,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACglC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACr8B,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC08B,aAAa,GAAGA,aAAa;IAClC,IAAI,CAAC90B,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAC+0B,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACnc,IAAI,GAAGA,IAAI;EAClB;EACAjhB,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAACsiC,YAAY,CAAC,IAAI,CAAC;EACnC;AACF;AACA,MAAMC,QAAQ,CAAC;EACbnoC,IAAI;EACJC,KAAK;EACLmO,UAAU;EACVuxB,OAAO;EACPC,SAAS;EACT58B,WAAWA,CAAChD,IAAI,EAAEC,KAAK,EAAEmO,UAAU,EAAEuxB,OAAO,EAAEC,SAAS,EAAE;IACvD,IAAI,CAAC5/B,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACmO,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACuxB,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,SAAS,GAAGA,SAAS;EAC5B;EACA55B,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAACwiC,aAAa,CAAC,IAAI,CAAC;EACpC;AACF;AACA,MAAMC,SAAS,CAAC;EACdroC,IAAI;EACJC,KAAK;EACLmO,UAAU;EACVuxB,OAAO;EACPC,SAAS;EACT58B,WAAWA,CAAChD,IAAI,EAAEC,KAAK,EAAEmO,UAAU,EAAEuxB,OAAO,EAAEC,SAAS,EAAE;IACvD,IAAI,CAAC5/B,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACmO,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACuxB,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,SAAS,GAAGA,SAAS;EAC5B;EACA55B,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAAC0iC,cAAc,CAAC,IAAI,CAAC;EACrC;AACF;AACA,IAAIC,KAAK,GAAG,MAAMC,GAAG,CAAC;EACpBC,IAAI;EACJC,YAAY;EACZt6B,UAAU;EACV6Y,IAAI;EACJjkB,WAAWA,CAACylC,IAAI,EAAEC,YAAY,EAAEt6B,UAAU,EAAE6Y,IAAI,EAAE;IAChD,IAAI,CAACwhB,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACt6B,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAC6Y,IAAI,GAAGA,IAAI;EAClB;EACAjhB,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAACc,QAAQ,CAAC,IAAI,CAAC;EAC/B;AACF,CAAC;AACD,MAAMiiC,WAAW,CAAC;EAChBC,QAAQ;EACRC,QAAQ;EACRC,SAAS;EACT16B,UAAU;EACVpL,WAAWA,CAAC4lC,QAAQ,EAAEC,QAAQ,EAAEC,SAAS,EAAE16B,UAAU,EAAE;IACrD,IAAI,CAACw6B,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAAC16B,UAAU,GAAGA,UAAU;IAC5B,IAAIw6B,QAAQ,CAAC1qC,MAAM,KAAK,CAAC,EAAE;MACzB,MAAM,IAAIQ,KAAK,CAAC,8CAA8C,CAAC;IACjE;EACF;EACAsH,KAAKA,CAAA,EAAG;IACN,MAAM,IAAItH,KAAK,CAAC,+BAA+B,CAAC;EAClD;AACF;AACA,IAAIqqC,kBAAkB,GAAG,MAAMC,gBAAgB,CAAC;EAC9C3F,YAAYA,CAAC7lC,OAAO,EAAE;IACpBooC,UAAU,CAAC,IAAI,EAAEpoC,OAAO,CAACqlC,UAAU,CAAC;IACpC+C,UAAU,CAAC,IAAI,EAAEpoC,OAAO,CAACslC,MAAM,CAAC;IAChC8C,UAAU,CAAC,IAAI,EAAEpoC,OAAO,CAACulC,OAAO,CAAC;IACjC6C,UAAU,CAAC,IAAI,EAAEpoC,OAAO,CAACwlC,UAAU,CAAC;IACpC4C,UAAU,CAAC,IAAI,EAAEpoC,OAAO,CAACgJ,QAAQ,CAAC;IAClCo/B,UAAU,CAAC,IAAI,EAAEpoC,OAAO,CAACylC,UAAU,CAAC;EACtC;EACA+E,aAAaA,CAAC70B,QAAQ,EAAE;IACtByyB,UAAU,CAAC,IAAI,EAAEzyB,QAAQ,CAAC0vB,UAAU,CAAC;IACrC+C,UAAU,CAAC,IAAI,EAAEzyB,QAAQ,CAAC2vB,MAAM,CAAC;IACjC8C,UAAU,CAAC,IAAI,EAAEzyB,QAAQ,CAAC4vB,OAAO,CAAC;IAClC6C,UAAU,CAAC,IAAI,EAAEzyB,QAAQ,CAAC6vB,UAAU,CAAC;IACrC4C,UAAU,CAAC,IAAI,EAAEzyB,QAAQ,CAAC3M,QAAQ,CAAC;IACnCo/B,UAAU,CAAC,IAAI,EAAEzyB,QAAQ,CAAC8vB,UAAU,CAAC;IACrC2C,UAAU,CAAC,IAAI,EAAEzyB,QAAQ,CAAC40B,SAAS,CAAC;EACtC;EACArC,kBAAkBA,CAACuD,QAAQ,EAAE;IAC3BA,QAAQ,CAACzJ,QAAQ,CAAC,IAAI,CAAC;EACzB;EACAkF,6BAA6BA,CAACwE,KAAK,EAAE;IACnCtD,UAAU,CAAC,IAAI,EAAEsD,KAAK,CAAC1iC,QAAQ,CAAC;EAClC;EACAu+B,uBAAuBA,CAACmE,KAAK,EAAE;IAC7BtD,UAAU,CAAC,IAAI,EAAEsD,KAAK,CAAC1iC,QAAQ,CAAC;EAClC;EACAq+B,yBAAyBA,CAACqE,KAAK,EAAE;IAC/BtD,UAAU,CAAC,IAAI,EAAEsD,KAAK,CAAC1iC,QAAQ,CAAC;EAClC;EACAy/B,gBAAgBA,CAACiD,KAAK,EAAE;IACtBtD,UAAU,CAAC,IAAI,EAAEsD,KAAK,CAACpiC,KAAK,CAAC;EAC/B;EACAq/B,oBAAoBA,CAAC+C,KAAK,EAAE;IAC1BtD,UAAU,CAAC,IAAI,EAAEsD,KAAK,CAAC1iC,QAAQ,CAAC;EAClC;EACAkgC,iBAAiBA,CAACwC,KAAK,EAAE;IACvB,MAAMC,UAAU,GAAG,CAACD,KAAK,CAAC7C,IAAI,EAAE,GAAG6C,KAAK,CAAC1C,gBAAgB,EAAE,GAAG0C,KAAK,CAAC1iC,QAAQ,CAAC;IAC7E0iC,KAAK,CAACzC,KAAK,IAAI0C,UAAU,CAAChrC,IAAI,CAAC+qC,KAAK,CAACzC,KAAK,CAAC;IAC3Cb,UAAU,CAAC,IAAI,EAAEuD,UAAU,CAAC;EAC9B;EACAvC,sBAAsBA,CAACsC,KAAK,EAAE;IAC5BtD,UAAU,CAAC,IAAI,EAAEsD,KAAK,CAAC1iC,QAAQ,CAAC;EAClC;EACAugC,YAAYA,CAACmC,KAAK,EAAE;IAClBtD,UAAU,CAAC,IAAI,EAAEsD,KAAK,CAACpC,QAAQ,CAAC;EAClC;EACAI,kBAAkBA,CAACgC,KAAK,EAAE;IACxB,MAAMC,UAAU,GAAGD,KAAK,CAAC1iC,QAAQ;IACjC0iC,KAAK,CAACjC,eAAe,IAAIkC,UAAU,CAAChrC,IAAI,CAAC+qC,KAAK,CAACjC,eAAe,CAAC;IAC/DrB,UAAU,CAAC,IAAI,EAAEuD,UAAU,CAAC;EAC9B;EACAjB,YAAYA,CAACjY,OAAO,EAAE;IACpB2V,UAAU,CAAC,IAAI,EAAE3V,OAAO,CAACzpB,QAAQ,CAAC;EACpC;EACAkhC,cAAcA,CAAC0B,SAAS,EAAE;IACxBxD,UAAU,CAAC,IAAI,EAAEwD,SAAS,CAACvG,UAAU,CAAC;IACtC+C,UAAU,CAAC,IAAI,EAAEwD,SAAS,CAACtG,MAAM,CAAC;IAClC8C,UAAU,CAAC,IAAI,EAAEwD,SAAS,CAACrG,OAAO,CAAC;IACnC6C,UAAU,CAAC,IAAI,EAAEwD,SAAS,CAACpG,UAAU,CAAC;IACtC4C,UAAU,CAAC,IAAI,EAAEwD,SAAS,CAAC5iC,QAAQ,CAAC;IACpCo/B,UAAU,CAAC,IAAI,EAAEwD,SAAS,CAACnG,UAAU,CAAC;EACxC;EACA2E,cAAcA,CAACyB,SAAS,EAAE;IACxBzD,UAAU,CAAC,IAAI,EAAEyD,SAAS,CAACxG,UAAU,CAAC;IACtC+C,UAAU,CAAC,IAAI,EAAEyD,SAAS,CAACvG,MAAM,CAAC;IAClC8C,UAAU,CAAC,IAAI,EAAEyD,SAAS,CAACtG,OAAO,CAAC;IACnC6C,UAAU,CAAC,IAAI,EAAEyD,SAAS,CAACpG,UAAU,CAAC;EACxC;EACAmF,aAAaA,CAACzsB,QAAQ,EAAE,CAAC;EACzB2sB,cAAcA,CAAC3gB,SAAS,EAAE,CAAC;EAC3Bqa,kBAAkBA,CAAC/iC,SAAS,EAAE,CAAC;EAC/BkjC,mBAAmBA,CAACljC,SAAS,EAAE,CAAC;EAChCyjC,eAAeA,CAACzjC,SAAS,EAAE,CAAC;EAC5BkH,SAASA,CAACC,IAAI,EAAE,CAAC;EACjB07B,cAAcA,CAAC17B,IAAI,EAAE,CAAC;EACtBM,QAAQA,CAACC,GAAG,EAAE,CAAC;EACf+8B,oBAAoBA,CAAC4F,OAAO,EAAE,CAAC;EAC/BlC,iBAAiBA,CAAC8B,KAAK,EAAE,CAAC;EAC1B3B,mBAAmBA,CAACgC,IAAI,EAAE,CAAC;AAC7B,CAAC;AACD,SAAS3D,UAAUA,CAAChgC,OAAO,EAAEJ,KAAK,EAAE;EAClC,MAAMpG,MAAM,GAAG,EAAE;EACjB,IAAIwG,OAAO,CAACI,KAAK,EAAE;IACjB,KAAK,MAAM2M,IAAI,IAAInN,KAAK,EAAE;MACxBI,OAAO,CAACI,KAAK,CAAC2M,IAAI,CAAC;IACrB;EACF,CAAC,MAAM;IACL,KAAK,MAAMA,IAAI,IAAInN,KAAK,EAAE;MACxB,MAAMgkC,OAAO,GAAG72B,IAAI,CAAC3M,KAAK,CAACJ,OAAO,CAAC;MACnC,IAAI4jC,OAAO,EAAE;QACXpqC,MAAM,CAACjB,IAAI,CAACqrC,OAAO,CAAC;MACtB;IACF;EACF;EACA,OAAOpqC,MAAM;AACf;AAEA,MAAMqqC,OAAO,CAAC;EACZjkC,KAAK;EACLkjC,YAAY;EACZgB,oBAAoB;EACpBjkC,OAAO;EACP0P,WAAW;EACXC,QAAQ;EACRub,OAAO;EACPvrB,EAAE;EACFiQ,SAAS,GAAG,EAAE;EACdS,aAAa;EACb9S,WAAWA,CAACwC,KAAK,EAAEkjC,YAAY,EAAEgB,oBAAoB,EAAEjkC,OAAO,EAAE0P,WAAW,EAAEC,QAAQ,EAAE;IACrF,IAAI,CAAC5P,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACkjC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACgB,oBAAoB,GAAGA,oBAAoB;IAChD,IAAI,CAACjkC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAAC0P,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAChQ,EAAE,GAAG,IAAI,CAACgQ,QAAQ;IACvB,IAAI,CAACU,aAAa,GAAG6zB,gBAAgB,CAAC,IAAI,CAACnkC,KAAK,CAAC;IACjD,IAAIA,KAAK,CAACtH,MAAM,EAAE;MAChB,IAAI,CAACyyB,OAAO,GAAG,CAAC;QACdiZ,QAAQ,EAAEpkC,KAAK,CAAC,CAAC,CAAC,CAAC4I,UAAU,CAACmmB,KAAK,CAAC5E,IAAI,CAAChZ,GAAG;QAC5CkzB,SAAS,EAAErkC,KAAK,CAAC,CAAC,CAAC,CAAC4I,UAAU,CAACmmB,KAAK,CAACN,IAAI,GAAG,CAAC;QAC7C6V,QAAQ,EAAEtkC,KAAK,CAAC,CAAC,CAAC,CAAC4I,UAAU,CAACmmB,KAAK,CAACG,GAAG,GAAG,CAAC;QAC3CqV,OAAO,EAAEvkC,KAAK,CAACA,KAAK,CAACtH,MAAM,GAAG,CAAC,CAAC,CAACkQ,UAAU,CAAC7D,GAAG,CAAC0pB,IAAI,GAAG,CAAC;QACxD+V,MAAM,EAAExkC,KAAK,CAAC,CAAC,CAAC,CAAC4I,UAAU,CAACmmB,KAAK,CAACG,GAAG,GAAG;MAC1C,CAAC,CAAC;IACJ,CAAC,MAAM;MACL,IAAI,CAAC/D,OAAO,GAAG,EAAE;IACnB;EACF;AACF;AACA,IAAIsZ,MAAM,GAAG,MAAMrI,IAAI,CAAC;EACtB3hC,KAAK;EACLmO,UAAU;EACVpL,WAAWA,CAAC/C,KAAK,EAAEmO,UAAU,EAAE;IAC7B,IAAI,CAACnO,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACmO,UAAU,GAAGA,UAAU;EAC9B;EACApI,KAAKA,CAACJ,OAAO,EAAES,OAAO,EAAE;IACtB,OAAOT,OAAO,CAACO,SAAS,CAAC,IAAI,EAAEE,OAAO,CAAC;EACzC;AACF,CAAC;AACD,MAAM6jC,SAAS,CAAC;EACd1jC,QAAQ;EACR4H,UAAU;EACVpL,WAAWA,CAACwD,QAAQ,EAAE4H,UAAU,EAAE;IAChC,IAAI,CAAC5H,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC4H,UAAU,GAAGA,UAAU;EAC9B;EACApI,KAAKA,CAACJ,OAAO,EAAES,OAAO,EAAE;IACtB,OAAOT,OAAO,CAACU,cAAc,CAAC,IAAI,EAAED,OAAO,CAAC;EAC9C;AACF;AACA,MAAMmiC,GAAG,CAAC;EACRxhC,UAAU;EACVC,IAAI;EACJH,KAAK;EACLsH,UAAU;EACV+7B,qBAAqB;EACrBnnC,WAAWA,CAACgE,UAAU,EAAEC,IAAI,EAAEH,KAAK,EAAEsH,UAAU,EAAE+7B,qBAAqB,EAAE;IACtE,IAAI,CAACnjC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACH,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACsH,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAC+7B,qBAAqB,GAAGA,qBAAqB;EACpD;EACAnkC,KAAKA,CAACJ,OAAO,EAAES,OAAO,EAAE;IACtB,OAAOT,OAAO,CAACc,QAAQ,CAAC,IAAI,EAAEL,OAAO,CAAC;EACxC;AACF;AACA,MAAM+jC,cAAc,CAAC;EACnBzrC,GAAG;EACHjB,KAAK;EACL2J,SAAS;EACTC,SAAS;EACTd,QAAQ;EACRY,MAAM;EACNgH,UAAU;EACV+0B,eAAe;EACfC,aAAa;EACbpgC,WAAWA,CAACrE,GAAG,EAAEjB,KAAK,EAAE2J,SAAS,EAAEC,SAAS,EAAEd,QAAQ,EAAEY,MAAM,EAAEgH,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,EAAE;IAC1G,IAAI,CAACzkC,GAAG,GAAGA,GAAG;IACd,IAAI,CAACjB,KAAK,GAAGA,KAAK;IAClB,IAAI,CAAC2J,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACd,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACY,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACgH,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAC+0B,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,aAAa,GAAGA,aAAa;EACpC;EACAp9B,KAAKA,CAACJ,OAAO,EAAES,OAAO,EAAE;IACtB,OAAOT,OAAO,CAACsB,mBAAmB,CAAC,IAAI,EAAEb,OAAO,CAAC;EACnD;AACF;AACA,MAAMgkC,WAAW,CAAC;EAChBpqC,KAAK;EACLD,IAAI;EACJoO,UAAU;EACVpL,WAAWA,CAAC/C,KAAK,EAAED,IAAI,EAAEoO,UAAU,EAAE;IACnC,IAAI,CAACnO,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACD,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACoO,UAAU,GAAGA,UAAU;EAC9B;EACApI,KAAKA,CAACJ,OAAO,EAAES,OAAO,EAAE;IACtB,OAAOT,OAAO,CAAC2B,gBAAgB,CAAC,IAAI,EAAElB,OAAO,CAAC;EAChD;AACF;AACA,MAAMikC,cAAc,CAAC;EACnBrqC,KAAK;EACLD,IAAI;EACJoO,UAAU;EACVm8B,eAAe;EACfvnC,WAAWA,CAAC/C,KAAK,EAAED,IAAI,EAAEoO,UAAU,EAAE;IACnC,IAAI,CAACnO,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACD,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACoO,UAAU,GAAGA,UAAU;EAC9B;EACApI,KAAKA,CAACJ,OAAO,EAAES,OAAO,EAAE;IACtB,OAAOT,OAAO,CAAC4B,mBAAmB,CAAC,IAAI,EAAEnB,OAAO,CAAC;EACnD;AACF;AACA,MAAMmkC,gBAAgB,CAAC;EACrBxqC,IAAI;EACJ+f,UAAU;EACV1Y,SAAS;EACTC,SAAS;EACTd,QAAQ;EACR4H,UAAU;EACV+0B,eAAe;EACfC,aAAa;EACbpgC,WAAWA,CAAChD,IAAI,EAAE+f,UAAU,EAAE1Y,SAAS,EAAEC,SAAS,EAAEd,QAAQ,EAAE4H,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,EAAE;IACxG,IAAI,CAACpjC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC+f,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAC1Y,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACd,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC4H,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAC+0B,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,aAAa,GAAGA,aAAa;EACpC;EACAp9B,KAAKA,CAACJ,OAAO,EAAES,OAAO,EAAE;IACtB,OAAOT,OAAO,CAAC6B,qBAAqB,CAAC,IAAI,EAAEpB,OAAO,CAAC;EACrD;AACF;AACA,MAAMokC,YAAY,CAAC;EACjBtkC,SAASA,CAACC,IAAI,EAAEC,OAAO,EAAE;IACvB,OAAO,IAAI4jC,MAAM,CAAC7jC,IAAI,CAACnG,KAAK,EAAEmG,IAAI,CAACgI,UAAU,CAAC;EAChD;EACA9H,cAAcA,CAACC,SAAS,EAAEF,OAAO,EAAE;IACjC,MAAMG,QAAQ,GAAGD,SAAS,CAACC,QAAQ,CAACnE,GAAG,CAACqoC,CAAC,IAAIA,CAAC,CAAC1kC,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,CAAC;IACpE,OAAO,IAAI6jC,SAAS,CAAC1jC,QAAQ,EAAED,SAAS,CAAC6H,UAAU,CAAC;EACtD;EACA1H,QAAQA,CAACC,GAAG,EAAEN,OAAO,EAAE;IACrB,MAAMS,KAAK,GAAG,CAAC,CAAC;IAChBpC,MAAM,CAACmC,IAAI,CAACF,GAAG,CAACG,KAAK,CAAC,CAAC1G,OAAO,CAACmO,GAAG,IAAIzH,KAAK,CAACyH,GAAG,CAAC,GAAG5H,GAAG,CAACG,KAAK,CAACyH,GAAG,CAAC,CAACvI,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,CAAC;IACvF,MAAMgE,GAAG,GAAG,IAAIm+B,GAAG,CAAC7hC,GAAG,CAACK,UAAU,EAAEL,GAAG,CAACM,IAAI,EAAEH,KAAK,EAAEH,GAAG,CAACyH,UAAU,EAAEzH,GAAG,CAACwjC,qBAAqB,CAAC;IAC/F,OAAO9/B,GAAG;EACZ;EACAnD,mBAAmBA,CAACC,EAAE,EAAEd,OAAO,EAAE;IAC/B,MAAMG,QAAQ,GAAGW,EAAE,CAACX,QAAQ,CAACnE,GAAG,CAACqoC,CAAC,IAAIA,CAAC,CAAC1kC,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,CAAC;IAC7D,OAAO,IAAI+jC,cAAc,CAACjjC,EAAE,CAACxI,GAAG,EAAEwI,EAAE,CAACzJ,KAAK,EAAEyJ,EAAE,CAACE,SAAS,EAAEF,EAAE,CAACG,SAAS,EAAEd,QAAQ,EAAEW,EAAE,CAACC,MAAM,EAAED,EAAE,CAACiH,UAAU,EAAEjH,EAAE,CAACg8B,eAAe,EAAEh8B,EAAE,CAACi8B,aAAa,CAAC;EACnJ;EACA77B,gBAAgBA,CAACJ,EAAE,EAAEd,OAAO,EAAE;IAC5B,OAAO,IAAIgkC,WAAW,CAACljC,EAAE,CAAClH,KAAK,EAAEkH,EAAE,CAACnH,IAAI,EAAEmH,EAAE,CAACiH,UAAU,CAAC;EAC1D;EACA5G,mBAAmBA,CAACL,EAAE,EAAEd,OAAO,EAAE;IAC/B,OAAO,IAAIikC,cAAc,CAACnjC,EAAE,CAAClH,KAAK,EAAEkH,EAAE,CAACnH,IAAI,EAAEmH,EAAE,CAACiH,UAAU,CAAC;EAC7D;EACA3G,qBAAqBA,CAACN,EAAE,EAAEd,OAAO,EAAE;IACjC,MAAMG,QAAQ,GAAGW,EAAE,CAACX,QAAQ,CAACnE,GAAG,CAACqoC,CAAC,IAAIA,CAAC,CAAC1kC,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,CAAC;IAC7D,OAAO,IAAImkC,gBAAgB,CAACrjC,EAAE,CAACnH,IAAI,EAAEmH,EAAE,CAAC4Y,UAAU,EAAE5Y,EAAE,CAACE,SAAS,EAAEF,EAAE,CAACG,SAAS,EAAEd,QAAQ,EAAEW,EAAE,CAACiH,UAAU,EAAEjH,EAAE,CAACg8B,eAAe,EAAEh8B,EAAE,CAACi8B,aAAa,CAAC;EAChJ;AACF;AACA,MAAMuH,cAAc,CAAC;EACnBxkC,SAASA,CAACC,IAAI,EAAEC,OAAO,EAAE,CAAC;EAC1BC,cAAcA,CAACC,SAAS,EAAEF,OAAO,EAAE;IACjCE,SAAS,CAACC,QAAQ,CAACpG,OAAO,CAACqG,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC;EACxD;EACAU,QAAQA,CAACC,GAAG,EAAEN,OAAO,EAAE;IACrB3B,MAAM,CAACmC,IAAI,CAACF,GAAG,CAACG,KAAK,CAAC,CAAC1G,OAAO,CAAC2G,CAAC,IAAI;MAClCJ,GAAG,CAACG,KAAK,CAACC,CAAC,CAAC,CAACf,KAAK,CAAC,IAAI,CAAC;IAC1B,CAAC,CAAC;EACJ;EACAkB,mBAAmBA,CAACC,EAAE,EAAEd,OAAO,EAAE;IAC/Bc,EAAE,CAACX,QAAQ,CAACpG,OAAO,CAACqG,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC;EACjD;EACAuB,gBAAgBA,CAACJ,EAAE,EAAEd,OAAO,EAAE,CAAC;EAC/BmB,mBAAmBA,CAACL,EAAE,EAAEd,OAAO,EAAE,CAAC;EAClCoB,qBAAqBA,CAACN,EAAE,EAAEd,OAAO,EAAE;IACjCc,EAAE,CAACX,QAAQ,CAACpG,OAAO,CAACqG,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC;EACjD;AACF;AACA,SAAS2jC,gBAAgBA,CAACiB,YAAY,EAAE;EACtC,MAAMhlC,OAAO,GAAG,IAAIilC,4BAA4B,CAAC,CAAC;EAClD,MAAMljC,GAAG,GAAGijC,YAAY,CAACvoC,GAAG,CAACqoC,CAAC,IAAIA,CAAC,CAAC1kC,KAAK,CAACJ,OAAO,CAAC,CAAC,CAAC9F,IAAI,CAAC,EAAE,CAAC;EAC5D,OAAO6H,GAAG;AACZ;AACA,MAAMkjC,4BAA4B,CAAC;EACjC1kC,SAASA,CAACC,IAAI,EAAE;IACd,OAAOA,IAAI,CAACnG,KAAK;EACnB;EACAqG,cAAcA,CAACC,SAAS,EAAE;IACxB,OAAOA,SAAS,CAACC,QAAQ,CAACnE,GAAG,CAACoE,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC,CAAClG,IAAI,CAAC,EAAE,CAAC;EACpE;EACA4G,QAAQA,CAACC,GAAG,EAAE;IACZ,MAAMC,QAAQ,GAAGlC,MAAM,CAACmC,IAAI,CAACF,GAAG,CAACG,KAAK,CAAC,CAACzE,GAAG,CAAC0E,CAAC,IAAI,GAAGA,CAAC,KAAKJ,GAAG,CAACG,KAAK,CAACC,CAAC,CAAC,CAACf,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC;IACtF,OAAO,IAAIW,GAAG,CAACwjC,qBAAqB,KAAKxjC,GAAG,CAACM,IAAI,KAAKL,QAAQ,CAAC9G,IAAI,CAAC,GAAG,CAAC,GAAG;EAC7E;EACAoH,mBAAmBA,CAACC,EAAE,EAAE;IACtB,MAAMX,QAAQ,GAAGW,EAAE,CAACX,QAAQ,CAACnE,GAAG,CAACoE,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC,CAAClG,IAAI,CAAC,EAAE,CAAC;IACrE,OAAO,KAAKqH,EAAE,CAACE,SAAS,IAAIb,QAAQ,KAAKW,EAAE,CAACG,SAAS,GAAG;EAC1D;EACAC,gBAAgBA,CAACJ,EAAE,EAAE;IACnB,OAAO,KAAKA,EAAE,CAACnH,IAAI,GAAG;EACxB;EACAwH,mBAAmBA,CAACL,EAAE,EAAE;IACtB,OAAO,KAAKA,EAAE,CAACnH,IAAI,GAAG;EACxB;EACAyH,qBAAqBA,CAACN,EAAE,EAAE;IACxB,MAAMX,QAAQ,GAAGW,EAAE,CAACX,QAAQ,CAACnE,GAAG,CAACoE,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC,CAAClG,IAAI,CAAC,EAAE,CAAC;IACrE,OAAO,KAAKqH,EAAE,CAACE,SAAS,IAAIb,QAAQ,KAAKW,EAAE,CAACG,SAAS,GAAG;EAC1D;AACF;AAEA,MAAMwjC,UAAU,CAAC;EACfC,gBAAgBA,CAAC5lC,OAAO,EAAE;IACxB,OAAO,IAAI;EACb;AACF;AACA,MAAM6lC,uBAAuB,SAASL,cAAc,CAAC;EACnDM,OAAO;EACPC,gBAAgB,GAAG,CAAC,CAAC;EACrBC,cAAc,GAAG,CAAC,CAAC;EACnBC,gBAAgB,GAAG,CAAC,CAAC;EACrBpoC,WAAWA,CAACmC,OAAO,EAAE8lC,OAAO,EAAE;IAC5B,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,OAAO,GAAGA,OAAO;IACtB9lC,OAAO,CAACK,KAAK,CAACpF,OAAO,CAACuS,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC;EACjD;EACAqlC,YAAYA,CAACC,YAAY,EAAE;IACzB,OAAO,IAAI,CAACJ,gBAAgB,CAACK,cAAc,CAACD,YAAY,CAAC,GAAG,IAAI,CAACJ,gBAAgB,CAACI,YAAY,CAAC,GAAG,IAAI;EACxG;EACAE,cAAcA,CAACC,UAAU,EAAE;IACzB,OAAO,IAAI,CAACL,gBAAgB,CAACG,cAAc,CAACE,UAAU,CAAC,GAAG,IAAI,CAACL,gBAAgB,CAACK,UAAU,CAAC,GAAG,IAAI;EACpG;EACAtlC,SAASA,CAACC,IAAI,EAAEC,OAAO,EAAE;IACvB,OAAO,IAAI;EACb;EACAa,mBAAmBA,CAACC,EAAE,EAAEd,OAAO,EAAE;IAC/B,IAAI,CAACqlC,oBAAoB,CAACvkC,EAAE,CAACE,SAAS,CAAC;IACvC,KAAK,CAACH,mBAAmB,CAACC,EAAE,EAAEd,OAAO,CAAC;IACtC,IAAI,CAACqlC,oBAAoB,CAACvkC,EAAE,CAACG,SAAS,CAAC;EACzC;EACAC,gBAAgBA,CAACJ,EAAE,EAAEd,OAAO,EAAE;IAC5B,IAAI,CAACqlC,oBAAoB,CAACvkC,EAAE,CAACnH,IAAI,CAAC;EACpC;EACAyH,qBAAqBA,CAACN,EAAE,EAAEd,OAAO,EAAE;IACjC,IAAI,CAACqlC,oBAAoB,CAACvkC,EAAE,CAACE,SAAS,CAAC;IACvC,KAAK,CAACI,qBAAqB,CAACN,EAAE,EAAEd,OAAO,CAAC;IACxC,IAAI,CAACqlC,oBAAoB,CAACvkC,EAAE,CAACG,SAAS,CAAC;EACzC;EACAE,mBAAmBA,CAACL,EAAE,EAAEd,OAAO,EAAE;IAC/B,IAAI,CAACqlC,oBAAoB,CAACvkC,EAAE,CAACnH,IAAI,CAAC;EACpC;EACA0rC,oBAAoBA,CAACJ,YAAY,EAAE;IACjC,IAAI,CAACA,YAAY,IAAI,IAAI,CAACJ,gBAAgB,CAACK,cAAc,CAACD,YAAY,CAAC,EAAE;MACvE;IACF;IACA,IAAIG,UAAU,GAAG,IAAI,CAACR,OAAO,CAACK,YAAY,CAAC;IAC3C,IAAI,IAAI,CAACF,gBAAgB,CAACG,cAAc,CAACE,UAAU,CAAC,EAAE;MACpD,MAAME,MAAM,GAAG,IAAI,CAACR,cAAc,CAACM,UAAU,CAAC;MAC9C,IAAI,CAACN,cAAc,CAACM,UAAU,CAAC,GAAGE,MAAM,GAAG,CAAC;MAC5CF,UAAU,GAAG,GAAGA,UAAU,IAAIE,MAAM,EAAE;IACxC,CAAC,MAAM;MACL,IAAI,CAACR,cAAc,CAACM,UAAU,CAAC,GAAG,CAAC;IACrC;IACA,IAAI,CAACP,gBAAgB,CAACI,YAAY,CAAC,GAAGG,UAAU;IAChD,IAAI,CAACL,gBAAgB,CAACK,UAAU,CAAC,GAAGH,YAAY;EAClD;AACF;AAEA,IAAIM,UAAU,GAAG,MAAMC,QAAQ,CAAC;EAC9BC,QAAQA,CAACntC,GAAG,EAAE;IACZ,MAAMotC,QAAQ,GAAG,IAAI,CAACC,oBAAoB,CAACrtC,GAAG,CAACjB,KAAK,CAAC;IACrD,IAAIiB,GAAG,CAAC6H,QAAQ,CAACtI,MAAM,IAAI,CAAC,EAAE;MAC5B,OAAO,IAAIS,GAAG,CAACqB,IAAI,GAAG+rC,QAAQ,IAAI;IACpC;IACA,MAAME,WAAW,GAAGttC,GAAG,CAAC6H,QAAQ,CAACnE,GAAG,CAACsQ,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC;IAC9D,OAAO,IAAIrH,GAAG,CAACqB,IAAI,GAAG+rC,QAAQ,IAAIE,WAAW,CAACnsC,IAAI,CAAC,EAAE,CAAC,KAAKnB,GAAG,CAACqB,IAAI,GAAG;EACxE;EACAmG,SAASA,CAACC,IAAI,EAAE;IACd,OAAOA,IAAI,CAACnG,KAAK;EACnB;EACAisC,gBAAgBA,CAAC3C,IAAI,EAAE;IACrB,OAAO,QAAQ,IAAI,CAACyC,oBAAoB,CAACzC,IAAI,CAAC7rC,KAAK,CAAC,KAAK;EAC3D;EACAsuC,oBAAoBA,CAACtuC,KAAK,EAAE;IAC1B,MAAMquC,QAAQ,GAAGrnC,MAAM,CAACmC,IAAI,CAACnJ,KAAK,CAAC,CAAC2E,GAAG,CAACrC,IAAI,IAAI,GAAGA,IAAI,KAAKtC,KAAK,CAACsC,IAAI,CAAC,GAAG,CAAC,CAACF,IAAI,CAAC,GAAG,CAAC;IACrF,OAAOisC,QAAQ,CAAC7tC,MAAM,GAAG,CAAC,GAAG,GAAG,GAAG6tC,QAAQ,GAAG,EAAE;EAClD;EACAI,YAAYA,CAACC,OAAO,EAAE;IACpB,OAAO,aAAaA,OAAO,CAACC,OAAO,OAAOD,OAAO,CAACE,GAAG,MAAM;EAC7D;AACF,CAAC;AACD,MAAM5K,QAAQ,GAAG,IAAIkK,UAAU,CAAC,CAAC;AACjC,SAASW,WAAWA,CAAC/mC,KAAK,EAAE;EAC1B,OAAOA,KAAK,CAACnD,GAAG,CAACsQ,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC07B,QAAQ,CAAC,CAAC,CAAC5hC,IAAI,CAAC,EAAE,CAAC;AACzD;AACA,MAAM0sC,WAAW,CAAC;EAChB9uC,KAAK,GAAG,CAAC,CAAC;EACVsF,WAAWA,CAACypC,cAAc,EAAE;IAC1B/nC,MAAM,CAACmC,IAAI,CAAC4lC,cAAc,CAAC,CAACrsC,OAAO,CAAC2G,CAAC,IAAI;MACvC,IAAI,CAACrJ,KAAK,CAACqJ,CAAC,CAAC,GAAG2lC,SAAS,CAACD,cAAc,CAAC1lC,CAAC,CAAC,CAAC;IAC9C,CAAC,CAAC;EACJ;EACAf,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAACsmC,gBAAgB,CAAC,IAAI,CAAC;EACvC;AACF;AACA,MAAMS,OAAO,CAAC;EACZN,OAAO;EACPC,GAAG;EACHtpC,WAAWA,CAACqpC,OAAO,EAAEC,GAAG,EAAE;IACxB,IAAI,CAACD,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,GAAG,GAAGA,GAAG;EAChB;EACAtmC,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAACumC,YAAY,CAAC,IAAI,CAAC;EACnC;AACF;AACA,MAAMS,GAAG,CAAC;EACR5sC,IAAI;EACJwG,QAAQ;EACR9I,KAAK,GAAG,CAAC,CAAC;EACVsF,WAAWA,CAAChD,IAAI,EAAEysC,cAAc,GAAG,CAAC,CAAC,EAAEjmC,QAAQ,GAAG,EAAE,EAAE;IACpD,IAAI,CAACxG,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACwG,QAAQ,GAAGA,QAAQ;IACxB9B,MAAM,CAACmC,IAAI,CAAC4lC,cAAc,CAAC,CAACrsC,OAAO,CAAC2G,CAAC,IAAI;MACvC,IAAI,CAACrJ,KAAK,CAACqJ,CAAC,CAAC,GAAG2lC,SAAS,CAACD,cAAc,CAAC1lC,CAAC,CAAC,CAAC;IAC9C,CAAC,CAAC;EACJ;EACAf,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAACkmC,QAAQ,CAAC,IAAI,CAAC;EAC/B;AACF;AACA,IAAIe,MAAM,GAAG,MAAMjL,IAAI,CAAC;EACtB3hC,KAAK;EACL+C,WAAWA,CAAC8pC,cAAc,EAAE;IAC1B,IAAI,CAAC7sC,KAAK,GAAGysC,SAAS,CAACI,cAAc,CAAC;EACxC;EACA9mC,KAAKA,CAACJ,OAAO,EAAE;IACb,OAAOA,OAAO,CAACO,SAAS,CAAC,IAAI,CAAC;EAChC;AACF,CAAC;AACD,MAAM4mC,EAAE,SAASF,MAAM,CAAC;EACtB7pC,WAAWA,CAACgqC,EAAE,GAAG,CAAC,EAAE;IAClB,KAAK,CAAC,KAAK,IAAIv1B,KAAK,CAACu1B,EAAE,GAAG,CAAC,CAAC,CAACltC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;EAC3C;AACF;AACA,MAAMmtC,cAAc,GAAG,CAAC,CAAC,IAAI,EAAE,OAAO,CAAC,EAAE,CAAC,IAAI,EAAE,QAAQ,CAAC,EAAE,CAAC,IAAI,EAAE,QAAQ,CAAC,EAAE,CAAC,IAAI,EAAE,MAAM,CAAC,EAAE,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;AAC5G,SAASP,SAASA,CAACtmC,IAAI,EAAE;EACvB,OAAO6mC,cAAc,CAAC5jC,MAAM,CAAC,CAACjD,IAAI,EAAEuT,KAAK,KAAKvT,IAAI,CAAC1G,OAAO,CAACia,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,CAAC,EAAEvT,IAAI,CAAC;AACvF;AAEA,MAAM8mC,YAAY,GAAG,SAAS;AAC9B,MAAMC,aAAa,GAAG,eAAe;AACrC,MAAMC,YAAY,GAAG,KAAK;AAC1B,MAAMC,kBAAkB,GAAG,IAAI;AAC/B,MAAMC,YAAY,GAAG,IAAI;AACzB,MAAMC,aAAa,GAAG,QAAQ;AAC9B,MAAMC,QAAQ,GAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,MAAMC,GAAG,SAAS3C,UAAU,CAAC;EAC3B4C,KAAKA,CAACC,QAAQ,EAAEC,MAAM,EAAE;IACtB,MAAMC,cAAc,GAAG,IAAIC,cAAc,CAAC,CAAC;IAC3C,MAAMloC,OAAO,GAAG,IAAImoC,UAAU,CAAC,CAAC;IAChC,MAAMC,QAAQ,GAAG,IAAIpB,GAAG,CAACO,aAAa,CAAC;IACvCa,QAAQ,CAACtwC,KAAK,CAAC,SAAS,CAAC,GAAGwvC,YAAY;IACxCS,QAAQ,CAACvtC,OAAO,CAAC+E,OAAO,IAAI;MAC1B,MAAMzH,KAAK,GAAG;QACZ0H,EAAE,EAAED,OAAO,CAACC;MACd,CAAC;MACD,IAAID,OAAO,CAACgQ,WAAW,EAAE;QACvBzX,KAAK,CAAC,MAAM,CAAC,GAAGyH,OAAO,CAACgQ,WAAW;MACrC;MACA,IAAIhQ,OAAO,CAACM,OAAO,EAAE;QACnB/H,KAAK,CAAC,SAAS,CAAC,GAAGyH,OAAO,CAACM,OAAO;MACpC;MACA,IAAIwoC,UAAU,GAAG,EAAE;MACnB9oC,OAAO,CAACwrB,OAAO,CAACvwB,OAAO,CAACk0B,MAAM,IAAI;QAChC2Z,UAAU,CAAC9vC,IAAI,CAAC,IAAIyuC,GAAG,CAACW,aAAa,EAAE,CAAC,CAAC,EAAE,CAAC,IAAIV,MAAM,CAAC,GAAGvY,MAAM,CAACsV,QAAQ,IAAItV,MAAM,CAACuV,SAAS,GAAGvV,MAAM,CAACyV,OAAO,KAAKzV,MAAM,CAACuV,SAAS,GAAG,GAAG,GAAGvV,MAAM,CAACyV,OAAO,GAAG,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;MACvK,CAAC,CAAC;MACFiE,QAAQ,CAACxnC,QAAQ,CAACrI,IAAI,CAAC,IAAI4uC,EAAE,CAAC,CAAC,CAAC,EAAE,IAAIH,GAAG,CAACQ,YAAY,EAAE1vC,KAAK,EAAE,CAAC,GAAGuwC,UAAU,EAAE,GAAGroC,OAAO,CAACsoC,SAAS,CAAC/oC,OAAO,CAACK,KAAK,CAAC,CAAC,CAAC,CAAC;IACvH,CAAC,CAAC;IACFwoC,QAAQ,CAACxnC,QAAQ,CAACrI,IAAI,CAAC,IAAI4uC,EAAE,CAAC,CAAC,CAAC;IAChC,OAAOR,WAAW,CAAC,CAAC,IAAIC,WAAW,CAAC;MAClCnd,OAAO,EAAE,KAAK;MACd8e,QAAQ,EAAE;IACZ,CAAC,CAAC,EAAE,IAAIpB,EAAE,CAAC,CAAC,EAAE,IAAIJ,OAAO,CAACQ,aAAa,EAAEK,QAAQ,CAAC,EAAE,IAAIT,EAAE,CAAC,CAAC,EAAEc,cAAc,CAACO,kBAAkB,CAACJ,QAAQ,CAAC,EAAE,IAAIjB,EAAE,CAAC,CAAC,CAAC,CAAC;EACvH;EACAsB,IAAIA,CAACpe,OAAO,EAAEtZ,GAAG,EAAE;IACjB,MAAM,IAAIjY,KAAK,CAAC,aAAa,CAAC;EAChC;EACA4vC,MAAMA,CAACnpC,OAAO,EAAE;IACd,OAAOmpC,MAAM,CAACnpC,OAAO,CAAC;EACxB;EACA4lC,gBAAgBA,CAAC5lC,OAAO,EAAE;IACxB,OAAO,IAAI6lC,uBAAuB,CAAC7lC,OAAO,EAAEkmC,YAAY,CAAC;EAC3D;AACF;AACA,IAAI0C,UAAU,GAAG,MAAMlC,QAAQ,CAAC;EAC9B1lC,SAASA,CAACC,IAAI,EAAEC,OAAO,EAAE;IACvB,OAAO,CAAC,IAAIwmC,MAAM,CAACzmC,IAAI,CAACnG,KAAK,CAAC,CAAC;EACjC;EACAqG,cAAcA,CAACC,SAAS,EAAEF,OAAO,EAAE;IACjC,MAAMb,KAAK,GAAG,EAAE;IAChBe,SAAS,CAACC,QAAQ,CAACpG,OAAO,CAACuS,IAAI,IAAInN,KAAK,CAACrH,IAAI,CAAC,GAAGwU,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;IACnE,OAAOR,KAAK;EACd;EACAkB,QAAQA,CAACC,GAAG,EAAEN,OAAO,EAAE;IACrB,MAAMb,KAAK,GAAG,CAAC,IAAIqnC,MAAM,CAAC,IAAIlmC,GAAG,CAACwjC,qBAAqB,KAAKxjC,GAAG,CAACM,IAAI,IAAI,CAAC,CAAC;IAC1EvC,MAAM,CAACmC,IAAI,CAACF,GAAG,CAACG,KAAK,CAAC,CAAC1G,OAAO,CAACmI,CAAC,IAAI;MAClC/C,KAAK,CAACrH,IAAI,CAAC,IAAI0uC,MAAM,CAAC,GAAGtkC,CAAC,IAAI,CAAC,EAAE,GAAG5B,GAAG,CAACG,KAAK,CAACyB,CAAC,CAAC,CAACvC,KAAK,CAAC,IAAI,CAAC,EAAE,IAAI6mC,MAAM,CAAC,IAAI,CAAC,CAAC;IACjF,CAAC,CAAC;IACFrnC,KAAK,CAACrH,IAAI,CAAC,IAAI0uC,MAAM,CAAC,GAAG,CAAC,CAAC;IAC3B,OAAOrnC,KAAK;EACd;EACA0B,mBAAmBA,CAACC,EAAE,EAAEd,OAAO,EAAE;IAC/B,MAAMkoC,cAAc,GAAG,IAAI1B,MAAM,CAAC,IAAI1lC,EAAE,CAACxI,GAAG,GAAG,CAAC;IAChD,MAAM6vC,OAAO,GAAG,IAAI5B,GAAG,CAACU,YAAY,EAAE,CAAC,CAAC,EAAE,CAACiB,cAAc,CAAC,CAAC;IAC3D,MAAME,UAAU,GAAG,IAAI7B,GAAG,CAACS,kBAAkB,EAAE;MAC7CrtC,IAAI,EAAEmH,EAAE,CAACE;IACX,CAAC,EAAE,CAACmnC,OAAO,EAAED,cAAc,CAAC,CAAC;IAC7B,IAAIpnC,EAAE,CAACC,MAAM,EAAE;MACb,OAAO,CAACqnC,UAAU,CAAC;IACrB;IACA,MAAMC,cAAc,GAAG,IAAI7B,MAAM,CAAC,KAAK1lC,EAAE,CAACxI,GAAG,GAAG,CAAC;IACjD,MAAMgwC,OAAO,GAAG,IAAI/B,GAAG,CAACU,YAAY,EAAE,CAAC,CAAC,EAAE,CAACoB,cAAc,CAAC,CAAC;IAC3D,MAAME,UAAU,GAAG,IAAIhC,GAAG,CAACS,kBAAkB,EAAE;MAC7CrtC,IAAI,EAAEmH,EAAE,CAACG;IACX,CAAC,EAAE,CAACqnC,OAAO,EAAED,cAAc,CAAC,CAAC;IAC7B,OAAO,CAACD,UAAU,EAAE,GAAG,IAAI,CAACP,SAAS,CAAC/mC,EAAE,CAACX,QAAQ,CAAC,EAAEooC,UAAU,CAAC;EACjE;EACArnC,gBAAgBA,CAACJ,EAAE,EAAEd,OAAO,EAAE;IAC5B,MAAMwoC,mBAAmB,GAAG,IAAIhC,MAAM,CAAC,KAAK1lC,EAAE,CAAClH,KAAK,IAAI,CAAC;IACzD,MAAM6uC,KAAK,GAAG,IAAIlC,GAAG,CAACU,YAAY,EAAE,CAAC,CAAC,EAAE,CAACuB,mBAAmB,CAAC,CAAC;IAC9D,OAAO,CAAC,IAAIjC,GAAG,CAACS,kBAAkB,EAAE;MAClCrtC,IAAI,EAAEmH,EAAE,CAACnH;IACX,CAAC,EAAE,CAAC8uC,KAAK,EAAED,mBAAmB,CAAC,CAAC,CAAC;EACnC;EACApnC,qBAAqBA,CAACN,EAAE,EAAEd,OAAO,EAAE;IACjC,MAAM0oC,WAAW,GAAG,IAAIlC,MAAM,CAAC,IAAI1lC,EAAE,CAACnH,IAAI,EAAE,CAAC;IAC7C,MAAMwuC,OAAO,GAAG,IAAI5B,GAAG,CAACU,YAAY,EAAE,CAAC,CAAC,EAAE,CAACyB,WAAW,CAAC,CAAC;IACxD,MAAMN,UAAU,GAAG,IAAI7B,GAAG,CAACS,kBAAkB,EAAE;MAC7CrtC,IAAI,EAAEmH,EAAE,CAACE;IACX,CAAC,EAAE,CAACmnC,OAAO,EAAEO,WAAW,CAAC,CAAC;IAC1B,MAAMC,WAAW,GAAG,IAAInC,MAAM,CAAC,GAAG,CAAC;IACnC,MAAM8B,OAAO,GAAG,IAAI/B,GAAG,CAACU,YAAY,EAAE,CAAC,CAAC,EAAE,CAAC0B,WAAW,CAAC,CAAC;IACxD,MAAMJ,UAAU,GAAG,IAAIhC,GAAG,CAACS,kBAAkB,EAAE;MAC7CrtC,IAAI,EAAEmH,EAAE,CAACG;IACX,CAAC,EAAE,CAACqnC,OAAO,EAAEK,WAAW,CAAC,CAAC;IAC1B,OAAO,CAACP,UAAU,EAAE,GAAG,IAAI,CAACP,SAAS,CAAC/mC,EAAE,CAACX,QAAQ,CAAC,EAAEooC,UAAU,CAAC;EACjE;EACApnC,mBAAmBA,CAACL,EAAE,EAAEd,OAAO,EAAE;IAC/B,MAAM4oC,aAAa,GAAG9nC,EAAE,CAAClH,KAAK,CAAC+G,UAAU;IACzC,MAAMkoC,OAAO,GAAG/nC,EAAE,CAAClH,KAAK,CAACgH,IAAI;IAC7B,MAAMkoC,QAAQ,GAAGzqC,MAAM,CAACmC,IAAI,CAACM,EAAE,CAAClH,KAAK,CAAC6G,KAAK,CAAC,CAACzE,GAAG,CAACpC,KAAK,IAAIA,KAAK,GAAG,QAAQ,CAAC,CAACH,IAAI,CAAC,GAAG,CAAC;IACrF,MAAMsvC,SAAS,GAAG,IAAIvC,MAAM,CAAC,IAAIoC,aAAa,KAAKC,OAAO,KAAKC,QAAQ,GAAG,CAAC;IAC3E,MAAML,KAAK,GAAG,IAAIlC,GAAG,CAACU,YAAY,EAAE,CAAC,CAAC,EAAE,CAAC8B,SAAS,CAAC,CAAC;IACpD,OAAO,CAAC,IAAIxC,GAAG,CAACS,kBAAkB,EAAE;MAClCrtC,IAAI,EAAEmH,EAAE,CAACnH;IACX,CAAC,EAAE,CAAC8uC,KAAK,EAAEM,SAAS,CAAC,CAAC,CAAC;EACzB;EACAlB,SAASA,CAAC1oC,KAAK,EAAE;IACf,OAAO,EAAE,CAACzF,MAAM,CAAC,GAAGyF,KAAK,CAACnD,GAAG,CAACsQ,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;EAC1D;AACF,CAAC;AACD,SAASsoC,MAAMA,CAACnpC,OAAO,EAAE;EACvB,OAAOO,aAAa,CAACP,OAAO,CAAC;AAC/B;AACA,MAAM2oC,cAAc,CAAC;EACnBM,kBAAkBA,CAACz7B,IAAI,EAAE;IACvBA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC;IAChB,OAAO2M,IAAI;EACb;EACAm5B,QAAQA,CAACntC,GAAG,EAAE;IACZ,IAAIA,GAAG,CAACqB,IAAI,KAAKqtC,kBAAkB,EAAE;MACnC,IAAI,CAAC1uC,GAAG,CAAC6H,QAAQ,IAAI7H,GAAG,CAAC6H,QAAQ,CAACtI,MAAM,IAAI,CAAC,EAAE;QAC7C,MAAMmxC,MAAM,GAAG,IAAIxC,MAAM,CAACluC,GAAG,CAACjB,KAAK,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC;QACrDiB,GAAG,CAAC6H,QAAQ,GAAG,CAAC,IAAIomC,GAAG,CAACU,YAAY,EAAE,CAAC,CAAC,EAAE,CAAC+B,MAAM,CAAC,CAAC,CAAC;MACtD;IACF,CAAC,MAAM,IAAI1wC,GAAG,CAAC6H,QAAQ,EAAE;MACvB7H,GAAG,CAAC6H,QAAQ,CAACpG,OAAO,CAACuS,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC;IAChD;EACF;EACAG,SAASA,CAACC,IAAI,EAAE,CAAC;EACjB8lC,gBAAgBA,CAAC3C,IAAI,EAAE,CAAC;EACxB4C,YAAYA,CAACC,OAAO,EAAE,CAAC;AACzB;AACA,SAASf,YAAYA,CAACC,YAAY,EAAE;EAClC,OAAOA,YAAY,CAACle,WAAW,CAAC,CAAC,CAAC1tB,OAAO,CAAC,aAAa,EAAE,GAAG,CAAC;AAC/D;AAEA,MAAM4vC,SAAS,GAAG,MAAM;AACxB,MAAMC,gBAAgB,GAAG,OAAO;AAChC,MAAMC,mBAAmB,GAAG,MAAM;AAClC,SAASC,eAAeA,CAACzvC,IAAI,EAAE;EAC7B,OAAOA,IAAI,KAAKsvC,SAAS,IAAItvC,IAAI,CAACsvB,UAAU,CAACigB,gBAAgB,CAAC;AAChE;AACA,SAASG,YAAYA,CAAC/8B,IAAI,EAAE;EAC1B,OAAOA,IAAI,CAACjV,KAAK,CAACiyC,IAAI,CAACxwC,IAAI,IAAIswC,eAAe,CAACtwC,IAAI,CAACa,IAAI,CAAC,CAAC;AAC5D;AACA,SAAS4vC,kBAAkBA,CAACzqC,OAAO,EAAE;EACnC,OAAOA,OAAO,CAACK,KAAK,CAAC,CAAC,CAAC;AACzB;AACA,SAASqqC,+BAA+BA,CAACnhC,MAAM,GAAG,CAAC,CAAC,EAAEohC,YAAY,EAAE;EAClE,MAAMC,OAAO,GAAG,CAAC,CAAC;EAClB,IAAIrhC,MAAM,IAAIhK,MAAM,CAACmC,IAAI,CAAC6H,MAAM,CAAC,CAACxQ,MAAM,EAAE;IACxCwG,MAAM,CAACmC,IAAI,CAAC6H,MAAM,CAAC,CAACtO,OAAO,CAACmO,GAAG,IAAIwhC,OAAO,CAACC,yBAAyB,CAACzhC,GAAG,EAAEuhC,YAAY,CAAC,CAAC,GAAGphC,MAAM,CAACH,GAAG,CAAC,CAAC;EACzG;EACA,OAAOwhC,OAAO;AAChB;AACA,SAASC,yBAAyBA,CAAChwC,IAAI,EAAE8vC,YAAY,GAAG,IAAI,EAAE;EAC5D,MAAMrE,UAAU,GAAGJ,YAAY,CAACrrC,IAAI,CAAC;EACrC,IAAI,CAAC8vC,YAAY,EAAE;IACjB,OAAOrE,UAAU;EACnB;EACA,MAAMwE,MAAM,GAAGxE,UAAU,CAACzc,KAAK,CAAC,GAAG,CAAC;EACpC,IAAIihB,MAAM,CAAC/xC,MAAM,KAAK,CAAC,EAAE;IACvB,OAAO8B,IAAI,CAACE,WAAW,CAAC,CAAC;EAC3B;EACA,IAAIgwC,OAAO;EACX,IAAI,OAAO,CAAC3gB,IAAI,CAAC0gB,MAAM,CAACA,MAAM,CAAC/xC,MAAM,GAAG,CAAC,CAAC,CAAC,EAAE;IAC3CgyC,OAAO,GAAGD,MAAM,CAAC5c,GAAG,CAAC,CAAC;EACxB;EACA,IAAIld,GAAG,GAAG85B,MAAM,CAACE,KAAK,CAAC,CAAC,CAACjwC,WAAW,CAAC,CAAC;EACtC,IAAI+vC,MAAM,CAAC/xC,MAAM,EAAE;IACjBiY,GAAG,IAAI85B,MAAM,CAAC5tC,GAAG,CAACkG,CAAC,IAAIA,CAAC,CAAC/I,MAAM,CAAC,CAAC,CAAC,CAAC4tB,WAAW,CAAC,CAAC,GAAG7kB,CAAC,CAACzJ,KAAK,CAAC,CAAC,CAAC,CAACoB,WAAW,CAAC,CAAC,CAAC,CAACJ,IAAI,CAAC,EAAE,CAAC;EACvF;EACA,OAAOowC,OAAO,GAAG,GAAG/5B,GAAG,IAAI+5B,OAAO,EAAE,GAAG/5B,GAAG;AAC5C;AAEA,MAAMi6B,6BAA6B,GAAG,MAAM;AAC5C,MAAMC,cAAc,GAAG,IAAI;AAC3B,MAAMC,YAAY,GAAG,KAAK;AAC1B,MAAMC,YAAY,GAAG,IAAI;AACzB,SAASC,kBAAkBA,CAACC,aAAa,EAAEzwC,IAAI,EAAE;EAC/C,IAAIoJ,IAAI,GAAG,IAAI;EACf,OAAO,MAAM;IACX,IAAI,CAACA,IAAI,EAAE;MACTqnC,aAAa,CAAC,IAAI74B,cAAc,CAACy4B,cAAc,EAAEtiB,SAAS,EAAErhB,YAAY,CAAC,CAAC;MAC1EtD,IAAI,GAAGuS,QAAQ,CAAC3b,IAAI,CAAC;IACvB;IACA,OAAOoJ,IAAI;EACb,CAAC;AACH;AACA,SAASsnC,SAASA,CAACzwC,KAAK,EAAE;EACxB,IAAIwX,KAAK,CAACC,OAAO,CAACzX,KAAK,CAAC,EAAE;IACxB,OAAOic,UAAU,CAACjc,KAAK,CAACoC,GAAG,CAACquC,SAAS,CAAC,CAAC;EACzC;EACA,OAAO9zB,OAAO,CAAC3c,KAAK,EAAE2M,aAAa,CAAC;AACtC;AACA,SAAS+jC,0CAA0CA,CAACtuC,GAAG,EAAEuuC,SAAS,EAAE;EAClE,MAAM/pC,IAAI,GAAGnC,MAAM,CAACmsC,mBAAmB,CAACxuC,GAAG,CAAC;EAC5C,IAAIwE,IAAI,CAAC3I,MAAM,KAAK,CAAC,EAAE;IACrB,OAAO,IAAI;EACb;EACA,OAAOke,UAAU,CAACvV,IAAI,CAACxE,GAAG,CAACkM,GAAG,IAAI;IAChC,MAAMtO,KAAK,GAAGoC,GAAG,CAACkM,GAAG,CAAC;IACtB,IAAIuiC,YAAY;IAChB,IAAIrF,UAAU;IACd,IAAIsF,YAAY;IAChB,IAAIC,eAAe;IACnB,IAAI,OAAO/wC,KAAK,KAAK,QAAQ,EAAE;MAC7B6wC,YAAY,GAAGviC,GAAG;MAClBwiC,YAAY,GAAGxiC,GAAG;MAClBk9B,UAAU,GAAGxrC,KAAK;MAClB+wC,eAAe,GAAGN,SAAS,CAACjF,UAAU,CAAC;IACzC,CAAC,MAAM;MACLsF,YAAY,GAAGxiC,GAAG;MAClBuiC,YAAY,GAAG7wC,KAAK,CAACgxC,iBAAiB;MACtCxF,UAAU,GAAGxrC,KAAK,CAACixC,mBAAmB;MACtC,MAAMC,sBAAsB,GAAG1F,UAAU,KAAKqF,YAAY;MAC1D,MAAMM,0BAA0B,GAAGnxC,KAAK,CAACoxC,iBAAiB,KAAK,IAAI;MACnE,IAAI59B,KAAK,GAAG/P,UAAU,CAAC8H,IAAI;MAC3B,IAAIvL,KAAK,CAACqxC,QAAQ,EAAE;QAClB79B,KAAK,IAAI/P,UAAU,CAAC6tC,WAAW;MACjC;MACA,IAAIH,0BAA0B,EAAE;QAC9B39B,KAAK,IAAI/P,UAAU,CAAC8tC,0BAA0B;MAChD;MACA,IAAIZ,SAAS,KAAKO,sBAAsB,IAAIC,0BAA0B,IAAI39B,KAAK,KAAK/P,UAAU,CAAC8H,IAAI,CAAC,EAAE;QACpG,MAAMpM,MAAM,GAAG,CAACwd,OAAO,CAACnJ,KAAK,CAAC,EAAEi9B,SAAS,CAACjF,UAAU,CAAC,CAAC;QACtD,IAAI0F,sBAAsB,IAAIC,0BAA0B,EAAE;UACxDhyC,MAAM,CAACjB,IAAI,CAACuyC,SAAS,CAACI,YAAY,CAAC,CAAC;UACpC,IAAIM,0BAA0B,EAAE;YAC9BhyC,MAAM,CAACjB,IAAI,CAAC8B,KAAK,CAACoxC,iBAAiB,CAAC;UACtC;QACF;QACAL,eAAe,GAAG90B,UAAU,CAAC9c,MAAM,CAAC;MACtC,CAAC,MAAM;QACL4xC,eAAe,GAAGN,SAAS,CAACjF,UAAU,CAAC;MACzC;IACF;IACA,OAAO;MACLl9B,GAAG,EAAEwiC,YAAY;MACjBx3B,MAAM,EAAE62B,6BAA6B,CAAC7gB,IAAI,CAACwhB,YAAY,CAAC;MACxD9wC,KAAK,EAAE+wC;IACT,CAAC;EACH,CAAC,CAAC,CAAC;AACL;AACA,MAAMS,aAAa,CAAC;EAClBt1B,MAAM,GAAG,EAAE;EACXja,GAAGA,CAACqM,GAAG,EAAEtO,KAAK,EAAE;IACd,IAAIA,KAAK,EAAE;MACT,MAAMyxC,QAAQ,GAAG,IAAI,CAACv1B,MAAM,CAACw1B,IAAI,CAAC1xC,KAAK,IAAIA,KAAK,CAACsO,GAAG,KAAKA,GAAG,CAAC;MAC7D,IAAImjC,QAAQ,EAAE;QACZA,QAAQ,CAACzxC,KAAK,GAAGA,KAAK;MACxB,CAAC,MAAM;QACL,IAAI,CAACkc,MAAM,CAAChe,IAAI,CAAC;UACfoQ,GAAG,EAAEA,GAAG;UACRtO,KAAK;UACLsZ,MAAM,EAAE;QACV,CAAC,CAAC;MACJ;IACF;EACF;EACAq4B,YAAYA,CAAA,EAAG;IACb,OAAOx1B,UAAU,CAAC,IAAI,CAACD,MAAM,CAAC;EAChC;AACF;AACA,SAAS01B,yBAAyBA,CAACl/B,IAAI,EAAE;EACvC,MAAMxO,WAAW,GAAGwO,IAAI,YAAYgwB,SAAS,GAAGhwB,IAAI,CAAC3S,IAAI,GAAG,aAAa;EACzE,MAAM6iC,UAAU,GAAGiP,4BAA4B,CAACn/B,IAAI,CAAC;EACrD,MAAMvU,WAAW,GAAG,IAAIb,WAAW,CAAC,CAAC;EACrC,MAAMw0C,eAAe,GAAGjR,WAAW,CAAC38B,WAAW,CAAC,CAAC,CAAC,CAAC;EACnD/F,WAAW,CAACY,UAAU,CAAC+yC,eAAe,CAAC;EACvCrtC,MAAM,CAACmsC,mBAAmB,CAAChO,UAAU,CAAC,CAACziC,OAAO,CAACJ,IAAI,IAAI;IACrD,MAAMgyC,QAAQ,GAAGlR,WAAW,CAAC9gC,IAAI,CAAC,CAAC,CAAC,CAAC;IACrC,MAAMC,KAAK,GAAG4iC,UAAU,CAAC7iC,IAAI,CAAC;IAC9B5B,WAAW,CAACS,YAAY,CAACmzC,QAAQ,EAAE/xC,KAAK,CAAC;IACzC,IAAID,IAAI,CAACE,WAAW,CAAC,CAAC,KAAK,OAAO,EAAE;MAClC,MAAMgE,OAAO,GAAGjE,KAAK,CAAC2tB,IAAI,CAAC,CAAC,CAACoB,KAAK,CAAC,KAAK,CAAC;MACzC9qB,OAAO,CAAC9D,OAAO,CAAC0B,SAAS,IAAI1D,WAAW,CAACW,YAAY,CAAC+C,SAAS,CAAC,CAAC;IACnE;EACF,CAAC,CAAC;EACF,OAAO1D,WAAW;AACpB;AACA,SAAS0zC,4BAA4BA,CAACG,OAAO,EAAE;EAC7C,MAAMC,aAAa,GAAG,CAAC,CAAC;EACxB,IAAID,OAAO,YAAYpK,QAAQ,IAAIoK,OAAO,CAAC90B,OAAO,KAAK,aAAa,EAAE;IACpE80B,OAAO,CAACnK,aAAa,CAAC1nC,OAAO,CAAC2F,CAAC,IAAImsC,aAAa,CAACnsC,CAAC,CAAC/F,IAAI,CAAC,GAAG,EAAE,CAAC;EAChE,CAAC,MAAM;IACLiyC,OAAO,CAACpP,UAAU,CAACziC,OAAO,CAAC2F,CAAC,IAAI;MAC9B,IAAI,CAAC0pC,eAAe,CAAC1pC,CAAC,CAAC/F,IAAI,CAAC,EAAE;QAC5BkyC,aAAa,CAACnsC,CAAC,CAAC/F,IAAI,CAAC,GAAG+F,CAAC,CAAC9F,KAAK;MACjC;IACF,CAAC,CAAC;IACFgyC,OAAO,CAACnP,MAAM,CAAC1iC,OAAO,CAACd,CAAC,IAAI;MAC1B,IAAIA,CAAC,CAAC2H,IAAI,KAAKw5B,WAAW,CAAC0R,QAAQ,IAAI7yC,CAAC,CAAC2H,IAAI,KAAKw5B,WAAW,CAAC2R,MAAM,EAAE;QACpEF,aAAa,CAAC5yC,CAAC,CAACU,IAAI,CAAC,GAAG,EAAE;MAC5B;IACF,CAAC,CAAC;IACFiyC,OAAO,CAAClP,OAAO,CAAC3iC,OAAO,CAACiyC,CAAC,IAAI;MAC3BH,aAAa,CAACG,CAAC,CAACryC,IAAI,CAAC,GAAG,EAAE;IAC5B,CAAC,CAAC;EACJ;EACA,OAAOkyC,aAAa;AACtB;AAEA,SAASI,iBAAiBA,CAAC9a,IAAI,EAAE+a,kBAAkB,EAAE;EACnD,IAAInzC,MAAM,GAAG,IAAI;EACjB,MAAMozC,WAAW,GAAG;IAClBxyC,IAAI,EAAEw3B,IAAI,CAACx3B,IAAI;IACfiH,IAAI,EAAEuwB,IAAI,CAACvwB,IAAI;IACfkyB,iBAAiB,EAAE3B,IAAI,CAAC2B,iBAAiB;IACzCrB,IAAI,EAAE,EAAE;IACRE,MAAM,EAAElzB,aAAa,CAACw1B;EACxB,CAAC;EACD,IAAI9C,IAAI,CAACib,QAAQ,KAAK1kB,SAAS,EAAE;IAC/B,MAAM2kB,cAAc,GAAGlb,IAAI,CAACib,QAAQ,CAACzrC,UAAU,CAAC6G,YAAY,CAAC2pB,IAAI,CAACvwB,IAAI,CAAChH,KAAK,CAAC;IAC7E,IAAI63B,IAAI,GAAG/J,SAAS;IACpB,IAAIyJ,IAAI,CAACM,IAAI,KAAK/J,SAAS,EAAE;MAC3B+J,IAAI,GAAGN,IAAI,CAACM,IAAI;IAClB;IACA,IAAIA,IAAI,KAAK/J,SAAS,EAAE;MACtB3uB,MAAM,GAAGm4B,sBAAsB,CAAC;QAC9B,GAAGib,WAAW;QACd7Z,QAAQ,EAAEnB,IAAI,CAACib,QAAQ,CAACzrC,UAAU;QAClCuxB,YAAY,EAAET,IAAI;QAClBW,YAAY,EAAEnB,qBAAqB,CAACoB;MACtC,CAAC,CAAC;IACJ,CAAC,MAAM,IAAIga,cAAc,EAAE;MACzBtzC,MAAM,GAAGm4B,sBAAsB,CAACib,WAAW,CAAC;IAC9C,CAAC,MAAM;MACLpzC,MAAM,GAAG;QACP+X,UAAU,EAAE,EAAE;QACdnQ,UAAU,EAAE2rC,iBAAiB,CAACnb,IAAI,CAACvwB,IAAI,CAAChH,KAAK,EAAEu3B,IAAI,CAACib,QAAQ,CAACzrC,UAAU,EAAEurC,kBAAkB;MAC7F,CAAC;IACH;EACF,CAAC,MAAM,IAAI/a,IAAI,CAACob,UAAU,KAAK7kB,SAAS,EAAE;IACxC,IAAIyJ,IAAI,CAACM,IAAI,KAAK/J,SAAS,EAAE;MAC3B3uB,MAAM,GAAGm4B,sBAAsB,CAAC;QAC9B,GAAGib,WAAW;QACd7Z,QAAQ,EAAEnB,IAAI,CAACob,UAAU;QACzBra,YAAY,EAAEf,IAAI,CAACM,IAAI,IAAI,EAAE;QAC7BW,YAAY,EAAEnB,qBAAqB,CAACxzB;MACtC,CAAC,CAAC;IACJ,CAAC,MAAM;MACL1E,MAAM,GAAG;QACP+X,UAAU,EAAE,EAAE;QACdnQ,UAAU,EAAEuV,OAAO,CAAC,EAAE,EAAEib,IAAI,CAACob,UAAU,CAACnkC,MAAM,CAAC,EAAE,CAAC;MACpD,CAAC;IACH;EACF,CAAC,MAAM,IAAI+oB,IAAI,CAACqb,QAAQ,KAAK9kB,SAAS,EAAE;IACtC3uB,MAAM,GAAGm4B,sBAAsB,CAAC;MAC9B,GAAGib,WAAW;MACdxrC,UAAU,EAAEwwB,IAAI,CAACqb,QAAQ,CAAC7rC;IAC5B,CAAC,CAAC;EACJ,CAAC,MAAM,IAAIwwB,IAAI,CAACsb,WAAW,KAAK/kB,SAAS,EAAE;IACzC3uB,MAAM,GAAGm4B,sBAAsB,CAAC;MAC9B,GAAGib,WAAW;MACdxrC,UAAU,EAAE4U,UAAU,CAACwE,WAAW,CAACwH,MAAM,CAAC,CAACnZ,MAAM,CAAC,CAAC+oB,IAAI,CAACsb,WAAW,CAAC9rC,UAAU,CAAC;IACjF,CAAC,CAAC;EACJ,CAAC,MAAM;IACL5H,MAAM,GAAG;MACP+X,UAAU,EAAE,EAAE;MACdnQ,UAAU,EAAE2rC,iBAAiB,CAACnb,IAAI,CAACvwB,IAAI,CAAChH,KAAK,EAAEu3B,IAAI,CAACvwB,IAAI,CAAChH,KAAK,EAAEsyC,kBAAkB;IACpF,CAAC;EACH;EACA,MAAMhkB,KAAK,GAAGiJ,IAAI,CAACvwB,IAAI,CAAChH,KAAK;EAC7B,MAAM8yC,eAAe,GAAG,IAAItB,aAAa,CAAC,CAAC;EAC3CsB,eAAe,CAAC7wC,GAAG,CAAC,OAAO,EAAEqsB,KAAK,CAAC;EACnCwkB,eAAe,CAAC7wC,GAAG,CAAC,SAAS,EAAE9C,MAAM,CAAC4H,UAAU,CAAC;EACjD,IAAIwwB,IAAI,CAACwb,UAAU,CAAChsC,UAAU,CAAC/G,KAAK,KAAK,IAAI,EAAE;IAC7C8yC,eAAe,CAAC7wC,GAAG,CAAC,YAAY,EAAEk1B,oCAAoC,CAACI,IAAI,CAACwb,UAAU,CAAC,CAAC;EAC1F;EACA,MAAMhsC,UAAU,GAAG4U,UAAU,CAACwE,WAAW,CAACkI,kBAAkB,CAAC,CAAC7Z,MAAM,CAAC,CAACskC,eAAe,CAACnB,YAAY,CAAC,CAAC,CAAC,EAAE7jB,SAAS,EAAE,IAAI,CAAC;EACvH,OAAO;IACL/mB,UAAU;IACVC,IAAI,EAAEgsC,oBAAoB,CAACzb,IAAI,CAAC;IAChCrgB,UAAU,EAAE/X,MAAM,CAAC+X;EACrB,CAAC;AACH;AACA,SAAS87B,oBAAoBA,CAACzb,IAAI,EAAE;EAClC,OAAO,IAAIzrB,cAAc,CAAC6P,UAAU,CAACwE,WAAW,CAACoI,qBAAqB,EAAE,CAACyN,kBAAkB,CAACuB,IAAI,CAACvwB,IAAI,CAACA,IAAI,EAAEuwB,IAAI,CAAC2B,iBAAiB,CAAC,CAAC,CAAC,CAAC;AACxI;AACA,SAASwZ,iBAAiBA,CAAC1rC,IAAI,EAAEisC,OAAO,EAAEC,iBAAiB,EAAE;EAC3D,IAAIlsC,IAAI,CAAC0L,IAAI,KAAKugC,OAAO,CAACvgC,IAAI,EAAE;IAC9B,OAAOugC,OAAO,CAAC7kC,IAAI,CAAC,MAAM,CAAC;EAC7B;EACA,IAAI,CAAC8kC,iBAAiB,EAAE;IACtB,OAAOC,qBAAqB,CAACF,OAAO,CAAC;EACvC;EACA,MAAMG,aAAa,GAAGz3B,UAAU,CAACwE,WAAW,CAAC+H,iBAAiB,CAAC,CAAC1Z,MAAM,CAAC,CAACykC,OAAO,CAAC,CAAC;EACjF,OAAOE,qBAAqB,CAACC,aAAa,CAAC;AAC7C;AACA,SAASD,qBAAqBA,CAACnsC,IAAI,EAAE;EACnC,MAAMwwB,CAAC,GAAG,IAAIzgB,OAAO,CAAC,mBAAmB,EAAEtK,YAAY,CAAC;EACxD,OAAO6P,OAAO,CAAC,CAACkb,CAAC,CAAC,EAAExwB,IAAI,CAACoH,IAAI,CAAC,MAAM,CAAC,CAACI,MAAM,CAAC,CAACkN,QAAQ,CAAC8b,CAAC,CAACz3B,IAAI,CAAC,CAAC,CAAC,CAAC;AACnE;AAEA,MAAMszC,IAAI,GAAG,CAAC;AACd,MAAMC,OAAO,GAAG,CAAC;AACjB,MAAMC,IAAI,GAAG,CAAC;AACd,MAAMC,GAAG,GAAG,EAAE;AACd,MAAMC,KAAK,GAAG,EAAE;AAChB,MAAMC,GAAG,GAAG,EAAE;AACd,MAAMC,GAAG,GAAG,EAAE;AACd,MAAMC,MAAM,GAAG,EAAE;AACjB,MAAMC,KAAK,GAAG,EAAE;AAChB,MAAMC,GAAG,GAAG,EAAE;AACd,MAAMC,KAAK,GAAG,EAAE;AAChB,MAAMC,EAAE,GAAG,EAAE;AACb,MAAMC,QAAQ,GAAG,EAAE;AACnB,MAAMC,UAAU,GAAG,EAAE;AACrB,MAAMC,GAAG,GAAG,EAAE;AACd,MAAMC,OAAO,GAAG,EAAE;AAClB,MAAMC,OAAO,GAAG,EAAE;AAClB,MAAMC,KAAK,GAAG,EAAE;AAChB,MAAMC,KAAK,GAAG,EAAE;AAChB,MAAMC,MAAM,GAAG,EAAE;AACjB,MAAMC,MAAM,GAAG,EAAE;AACjB,MAAMC,OAAO,GAAG,EAAE;AAClB,MAAMC,MAAM,GAAG,EAAE;AACjB,MAAMC,MAAM,GAAG,EAAE;AACjB,MAAMC,UAAU,GAAG,EAAE;AACrB,MAAMC,GAAG,GAAG,EAAE;AACd,MAAMC,GAAG,GAAG,EAAE;AACd,MAAMC,GAAG,GAAG,EAAE;AACd,MAAMC,SAAS,GAAG,EAAE;AACpB,MAAMC,EAAE,GAAG,EAAE;AACb,MAAMC,EAAE,GAAG,EAAE;AACb,MAAMC,EAAE,GAAG,EAAE;AACb,MAAMC,EAAE,GAAG,EAAE;AACb,MAAMC,EAAE,GAAG,EAAE;AACb,MAAMC,EAAE,GAAG,EAAE;AACb,MAAMC,EAAE,GAAG,EAAE;AACb,MAAMC,EAAE,GAAG,EAAE;AACb,MAAMC,SAAS,GAAG,EAAE;AACpB,MAAMC,UAAU,GAAG,EAAE;AACrB,MAAMC,SAAS,GAAG,EAAE;AACpB,MAAMC,MAAM,GAAG,EAAE;AACjB,MAAMC,EAAE,GAAG,EAAE;AACb,MAAMC,EAAE,GAAG,EAAE;AACb,MAAMC,EAAE,GAAG,EAAE;AACb,MAAMC,EAAE,GAAG,GAAG;AACd,MAAMC,EAAE,GAAG,GAAG;AACd,MAAMC,EAAE,GAAG,GAAG;AACd,MAAMC,EAAE,GAAG,GAAG;AACd,MAAMC,EAAE,GAAG,GAAG;AACd,MAAMC,EAAE,GAAG,GAAG;AACd,MAAMC,EAAE,GAAG,GAAG;AACd,MAAMC,EAAE,GAAG,GAAG;AACd,MAAMC,EAAE,GAAG,GAAG;AACd,MAAMC,OAAO,GAAG,GAAG;AACnB,MAAMC,IAAI,GAAG,GAAG;AAChB,MAAMC,OAAO,GAAG,GAAG;AACnB,MAAMC,KAAK,GAAG,GAAG;AACjB,MAAMC,GAAG,GAAG,EAAE;AACd,MAAMC,GAAG,GAAG,EAAE;AACd,SAASC,YAAYA,CAACC,IAAI,EAAE;EAC1B,OAAOA,IAAI,IAAI1D,IAAI,IAAI0D,IAAI,IAAIrD,MAAM,IAAIqD,IAAI,IAAIJ,KAAK;AACxD;AACA,SAASK,OAAOA,CAACD,IAAI,EAAE;EACrB,OAAO/B,EAAE,IAAI+B,IAAI,IAAIA,IAAI,IAAI7B,EAAE;AACjC;AACA,SAAS+B,aAAaA,CAACF,IAAI,EAAE;EAC3B,OAAOA,IAAI,IAAIlB,EAAE,IAAIkB,IAAI,IAAIR,EAAE,IAAIQ,IAAI,IAAI5B,EAAE,IAAI4B,IAAI,IAAIxB,EAAE;AAC7D;AACA,SAAS2B,eAAeA,CAACH,IAAI,EAAE;EAC7B,OAAOA,IAAI,IAAIlB,EAAE,IAAIkB,IAAI,IAAIf,EAAE,IAAIe,IAAI,IAAI5B,EAAE,IAAI4B,IAAI,IAAI1B,EAAE,IAAI2B,OAAO,CAACD,IAAI,CAAC;AAC9E;AACA,SAASI,SAASA,CAACJ,IAAI,EAAE;EACvB,OAAOA,IAAI,KAAKzD,GAAG,IAAIyD,IAAI,KAAKtD,GAAG;AACrC;AACA,SAAS2D,YAAYA,CAACL,IAAI,EAAE;EAC1B,OAAO/B,EAAE,IAAI+B,IAAI,IAAIA,IAAI,IAAI9B,EAAE;AACjC;AACA,SAASoC,OAAOA,CAACN,IAAI,EAAE;EACrB,OAAOA,IAAI,KAAK9C,GAAG,IAAI8C,IAAI,KAAKnD,GAAG,IAAImD,IAAI,KAAKF,GAAG;AACrD;AAEA,MAAMS,aAAa,CAAC;EAClB9nB,IAAI;EACJ+nB,MAAM;EACNzjB,IAAI;EACJS,GAAG;EACH1xB,WAAWA,CAAC2sB,IAAI,EAAE+nB,MAAM,EAAEzjB,IAAI,EAAES,GAAG,EAAE;IACnC,IAAI,CAAC/E,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC+nB,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACzjB,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACS,GAAG,GAAGA,GAAG;EAChB;EACAv0B,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI,CAACu3C,MAAM,IAAI,IAAI,GAAG,GAAG,IAAI,CAAC/nB,IAAI,CAAChZ,GAAG,IAAI,IAAI,CAACsd,IAAI,IAAI,IAAI,CAACS,GAAG,EAAE,GAAG,IAAI,CAAC/E,IAAI,CAAChZ,GAAG;EAC1F;EACAghC,MAAMA,CAACC,KAAK,EAAE;IACZ,MAAMtjB,MAAM,GAAG,IAAI,CAAC3E,IAAI,CAACM,OAAO;IAChC,MAAM9nB,GAAG,GAAGmsB,MAAM,CAACp2B,MAAM;IACzB,IAAIw5C,MAAM,GAAG,IAAI,CAACA,MAAM;IACxB,IAAIzjB,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAIS,GAAG,GAAG,IAAI,CAACA,GAAG;IAClB,OAAOgjB,MAAM,GAAG,CAAC,IAAIE,KAAK,GAAG,CAAC,EAAE;MAC9BF,MAAM,EAAE;MACRE,KAAK,EAAE;MACP,MAAMC,EAAE,GAAGvjB,MAAM,CAACjG,UAAU,CAACqpB,MAAM,CAAC;MACpC,IAAIG,EAAE,IAAIpE,GAAG,EAAE;QACbxf,IAAI,EAAE;QACN,MAAM6jB,SAAS,GAAGxjB,MAAM,CAACyjB,SAAS,CAAC,CAAC,EAAEL,MAAM,GAAG,CAAC,CAAC,CAACM,WAAW,CAAC3qC,MAAM,CAAC4qC,YAAY,CAACxE,GAAG,CAAC,CAAC;QACvF/e,GAAG,GAAGojB,SAAS,GAAG,CAAC,GAAGJ,MAAM,GAAGI,SAAS,GAAGJ,MAAM;MACnD,CAAC,MAAM;QACLhjB,GAAG,EAAE;MACP;IACF;IACA,OAAOgjB,MAAM,GAAGvvC,GAAG,IAAIyvC,KAAK,GAAG,CAAC,EAAE;MAChC,MAAMC,EAAE,GAAGvjB,MAAM,CAACjG,UAAU,CAACqpB,MAAM,CAAC;MACpCA,MAAM,EAAE;MACRE,KAAK,EAAE;MACP,IAAIC,EAAE,IAAIpE,GAAG,EAAE;QACbxf,IAAI,EAAE;QACNS,GAAG,GAAG,CAAC;MACT,CAAC,MAAM;QACLA,GAAG,EAAE;MACP;IACF;IACA,OAAO,IAAI+iB,aAAa,CAAC,IAAI,CAAC9nB,IAAI,EAAE+nB,MAAM,EAAEzjB,IAAI,EAAES,GAAG,CAAC;EACxD;EACAwjB,UAAUA,CAACC,QAAQ,EAAEC,QAAQ,EAAE;IAC7B,MAAMnoB,OAAO,GAAG,IAAI,CAACN,IAAI,CAACM,OAAO;IACjC,IAAIooB,WAAW,GAAG,IAAI,CAACX,MAAM;IAC7B,IAAIW,WAAW,IAAI,IAAI,EAAE;MACvB,IAAIA,WAAW,GAAGpoB,OAAO,CAAC/xB,MAAM,GAAG,CAAC,EAAE;QACpCm6C,WAAW,GAAGpoB,OAAO,CAAC/xB,MAAM,GAAG,CAAC;MAClC;MACA,IAAIo6C,SAAS,GAAGD,WAAW;MAC3B,IAAIE,QAAQ,GAAG,CAAC;MAChB,IAAIC,QAAQ,GAAG,CAAC;MAChB,OAAOD,QAAQ,GAAGJ,QAAQ,IAAIE,WAAW,GAAG,CAAC,EAAE;QAC7CA,WAAW,EAAE;QACbE,QAAQ,EAAE;QACV,IAAItoB,OAAO,CAACooB,WAAW,CAAC,IAAI,IAAI,EAAE;UAChC,IAAI,EAAEG,QAAQ,IAAIJ,QAAQ,EAAE;YAC1B;UACF;QACF;MACF;MACAG,QAAQ,GAAG,CAAC;MACZC,QAAQ,GAAG,CAAC;MACZ,OAAOD,QAAQ,GAAGJ,QAAQ,IAAIG,SAAS,GAAGroB,OAAO,CAAC/xB,MAAM,GAAG,CAAC,EAAE;QAC5Do6C,SAAS,EAAE;QACXC,QAAQ,EAAE;QACV,IAAItoB,OAAO,CAACqoB,SAAS,CAAC,IAAI,IAAI,EAAE;UAC9B,IAAI,EAAEE,QAAQ,IAAIJ,QAAQ,EAAE;YAC1B;UACF;QACF;MACF;MACA,OAAO;QACLK,MAAM,EAAExoB,OAAO,CAAC8nB,SAAS,CAACM,WAAW,EAAE,IAAI,CAACX,MAAM,CAAC;QACnDgB,KAAK,EAAEzoB,OAAO,CAAC8nB,SAAS,CAAC,IAAI,CAACL,MAAM,EAAEY,SAAS,GAAG,CAAC;MACrD,CAAC;IACH;IACA,OAAO,IAAI;EACb;AACF;AACA,MAAMK,eAAe,CAAC;EACpB1oB,OAAO;EACPtZ,GAAG;EACH3T,WAAWA,CAACitB,OAAO,EAAEtZ,GAAG,EAAE;IACxB,IAAI,CAACsZ,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACtZ,GAAG,GAAGA,GAAG;EAChB;AACF;AACA,MAAMiiC,eAAe,CAAC;EACpBrkB,KAAK;EACLhqB,GAAG;EACHsuC,SAAS;EACTC,OAAO;EACP91C,WAAWA,CAACuxB,KAAK,EAAEhqB,GAAG,EAAEsuC,SAAS,GAAGtkB,KAAK,EAAEukB,OAAO,GAAG,IAAI,EAAE;IACzD,IAAI,CAACvkB,KAAK,GAAGA,KAAK;IAClB,IAAI,CAAChqB,GAAG,GAAGA,GAAG;IACd,IAAI,CAACsuC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,OAAO,GAAGA,OAAO;EACxB;EACA34C,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI,CAACo0B,KAAK,CAAC5E,IAAI,CAACM,OAAO,CAAC8nB,SAAS,CAAC,IAAI,CAACxjB,KAAK,CAACmjB,MAAM,EAAE,IAAI,CAACntC,GAAG,CAACmtC,MAAM,CAAC;EAC9E;AACF;AACA,IAAIqB,eAAe;AACnB,CAAC,UAAUA,eAAe,EAAE;EAC1BA,eAAe,CAACA,eAAe,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;EAC3DA,eAAe,CAACA,eAAe,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;AACzD,CAAC,EAAEA,eAAe,KAAKA,eAAe,GAAG,CAAC,CAAC,CAAC,CAAC;AAC7C,MAAMC,UAAU,SAASt6C,KAAK,CAAC;EAC7B21B,IAAI;EACJhqB,GAAG;EACH4uC,KAAK;EACLC,YAAY;EACZl2C,WAAWA,CAACqxB,IAAI,EAAEhqB,GAAG,EAAE4uC,KAAK,GAAGF,eAAe,CAACI,KAAK,EAAED,YAAY,EAAE;IAClE,KAAK,CAAC7uC,GAAG,CAAC;IACV,IAAI,CAACgqB,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAChqB,GAAG,GAAGA,GAAG;IACd,IAAI,CAAC4uC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChCx0C,MAAM,CAAC00C,cAAc,CAAC,IAAI,EAAEC,GAAG,CAACrhB,MAAM,CAACshB,SAAS,CAAC;EACnD;EACAC,iBAAiBA,CAAA,EAAG;IAClB,MAAMpkB,GAAG,GAAG,IAAI,CAACd,IAAI,CAACE,KAAK,CAAC2jB,UAAU,CAAC,GAAG,EAAE,CAAC,CAAC;IAC9C,OAAO/iB,GAAG,GAAG,GAAG,IAAI,CAAC9qB,GAAG,MAAM8qB,GAAG,CAACsjB,MAAM,IAAIM,eAAe,CAAC,IAAI,CAACE,KAAK,CAAC,OAAO9jB,GAAG,CAACujB,KAAK,IAAI,GAAG,IAAI,CAACruC,GAAG;EACxG;EACAlK,QAAQA,CAAA,EAAG;IACT,MAAM24C,OAAO,GAAG,IAAI,CAACzkB,IAAI,CAACykB,OAAO,GAAG,KAAK,IAAI,CAACzkB,IAAI,CAACykB,OAAO,EAAE,GAAG,EAAE;IACjE,OAAO,GAAG,IAAI,CAACS,iBAAiB,CAAC,CAAC,KAAK,IAAI,CAACllB,IAAI,CAACE,KAAK,GAAGukB,OAAO,EAAE;EACpE;AACF;AACA,SAASU,mBAAmBA,CAACC,IAAI,EAAEC,QAAQ,EAAErpB,SAAS,EAAE;EACtD,MAAMspB,cAAc,GAAG,MAAMF,IAAI,IAAIC,QAAQ,OAAOrpB,SAAS,EAAE;EAC/D,MAAMupB,UAAU,GAAG,IAAIjB,eAAe,CAAC,EAAE,EAAEgB,cAAc,CAAC;EAC1D,OAAO,IAAIf,eAAe,CAAC,IAAInB,aAAa,CAACmC,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,IAAInC,aAAa,CAACmC,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;AAClH;AACA,IAAIC,mBAAmB,GAAG,CAAC;AAC3B,SAASC,cAAcA,CAACC,iBAAiB,EAAE;EACzC,IAAI,CAACA,iBAAiB,IAAI,CAACA,iBAAiB,CAACpyB,SAAS,EAAE;IACtD,OAAO,IAAI;EACb;EACA,MAAMuP,GAAG,GAAG6iB,iBAAiB,CAACpyB,SAAS;EACvC,IAAIuP,GAAG,CAAC,iBAAiB,CAAC,EAAE;IAC1B,OAAOA,GAAG,CAAC,iBAAiB,CAAC;EAC/B;EACA,IAAIA,GAAG,CAAC,iBAAiB,CAAC,EAAE;IAC1B,OAAO,iBAAiB;EAC1B;EACA,IAAI8iB,UAAU,GAAG1rB,SAAS,CAAC4I,GAAG,CAAC;EAC/B,IAAI8iB,UAAU,CAACrsB,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;IAChCqsB,UAAU,GAAG,aAAaH,mBAAmB,EAAE,EAAE;IACjD3iB,GAAG,CAAC,iBAAiB,CAAC,GAAG8iB,UAAU;EACrC,CAAC,MAAM;IACLA,UAAU,GAAGC,kBAAkB,CAACD,UAAU,CAAC;EAC7C;EACA,OAAOA,UAAU;AACnB;AACA,SAASC,kBAAkBA,CAACj6C,IAAI,EAAE;EAChC,OAAOA,IAAI,CAACN,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;AACjC;AAEA,MAAMw6C,0BAA0B,GAAG,mIAAmI;AACtK,MAAMC,wBAAwB,SAASplB,sBAAsB,CAAC;EAC5D/xB,WAAWA,CAAA,EAAG;IACZ,KAAK,CAAC,KAAK,CAAC;EACd;EACA4P,oBAAoBA,CAACyI,GAAG,EAAE8Z,GAAG,EAAE;IAC7B,MAAM,IAAIz2B,KAAK,CAAC,8CAA8C,CAAC;EACjE;EACAkc,mBAAmBA,CAACF,IAAI,EAAEya,GAAG,EAAE;IAC7BA,GAAG,CAACpC,KAAK,CAACrY,IAAI,EAAE,OAAOA,IAAI,CAAC1a,IAAI,EAAE,CAAC;IACnC,IAAI0a,IAAI,CAACza,KAAK,EAAE;MACdk1B,GAAG,CAACpC,KAAK,CAACrY,IAAI,EAAE,KAAK,CAAC;MACtBA,IAAI,CAACza,KAAK,CAACgS,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;IACvC;IACAA,GAAG,CAACtC,OAAO,CAACnY,IAAI,EAAE,GAAG,CAAC;IACtB,OAAO,IAAI;EACb;EACAtH,8BAA8BA,CAACiI,GAAG,EAAE8Z,GAAG,EAAE;IACvC,MAAMrhB,QAAQ,GAAGuH,GAAG,CAAClI,QAAQ,CAACW,QAAQ;IACtCuH,GAAG,CAAC1c,GAAG,CAACsT,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;IAClCA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,IAAI6+B,0BAA0B,GAAG,CAAC;IACjD/kB,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,IAAIvH,QAAQ,CAACzR,GAAG,CAAC6wB,IAAI,IAAIqC,gBAAgB,CAACrC,IAAI,CAAC9sB,IAAI,EAAE,KAAK,CAAC,CAAC,CAACtG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;IAC5Fq1B,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,IAAIvH,QAAQ,CAACzR,GAAG,CAAC6wB,IAAI,IAAIqC,gBAAgB,CAACrC,IAAI,CAAC/e,OAAO,EAAE,KAAK,CAAC,CAAC,CAACrU,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;IAC9Fub,GAAG,CAAClI,QAAQ,CAACY,WAAW,CAAC3T,OAAO,CAAC4G,UAAU,IAAI;MAC7CmuB,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,IAAI,CAAC;MACpBrU,UAAU,CAACiL,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;IACvC,CAAC,CAAC;IACFA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IACnB,OAAO,IAAI;EACb;EACArH,wBAAwBA,CAAC1B,IAAI,EAAE6iB,GAAG,EAAE;IAClCA,GAAG,CAACpC,KAAK,CAACzgB,IAAI,EAAE,GAAG,CAAC;IACpB,KAAK,IAAIhT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgT,IAAI,CAACwB,QAAQ,CAAC5V,MAAM,EAAEoB,CAAC,EAAE,EAAE;MAC7CgT,IAAI,CAACwB,QAAQ,CAACxU,CAAC,CAAC,CAAC2S,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;MAC3C,MAAMnuB,UAAU,GAAG1H,CAAC,GAAGgT,IAAI,CAACyB,WAAW,CAAC7V,MAAM,GAAGoU,IAAI,CAACyB,WAAW,CAACzU,CAAC,CAAC,GAAG,IAAI;MAC3E,IAAI0H,UAAU,KAAK,IAAI,EAAE;QACvBmuB,GAAG,CAACpC,KAAK,CAAC/rB,UAAU,EAAE,IAAI,CAAC;QAC3BA,UAAU,CAACiL,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;QACrCA,GAAG,CAACpC,KAAK,CAAC/rB,UAAU,EAAE,GAAG,CAAC;MAC5B;IACF;IACAmuB,GAAG,CAACpC,KAAK,CAACzgB,IAAI,EAAE,GAAG,CAAC;EACtB;EACAgC,+BAA+BA,CAAChC,IAAI,EAAE6iB,GAAG,EAAE;IACzCA,GAAG,CAACpC,KAAK,CAACzgB,IAAI,EAAEA,IAAI,CAAC6B,OAAO,CAAC;IAC7B,OAAO,IAAI;EACb;EACAkD,iBAAiBA,CAACgE,GAAG,EAAE8Z,GAAG,EAAE;IAC1BA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,WAAWA,GAAG,CAACrb,IAAI,GAAG,GAAG,GAAGqb,GAAG,CAACrb,IAAI,GAAG,EAAE,GAAG,CAAC;IAC5D,IAAI,CAACo6C,YAAY,CAAC/+B,GAAG,CAAC3M,MAAM,EAAEymB,GAAG,CAAC;IAClCA,GAAG,CAACtC,OAAO,CAACxX,GAAG,EAAE,KAAK,CAAC;IACvB8Z,GAAG,CAAC7B,SAAS,CAAC,CAAC;IACf,IAAI,CAAC/X,kBAAkB,CAACF,GAAG,CAAClE,UAAU,EAAEge,GAAG,CAAC;IAC5CA,GAAG,CAAC5B,SAAS,CAAC,CAAC;IACf4B,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IACnB,OAAO,IAAI;EACb;EACA1D,sBAAsBA,CAAC0D,GAAG,EAAE8Z,GAAG,EAAE;IAC/BA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IACnB,IAAI,CAAC++B,YAAY,CAAC/+B,GAAG,CAAC3M,MAAM,EAAEymB,GAAG,CAAC;IAClCA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,MAAM,CAAC;IACtB,IAAI5D,KAAK,CAACC,OAAO,CAAC2D,GAAG,CAAC7H,IAAI,CAAC,EAAE;MAC3B2hB,GAAG,CAACtC,OAAO,CAACxX,GAAG,EAAE,GAAG,CAAC;MACrB8Z,GAAG,CAAC7B,SAAS,CAAC,CAAC;MACf,IAAI,CAAC/X,kBAAkB,CAACF,GAAG,CAAC7H,IAAI,EAAE2hB,GAAG,CAAC;MACtCA,GAAG,CAAC5B,SAAS,CAAC,CAAC;MACf4B,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IACrB,CAAC,MAAM;MACL,MAAMg/B,eAAe,GAAGh/B,GAAG,CAAC7H,IAAI,YAAYgG,cAAc;MAC1D,IAAI6gC,eAAe,EAAE;QACnBllB,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;MACrB;MACAA,GAAG,CAAC7H,IAAI,CAACvB,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;MACnC,IAAIklB,eAAe,EAAE;QACnBllB,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;MACrB;IACF;IACA,OAAO,IAAI;EACb;EACAR,wBAAwBA,CAACH,IAAI,EAAEya,GAAG,EAAE;IAClCA,GAAG,CAACpC,KAAK,CAACrY,IAAI,EAAE,YAAYA,IAAI,CAAC1a,IAAI,GAAG,CAAC;IACzC,IAAI,CAACo6C,YAAY,CAAC1/B,IAAI,CAAChM,MAAM,EAAEymB,GAAG,CAAC;IACnCA,GAAG,CAACtC,OAAO,CAACnY,IAAI,EAAE,KAAK,CAAC;IACxBya,GAAG,CAAC7B,SAAS,CAAC,CAAC;IACf,IAAI,CAAC/X,kBAAkB,CAACb,IAAI,CAACvD,UAAU,EAAEge,GAAG,CAAC;IAC7CA,GAAG,CAAC5B,SAAS,CAAC,CAAC;IACf4B,GAAG,CAACtC,OAAO,CAACnY,IAAI,EAAE,GAAG,CAAC;IACtB,OAAO,IAAI;EACb;EACAzF,oBAAoBA,CAACoG,GAAG,EAAE8Z,GAAG,EAAE;IAC7BA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,aAAa6+B,0BAA0B,GAAG,CAAC;IAC1D,MAAMp0C,KAAK,GAAG,CAACuV,GAAG,CAACnG,iBAAiB,CAAC,CAAC,CAAC;IACvC,KAAK,IAAI5V,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+b,GAAG,CAACtG,YAAY,CAAC7W,MAAM,EAAEoB,CAAC,EAAE,EAAE;MAChDwG,KAAK,CAAC3H,IAAI,CAACkd,GAAG,CAAC3F,yBAAyB,CAACpW,CAAC,CAAC,CAAC;IAC9C;IACA61B,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,IAAIvV,KAAK,CAACzD,GAAG,CAAC6wB,IAAI,IAAIqC,gBAAgB,CAACrC,IAAI,CAAChd,MAAM,EAAE,KAAK,CAAC,CAAC,CAACpW,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;IAC3Fq1B,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,IAAIvV,KAAK,CAACzD,GAAG,CAAC6wB,IAAI,IAAIqC,gBAAgB,CAACrC,IAAI,CAAC/c,GAAG,EAAE,KAAK,CAAC,CAAC,CAACrW,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;IACvFub,GAAG,CAACtH,WAAW,CAAC3T,OAAO,CAAC4G,UAAU,IAAI;MACpCmuB,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,IAAI,CAAC;MACpBrU,UAAU,CAACiL,eAAe,CAAC,IAAI,EAAEkjB,GAAG,CAAC;IACvC,CAAC,CAAC;IACFA,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,GAAG,CAAC;IACnB,OAAO,IAAI;EACb;EACA++B,YAAYA,CAAC1rC,MAAM,EAAEymB,GAAG,EAAE;IACxB,IAAI,CAACO,eAAe,CAACze,KAAK,IAAIke,GAAG,CAACpC,KAAK,CAAC,IAAI,EAAE9b,KAAK,CAACjX,IAAI,CAAC,EAAE0O,MAAM,EAAEymB,GAAG,EAAE,GAAG,CAAC;EAC9E;AACF;AAEA,IAAImlB,MAAM;AACV,SAASC,SAASA,CAAA,EAAG;EACnB,IAAID,MAAM,KAAKvsB,SAAS,EAAE;IACxB,MAAMysB,YAAY,GAAGvrB,OAAO,CAAC,cAAc,CAAC;IAC5CqrB,MAAM,GAAG,IAAI;IACb,IAAIE,YAAY,EAAE;MAChB,IAAI;QACFF,MAAM,GAAGE,YAAY,CAACC,YAAY,CAAC,oBAAoB,EAAE;UACvDC,YAAY,EAAEzsB,CAAC,IAAIA;QACrB,CAAC,CAAC;MACJ,CAAC,CAAC,MAAM,CAAC;IACX;EACF;EACA,OAAOqsB,MAAM;AACf;AACA,SAASK,uBAAuBA,CAACC,MAAM,EAAE;EACvC,OAAOL,SAAS,CAAC,CAAC,EAAEG,YAAY,CAACE,MAAM,CAAC,IAAIA,MAAM;AACpD;AACA,SAASC,wBAAwBA,CAAC,GAAG/nC,IAAI,EAAE;EACzC,IAAI,CAACmc,OAAO,CAAC,cAAc,CAAC,EAAE;IAC5B,OAAO,IAAInrB,QAAQ,CAAC,GAAGgP,IAAI,CAAC;EAC9B;EACA,MAAMgoC,MAAM,GAAGhoC,IAAI,CAAChU,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACgB,IAAI,CAAC,GAAG,CAAC;EAC1C,MAAMi7C,MAAM,GAAGjoC,IAAI,CAACA,IAAI,CAAC5U,MAAM,GAAG,CAAC,CAAC;EACpC,MAAMsV,IAAI,GAAG,uBAAuBsnC,MAAM;AAC5C,MAAMC,MAAM;AACZ,GAAG;EACD,MAAMloC,EAAE,GAAGoc,OAAO,CAAC,MAAM,CAAC,CAAC0rB,uBAAuB,CAACnnC,IAAI,CAAC,CAAC;EACzD,IAAIX,EAAE,CAACmoC,IAAI,KAAKjtB,SAAS,EAAE;IACzB,OAAO,IAAIjqB,QAAQ,CAAC,GAAGgP,IAAI,CAAC;EAC9B;EACAD,EAAE,CAAC1S,QAAQ,GAAG,MAAMqT,IAAI;EACxB,OAAOX,EAAE,CAACmoC,IAAI,CAAC/rB,OAAO,CAAC;AACzB;AAEA,MAAMgsB,YAAY,CAAC;EACjBC,kBAAkBA,CAAC7qB,SAAS,EAAElZ,UAAU,EAAEgkC,WAAW,EAAEC,gBAAgB,EAAE;IACvE,MAAMC,SAAS,GAAG,IAAIC,iBAAiB,CAACH,WAAW,CAAC;IACpD,MAAMhmB,GAAG,GAAG3C,qBAAqB,CAACE,UAAU,CAAC,CAAC;IAC9C,IAAIvb,UAAU,CAACjZ,MAAM,GAAG,CAAC,IAAI,CAACq9C,oBAAoB,CAACpkC,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;MACjEA,UAAU,GAAG,CAACyF,OAAO,CAAC,YAAY,CAAC,CAAC/K,MAAM,CAAC,CAAC,EAAE,GAAGsF,UAAU,CAAC;IAC9D;IACAkkC,SAAS,CAAC9/B,kBAAkB,CAACpE,UAAU,EAAEge,GAAG,CAAC;IAC7CkmB,SAAS,CAACG,gBAAgB,CAACrmB,GAAG,CAAC;IAC/B,OAAO,IAAI,CAACsmB,YAAY,CAACprB,SAAS,EAAE8E,GAAG,EAAEkmB,SAAS,CAACK,OAAO,CAAC,CAAC,EAAEN,gBAAgB,CAAC;EACjF;EACAK,YAAYA,CAACprB,SAAS,EAAE8E,GAAG,EAAEsT,IAAI,EAAEkT,eAAe,EAAE;IAClD,IAAIZ,MAAM,GAAG,gBAAgB5lB,GAAG,CAAC3B,QAAQ,CAAC,CAAC,mBAAmBnD,SAAS,EAAE;IACzE,MAAMurB,UAAU,GAAG,EAAE;IACrB,MAAMC,WAAW,GAAG,EAAE;IACtB,KAAK,MAAMC,OAAO,IAAIrT,IAAI,EAAE;MAC1BoT,WAAW,CAAC19C,IAAI,CAACsqC,IAAI,CAACqT,OAAO,CAAC,CAAC;MAC/BF,UAAU,CAACz9C,IAAI,CAAC29C,OAAO,CAAC;IAC1B;IACA,IAAIH,eAAe,EAAE;MACnB,MAAMI,OAAO,GAAGlB,wBAAwB,CAAC,GAAGe,UAAU,CAAC77C,MAAM,CAAC,cAAc,CAAC,CAAC,CAACI,QAAQ,CAAC,CAAC;MACzF,MAAM67C,WAAW,GAAGD,OAAO,CAACj9C,KAAK,CAAC,CAAC,EAAEi9C,OAAO,CAACpuB,OAAO,CAAC,cAAc,CAAC,CAAC,CAACqB,KAAK,CAAC,IAAI,CAAC,CAAC9wB,MAAM,GAAG,CAAC;MAC5F68C,MAAM,IAAI,KAAK5lB,GAAG,CAACvB,oBAAoB,CAACvD,SAAS,EAAE2rB,WAAW,CAAC,CAAC3qB,WAAW,CAAC,CAAC,EAAE;IACjF;IACA,MAAMxe,EAAE,GAAGgoC,wBAAwB,CAAC,GAAGe,UAAU,CAAC77C,MAAM,CAACg7C,MAAM,CAAC,CAAC;IACjE,OAAO,IAAI,CAACkB,eAAe,CAACppC,EAAE,EAAEgpC,WAAW,CAAC;EAC9C;EACAI,eAAeA,CAACppC,EAAE,EAAEC,IAAI,EAAE;IACxB,OAAOD,EAAE,CAAC,GAAGC,IAAI,CAAC;EACpB;AACF;AACA,MAAMwoC,iBAAiB,SAASnB,wBAAwB,CAAC;EACvDgB,WAAW;EACXe,aAAa,GAAG,EAAE;EAClBC,cAAc,GAAG,EAAE;EACnBC,iBAAiB,GAAG,EAAE;EACtBp5C,WAAWA,CAACm4C,WAAW,EAAE;IACvB,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,WAAW,GAAGA,WAAW;EAChC;EACAK,gBAAgBA,CAACrmB,GAAG,EAAE;IACpB,MAAMza,IAAI,GAAG,IAAIK,eAAe,CAAC,IAAIvB,cAAc,CAAC,IAAI,CAAC4iC,iBAAiB,CAAC/5C,GAAG,CAACg6C,SAAS,IAAI,IAAI/iC,eAAe,CAAC+iC,SAAS,EAAE1gC,QAAQ,CAAC0gC,SAAS,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;IACzJ3hC,IAAI,CAACC,cAAc,CAAC,IAAI,EAAEwa,GAAG,CAAC;EAChC;EACAumB,OAAOA,CAAA,EAAG;IACR,MAAMt8C,MAAM,GAAG,CAAC,CAAC;IACjB,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC48C,aAAa,CAACh+C,MAAM,EAAEoB,CAAC,EAAE,EAAE;MAClDF,MAAM,CAAC,IAAI,CAAC88C,aAAa,CAAC58C,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC68C,cAAc,CAAC78C,CAAC,CAAC;IACxD;IACA,OAAOF,MAAM;EACf;EACAkX,iBAAiBA,CAAC+E,GAAG,EAAE8Z,GAAG,EAAE;IAC1B,IAAI,CAACmnB,wBAAwB,CAACjhC,GAAG,EAAE,IAAI,CAAC8/B,WAAW,CAACoB,wBAAwB,CAAClhC,GAAG,CAACpb,KAAK,CAAC,EAAEk1B,GAAG,CAAC;IAC7F,OAAO,IAAI;EACb;EACAviB,oBAAoBA,CAACyI,GAAG,EAAE8Z,GAAG,EAAE;IAC7B,IAAI,CAACmnB,wBAAwB,CAACjhC,GAAG,EAAEA,GAAG,CAAC1I,IAAI,EAAEwiB,GAAG,CAAC;IACjD,OAAO,IAAI;EACb;EACAva,mBAAmBA,CAACF,IAAI,EAAEya,GAAG,EAAE;IAC7B,IAAIza,IAAI,CAACjP,WAAW,CAACsO,YAAY,CAACyiC,QAAQ,CAAC,EAAE;MAC3C,IAAI,CAACJ,iBAAiB,CAACj+C,IAAI,CAACuc,IAAI,CAAC1a,IAAI,CAAC;IACxC;IACA,OAAO,KAAK,CAAC4a,mBAAmB,CAACF,IAAI,EAAEya,GAAG,CAAC;EAC7C;EACAta,wBAAwBA,CAACH,IAAI,EAAEya,GAAG,EAAE;IAClC,IAAIza,IAAI,CAACjP,WAAW,CAACsO,YAAY,CAACyiC,QAAQ,CAAC,EAAE;MAC3C,IAAI,CAACJ,iBAAiB,CAACj+C,IAAI,CAACuc,IAAI,CAAC1a,IAAI,CAAC;IACxC;IACA,OAAO,KAAK,CAAC6a,wBAAwB,CAACH,IAAI,EAAEya,GAAG,CAAC;EAClD;EACAmnB,wBAAwBA,CAACjhC,GAAG,EAAEpb,KAAK,EAAEk1B,GAAG,EAAE;IACxC,IAAI/vB,EAAE,GAAG,IAAI,CAAC+2C,cAAc,CAACxuB,OAAO,CAAC1tB,KAAK,CAAC;IAC3C,IAAImF,EAAE,KAAK,CAAC,CAAC,EAAE;MACbA,EAAE,GAAG,IAAI,CAAC+2C,cAAc,CAACj+C,MAAM;MAC/B,IAAI,CAACi+C,cAAc,CAACh+C,IAAI,CAAC8B,KAAK,CAAC;MAC/B,MAAMD,IAAI,GAAG85C,cAAc,CAAC;QAC1BnyB,SAAS,EAAE1nB;MACb,CAAC,CAAC,IAAI,KAAK;MACX,IAAI,CAACi8C,aAAa,CAAC/9C,IAAI,CAAC,OAAO6B,IAAI,IAAIoF,EAAE,EAAE,CAAC;IAC9C;IACA+vB,GAAG,CAACpC,KAAK,CAAC1X,GAAG,EAAE,IAAI,CAAC6gC,aAAa,CAAC92C,EAAE,CAAC,CAAC;EACxC;AACF;AACA,SAASm2C,oBAAoBA,CAACkB,SAAS,EAAE;EACvC,OAAOA,SAAS,CAAC5uC,YAAY,CAAC+O,OAAO,CAAC,YAAY,CAAC,CAAC/K,MAAM,CAAC,CAAC,CAAC;AAC/D;AAEA,SAAS6qC,eAAeA,CAACllB,IAAI,EAAE;EAC7B,MAAMmlB,aAAa,GAAG,IAAIlL,aAAa,CAAC,CAAC;EACzC,IAAIja,IAAI,CAAColB,SAAS,KAAK,IAAI,EAAE;IAC3BD,aAAa,CAACz6C,GAAG,CAAC,WAAW,EAAEs1B,IAAI,CAAColB,SAAS,CAAC;EAChD;EACA,IAAIplB,IAAI,CAACqlB,OAAO,CAAC3+C,MAAM,GAAG,CAAC,EAAE;IAC3By+C,aAAa,CAACz6C,GAAG,CAAC,SAAS,EAAEga,UAAU,CAACsb,IAAI,CAACqlB,OAAO,CAAC,CAAC;EACxD;EACA,MAAM71C,UAAU,GAAG4U,UAAU,CAACwE,WAAW,CAACoJ,cAAc,CAAC,CAAC/a,MAAM,CAAC,CAACkuC,aAAa,CAAC/K,YAAY,CAAC,CAAC,CAAC,EAAE7jB,SAAS,EAAE,IAAI,CAAC;EACjH,MAAM9mB,IAAI,GAAG61C,kBAAkB,CAACtlB,IAAI,CAAC;EACrC,OAAO;IACLxwB,UAAU;IACVC,IAAI;IACJkQ,UAAU,EAAE;EACd,CAAC;AACH;AACA,SAAS2lC,kBAAkBA,CAACtlB,IAAI,EAAE;EAChC,OAAO,IAAIzrB,cAAc,CAAC6P,UAAU,CAACwE,WAAW,CAACmJ,mBAAmB,EAAE,CAAC,IAAIxd,cAAc,CAACyrB,IAAI,CAACvwB,IAAI,CAACA,IAAI,CAAC,CAAC,CAAC,CAAC;AAC9G;AAEA,MAAM81C,cAAc,CAAC;EACnB12C,OAAO;EACPrD,WAAWA,CAACqD,OAAO,EAAE;IACnB,IAAI,CAACA,OAAO,GAAGA,OAAO;EACxB;EACAk2C,wBAAwBA,CAACrlB,GAAG,EAAE;IAC5B,IAAIA,GAAG,CAAC7gB,UAAU,KAAK,eAAe,EAAE;MACtC,MAAM,IAAI3X,KAAK,CAAC,wCAAwCw4B,GAAG,CAAC7gB,UAAU,mDAAmD,CAAC;IAC5H;IACA,IAAI,CAAC,IAAI,CAAChQ,OAAO,CAACklC,cAAc,CAACrU,GAAG,CAACl3B,IAAI,CAAC,EAAE;MAC1C,MAAM,IAAItB,KAAK,CAAC,+CAA+Cw4B,GAAG,CAACl3B,IAAI,IAAI,CAAC;IAC9E;IACA,OAAO,IAAI,CAACqG,OAAO,CAAC6wB,GAAG,CAACl3B,IAAI,CAAC;EAC/B;AACF;AAEA,IAAIg9C,mBAAmB;AACvB,CAAC,UAAUA,mBAAmB,EAAE;EAC9BA,mBAAmB,CAACA,mBAAmB,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;EACjEA,mBAAmB,CAACA,mBAAmB,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,GAAG,YAAY;EACzEA,mBAAmB,CAACA,mBAAmB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;AAC/D,CAAC,EAAEA,mBAAmB,KAAKA,mBAAmB,GAAG,CAAC,CAAC,CAAC,CAAC;AACrD,IAAIC,sBAAsB;AAC1B,CAAC,UAAUA,sBAAsB,EAAE;EACjCA,sBAAsB,CAACA,sBAAsB,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;EACvEA,sBAAsB,CAACA,sBAAsB,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;AACvE,CAAC,EAAEA,sBAAsB,KAAKA,sBAAsB,GAAG,CAAC,CAAC,CAAC,CAAC;AAC3D,SAASC,eAAeA,CAAC1lB,IAAI,EAAE;EAC7B,MAAMrgB,UAAU,GAAG,EAAE;EACrB,MAAMwlC,aAAa,GAAG,IAAIlL,aAAa,CAAC,CAAC;EACzCkL,aAAa,CAACz6C,GAAG,CAAC,MAAM,EAAEs1B,IAAI,CAACvwB,IAAI,CAAChH,KAAK,CAAC;EAC1C,IAAIu3B,IAAI,CAACiiB,IAAI,KAAKwD,sBAAsB,CAACE,MAAM,IAAI3lB,IAAI,CAAC4lB,SAAS,CAACl/C,MAAM,GAAG,CAAC,EAAE;IAC5Ey+C,aAAa,CAACz6C,GAAG,CAAC,WAAW,EAAE60B,WAAW,CAACS,IAAI,CAAC4lB,SAAS,EAAE5lB,IAAI,CAAC6lB,oBAAoB,CAAC,CAAC;EACxF;EACA,IAAI7lB,IAAI,CAAC8lB,iBAAiB,KAAKN,mBAAmB,CAACO,MAAM,EAAE;IACzD,IAAI/lB,IAAI,CAACgmB,YAAY,CAACt/C,MAAM,GAAG,CAAC,EAAE;MAChCy+C,aAAa,CAACz6C,GAAG,CAAC,cAAc,EAAE60B,WAAW,CAACS,IAAI,CAACgmB,YAAY,EAAEhmB,IAAI,CAAC6lB,oBAAoB,CAAC,CAAC;IAC9F;IACA,IAAI7lB,IAAI,CAACqlB,OAAO,CAAC3+C,MAAM,GAAG,CAAC,EAAE;MAC3By+C,aAAa,CAACz6C,GAAG,CAAC,SAAS,EAAE60B,WAAW,CAACS,IAAI,CAACqlB,OAAO,EAAErlB,IAAI,CAAC6lB,oBAAoB,CAAC,CAAC;IACpF;IACA,IAAI7lB,IAAI,CAACimB,OAAO,CAACv/C,MAAM,GAAG,CAAC,EAAE;MAC3By+C,aAAa,CAACz6C,GAAG,CAAC,SAAS,EAAE60B,WAAW,CAACS,IAAI,CAACimB,OAAO,EAAEjmB,IAAI,CAAC6lB,oBAAoB,CAAC,CAAC;IACpF;EACF,CAAC,MAAM,IAAI7lB,IAAI,CAAC8lB,iBAAiB,KAAKN,mBAAmB,CAACU,UAAU,EAAE;IACpE,MAAMC,oBAAoB,GAAGC,4BAA4B,CAACpmB,IAAI,CAAC;IAC/D,IAAImmB,oBAAoB,KAAK,IAAI,EAAE;MACjCxmC,UAAU,CAAChZ,IAAI,CAACw/C,oBAAoB,CAAC;IACvC;EACF,CAAC,MAAM;EACP,IAAInmB,IAAI,CAACqmB,OAAO,KAAK,IAAI,IAAIrmB,IAAI,CAACqmB,OAAO,CAAC3/C,MAAM,GAAG,CAAC,EAAE;IACpDy+C,aAAa,CAACz6C,GAAG,CAAC,SAAS,EAAEga,UAAU,CAACsb,IAAI,CAACqmB,OAAO,CAACx7C,GAAG,CAAC60B,GAAG,IAAIA,GAAG,CAACj3B,KAAK,CAAC,CAAC,CAAC;EAC9E;EACA,IAAIu3B,IAAI,CAACpyB,EAAE,KAAK,IAAI,EAAE;IACpBu3C,aAAa,CAACz6C,GAAG,CAAC,IAAI,EAAEs1B,IAAI,CAACpyB,EAAE,CAAC;IAChC+R,UAAU,CAAChZ,IAAI,CAACyd,UAAU,CAACwE,WAAW,CAAC2J,oBAAoB,CAAC,CAACtb,MAAM,CAAC,CAAC+oB,IAAI,CAACvwB,IAAI,CAAChH,KAAK,EAAEu3B,IAAI,CAACpyB,EAAE,CAAC,CAAC,CAACyM,MAAM,CAAC,CAAC,CAAC;EAC3G;EACA,MAAM7K,UAAU,GAAG4U,UAAU,CAACwE,WAAW,CAACwJ,cAAc,CAAC,CAACnb,MAAM,CAAC,CAACkuC,aAAa,CAAC/K,YAAY,CAAC,CAAC,CAAC,EAAE7jB,SAAS,EAAE,IAAI,CAAC;EACjH,MAAM9mB,IAAI,GAAG62C,kBAAkB,CAACtmB,IAAI,CAAC;EACrC,OAAO;IACLxwB,UAAU;IACVC,IAAI;IACJkQ;EACF,CAAC;AACH;AACA,SAAS4mC,oCAAoCA,CAACvmB,IAAI,EAAE;EAClD,MAAMmlB,aAAa,GAAG,IAAIlL,aAAa,CAAC,CAAC;EACzCkL,aAAa,CAACz6C,GAAG,CAAC,MAAM,EAAE,IAAIwQ,eAAe,CAAC8kB,IAAI,CAACvwB,IAAI,CAAC,CAAC;EACzD,IAAIuwB,IAAI,CAAC4lB,SAAS,KAAKrvB,SAAS,EAAE;IAChC4uB,aAAa,CAACz6C,GAAG,CAAC,WAAW,EAAE,IAAIwQ,eAAe,CAAC8kB,IAAI,CAAC4lB,SAAS,CAAC,CAAC;EACrE;EACA,IAAI5lB,IAAI,CAACgmB,YAAY,KAAKzvB,SAAS,EAAE;IACnC4uB,aAAa,CAACz6C,GAAG,CAAC,cAAc,EAAE,IAAIwQ,eAAe,CAAC8kB,IAAI,CAACgmB,YAAY,CAAC,CAAC;EAC3E;EACA,IAAIhmB,IAAI,CAACqlB,OAAO,KAAK9uB,SAAS,EAAE;IAC9B4uB,aAAa,CAACz6C,GAAG,CAAC,SAAS,EAAE,IAAIwQ,eAAe,CAAC8kB,IAAI,CAACqlB,OAAO,CAAC,CAAC;EACjE;EACA,IAAIrlB,IAAI,CAACimB,OAAO,KAAK1vB,SAAS,EAAE;IAC9B4uB,aAAa,CAACz6C,GAAG,CAAC,SAAS,EAAE,IAAIwQ,eAAe,CAAC8kB,IAAI,CAACimB,OAAO,CAAC,CAAC;EACjE;EACA,IAAIjmB,IAAI,CAACqmB,OAAO,KAAK9vB,SAAS,EAAE;IAC9B4uB,aAAa,CAACz6C,GAAG,CAAC,SAAS,EAAE,IAAIwQ,eAAe,CAAC8kB,IAAI,CAACqmB,OAAO,CAAC,CAAC;EACjE;EACA,IAAIrmB,IAAI,CAACpyB,EAAE,KAAK2oB,SAAS,EAAE;IACzB4uB,aAAa,CAACz6C,GAAG,CAAC,IAAI,EAAE,IAAIwQ,eAAe,CAAC8kB,IAAI,CAACpyB,EAAE,CAAC,CAAC;EACvD;EACA,OAAOwW,UAAU,CAACwE,WAAW,CAACwJ,cAAc,CAAC,CAACnb,MAAM,CAAC,CAACkuC,aAAa,CAAC/K,YAAY,CAAC,CAAC,CAAC,CAAC;AACtF;AACA,SAASkM,kBAAkBA,CAACtmB,IAAI,EAAE;EAChC,IAAIA,IAAI,CAACiiB,IAAI,KAAKwD,sBAAsB,CAACe,KAAK,EAAE;IAC9C,OAAO,IAAIjyC,cAAc,CAACyrB,IAAI,CAACvwB,IAAI,CAAChH,KAAK,CAAC;EAC5C;EACA,MAAM;IACJgH,IAAI,EAAEg3C,UAAU;IAChBT,YAAY;IACZC,OAAO;IACPZ,OAAO;IACPqB,kBAAkB;IAClBC;EACF,CAAC,GAAG3mB,IAAI;EACR,OAAO,IAAIzrB,cAAc,CAAC6P,UAAU,CAACwE,WAAW,CAACsJ,mBAAmB,EAAE,CAAC,IAAI3d,cAAc,CAACkyC,UAAU,CAACh3C,IAAI,CAAC,EAAEk3C,sBAAsB,KAAK,IAAI,GAAGC,WAAW,CAACZ,YAAY,CAAC,GAAGa,YAAY,CAACF,sBAAsB,CAAC,EAAED,kBAAkB,GAAGE,WAAW,CAACvB,OAAO,CAAC,GAAGtvC,SAAS,EAAE6wC,WAAW,CAACX,OAAO,CAAC,CAAC,CAAC,CAAC;AAChS;AACA,SAASG,4BAA4BA,CAACpmB,IAAI,EAAE;EAC1C,MAAM8mB,QAAQ,GAAG,IAAI7M,aAAa,CAAC,CAAC;EACpC,IAAIja,IAAI,CAACiiB,IAAI,KAAKwD,sBAAsB,CAACE,MAAM,EAAE;IAC/C,IAAI3lB,IAAI,CAACgmB,YAAY,CAACt/C,MAAM,GAAG,CAAC,EAAE;MAChCogD,QAAQ,CAACp8C,GAAG,CAAC,cAAc,EAAE60B,WAAW,CAACS,IAAI,CAACgmB,YAAY,EAAEhmB,IAAI,CAAC6lB,oBAAoB,CAAC,CAAC;IACzF;EACF,CAAC,MAAM;IACL,IAAI7lB,IAAI,CAAC+mB,sBAAsB,EAAE;MAC/BD,QAAQ,CAACp8C,GAAG,CAAC,cAAc,EAAEs1B,IAAI,CAAC+mB,sBAAsB,CAAC;IAC3D;EACF;EACA,IAAI/mB,IAAI,CAACiiB,IAAI,KAAKwD,sBAAsB,CAACE,MAAM,EAAE;IAC/C,IAAI3lB,IAAI,CAACqlB,OAAO,CAAC3+C,MAAM,GAAG,CAAC,EAAE;MAC3BogD,QAAQ,CAACp8C,GAAG,CAAC,SAAS,EAAE60B,WAAW,CAACS,IAAI,CAACqlB,OAAO,EAAErlB,IAAI,CAAC6lB,oBAAoB,CAAC,CAAC;IAC/E;EACF,CAAC,MAAM;IACL,IAAI7lB,IAAI,CAACgnB,iBAAiB,EAAE;MAC1BF,QAAQ,CAACp8C,GAAG,CAAC,SAAS,EAAEs1B,IAAI,CAACgnB,iBAAiB,CAAC;IACjD;EACF;EACA,IAAIhnB,IAAI,CAACiiB,IAAI,KAAKwD,sBAAsB,CAACE,MAAM,EAAE;IAC/C,IAAI3lB,IAAI,CAACimB,OAAO,CAACv/C,MAAM,GAAG,CAAC,EAAE;MAC3BogD,QAAQ,CAACp8C,GAAG,CAAC,SAAS,EAAE60B,WAAW,CAACS,IAAI,CAACimB,OAAO,EAAEjmB,IAAI,CAAC6lB,oBAAoB,CAAC,CAAC;IAC/E;EACF,CAAC,MAAM;IACL,IAAI7lB,IAAI,CAACinB,iBAAiB,EAAE;MAC1BH,QAAQ,CAACp8C,GAAG,CAAC,SAAS,EAAEs1B,IAAI,CAACinB,iBAAiB,CAAC;IACjD;EACF;EACA,IAAIjnB,IAAI,CAACiiB,IAAI,KAAKwD,sBAAsB,CAACe,KAAK,IAAIxmB,IAAI,CAACknB,mBAAmB,EAAE;IAC1EJ,QAAQ,CAACp8C,GAAG,CAAC,WAAW,EAAEs1B,IAAI,CAACknB,mBAAmB,CAAC;EACrD;EACA,IAAIh6C,MAAM,CAACmC,IAAI,CAACy3C,QAAQ,CAACniC,MAAM,CAAC,CAACje,MAAM,KAAK,CAAC,EAAE;IAC7C,OAAO,IAAI;EACb;EACA,MAAMygD,MAAM,GAAG,IAAI/vC,kBAAkB,CAACgN,UAAU,CAACwE,WAAW,CAAC0J,gBAAgB,CAAC,EAAE,CAAC0N,IAAI,CAACvwB,IAAI,CAAChH,KAAK,EAAEq+C,QAAQ,CAAC1M,YAAY,CAAC,CAAC,CAAC,CAAC;EAC3H,MAAMgN,WAAW,GAAGtoB,wBAAwB,CAACqoB,MAAM,CAAC;EACpD,MAAME,IAAI,GAAG,IAAI3nC,YAAY,CAAC,EAAE,EAAE,CAAC0nC,WAAW,CAAC/sC,MAAM,CAAC,CAAC,CAAC,CAAC;EACzD,MAAMitC,QAAQ,GAAG,IAAIlwC,kBAAkB,CAACiwC,IAAI,EAAE,EAAE,CAAC;EACjD,OAAOC,QAAQ,CAACjtC,MAAM,CAAC,CAAC;AAC1B;AACA,SAASusC,WAAWA,CAACphC,GAAG,EAAE;EACxB,MAAM+hC,KAAK,GAAG/hC,GAAG,CAAC3a,GAAG,CAAC60B,GAAG,IAAIjb,UAAU,CAACib,GAAG,CAACjwB,IAAI,CAAC,CAAC;EAClD,OAAO+V,GAAG,CAAC9e,MAAM,GAAG,CAAC,GAAG6d,cAAc,CAACG,UAAU,CAAC6iC,KAAK,CAAC,CAAC,GAAGxxC,SAAS;AACvE;AACA,SAAS8wC,YAAYA,CAACU,KAAK,EAAE;EAC3B,MAAMC,WAAW,GAAGD,KAAK,CAAC18C,GAAG,CAAC4E,IAAI,IAAIgV,UAAU,CAAChV,IAAI,CAAC,CAAC;EACvD,OAAO83C,KAAK,CAAC7gD,MAAM,GAAG,CAAC,GAAG6d,cAAc,CAACG,UAAU,CAAC8iC,WAAW,CAAC,CAAC,GAAGzxC,SAAS;AAC/E;AAEA,SAAS0xC,uBAAuBA,CAACC,QAAQ,EAAE;EACzC,MAAMC,mBAAmB,GAAG,EAAE;EAC9BA,mBAAmB,CAAChhD,IAAI,CAAC;IACvBoQ,GAAG,EAAE,MAAM;IACXtO,KAAK,EAAE2c,OAAO,CAACsiC,QAAQ,CAACE,QAAQ,IAAIF,QAAQ,CAACl/C,IAAI,CAAC;IAClDuZ,MAAM,EAAE;EACV,CAAC,CAAC;EACF4lC,mBAAmB,CAAChhD,IAAI,CAAC;IACvBoQ,GAAG,EAAE,MAAM;IACXtO,KAAK,EAAEi/C,QAAQ,CAACj4C,IAAI,CAAChH,KAAK;IAC1BsZ,MAAM,EAAE;EACV,CAAC,CAAC;EACF4lC,mBAAmB,CAAChhD,IAAI,CAAC;IACvBoQ,GAAG,EAAE,MAAM;IACXtO,KAAK,EAAE2c,OAAO,CAACsiC,QAAQ,CAACvwC,IAAI,CAAC;IAC7B4K,MAAM,EAAE;EACV,CAAC,CAAC;EACF,IAAI2lC,QAAQ,CAACG,YAAY,KAAK,KAAK,EAAE;IACnCF,mBAAmB,CAAChhD,IAAI,CAAC;MACvBoQ,GAAG,EAAE,YAAY;MACjBtO,KAAK,EAAE2c,OAAO,CAAC,KAAK,CAAC;MACrBrD,MAAM,EAAE;IACV,CAAC,CAAC;EACJ;EACA,MAAMvS,UAAU,GAAG4U,UAAU,CAACwE,WAAW,CAAC6J,UAAU,CAAC,CAACxb,MAAM,CAAC,CAAC2N,UAAU,CAAC+iC,mBAAmB,CAAC,CAAC,EAAEpxB,SAAS,EAAE,IAAI,CAAC;EAChH,MAAM9mB,IAAI,GAAGq4C,cAAc,CAACJ,QAAQ,CAAC;EACrC,OAAO;IACLl4C,UAAU;IACVC,IAAI;IACJkQ,UAAU,EAAE;EACd,CAAC;AACH;AACA,SAASmoC,cAAcA,CAACJ,QAAQ,EAAE;EAChC,OAAO,IAAInzC,cAAc,CAAC6P,UAAU,CAACwE,WAAW,CAAC4J,eAAe,EAAE,CAACiM,kBAAkB,CAACipB,QAAQ,CAACj4C,IAAI,CAACA,IAAI,EAAEi4C,QAAQ,CAAC/lB,iBAAiB,CAAC,EAAE,IAAIptB,cAAc,CAAC,IAAI4H,WAAW,CAACurC,QAAQ,CAACE,QAAQ,CAAC,CAAC,EAAE,IAAIrzC,cAAc,CAAC,IAAI4H,WAAW,CAACurC,QAAQ,CAACG,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9P;AAEA,IAAIr6C,wBAAwB;AAC5B,CAAC,UAAUA,wBAAwB,EAAE;EACnCA,wBAAwB,CAACA,wBAAwB,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;EACjFA,wBAAwB,CAACA,wBAAwB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EACvEA,wBAAwB,CAACA,wBAAwB,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;AACjF,CAAC,EAAEA,wBAAwB,KAAKA,wBAAwB,GAAG,CAAC,CAAC,CAAC,CAAC;AAE/D,MAAMu6C,iBAAiB,GAAG,IAAIC,GAAG,CAAC,CAAC,SAAS,EAAE,SAAS,EAAE,QAAQ,EAAE,OAAO,EAAE,WAAW,EAAE,mBAAmB,EAAE,QAAQ,EAAE,SAAS,EAAE,WAAW,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,EAAE,SAAS,EAAE,aAAa,EAAE,UAAU,EAAE,QAAQ,EAAE,YAAY,EAAE,UAAU,EAAE,KAAK,EAAE,WAAW,EAAE,UAAU,EAAE,WAAW,EAAE,YAAY,EAAE,OAAO,CAAC,CAAC;AACvV,MAAMC,uBAAuB,GAAG,CAAC,QAAQ,EAAE,WAAW,EAAE,WAAW,EAAE,QAAQ,EAAE,YAAY,EAAE,QAAQ,EAAE,iBAAiB,CAAC;AACzH,MAAMC,SAAS,CAAC;EACdC,WAAWA,CAACC,OAAO,EAAE/hD,QAAQ,EAAEgiD,YAAY,GAAG,EAAE,EAAE;IAChD,MAAMC,QAAQ,GAAG,EAAE;IACnBF,OAAO,GAAGA,OAAO,CAAClgD,OAAO,CAACqgD,UAAU,EAAE5yB,CAAC,IAAI;MACzC,IAAIA,CAAC,CAAC9uB,KAAK,CAAC2hD,kBAAkB,CAAC,EAAE;QAC/BF,QAAQ,CAAC3hD,IAAI,CAACgvB,CAAC,CAAC;MAClB,CAAC,MAAM;QACL,MAAM8yB,eAAe,GAAG9yB,CAAC,CAAC9uB,KAAK,CAAC6hD,WAAW,CAAC;QAC5CJ,QAAQ,CAAC3hD,IAAI,CAAC,CAAC8hD,eAAe,EAAEngD,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,IAAI,IAAI,CAAC;MACzD;MACA,OAAOqgD,mBAAmB;IAC5B,CAAC,CAAC;IACFP,OAAO,GAAG,IAAI,CAACQ,iBAAiB,CAACR,OAAO,CAAC;IACzC,MAAMS,aAAa,GAAG,IAAI,CAACC,aAAa,CAACV,OAAO,EAAE/hD,QAAQ,EAAEgiD,YAAY,CAAC;IACzE,IAAIU,UAAU,GAAG,CAAC;IAClB,OAAOF,aAAa,CAAC3gD,OAAO,CAAC8gD,6BAA6B,EAAE,MAAMV,QAAQ,CAACS,UAAU,EAAE,CAAC,CAAC;EAC3F;EACAH,iBAAiBA,CAACR,OAAO,EAAE;IACzBA,OAAO,GAAG,IAAI,CAACa,kCAAkC,CAACb,OAAO,CAAC;IAC1D,OAAO,IAAI,CAACc,6BAA6B,CAACd,OAAO,CAAC;EACpD;EACAe,yBAAyBA,CAACf,OAAO,EAAEgB,aAAa,EAAE;IAChD,MAAMC,oBAAoB,GAAG,IAAIrB,GAAG,CAAC,CAAC;IACtC,MAAMsB,sBAAsB,GAAGC,YAAY,CAACnB,OAAO,EAAEoB,IAAI,IAAI,IAAI,CAACC,+BAA+B,CAACD,IAAI,EAAEJ,aAAa,EAAEC,oBAAoB,CAAC,CAAC;IAC7I,OAAOE,YAAY,CAACD,sBAAsB,EAAEE,IAAI,IAAI,IAAI,CAACE,mBAAmB,CAACF,IAAI,EAAEJ,aAAa,EAAEC,oBAAoB,CAAC,CAAC;EAC1H;EACAI,+BAA+BA,CAACD,IAAI,EAAEJ,aAAa,EAAEC,oBAAoB,EAAE;IACzE,OAAO;MACL,GAAGG,IAAI;MACPnjD,QAAQ,EAAEmjD,IAAI,CAACnjD,QAAQ,CAAC6B,OAAO,CAAC,sDAAsD,EAAE,CAACyhD,CAAC,EAAE5sB,KAAK,EAAE6sB,KAAK,EAAEC,YAAY,EAAEC,SAAS,KAAK;QACpIT,oBAAoB,CAACU,GAAG,CAACC,cAAc,CAACH,YAAY,EAAED,KAAK,CAAC,CAAC;QAC7D,OAAO,GAAG7sB,KAAK,GAAG6sB,KAAK,GAAGR,aAAa,IAAIS,YAAY,GAAGD,KAAK,GAAGE,SAAS,EAAE;MAC/E,CAAC;IACH,CAAC;EACH;EACAG,uBAAuBA,CAACC,QAAQ,EAAEd,aAAa,EAAEC,oBAAoB,EAAE;IACrE,OAAOa,QAAQ,CAAChiD,OAAO,CAAC,4BAA4B,EAAE,CAACyhD,CAAC,EAAEQ,OAAO,EAAEP,KAAK,EAAEphD,IAAI,EAAE4hD,OAAO,KAAK;MAC1F5hD,IAAI,GAAG,GAAG6gD,oBAAoB,CAACx9C,GAAG,CAACm+C,cAAc,CAACxhD,IAAI,EAAEohD,KAAK,CAAC,CAAC,GAAGR,aAAa,GAAG,GAAG,GAAG,EAAE,GAAG5gD,IAAI,EAAE;MACnG,OAAO,GAAG2hD,OAAO,GAAGP,KAAK,GAAGphD,IAAI,GAAGohD,KAAK,GAAGQ,OAAO,EAAE;IACtD,CAAC,CAAC;EACJ;EACAC,gCAAgC,GAAG,mFAAmF;EACtHX,mBAAmBA,CAACF,IAAI,EAAEJ,aAAa,EAAEC,oBAAoB,EAAE;IAC7D,IAAI5wB,OAAO,GAAG+wB,IAAI,CAAC/wB,OAAO,CAACvwB,OAAO,CAAC,sDAAsD,EAAE,CAACyhD,CAAC,EAAE5sB,KAAK,EAAEutB,qBAAqB,KAAKvtB,KAAK,GAAGutB,qBAAqB,CAACpiD,OAAO,CAAC,IAAI,CAACmiD,gCAAgC,EAAE,CAAClkC,QAAQ,EAAEokC,aAAa,EAAEX,KAAK,GAAG,EAAE,EAAEY,UAAU,EAAEC,aAAa,KAAK;MAC/Q,IAAID,UAAU,EAAE;QACd,OAAO,GAAGD,aAAa,GAAG,IAAI,CAACN,uBAAuB,CAAC,GAAGL,KAAK,GAAGY,UAAU,GAAGZ,KAAK,EAAE,EAAER,aAAa,EAAEC,oBAAoB,CAAC,EAAE;MAChI,CAAC,MAAM;QACL,OAAOtB,iBAAiB,CAACl8C,GAAG,CAAC4+C,aAAa,CAAC,GAAGtkC,QAAQ,GAAG,GAAGokC,aAAa,GAAG,IAAI,CAACN,uBAAuB,CAACQ,aAAa,EAAErB,aAAa,EAAEC,oBAAoB,CAAC,EAAE;MAChK;IACF,CAAC,CAAC,CAAC;IACH5wB,OAAO,GAAGA,OAAO,CAACvwB,OAAO,CAAC,iEAAiE,EAAE,CAACwiD,MAAM,EAAE3tB,KAAK,EAAE4tB,uBAAuB,KAAK,GAAG5tB,KAAK,GAAG4tB,uBAAuB,CAACnzB,KAAK,CAAC,GAAG,CAAC,CAAC3sB,GAAG,CAACq/C,QAAQ,IAAI,IAAI,CAACD,uBAAuB,CAACC,QAAQ,EAAEd,aAAa,EAAEC,oBAAoB,CAAC,CAAC,CAAC/gD,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;IAChS,OAAO;MACL,GAAGkhD,IAAI;MACP/wB;IACF,CAAC;EACH;EACAwwB,kCAAkCA,CAACb,OAAO,EAAE;IAC1C,OAAOA,OAAO,CAAClgD,OAAO,CAAC0iD,yBAAyB,EAAE,UAAU,GAAGj1B,CAAC,EAAE;MAChE,OAAOA,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG;IACnB,CAAC,CAAC;EACJ;EACAuzB,6BAA6BA,CAACd,OAAO,EAAE;IACrC,OAAOA,OAAO,CAAClgD,OAAO,CAAC2iD,iBAAiB,EAAE,CAAC,GAAGl1B,CAAC,KAAK;MAClD,MAAM6zB,IAAI,GAAG7zB,CAAC,CAAC,CAAC,CAAC,CAACztB,OAAO,CAACytB,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAACztB,OAAO,CAACytB,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;MACrD,OAAOA,CAAC,CAAC,CAAC,CAAC,GAAG6zB,IAAI;IACpB,CAAC,CAAC;EACJ;EACAV,aAAaA,CAACV,OAAO,EAAEgB,aAAa,EAAEf,YAAY,EAAE;IAClD,MAAMyC,aAAa,GAAG,IAAI,CAACC,gCAAgC,CAAC3C,OAAO,CAAC;IACpEA,OAAO,GAAG,IAAI,CAAC4C,4BAA4B,CAAC5C,OAAO,CAAC;IACpDA,OAAO,GAAG,IAAI,CAAC6C,iBAAiB,CAAC7C,OAAO,CAAC;IACzCA,OAAO,GAAG,IAAI,CAAC8C,wBAAwB,CAAC9C,OAAO,CAAC;IAChDA,OAAO,GAAG,IAAI,CAAC+C,0BAA0B,CAAC/C,OAAO,CAAC;IAClD,IAAIgB,aAAa,EAAE;MACjBhB,OAAO,GAAG,IAAI,CAACe,yBAAyB,CAACf,OAAO,EAAEgB,aAAa,CAAC;MAChEhB,OAAO,GAAG,IAAI,CAACgD,eAAe,CAAChD,OAAO,EAAEgB,aAAa,EAAEf,YAAY,CAAC;IACtE;IACAD,OAAO,GAAGA,OAAO,GAAG,IAAI,GAAG0C,aAAa;IACxC,OAAO1C,OAAO,CAAChyB,IAAI,CAAC,CAAC;EACvB;EACA20B,gCAAgCA,CAAC3C,OAAO,EAAE;IACxC,IAAIxnB,CAAC,GAAG,EAAE;IACV,IAAIjL,CAAC;IACL01B,yBAAyB,CAACrkD,SAAS,GAAG,CAAC;IACvC,OAAO,CAAC2uB,CAAC,GAAG01B,yBAAyB,CAACpkD,IAAI,CAACmhD,OAAO,CAAC,MAAM,IAAI,EAAE;MAC7D,MAAMoB,IAAI,GAAG7zB,CAAC,CAAC,CAAC,CAAC,CAACztB,OAAO,CAACytB,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAACztB,OAAO,CAACytB,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,CAAC;MACvDiL,CAAC,IAAI4oB,IAAI,GAAG,MAAM;IACpB;IACA,OAAO5oB,CAAC;EACV;EACAqqB,iBAAiBA,CAAC7C,OAAO,EAAE;IACzB,OAAOA,OAAO,CAAClgD,OAAO,CAACojD,eAAe,EAAE,CAAC3B,CAAC,EAAE4B,aAAa,EAAEC,cAAc,KAAK;MAC5E,IAAID,aAAa,EAAE;QACjB,MAAME,kBAAkB,GAAG,EAAE;QAC7B,KAAK,MAAMpD,YAAY,IAAI,IAAI,CAACqD,sBAAsB,CAACH,aAAa,EAAE,IAAI,CAAC,EAAE;UAC3E,MAAMI,mBAAmB,GAAGtD,YAAY,CAACjyB,IAAI,CAAC,CAAC;UAC/C,IAAI,CAACu1B,mBAAmB,EAAE;UAC1B,MAAMC,iBAAiB,GAAGC,yBAAyB,GAAGF,mBAAmB,CAACzjD,OAAO,CAAC4jD,aAAa,EAAE,EAAE,CAAC,GAAGN,cAAc;UACrHC,kBAAkB,CAAC9kD,IAAI,CAACilD,iBAAiB,CAAC;QAC5C;QACA,OAAOH,kBAAkB,CAACnjD,IAAI,CAAC,GAAG,CAAC;MACrC,CAAC,MAAM;QACL,OAAOujD,yBAAyB,GAAGL,cAAc;MACnD;IACF,CAAC,CAAC;EACJ;EACA,CAACE,sBAAsBA,CAAC98C,IAAI,EAAEm9C,oBAAoB,EAAE;IAClD,MAAMrlD,MAAM,GAAGkI,IAAI,CAAClI,MAAM;IAC1B,IAAI6Z,MAAM,GAAG,CAAC;IACd,IAAIyrC,IAAI,GAAG,CAAC;IACZ,KAAK,IAAIlkD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpB,MAAM,EAAEoB,CAAC,EAAE,EAAE;MAC/B,MAAMmkD,QAAQ,GAAGr9C,IAAI,CAACioB,UAAU,CAAC/uB,CAAC,CAAC;MACnC,IAAImkD,QAAQ,KAAKpP,OAAO,EAAE;QACxBt8B,MAAM,EAAE;MACV,CAAC,MAAM,IAAI0rC,QAAQ,KAAKnP,OAAO,EAAE;QAC/Bv8B,MAAM,EAAE;QACR,IAAIA,MAAM,GAAG,CAAC,IAAIwrC,oBAAoB,EAAE;UACtC,MAAMn9C,IAAI,CAACtH,KAAK,CAAC0kD,IAAI,EAAElkD,CAAC,CAAC;UACzB;QACF;MACF,CAAC,MAAM,IAAImkD,QAAQ,KAAKhP,MAAM,IAAI18B,MAAM,KAAK,CAAC,EAAE;QAC9C,MAAM3R,IAAI,CAACtH,KAAK,CAAC0kD,IAAI,EAAElkD,CAAC,CAAC;QACzBkkD,IAAI,GAAGlkD,CAAC,GAAG,CAAC;MACd;IACF;IACA,MAAM8G,IAAI,CAACtH,KAAK,CAAC0kD,IAAI,CAAC;EACxB;EACAd,wBAAwBA,CAAC9C,OAAO,EAAE;IAChC,MAAM9hD,OAAO,GAAG,EAAE;IAClB,KAAK,MAAMo1B,IAAI,IAAI,IAAI,CAACgwB,sBAAsB,CAACtD,OAAO,EAAE,KAAK,CAAC,EAAE;MAC9D9hD,OAAO,CAACK,IAAI,CAAC,IAAI,CAACulD,sCAAsC,CAACxwB,IAAI,CAAC,CAAC;IACjE;IACA,OAAOp1B,OAAO,CAACgC,IAAI,CAAC,GAAG,CAAC;EAC1B;EACA4jD,sCAAsCA,CAAC9D,OAAO,EAAE;IAC9C,OAAOA,OAAO,CAAClgD,OAAO,CAACikD,4BAA4B,EAAE,CAACC,YAAY,EAAEC,YAAY,KAAK;MACnF,MAAMC,qBAAqB,GAAG,CAAC,EAAE,CAAC;MAClC,IAAIC,UAAU,GAAGH,YAAY,CAACj2B,OAAO,CAACq2B,oBAAoB,CAAC;MAC3D,OAAOD,UAAU,KAAK,CAAC,CAAC,EAAE;QACxB,MAAME,WAAW,GAAGL,YAAY,CAAC7L,SAAS,CAACgM,UAAU,GAAGC,oBAAoB,CAAC9lD,MAAM,CAAC;QACpF,IAAI,CAAC+lD,WAAW,IAAIA,WAAW,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;UAC1CL,YAAY,GAAGK,WAAW;UAC1BF,UAAU,GAAGH,YAAY,CAACj2B,OAAO,CAACq2B,oBAAoB,CAAC;UACvD;QACF;QACA,MAAME,mBAAmB,GAAG,EAAE;QAC9B,IAAIC,QAAQ,GAAG,CAAC;QAChB,KAAK,MAAMtmD,QAAQ,IAAI,IAAI,CAACqlD,sBAAsB,CAACe,WAAW,CAAClM,SAAS,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,EAAE;UAClFoM,QAAQ,GAAGA,QAAQ,GAAGtmD,QAAQ,CAACK,MAAM,GAAG,CAAC;UACzC,MAAMkmD,OAAO,GAAGvmD,QAAQ,CAAC+vB,IAAI,CAAC,CAAC;UAC/B,IAAIw2B,OAAO,EAAE;YACXF,mBAAmB,CAAC/lD,IAAI,CAACimD,OAAO,CAAC;UACnC;QACF;QACA,MAAMC,2BAA2B,GAAGP,qBAAqB,CAAC5lD,MAAM;QAChEomD,YAAY,CAACR,qBAAqB,EAAEI,mBAAmB,CAAChmD,MAAM,CAAC;QAC/D,KAAK,IAAIoB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4kD,mBAAmB,CAAChmD,MAAM,EAAEoB,CAAC,EAAE,EAAE;UACnD,KAAK,IAAIyJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGs7C,2BAA2B,EAAEt7C,CAAC,EAAE,EAAE;YACpD+6C,qBAAqB,CAAC/6C,CAAC,GAAGzJ,CAAC,GAAG+kD,2BAA2B,CAAC,CAAClmD,IAAI,CAAC+lD,mBAAmB,CAAC5kD,CAAC,CAAC,CAAC;UACzF;QACF;QACAskD,YAAY,GAAGK,WAAW,CAAClM,SAAS,CAACoM,QAAQ,GAAG,CAAC,CAAC;QAClDJ,UAAU,GAAGH,YAAY,CAACj2B,OAAO,CAACq2B,oBAAoB,CAAC;MACzD;MACA,OAAOF,qBAAqB,CAACzhD,GAAG,CAACkiD,gBAAgB,IAAIC,4BAA4B,CAACD,gBAAgB,EAAEX,YAAY,EAAEC,YAAY,CAAC,CAAC,CAAC/jD,IAAI,CAAC,IAAI,CAAC;IAC7I,CAAC,CAAC;EACJ;EACA6iD,0BAA0BA,CAAC/C,OAAO,EAAE;IAClC,OAAO6E,qBAAqB,CAACp7C,MAAM,CAAC,CAACjK,MAAM,EAAEslD,OAAO,KAAKtlD,MAAM,CAACM,OAAO,CAACglD,OAAO,EAAE,GAAG,CAAC,EAAE9E,OAAO,CAAC;EACjG;EACAgD,eAAeA,CAAChD,OAAO,EAAEgB,aAAa,EAAEf,YAAY,EAAE;IACpD,OAAOkB,YAAY,CAACnB,OAAO,EAAEoB,IAAI,IAAI;MACnC,IAAInjD,QAAQ,GAAGmjD,IAAI,CAACnjD,QAAQ;MAC5B,IAAIoyB,OAAO,GAAG+wB,IAAI,CAAC/wB,OAAO;MAC1B,IAAI+wB,IAAI,CAACnjD,QAAQ,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAC5BA,QAAQ,GAAG,IAAI,CAAC8mD,cAAc,CAAC;UAC7B9mD,QAAQ;UACR+iD,aAAa;UACbf,YAAY;UACZ+E,gBAAgB,EAAE;QACpB,CAAC,CAAC;MACJ,CAAC,MAAM,IAAInF,uBAAuB,CAAC9P,IAAI,CAACkV,MAAM,IAAI7D,IAAI,CAACnjD,QAAQ,CAACyxB,UAAU,CAACu1B,MAAM,CAAC,CAAC,EAAE;QACnF50B,OAAO,GAAG,IAAI,CAAC2yB,eAAe,CAAC5B,IAAI,CAAC/wB,OAAO,EAAE2wB,aAAa,EAAEf,YAAY,CAAC;MAC3E,CAAC,MAAM,IAAImB,IAAI,CAACnjD,QAAQ,CAACyxB,UAAU,CAAC,YAAY,CAAC,IAAI0xB,IAAI,CAACnjD,QAAQ,CAACyxB,UAAU,CAAC,OAAO,CAAC,EAAE;QACtFW,OAAO,GAAG,IAAI,CAAC60B,sBAAsB,CAAC9D,IAAI,CAAC/wB,OAAO,CAAC;MACrD;MACA,OAAO,IAAI80B,OAAO,CAAClnD,QAAQ,EAAEoyB,OAAO,CAAC;IACvC,CAAC,CAAC;EACJ;EACA60B,sBAAsBA,CAAClF,OAAO,EAAE;IAC9B,OAAOmB,YAAY,CAACnB,OAAO,EAAEoB,IAAI,IAAI;MACnC,MAAMnjD,QAAQ,GAAGmjD,IAAI,CAACnjD,QAAQ,CAAC6B,OAAO,CAACslD,oBAAoB,EAAE,GAAG,CAAC,CAACtlD,OAAO,CAACulD,2BAA2B,EAAE,GAAG,CAAC;MAC3G,OAAO,IAAIF,OAAO,CAAClnD,QAAQ,EAAEmjD,IAAI,CAAC/wB,OAAO,CAAC;IAC5C,CAAC,CAAC;EACJ;EACAi1B,aAAa;EACbC,qBAAqB;EACrBR,cAAcA,CAAC;IACb9mD,QAAQ;IACR+iD,aAAa;IACbf,YAAY;IACZ+E,gBAAgB,GAAG;EACrB,CAAC,EAAE;IACD,MAAMQ,eAAe,GAAG,sFAAsF;IAC9G,OAAOvnD,QAAQ,CAACmxB,KAAK,CAACo2B,eAAe,CAAC,CAAC/iD,GAAG,CAAC6wB,IAAI,IAAIA,IAAI,CAAClE,KAAK,CAACg2B,oBAAoB,CAAC,CAAC,CAAC3iD,GAAG,CAACgjD,SAAS,IAAI;MACpG,MAAM,CAACC,WAAW,EAAE,GAAGC,UAAU,CAAC,GAAGF,SAAS;MAC9C,MAAMG,UAAU,GAAGF,WAAW,IAAI;QAChC,IAAI,IAAI,CAACG,qBAAqB,CAACH,WAAW,EAAE1E,aAAa,CAAC,EAAE;UAC1D,OAAO,IAAI,CAAC8E,mBAAmB,CAAC;YAC9B7nD,QAAQ,EAAEynD,WAAW;YACrB1E,aAAa;YACbf,YAAY;YACZ+E;UACF,CAAC,CAAC;QACJ,CAAC,MAAM;UACL,OAAOU,WAAW;QACpB;MACF,CAAC;MACD,OAAO,CAACE,UAAU,CAACF,WAAW,CAAC,EAAE,GAAGC,UAAU,CAAC,CAACzlD,IAAI,CAAC,GAAG,CAAC;IAC3D,CAAC,CAAC,CAACA,IAAI,CAAC,IAAI,CAAC;EACf;EACA2lD,qBAAqBA,CAAC5nD,QAAQ,EAAE+iD,aAAa,EAAE;IAC7C,MAAM+E,EAAE,GAAG,IAAI,CAACC,iBAAiB,CAAChF,aAAa,CAAC;IAChD,OAAO,CAAC+E,EAAE,CAACp2B,IAAI,CAAC1xB,QAAQ,CAAC;EAC3B;EACA+nD,iBAAiBA,CAAChF,aAAa,EAAE;IAC/B,MAAMiF,GAAG,GAAG,KAAK;IACjB,MAAMC,GAAG,GAAG,KAAK;IACjBlF,aAAa,GAAGA,aAAa,CAAClhD,OAAO,CAACmmD,GAAG,EAAE,KAAK,CAAC,CAACnmD,OAAO,CAAComD,GAAG,EAAE,KAAK,CAAC;IACrE,OAAO,IAAIxoD,MAAM,CAAC,IAAI,GAAGsjD,aAAa,GAAG,GAAG,GAAGmF,iBAAiB,EAAE,GAAG,CAAC;EACxE;EACAC,yBAAyBA,CAACnoD,QAAQ,EAAE+iD,aAAa,EAAEf,YAAY,EAAE;IAC/DoG,eAAe,CAACznD,SAAS,GAAG,CAAC;IAC7B,IAAIynD,eAAe,CAAC12B,IAAI,CAAC1xB,QAAQ,CAAC,EAAE;MAClC,MAAMqoD,SAAS,GAAG,IAAIrG,YAAY,GAAG;MACrC,IAAIzgD,MAAM,GAAGvB,QAAQ;MACrB,OAAOuB,MAAM,CAACf,KAAK,CAAC4mD,2BAA2B,CAAC,EAAE;QAChD7lD,MAAM,GAAGA,MAAM,CAACM,OAAO,CAACulD,2BAA2B,EAAE,CAACkB,IAAI,EAAEtoD,QAAQ,KAAK;UACvE,OAAOA,QAAQ,CAAC6B,OAAO,CAAC,mBAAmB,EAAE,CAACyhD,CAAC,EAAE1I,MAAM,EAAE2N,KAAK,EAAE1N,KAAK,KAAK;YACxE,OAAOD,MAAM,GAAGyN,SAAS,GAAGE,KAAK,GAAG1N,KAAK;UAC3C,CAAC,CAAC;QACJ,CAAC,CAAC;MACJ;MACA,OAAOt5C,MAAM,CAACM,OAAO,CAACumD,eAAe,EAAEC,SAAS,CAAC;IACnD;IACA,OAAOtF,aAAa,GAAG,GAAG,GAAG/iD,QAAQ;EACvC;EACA6nD,mBAAmBA,CAAC;IAClB7nD,QAAQ;IACR+iD,aAAa;IACbf,YAAY;IACZ+E;EACF,CAAC,EAAE;IACD,MAAMyB,IAAI,GAAG,kBAAkB;IAC/BzF,aAAa,GAAGA,aAAa,CAAClhD,OAAO,CAAC2mD,IAAI,EAAE,CAAClF,CAAC,EAAE,GAAGr7C,KAAK,KAAKA,KAAK,CAAC,CAAC,CAAC,CAAC;IACtE,MAAMwgD,QAAQ,GAAG,IAAI1F,aAAa,GAAG;IACrC,MAAM2F,kBAAkB,GAAGhvC,CAAC,IAAI;MAC9B,IAAIivC,OAAO,GAAGjvC,CAAC,CAACqW,IAAI,CAAC,CAAC;MACtB,IAAI,CAAC44B,OAAO,EAAE;QACZ,OAAOjvC,CAAC;MACV;MACA,IAAIA,CAAC,CAACkvC,QAAQ,CAACpD,yBAAyB,CAAC,EAAE;QACzCmD,OAAO,GAAG,IAAI,CAACR,yBAAyB,CAACzuC,CAAC,EAAEqpC,aAAa,EAAEf,YAAY,CAAC;QACxE,IAAI,CAACtoC,CAAC,CAAClZ,KAAK,CAACqoD,8CAA8C,CAAC,EAAE;UAC5D,MAAM,CAACvF,CAAC,EAAE1I,MAAM,EAAE2N,KAAK,EAAE1N,KAAK,CAAC,GAAG8N,OAAO,CAACnoD,KAAK,CAAC,sBAAsB,CAAC;UACvEmoD,OAAO,GAAG/N,MAAM,GAAG6N,QAAQ,GAAGF,KAAK,GAAG1N,KAAK;QAC7C;MACF,CAAC,MAAM;QACL,MAAMjhB,CAAC,GAAGlgB,CAAC,CAAC7X,OAAO,CAACumD,eAAe,EAAE,EAAE,CAAC;QACxC,IAAIxuB,CAAC,CAACv5B,MAAM,GAAG,CAAC,EAAE;UAChB,MAAMyoD,OAAO,GAAGlvB,CAAC,CAACp5B,KAAK,CAAC,sBAAsB,CAAC;UAC/C,IAAIsoD,OAAO,EAAE;YACXH,OAAO,GAAGG,OAAO,CAAC,CAAC,CAAC,GAAGL,QAAQ,GAAGK,OAAO,CAAC,CAAC,CAAC,GAAGA,OAAO,CAAC,CAAC,CAAC;UAC3D;QACF;MACF;MACA,OAAOH,OAAO;IAChB,CAAC;IACD,MAAMI,qCAAqC,GAAGC,YAAY,IAAI;MAC5D,IAAIC,UAAU,GAAG,EAAE;MACnB,MAAMC,mBAAmB,GAAG,EAAE;MAC9B,IAAIC,mBAAmB;MACvB,OAAO,CAACA,mBAAmB,GAAGC,oCAAoC,CAACxoD,IAAI,CAACooD,YAAY,CAAC,MAAM,IAAI,EAAE;QAC/F,IAAIK,cAAc,GAAG,CAAC;QACtB,IAAIz9C,KAAK,GAAGw9C,oCAAoC,CAACzoD,SAAS;QAC1D,OAAOiL,KAAK,GAAGo9C,YAAY,CAAC3oD,MAAM,EAAE;UAClC,MAAMipD,aAAa,GAAGN,YAAY,CAACp9C,KAAK,CAAC;UACzCA,KAAK,EAAE;UACP,IAAI09C,aAAa,KAAK,GAAG,EAAE;YACzBD,cAAc,EAAE;YAChB;UACF;UACA,IAAIC,aAAa,KAAK,GAAG,EAAE;YACzBD,cAAc,EAAE;YAChB,IAAIA,cAAc,KAAK,CAAC,EAAE;cACxB;YACF;YACA;UACF;QACF;QACAH,mBAAmB,CAAC5oD,IAAI,CAAC,GAAG6oD,mBAAmB,CAAC,CAAC,CAAC,GAAGH,YAAY,CAAC/nD,KAAK,CAACmoD,oCAAoC,CAACzoD,SAAS,EAAEiL,KAAK,CAAC,EAAE,CAAC;QACjIw9C,oCAAoC,CAACzoD,SAAS,GAAGiL,KAAK;MACxD;MACA,IAAIs9C,mBAAmB,CAACjnD,IAAI,CAAC,EAAE,CAAC,KAAK+mD,YAAY,EAAE;QACjDC,UAAU,GAAGC,mBAAmB,CAAC1kD,GAAG,CAACwkD,YAAY,IAAI;UACnD,MAAM,CAACO,yBAAyB,CAAC,GAAGP,YAAY,CAACxoD,KAAK,CAAC4oD,oCAAoC,CAAC,IAAI,EAAE;UAClG,MAAMI,eAAe,GAAGR,YAAY,CAAC/nD,KAAK,CAACsoD,yBAAyB,EAAElpD,MAAM,EAAE,CAAC,CAAC,CAAC;UACjF,IAAImpD,eAAe,CAACZ,QAAQ,CAACpD,yBAAyB,CAAC,EAAE;YACvD,IAAI,CAAC8B,qBAAqB,GAAG,IAAI;UACnC;UACA,MAAMmC,eAAe,GAAG,IAAI,CAAC3C,cAAc,CAAC;YAC1C9mD,QAAQ,EAAEwpD,eAAe;YACzBzG,aAAa;YACbf;UACF,CAAC,CAAC;UACF,OAAO,GAAGuH,yBAAyB,GAAGE,eAAe,GAAG;QAC1D,CAAC,CAAC,CAACxnD,IAAI,CAAC,EAAE,CAAC;MACb,CAAC,MAAM;QACL,IAAI,CAACqlD,qBAAqB,GAAG,IAAI,CAACA,qBAAqB,IAAI0B,YAAY,CAACJ,QAAQ,CAACpD,yBAAyB,CAAC;QAC3GyD,UAAU,GAAG,IAAI,CAAC3B,qBAAqB,GAAGoB,kBAAkB,CAACM,YAAY,CAAC,GAAGA,YAAY;MAC3F;MACA,OAAOC,UAAU;IACnB,CAAC;IACD,IAAIlC,gBAAgB,EAAE;MACpB,IAAI,CAACM,aAAa,GAAG,IAAIqC,YAAY,CAAC1pD,QAAQ,CAAC;MAC/CA,QAAQ,GAAG,IAAI,CAACqnD,aAAa,CAACj1B,OAAO,CAAC,CAAC;IACzC;IACA,IAAIu3B,cAAc,GAAG,EAAE;IACvB,IAAIzD,UAAU,GAAG,CAAC;IAClB,IAAI/lD,GAAG;IACP,MAAMypD,GAAG,GAAG,kGAAkG;IAC9G,MAAMC,OAAO,GAAG7pD,QAAQ,CAAC4oD,QAAQ,CAACpD,yBAAyB,CAAC;IAC5D,IAAIuB,gBAAgB,IAAI,IAAI,CAACO,qBAAqB,EAAE;MAClD,IAAI,CAACA,qBAAqB,GAAG,CAACuC,OAAO;IACvC;IACA,OAAO,CAAC1pD,GAAG,GAAGypD,GAAG,CAAChpD,IAAI,CAACZ,QAAQ,CAAC,MAAM,IAAI,EAAE;MAC1C,MAAM83B,SAAS,GAAG33B,GAAG,CAAC,CAAC,CAAC;MACxB,MAAMk1B,IAAI,GAAGr1B,QAAQ,CAACiB,KAAK,CAACilD,UAAU,EAAE/lD,GAAG,CAACyL,KAAK,CAAC;MAClD,IAAIypB,IAAI,CAAC70B,KAAK,CAAC,kBAAkB,CAAC,IAAIR,QAAQ,CAACG,GAAG,CAACyL,KAAK,GAAG,CAAC,CAAC,EAAEpL,KAAK,CAAC,YAAY,CAAC,EAAE;QAClF;MACF;MACA,MAAMyoD,UAAU,GAAGF,qCAAqC,CAAC1zB,IAAI,CAAC;MAC9Ds0B,cAAc,IAAI,GAAGV,UAAU,IAAInxB,SAAS,GAAG;MAC/CouB,UAAU,GAAG0D,GAAG,CAACjpD,SAAS;IAC5B;IACA,MAAM00B,IAAI,GAAGr1B,QAAQ,CAACk6C,SAAS,CAACgM,UAAU,CAAC;IAC3CyD,cAAc,IAAIZ,qCAAqC,CAAC1zB,IAAI,CAAC;IAC7D,OAAO,IAAI,CAACgyB,aAAa,CAACyC,OAAO,CAACH,cAAc,CAAC;EACnD;EACAhF,4BAA4BA,CAAC3kD,QAAQ,EAAE;IACrC,OAAOA,QAAQ,CAAC6B,OAAO,CAACkoD,mBAAmB,EAAE5D,oBAAoB,CAAC,CAACtkD,OAAO,CAACmoD,YAAY,EAAEvE,aAAa,CAAC;EACzG;AACF;AACA,MAAMiE,YAAY,CAAC;EACjB7e,YAAY,GAAG,EAAE;EACjBj/B,KAAK,GAAG,CAAC;EACTq+C,QAAQ;EACR9kD,WAAWA,CAACnF,QAAQ,EAAE;IACpBA,QAAQ,GAAG,IAAI,CAACkqD,mBAAmB,CAAClqD,QAAQ,EAAE,eAAe,CAAC;IAC9DA,QAAQ,GAAGA,QAAQ,CAAC6B,OAAO,CAAC,QAAQ,EAAE,CAACyhD,CAAC,EAAE6G,IAAI,KAAK;MACjD,MAAM9B,SAAS,GAAG,YAAY,IAAI,CAACz8C,KAAK,IAAI;MAC5C,IAAI,CAACi/B,YAAY,CAACvqC,IAAI,CAAC6pD,IAAI,CAAC;MAC5B,IAAI,CAACv+C,KAAK,EAAE;MACZ,OAAOy8C,SAAS;IAClB,CAAC,CAAC;IACF,IAAI,CAAC4B,QAAQ,GAAGjqD,QAAQ,CAAC6B,OAAO,CAACuoD,QAAQ,EAAE,CAAC9G,CAAC,EAAE+G,MAAM,EAAElrC,GAAG,KAAK;MAC7D,MAAMkpC,SAAS,GAAG,QAAQ,IAAI,CAACz8C,KAAK,IAAI;MACxC,IAAI,CAACi/B,YAAY,CAACvqC,IAAI,CAAC,IAAI6e,GAAG,GAAG,CAAC;MAClC,IAAI,CAACvT,KAAK,EAAE;MACZ,OAAOy+C,MAAM,GAAGhC,SAAS;IAC3B,CAAC,CAAC;EACJ;EACAyB,OAAOA,CAAC13B,OAAO,EAAE;IACf,OAAOA,OAAO,CAACvwB,OAAO,CAAC,0BAA0B,EAAE,CAACyoD,GAAG,EAAE1+C,KAAK,KAAK,IAAI,CAACi/B,YAAY,CAAC,CAACj/B,KAAK,CAAC,CAAC;EAC/F;EACAwmB,OAAOA,CAAA,EAAG;IACR,OAAO,IAAI,CAAC63B,QAAQ;EACtB;EACAC,mBAAmBA,CAAC93B,OAAO,EAAEy0B,OAAO,EAAE;IACpC,OAAOz0B,OAAO,CAACvwB,OAAO,CAACglD,OAAO,EAAE,CAACvD,CAAC,EAAE6G,IAAI,KAAK;MAC3C,MAAM9B,SAAS,GAAG,QAAQ,IAAI,CAACz8C,KAAK,IAAI;MACxC,IAAI,CAACi/B,YAAY,CAACvqC,IAAI,CAAC6pD,IAAI,CAAC;MAC5B,IAAI,CAACv+C,KAAK,EAAE;MACZ,OAAOy8C,SAAS;IAClB,CAAC,CAAC;EACJ;AACF;AACA,MAAMkC,8BAA8B,GAAG,mBAAmB;AAC1D,MAAMnB,oCAAoC,GAAG,iBAAiB;AAC9D,MAAM7E,yBAAyB,GAAG,2EAA2E;AAC7G,MAAMC,iBAAiB,GAAG,iEAAiE;AAC3F,MAAMQ,yBAAyB,GAAG,0EAA0E;AAC5G,MAAMS,aAAa,GAAG,gBAAgB;AACtC,MAAMU,oBAAoB,GAAG,mBAAmB;AAChD,MAAMqE,SAAS,GAAG,QAAQ;AAC1B,MAAMC,aAAa,GAAGj7C,MAAM,CAAC8I,GAAG,QAAQkyC,SAAS,MAAMA,SAAS,KAAK;AACrE,MAAME,aAAa,GAAGl7C,MAAM,CAAC8I,GAAG,QAAQmyC,aAAa,MAAMD,SAAS,KAAK;AACzE,MAAMG,YAAY,GAAGn7C,MAAM,CAAC8I,GAAG,SAASoyC,aAAa,MAAM;AAC3D,MAAMN,QAAQ,GAAG,IAAI3qD,MAAM,CAAC+P,MAAM,CAAC8I,GAAG,eAAe,GAAGqyC,YAAY,EAAE,GAAG,CAAC;AAC1E,MAAM1F,eAAe,GAAG,IAAIxlD,MAAM,CAACgmD,aAAa,GAAGkF,YAAY,GAAG,WAAW,EAAE,KAAK,CAAC;AACrF,MAAMC,mBAAmB,GAAGzE,oBAAoB,GAAGwE,YAAY,GAAG,UAAU;AAC5E,MAAM7E,4BAA4B,GAAG,IAAIrmD,MAAM,CAAC,GAAG8qD,8BAA8B,IAAIK,mBAAmB,GAAG,EAAE,KAAK,CAAC;AACnH,MAAMpF,yBAAyB,GAAGC,aAAa,GAAG,gBAAgB;AAClE,MAAMoD,8CAA8C,GAAG,IAAIppD,MAAM,CAAC,GAAG+lD,yBAAyB,cAAc,EAAE,GAAG,CAAC;AAClH,MAAM4B,2BAA2B,GAAG,uCAAuC;AAC3E,MAAMR,qBAAqB,GAAG,CAAC,WAAW,EAAE,YAAY,EAAE,kBAAkB,EAAE,aAAa,CAAC;AAC5F,MAAMO,oBAAoB,GAAG,qCAAqC;AAClE,MAAMe,iBAAiB,GAAG,4BAA4B;AACtD,MAAME,eAAe,GAAG,mBAAmB;AAC3C,MAAM4B,YAAY,GAAG,UAAU;AAC/B,MAAMD,mBAAmB,GAAG,kBAAkB;AAC9C,MAAM1H,WAAW,GAAG,QAAQ;AAC5B,MAAMH,UAAU,GAAG,mBAAmB;AACtC,MAAMC,kBAAkB,GAAG,kCAAkC;AAC7D,MAAMG,mBAAmB,GAAG,WAAW;AACvC,MAAMK,6BAA6B,GAAG,IAAIljD,MAAM,CAAC6iD,mBAAmB,EAAE,GAAG,CAAC;AAC1E,MAAMuI,iBAAiB,GAAG,SAAS;AACnC,MAAMC,OAAO,GAAG,IAAIrrD,MAAM,CAAC,WAAW6iD,mBAAmB,6DAA6D,EAAE,GAAG,CAAC;AAC5H,MAAMyI,aAAa,GAAG,IAAIhoD,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;AAC3C,MAAMioD,oBAAoB,GAAG,wBAAwB;AACrD,MAAMC,mBAAmB,GAAG,uBAAuB;AACnD,MAAMC,oBAAoB,GAAG,wBAAwB;AACrD,MAAMC,8BAA8B,GAAG,IAAI1rD,MAAM,CAACurD,oBAAoB,EAAE,GAAG,CAAC;AAC5E,MAAMI,6BAA6B,GAAG,IAAI3rD,MAAM,CAACwrD,mBAAmB,EAAE,GAAG,CAAC;AAC1E,MAAMI,8BAA8B,GAAG,IAAI5rD,MAAM,CAACyrD,oBAAoB,EAAE,GAAG,CAAC;AAC5E,MAAMhE,OAAO,CAAC;EACZlnD,QAAQ;EACRoyB,OAAO;EACPjtB,WAAWA,CAACnF,QAAQ,EAAEoyB,OAAO,EAAE;IAC7B,IAAI,CAACpyB,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACoyB,OAAO,GAAGA,OAAO;EACxB;AACF;AACA,SAAS8wB,YAAYA,CAAC7zB,KAAK,EAAEi8B,YAAY,EAAE;EACzC,MAAMC,OAAO,GAAGC,eAAe,CAACn8B,KAAK,CAAC;EACtC,MAAMo8B,sBAAsB,GAAGC,YAAY,CAACH,OAAO,EAAER,aAAa,EAAEF,iBAAiB,CAAC;EACtF,IAAIc,cAAc,GAAG,CAAC;EACtB,MAAMC,aAAa,GAAGH,sBAAsB,CAACI,aAAa,CAAChqD,OAAO,CAACipD,OAAO,EAAE,CAAC,GAAGx7B,CAAC,KAAK;IACpF,MAAMtvB,QAAQ,GAAGsvB,CAAC,CAAC,CAAC,CAAC;IACrB,IAAI8C,OAAO,GAAG,EAAE;IAChB,IAAI05B,MAAM,GAAGx8B,CAAC,CAAC,CAAC,CAAC;IACjB,IAAIy8B,aAAa,GAAG,EAAE;IACtB,IAAID,MAAM,IAAIA,MAAM,CAACr6B,UAAU,CAAC,GAAG,GAAGo5B,iBAAiB,CAAC,EAAE;MACxDz4B,OAAO,GAAGq5B,sBAAsB,CAACO,MAAM,CAACL,cAAc,EAAE,CAAC;MACzDG,MAAM,GAAGA,MAAM,CAAC5R,SAAS,CAAC2Q,iBAAiB,CAACxqD,MAAM,GAAG,CAAC,CAAC;MACvD0rD,aAAa,GAAG,GAAG;IACrB;IACA,MAAM5I,IAAI,GAAGmI,YAAY,CAAC,IAAIpE,OAAO,CAAClnD,QAAQ,EAAEoyB,OAAO,CAAC,CAAC;IACzD,OAAO,GAAG9C,CAAC,CAAC,CAAC,CAAC,GAAG6zB,IAAI,CAACnjD,QAAQ,GAAGsvB,CAAC,CAAC,CAAC,CAAC,GAAGy8B,aAAa,GAAG5I,IAAI,CAAC/wB,OAAO,GAAG05B,MAAM,EAAE;EACjF,CAAC,CAAC;EACF,OAAOG,iBAAiB,CAACL,aAAa,CAAC;AACzC;AACA,MAAMM,uBAAuB,CAAC;EAC5BL,aAAa;EACbG,MAAM;EACN7mD,WAAWA,CAAC0mD,aAAa,EAAEG,MAAM,EAAE;IACjC,IAAI,CAACH,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACG,MAAM,GAAGA,MAAM;EACtB;AACF;AACA,SAASN,YAAYA,CAACr8B,KAAK,EAAE88B,SAAS,EAAEp0C,WAAW,EAAE;EACnD,MAAMq0C,WAAW,GAAG,EAAE;EACtB,MAAMC,aAAa,GAAG,EAAE;EACxB,IAAIC,aAAa,GAAG,CAAC;EACrB,IAAIC,kBAAkB,GAAG,CAAC;EAC1B,IAAIC,eAAe,GAAG,CAAC,CAAC;EACxB,IAAIC,QAAQ;EACZ,IAAIC,SAAS;EACb,KAAK,IAAIjrD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4tB,KAAK,CAAChvB,MAAM,EAAEoB,CAAC,EAAE,EAAE;IACrC,MAAMC,IAAI,GAAG2tB,KAAK,CAAC5tB,CAAC,CAAC;IACrB,IAAIC,IAAI,KAAK,IAAI,EAAE;MACjBD,CAAC,EAAE;IACL,CAAC,MAAM,IAAIC,IAAI,KAAKgrD,SAAS,EAAE;MAC7BJ,aAAa,EAAE;MACf,IAAIA,aAAa,KAAK,CAAC,EAAE;QACvBD,aAAa,CAAC/rD,IAAI,CAAC+uB,KAAK,CAAC6qB,SAAS,CAACsS,eAAe,EAAE/qD,CAAC,CAAC,CAAC;QACvD2qD,WAAW,CAAC9rD,IAAI,CAACyX,WAAW,CAAC;QAC7Bw0C,kBAAkB,GAAG9qD,CAAC;QACtB+qD,eAAe,GAAG,CAAC,CAAC;QACpBC,QAAQ,GAAGC,SAAS,GAAGx8B,SAAS;MAClC;IACF,CAAC,MAAM,IAAIxuB,IAAI,KAAK+qD,QAAQ,EAAE;MAC5BH,aAAa,EAAE;IACjB,CAAC,MAAM,IAAIA,aAAa,KAAK,CAAC,IAAIH,SAAS,CAAC3mD,GAAG,CAAC9D,IAAI,CAAC,EAAE;MACrD+qD,QAAQ,GAAG/qD,IAAI;MACfgrD,SAAS,GAAGP,SAAS,CAAC/nD,GAAG,CAAC1C,IAAI,CAAC;MAC/B4qD,aAAa,GAAG,CAAC;MACjBE,eAAe,GAAG/qD,CAAC,GAAG,CAAC;MACvB2qD,WAAW,CAAC9rD,IAAI,CAAC+uB,KAAK,CAAC6qB,SAAS,CAACqS,kBAAkB,EAAEC,eAAe,CAAC,CAAC;IACxE;EACF;EACA,IAAIA,eAAe,KAAK,CAAC,CAAC,EAAE;IAC1BH,aAAa,CAAC/rD,IAAI,CAAC+uB,KAAK,CAAC6qB,SAAS,CAACsS,eAAe,CAAC,CAAC;IACpDJ,WAAW,CAAC9rD,IAAI,CAACyX,WAAW,CAAC;EAC/B,CAAC,MAAM;IACLq0C,WAAW,CAAC9rD,IAAI,CAAC+uB,KAAK,CAAC6qB,SAAS,CAACqS,kBAAkB,CAAC,CAAC;EACvD;EACA,OAAO,IAAIL,uBAAuB,CAACE,WAAW,CAACnqD,IAAI,CAAC,EAAE,CAAC,EAAEoqD,aAAa,CAAC;AACzE;AACA,MAAMM,oBAAoB,GAAG;EAC3B,GAAG,EAAE1B,mBAAmB;EACxB,GAAG,EAAED,oBAAoB;EACzB,GAAG,EAAEE;AACP,CAAC;AACD,SAASM,eAAeA,CAACn8B,KAAK,EAAE;EAC9B,IAAI9tB,MAAM,GAAG8tB,KAAK;EAClB,IAAIu9B,gBAAgB,GAAG,IAAI;EAC3B,KAAK,IAAInrD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,MAAM,CAAClB,MAAM,EAAEoB,CAAC,EAAE,EAAE;IACtC,MAAMC,IAAI,GAAGH,MAAM,CAACE,CAAC,CAAC;IACtB,IAAIC,IAAI,KAAK,IAAI,EAAE;MACjBD,CAAC,EAAE;IACL,CAAC,MAAM;MACL,IAAImrD,gBAAgB,KAAK,IAAI,EAAE;QAC7B,IAAIlrD,IAAI,KAAKkrD,gBAAgB,EAAE;UAC7BA,gBAAgB,GAAG,IAAI;QACzB,CAAC,MAAM;UACL,MAAM70C,WAAW,GAAG40C,oBAAoB,CAACjrD,IAAI,CAAC;UAC9C,IAAIqW,WAAW,EAAE;YACfxW,MAAM,GAAG,GAAGA,MAAM,CAACsrD,MAAM,CAAC,CAAC,EAAEprD,CAAC,CAAC,GAAGsW,WAAW,GAAGxW,MAAM,CAACsrD,MAAM,CAACprD,CAAC,GAAG,CAAC,CAAC,EAAE;YACtEA,CAAC,IAAIsW,WAAW,CAAC1X,MAAM,GAAG,CAAC;UAC7B;QACF;MACF,CAAC,MAAM,IAAIqB,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,GAAG,EAAE;QACvCkrD,gBAAgB,GAAGlrD,IAAI;MACzB;IACF;EACF;EACA,OAAOH,MAAM;AACf;AACA,SAAS0qD,iBAAiBA,CAAC58B,KAAK,EAAE;EAChC,IAAI9tB,MAAM,GAAG8tB,KAAK,CAACxtB,OAAO,CAACspD,8BAA8B,EAAE,GAAG,CAAC;EAC/D5pD,MAAM,GAAGA,MAAM,CAACM,OAAO,CAACupD,6BAA6B,EAAE,GAAG,CAAC;EAC3D7pD,MAAM,GAAGA,MAAM,CAACM,OAAO,CAACwpD,8BAA8B,EAAE,GAAG,CAAC;EAC5D,OAAO9pD,MAAM;AACf;AACA,SAASoiD,cAAcA,CAAC75C,GAAG,EAAEgjD,QAAQ,EAAE;EACrC,OAAO,CAACA,QAAQ,GAAGhjD,GAAG,GAAGA,GAAG,CAACjI,OAAO,CAAC,mCAAmC,EAAE,IAAI,CAAC;AACjF;AACA,SAAS8kD,4BAA4BA,CAACD,gBAAgB,EAAEvB,cAAc,EAAEa,YAAY,GAAG,EAAE,EAAE;EACzF,MAAM+G,UAAU,GAAGvH,yBAAyB;EAC5C4C,eAAe,CAACznD,SAAS,GAAG,CAAC;EAC7B,MAAMqsD,qBAAqB,GAAG5E,eAAe,CAAC12B,IAAI,CAACyzB,cAAc,CAAC;EAClE,IAAIuB,gBAAgB,CAACrmD,MAAM,KAAK,CAAC,EAAE;IACjC,OAAO0sD,UAAU,GAAG5H,cAAc;EACpC;EACA,MAAM8H,QAAQ,GAAG,CAACvG,gBAAgB,CAAClxB,GAAG,CAAC,CAAC,IAAI,EAAE,CAAC;EAC/C,OAAOkxB,gBAAgB,CAACrmD,MAAM,GAAG,CAAC,EAAE;IAClC,MAAMA,MAAM,GAAG4sD,QAAQ,CAAC5sD,MAAM;IAC9B,MAAM6sD,eAAe,GAAGxG,gBAAgB,CAAClxB,GAAG,CAAC,CAAC;IAC9C,KAAK,IAAI/zB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpB,MAAM,EAAEoB,CAAC,EAAE,EAAE;MAC/B,MAAM0rD,iBAAiB,GAAGF,QAAQ,CAACxrD,CAAC,CAAC;MACrCwrD,QAAQ,CAAC5sD,MAAM,GAAG,CAAC,GAAGoB,CAAC,CAAC,GAAG0rD,iBAAiB,GAAG,GAAG,GAAGD,eAAe;MACpED,QAAQ,CAAC5sD,MAAM,GAAGoB,CAAC,CAAC,GAAGyrD,eAAe,GAAG,GAAG,GAAGC,iBAAiB;MAChEF,QAAQ,CAACxrD,CAAC,CAAC,GAAGyrD,eAAe,GAAGC,iBAAiB;IACnD;EACF;EACA,OAAOF,QAAQ,CAACzoD,GAAG,CAAC4rB,CAAC,IAAI48B,qBAAqB,GAAG,GAAGhH,YAAY,GAAG51B,CAAC,GAAG+0B,cAAc,EAAE,GAAG,GAAGa,YAAY,GAAG51B,CAAC,GAAG28B,UAAU,GAAG5H,cAAc,KAAKa,YAAY,GAAG51B,CAAC,IAAI28B,UAAU,GAAG5H,cAAc,EAAE,CAAC,CAACljD,IAAI,CAAC,GAAG,CAAC;AAC9M;AACA,SAASwkD,YAAYA,CAAC2G,MAAM,EAAEC,SAAS,EAAE;EACvC,MAAMhtD,MAAM,GAAG+sD,MAAM,CAAC/sD,MAAM;EAC5B,KAAK,IAAIoB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4rD,SAAS,EAAE5rD,CAAC,EAAE,EAAE;IAClC,KAAK,IAAIyJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7K,MAAM,EAAE6K,CAAC,EAAE,EAAE;MAC/BkiD,MAAM,CAACliD,CAAC,GAAGzJ,CAAC,GAAGpB,MAAM,CAAC,GAAG+sD,MAAM,CAACliD,CAAC,CAAC,CAACjK,KAAK,CAAC,CAAC,CAAC;IAC7C;EACF;AACF;AAEA,IAAIqsD,MAAM;AACV,CAAC,UAAUA,MAAM,EAAE;EACjBA,MAAM,CAACA,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;EACzCA,MAAM,CAACA,MAAM,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;EAC7CA,MAAM,CAACA,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EAC3CA,MAAM,CAACA,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,GAAG,cAAc;EACnDA,MAAM,CAACA,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;EACzCA,MAAM,CAACA,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EAC3CA,MAAM,CAACA,MAAM,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,GAAG,YAAY;EAC/CA,MAAM,CAACA,MAAM,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC,GAAG,gBAAgB;EACvDA,MAAM,CAACA,MAAM,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;EAC7CA,MAAM,CAACA,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,GAAG,cAAc;EACnDA,MAAM,CAACA,MAAM,CAAC,iBAAiB,CAAC,GAAG,EAAE,CAAC,GAAG,iBAAiB;EAC1DA,MAAM,CAACA,MAAM,CAAC,mBAAmB,CAAC,GAAG,EAAE,CAAC,GAAG,mBAAmB;EAC9DA,MAAM,CAACA,MAAM,CAAC,yBAAyB,CAAC,GAAG,EAAE,CAAC,GAAG,yBAAyB;EAC1EA,MAAM,CAACA,MAAM,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC,GAAG,aAAa;EAClDA,MAAM,CAACA,MAAM,CAAC,gBAAgB,CAAC,GAAG,EAAE,CAAC,GAAG,gBAAgB;EACxDA,MAAM,CAACA,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG,MAAM;EACpCA,MAAM,CAACA,MAAM,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,GAAG,UAAU;EAC5CA,MAAM,CAACA,MAAM,CAAC,iBAAiB,CAAC,GAAG,EAAE,CAAC,GAAG,iBAAiB;EAC1DA,MAAM,CAACA,MAAM,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,GAAG,SAAS;EAC1CA,MAAM,CAACA,MAAM,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,GAAG,UAAU;EAC5CA,MAAM,CAACA,MAAM,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,GAAG,WAAW;EAC9CA,MAAM,CAACA,MAAM,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,GAAG,WAAW;EAC9CA,MAAM,CAACA,MAAM,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,GAAG,UAAU;EAC5CA,MAAM,CAACA,MAAM,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,GAAG,UAAU;EAC5CA,MAAM,CAACA,MAAM,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,GAAG,SAAS;EAC1CA,MAAM,CAACA,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG,MAAM;EACpCA,MAAM,CAACA,MAAM,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,GAAG,WAAW;EAC9CA,MAAM,CAACA,MAAM,CAAC,oBAAoB,CAAC,GAAG,EAAE,CAAC,GAAG,oBAAoB;EAChEA,MAAM,CAACA,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,GAAG,OAAO;EACtCA,MAAM,CAACA,MAAM,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,GAAG,SAAS;EAC1CA,MAAM,CAACA,MAAM,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,GAAG,WAAW;EAC9CA,MAAM,CAACA,MAAM,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC,GAAG,aAAa;EAClDA,MAAM,CAACA,MAAM,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC,GAAG,aAAa;EAClDA,MAAM,CAACA,MAAM,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,GAAG,WAAW;EAC9CA,MAAM,CAACA,MAAM,CAAC,eAAe,CAAC,GAAG,EAAE,CAAC,GAAG,eAAe;EACtDA,MAAM,CAACA,MAAM,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC,GAAG,YAAY;EAChDA,MAAM,CAACA,MAAM,CAAC,gBAAgB,CAAC,GAAG,EAAE,CAAC,GAAG,gBAAgB;EACxDA,MAAM,CAACA,MAAM,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,GAAG,UAAU;EAC5CA,MAAM,CAACA,MAAM,CAAC,gBAAgB,CAAC,GAAG,EAAE,CAAC,GAAG,gBAAgB;EACxDA,MAAM,CAACA,MAAM,CAAC,gBAAgB,CAAC,GAAG,EAAE,CAAC,GAAG,gBAAgB;EACxDA,MAAM,CAACA,MAAM,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC,GAAG,YAAY;EAChDA,MAAM,CAACA,MAAM,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,GAAG,UAAU;EAC5CA,MAAM,CAACA,MAAM,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,GAAG,WAAW;EAC9CA,MAAM,CAACA,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG,MAAM;EACpCA,MAAM,CAACA,MAAM,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,GAAG,SAAS;EAC1CA,MAAM,CAACA,MAAM,CAAC,gBAAgB,CAAC,GAAG,EAAE,CAAC,GAAG,gBAAgB;EACxDA,MAAM,CAACA,MAAM,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,GAAG,WAAW;EAC9CA,MAAM,CAACA,MAAM,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,GAAG,UAAU;EAC5CA,MAAM,CAACA,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,GAAG,QAAQ;EACxCA,MAAM,CAACA,MAAM,CAAC,gBAAgB,CAAC,GAAG,EAAE,CAAC,GAAG,gBAAgB;EACxDA,MAAM,CAACA,MAAM,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC,GAAG,aAAa;EAClDA,MAAM,CAACA,MAAM,CAAC,gBAAgB,CAAC,GAAG,EAAE,CAAC,GAAG,gBAAgB;EACxDA,MAAM,CAACA,MAAM,CAAC,gBAAgB,CAAC,GAAG,EAAE,CAAC,GAAG,gBAAgB;EACxDA,MAAM,CAACA,MAAM,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,GAAG,WAAW;EAC9CA,MAAM,CAACA,MAAM,CAAC,iBAAiB,CAAC,GAAG,EAAE,CAAC,GAAG,iBAAiB;EAC1DA,MAAM,CAACA,MAAM,CAAC,kBAAkB,CAAC,GAAG,EAAE,CAAC,GAAG,kBAAkB;EAC5DA,MAAM,CAACA,MAAM,CAAC,mBAAmB,CAAC,GAAG,EAAE,CAAC,GAAG,mBAAmB;EAC9DA,MAAM,CAACA,MAAM,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,GAAG,SAAS;EAC1CA,MAAM,CAACA,MAAM,CAAC,eAAe,CAAC,GAAG,EAAE,CAAC,GAAG,eAAe;AACxD,CAAC,EAAEA,MAAM,KAAKA,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;AAC3B,IAAIC,cAAc;AAClB,CAAC,UAAUA,cAAc,EAAE;EACzBA,cAAc,CAACA,cAAc,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,GAAG,aAAa;EACjEA,cAAc,CAACA,cAAc,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;EACzDA,cAAc,CAACA,cAAc,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,GAAG,cAAc;EACnEA,cAAc,CAACA,cAAc,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,GAAG,cAAc;EACnEA,cAAc,CAACA,cAAc,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,GAAG,aAAa;EACjEA,cAAc,CAACA,cAAc,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;EAC7DA,cAAc,CAACA,cAAc,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EAC3DA,cAAc,CAACA,cAAc,CAAC,qBAAqB,CAAC,GAAG,CAAC,CAAC,GAAG,qBAAqB;EACjFA,cAAc,CAACA,cAAc,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC,GAAG,gBAAgB;EACvEA,cAAc,CAACA,cAAc,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,GAAG,aAAa;EACjEA,cAAc,CAACA,cAAc,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,GAAG,WAAW;EAC9DA,cAAc,CAACA,cAAc,CAAC,kBAAkB,CAAC,GAAG,EAAE,CAAC,GAAG,kBAAkB;EAC5EA,cAAc,CAACA,cAAc,CAAC,2BAA2B,CAAC,GAAG,EAAE,CAAC,GAAG,2BAA2B;EAC9FA,cAAc,CAACA,cAAc,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC,GAAG,aAAa;EAClEA,cAAc,CAACA,cAAc,CAAC,qBAAqB,CAAC,GAAG,EAAE,CAAC,GAAG,qBAAqB;EAClFA,cAAc,CAACA,cAAc,CAAC,kBAAkB,CAAC,GAAG,EAAE,CAAC,GAAG,kBAAkB;EAC5EA,cAAc,CAACA,cAAc,CAAC,eAAe,CAAC,GAAG,EAAE,CAAC,GAAG,eAAe;EACtEA,cAAc,CAACA,cAAc,CAAC,oBAAoB,CAAC,GAAG,EAAE,CAAC,GAAG,oBAAoB;EAChFA,cAAc,CAACA,cAAc,CAAC,iBAAiB,CAAC,GAAG,EAAE,CAAC,GAAG,iBAAiB;EAC1EA,cAAc,CAACA,cAAc,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,GAAG,WAAW;EAC9DA,cAAc,CAACA,cAAc,CAAC,qBAAqB,CAAC,GAAG,EAAE,CAAC,GAAG,qBAAqB;EAClFA,cAAc,CAACA,cAAc,CAAC,mBAAmB,CAAC,GAAG,EAAE,CAAC,GAAG,mBAAmB;EAC9EA,cAAc,CAACA,cAAc,CAAC,iBAAiB,CAAC,GAAG,EAAE,CAAC,GAAG,iBAAiB;EAC1EA,cAAc,CAACA,cAAc,CAAC,iBAAiB,CAAC,GAAG,EAAE,CAAC,GAAG,iBAAiB;EAC1EA,cAAc,CAACA,cAAc,CAAC,gBAAgB,CAAC,GAAG,EAAE,CAAC,GAAG,gBAAgB;EACxEA,cAAc,CAACA,cAAc,CAAC,kBAAkB,CAAC,GAAG,EAAE,CAAC,GAAG,kBAAkB;AAC9E,CAAC,EAAEA,cAAc,KAAKA,cAAc,GAAG,CAAC,CAAC,CAAC,CAAC;AAC3C,IAAIC,aAAa;AACjB,CAAC,UAAUA,aAAa,EAAE;EACxBA,aAAa,CAACA,aAAa,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EACjDA,aAAa,CAACA,aAAa,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,GAAG,cAAc;AACnE,CAAC,EAAEA,aAAa,KAAKA,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC;AACzC,IAAIC,oBAAoB;AACxB,CAAC,UAAUA,oBAAoB,EAAE;EAC/BA,oBAAoB,CAACA,oBAAoB,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;EACrEA,oBAAoB,CAACA,oBAAoB,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,GAAG,YAAY;EAC3EA,oBAAoB,CAACA,oBAAoB,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;EACzEA,oBAAoB,CAACA,oBAAoB,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;AACnE,CAAC,EAAEA,oBAAoB,KAAKA,oBAAoB,GAAG,CAAC,CAAC,CAAC,CAAC;AACvD,IAAIC,iBAAiB;AACrB,CAAC,UAAUA,iBAAiB,EAAE;EAC5BA,iBAAiB,CAACA,iBAAiB,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;EAC7DA,iBAAiB,CAACA,iBAAiB,CAAC,2BAA2B,CAAC,GAAG,CAAC,CAAC,GAAG,2BAA2B;AACrG,CAAC,EAAEA,iBAAiB,KAAKA,iBAAiB,GAAG,CAAC,CAAC,CAAC,CAAC;AACjD,IAAIC,WAAW;AACf,CAAC,UAAUA,WAAW,EAAE;EACtBA,WAAW,CAACA,WAAW,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;EACvDA,WAAW,CAACA,WAAW,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;EACvDA,WAAW,CAACA,WAAW,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,GAAG,eAAe;EAC/DA,WAAW,CAACA,WAAW,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EACrDA,WAAW,CAACA,WAAW,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EACrDA,WAAW,CAACA,WAAW,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EAC7CA,WAAW,CAACA,WAAW,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC,GAAG,iBAAiB;EACnEA,WAAW,CAACA,WAAW,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC,GAAG,gBAAgB;EACjEA,WAAW,CAACA,WAAW,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;AACzD,CAAC,EAAEA,WAAW,KAAKA,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC;AACrC,IAAIC,uBAAuB;AAC3B,CAAC,UAAUA,uBAAuB,EAAE;EAClCA,uBAAuB,CAACA,uBAAuB,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EAC7EA,uBAAuB,CAACA,uBAAuB,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC,GAAG,iBAAiB;AAC7F,CAAC,EAAEA,uBAAuB,KAAKA,uBAAuB,GAAG,CAAC,CAAC,CAAC,CAAC;AAC7D,IAAIC,iBAAiB;AACrB,CAAC,UAAUA,iBAAiB,EAAE;EAC5BA,iBAAiB,CAACA,iBAAiB,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EACjEA,iBAAiB,CAACA,iBAAiB,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,GAAG,eAAe;AAC7E,CAAC,EAAEA,iBAAiB,KAAKA,iBAAiB,GAAG,CAAC,CAAC,CAAC,CAAC;AACjD,IAAIC,mBAAmB;AACvB,CAAC,UAAUA,mBAAmB,EAAE;EAC9BA,mBAAmB,CAACA,mBAAmB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EAC7DA,mBAAmB,CAACA,mBAAmB,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,GAAG,YAAY;EACzEA,mBAAmB,CAACA,mBAAmB,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,GAAG,aAAa;EAC3EA,mBAAmB,CAACA,mBAAmB,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;EACnEA,mBAAmB,CAACA,mBAAmB,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EACrEA,mBAAmB,CAACA,mBAAmB,CAAC,iBAAiB,CAAC,GAAG,EAAE,CAAC,GAAG,iBAAiB;AACtF,CAAC,EAAEA,mBAAmB,KAAKA,mBAAmB,GAAG,CAAC,CAAC,CAAC,CAAC;AACrD,IAAIC,SAAS;AACb,CAAC,UAAUA,SAAS,EAAE;EACpBA,SAAS,CAACA,SAAS,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EACzCA,SAAS,CAACA,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK;EACvCA,SAAS,CAACA,SAAS,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;AAC3C,CAAC,EAAEA,SAAS,KAAKA,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC;AACjC,IAAIC,gBAAgB;AACpB,CAAC,UAAUA,gBAAgB,EAAE;EAC3BA,gBAAgB,CAACA,gBAAgB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EACvDA,gBAAgB,CAACA,gBAAgB,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;EACjEA,gBAAgB,CAACA,gBAAgB,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;EACzDA,gBAAgB,CAACA,gBAAgB,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;EACzDA,gBAAgB,CAACA,gBAAgB,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,GAAG,aAAa;EACrEA,gBAAgB,CAACA,gBAAgB,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EAC/DA,gBAAgB,CAACA,gBAAgB,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;AAC3D,CAAC,EAAEA,gBAAgB,KAAKA,gBAAgB,GAAG,CAAC,CAAC,CAAC,CAAC;AAC/C,IAAIC,eAAe;AACnB,CAAC,UAAUA,eAAe,EAAE;EAC1BA,eAAe,CAACA,eAAe,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EAC7DA,eAAe,CAACA,eAAe,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK;EACnDA,eAAe,CAACA,eAAe,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;AACvD,CAAC,EAAEA,eAAe,KAAKA,eAAe,GAAG,CAAC,CAAC,CAAC,CAAC;AAC7C,IAAIC,YAAY;AAChB,CAAC,UAAUA,YAAY,EAAE;EACvBA,YAAY,CAACA,YAAY,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,GAAG,YAAY;EAC3DA,YAAY,CAACA,YAAY,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,GAAG,YAAY;EAC3DA,YAAY,CAACA,YAAY,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;AACnD,CAAC,EAAEA,YAAY,KAAKA,YAAY,GAAG,CAAC,CAAC,CAAC,CAAC;AAEvC,MAAMC,YAAY,GAAGC,MAAM,CAAC,cAAc,CAAC;AAC3C,MAAMC,oBAAoB,GAAGD,MAAM,CAAC,sBAAsB,CAAC;AAC3D,MAAME,iBAAiB,GAAGF,MAAM,CAAC,cAAc,CAAC;AAChD,MAAMG,aAAa,GAAGH,MAAM,CAAC,eAAe,CAAC;AAC7C,MAAMI,mBAAmB,GAAG;EAC1B,CAACL,YAAY,GAAG,IAAI;EACpBM,YAAY,EAAE;AAChB,CAAC;AACD,MAAMC,6BAA6B,GAAG;EACpC,CAACL,oBAAoB,GAAG;AAC1B,CAAC;AACD,MAAMM,mBAAmB,GAAG;EAC1B,CAACL,iBAAiB,GAAG;AACvB,CAAC;AACD,SAASM,oBAAoBA,CAACn0C,EAAE,EAAE;EAChC,OAAOA,EAAE,CAAC0zC,YAAY,CAAC,KAAK,IAAI;AAClC;AACA,SAASU,4BAA4BA,CAACzsD,KAAK,EAAE;EAC3C,OAAOA,KAAK,CAACisD,oBAAoB,CAAC,KAAK,IAAI;AAC7C;AACA,SAASS,oBAAoBA,CAAC1sD,KAAK,EAAE;EACnC,OAAOA,KAAK,CAACksD,iBAAiB,CAAC,KAAK,IAAI;AAC1C;AACA,SAASS,qBAAqBA,CAACt6C,IAAI,EAAE;EACnC,OAAOA,IAAI,CAAC85C,aAAa,CAAC,KAAK,IAAI;AACrC;AAEA,SAASS,iBAAiBA,CAACpQ,SAAS,EAAE;EACpC,OAAO;IACLhD,IAAI,EAAE0R,MAAM,CAAC7wC,SAAS;IACtBmiC,SAAS;IACT,GAAGqQ;EACL,CAAC;AACH;AACA,SAASC,gBAAgBA,CAACC,IAAI,EAAErxC,QAAQ,EAAEsxC,WAAW,EAAEx5C,KAAK,EAAE;EAC5D,OAAO;IACLgmC,IAAI,EAAE0R,MAAM,CAAChjB,QAAQ;IACrB6kB,IAAI;IACJrxC,QAAQ;IACRsxC,WAAW;IACXx5C,KAAK;IACL,GAAGq5C;EACL,CAAC;AACH;AACA,MAAMA,MAAM,GAAG;EACbI,WAAW,EAAE,IAAI;EACjB1J,IAAI,EAAE,IAAI;EACV2J,IAAI,EAAE;AACR,CAAC;AAED,SAASC,uBAAuBA,CAACJ,IAAI,EAAEK,aAAa,EAAEj/C,UAAU,EAAE;EAChE,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAACmC,eAAe;IAC5Bt1B,MAAM,EAAEg1B,IAAI;IACZK,aAAa;IACbj/C,UAAU;IACV,GAAGm+C,6BAA6B;IAChC,GAAGC,mBAAmB;IACtB,GAAGM;EACL,CAAC;AACH;AACA,MAAMlwB,aAAa,CAAC;EAClBC,OAAO;EACP9oB,WAAW;EACXw5C,gBAAgB;EAChBvqD,WAAWA,CAAC65B,OAAO,EAAE9oB,WAAW,EAAEw5C,gBAAgB,EAAE;IAClD,IAAI,CAAC1wB,OAAO,GAAGA,OAAO;IACtB,IAAI,CAAC9oB,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACw5C,gBAAgB,GAAGA,gBAAgB;IACxC,IAAIA,gBAAgB,CAACrvD,MAAM,KAAK,CAAC,IAAIqvD,gBAAgB,CAACrvD,MAAM,KAAK6V,WAAW,CAAC7V,MAAM,EAAE;MACnF,MAAM,IAAIQ,KAAK,CAAC,YAAYqV,WAAW,CAAC7V,MAAM,kEAAkEqvD,gBAAgB,CAACrvD,MAAM,EAAE,CAAC;IAC5I;EACF;AACF;AACA,SAASsvD,eAAeA,CAACx1B,MAAM,EAAEyhB,IAAI,EAAEz5C,IAAI,EAAEgH,UAAU,EAAE45B,IAAI,EAAED,eAAe,EAAE8sB,eAAe,EAAEC,6BAA6B,EAAEC,YAAY,EAAEC,WAAW,EAAEx/C,UAAU,EAAE;EACrK,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAAC0C,OAAO;IACpBC,WAAW,EAAErU,IAAI;IACjBzhB,MAAM;IACNh4B,IAAI;IACJgH,UAAU;IACV45B,IAAI;IACJD,eAAe;IACf8sB,eAAe;IACfC,6BAA6B;IAC7BC,YAAY;IACZI,WAAW,EAAE,IAAI;IACjBH,WAAW;IACXx/C,UAAU;IACV,GAAG0+C;EACL,CAAC;AACH;AACA,SAASkB,gBAAgBA,CAACh2B,MAAM,EAAEh4B,IAAI,EAAEgH,UAAU,EAAE8mD,WAAW,EAAEntB,eAAe,EAAE+sB,6BAA6B,EAAEC,YAAY,EAAEI,WAAW,EAAEH,WAAW,EAAEx/C,UAAU,EAAE;EACnK,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAAChZ,QAAQ;IACrBna,MAAM;IACNh4B,IAAI;IACJgH,UAAU;IACV8mD,WAAW;IACXntB,eAAe;IACfstB,SAAS,EAAE,IAAI;IACfP,6BAA6B;IAC7BC,YAAY;IACZI,WAAW;IACXH,WAAW;IACXx/C,UAAU;IACV,GAAGm+C,6BAA6B;IAChC,GAAGC,mBAAmB;IACtB,GAAGM;EACL,CAAC;AACH;AACA,SAASoB,sBAAsBA,CAACl2B,MAAM,EAAEh4B,IAAI,EAAEgH,UAAU,EAAE25B,eAAe,EAAE+sB,6BAA6B,EAAEC,YAAY,EAAEI,WAAW,EAAEH,WAAW,EAAEx/C,UAAU,EAAE;EAC5J,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAACgD,cAAc;IAC3Bn2B,MAAM;IACNh4B,IAAI;IACJgH,UAAU;IACV25B,eAAe;IACfstB,SAAS,EAAE,IAAI;IACfP,6BAA6B;IAC7BC,YAAY;IACZI,WAAW;IACXH,WAAW;IACXx/C,UAAU;IACV,GAAGm+C,6BAA6B;IAChC,GAAGC,mBAAmB;IACtB,GAAGM;EACL,CAAC;AACH;AACA,SAASsB,iBAAiBA,CAACpB,IAAI,EAAEhtD,IAAI,EAAEgH,UAAU,EAAE45B,IAAI,EAAExyB,UAAU,EAAE;EACnE,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAACkD,SAAS;IACtBr2B,MAAM,EAAEg1B,IAAI;IACZhtD,IAAI;IACJgH,UAAU;IACV45B,IAAI;IACJxyB,UAAU;IACV,GAAGm+C,6BAA6B;IAChC,GAAGC,mBAAmB;IACtB,GAAGM;EACL,CAAC;AACH;AACA,SAASwB,iBAAiBA,CAACtB,IAAI,EAAEhtD,IAAI,EAAEgH,UAAU,EAAEoH,UAAU,EAAE;EAC7D,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAACoD,SAAS;IACtBv2B,MAAM,EAAEg1B,IAAI;IACZhtD,IAAI;IACJgH,UAAU;IACVoH,UAAU;IACV,GAAGm+C,6BAA6B;IAChC,GAAGC,mBAAmB;IACtB,GAAGM;EACL,CAAC;AACH;AACA,SAAS0B,gBAAgBA,CAACxB,IAAI,EAAEhmD,UAAU,EAAEoH,UAAU,EAAE;EACtD,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAACsD,QAAQ;IACrBz2B,MAAM,EAAEg1B,IAAI;IACZhmD,UAAU;IACVoH,UAAU;IACV,GAAGm+C,6BAA6B;IAChC,GAAGC,mBAAmB;IACtB,GAAGM;EACL,CAAC;AACH;AACA,SAAS4B,gBAAgBA,CAAC1B,IAAI,EAAEhmD,UAAU,EAAEoH,UAAU,EAAE;EACtD,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAACwD,QAAQ;IACrB32B,MAAM,EAAEg1B,IAAI;IACZhmD,UAAU;IACVoH,UAAU;IACV,GAAGm+C,6BAA6B;IAChC,GAAGC,mBAAmB;IACtB,GAAGM;EACL,CAAC;AACH;AACA,SAAS8B,iBAAiBA,CAAC52B,MAAM,EAAE62B,SAAS,EAAE7uD,IAAI,EAAEgH,UAAU,EAAE25B,eAAe,EAAE8sB,eAAe,EAAEC,6BAA6B,EAAEC,YAAY,EAAEC,WAAW,EAAEx/C,UAAU,EAAE;EACtK,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAAC2D,SAAS;IACtB92B,MAAM;IACN62B,SAAS;IACT7uD,IAAI;IACJgH,UAAU;IACV25B,eAAe;IACfstB,SAAS,EAAE,IAAI;IACfR,eAAe;IACfC,6BAA6B;IAC7BC,YAAY;IACZI,WAAW,EAAE,IAAI;IACjBH,WAAW;IACXx/C,UAAU;IACV,GAAGm+C,6BAA6B;IAChC,GAAGC,mBAAmB;IACtB,GAAGM;EACL,CAAC;AACH;AACA,SAASiC,eAAeA,CAACnX,KAAK,EAAExpC,UAAU,EAAE;EAC1C,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAAC6D,OAAO;IACpBpX,KAAK;IACLxpC,UAAU;IACV,GAAG0+C;EACL,CAAC;AACH;AACA,SAASmC,mBAAmBA,CAACj3B,MAAM,EAAEzI,IAAI,EAAE2/B,UAAU,EAAE9gD,UAAU,EAAE;EACjE,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAAC7vB,WAAW;IACxBtD,MAAM;IACNzI,IAAI;IACJ2/B,UAAU;IACVC,SAAS,EAAE,IAAI;IACf/gD,UAAU;IACVghD,YAAY,EAAE,IAAI;IAClB,GAAGtC,MAAM;IACT,GAAGP,6BAA6B;IAChC,GAAGC;EACL,CAAC;AACH;AACA,SAAS6C,gBAAgBA,CAAC9qC,cAAc,EAAE+qC,UAAU,EAAEC,UAAU,EAAEnhD,UAAU,EAAE;EAC5E,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAACqE,QAAQ;IACrBx3B,MAAM,EAAEzT,cAAc;IACtB+qC,UAAU;IACVC,UAAU;IACVnhD,UAAU;IACV,GAAG0+C,MAAM;IACT,GAAGP;EACL,CAAC;AACH;AACA,SAASkD,wBAAwBA,CAACzvD,IAAI,EAAEg4B,MAAM,EAAE03B,aAAa,EAAE1oD,UAAU,EAAE25B,eAAe,EAAEvyB,UAAU,EAAEuhD,oBAAoB,EAAE;EAC5H,OAAO;IACLlW,IAAI,EAAE0R,MAAM,CAACyE,gBAAgB;IAC7B5vD,IAAI;IACJg4B,MAAM;IACN03B,aAAa;IACb1oD,UAAU;IACV4mD,WAAW,EAAE,IAAI;IACjBjtB,eAAe;IACfstB,SAAS,EAAE,IAAI;IACf7/C,UAAU;IACVuhD,oBAAoB;IACpB,GAAG7C;EACL,CAAC;AACH;AACA,SAAS+C,iBAAiBA,CAAC73B,MAAM,EAAE1lB,IAAI,EAAE5G,QAAQ,EAAE0C,UAAU,EAAE;EAC7D,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAAC2E,SAAS;IACtB93B,MAAM;IACN1lB,IAAI;IACJ5G,QAAQ;IACR0C,UAAU;IACV,GAAG0+C,MAAM;IACT,GAAGP,6BAA6B;IAChC,GAAGC;EACL,CAAC;AACH;AACA,SAASuD,sBAAsBA,CAAC1pD,OAAO,EAAE2xB,MAAM,EAAEg4B,SAAS,EAAEC,MAAM,EAAEjpD,UAAU,EAAEkpD,cAAc,EAAEC,eAAe,EAAEC,cAAc,EAAEvxC,KAAK,EAAE7e,IAAI,EAAEoO,UAAU,EAAE;EACxJ,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAACkF,cAAc;IAC3BhqD,OAAO;IACP2xB,MAAM;IACNg4B,SAAS;IACTC,MAAM;IACNjpD,UAAU;IACVkpD,cAAc;IACdC,eAAe;IACfC,cAAc;IACdvxC,KAAK;IACL7e,IAAI;IACJoO,UAAU;IACV,GAAG0+C,MAAM;IACT,GAAGN,mBAAmB;IACtB,GAAGD;EACL,CAAC;AACH;AACA,SAAS+D,iBAAiBA,CAACC,KAAK,EAAEN,MAAM,EAAE7hD,UAAU,EAAE;EACpD,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAACqF,SAAS;IACtBD,KAAK;IACLN,MAAM;IACN7hD,UAAU;IACV,GAAG0+C;EACL,CAAC;AACH;AACA,SAAS2D,gBAAgBA,CAACz4B,MAAM,EAAE8Y,YAAY,EAAE7wC,KAAK,EAAEmO,UAAU,EAAE;EACjE,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAACuF,QAAQ;IACrB14B,MAAM;IACN8Y,YAAY;IACZ7wC,KAAK;IACLmO,UAAU;IACV,GAAGm+C,6BAA6B;IAChC,GAAGC,mBAAmB;IACtB,GAAGM;EACL,CAAC;AACH;AACA,SAAS6D,eAAeA,CAACr4C,EAAE,EAAE;EAC3B,OAAO;IACLmhC,IAAI,EAAE0R,MAAM,CAACyF,OAAO;IACpB54B,MAAM,EAAE1f,EAAE,CAAC0f,MAAM;IACjBhxB,UAAU,EAAEsR,EAAE,CAACtR,UAAU;IACzB8mD,WAAW,EAAEx1C,EAAE,CAACw1C,WAAW;IAC3BntB,eAAe,EAAEroB,EAAE,CAACqoB,eAAe;IACnCstB,SAAS,EAAE,IAAI;IACfP,6BAA6B,EAAEp1C,EAAE,CAACo1C,6BAA6B;IAC/DC,YAAY,EAAEr1C,EAAE,CAACq1C,YAAY;IAC7BI,WAAW,EAAEz1C,EAAE,CAACy1C,WAAW;IAC3BH,WAAW,EAAEt1C,EAAE,CAACs1C,WAAW;IAC3Bx/C,UAAU,EAAEkK,EAAE,CAAClK,UAAU;IACzB,GAAGm+C,6BAA6B;IAChC,GAAGC,mBAAmB;IACtB,GAAGM;EACL,CAAC;AACH;AAEA,SAAS+D,cAAcA,CAACv+C,IAAI,EAAE;EAC5B,OAAOA,IAAI,YAAYw+C,cAAc;AACvC;AACA,MAAMA,cAAc,SAAS3iD,UAAU,CAAC;EACtCnL,WAAWA,CAACoL,UAAU,GAAG,IAAI,EAAE;IAC7B,KAAK,CAAC,IAAI,EAAEA,UAAU,CAAC;EACzB;AACF;AACA,MAAM2iD,eAAe,SAASD,cAAc,CAAC;EAC3C9wD,IAAI;EACJy5C,IAAI,GAAG2R,cAAc,CAAC4F,WAAW;EACjChuD,WAAWA,CAAChD,IAAI,EAAE;IAChB,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,IAAI,GAAGA,IAAI;EAClB;EACAiS,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE,CAAC;EACnCwH,YAAYA,CAACD,KAAK,EAAE;IAClB,OAAO,IAAI,CAAC5N,IAAI,KAAK4N,KAAK,CAAC5N,IAAI;EACjC;EACAgS,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAi/C,4BAA4BA,CAAA,EAAG,CAAC;EAChC9+C,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI4+C,eAAe,CAAC,IAAI,CAAC/wD,IAAI,CAAC;EACvC;AACF;AACA,MAAMkxD,aAAa,SAASJ,cAAc,CAAC;EACzC94B,MAAM;EACNs3B,UAAU;EACV5X,MAAM;EACN+B,IAAI,GAAG2R,cAAc,CAAC/iB,SAAS;EAC/BrlC,WAAWA,CAACg1B,MAAM,EAAEs3B,UAAU,EAAE5X,MAAM,EAAE;IACtC,KAAK,CAAC,CAAC;IACP,IAAI,CAAC1f,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACs3B,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAC5X,MAAM,GAAGA,MAAM;EACtB;EACAzlC,eAAeA,CAAA,EAAG,CAAC;EACnBpE,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAYyoD,aAAa,IAAIzoD,CAAC,CAACuvB,MAAM,KAAK,IAAI,CAACA,MAAM;EAC/D;EACAhmB,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAi/C,4BAA4BA,CAAA,EAAG,CAAC;EAChC9+C,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI++C,aAAa,CAAC,IAAI,CAACl5B,MAAM,EAAE,IAAI,CAACs3B,UAAU,EAAE,IAAI,CAAC5X,MAAM,CAAC;EACrE;AACF;AACA,MAAMyZ,YAAY,SAASL,cAAc,CAAC;EACxC94B,MAAM;EACN/3B,KAAK;EACLmO,UAAU;EACVqrC,IAAI,GAAG2R,cAAc,CAACsF,QAAQ;EAC9B,CAACvE,iBAAiB,IAAI,IAAI;EAC1B,CAACD,oBAAoB,IAAI,IAAI;EAC7BlpD,WAAWA,CAACg1B,MAAM,EAAE/3B,KAAK,EAAEmO,UAAU,EAAE;IACrC,KAAK,CAAC,CAAC;IACP,IAAI,CAAC4pB,MAAM,GAAGA,MAAM;IACpB,IAAI,CAAC/3B,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACmO,UAAU,GAAGA,UAAU;EAC9B;EACA6D,eAAeA,CAAA,EAAG,CAAC;EACnBpE,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAY0oD,YAAY,IAAI1oD,CAAC,CAACuvB,MAAM,KAAK,IAAI,CAACA,MAAM,IAAIvvB,CAAC,CAACxI,KAAK,CAAC4N,YAAY,CAAC,IAAI,CAAC5N,KAAK,CAAC;EAClG;EACA+R,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAi/C,4BAA4BA,CAACG,SAAS,EAAE39C,KAAK,EAAE;IAC7C,IAAI,CAACxT,KAAK,GAAGoxD,gCAAgC,CAAC,IAAI,CAACpxD,KAAK,EAAEmxD,SAAS,EAAE39C,KAAK,CAAC;EAC7E;EACAtB,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIg/C,YAAY,CAAC,IAAI,CAACn5B,MAAM,EAAE,IAAI,CAAC/3B,KAAK,EAAE,IAAI,CAACmO,UAAU,CAAC;EACnE;AACF;AACA,MAAMkjD,uBAAuB,SAASR,cAAc,CAAC;EACnD94B,MAAM;EACNs3B,UAAU;EACV7V,IAAI,GAAG2R,cAAc,CAACmG,mBAAmB;EACzCvuD,WAAWA,CAACg1B,MAAM,EAAEs3B,UAAU,EAAE;IAC9B,KAAK,CAAC,CAAC;IACP,IAAI,CAACt3B,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACs3B,UAAU,GAAGA,UAAU;EAC9B;EACAr9C,eAAeA,CAAA,EAAG,CAAC;EACnBpE,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAY6oD,uBAAuB,IAAI7oD,CAAC,CAACuvB,MAAM,KAAK,IAAI,CAACA,MAAM;EACzE;EACAhmB,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAi/C,4BAA4BA,CAAA,EAAG,CAAC;EAChC9+C,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIm/C,uBAAuB,CAAC,IAAI,CAACt5B,MAAM,EAAE,IAAI,CAACs3B,UAAU,CAAC;EAClE;AACF;AACA,MAAMkC,WAAW,SAASV,cAAc,CAAC;EACvCnnD,IAAI;EACJ8vC,IAAI,GAAG2R,cAAc,CAACqG,OAAO;EAC7BzuD,WAAWA,CAAC2G,IAAI,EAAE;IAChB,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,IAAI,GAAGA,IAAI;EAClB;EACAsI,eAAeA,CAAA,EAAG,CAAC;EACnBpE,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAY+oD,WAAW,IAAI/oD,CAAC,CAACkB,IAAI,KAAK,IAAI,CAACA,IAAI;EACzD;EACAqI,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAi/C,4BAA4BA,CAAA,EAAG,CAAC;EAChC9+C,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIq/C,WAAW,CAAC,IAAI,CAAC7nD,IAAI,CAAC;EACnC;AACF;AACA,MAAM+nD,gBAAgB,SAASZ,cAAc,CAAC;EAC5CnnD,IAAI;EACJ8vC,IAAI,GAAG2R,cAAc,CAACuG,YAAY;EAClC3uD,WAAWA,CAAC2G,IAAI,EAAE;IAChB,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,IAAI,GAAGA,IAAI;EAClB;EACAsI,eAAeA,CAAA,EAAG,CAAC;EACnBpE,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAYipD,gBAAgB,IAAIjpD,CAAC,CAACkB,IAAI,KAAK,IAAI,CAACA,IAAI;EAC9D;EACAqI,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAi/C,4BAA4BA,CAAA,EAAG,CAAC;EAChC9+C,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIu/C,gBAAgB,CAAC,IAAI,CAAC/nD,IAAI,CAAC;EACxC;AACF;AACA,MAAMioD,eAAe,SAASd,cAAc,CAAC;EAC3CrX,IAAI,GAAG2R,cAAc,CAACyG,WAAW;EACjCC,KAAK,GAAG,CAAC;EACT9uD,WAAWA,CAAA,EAAG;IACZ,KAAK,CAAC,CAAC;EACT;EACAiP,eAAeA,CAAA,EAAG,CAAC;EACnBpE,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAYmpD,eAAe,IAAInpD,CAAC,CAACqpD,KAAK,KAAK,IAAI,CAACA,KAAK;EAC/D;EACA9/C,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAi/C,4BAA4BA,CAAA,EAAG,CAAC;EAChC9+C,KAAKA,CAAA,EAAG;IACN,MAAMG,IAAI,GAAG,IAAIs/C,eAAe,CAAC,CAAC;IAClCt/C,IAAI,CAACw/C,KAAK,GAAG,IAAI,CAACA,KAAK;IACvB,OAAOx/C,IAAI;EACb;AACF;AACA,MAAMy/C,kBAAkB,SAASjB,cAAc,CAAC;EAC9CrX,IAAI,GAAG2R,cAAc,CAAC4G,cAAc;EACpChvD,WAAWA,CAAA,EAAG;IACZ,KAAK,CAAC,CAAC;EACT;EACAiP,eAAeA,CAAA,EAAG,CAAC;EACnBpE,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAYspD,kBAAkB;EACxC;EACA//C,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAi/C,4BAA4BA,CAAA,EAAG,CAAC;EAChC9+C,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI4/C,kBAAkB,CAAC,CAAC;EACjC;AACF;AACA,MAAME,eAAe,SAASnB,cAAc,CAAC;EAC3CnnD,IAAI;EACJ8vC,IAAI,GAAG2R,cAAc,CAAC8G,WAAW;EACjClvD,WAAWA,CAAC2G,IAAI,EAAE;IAChB,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,IAAI,GAAGA,IAAI;EAClB;EACAsI,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,IAAI,OAAO,IAAI,CAACsD,IAAI,KAAK,QAAQ,EAAE;MACjC,IAAI,CAACA,IAAI,CAACsI,eAAe,CAACrM,OAAO,EAAES,OAAO,CAAC;IAC7C;EACF;EACAwH,YAAYA,CAACpF,CAAC,EAAE;IACd,IAAI,EAAEA,CAAC,YAAYwpD,eAAe,CAAC,IAAI,OAAOxpD,CAAC,CAACkB,IAAI,KAAK,OAAO,IAAI,CAACA,IAAI,EAAE;MACzE,OAAO,KAAK;IACd;IACA,IAAI,OAAO,IAAI,CAACA,IAAI,KAAK,QAAQ,EAAE;MACjC,OAAO,IAAI,CAACA,IAAI,KAAKlB,CAAC,CAACkB,IAAI;IAC7B,CAAC,MAAM;MACL,OAAO,IAAI,CAACA,IAAI,CAACkE,YAAY,CAACpF,CAAC,CAACkB,IAAI,CAAC;IACvC;EACF;EACAqI,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAi/C,4BAA4BA,CAACG,SAAS,EAAE39C,KAAK,EAAE;IAC7C,IAAI,OAAO,IAAI,CAAC9J,IAAI,KAAK,QAAQ,EAAE;MACjC,IAAI,CAACA,IAAI,GAAG0nD,gCAAgC,CAAC,IAAI,CAAC1nD,IAAI,EAAEynD,SAAS,EAAE39C,KAAK,CAAC;IAC3E;EACF;EACAtB,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI8/C,eAAe,CAAC,IAAI,CAACtoD,IAAI,YAAYwE,UAAU,GAAG,IAAI,CAACxE,IAAI,CAACwI,KAAK,CAAC,CAAC,GAAG,IAAI,CAACxI,IAAI,CAAC;EAC7F;AACF;AACA,MAAMwoD,aAAa,SAASrB,cAAc,CAAC;EACzCx+C,IAAI;EACJmnC,IAAI,GAAG2R,cAAc,CAACgH,SAAS;EAC/BpvD,WAAWA,CAACsP,IAAI,EAAE;IAChB,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,IAAI,GAAGA,IAAI;EAClB;EACAL,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,IAAI,CAACiM,IAAI,CAACL,eAAe,CAACrM,OAAO,EAAES,OAAO,CAAC;EAC7C;EACAwH,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAY0pD,aAAa,IAAI,IAAI,CAAC7/C,IAAI,CAACzE,YAAY,CAACpF,CAAC,CAAC6J,IAAI,CAAC;EACrE;EACAN,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAi/C,4BAA4BA,CAACG,SAAS,EAAE39C,KAAK,EAAE;IAC7C,IAAI,CAACnB,IAAI,GAAG++C,gCAAgC,CAAC,IAAI,CAAC/+C,IAAI,EAAE8+C,SAAS,EAAE39C,KAAK,CAAC;EAC3E;EACAtB,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIggD,aAAa,CAAC,IAAI,CAAC7/C,IAAI,CAACH,KAAK,CAAC,CAAC,CAAC;EAC7C;AACF;AACA,MAAMkgD,oBAAoB,SAASvB,cAAc,CAAC;EAChD94B,MAAM;EACN/3B,KAAK;EACLw5C,IAAI,GAAG2R,cAAc,CAACkH,gBAAgB;EACtCtvD,WAAWA,CAACg1B,MAAM,EAAE/3B,KAAK,EAAE;IACzB,KAAK,CAAC,CAAC;IACP,IAAI,CAAC+3B,MAAM,GAAGA,MAAM;IACpB,IAAI,CAAC/3B,KAAK,GAAGA,KAAK;EACpB;EACAgS,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,IAAI,CAAC2xB,MAAM,CAAC/lB,eAAe,CAACrM,OAAO,EAAES,OAAO,CAAC;IAC7C,IAAI,CAACpG,KAAK,CAACgS,eAAe,CAACrM,OAAO,EAAES,OAAO,CAAC;EAC9C;EACAwH,YAAYA,CAACD,KAAK,EAAE;IAClB,OAAO,IAAI,CAACoqB,MAAM,CAACnqB,YAAY,CAACD,KAAK,CAACoqB,MAAM,CAAC,IAAI,IAAI,CAAC/3B,KAAK,CAAC4N,YAAY,CAACD,KAAK,CAAC3N,KAAK,CAAC;EACvF;EACA+R,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAi/C,4BAA4BA,CAACG,SAAS,EAAE39C,KAAK,EAAE;IAC7C,IAAI,CAACukB,MAAM,GAAGq5B,gCAAgC,CAAC,IAAI,CAACr5B,MAAM,EAAEo5B,SAAS,EAAE39C,KAAK,CAAC;IAC7E,IAAI,CAACxT,KAAK,GAAGoxD,gCAAgC,CAAC,IAAI,CAACpxD,KAAK,EAAEmxD,SAAS,EAAE39C,KAAK,CAAC;EAC7E;EACAtB,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIkgD,oBAAoB,CAAC,IAAI,CAACr6B,MAAM,EAAE,IAAI,CAAC/3B,KAAK,CAAC;EAC1D;AACF;AACA,MAAMsyD,gBAAgB,SAASzB,cAAc,CAAC;EAC5C9D,IAAI;EACJvT,IAAI,GAAG2R,cAAc,CAACoH,YAAY;EAClCxyD,IAAI,GAAG,IAAI;EACXgD,WAAWA,CAACgqD,IAAI,EAAE;IAChB,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,IAAI,GAAGA,IAAI;EAClB;EACA/6C,eAAeA,CAAA,EAAG,CAAC;EACnBpE,YAAYA,CAACD,KAAK,EAAE;IAClB,OAAOA,KAAK,YAAY2kD,gBAAgB,IAAI3kD,KAAK,CAACo/C,IAAI,KAAK,IAAI,CAACA,IAAI;EACtE;EACAh7C,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAi/C,4BAA4BA,CAAA,EAAG,CAAC;EAChC9+C,KAAKA,CAAA,EAAG;IACN,MAAMG,IAAI,GAAG,IAAIigD,gBAAgB,CAAC,IAAI,CAACvF,IAAI,CAAC;IAC5C16C,IAAI,CAACtS,IAAI,GAAG,IAAI,CAACA,IAAI;IACrB,OAAOsS,IAAI;EACb;AACF;AACA,MAAMmgD,gBAAgB,SAAS3B,cAAc,CAAC;EAC5CrX,IAAI,GAAG2R,cAAc,CAACqH,gBAAgB;EACtC,CAACtG,iBAAiB,IAAI,IAAI;EAC1B,CAACC,aAAa,IAAI,IAAI;EACtBsG,SAAS,GAAG,IAAI;EAChBl/C,IAAI;EACJV,IAAI;EACJD,EAAE,GAAG,IAAI;EACT7P,WAAWA,CAACgE,UAAU,EAAE8L,IAAI,EAAE;IAC5B,KAAK,CAAC,CAAC;IACP,IAAI,CAACU,IAAI,GAAGxM,UAAU;IACtB,IAAI,CAAC8L,IAAI,GAAGA,IAAI;EAClB;EACAb,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,IAAI,CAACmN,IAAI,EAAEvB,eAAe,CAACrM,OAAO,EAAES,OAAO,CAAC;IAC5C,KAAK,MAAM4M,GAAG,IAAI,IAAI,CAACH,IAAI,EAAE;MAC3BG,GAAG,CAAChB,eAAe,CAACrM,OAAO,EAAES,OAAO,CAAC;IACvC;EACF;EACAwH,YAAYA,CAACD,KAAK,EAAE;IAClB,IAAI,EAAEA,KAAK,YAAY6kD,gBAAgB,CAAC,IAAI7kD,KAAK,CAACkF,IAAI,CAAC5U,MAAM,KAAK,IAAI,CAAC4U,IAAI,CAAC5U,MAAM,EAAE;MAClF,OAAO,KAAK;IACd;IACA,OAAO0P,KAAK,CAAC4F,IAAI,KAAK,IAAI,IAAI,IAAI,CAACA,IAAI,KAAK,IAAI,IAAI5F,KAAK,CAAC4F,IAAI,CAAC3F,YAAY,CAAC,IAAI,CAAC2F,IAAI,CAAC,IAAI5F,KAAK,CAACkF,IAAI,CAACsG,KAAK,CAAC,CAACnG,GAAG,EAAE0/C,GAAG,KAAK1/C,GAAG,CAACpF,YAAY,CAAC,IAAI,CAACiF,IAAI,CAAC6/C,GAAG,CAAC,CAAC,CAAC;EAC5J;EACA3gD,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAi/C,4BAA4BA,CAACG,SAAS,EAAE39C,KAAK,EAAE;IAC7C,IAAI,IAAI,CAACD,IAAI,KAAK,IAAI,EAAE;MACtB,IAAI,CAACA,IAAI,GAAG69C,gCAAgC,CAAC,IAAI,CAAC79C,IAAI,EAAE49C,SAAS,EAAE39C,KAAK,GAAGm/C,kBAAkB,CAACC,gBAAgB,CAAC;IACjH,CAAC,MAAM,IAAI,IAAI,CAAChgD,EAAE,KAAK,IAAI,EAAE;MAC3B,IAAI,CAACA,EAAE,GAAGw+C,gCAAgC,CAAC,IAAI,CAACx+C,EAAE,EAAEu+C,SAAS,EAAE39C,KAAK,CAAC;IACvE;IACA,KAAK,IAAInU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACwT,IAAI,CAAC5U,MAAM,EAAEoB,CAAC,EAAE,EAAE;MACzC,IAAI,CAACwT,IAAI,CAACxT,CAAC,CAAC,GAAG+xD,gCAAgC,CAAC,IAAI,CAACv+C,IAAI,CAACxT,CAAC,CAAC,EAAE8xD,SAAS,EAAE39C,KAAK,CAAC;IACjF;EACF;EACAtB,KAAKA,CAAA,EAAG;IACN,MAAMG,IAAI,GAAG,IAAImgD,gBAAgB,CAAC,IAAI,CAACj/C,IAAI,EAAErB,KAAK,CAAC,CAAC,IAAI,IAAI,EAAE,IAAI,CAACW,IAAI,CAACzQ,GAAG,CAAC4Q,GAAG,IAAIA,GAAG,CAACd,KAAK,CAAC,CAAC,CAAC,CAAC;IAChGG,IAAI,CAACO,EAAE,GAAG,IAAI,CAACA,EAAE,EAAEV,KAAK,CAAC,CAAC,IAAI,IAAI;IAClCG,IAAI,CAACogD,SAAS,GAAG,IAAI,CAACA,SAAS;IAC/B,OAAOpgD,IAAI;EACb;AACF;AACA,MAAMwgD,yBAAyB,SAAShC,cAAc,CAAC;EACrDrnD,KAAK;EACLgwC,IAAI,GAAG2R,cAAc,CAAC0H,yBAAyB;EAC/C9vD,WAAWA,CAACyG,KAAK,EAAE;IACjB,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,KAAK,GAAGA,KAAK;EACpB;EACAwI,eAAeA,CAAA,EAAG,CAAC;EACnBpE,YAAYA,CAACD,KAAK,EAAE;IAClB,OAAOA,KAAK,YAAYklD,yBAAyB,IAAIllD,KAAK,CAACnE,KAAK,KAAK,IAAI,CAACA,KAAK;EACjF;EACAuI,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI;EACb;EACAi/C,4BAA4BA,CAAA,EAAG,CAAC;EAChC9+C,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI2gD,yBAAyB,CAAC,IAAI,CAACrpD,KAAK,CAAC;EAClD;AACF;AACA,MAAMspD,eAAe,SAASjC,cAAc,CAAC;EAC3C94B,MAAM;EACNs3B,UAAU;EACVtvD,IAAI;EACJ8S,IAAI;EACJ2mC,IAAI,GAAG2R,cAAc,CAAC4H,WAAW;EACjC,CAAC7G,iBAAiB,IAAI,IAAI;EAC1B,CAACC,aAAa,IAAI,IAAI;EACtBsG,SAAS,GAAG,IAAI;EAChB1vD,WAAWA,CAACg1B,MAAM,EAAEs3B,UAAU,EAAEtvD,IAAI,EAAE8S,IAAI,EAAE;IAC1C,KAAK,CAAC,CAAC;IACP,IAAI,CAACklB,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACs3B,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACtvD,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC8S,IAAI,GAAGA,IAAI;EAClB;EACAb,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,KAAK,MAAM4M,GAAG,IAAI,IAAI,CAACH,IAAI,EAAE;MAC3BG,GAAG,CAAChB,eAAe,CAACrM,OAAO,EAAES,OAAO,CAAC;IACvC;EACF;EACAwH,YAAYA,CAAA,EAAG;IACb,OAAO,KAAK;EACd;EACAmE,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAi/C,4BAA4BA,CAACG,SAAS,EAAE39C,KAAK,EAAE;IAC7C,KAAK,IAAIk/C,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG,IAAI,CAAC7/C,IAAI,CAAC5U,MAAM,EAAEy0D,GAAG,EAAE,EAAE;MAC/C,IAAI,CAAC7/C,IAAI,CAAC6/C,GAAG,CAAC,GAAGtB,gCAAgC,CAAC,IAAI,CAACv+C,IAAI,CAAC6/C,GAAG,CAAC,EAAEvB,SAAS,EAAE39C,KAAK,CAAC;IACrF;EACF;EACAtB,KAAKA,CAAA,EAAG;IACN,MAAMimB,CAAC,GAAG,IAAI26B,eAAe,CAAC,IAAI,CAAC/6B,MAAM,EAAE,IAAI,CAACs3B,UAAU,EAAE,IAAI,CAACtvD,IAAI,EAAE,IAAI,CAAC8S,IAAI,CAACzQ,GAAG,CAAC0D,CAAC,IAAIA,CAAC,CAACoM,KAAK,CAAC,CAAC,CAAC,CAAC;IACrGimB,CAAC,CAACs6B,SAAS,GAAG,IAAI,CAACA,SAAS;IAC5B,OAAOt6B,CAAC;EACV;AACF;AACA,MAAM66B,uBAAuB,SAASnC,cAAc,CAAC;EACnD94B,MAAM;EACNs3B,UAAU;EACVtvD,IAAI;EACJ8S,IAAI;EACJogD,OAAO;EACPzZ,IAAI,GAAG2R,cAAc,CAAC+H,mBAAmB;EACzC,CAAChH,iBAAiB,IAAI,IAAI;EAC1B,CAACC,aAAa,IAAI,IAAI;EACtBsG,SAAS,GAAG,IAAI;EAChB1vD,WAAWA,CAACg1B,MAAM,EAAEs3B,UAAU,EAAEtvD,IAAI,EAAE8S,IAAI,EAAEogD,OAAO,EAAE;IACnD,KAAK,CAAC,CAAC;IACP,IAAI,CAACl7B,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACs3B,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACtvD,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC8S,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACogD,OAAO,GAAGA,OAAO;EACxB;EACAjhD,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,IAAI,CAACyM,IAAI,CAACb,eAAe,CAACrM,OAAO,EAAES,OAAO,CAAC;EAC7C;EACAwH,YAAYA,CAAA,EAAG;IACb,OAAO,KAAK;EACd;EACAmE,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAi/C,4BAA4BA,CAACG,SAAS,EAAE39C,KAAK,EAAE;IAC7C,IAAI,CAACX,IAAI,GAAGu+C,gCAAgC,CAAC,IAAI,CAACv+C,IAAI,EAAEs+C,SAAS,EAAE39C,KAAK,CAAC;EAC3E;EACAtB,KAAKA,CAAA,EAAG;IACN,MAAMimB,CAAC,GAAG,IAAI66B,uBAAuB,CAAC,IAAI,CAACj7B,MAAM,EAAE,IAAI,CAACs3B,UAAU,EAAE,IAAI,CAACtvD,IAAI,EAAE,IAAI,CAAC8S,IAAI,CAACX,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC+gD,OAAO,CAAC;IAC/G96B,CAAC,CAACs6B,SAAS,GAAG,IAAI,CAACA,SAAS;IAC5B,OAAOt6B,CAAC;EACV;AACF;AACA,MAAMg7B,oBAAoB,SAAStC,cAAc,CAAC;EAChD/9C,QAAQ;EACR/S,IAAI;EACJy5C,IAAI,GAAG2R,cAAc,CAACxvB,gBAAgB;EACtC54B,WAAWA,CAAC+P,QAAQ,EAAE/S,IAAI,EAAE;IAC1B,KAAK,CAAC,CAAC;IACP,IAAI,CAAC+S,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC/S,IAAI,GAAGA,IAAI;EAClB;EACA,IAAIyJ,KAAKA,CAAA,EAAG;IACV,OAAO,IAAI,CAACzJ,IAAI;EAClB;EACAiS,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,IAAI,CAAC0M,QAAQ,CAACd,eAAe,CAACrM,OAAO,EAAES,OAAO,CAAC;EACjD;EACAwH,YAAYA,CAAA,EAAG;IACb,OAAO,KAAK;EACd;EACAmE,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAi/C,4BAA4BA,CAACG,SAAS,EAAE39C,KAAK,EAAE;IAC7C,IAAI,CAACV,QAAQ,GAAGs+C,gCAAgC,CAAC,IAAI,CAACt+C,QAAQ,EAAEq+C,SAAS,EAAE39C,KAAK,CAAC;EACnF;EACAtB,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIihD,oBAAoB,CAAC,IAAI,CAACrgD,QAAQ,CAACZ,KAAK,CAAC,CAAC,EAAE,IAAI,CAACnS,IAAI,CAAC;EACnE;AACF;AACA,MAAMqzD,iBAAiB,SAASvC,cAAc,CAAC;EAC7C/9C,QAAQ;EACRtJ,KAAK;EACLgwC,IAAI,GAAG2R,cAAc,CAACpvB,aAAa;EACnCh5B,WAAWA,CAAC+P,QAAQ,EAAEtJ,KAAK,EAAE2E,UAAU,EAAE;IACvC,KAAK,CAACA,UAAU,CAAC;IACjB,IAAI,CAAC2E,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACtJ,KAAK,GAAGA,KAAK;EACpB;EACAwI,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,IAAI,CAAC0M,QAAQ,CAACd,eAAe,CAACrM,OAAO,EAAES,OAAO,CAAC;IAC/C,IAAI,CAACoD,KAAK,CAACwI,eAAe,CAACrM,OAAO,EAAES,OAAO,CAAC;EAC9C;EACAwH,YAAYA,CAAA,EAAG;IACb,OAAO,KAAK;EACd;EACAmE,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAi/C,4BAA4BA,CAACG,SAAS,EAAE39C,KAAK,EAAE;IAC7C,IAAI,CAACV,QAAQ,GAAGs+C,gCAAgC,CAAC,IAAI,CAACt+C,QAAQ,EAAEq+C,SAAS,EAAE39C,KAAK,CAAC;IACjF,IAAI,CAAChK,KAAK,GAAG4nD,gCAAgC,CAAC,IAAI,CAAC5nD,KAAK,EAAE2nD,SAAS,EAAE39C,KAAK,CAAC;EAC7E;EACAtB,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIkhD,iBAAiB,CAAC,IAAI,CAACtgD,QAAQ,CAACZ,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC1I,KAAK,CAAC0I,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC/D,UAAU,CAAC;EAC1F;AACF;AACA,MAAMklD,sBAAsB,SAASxC,cAAc,CAAC;EAClD/9C,QAAQ;EACRD,IAAI;EACJ2mC,IAAI,GAAG2R,cAAc,CAACmI,kBAAkB;EACxCvwD,WAAWA,CAAC+P,QAAQ,EAAED,IAAI,EAAE;IAC1B,KAAK,CAAC,CAAC;IACP,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACD,IAAI,GAAGA,IAAI;EAClB;EACAb,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,IAAI,CAAC0M,QAAQ,CAACd,eAAe,CAACrM,OAAO,EAAES,OAAO,CAAC;IAC/C,KAAK,MAAMN,CAAC,IAAI,IAAI,CAAC+M,IAAI,EAAE;MACzB/M,CAAC,CAACkM,eAAe,CAACrM,OAAO,EAAES,OAAO,CAAC;IACrC;EACF;EACAwH,YAAYA,CAAA,EAAG;IACb,OAAO,KAAK;EACd;EACAmE,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAi/C,4BAA4BA,CAACG,SAAS,EAAE39C,KAAK,EAAE;IAC7C,IAAI,CAACV,QAAQ,GAAGs+C,gCAAgC,CAAC,IAAI,CAACt+C,QAAQ,EAAEq+C,SAAS,EAAE39C,KAAK,CAAC;IACjF,KAAK,IAAInU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACwT,IAAI,CAAC5U,MAAM,EAAEoB,CAAC,EAAE,EAAE;MACzC,IAAI,CAACwT,IAAI,CAACxT,CAAC,CAAC,GAAG+xD,gCAAgC,CAAC,IAAI,CAACv+C,IAAI,CAACxT,CAAC,CAAC,EAAE8xD,SAAS,EAAE39C,KAAK,CAAC;IACjF;EACF;EACAtB,KAAKA,CAAA,EAAG;IACN,OAAO,IAAImhD,sBAAsB,CAAC,IAAI,CAACvgD,QAAQ,CAACZ,KAAK,CAAC,CAAC,EAAE,IAAI,CAACW,IAAI,CAACzQ,GAAG,CAAC0D,CAAC,IAAIA,CAAC,CAACoM,KAAK,CAAC,CAAC,CAAC,CAAC;EACzF;AACF;AACA,MAAMqhD,eAAe,SAAS1C,cAAc,CAAC;EAC3Cr6B,KAAK;EACLnkB,IAAI;EACJmnC,IAAI,GAAG2R,cAAc,CAACoI,eAAe;EACrCxwD,WAAWA,CAACyzB,KAAK,EAAEnkB,IAAI,EAAE;IACvB,KAAK,CAAC,CAAC;IACP,IAAI,CAACmkB,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACnkB,IAAI,GAAGA,IAAI;EAClB;EACAL,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,IAAI,CAACowB,KAAK,CAACxkB,eAAe,CAACrM,OAAO,EAAES,OAAO,CAAC;IAC5C,IAAI,CAACiM,IAAI,CAACL,eAAe,CAACrM,OAAO,EAAES,OAAO,CAAC;EAC7C;EACAwH,YAAYA,CAAA,EAAG;IACb,OAAO,KAAK;EACd;EACAmE,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAi/C,4BAA4BA,CAACG,SAAS,EAAE39C,KAAK,EAAE;IAC7C,IAAI,CAACgjB,KAAK,GAAG46B,gCAAgC,CAAC,IAAI,CAAC56B,KAAK,EAAE26B,SAAS,EAAE39C,KAAK,CAAC;IAC3E,IAAI,CAACnB,IAAI,GAAG++C,gCAAgC,CAAC,IAAI,CAAC/+C,IAAI,EAAE8+C,SAAS,EAAE39C,KAAK,CAAC;EAC3E;EACAtB,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIqhD,eAAe,CAAC,IAAI,CAAC/8B,KAAK,CAACtkB,KAAK,CAAC,CAAC,EAAE,IAAI,CAACG,IAAI,CAACH,KAAK,CAAC,CAAC,CAAC;EACnE;AACF;AACA,MAAM4oB,SAAS,SAAS+1B,cAAc,CAAC;EACrCrX,IAAI,GAAG2R,cAAc,CAACrwB,SAAS;EAC/B9oB,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE,CAAC;EACnCwH,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAYsyB,SAAS;EAC/B;EACA/oB,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI;EACb;EACAG,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI4oB,SAAS,CAAC,CAAC;EACxB;EACAk2B,4BAA4BA,CAAA,EAAG,CAAC;AAClC;AACA,MAAMwC,mBAAmB,SAAS3C,cAAc,CAAC;EAC/Cx+C,IAAI;EACJ06C,IAAI;EACJvT,IAAI,GAAG2R,cAAc,CAACqI,mBAAmB;EACzCzzD,IAAI,GAAG,IAAI;EACXgD,WAAWA,CAACsP,IAAI,EAAE06C,IAAI,EAAE;IACtB,KAAK,CAAC,CAAC;IACP,IAAI,CAAC16C,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC06C,IAAI,GAAGA,IAAI;EAClB;EACA/6C,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,IAAI,CAACiM,IAAI,CAACL,eAAe,CAACrM,OAAO,EAAES,OAAO,CAAC;EAC7C;EACAwH,YAAYA,CAAA,EAAG;IACb,OAAO,KAAK;EACd;EACAmE,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAi/C,4BAA4BA,CAACG,SAAS,EAAE39C,KAAK,EAAE;IAC7C,IAAI,CAACnB,IAAI,GAAG++C,gCAAgC,CAAC,IAAI,CAAC/+C,IAAI,EAAE8+C,SAAS,EAAE39C,KAAK,CAAC;EAC3E;EACAtB,KAAKA,CAAA,EAAG;IACN,MAAMpM,CAAC,GAAG,IAAI0tD,mBAAmB,CAAC,IAAI,CAACnhD,IAAI,CAACH,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC66C,IAAI,CAAC;IAC/DjnD,CAAC,CAAC/F,IAAI,GAAG,IAAI,CAACA,IAAI;IAClB,OAAO+F,CAAC;EACV;AACF;AACA,MAAM2tD,iBAAiB,SAAS5C,cAAc,CAAC;EAC7C9D,IAAI;EACJvT,IAAI,GAAG2R,cAAc,CAACsI,iBAAiB;EACvC1zD,IAAI,GAAG,IAAI;EACXgD,WAAWA,CAACgqD,IAAI,EAAE;IAChB,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,IAAI,GAAGA,IAAI;EAClB;EACA/6C,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE,CAAC;EACnCwH,YAAYA,CAAA,EAAG;IACb,OAAO,IAAI,CAACm/C,IAAI,KAAK,IAAI,CAACA,IAAI;EAChC;EACAh7C,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EACAi/C,4BAA4BA,CAACG,SAAS,EAAE39C,KAAK,EAAE,CAAC;EAChDtB,KAAKA,CAAA,EAAG;IACN,MAAMimB,CAAC,GAAG,IAAIs7B,iBAAiB,CAAC,IAAI,CAAC1G,IAAI,CAAC;IAC1C50B,CAAC,CAACp4B,IAAI,GAAG,IAAI,CAACA,IAAI;IAClB,OAAOo4B,CAAC;EACV;AACF;AACA,MAAMu7B,eAAe,SAAS7C,cAAc,CAAC;EAC3C8C,IAAI;EACJna,IAAI,GAAG2R,cAAc,CAACuI,eAAe;EACrC3wD,WAAWA,CAAC4wD,IAAI,EAAE;IAChB,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,IAAI,GAAGA,IAAI;EAClB;EACA3hD,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE,CAAC;EACnCwH,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAYkrD,eAAe,IAAIlrD,CAAC,CAACmrD,IAAI,KAAK,IAAI,CAACA,IAAI;EAC7D;EACA5hD,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI;EACb;EACAG,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIwhD,eAAe,CAAC,IAAI,CAACC,IAAI,CAAC;EACvC;EACA3C,4BAA4BA,CAAA,EAAG,CAAC;AAClC;AACA,MAAM4C,mBAAmB,SAAS/C,cAAc,CAAC;EAC/Cx+C,IAAI;EACJ0lB,MAAM;EACNs3B,UAAU;EACVwE,KAAK;EACLra,IAAI,GAAG2R,cAAc,CAAC2I,eAAe;EACrC/wD,WAAWA,CAACsP,IAAI,EAAE0lB,MAAM,EAAEs3B,UAAU,EAAEwE,KAAK,GAAG,IAAI,EAAE;IAClD,KAAK,CAAC,CAAC;IACP,IAAI,CAACxhD,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC0lB,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACs3B,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACwE,KAAK,GAAGA,KAAK;EACpB;EACA7hD,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,IAAI,IAAI,CAACiM,IAAI,KAAK,IAAI,EAAE;MACtB,IAAI,CAACA,IAAI,CAACL,eAAe,CAACrM,OAAO,EAAES,OAAO,CAAC;IAC7C;EACF;EACAwH,YAAYA,CAACpF,CAAC,EAAE;IACd,OAAOA,CAAC,YAAYorD,mBAAmB,IAAIprD,CAAC,CAAC6J,IAAI,KAAK,IAAI,CAACA,IAAI;EACjE;EACAN,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI;EACb;EACAG,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI0hD,mBAAmB,CAAC,IAAI,CAACvhD,IAAI,EAAE,IAAI,CAAC0lB,MAAM,EAAE,IAAI,CAACs3B,UAAU,CAAC;EACzE;EACA2B,4BAA4BA,CAACG,SAAS,EAAE39C,KAAK,EAAE;IAC7C,IAAI,IAAI,CAACnB,IAAI,KAAK,IAAI,EAAE;MACtB,IAAI,CAACA,IAAI,GAAG++C,gCAAgC,CAAC,IAAI,CAAC/+C,IAAI,EAAE8+C,SAAS,EAAE39C,KAAK,CAAC;IAC3E;EACF;AACF;AACA,MAAMugD,kBAAkB,SAASlD,cAAc,CAAC;EAC9Cx+C,IAAI;EACJmnC,IAAI,GAAG2R,cAAc,CAAC6I,cAAc;EACpCjxD,WAAWA,CAACsP,IAAI,EAAE;IAChB,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,IAAI,GAAGA,IAAI;EAClB;EACA2+C,4BAA4BA,CAACG,SAAS,EAAE39C,KAAK,EAAE;IAC7C,IAAI,CAACnB,IAAI,GAAG8+C,SAAS,CAAC,IAAI,CAAC9+C,IAAI,EAAEmB,KAAK,CAAC;EACzC;EACAxB,eAAeA,CAACrM,OAAO,EAAES,OAAO,EAAE;IAChC,IAAI,CAACiM,IAAI,CAACL,eAAe,CAACrM,OAAO,EAAES,OAAO,CAAC;EAC7C;EACAwH,YAAYA,CAACpF,CAAC,EAAE;IACd,IAAI,EAAEA,CAAC,YAAYurD,kBAAkB,CAAC,EAAE;MACtC,OAAO,KAAK;IACd;IACA,OAAO,IAAI,CAAC1hD,IAAI,CAACzE,YAAY,CAACpF,CAAC,CAAC6J,IAAI,CAAC;EACvC;EACAN,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI,CAACM,IAAI,CAACN,UAAU,CAAC,CAAC;EAC/B;EACAG,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI6hD,kBAAkB,CAAC,IAAI,CAAC1hD,IAAI,CAAC;EAC1C;AACF;AACA,SAAS4hD,oBAAoBA,CAAC57C,EAAE,EAAE1S,OAAO,EAAE;EACzCuuD,wBAAwB,CAAC77C,EAAE,EAAE,CAAChG,IAAI,EAAEmB,KAAK,KAAK;IAC5C7N,OAAO,CAAC0M,IAAI,EAAEmB,KAAK,CAAC;IACpB,OAAOnB,IAAI;EACb,CAAC,EAAEsgD,kBAAkB,CAACpnD,IAAI,CAAC;AAC7B;AACA,IAAIonD,kBAAkB;AACtB,CAAC,UAAUA,kBAAkB,EAAE;EAC7BA,kBAAkB,CAACA,kBAAkB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EAC3DA,kBAAkB,CAACA,kBAAkB,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,GAAG,kBAAkB;AACrF,CAAC,EAAEA,kBAAkB,KAAKA,kBAAkB,GAAG,CAAC,CAAC,CAAC,CAAC;AACnD,SAASwB,mCAAmCA,CAAC/G,aAAa,EAAE+D,SAAS,EAAE39C,KAAK,EAAE;EAC5E,KAAK,IAAInU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+tD,aAAa,CAACt5C,WAAW,CAAC7V,MAAM,EAAEoB,CAAC,EAAE,EAAE;IACzD+tD,aAAa,CAACt5C,WAAW,CAACzU,CAAC,CAAC,GAAG+xD,gCAAgC,CAAChE,aAAa,CAACt5C,WAAW,CAACzU,CAAC,CAAC,EAAE8xD,SAAS,EAAE39C,KAAK,CAAC;EACjH;AACF;AACA,SAAS0gD,wBAAwBA,CAAC77C,EAAE,EAAE84C,SAAS,EAAE39C,KAAK,EAAE;EACtD,QAAQ6E,EAAE,CAACmhC,IAAI;IACb,KAAK0R,MAAM,CAACkD,SAAS;IACrB,KAAKlD,MAAM,CAACsD,QAAQ;IACpB,KAAKtD,MAAM,CAACoD,SAAS;IACrB,KAAKpD,MAAM,CAACwD,QAAQ;IACpB,KAAKxD,MAAM,CAACkJ,eAAe;IAC3B,KAAKlJ,MAAM,CAACyE,gBAAgB;IAC5B,KAAKzE,MAAM,CAAC0C,OAAO;MACjB,IAAIv1C,EAAE,CAACtR,UAAU,YAAY41B,aAAa,EAAE;QAC1Cw3B,mCAAmC,CAAC97C,EAAE,CAACtR,UAAU,EAAEoqD,SAAS,EAAE39C,KAAK,CAAC;MACtE,CAAC,MAAM;QACL6E,EAAE,CAACtR,UAAU,GAAGqqD,gCAAgC,CAAC/4C,EAAE,CAACtR,UAAU,EAAEoqD,SAAS,EAAE39C,KAAK,CAAC;MACnF;MACA;IACF,KAAK03C,MAAM,CAAChZ,QAAQ;IACpB,KAAKgZ,MAAM,CAACmJ,WAAW;IACvB,KAAKnJ,MAAM,CAAC2D,SAAS;IACrB,KAAK3D,MAAM,CAACyF,OAAO;MACjB,IAAIt4C,EAAE,CAACtR,UAAU,YAAY41B,aAAa,EAAE;QAC1Cw3B,mCAAmC,CAAC97C,EAAE,CAACtR,UAAU,EAAEoqD,SAAS,EAAE39C,KAAK,CAAC;MACtE,CAAC,MAAM;QACL6E,EAAE,CAACtR,UAAU,GAAGqqD,gCAAgC,CAAC/4C,EAAE,CAACtR,UAAU,EAAEoqD,SAAS,EAAE39C,KAAK,CAAC;MACnF;MACA6E,EAAE,CAAC21C,SAAS,GAAG31C,EAAE,CAAC21C,SAAS,IAAIoD,gCAAgC,CAAC/4C,EAAE,CAAC21C,SAAS,EAAEmD,SAAS,EAAE39C,KAAK,CAAC;MAC/F;IACF,KAAK03C,MAAM,CAACgD,cAAc;MACxB71C,EAAE,CAACtR,UAAU,GAAGqqD,gCAAgC,CAAC/4C,EAAE,CAACtR,UAAU,EAAEoqD,SAAS,EAAE39C,KAAK,CAAC;MACjF6E,EAAE,CAAC21C,SAAS,GAAG31C,EAAE,CAAC21C,SAAS,IAAIoD,gCAAgC,CAAC/4C,EAAE,CAAC21C,SAAS,EAAEmD,SAAS,EAAE39C,KAAK,CAAC;MAC/F;IACF,KAAK03C,MAAM,CAACkF,cAAc;MACxB/3C,EAAE,CAACtR,UAAU,GAAGqqD,gCAAgC,CAAC/4C,EAAE,CAACtR,UAAU,EAAEoqD,SAAS,EAAE39C,KAAK,CAAC;MACjF;IACF,KAAK03C,MAAM,CAACmC,eAAe;MACzB8G,mCAAmC,CAAC97C,EAAE,CAAC+0C,aAAa,EAAE+D,SAAS,EAAE39C,KAAK,CAAC;MACvE;IACF,KAAK03C,MAAM,CAAC7wC,SAAS;MACnBi6C,+BAA+B,CAACj8C,EAAE,CAACmkC,SAAS,EAAE2U,SAAS,EAAE39C,KAAK,CAAC;MAC/D;IACF,KAAK03C,MAAM,CAAChjB,QAAQ;MAClB7vB,EAAE,CAAC20C,WAAW,GAAGoE,gCAAgC,CAAC/4C,EAAE,CAAC20C,WAAW,EAAEmE,SAAS,EAAE39C,KAAK,CAAC;MACnF;IACF,KAAK03C,MAAM,CAAC7vB,WAAW;MACrB,KAAK,MAAM9kB,SAAS,IAAI8B,EAAE,CAAC42C,UAAU,EAAE;QACrC,IAAI14C,SAAS,CAAClE,IAAI,KAAK,IAAI,EAAE;UAC3B;QACF;QACAkE,SAAS,CAAClE,IAAI,GAAG++C,gCAAgC,CAAC76C,SAAS,CAAClE,IAAI,EAAE8+C,SAAS,EAAE39C,KAAK,CAAC;MACrF;MACA,IAAI6E,EAAE,CAAC62C,SAAS,KAAK,IAAI,EAAE;QACzB72C,EAAE,CAAC62C,SAAS,GAAGkC,gCAAgC,CAAC/4C,EAAE,CAAC62C,SAAS,EAAEiC,SAAS,EAAE39C,KAAK,CAAC;MACjF;MACA,IAAI6E,EAAE,CAAC82C,YAAY,KAAK,IAAI,EAAE;QAC5B92C,EAAE,CAAC82C,YAAY,GAAGiC,gCAAgC,CAAC/4C,EAAE,CAAC82C,YAAY,EAAEgC,SAAS,EAAE39C,KAAK,CAAC;MACvF;MACA;IACF,KAAK03C,MAAM,CAACqJ,SAAS;IACrB,KAAKrJ,MAAM,CAACsJ,iBAAiB;IAC7B,KAAKtJ,MAAM,CAACuJ,QAAQ;IACpB,KAAKvJ,MAAM,CAACwJ,cAAc;MACxB,KAAK,MAAMC,OAAO,IAAIt8C,EAAE,CAACu8C,UAAU,EAAE;QACnCV,wBAAwB,CAACS,OAAO,EAAExD,SAAS,EAAE39C,KAAK,GAAGm/C,kBAAkB,CAACC,gBAAgB,CAAC;MAC3F;MACA;IACF,KAAK1H,MAAM,CAAC2J,kBAAkB;MAC5Bx8C,EAAE,CAACtR,UAAU,GAAGsR,EAAE,CAACtR,UAAU,IAAIqqD,gCAAgC,CAAC/4C,EAAE,CAACtR,UAAU,EAAEoqD,SAAS,EAAE39C,KAAK,CAAC;MAClG6E,EAAE,CAACy8C,cAAc,GAAGz8C,EAAE,CAACy8C,cAAc,IAAI1D,gCAAgC,CAAC/4C,EAAE,CAACy8C,cAAc,EAAE3D,SAAS,EAAE39C,KAAK,CAAC;MAC9G;IACF,KAAK03C,MAAM,CAAC6J,cAAc;MACxB,IAAI18C,EAAE,CAAC28C,UAAU,KAAK,IAAI,EAAE;QAC1B38C,EAAE,CAAC48C,KAAK,GAAG7D,gCAAgC,CAAC/4C,EAAE,CAAC48C,KAAK,EAAE9D,SAAS,EAAE39C,KAAK,CAAC;MACzE,CAAC,MAAM;QACL,KAAK,MAAMmhD,OAAO,IAAIt8C,EAAE,CAAC28C,UAAU,EAAE;UACnCd,wBAAwB,CAACS,OAAO,EAAExD,SAAS,EAAE39C,KAAK,GAAGm/C,kBAAkB,CAACC,gBAAgB,CAAC;QAC3F;MACF;MACA,IAAIv6C,EAAE,CAAC68C,SAAS,KAAK,IAAI,EAAE;QACzB78C,EAAE,CAAC68C,SAAS,GAAG9D,gCAAgC,CAAC/4C,EAAE,CAAC68C,SAAS,EAAE/D,SAAS,EAAE39C,KAAK,CAAC;MACjF;MACA;IACF,KAAK03C,MAAM,CAACqE,QAAQ;MAClBl3C,EAAE,CAACi3C,UAAU,GAAG8B,gCAAgC,CAAC/4C,EAAE,CAACi3C,UAAU,EAAE6B,SAAS,EAAE39C,KAAK,CAAC;MACjF;IACF,KAAK03C,MAAM,CAACiK,KAAK;MACf,IAAI98C,EAAE,CAAC+8C,aAAa,KAAK,IAAI,EAAE;QAC7B/8C,EAAE,CAAC+8C,aAAa,GAAGhE,gCAAgC,CAAC/4C,EAAE,CAAC+8C,aAAa,EAAEjE,SAAS,EAAE39C,KAAK,CAAC;MACzF;MACA,IAAI6E,EAAE,CAACg9C,iBAAiB,KAAK,IAAI,EAAE;QACjCh9C,EAAE,CAACg9C,iBAAiB,GAAGjE,gCAAgC,CAAC/4C,EAAE,CAACg9C,iBAAiB,EAAElE,SAAS,EAAE39C,KAAK,CAAC;MACjG;MACA,IAAI6E,EAAE,CAACi9C,UAAU,KAAK,IAAI,EAAE;QAC1Bj9C,EAAE,CAACi9C,UAAU,GAAGlE,gCAAgC,CAAC/4C,EAAE,CAACi9C,UAAU,EAAEnE,SAAS,EAAE39C,KAAK,CAAC;MACnF;MACA;IACF,KAAK03C,MAAM,CAACqK,WAAW;MACrB,KAAK,MAAM,CAAC5/C,WAAW,EAAEtD,IAAI,CAAC,IAAIgG,EAAE,CAAC5J,MAAM,EAAE;QAC3C4J,EAAE,CAAC5J,MAAM,CAACxM,GAAG,CAAC0T,WAAW,EAAEy7C,gCAAgC,CAAC/+C,IAAI,EAAE8+C,SAAS,EAAE39C,KAAK,CAAC,CAAC;MACtF;MACA,KAAK,MAAM,CAACmC,WAAW,EAAEtD,IAAI,CAAC,IAAIgG,EAAE,CAACm9C,oBAAoB,EAAE;QACzDn9C,EAAE,CAACm9C,oBAAoB,CAACvzD,GAAG,CAAC0T,WAAW,EAAEy7C,gCAAgC,CAAC/+C,IAAI,EAAE8+C,SAAS,EAAE39C,KAAK,CAAC,CAAC;MACpG;MACA;IACF,KAAK03C,MAAM,CAAC2E,SAAS;MACnBx3C,EAAE,CAAChG,IAAI,GAAG++C,gCAAgC,CAAC/4C,EAAE,CAAChG,IAAI,EAAE8+C,SAAS,EAAE39C,KAAK,CAAC;MACrE;IACF,KAAK03C,MAAM,CAACuF,QAAQ;MAClBp4C,EAAE,CAACrY,KAAK,GAAGoxD,gCAAgC,CAAC/4C,EAAE,CAACrY,KAAK,EAAEmxD,SAAS,EAAE39C,KAAK,CAAC;MACvE;IACF,KAAK03C,MAAM,CAAC6D,OAAO;IACnB,KAAK7D,MAAM,CAACjhB,SAAS;IACrB,KAAKihB,MAAM,CAACuK,YAAY;IACxB,KAAKvK,MAAM,CAACwK,cAAc;IAC1B,KAAKxK,MAAM,CAACyK,OAAO;IACnB,KAAKzK,MAAM,CAAC0K,eAAe;IAC3B,KAAK1K,MAAM,CAACvoB,OAAO;IACnB,KAAKuoB,MAAM,CAAC2K,UAAU;IACtB,KAAK3K,MAAM,CAAC4K,YAAY;IACxB,KAAK5K,MAAM,CAAC6K,cAAc;IAC1B,KAAK7K,MAAM,CAAC8K,IAAI;IAChB,KAAK9K,MAAM,CAACqF,SAAS;IACrB,KAAKrF,MAAM,CAAC+K,WAAW;IACvB,KAAK/K,MAAM,CAACgL,OAAO;IACnB,KAAKhL,MAAM,CAACiL,SAAS;IACrB,KAAKjL,MAAM,CAACkL,MAAM;IAClB,KAAKlL,MAAM,CAACmL,QAAQ;IACpB,KAAKnL,MAAM,CAACS,SAAS;IACrB,KAAKT,MAAM,CAACxxB,IAAI;IAChB,KAAKwxB,MAAM,CAACoL,UAAU;IACtB,KAAKpL,MAAM,CAACqL,aAAa;IACzB,KAAKrL,MAAM,CAACtjB,QAAQ;IACpB,KAAKsjB,MAAM,CAACvpB,IAAI;IAChB,KAAKupB,MAAM,CAACsL,cAAc;IAC1B,KAAKtL,MAAM,CAAC7gB,cAAc;IAC1B,KAAK6gB,MAAM,CAACuL,UAAU;IACtB,KAAKvL,MAAM,CAACwL,cAAc;IAC1B,KAAKxL,MAAM,CAACyL,iBAAiB;IAC7B,KAAKzL,MAAM,CAAC0L,uBAAuB;IACnC,KAAK1L,MAAM,CAAC2L,aAAa;MACvB;IACF;MACE,MAAM,IAAIp4D,KAAK,CAAC,2DAA2DysD,MAAM,CAAC7yC,EAAE,CAACmhC,IAAI,CAAC,EAAE,CAAC;EACjG;AACF;AACA,SAAS4X,gCAAgCA,CAAC/+C,IAAI,EAAE8+C,SAAS,EAAE39C,KAAK,EAAE;EAChE,IAAInB,IAAI,YAAYw+C,cAAc,EAAE;IAClCx+C,IAAI,CAAC2+C,4BAA4B,CAACG,SAAS,EAAE39C,KAAK,CAAC;EACrD,CAAC,MAAM,IAAInB,IAAI,YAAYjD,kBAAkB,EAAE;IAC7CiD,IAAI,CAAC6F,GAAG,GAAGk5C,gCAAgC,CAAC/+C,IAAI,CAAC6F,GAAG,EAAEi5C,SAAS,EAAE39C,KAAK,CAAC;IACvEnB,IAAI,CAAClD,GAAG,GAAGiiD,gCAAgC,CAAC/+C,IAAI,CAAClD,GAAG,EAAEgiD,SAAS,EAAE39C,KAAK,CAAC;EACzE,CAAC,MAAM,IAAInB,IAAI,YAAYuF,iBAAiB,EAAE;IAC5CvF,IAAI,CAACA,IAAI,GAAG++C,gCAAgC,CAAC/+C,IAAI,CAACA,IAAI,EAAE8+C,SAAS,EAAE39C,KAAK,CAAC;EAC3E,CAAC,MAAM,IAAInB,IAAI,YAAYhE,YAAY,EAAE;IACvCgE,IAAI,CAACS,QAAQ,GAAGs+C,gCAAgC,CAAC/+C,IAAI,CAACS,QAAQ,EAAEq+C,SAAS,EAAE39C,KAAK,CAAC;EACnF,CAAC,MAAM,IAAInB,IAAI,YAAY9D,WAAW,EAAE;IACtC8D,IAAI,CAACS,QAAQ,GAAGs+C,gCAAgC,CAAC/+C,IAAI,CAACS,QAAQ,EAAEq+C,SAAS,EAAE39C,KAAK,CAAC;IACjFnB,IAAI,CAAC7I,KAAK,GAAG4nD,gCAAgC,CAAC/+C,IAAI,CAAC7I,KAAK,EAAE2nD,SAAS,EAAE39C,KAAK,CAAC;EAC7E,CAAC,MAAM,IAAInB,IAAI,YAAY1D,kBAAkB,EAAE;IAC7C0D,IAAI,CAACO,EAAE,GAAGw+C,gCAAgC,CAAC/+C,IAAI,CAACO,EAAE,EAAEu+C,SAAS,EAAE39C,KAAK,CAAC;IACrE,KAAK,IAAInU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgT,IAAI,CAACQ,IAAI,CAAC5U,MAAM,EAAEoB,CAAC,EAAE,EAAE;MACzCgT,IAAI,CAACQ,IAAI,CAACxT,CAAC,CAAC,GAAG+xD,gCAAgC,CAAC/+C,IAAI,CAACQ,IAAI,CAACxT,CAAC,CAAC,EAAE8xD,SAAS,EAAE39C,KAAK,CAAC;IACjF;EACF,CAAC,MAAM,IAAInB,IAAI,YAAY4G,gBAAgB,EAAE;IAC3C,KAAK,IAAI5Z,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgT,IAAI,CAAC6G,OAAO,CAACjb,MAAM,EAAEoB,CAAC,EAAE,EAAE;MAC5CgT,IAAI,CAAC6G,OAAO,CAAC7Z,CAAC,CAAC,GAAG+xD,gCAAgC,CAAC/+C,IAAI,CAAC6G,OAAO,CAAC7Z,CAAC,CAAC,EAAE8xD,SAAS,EAAE39C,KAAK,CAAC;IACvF;EACF,CAAC,MAAM,IAAInB,IAAI,YAAYkH,cAAc,EAAE;IACzC,KAAK,IAAIla,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgT,IAAI,CAAC6G,OAAO,CAACjb,MAAM,EAAEoB,CAAC,EAAE,EAAE;MAC5CgT,IAAI,CAAC6G,OAAO,CAAC7Z,CAAC,CAAC,CAACW,KAAK,GAAGoxD,gCAAgC,CAAC/+C,IAAI,CAAC6G,OAAO,CAAC7Z,CAAC,CAAC,CAACW,KAAK,EAAEmxD,SAAS,EAAE39C,KAAK,CAAC;IACnG;EACF,CAAC,MAAM,IAAInB,IAAI,YAAYpD,eAAe,EAAE;IAC1CoD,IAAI,CAACkE,SAAS,GAAG66C,gCAAgC,CAAC/+C,IAAI,CAACkE,SAAS,EAAE46C,SAAS,EAAE39C,KAAK,CAAC;IACnFnB,IAAI,CAACtD,QAAQ,GAAGqiD,gCAAgC,CAAC/+C,IAAI,CAACtD,QAAQ,EAAEoiD,SAAS,EAAE39C,KAAK,CAAC;IACjF,IAAInB,IAAI,CAACrD,SAAS,KAAK,IAAI,EAAE;MAC3BqD,IAAI,CAACrD,SAAS,GAAGoiD,gCAAgC,CAAC/+C,IAAI,CAACrD,SAAS,EAAEmiD,SAAS,EAAE39C,KAAK,CAAC;IACrF;EACF,CAAC,MAAM,IAAInB,IAAI,YAAYD,UAAU,EAAE;IACrCC,IAAI,CAACA,IAAI,GAAG++C,gCAAgC,CAAC/+C,IAAI,CAACA,IAAI,EAAE8+C,SAAS,EAAE39C,KAAK,CAAC;EAC3E,CAAC,MAAM,IAAInB,IAAI,YAAYE,QAAQ,EAAE;IACnCF,IAAI,CAACA,IAAI,GAAG++C,gCAAgC,CAAC/+C,IAAI,CAACA,IAAI,EAAE8+C,SAAS,EAAE39C,KAAK,CAAC;EAC3E,CAAC,MAAM,IAAInB,IAAI,YAAYuC,eAAe,EAAE;IAC1C,KAAK,IAAIvV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgT,IAAI,CAACyB,WAAW,CAAC7V,MAAM,EAAEoB,CAAC,EAAE,EAAE;MAChDgT,IAAI,CAACyB,WAAW,CAACzU,CAAC,CAAC,GAAG+xD,gCAAgC,CAAC/+C,IAAI,CAACyB,WAAW,CAACzU,CAAC,CAAC,EAAE8xD,SAAS,EAAE39C,KAAK,CAAC;IAC/F;EACF,CAAC,MAAM,IAAInB,IAAI,YAAYwE,OAAO,EAAE;IAClCxE,IAAI,CAACkE,SAAS,GAAG66C,gCAAgC,CAAC/+C,IAAI,CAACkE,SAAS,EAAE46C,SAAS,EAAE39C,KAAK,CAAC;EACrF,CAAC,MAAM,IAAInB,IAAI,YAAYY,yBAAyB,EAAE;IACpDZ,IAAI,CAAC3T,GAAG,GAAG0yD,gCAAgC,CAAC/+C,IAAI,CAAC3T,GAAG,EAAEyyD,SAAS,EAAE39C,KAAK,CAAC;IACvEnB,IAAI,CAACa,QAAQ,CAACY,WAAW,GAAGzB,IAAI,CAACa,QAAQ,CAACY,WAAW,CAAC1R,GAAG,CAACoG,CAAC,IAAI4oD,gCAAgC,CAAC5oD,CAAC,EAAE2oD,SAAS,EAAE39C,KAAK,CAAC,CAAC;EACvH,CAAC,MAAM,IAAInB,IAAI,YAAYkF,iBAAiB,EAAE;IAC5C,IAAIC,KAAK,CAACC,OAAO,CAACpF,IAAI,CAACkB,IAAI,CAAC,EAAE;MAC5B,KAAK,IAAIlU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgT,IAAI,CAACkB,IAAI,CAACtV,MAAM,EAAEoB,CAAC,EAAE,EAAE;QACzCi1D,+BAA+B,CAACjiD,IAAI,CAACkB,IAAI,CAAClU,CAAC,CAAC,EAAE8xD,SAAS,EAAE39C,KAAK,CAAC;MACjE;IACF,CAAC,MAAM;MACLnB,IAAI,CAACkB,IAAI,GAAG69C,gCAAgC,CAAC/+C,IAAI,CAACkB,IAAI,EAAE49C,SAAS,EAAE39C,KAAK,CAAC;IAC3E;EACF,CAAC,MAAM,IAAInB,IAAI,YAAYI,eAAe,EAAE,CAAC,KAAM,IAAIJ,IAAI,YAAYuB,mBAAmB,EAAE;IAC1F,KAAK,IAAIvU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgT,IAAI,CAACyB,WAAW,CAAC7V,MAAM,EAAEoB,CAAC,EAAE,EAAE;MAChDgT,IAAI,CAACyB,WAAW,CAACzU,CAAC,CAAC,GAAG+xD,gCAAgC,CAAC/+C,IAAI,CAACyB,WAAW,CAACzU,CAAC,CAAC,EAAE8xD,SAAS,EAAE39C,KAAK,CAAC;IAC/F;EACF,CAAC,MAAM,IAAInB,IAAI,YAAY2F,iBAAiB,EAAE;IAC5C3F,IAAI,CAACA,IAAI,GAAG++C,gCAAgC,CAAC/+C,IAAI,CAACA,IAAI,EAAE8+C,SAAS,EAAE39C,KAAK,CAAC;EAC3E,CAAC,MAAM,IAAInB,IAAI,YAAYP,WAAW,IAAIO,IAAI,YAAY8D,YAAY,IAAI9D,IAAI,YAAYqB,WAAW,IAAIrB,IAAI,YAAYiB,4BAA4B,EAAE,CAAC,KAAM;IAC5J,MAAM,IAAI7U,KAAK,CAAC,8BAA8B4T,IAAI,CAACtP,WAAW,CAAChD,IAAI,EAAE,CAAC;EACxE;EACA,OAAOoxD,SAAS,CAAC9+C,IAAI,EAAEmB,KAAK,CAAC;AAC/B;AACA,SAAS8gD,+BAA+BA,CAAC75C,IAAI,EAAE02C,SAAS,EAAE39C,KAAK,EAAE;EAC/D,IAAIiH,IAAI,YAAY5I,mBAAmB,EAAE;IACvC4I,IAAI,CAACpI,IAAI,GAAG++C,gCAAgC,CAAC32C,IAAI,CAACpI,IAAI,EAAE8+C,SAAS,EAAE39C,KAAK,CAAC;EAC3E,CAAC,MAAM,IAAIiH,IAAI,YAAYK,eAAe,EAAE;IAC1CL,IAAI,CAACza,KAAK,GAAGoxD,gCAAgC,CAAC32C,IAAI,CAACza,KAAK,EAAEmxD,SAAS,EAAE39C,KAAK,CAAC;EAC7E,CAAC,MAAM,IAAIiH,IAAI,YAAY9C,cAAc,EAAE;IACzC,IAAI8C,IAAI,CAACza,KAAK,KAAK8tB,SAAS,EAAE;MAC5BrT,IAAI,CAACza,KAAK,GAAGoxD,gCAAgC,CAAC32C,IAAI,CAACza,KAAK,EAAEmxD,SAAS,EAAE39C,KAAK,CAAC;IAC7E;EACF,CAAC,MAAM,IAAIiH,IAAI,YAAYO,MAAM,EAAE;IACjCP,IAAI,CAAClE,SAAS,GAAG66C,gCAAgC,CAAC32C,IAAI,CAAClE,SAAS,EAAE46C,SAAS,EAAE39C,KAAK,CAAC;IACnF,KAAK,MAAMsjD,aAAa,IAAIr8C,IAAI,CAAC1L,QAAQ,EAAE;MACzCulD,+BAA+B,CAACwC,aAAa,EAAE3F,SAAS,EAAE39C,KAAK,CAAC;IAClE;IACA,KAAK,MAAMsjD,aAAa,IAAIr8C,IAAI,CAACzL,SAAS,EAAE;MAC1CslD,+BAA+B,CAACwC,aAAa,EAAE3F,SAAS,EAAE39C,KAAK,CAAC;IAClE;EACF,CAAC,MAAM;IACL,MAAM,IAAI/U,KAAK,CAAC,6BAA6Bgc,IAAI,CAAC1X,WAAW,CAAChD,IAAI,EAAE,CAAC;EACvE;AACF;AACA,SAASg3D,eAAeA,CAAC1kD,IAAI,EAAE;EAC7B,OAAOA,IAAI,YAAYqB,WAAW,IAAI,OAAOrB,IAAI,CAACrS,KAAK,KAAK,QAAQ;AACtE;AAEA,MAAMg3D,MAAM,CAAC;EACX,OAAOC,UAAU,GAAG,CAAC;EACrBhK,WAAW,GAAG+J,MAAM,CAACC,UAAU,EAAE;EACjC1hC,IAAI,GAAG;IACLikB,IAAI,EAAE0R,MAAM,CAACgM,OAAO;IACpBhK,IAAI,EAAE,IAAI;IACV3J,IAAI,EAAE,IAAI;IACV0J,WAAW,EAAE,IAAI,CAACA;EACpB,CAAC;EACDkK,IAAI,GAAG;IACL3d,IAAI,EAAE0R,MAAM,CAACgM,OAAO;IACpBhK,IAAI,EAAE,IAAI;IACV3J,IAAI,EAAE,IAAI;IACV0J,WAAW,EAAE,IAAI,CAACA;EACpB,CAAC;EACDlqD,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACwyB,IAAI,CAAC23B,IAAI,GAAG,IAAI,CAACiK,IAAI;IAC1B,IAAI,CAACA,IAAI,CAAC5T,IAAI,GAAG,IAAI,CAAChuB,IAAI;EAC5B;EACAr3B,IAAIA,CAACma,EAAE,EAAE;IACP,IAAIb,KAAK,CAACC,OAAO,CAACY,EAAE,CAAC,EAAE;MACrB,KAAK,MAAM+5B,CAAC,IAAI/5B,EAAE,EAAE;QAClB,IAAI,CAACna,IAAI,CAACk0C,CAAC,CAAC;MACd;MACA;IACF;IACA4kB,MAAM,CAACI,cAAc,CAAC/+C,EAAE,CAAC;IACzB2+C,MAAM,CAACK,eAAe,CAACh/C,EAAE,CAAC;IAC1BA,EAAE,CAAC40C,WAAW,GAAG,IAAI,CAACA,WAAW;IACjC,MAAMqK,OAAO,GAAG,IAAI,CAACH,IAAI,CAAC5T,IAAI;IAC9BlrC,EAAE,CAACkrC,IAAI,GAAG+T,OAAO;IACjBA,OAAO,CAACpK,IAAI,GAAG70C,EAAE;IACjBA,EAAE,CAAC60C,IAAI,GAAG,IAAI,CAACiK,IAAI;IACnB,IAAI,CAACA,IAAI,CAAC5T,IAAI,GAAGlrC,EAAE;EACrB;EACAk/C,OAAOA,CAACC,GAAG,EAAE;IACX,IAAIA,GAAG,CAACv5D,MAAM,KAAK,CAAC,EAAE;MACpB;IACF;IACA,KAAK,MAAMoa,EAAE,IAAIm/C,GAAG,EAAE;MACpBR,MAAM,CAACI,cAAc,CAAC/+C,EAAE,CAAC;MACzB2+C,MAAM,CAACK,eAAe,CAACh/C,EAAE,CAAC;MAC1BA,EAAE,CAAC40C,WAAW,GAAG,IAAI,CAACA,WAAW;IACnC;IACA,MAAMwK,KAAK,GAAG,IAAI,CAACliC,IAAI,CAAC23B,IAAI;IAC5B,IAAI3J,IAAI,GAAG,IAAI,CAAChuB,IAAI;IACpB,KAAK,MAAMld,EAAE,IAAIm/C,GAAG,EAAE;MACpBjU,IAAI,CAAC2J,IAAI,GAAG70C,EAAE;MACdA,EAAE,CAACkrC,IAAI,GAAGA,IAAI;MACdA,IAAI,GAAGlrC,EAAE;IACX;IACAkrC,IAAI,CAAC2J,IAAI,GAAGuK,KAAK;IACjBA,KAAK,CAAClU,IAAI,GAAGA,IAAI;EACnB;EACA,EAAEyI,MAAM,CAAC0L,QAAQ,IAAI;IACnB,IAAIr5D,OAAO,GAAG,IAAI,CAACk3B,IAAI,CAAC23B,IAAI;IAC5B,OAAO7uD,OAAO,KAAK,IAAI,CAAC84D,IAAI,EAAE;MAC5BH,MAAM,CAACW,aAAa,CAACt5D,OAAO,EAAE,IAAI,CAAC4uD,WAAW,CAAC;MAC/C,MAAMC,IAAI,GAAG7uD,OAAO,CAAC6uD,IAAI;MACzB,MAAM7uD,OAAO;MACbA,OAAO,GAAG6uD,IAAI;IAChB;EACF;EACA,CAAC0K,QAAQA,CAAA,EAAG;IACV,IAAIv5D,OAAO,GAAG,IAAI,CAAC84D,IAAI,CAAC5T,IAAI;IAC5B,OAAOllD,OAAO,KAAK,IAAI,CAACk3B,IAAI,EAAE;MAC5ByhC,MAAM,CAACW,aAAa,CAACt5D,OAAO,EAAE,IAAI,CAAC4uD,WAAW,CAAC;MAC/C,MAAM1J,IAAI,GAAGllD,OAAO,CAACklD,IAAI;MACzB,MAAMllD,OAAO;MACbA,OAAO,GAAGklD,IAAI;IAChB;EACF;EACA,OAAO9jD,OAAOA,CAACo4D,KAAK,EAAEC,KAAK,EAAE;IAC3Bd,MAAM,CAACI,cAAc,CAACS,KAAK,CAAC;IAC5Bb,MAAM,CAACI,cAAc,CAACU,KAAK,CAAC;IAC5Bd,MAAM,CAACW,aAAa,CAACE,KAAK,CAAC;IAC3Bb,MAAM,CAACK,eAAe,CAACS,KAAK,CAAC;IAC7BA,KAAK,CAAC7K,WAAW,GAAG4K,KAAK,CAAC5K,WAAW;IACrC,IAAI4K,KAAK,CAACtU,IAAI,KAAK,IAAI,EAAE;MACvBsU,KAAK,CAACtU,IAAI,CAAC2J,IAAI,GAAG4K,KAAK;MACvBA,KAAK,CAACvU,IAAI,GAAGsU,KAAK,CAACtU,IAAI;IACzB;IACA,IAAIsU,KAAK,CAAC3K,IAAI,KAAK,IAAI,EAAE;MACvB2K,KAAK,CAAC3K,IAAI,CAAC3J,IAAI,GAAGuU,KAAK;MACvBA,KAAK,CAAC5K,IAAI,GAAG2K,KAAK,CAAC3K,IAAI;IACzB;IACA2K,KAAK,CAAC5K,WAAW,GAAG,IAAI;IACxB4K,KAAK,CAACtU,IAAI,GAAG,IAAI;IACjBsU,KAAK,CAAC3K,IAAI,GAAG,IAAI;EACnB;EACA,OAAO6K,eAAeA,CAACF,KAAK,EAAEG,MAAM,EAAE;IACpC,IAAIA,MAAM,CAAC/5D,MAAM,KAAK,CAAC,EAAE;MACvB+4D,MAAM,CAACiB,MAAM,CAACJ,KAAK,CAAC;MACpB;IACF;IACAb,MAAM,CAACI,cAAc,CAACS,KAAK,CAAC;IAC5Bb,MAAM,CAACW,aAAa,CAACE,KAAK,CAAC;IAC3B,MAAMK,MAAM,GAAGL,KAAK,CAAC5K,WAAW;IAChC4K,KAAK,CAAC5K,WAAW,GAAG,IAAI;IACxB,KAAK,MAAM6K,KAAK,IAAIE,MAAM,EAAE;MAC1BhB,MAAM,CAACI,cAAc,CAACU,KAAK,CAAC;MAC5Bd,MAAM,CAACK,eAAe,CAACS,KAAK,CAAC;IAC/B;IACA,MAAM;MACJvU,IAAI,EAAE4U,OAAO;MACbjL,IAAI,EAAEkL;IACR,CAAC,GAAGP,KAAK;IACTA,KAAK,CAACtU,IAAI,GAAG,IAAI;IACjBsU,KAAK,CAAC3K,IAAI,GAAG,IAAI;IACjB,IAAI3J,IAAI,GAAG4U,OAAO;IAClB,KAAK,MAAML,KAAK,IAAIE,MAAM,EAAE;MAC1BhB,MAAM,CAACK,eAAe,CAACS,KAAK,CAAC;MAC7BA,KAAK,CAAC7K,WAAW,GAAGiL,MAAM;MAC1B3U,IAAI,CAAC2J,IAAI,GAAG4K,KAAK;MACjBA,KAAK,CAACvU,IAAI,GAAGA,IAAI;MACjBuU,KAAK,CAAC5K,IAAI,GAAG,IAAI;MACjB3J,IAAI,GAAGuU,KAAK;IACd;IACA,MAAML,KAAK,GAAGO,MAAM,CAAC,CAAC,CAAC;IACvB,MAAMK,IAAI,GAAG9U,IAAI;IACjB,IAAI4U,OAAO,KAAK,IAAI,EAAE;MACpBA,OAAO,CAACjL,IAAI,GAAGuK,KAAK;MACpBA,KAAK,CAAClU,IAAI,GAAG4U,OAAO;IACtB;IACA,IAAIC,OAAO,KAAK,IAAI,EAAE;MACpBA,OAAO,CAAC7U,IAAI,GAAG8U,IAAI;MACnBA,IAAI,CAACnL,IAAI,GAAGkL,OAAO;IACrB;EACF;EACA,OAAOH,MAAMA,CAAC5/C,EAAE,EAAE;IAChB2+C,MAAM,CAACI,cAAc,CAAC/+C,EAAE,CAAC;IACzB2+C,MAAM,CAACW,aAAa,CAACt/C,EAAE,CAAC;IACxBA,EAAE,CAACkrC,IAAI,CAAC2J,IAAI,GAAG70C,EAAE,CAAC60C,IAAI;IACtB70C,EAAE,CAAC60C,IAAI,CAAC3J,IAAI,GAAGlrC,EAAE,CAACkrC,IAAI;IACtBlrC,EAAE,CAAC40C,WAAW,GAAG,IAAI;IACrB50C,EAAE,CAACkrC,IAAI,GAAG,IAAI;IACdlrC,EAAE,CAAC60C,IAAI,GAAG,IAAI;EAChB;EACA,OAAOoL,YAAYA,CAACjgD,EAAE,EAAE0f,MAAM,EAAE;IAC9B,IAAIvgB,KAAK,CAACC,OAAO,CAACY,EAAE,CAAC,EAAE;MACrB,KAAK,MAAM+5B,CAAC,IAAI/5B,EAAE,EAAE;QAClB2+C,MAAM,CAACsB,YAAY,CAAClmB,CAAC,EAAEra,MAAM,CAAC;MAChC;MACA;IACF;IACAi/B,MAAM,CAACW,aAAa,CAAC5/B,MAAM,CAAC;IAC5B,IAAIA,MAAM,CAACwrB,IAAI,KAAK,IAAI,EAAE;MACxB,MAAM,IAAI9kD,KAAK,CAAC,iDAAiD,CAAC;IACpE;IACAu4D,MAAM,CAACI,cAAc,CAAC/+C,EAAE,CAAC;IACzB2+C,MAAM,CAACK,eAAe,CAACh/C,EAAE,CAAC;IAC1BA,EAAE,CAAC40C,WAAW,GAAGl1B,MAAM,CAACk1B,WAAW;IACnC50C,EAAE,CAACkrC,IAAI,GAAG,IAAI;IACdxrB,MAAM,CAACwrB,IAAI,CAAC2J,IAAI,GAAG70C,EAAE;IACrBA,EAAE,CAACkrC,IAAI,GAAGxrB,MAAM,CAACwrB,IAAI;IACrBlrC,EAAE,CAAC60C,IAAI,GAAGn1B,MAAM;IAChBA,MAAM,CAACwrB,IAAI,GAAGlrC,EAAE;EAClB;EACA,OAAOkgD,WAAWA,CAAClgD,EAAE,EAAE0f,MAAM,EAAE;IAC7Bi/B,MAAM,CAACW,aAAa,CAAC5/B,MAAM,CAAC;IAC5B,IAAIA,MAAM,CAACm1B,IAAI,KAAK,IAAI,EAAE;MACxB,MAAM,IAAIzuD,KAAK,CAAC,+CAA+C,CAAC;IAClE;IACAu4D,MAAM,CAACI,cAAc,CAAC/+C,EAAE,CAAC;IACzB2+C,MAAM,CAACK,eAAe,CAACh/C,EAAE,CAAC;IAC1BA,EAAE,CAAC40C,WAAW,GAAGl1B,MAAM,CAACk1B,WAAW;IACnCl1B,MAAM,CAACm1B,IAAI,CAAC3J,IAAI,GAAGlrC,EAAE;IACrBA,EAAE,CAAC60C,IAAI,GAAGn1B,MAAM,CAACm1B,IAAI;IACrB70C,EAAE,CAACkrC,IAAI,GAAGxrB,MAAM;IAChBA,MAAM,CAACm1B,IAAI,GAAG70C,EAAE;EAClB;EACA,OAAOg/C,eAAeA,CAACh/C,EAAE,EAAE;IACzB,IAAIA,EAAE,CAAC40C,WAAW,KAAK,IAAI,EAAE;MAC3B,MAAM,IAAIxuD,KAAK,CAAC,oDAAoDysD,MAAM,CAAC7yC,EAAE,CAACmhC,IAAI,CAAC,EAAE,CAAC;IACxF;EACF;EACA,OAAOme,aAAaA,CAACt/C,EAAE,EAAEmgD,MAAM,EAAE;IAC/B,IAAIngD,EAAE,CAAC40C,WAAW,KAAK,IAAI,EAAE;MAC3B,MAAM,IAAIxuD,KAAK,CAAC,sDAAsDysD,MAAM,CAAC7yC,EAAE,CAACmhC,IAAI,CAAC,EAAE,CAAC;IAC1F,CAAC,MAAM,IAAIgf,MAAM,KAAK1qC,SAAS,IAAIzV,EAAE,CAAC40C,WAAW,KAAKuL,MAAM,EAAE;MAC5D,MAAM,IAAI/5D,KAAK,CAAC,4DAA4D+5D,MAAM,YAAYngD,EAAE,CAAC40C,WAAW,GAAG,CAAC;IAClH;EACF;EACA,OAAOmK,cAAcA,CAAC/+C,EAAE,EAAE;IACxB,IAAIA,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACgM,OAAO,EAAE;MAC9B,MAAM,IAAIz4D,KAAK,CAAC,wDAAwD,CAAC;IAC3E;EACF;AACF;AAEA,MAAMg6D,UAAU,CAAC;EACf9E,IAAI,GAAG,IAAI;AACb;AAEA,MAAM+E,uBAAuB,GAAG,IAAInZ,GAAG,CAAC,CAAC2L,MAAM,CAACvoB,OAAO,EAAEuoB,MAAM,CAAC4K,YAAY,EAAE5K,MAAM,CAACjhB,SAAS,EAAEihB,MAAM,CAACwK,cAAc,EAAExK,MAAM,CAACtjB,QAAQ,EAAEsjB,MAAM,CAAC6J,cAAc,EAAE7J,MAAM,CAACyL,iBAAiB,EAAEzL,MAAM,CAAC0L,uBAAuB,CAAC,CAAC;AACzN,SAAS+B,sBAAsBA,CAACtgD,EAAE,EAAE;EAClC,OAAOqgD,uBAAuB,CAACt1D,GAAG,CAACiV,EAAE,CAACmhC,IAAI,CAAC;AAC7C;AACA,SAASof,oBAAoBA,CAACl6D,GAAG,EAAEquD,IAAI,EAAE6B,SAAS,EAAEsB,eAAe,EAAEhtB,eAAe,EAAE21B,eAAe,EAAE;EACrG,OAAO;IACLrf,IAAI,EAAE0R,MAAM,CAAC4K,YAAY;IACzB/I,IAAI;IACJruD,GAAG;IACHsxD,MAAM,EAAE,IAAIyI,UAAU,CAAC,CAAC;IACxB71B,UAAU,EAAE,IAAI;IAChBk2B,SAAS,EAAE,EAAE;IACbC,WAAW,EAAE,KAAK;IAClBnK,SAAS;IACTsB,eAAe;IACfhtB,eAAe;IACf21B,eAAe;IACf,GAAGzM,mBAAmB;IACtB,GAAGS;EACL,CAAC;AACH;AACA,SAASmM,gBAAgBA,CAACjM,IAAI,EAAEW,YAAY,EAAEhvD,GAAG,EAAEu6D,kBAAkB,EAAErK,SAAS,EAAEsB,eAAe,EAAEhtB,eAAe,EAAE21B,eAAe,EAAE;EACnI,OAAO;IACLrf,IAAI,EAAE0R,MAAM,CAACtjB,QAAQ;IACrBmlB,IAAI;IACJW,YAAY;IACZ9qB,UAAU,EAAE,IAAI;IAChBlkC,GAAG;IACHsxD,MAAM,EAAE,IAAIyI,UAAU,CAAC,CAAC;IACxBQ,kBAAkB;IAClBC,KAAK,EAAE,IAAI;IACX1wB,IAAI,EAAE,IAAI;IACVswB,SAAS,EAAE,EAAE;IACbC,WAAW,EAAE,KAAK;IAClBnK,SAAS;IACTsB,eAAe;IACfhtB,eAAe;IACf21B,eAAe;IACf,GAAGzM,mBAAmB;IACtB,GAAGS;EACL,CAAC;AACH;AACA,SAASsM,yBAAyBA,CAACpM,IAAI,EAAEW,YAAY,EAAEhvD,GAAG,EAAEu6D,kBAAkB,EAAErK,SAAS,EAAEsB,eAAe,EAAEhtB,eAAe,EAAE21B,eAAe,EAAE;EAC5I,OAAO;IACLrf,IAAI,EAAE0R,MAAM,CAACyL,iBAAiB;IAC9B5J,IAAI;IACJW,YAAY;IACZ9qB,UAAU,EAAE,IAAI;IAChBlkC,GAAG;IACHsxD,MAAM,EAAE,IAAIyI,UAAU,CAAC,CAAC;IACxBQ,kBAAkB;IAClBC,KAAK,EAAE,IAAI;IACX1wB,IAAI,EAAE,IAAI;IACVswB,SAAS,EAAE,EAAE;IACbC,WAAW,EAAE,KAAK;IAClBnK,SAAS;IACTsB,eAAe;IACfhtB,eAAe;IACf21B,eAAe;IACf,GAAGzM,mBAAmB;IACtB,GAAGS;EACL,CAAC;AACH;AACA,SAASuM,+BAA+BA,CAACrM,IAAI,EAAEW,YAAY,EAAEhvD,GAAG,EAAEu6D,kBAAkB,EAAErK,SAAS,EAAEsB,eAAe,EAAEhtB,eAAe,EAAE21B,eAAe,EAAE;EAClJ,OAAO;IACLrf,IAAI,EAAE0R,MAAM,CAAC0L,uBAAuB;IACpC7J,IAAI;IACJW,YAAY;IACZ9qB,UAAU,EAAE,IAAI;IAChBlkC,GAAG;IACHsxD,MAAM,EAAE,IAAIyI,UAAU,CAAC,CAAC;IACxBQ,kBAAkB;IAClBC,KAAK,EAAE,IAAI;IACX1wB,IAAI,EAAE,IAAI;IACVswB,SAAS,EAAE,EAAE;IACbC,WAAW,EAAE,KAAK;IAClBnK,SAAS;IACTsB,eAAe;IACfhtB,eAAe;IACf21B,eAAe;IACf,GAAGzM,mBAAmB;IACtB,GAAGS;EACL,CAAC;AACH;AACA,SAASwM,sBAAsBA,CAACC,WAAW,EAAEC,SAAS,EAAE76D,GAAG,EAAEu2D,KAAK,EAAEuE,QAAQ,EAAEC,QAAQ,EAAEvJ,eAAe,EAAEwJ,oBAAoB,EAAEx2B,eAAe,EAAE21B,eAAe,EAAE;EAC/J,OAAO;IACLrf,IAAI,EAAE0R,MAAM,CAAC6J,cAAc;IAC3BnyB,UAAU,EAAE,IAAI;IAChBmqB,IAAI,EAAEuM,WAAW;IACjBtJ,MAAM,EAAE,IAAIyI,UAAU,CAAC,CAAC;IACxBc,SAAS;IACTtE,KAAK;IACLC,SAAS,EAAE,IAAI;IACfF,UAAU,EAAE,IAAI;IAChBt2D,GAAG;IACH+6D,QAAQ;IACRE,eAAe,EAAE,IAAI;IACrBV,kBAAkB,EAAE,KAAK;IACzBrK,SAAS,EAAEjD,SAAS,CAACiO,IAAI;IACzBb,WAAW,EAAE,KAAK;IAClBD,SAAS,EAAE,EAAE;IACbI,KAAK,EAAE,IAAI;IACX1wB,IAAI,EAAE,IAAI;IACVgxB,QAAQ;IACRK,qBAAqB,EAAE,KAAK;IAC5B3J,eAAe;IACfwJ,oBAAoB;IACpBx2B,eAAe;IACf21B,eAAe;IACf,GAAGzM,mBAAmB;IACtB,GAAGS,MAAM;IACT,GAAGN,mBAAmB;IACtBF,YAAY,EAAEkN,SAAS,KAAK,IAAI,GAAG,CAAC,GAAG;EACzC,CAAC;AACH;AACA,SAASO,kBAAkBA,CAAC/M,IAAI,EAAE5+C,UAAU,EAAE;EAC5C,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAAC2K,UAAU;IACvB9I,IAAI;IACJ5+C,UAAU;IACV,GAAG0+C;EACL,CAAC;AACH;AACA,SAASkN,uBAAuBA,CAAChN,IAAI,EAAE;EACrC,OAAO;IACLvT,IAAI,EAAE0R,MAAM,CAAC0K,eAAe;IAC5B7I,IAAI;IACJ,GAAGF;EACL,CAAC;AACH;AACA,SAASmN,sBAAsBA,CAACjN,IAAI,EAAE;EACpC,OAAO;IACLvT,IAAI,EAAE0R,MAAM,CAAC6K,cAAc;IAC3BhJ,IAAI;IACJ,GAAGF;EACL,CAAC;AACH;AACA,SAASoN,YAAYA,CAAClN,IAAI,EAAEmN,YAAY,EAAEjK,cAAc,EAAE9hD,UAAU,EAAE;EACpE,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAACvpB,IAAI;IACjBorB,IAAI;IACJiD,MAAM,EAAE,IAAIyI,UAAU,CAAC,CAAC;IACxByB,YAAY;IACZjK,cAAc;IACd9hD,UAAU;IACV,GAAGi+C,mBAAmB;IACtB,GAAGS;EACL,CAAC;AACH;AACA,SAASsN,uBAAuBA,CAACp6D,IAAI,EAAEg4B,MAAM,EAAE03B,aAAa,EAAE1oD,UAAU,EAAE25B,eAAe,EAAEvyB,UAAU,EAAE;EACrG,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAACkJ,eAAe;IAC5Br0D,IAAI;IACJg4B,MAAM;IACN03B,aAAa;IACb1oD,UAAU;IACV4mD,WAAW,EAAE,IAAI;IACjBjtB,eAAe;IACfstB,SAAS,EAAE,IAAI;IACf7/C,UAAU;IACV,GAAG0+C;EACL,CAAC;AACH;AACA,SAASuN,iBAAiBA,CAACr6D,IAAI,EAAEg4B,MAAM,EAAE03B,aAAa,EAAE4K,WAAW,EAAE35B,eAAe,EAAEvyB,UAAU,EAAE;EAChG,MAAMymD,UAAU,GAAG,IAAIoC,MAAM,CAAC,CAAC;EAC/BpC,UAAU,CAAC12D,IAAI,CAACm8D,WAAW,CAAC;EAC5B,OAAO;IACL7gB,IAAI,EAAE0R,MAAM,CAACqJ,SAAS;IACtBx0D,IAAI;IACJg4B,MAAM;IACN03B,aAAa;IACbmF,UAAU;IACV0F,aAAa,EAAE,IAAI;IACnB3M,WAAW,EAAE,IAAI;IACjBjtB,eAAe;IACfstB,SAAS,EAAE,IAAI;IACf7/C,UAAU;IACV,GAAG0+C;EACL,CAAC;AACH;AACA,SAAS0N,gBAAgBA,CAACxiC,MAAM,EAAEs3B,UAAU,EAAEtvD,IAAI,EAAErB,GAAG,EAAEk2D,UAAU,EAAE4F,oBAAoB,EAAEC,WAAW,EAAEC,YAAY,EAAEvsD,UAAU,EAAE;EAChI,MAAMwsD,WAAW,GAAG,IAAI3D,MAAM,CAAC,CAAC;EAChC2D,WAAW,CAACz8D,IAAI,CAAC02D,UAAU,CAAC;EAC5B,OAAO;IACLpb,IAAI,EAAE0R,MAAM,CAACuJ,QAAQ;IACrB18B,MAAM;IACNs3B,UAAU;IACV3wD,GAAG;IACHg8D,YAAY;IACZ36D,IAAI;IACJ60D,UAAU,EAAE+F,WAAW;IACvBL,aAAa,EAAE,IAAI;IACnBM,mBAAmB,EAAE,KAAK;IAC1BC,yBAAyB,EAAEL,oBAAoB,KAAK,IAAI;IACxDA,oBAAoB,EAAEA,oBAAoB;IAC1CC,WAAW;IACXtsD,UAAU;IACV,GAAG0+C;EACL,CAAC;AACH;AACA,SAASiO,yBAAyBA,CAAC/iC,MAAM,EAAEs3B,UAAU,EAAEtvD,IAAI,EAAErB,GAAG,EAAEk2D,UAAU,EAAEnF,aAAa,EAAEgL,WAAW,EAAEC,YAAY,EAAEvsD,UAAU,EAAE;EAClI,MAAMwsD,WAAW,GAAG,IAAI3D,MAAM,CAAC,CAAC;EAChC2D,WAAW,CAACz8D,IAAI,CAAC02D,UAAU,CAAC;EAC5B,OAAO;IACLpb,IAAI,EAAE0R,MAAM,CAACsJ,iBAAiB;IAC9Bz8B,MAAM;IACNs3B,UAAU;IACV3wD,GAAG;IACHg8D,YAAY;IACZ36D,IAAI;IACJ0vD,aAAa;IACbmF,UAAU,EAAE+F,WAAW;IACvBL,aAAa,EAAE,IAAI;IACnBM,mBAAmB,EAAE,KAAK;IAC1BH,WAAW;IACXtsD,UAAU;IACV,GAAG0+C;EACL,CAAC;AACH;AACA,SAASkO,sBAAsBA,CAAChjC,MAAM,EAAEs3B,UAAU,EAAEtvD,IAAI,EAAErB,GAAG,EAAEk2D,UAAU,EAAEzmD,UAAU,EAAE;EACrF,MAAMwsD,WAAW,GAAG,IAAI3D,MAAM,CAAC,CAAC;EAChC2D,WAAW,CAACz8D,IAAI,CAAC02D,UAAU,CAAC;EAC5B,OAAO;IACLpb,IAAI,EAAE0R,MAAM,CAACwJ,cAAc;IAC3B38B,MAAM;IACNs3B,UAAU;IACV3wD,GAAG;IACHqB,IAAI;IACJ60D,UAAU,EAAE+F,WAAW;IACvBL,aAAa,EAAE,IAAI;IACnBnsD,UAAU;IACV,GAAG0+C;EACL,CAAC;AACH;AACA,SAASmO,YAAYA,CAACjO,IAAI,EAAE4G,IAAI,EAAE5zD,IAAI,EAAE;EACtC,OAAO;IACLy5C,IAAI,EAAE0R,MAAM,CAACxxB,IAAI;IACjBqzB,IAAI;IACJiD,MAAM,EAAE2D,IAAI;IACZ5zD,IAAI;IACJ,GAAG8sD,MAAM;IACT,GAAGT;EACL,CAAC;AACH;AACA,SAAS6O,iBAAiBA,CAACrM,SAAS,EAAE;EACpC,OAAO;IACLpV,IAAI,EAAE0R,MAAM,CAACS,SAAS;IACtBuP,MAAM,EAAEtM,SAAS;IACjB,GAAG/B;EACL,CAAC;AACH;AACA,SAASsO,qBAAqBA,CAACp8C,GAAG,EAAE;EAClC,OAAO;IACLy6B,IAAI,EAAE0R,MAAM,CAACqL,aAAa;IAC1Bx3C,GAAG;IACH,GAAG8tC;EACL,CAAC;AACH;AACA,SAASuO,kBAAkBA,CAACrO,IAAI,EAAEnvD,QAAQ,EAAEsyD,eAAe,EAAEmL,YAAY,EAAEltD,UAAU,EAAE;EACrF,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAACoL,UAAU;IACvBvJ,IAAI;IACJiD,MAAM,EAAE,IAAIyI,UAAU,CAAC,CAAC;IACxB76D,QAAQ;IACRsyD,eAAe;IACfmL,YAAY;IACZC,mBAAmB,EAAE,CAAC;IACtB14B,UAAU,EAAE,IAAI;IAChBk2B,SAAS,EAAE,EAAE;IACb3qD,UAAU;IACV,GAAG0+C,MAAM;IACT,GAAGT,mBAAmB;IACtBC,YAAY,EAAEgP,YAAY,KAAK,IAAI,GAAG,CAAC,GAAG;EAC5C,CAAC;AACH;AACA,SAASE,0BAA0BA,CAACxjC,MAAM,EAAE81B,WAAW,EAAEe,SAAS,EAAE7uD,IAAI,EAAEgH,UAAU,EAAE+mD,WAAW,EAAEH,WAAW,EAAEjtB,eAAe,EAAE;EAC/H,OAAO;IACL8Y,IAAI,EAAE0R,MAAM,CAAC2J,kBAAkB;IAC/B98B,MAAM;IACN81B,WAAW;IACXe,SAAS;IACT7uD,IAAI;IACJgH,UAAU;IACV+mD,WAAW;IACXH,WAAW;IACXjtB,eAAe;IACfo0B,cAAc,EAAE,IAAI;IACpB,GAAGjI;EACL,CAAC;AACH;AACA,SAAS2O,aAAaA,CAACzO,IAAI,EAAE0O,IAAI,EAAEC,QAAQ,EAAEC,aAAa,EAAErG,UAAU,EAAEnnD,UAAU,EAAE;EAClF,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAACiK,KAAK;IAClBpI,IAAI;IACJiD,MAAM,EAAE,IAAIyI,UAAU,CAAC,CAAC;IACxBmD,QAAQ,EAAEH,IAAI;IACdC,QAAQ;IACRG,WAAW,EAAE,IAAI;IACjBC,WAAW,EAAE,IAAI;IACjB1G,aAAa,EAAE,IAAI;IACnB2G,kBAAkB,EAAE,IAAI;IACxBC,gBAAgB,EAAE,IAAI;IACtBC,eAAe,EAAE,IAAI;IACrBC,eAAe,EAAE,IAAI;IACrB7G,iBAAiB,EAAE,IAAI;IACvB8G,sBAAsB,EAAE,IAAI;IAC5BC,SAAS,EAAE,IAAI;IACfC,SAAS,EAAE,IAAI;IACfV,aAAa;IACbrG,UAAU;IACV9hD,KAAK,EAAE,IAAI;IACXrF,UAAU;IACV,GAAG0+C,MAAM;IACT,GAAGT,mBAAmB;IACtBC,YAAY,EAAE;EAChB,CAAC;AACH;AACA,SAASiQ,eAAeA,CAAC35C,KAAK,EAAE0mB,OAAO,EAAE59B,QAAQ,EAAE0C,UAAU,EAAE;EAC7D,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAACyK,OAAO;IACpBhzC,KAAK;IACL0mB,OAAO;IACP59B,QAAQ;IACR0C,UAAU;IACV,GAAG0+C;EACL,CAAC;AACH;AACA,SAAS0P,kBAAkBA,CAACxP,IAAI,EAAElc,YAAY,EAAE1iC,UAAU,EAAE;EAC1D,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAACuL,UAAU;IACvB1J,IAAI;IACJlc,YAAY;IACZ1iC,UAAU;IACV6hD,MAAM,EAAE,IAAIyI,UAAU,CAAC,CAAC;IACxB,GAAGrM,mBAAmB;IACtB,GAAGS;EACL,CAAC;AACH;AACA,SAAS2P,mBAAmBA,CAACzP,IAAI,EAAEe,WAAW,EAAE2O,SAAS,EAAEv3D,OAAO,EAAEw3D,kBAAkB,EAAEjuD,MAAM,EAAE+mD,oBAAoB,EAAEmH,mBAAmB,EAAE;EACzI,OAAO;IACLnjB,IAAI,EAAE0R,MAAM,CAACqK,WAAW;IACxBxI,IAAI;IACJe,WAAW;IACX2O,SAAS;IACTv3D,OAAO;IACPw3D,kBAAkB;IAClBjuD,MAAM;IACN+mD,oBAAoB;IACpBmH,mBAAmB;IACnBC,WAAW,EAAE,EAAE;IACf,GAAG/P;EACL,CAAC;AACH;AACA,SAASgQ,iBAAiBA,CAAC9P,IAAI,EAAE7nD,OAAO,EAAE43D,IAAI,EAAE3uD,UAAU,EAAE;EAC1D,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAACiL,SAAS;IACtBpJ,IAAI;IACJiD,MAAM,EAAE,IAAIyI,UAAU,CAAC,CAAC;IACxBqE,IAAI,EAAEA,IAAI,IAAI/P,IAAI;IAClB7nD,OAAO;IACP63D,YAAY,EAAE,IAAI;IAClBC,gBAAgB,EAAE,IAAI;IACtB52D,OAAO,EAAE,IAAI;IACb+H,UAAU;IACV,GAAG0+C,MAAM;IACT,GAAGT;EACL,CAAC;AACH;AACA,SAAS6Q,eAAeA,CAAClQ,IAAI,EAAE5+C,UAAU,EAAE;EACzC,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAACgL,OAAO;IACpBnJ,IAAI;IACJ5+C,UAAU;IACV,GAAG0+C;EACL,CAAC;AACH;AACA,SAASqQ,gBAAgBA,CAACnQ,IAAI,EAAE7nD,OAAO,EAAEw3D,kBAAkB,EAAEvuD,UAAU,EAAE;EACvE,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAACmL,QAAQ;IACrBtJ,IAAI;IACJ7nD,OAAO;IACPw3D,kBAAkB;IAClBt2D,OAAO,EAAE,IAAI;IACb+H,UAAU;IACV,GAAG0+C;EACL,CAAC;AACH;AACA,SAASsQ,cAAcA,CAACpQ,IAAI,EAAE;EAC5B,OAAO;IACLvT,IAAI,EAAE0R,MAAM,CAACkL,MAAM;IACnBrJ,IAAI;IACJ,GAAGF;EACL,CAAC;AACH;AACA,SAASuQ,sBAAsBA,CAACrQ,IAAI,EAAEhtD,IAAI,EAAE68B,OAAO,EAAE;EACnD,OAAO;IACL4c,IAAI,EAAE0R,MAAM,CAAC7gB,cAAc;IAC3B0iB,IAAI;IACJhtD,IAAI;IACJ68B,OAAO;IACPygC,sBAAsB,EAAE,EAAE;IAC1B,GAAGxQ;EACL,CAAC;AACH;AACA,SAASyQ,mBAAmBA,CAACC,WAAW,EAAExQ,IAAI,EAAE0P,SAAS,EAAEv3D,OAAO,EAAEiJ,UAAU,EAAE;EAC9E,IAAIsuD,SAAS,KAAK,IAAI,IAAIc,WAAW,KAAK1R,eAAe,CAAC2R,IAAI,EAAE;IAC9D,MAAM,IAAI/+D,KAAK,CAAC,wEAAwE,CAAC;EAC3F;EACA,OAAO;IACL+6C,IAAI,EAAE0R,MAAM,CAAC+K,WAAW;IACxBsH,WAAW;IACXxQ,IAAI;IACJ0P,SAAS;IACTv3D,OAAO;IACPiJ,UAAU;IACVM,MAAM,EAAE,IAAI9N,GAAG,CAAC,CAAC;IACjB60D,oBAAoB,EAAE,IAAI70D,GAAG,CAAC,CAAC;IAC/B,GAAGksD;EACL,CAAC;AACH;AACA,SAAS4Q,sBAAsBA,CAAC1Q,IAAI,EAAEiD,MAAM,EAAEj4B,MAAM,EAAE;EACpD,OAAO;IACLyhB,IAAI,EAAE0R,MAAM,CAACsL,cAAc;IAC3BzJ,IAAI;IACJiD,MAAM;IACNj4B,MAAM;IACN2lC,oBAAoB,EAAE,IAAI;IAC1B,GAAG7Q,MAAM;IACT,GAAGT;EACL,CAAC;AACH;AACA,SAASuR,sBAAsBA,CAACC,YAAY,EAAEC,SAAS,EAAE;EACvD,OAAO;IACLrkB,IAAI,EAAE0R,MAAM,CAACwL,cAAc;IAC3BkH,YAAY;IACZC,SAAS;IACT,GAAGhR;EACL,CAAC;AACH;AACA,SAASiR,qBAAqBA,CAAC3vD,UAAU,EAAE;EACzC,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAAC2L,aAAa;IAC1B1oD,UAAU;IACV,GAAG0+C;EACL,CAAC;AACH;AAEA,SAASkR,mBAAmBA,CAACh+D,IAAI,EAAEgH,UAAU,EAAE8mD,WAAW,EAAEC,WAAW,EAAEptB,eAAe,EAAEvyB,UAAU,EAAE;EACpG,OAAO;IACLqrC,IAAI,EAAE0R,MAAM,CAACmJ,WAAW;IACxBt0D,IAAI;IACJgH,UAAU;IACV8mD,WAAW;IACXC,WAAW;IACXptB,eAAe;IACfstB,SAAS,EAAE,IAAI;IACf7/C,UAAU;IACV,GAAGo+C,mBAAmB;IACtB,GAAGM;EACL,CAAC;AACH;AAEA,MAAMmR,OAAO,GAAG,gBAAgB;AAEhC,IAAIC,kBAAkB;AACtB,CAAC,UAAUA,kBAAkB,EAAE;EAC7BA,kBAAkB,CAACA,kBAAkB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EAC3DA,kBAAkB,CAACA,kBAAkB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EAC3DA,kBAAkB,CAACA,kBAAkB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;AAC7D,CAAC,EAAEA,kBAAkB,KAAKA,kBAAkB,GAAG,CAAC,CAAC,CAAC,CAAC;AACnD,IAAIC,uBAAuB;AAC3B,CAAC,UAAUA,uBAAuB,EAAE;EAClCA,uBAAuB,CAACA,uBAAuB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EACrEA,uBAAuB,CAACA,uBAAuB,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;AAC7E,CAAC,EAAEA,uBAAuB,KAAKA,uBAAuB,GAAG,CAAC,CAAC,CAAC,CAAC;AAC7D,MAAMC,cAAc,CAAC;EACnB32B,aAAa;EACb42B,IAAI;EACJC,aAAa;EACbC,IAAI;EACJv7D,WAAWA,CAACykC,aAAa,EAAE42B,IAAI,EAAEC,aAAa,EAAEC,IAAI,EAAE;IACpD,IAAI,CAAC92B,aAAa,GAAGA,aAAa;IAClC,IAAI,CAAC42B,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,IAAI,GAAGA,IAAI;EAClB;EACA9kB,IAAI,GAAGykB,kBAAkB,CAACM,IAAI;EAC9BC,cAAcA,CAAA,EAAG;IACf,OAAO,IAAI,CAACC,UAAU,EAAE;EAC1B;EACAA,UAAU,GAAG,CAAC;AAChB;AACA,MAAMC,uBAAuB,SAASP,cAAc,CAAC;EACnDQ,uBAAuB;EACvBC,kBAAkB;EAClBC,SAAS;EACTC,mBAAmB;EACnBC,oBAAoB;EACpBC,oBAAoB;EACpBj8D,WAAWA,CAACykC,aAAa,EAAE42B,IAAI,EAAEC,aAAa,EAAEC,IAAI,EAAEK,uBAAuB,EAAEC,kBAAkB,EAAEC,SAAS,EAAEC,mBAAmB,EAAEC,oBAAoB,EAAEC,oBAAoB,EAAE;IAC7K,KAAK,CAACx3B,aAAa,EAAE42B,IAAI,EAAEC,aAAa,EAAEC,IAAI,CAAC;IAC/C,IAAI,CAACK,uBAAuB,GAAGA,uBAAuB;IACtD,IAAI,CAACC,kBAAkB,GAAGA,kBAAkB;IAC5C,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,mBAAmB,GAAGA,mBAAmB;IAC9C,IAAI,CAACC,oBAAoB,GAAGA,oBAAoB;IAChD,IAAI,CAACC,oBAAoB,GAAGA,oBAAoB;IAChD,IAAI,CAAClC,IAAI,GAAG,IAAImC,mBAAmB,CAAC,IAAI,EAAE,IAAI,CAACT,cAAc,CAAC,CAAC,EAAE,IAAI,CAAC;IACtE,IAAI,CAACU,KAAK,CAACj9D,GAAG,CAAC,IAAI,CAAC66D,IAAI,CAAC/P,IAAI,EAAE,IAAI,CAAC+P,IAAI,CAAC;EAC3C;EACAtjB,IAAI,GAAGykB,kBAAkB,CAACkB,IAAI;EAC9BC,QAAQ,GAAG,UAAU;EACrBtC,IAAI;EACJoC,KAAK,GAAG,IAAIv+D,GAAG,CAAC,CAAC;EACjB0+D,gBAAgB,GAAG,IAAI;EACvBC,YAAYA,CAACC,MAAM,EAAE;IACnB,MAAM71D,IAAI,GAAG,IAAIu1D,mBAAmB,CAAC,IAAI,EAAE,IAAI,CAACT,cAAc,CAAC,CAAC,EAAEe,MAAM,CAAC;IACzE,IAAI,CAACL,KAAK,CAACj9D,GAAG,CAACyH,IAAI,CAACqjD,IAAI,EAAErjD,IAAI,CAAC;IAC/B,OAAOA,IAAI;EACb;EACA,IAAI81D,KAAKA,CAAA,EAAG;IACV,OAAO,IAAI,CAACN,KAAK,CAAChjD,MAAM,CAAC,CAAC;EAC5B;EACAujD,QAAQA,CAACC,QAAQ,EAAEC,YAAY,EAAE;IAC/B,KAAK,IAAIjN,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG,IAAI,CAACkN,MAAM,CAAC3hE,MAAM,EAAEy0D,GAAG,EAAE,EAAE;MACjD,IAAI,IAAI,CAACkN,MAAM,CAAClN,GAAG,CAAC,CAAC9kD,YAAY,CAAC8xD,QAAQ,CAAC,EAAE;QAC3C,OAAOhN,GAAG;MACZ;IACF;IACA,MAAMA,GAAG,GAAG,IAAI,CAACkN,MAAM,CAAC3hE,MAAM;IAC9B,IAAI,CAAC2hE,MAAM,CAAC1hE,IAAI,CAACwhE,QAAQ,CAAC;IAC1B,IAAIC,YAAY,EAAE;MAChB,IAAI,CAACE,kBAAkB,CAAC3hE,IAAI,CAAC,GAAGyhE,YAAY,CAAC;IAC/C;IACA,OAAOjN,GAAG;EACZ;EACAkN,MAAM,GAAG,EAAE;EACXC,kBAAkB,GAAG,EAAE;AACzB;AACA,MAAMC,eAAe,CAAC;EACpB/S,IAAI;EACJhqD,WAAWA,CAACgqD,IAAI,EAAE;IAChB,IAAI,CAACA,IAAI,GAAGA,IAAI;EAClB;EACAgT,MAAM,GAAG,IAAI/I,MAAM,CAAC,CAAC;EACrBgJ,MAAM,GAAG,IAAIhJ,MAAM,CAAC,CAAC;EACrBiJ,MAAM,GAAG,IAAI;EACbz3B,IAAI,GAAG,IAAI;EACX,CAACgvB,GAAGA,CAAA,EAAG;IACL,KAAK,MAAMn/C,EAAE,IAAI,IAAI,CAAC0nD,MAAM,EAAE;MAC5B,MAAM1nD,EAAE;MACR,IAAIA,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACuJ,QAAQ,IAAIp8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACqJ,SAAS,IAAIl8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACsJ,iBAAiB,IAAIn8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACwJ,cAAc,EAAE;QAC5I,KAAK,MAAMwL,UAAU,IAAI7nD,EAAE,CAACu8C,UAAU,EAAE;UACtC,MAAMsL,UAAU;QAClB;MACF,CAAC,MAAM,IAAI7nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC6J,cAAc,IAAI18C,EAAE,CAAC28C,UAAU,KAAK,IAAI,EAAE;QACtE,KAAK,MAAMmL,OAAO,IAAI9nD,EAAE,CAAC28C,UAAU,EAAE;UACnC,MAAMmL,OAAO;QACf;MACF;IACF;IACA,KAAK,MAAM9nD,EAAE,IAAI,IAAI,CAAC2nD,MAAM,EAAE;MAC5B,MAAM3nD,EAAE;IACV;EACF;AACF;AACA,MAAM4mD,mBAAmB,SAASa,eAAe,CAAC;EAChDM,GAAG;EACHb,MAAM;EACNx8D,WAAWA,CAACq9D,GAAG,EAAErT,IAAI,EAAEwS,MAAM,EAAE;IAC7B,KAAK,CAACxS,IAAI,CAAC;IACX,IAAI,CAACqT,GAAG,GAAGA,GAAG;IACd,IAAI,CAACb,MAAM,GAAGA,MAAM;EACtB;EACAh5B,gBAAgB,GAAG,IAAI5lC,GAAG,CAAC,CAAC;EAC5B0/D,OAAO,GAAG,IAAI9gB,GAAG,CAAC,CAAC;EACnB2Z,KAAK,GAAG,IAAI;AACd;AACA,MAAMoH,yBAAyB,SAASnC,cAAc,CAAC;EACrDp7D,WAAWA,CAACykC,aAAa,EAAE42B,IAAI,EAAEC,aAAa,EAAEC,IAAI,EAAE;IACpD,KAAK,CAAC92B,aAAa,EAAE42B,IAAI,EAAEC,aAAa,EAAEC,IAAI,CAAC;IAC/C,IAAI,CAACxB,IAAI,GAAG,IAAIyD,0BAA0B,CAAC,IAAI,CAAC;EAClD;EACA/mB,IAAI,GAAGykB,kBAAkB,CAACuC,IAAI;EAC9BpB,QAAQ,GAAG,cAAc;EACzBtC,IAAI;EACJ,IAAI0C,KAAKA,CAAA,EAAG;IACV,OAAO,CAAC,IAAI,CAAC1C,IAAI,CAAC;EACpB;AACF;AACA,MAAMyD,0BAA0B,SAAST,eAAe,CAAC;EACvDM,GAAG;EACHr9D,WAAWA,CAACq9D,GAAG,EAAE;IACf,KAAK,CAAC,CAAC,CAAC;IACR,IAAI,CAACA,GAAG,GAAGA,GAAG;EAChB;EACAx9B,UAAU,GAAG,IAAI;AACnB;AAEA,SAAS69B,cAAcA,CAACL,GAAG,EAAE;EAC3B,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAAC62B,GAAG,CAAC,CAAC,EAAE;MAC3BtD,wBAAwB,CAAC77C,EAAE,EAAEqoD,UAAU,EAAE/N,kBAAkB,CAACpnD,IAAI,CAAC;IACnE;EACF;AACF;AACA,SAASm1D,UAAUA,CAACl4D,CAAC,EAAE;EACrB,IAAIA,CAAC,YAAYmG,kBAAkB,IAAInG,CAAC,CAACoK,EAAE,YAAYk+C,eAAe,IAAItoD,CAAC,CAACoK,EAAE,CAAC7S,IAAI,KAAK,MAAM,EAAE;IAC9F,IAAIyI,CAAC,CAACqK,IAAI,CAAC5U,MAAM,KAAK,CAAC,EAAE;MACvB,MAAM,IAAIQ,KAAK,CAAC,yDAAyD,CAAC;IAC5E;IACA,OAAO+J,CAAC,CAACqK,IAAI,CAAC,CAAC,CAAC;EAClB;EACA,OAAOrK,CAAC;AACV;AAEA,SAASm4D,oBAAoBA,CAACP,GAAG,EAAE;EACjC,MAAMQ,YAAY,GAAG,IAAIjgE,GAAG,CAAC,CAAC;EAC9B,KAAK,MAAMggC,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC+K,WAAW,EAAE;QAClC2K,YAAY,CAAC3+D,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC;MAC/B;IACF;EACF;EACA,KAAK,MAAMsoB,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACq/B,MAAM,EAAE;MAC5B,IAAI3nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACkF,cAAc,IAAIyQ,gBAAgB,CAACD,YAAY,EAAEvoD,EAAE,CAAC,EAAE;QAC3E2+C,MAAM,CAACuB,WAAW,CAAClI,iBAAiB,CAACh4C,EAAE,CAAC03C,SAAS,EAAE13C,EAAE,CAAC23C,MAAM,EAAE,IAAI,CAAC,EAAE33C,EAAE,CAAC;MAC1E;IACF;EACF;AACF;AACA,SAASwoD,gBAAgBA,CAACD,YAAY,EAAEvoD,EAAE,EAAE;EAC1C,IAAIA,EAAE,CAAC60C,IAAI,EAAE1T,IAAI,KAAK0R,MAAM,CAACkF,cAAc,EAAE;IAC3C,OAAO,IAAI;EACb;EACA,MAAMhqD,OAAO,GAAGw6D,YAAY,CAAC5+D,GAAG,CAACqW,EAAE,CAACjS,OAAO,CAAC;EAC5C,MAAMoc,WAAW,GAAGo+C,YAAY,CAAC5+D,GAAG,CAACqW,EAAE,CAAC60C,IAAI,CAAC9mD,OAAO,CAAC;EACrD,IAAIA,OAAO,KAAK0nB,SAAS,EAAE;IACzB,MAAM,IAAIrvB,KAAK,CAAC,uFAAuF,CAAC;EAC1G;EACA,IAAI+jB,WAAW,KAAKsL,SAAS,EAAE;IAC7B,MAAM,IAAIrvB,KAAK,CAAC,4FAA4F,CAAC;EAC/G;EACA,IAAI2H,OAAO,CAACq2D,SAAS,KAAK,IAAI,EAAE;IAC9B,IAAIr2D,OAAO,CAACq2D,SAAS,KAAKj6C,WAAW,CAACi6C,SAAS,EAAE;MAC/C,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd;EACA,IAAIpkD,EAAE,CAAC03C,SAAS,KAAK13C,EAAE,CAAC60C,IAAI,CAAC6C,SAAS,EAAE;IACtC,OAAO,IAAI;EACb;EACA,OAAO,KAAK;AACd;AAEA,SAAS+Q,0BAA0BA,CAACV,GAAG,EAAE;EACvC,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,IAAIuB,QAAQ,GAAGpgC,IAAI,CAACq/B,MAAM,CAACzqC,IAAI;IAC/B,IAAIyrC,yBAAyB,GAAG,EAAE;IAClC,IAAIC,KAAK,GAAG,IAAI;IAChB,KAAK,MAAMC,QAAQ,IAAIvgC,IAAI,CAACo/B,MAAM,EAAE;MAClC,IAAImB,QAAQ,CAAC1nB,IAAI,KAAK0R,MAAM,CAACiL,SAAS,EAAE;QACtC8K,KAAK,GAAG;UACNE,SAAS,EAAED,QAAQ,CAACnU,IAAI;UACxBqU,gBAAgB,EAAEF,QAAQ,CAACnU;QAC7B,CAAC;MACH,CAAC,MAAM,IAAImU,QAAQ,CAAC1nB,IAAI,KAAK0R,MAAM,CAACgL,OAAO,EAAE;QAC3C,KAAK,MAAM79C,EAAE,IAAI2oD,yBAAyB,EAAE;UAC1C3oD,EAAE,CAAC0f,MAAM,GAAGkpC,KAAK,CAACG,gBAAgB;UAClCpK,MAAM,CAACsB,YAAY,CAACjgD,EAAE,EAAE0oD,QAAQ,CAAC;QACnC;QACAC,yBAAyB,CAAC/iE,MAAM,GAAG,CAAC;QACpCgjE,KAAK,GAAG,IAAI;MACd;MACA,IAAIzU,oBAAoB,CAAC0U,QAAQ,CAAC,EAAE;QAClC,IAAID,KAAK,KAAK,IAAI,EAAE;UAClBA,KAAK,CAACG,gBAAgB,GAAGF,QAAQ,CAACnU,IAAI;QACxC;QACA,OAAO,IAAI,EAAE;UACX,IAAIgU,QAAQ,CAAC7T,IAAI,KAAK,IAAI,EAAE;YAC1B;UACF;UACA,IAAI+T,KAAK,KAAK,IAAI,IAAIF,QAAQ,CAACvnB,IAAI,KAAK0R,MAAM,CAACkF,cAAc,IAAI2Q,QAAQ,CAACniD,KAAK,KAAK6sC,iBAAiB,CAAC4V,QAAQ,IAAIN,QAAQ,CAAChR,SAAS,KAAKkR,KAAK,CAACE,SAAS,EAAE;YACxJ,MAAMG,UAAU,GAAGP,QAAQ;YAC3BA,QAAQ,GAAGA,QAAQ,CAAC7T,IAAI;YACxB8J,MAAM,CAACiB,MAAM,CAACqJ,UAAU,CAAC;YACzBN,yBAAyB,CAAC9iE,IAAI,CAACojE,UAAU,CAAC;YAC1C;UACF;UACA,IAAIC,kBAAkB,GAAG,KAAK;UAC9B,IAAI9U,4BAA4B,CAACsU,QAAQ,CAAC,IAAIA,QAAQ,CAAChpC,MAAM,KAAKmpC,QAAQ,CAACnU,IAAI,EAAE;YAC/EwU,kBAAkB,GAAG,IAAI;UAC3B,CAAC,MAAM,IAAIR,QAAQ,CAACvnB,IAAI,KAAK0R,MAAM,CAAC7wC,SAAS,IAAI0mD,QAAQ,CAACvnB,IAAI,KAAK0R,MAAM,CAAChjB,QAAQ,EAAE;YAClF+rB,oBAAoB,CAAC8M,QAAQ,EAAE1uD,IAAI,IAAI;cACrC,IAAI,CAACkvD,kBAAkB,IAAI9U,4BAA4B,CAACp6C,IAAI,CAAC,IAAIA,IAAI,CAAC0lB,MAAM,KAAKmpC,QAAQ,CAACnU,IAAI,EAAE;gBAC9FwU,kBAAkB,GAAG,IAAI;cAC3B;YACF,CAAC,CAAC;UACJ;UACA,IAAIA,kBAAkB,EAAE;YACtB;UACF;UACAR,QAAQ,GAAGA,QAAQ,CAAC7T,IAAI;QAC1B;MACF;IACF;EACF;AACF;AAEA,SAAS9hC,qBAAqBA,CAACg1C,GAAG,EAAE;EAClC,IAAI,CAACA,GAAG,CAACpB,oBAAoB,IAAIoB,GAAG,CAACrB,oBAAoB,KAAK,IAAI,EAAE;IAClE;EACF;EACA,KAAK,MAAMp+B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,MAAM3B,SAAS,GAAG,EAAE;IACpB,KAAK,MAAMxlD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC4K,YAAY,IAAIz9C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACvoB,OAAO,EAAE;QACjE,MAAMrO,KAAK,GAAGjc,EAAE,CAAC6qB,eAAe,CAAC5O,KAAK;QACtCupC,SAAS,CAAC3/D,IAAI,CAAC;UACbmxD,UAAU,EAAEh3C,EAAE,CAAC23C,MAAM;UACrBvY,MAAM,EAAEnjB,KAAK,CAACmjB,MAAM;UACpBzjB,IAAI,EAAEM,KAAK,CAACN,IAAI;UAChBW,MAAM,EAAEL,KAAK,CAACG;QAChB,CAAC,CAAC;MACJ;IACF;IACA,IAAIopC,SAAS,CAAC5/D,MAAM,GAAG,CAAC,EAAE;MACxB0iC,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAACy/D,sBAAsB,CAACyC,GAAG,CAACrB,oBAAoB,EAAElB,SAAS,CAAC,CAAC;IAC/E;EACF;AACF;AAEA,SAAS2D,eAAeA,CAAC7gC,IAAI,EAAE;EAC7B,MAAMv+B,GAAG,GAAG,IAAIzB,GAAG,CAAC,CAAC;EACrB,KAAK,MAAM0X,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;IAC5B,IAAI,CAACvT,oBAAoB,CAACn0C,EAAE,CAAC,EAAE;MAC7B;IACF;IACAjW,GAAG,CAACH,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC;IACpB,IAAIA,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC6J,cAAc,IAAI18C,EAAE,CAACkhD,SAAS,KAAK,IAAI,EAAE;MAC9Dn3D,GAAG,CAACH,GAAG,CAACoW,EAAE,CAACkhD,SAAS,EAAElhD,EAAE,CAAC;IAC3B;EACF;EACA,OAAOjW,GAAG;AACZ;AAEA,SAASq/D,iBAAiBA,CAACrB,GAAG,EAAE;EAC9B,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,MAAM3rD,QAAQ,GAAG2tD,eAAe,CAAC7gC,IAAI,CAAC;IACtC,KAAK,MAAMtoB,EAAE,IAAIsoB,IAAI,CAAC62B,GAAG,CAAC,CAAC,EAAE;MAC3B,QAAQn/C,EAAE,CAACmhC,IAAI;QACb,KAAK0R,MAAM,CAAC2D,SAAS;UACnB6S,kBAAkB,CAAC/gC,IAAI,EAAEtoB,EAAE,EAAExE,QAAQ,CAAC;UACtC;QACF,KAAKq3C,MAAM,CAAChZ,QAAQ;UAClB,IAAI75B,EAAE,CAACw1C,WAAW,KAAKtC,WAAW,CAAC/oB,eAAe,IAAInqB,EAAE,CAACw1C,WAAW,KAAKtC,WAAW,CAACgJ,SAAS,EAAE;YAC9F,IAAI1G,WAAW;YACf,IAAIx1C,EAAE,CAACs1C,WAAW,KAAK,IAAI,IAAIt1C,EAAE,CAACq1C,YAAY,KAAK,IAAI,EAAE;cACvDG,WAAW,GAAGtC,WAAW,CAACyK,IAAI;YAChC,CAAC,MAAM,IAAI39C,EAAE,CAACo1C,6BAA6B,EAAE;cAC3CI,WAAW,GAAGtC,WAAW,CAAC3jB,QAAQ;YACpC,CAAC,MAAM;cACLimB,WAAW,GAAGtC,WAAW,CAACrZ,QAAQ;YACpC;YACA8kB,MAAM,CAACsB,YAAY,CAACiD,0BAA0B,CAACljD,EAAE,CAAC0f,MAAM,EAAE81B,WAAW,EAAE,IAAI,EAAEx1C,EAAE,CAACtY,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAEsY,EAAE,CAACqoB,eAAe,CAAC,EAAEihC,eAAe,CAAC9tD,QAAQ,EAAEwE,EAAE,CAAC0f,MAAM,CAAC,CAAC;UACpK;UACA;QACF,KAAKmzB,MAAM,CAACyF,OAAO;UACjBqG,MAAM,CAACsB,YAAY,CAACiD,0BAA0B,CAACljD,EAAE,CAAC0f,MAAM,EAAEwzB,WAAW,CAACrZ,QAAQ,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE75B,EAAE,CAACqoB,eAAe,CAAC,EAAEihC,eAAe,CAAC9tD,QAAQ,EAAEwE,EAAE,CAAC0f,MAAM,CAAC,CAAC;UAC3K;QACF,KAAKmzB,MAAM,CAACgD,cAAc;UACxB8I,MAAM,CAACsB,YAAY,CAACiD,0BAA0B,CAACljD,EAAE,CAAC0f,MAAM,EAAEwzB,WAAW,CAAC2C,cAAc,EAAE,IAAI,EAAE71C,EAAE,CAACtY,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAEsY,EAAE,CAACqoB,eAAe,CAAC,EAAEihC,eAAe,CAAC9tD,QAAQ,EAAEwE,EAAE,CAAC0f,MAAM,CAAC,CAAC;UACjL;QACF,KAAKmzB,MAAM,CAACkD,SAAS;QACrB,KAAKlD,MAAM,CAACoD,SAAS;UACnB,IAAI3tB,IAAI,CAACy/B,GAAG,CAAC/B,aAAa,KAAK/S,iBAAiB,CAACsW,yBAAyB,IAAIvpD,EAAE,CAACtR,UAAU,YAAY+zB,SAAS,EAAE;YAChHk8B,MAAM,CAACsB,YAAY,CAACiD,0BAA0B,CAACljD,EAAE,CAAC0f,MAAM,EAAEwzB,WAAW,CAACrZ,QAAQ,EAAE,IAAI,EAAE75B,EAAE,CAACtY,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE+D,eAAe,CAAC+9D,KAAK,CAAC,EAAEF,eAAe,CAAC9tD,QAAQ,EAAEwE,EAAE,CAAC0f,MAAM,CAAC,CAAC;UAChL;UACA;QACF,KAAKmzB,MAAM,CAACuJ,QAAQ;UAClB,IAAI,CAACp8C,EAAE,CAACwiD,yBAAyB,EAAE;YACjC,MAAMiH,oBAAoB,GAAGvG,0BAA0B,CAACljD,EAAE,CAAC0f,MAAM,EAAEwzB,WAAW,CAACrZ,QAAQ,EAAE,IAAI,EAAE75B,EAAE,CAACtY,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE+D,eAAe,CAACi+D,IAAI,CAAC;YAC/I,IAAI3B,GAAG,CAAC5mB,IAAI,KAAKykB,kBAAkB,CAACuC,IAAI,EAAE;cACxC,IAAIJ,GAAG,CAAC/B,aAAa,EAAE;gBACrB;cACF;cACA19B,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAAC4jE,oBAAoB,CAAC;YACxC,CAAC,MAAM;cACL9K,MAAM,CAACsB,YAAY,CAACwJ,oBAAoB,EAAEH,eAAe,CAAC9tD,QAAQ,EAAEwE,EAAE,CAAC0f,MAAM,CAAC,CAAC;YACjF;UACF;UACA;QACF,KAAKmzB,MAAM,CAACwJ,cAAc;UACxB,IAAI0L,GAAG,CAAC5mB,IAAI,KAAKykB,kBAAkB,CAACuC,IAAI,EAAE;YACxC,MAAMsB,oBAAoB,GAAGvG,0BAA0B,CAACljD,EAAE,CAAC0f,MAAM,EAAEwzB,WAAW,CAACrZ,QAAQ,EAAE,IAAI,EAAE75B,EAAE,CAACtY,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE+D,eAAe,CAACi+D,IAAI,CAAC;YAC/I/K,MAAM,CAACsB,YAAY,CAACwJ,oBAAoB,EAAEH,eAAe,CAAC9tD,QAAQ,EAAEwE,EAAE,CAAC0f,MAAM,CAAC,CAAC;UACjF;UACA;MACJ;IACF;EACF;AACF;AACA,SAAS4pC,eAAeA,CAAC9tD,QAAQ,EAAEk5C,IAAI,EAAE;EACvC,MAAM/4C,EAAE,GAAGH,QAAQ,CAAC7R,GAAG,CAAC+qD,IAAI,CAAC;EAC7B,IAAI/4C,EAAE,KAAK8Z,SAAS,EAAE;IACpB,MAAM,IAAIrvB,KAAK,CAAC,oDAAoD,CAAC;EACvE;EACA,OAAOuV,EAAE;AACX;AACA,SAAS0tD,kBAAkBA,CAAC/gC,IAAI,EAAEtoB,EAAE,EAAExE,QAAQ,EAAE;EAC9C,IAAIwE,EAAE,CAACtR,UAAU,YAAY41B,aAAa,EAAE;IAC1C;EACF;EACA,IAAIqlC,WAAW,GAAG3pD,EAAE,CAACm1C,eAAe,IAAIn1C,EAAE,CAACtR,UAAU,CAACgL,UAAU,CAAC,CAAC;EAClE,IAAI4uB,IAAI,CAACy/B,GAAG,CAAC/B,aAAa,KAAK/S,iBAAiB,CAACsW,yBAAyB,EAAE;IAC1EI,WAAW,KAAK3pD,EAAE,CAACm1C,eAAe;EACpC;EACA,IAAIwU,WAAW,EAAE;IACf,MAAMF,oBAAoB,GAAGvG,0BAA0B,CAACljD,EAAE,CAAC0f,MAAM,EAAE1f,EAAE,CAACo1C,6BAA6B,GAAGlC,WAAW,CAAC3jB,QAAQ,GAAG2jB,WAAW,CAACsD,SAAS,EAAEx2C,EAAE,CAACu2C,SAAS,EAAEv2C,EAAE,CAACtY,IAAI,EAAEsY,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAACy1C,WAAW,EAAEz1C,EAAE,CAACs1C,WAAW,EAAEt1C,EAAE,CAACqoB,eAAe,CAAC;IAC7O,IAAIC,IAAI,CAACy/B,GAAG,CAAC5mB,IAAI,KAAKykB,kBAAkB,CAACuC,IAAI,EAAE;MAC7C7/B,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAAC4jE,oBAAoB,CAAC;IACxC,CAAC,MAAM;MACL,MAAMG,OAAO,GAAGN,eAAe,CAAC9tD,QAAQ,EAAEwE,EAAE,CAAC0f,MAAM,CAAC;MACpDi/B,MAAM,CAACsB,YAAY,CAACwJ,oBAAoB,EAAEG,OAAO,CAAC;IACpD;IACAjL,MAAM,CAACiB,MAAM,CAAC5/C,EAAE,CAAC;EACnB;AACF;AAEA,MAAM6pD,WAAW,GAAG,OAAO;AAC3B,SAASC,eAAeA,CAACpiE,IAAI,EAAE;EAC7B,OAAOA,IAAI,CAACsvB,UAAU,CAAC6yC,WAAW,CAAC,IAAIniE,IAAI,CAAC9B,MAAM,GAAGikE,WAAW,CAACjkE,MAAM;AACzE;AAEA,SAASmkE,eAAeA,CAACvuD,QAAQ,EAAEk5C,IAAI,EAAE;EACvC,MAAM/4C,EAAE,GAAGH,QAAQ,CAAC7R,GAAG,CAAC+qD,IAAI,CAAC;EAC7B,IAAI/4C,EAAE,KAAK8Z,SAAS,EAAE;IACpB,MAAM,IAAIrvB,KAAK,CAAC,oDAAoD,CAAC;EACvE;EACA,OAAOuV,EAAE;AACX;AACA,SAASquD,kBAAkBA,CAACjC,GAAG,EAAE;EAC/B,MAAMvsD,QAAQ,GAAG,IAAIlT,GAAG,CAAC,CAAC;EAC1B,KAAK,MAAMggC,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI,CAACpH,sBAAsB,CAACtgD,EAAE,CAAC,EAAE;QAC/B;MACF;MACAxE,QAAQ,CAAC5R,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC;IAC3B;EACF;EACA,KAAK,MAAMsoB,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAAC62B,GAAG,CAAC,CAAC,EAAE;MAC3B,IAAIn/C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC0C,OAAO,EAAE;QAC9B;MACF;MACA,QAAQv1C,EAAE,CAACw1C,WAAW;QACpB,KAAKtC,WAAW,CAACsD,SAAS;UACxB,IAAIx2C,EAAE,CAACtY,IAAI,KAAK,eAAe,EAAE;YAC/Bi3D,MAAM,CAACiB,MAAM,CAAC5/C,EAAE,CAAC;YACjB,MAAM0f,MAAM,GAAGqqC,eAAe,CAACvuD,QAAQ,EAAEwE,EAAE,CAAC0f,MAAM,CAAC;YACnDA,MAAM,CAACghC,WAAW,GAAG,IAAI;UAC3B,CAAC,MAAM,IAAI1gD,EAAE,CAACtY,IAAI,CAACsvB,UAAU,CAAC,UAAU,CAAC,EAAE;YACzC2nC,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEm3C,wBAAwB,CAACn3C,EAAE,CAACtY,IAAI,EAAEsY,EAAE,CAAC0f,MAAM,EAAE1f,EAAE,CAACtY,IAAI,KAAK,eAAe,GAAG,OAAO,GAAG,OAAO,EAAEsY,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAACqoB,eAAe,EAAEroB,EAAE,CAAClK,UAAU,EAAE,CAAC,CAAC,CAAC;UACxK,CAAC,MAAM;YACL,MAAM,CAACygD,SAAS,EAAE7uD,IAAI,CAAC,GAAG8gC,WAAW,CAACxoB,EAAE,CAACtY,IAAI,CAAC;YAC9Ci3D,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEs2C,iBAAiB,CAACt2C,EAAE,CAAC0f,MAAM,EAAE62B,SAAS,EAAE7uD,IAAI,EAAEsY,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAACqoB,eAAe,EAAEroB,EAAE,CAACm1C,eAAe,EAAEn1C,EAAE,CAACo1C,6BAA6B,EAAEp1C,EAAE,CAACq1C,YAAY,EAAEr1C,EAAE,CAACs1C,WAAW,EAAEt1C,EAAE,CAAClK,UAAU,CAAC,CAAC;UAC5M;UACA;QACF,KAAKo9C,WAAW,CAACgJ,SAAS;UACxByC,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEm3C,wBAAwB,CAACn3C,EAAE,CAACtY,IAAI,EAAEsY,EAAE,CAAC0f,MAAM,EAAE1f,EAAE,CAACtY,IAAI,KAAK,eAAe,GAAG,OAAO,GAAG,OAAO,EAAEsY,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAACqoB,eAAe,EAAEroB,EAAE,CAAClK,UAAU,EAAE,CAAC,CAAC,CAAC;UACtK;QACF,KAAKo9C,WAAW,CAACrZ,QAAQ;QACzB,KAAKqZ,WAAW,CAAC/oB,eAAe;UAC9B,IAAI49B,GAAG,CAAC9B,IAAI,KAAKJ,uBAAuB,CAACoE,OAAO,IAAIH,eAAe,CAAC9pD,EAAE,CAACtY,IAAI,CAAC,EAAE;YAC5Ei3D,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEs2C,iBAAiB,CAACt2C,EAAE,CAAC0f,MAAM,EAAE,IAAI,EAAE1f,EAAE,CAACtY,IAAI,EAAEsY,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAACqoB,eAAe,EAAE,KAAK,EAAEroB,EAAE,CAACo1C,6BAA6B,EAAEp1C,EAAE,CAACq1C,YAAY,EAAEr1C,EAAE,CAACs1C,WAAW,EAAEt1C,EAAE,CAAClK,UAAU,CAAC,CAAC;UAC7L,CAAC,MAAM,IAAIiyD,GAAG,CAAC5mB,IAAI,KAAKykB,kBAAkB,CAACuC,IAAI,EAAE;YAC/CxJ,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAE0lD,mBAAmB,CAAC1lD,EAAE,CAACtY,IAAI,EAAEsY,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAACw1C,WAAW,EAAEx1C,EAAE,CAACy1C,WAAW,EAAEz1C,EAAE,CAACqoB,eAAe,EAAEroB,EAAE,CAAClK,UAAU,CAAC,CAAC;UACpI,CAAC,MAAM,IAAIkK,EAAE,CAACtY,IAAI,KAAK,OAAO,EAAE;YAC9Bi3D,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEq4C,eAAe,CAACr4C,EAAE,CAAC,CAAC;UACzC,CAAC,MAAM;YACL2+C,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAE01C,gBAAgB,CAAC11C,EAAE,CAAC0f,MAAM,EAAE1f,EAAE,CAACtY,IAAI,EAAEsY,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAACw1C,WAAW,EAAEx1C,EAAE,CAACqoB,eAAe,EAAEroB,EAAE,CAACo1C,6BAA6B,EAAEp1C,EAAE,CAACq1C,YAAY,EAAEr1C,EAAE,CAACy1C,WAAW,EAAEz1C,EAAE,CAACs1C,WAAW,EAAEt1C,EAAE,CAAClK,UAAU,CAAC,CAAC;UAC/M;UACA;QACF,KAAKo9C,WAAW,CAAC2C,cAAc;UAC7B,IAAI,EAAE71C,EAAE,CAACtR,UAAU,YAAYmH,UAAU,CAAC,EAAE;YAC1C,MAAM,IAAIzP,KAAK,CAAC,+CAA+C4Z,EAAE,CAACtY,IAAI,uBAAuB,CAAC;UAChG;UACAi3D,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAE41C,sBAAsB,CAAC51C,EAAE,CAAC0f,MAAM,EAAE1f,EAAE,CAACtY,IAAI,EAAEsY,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAACqoB,eAAe,EAAEroB,EAAE,CAACo1C,6BAA6B,EAAEp1C,EAAE,CAACq1C,YAAY,EAAEr1C,EAAE,CAACy1C,WAAW,EAAEz1C,EAAE,CAACs1C,WAAW,EAAEt1C,EAAE,CAAClK,UAAU,CAAC,CAAC;UACnM;QACF,KAAKo9C,WAAW,CAACyK,IAAI;QACrB,KAAKzK,WAAW,CAACgX,SAAS;QAC1B,KAAKhX,WAAW,CAACiX,aAAa;UAC5B,MAAM,IAAI/jE,KAAK,CAAC,6BAA6B8sD,WAAW,CAAClzC,EAAE,CAACw1C,WAAW,CAAC,EAAE,CAAC;MAC/E;IACF;EACF;AACF;AAEA,MAAM4U,mBAAmB,GAAG,IAAI9hE,GAAG,CAAC,CAAC,CAACwf,WAAW,CAACqG,YAAY,EAAErG,WAAW,CAACqG,YAAY,CAAC,EAAE,CAACrG,WAAW,CAACnhB,SAAS,EAAEmhB,WAAW,CAACnhB,SAAS,CAAC,EAAE,CAACmhB,WAAW,CAACoB,SAAS,EAAEpB,WAAW,CAACoB,SAAS,CAAC,EAAE,CAACpB,WAAW,CAAC5iB,OAAO,EAAE4iB,WAAW,CAAC5iB,OAAO,CAAC,EAAE,CAAC4iB,WAAW,CAACuB,gBAAgB,EAAEvB,WAAW,CAACuB,gBAAgB,CAAC,EAAE,CAACvB,WAAW,CAACsB,mBAAmB,EAAEtB,WAAW,CAACsB,mBAAmB,CAAC,EAAE,CAACtB,WAAW,CAACqB,qBAAqB,EAAErB,WAAW,CAACqB,qBAAqB,CAAC,EAAE,CAACrB,WAAW,CAACQ,UAAU,EAAER,WAAW,CAACQ,UAAU,CAAC,EAAE,CAACR,WAAW,CAACO,YAAY,EAAEP,WAAW,CAACO,YAAY,CAAC,EAAE,CAACP,WAAW,CAACoG,WAAW,EAAEpG,WAAW,CAACoG,WAAW,CAAC,EAAE,CAACpG,WAAW,CAAC+G,OAAO,EAAE/G,WAAW,CAAC+G,OAAO,CAAC,EAAE,CAAC/G,WAAW,CAACuL,QAAQ,EAAEvL,WAAW,CAACuL,QAAQ,CAAC,EAAE,CAACvL,WAAW,CAACuL,QAAQ,EAAEvL,WAAW,CAACuL,QAAQ,CAAC,EAAE,CAACvL,WAAW,CAACsG,QAAQ,EAAEtG,WAAW,CAACsG,QAAQ,CAAC,EAAE,CAACtG,WAAW,CAAC0B,SAAS,EAAE1B,WAAW,CAAC0B,SAAS,CAAC,EAAE,CAAC1B,WAAW,CAACmB,qBAAqB,EAAEnB,WAAW,CAACmB,qBAAqB,CAAC,EAAE,CAACnB,WAAW,CAACkB,qBAAqB,EAAElB,WAAW,CAACkB,qBAAqB,CAAC,EAAE,CAAClB,WAAW,CAACuC,cAAc,EAAEvC,WAAW,CAACuC,cAAc,CAAC,EAAE,CAACvC,WAAW,CAAC2K,cAAc,EAAE3K,WAAW,CAAC2K,cAAc,CAAC,EAAE,CAAC3K,WAAW,CAAC6K,cAAc,EAAE7K,WAAW,CAAC6K,cAAc,CAAC,EAAE,CAAC7K,WAAW,CAAC8K,UAAU,EAAE9K,WAAW,CAAC8K,UAAU,CAAC,EAAE,CAAC9K,WAAW,CAACgE,iBAAiB,EAAEhE,WAAW,CAACiE,uBAAuB,CAAC,EAAE,CAACjE,WAAW,CAACiE,uBAAuB,EAAEjE,WAAW,CAACiE,uBAAuB,CAAC,EAAE,CAACjE,WAAW,CAACS,UAAU,EAAET,WAAW,CAACS,UAAU,CAAC,EAAE,CAACT,WAAW,CAACU,eAAe,EAAEV,WAAW,CAACU,eAAe,CAAC,EAAE,CAACV,WAAW,CAACW,aAAa,EAAEX,WAAW,CAACW,aAAa,CAAC,EAAE,CAACX,WAAW,CAACY,mBAAmB,EAAEZ,WAAW,CAACY,mBAAmB,CAAC,EAAE,CAACZ,WAAW,CAACa,wBAAwB,EAAEb,WAAW,CAACa,wBAAwB,CAAC,EAAE,CAACb,WAAW,CAACc,sBAAsB,EAAEd,WAAW,CAACc,sBAAsB,CAAC,EAAE,CAACd,WAAW,CAACgB,WAAW,EAAEhB,WAAW,CAACgB,WAAW,CAAC,EAAE,CAAChB,WAAW,CAACe,WAAW,EAAEf,WAAW,CAACe,WAAW,CAAC,EAAE,CAACf,WAAW,CAAC2G,cAAc,EAAE3G,WAAW,CAAC2G,cAAc,CAAC,EAAE,CAAC3G,WAAW,CAAC4G,cAAc,EAAE5G,WAAW,CAAC4G,cAAc,CAAC,EAAE,CAAC5G,WAAW,CAACyG,sBAAsB,EAAEzG,WAAW,CAACyG,sBAAsB,CAAC,EAAE,CAACzG,WAAW,CAAC0G,sBAAsB,EAAE1G,WAAW,CAAC0G,sBAAsB,CAAC,CAAC,CAAC;AACviE,MAAM67C,gBAAgB,GAAG,GAAG;AAC5B,SAASC,KAAKA,CAACvC,GAAG,EAAE;EAClB,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5BoD,qBAAqB,CAACjiC,IAAI,CAACo/B,MAAM,CAAC;IAClC6C,qBAAqB,CAACjiC,IAAI,CAACq/B,MAAM,CAAC;EACpC;AACF;AACA,SAAS4C,qBAAqBA,CAACC,MAAM,EAAE;EACrC,IAAIF,KAAK,GAAG,IAAI;EAChB,KAAK,MAAMtqD,EAAE,IAAIwqD,MAAM,EAAE;IACvB,IAAIxqD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC7wC,SAAS,IAAI,EAAEhC,EAAE,CAACmkC,SAAS,YAAY3qC,mBAAmB,CAAC,EAAE;MAClF8wD,KAAK,GAAG,IAAI;MACZ;IACF;IACA,IAAI,EAAEtqD,EAAE,CAACmkC,SAAS,CAACnqC,IAAI,YAAY1D,kBAAkB,CAAC,IAAI,EAAE0J,EAAE,CAACmkC,SAAS,CAACnqC,IAAI,CAACO,EAAE,YAAYuD,YAAY,CAAC,EAAE;MACzGwsD,KAAK,GAAG,IAAI;MACZ;IACF;IACA,MAAMG,WAAW,GAAGzqD,EAAE,CAACmkC,SAAS,CAACnqC,IAAI,CAACO,EAAE,CAAC5S,KAAK;IAC9C,IAAI,CAACyiE,mBAAmB,CAACr/D,GAAG,CAAC0/D,WAAW,CAAC,EAAE;MACzCH,KAAK,GAAG,IAAI;MACZ;IACF;IACA,IAAIA,KAAK,KAAK,IAAI,IAAIF,mBAAmB,CAACzgE,GAAG,CAAC2gE,KAAK,CAACG,WAAW,CAAC,KAAKA,WAAW,IAAIH,KAAK,CAAC1kE,MAAM,GAAGykE,gBAAgB,EAAE;MACnH,MAAM37D,UAAU,GAAG47D,KAAK,CAAC57D,UAAU,CAACyH,MAAM,CAAC6J,EAAE,CAACmkC,SAAS,CAACnqC,IAAI,CAACQ,IAAI,EAAEwF,EAAE,CAACmkC,SAAS,CAACnqC,IAAI,CAAClE,UAAU,EAAEkK,EAAE,CAACmkC,SAAS,CAACnqC,IAAI,CAAC3D,IAAI,CAAC;MACxHi0D,KAAK,CAAC57D,UAAU,GAAGA,UAAU;MAC7B47D,KAAK,CAACtqD,EAAE,CAACmkC,SAAS,GAAGz1C,UAAU,CAAC6K,MAAM,CAAC,CAAC;MACxC+wD,KAAK,CAAC1kE,MAAM,EAAE;MACd+4D,MAAM,CAACiB,MAAM,CAAC5/C,EAAE,CAAC;IACnB,CAAC,MAAM;MACLsqD,KAAK,GAAG;QACNtqD,EAAE;QACFyqD,WAAW;QACX/7D,UAAU,EAAEsR,EAAE,CAACmkC,SAAS,CAACnqC,IAAI;QAC7BpU,MAAM,EAAE;MACV,CAAC;IACH;EACF;AACF;AAEA,SAAS8kE,+BAA+BA,CAAC3C,GAAG,EAAE;EAC5C,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACq/B,MAAM,EAAE;MAC5B,MAAMgD,cAAc,GAAG3qD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC2D,SAAS,IAAIx2C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACkD,SAAS,IAAI/1C,EAAE,CAACmhC,IAAI,IAAI0R,MAAM,CAACsD,QAAQ,IAAIn2C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACwD,QAAQ;MAChJ,IAAIsU,cAAc,IAAI3qD,EAAE,CAACtR,UAAU,YAAY41B,aAAa,IAAItkB,EAAE,CAACtR,UAAU,CAAC61B,OAAO,CAAC3+B,MAAM,KAAK,CAAC,IAAIoa,EAAE,CAACtR,UAAU,CAAC61B,OAAO,CAACzjB,KAAK,CAAC6U,CAAC,IAAIA,CAAC,KAAK,EAAE,CAAC,EAAE;QAChJ3V,EAAE,CAACtR,UAAU,GAAGsR,EAAE,CAACtR,UAAU,CAAC+M,WAAW,CAAC,CAAC,CAAC;MAC9C;IACF;EACF;AACF;AAEA,SAASmvD,8BAA8BA,CAAC7C,GAAG,EAAE;EAC3C,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAAC62B,GAAG,CAAC,CAAC,EAAE;MAC3B,IAAIn/C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC7vB,WAAW,EAAE;QAClC;MACF;MACA,IAAI/L,IAAI;MACR,MAAM4zC,WAAW,GAAG7qD,EAAE,CAAC42C,UAAU,CAACkU,SAAS,CAACC,IAAI,IAAIA,IAAI,CAAC/wD,IAAI,KAAK,IAAI,CAAC;MACvE,IAAI6wD,WAAW,IAAI,CAAC,EAAE;QACpB,MAAMvP,IAAI,GAAGt7C,EAAE,CAAC42C,UAAU,CAACoU,MAAM,CAACH,WAAW,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC7T,UAAU;QAC/D//B,IAAI,GAAG,IAAIokC,eAAe,CAACC,IAAI,CAAC;MAClC,CAAC,MAAM;QACLrkC,IAAI,GAAG3S,OAAO,CAAC,CAAC,CAAC,CAAC;MACpB;MACA,IAAI2mD,GAAG,GAAGjrD,EAAE,CAACiX,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,IAAIkkC,mBAAmB,CAACn7C,EAAE,CAACiX,IAAI,EAAE8wC,GAAG,CAAC5B,cAAc,CAAC,CAAC,CAAC;MACzF,IAAI+E,2BAA2B,GAAG,IAAI;MACtC,KAAK,IAAIlkE,CAAC,GAAGgZ,EAAE,CAAC42C,UAAU,CAAChxD,MAAM,GAAG,CAAC,EAAEoB,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;QAClD,IAAImkE,eAAe,GAAGnrD,EAAE,CAAC42C,UAAU,CAAC5vD,CAAC,CAAC;QACtC,IAAImkE,eAAe,CAACnxD,IAAI,KAAK,IAAI,EAAE;UACjC;QACF;QACA,IAAIixD,GAAG,KAAK,IAAI,EAAE;UAChB,MAAMG,MAAM,GAAGpkE,CAAC,KAAK,CAAC,GAAGikE,GAAG,GAAG,IAAI7P,iBAAiB,CAAC6P,GAAG,CAACvW,IAAI,CAAC;UAC9DyW,eAAe,CAACnxD,IAAI,GAAG,IAAIjD,kBAAkB,CAAC5B,cAAc,CAACiC,SAAS,EAAEg0D,MAAM,EAAED,eAAe,CAACnxD,IAAI,CAAC;QACvG,CAAC,MAAM,IAAImxD,eAAe,CAAC3P,KAAK,KAAK,IAAI,EAAE;UACzC0P,2BAA2B,KAAKnD,GAAG,CAAC5B,cAAc,CAAC,CAAC;UACpDgF,eAAe,CAACnxD,IAAI,GAAG,IAAImhD,mBAAmB,CAACgQ,eAAe,CAACnxD,IAAI,EAAEkxD,2BAA2B,CAAC;UACjGlrD,EAAE,CAAC82C,YAAY,GAAG,IAAIsE,iBAAiB,CAAC8P,2BAA2B,CAAC;QACtE;QACAj0C,IAAI,GAAG,IAAIrgB,eAAe,CAACu0D,eAAe,CAACnxD,IAAI,EAAE,IAAIqhD,eAAe,CAAC8P,eAAe,CAACnU,UAAU,CAAC,EAAE//B,IAAI,CAAC;MACzG;MACAjX,EAAE,CAAC62C,SAAS,GAAG5/B,IAAI;MACnBjX,EAAE,CAAC42C,UAAU,GAAG,EAAE;IACpB;EACF;AACF;AAEA,MAAMyU,gBAAgB,GAAG,IAAI/iE,GAAG,CAAC,CAAC,CAAC,IAAI,EAAE6M,cAAc,CAACiD,GAAG,CAAC,EAAE,CAAC,GAAG,EAAEjD,cAAc,CAAC6D,MAAM,CAAC,EAAE,CAAC,IAAI,EAAE7D,cAAc,CAAC+D,YAAY,CAAC,EAAE,CAAC,GAAG,EAAE/D,cAAc,CAACmD,SAAS,CAAC,EAAE,CAAC,GAAG,EAAEnD,cAAc,CAACqD,UAAU,CAAC,EAAE,CAAC,GAAG,EAAErD,cAAc,CAACyC,MAAM,CAAC,EAAE,CAAC,GAAG,EAAEzC,cAAc,CAAC2E,MAAM,CAAC,EAAE,CAAC,IAAI,EAAE3E,cAAc,CAAC6B,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE7B,cAAc,CAACiC,SAAS,CAAC,EAAE,CAAC,GAAG,EAAEjC,cAAc,CAACyD,KAAK,CAAC,EAAE,CAAC,IAAI,EAAEzD,cAAc,CAAC2D,WAAW,CAAC,EAAE,CAAC,GAAG,EAAE3D,cAAc,CAACqC,KAAK,CAAC,EAAE,CAAC,GAAG,EAAErC,cAAc,CAAC6C,MAAM,CAAC,EAAE,CAAC,IAAI,EAAE7C,cAAc,CAAC+C,cAAc,CAAC,EAAE,CAAC,GAAG,EAAE/C,cAAc,CAAC2C,QAAQ,CAAC,EAAE,CAAC,IAAI,EAAE3C,cAAc,CAAC+B,SAAS,CAAC,EAAE,CAAC,KAAK,EAAE/B,cAAc,CAACmC,YAAY,CAAC,EAAE,CAAC,IAAI,EAAEnC,cAAc,CAACmE,eAAe,CAAC,EAAE,CAAC,IAAI,EAAEnE,cAAc,CAACuD,EAAE,CAAC,EAAE,CAAC,GAAG,EAAEvD,cAAc,CAACuC,IAAI,CAAC,EAAE,CAAC,IAAI,EAAEvC,cAAc,CAAC8kB,EAAE,CAAC,EAAE,CAAC,IAAI,EAAE9kB,cAAc,CAAC8K,kBAAkB,CAAC,EAAE,CAAC,IAAI,EAAE9K,cAAc,CAAC+K,qBAAqB,CAAC,EAAE,CAAC,IAAI,EAAE/K,cAAc,CAACgL,wBAAwB,CAAC,EAAE,CAAC,IAAI,EAAEhL,cAAc,CAACiL,kBAAkB,CAAC,EAAE,CAAC,IAAI,EAAEjL,cAAc,CAACkL,mBAAmB,CAAC,EAAE,CAAC,KAAK,EAAElL,cAAc,CAACmL,wBAAwB,CAAC,EAAE,CAAC,KAAK,EAAEnL,cAAc,CAACoL,aAAa,CAAC,EAAE,CAAC,KAAK,EAAEpL,cAAc,CAACqL,YAAY,CAAC,EAAE,CAAC,KAAK,EAAErL,cAAc,CAACsL,yBAAyB,CAAC,CAAC,CAAC;AAC1lC,SAAS6qD,eAAeA,CAACC,kBAAkB,EAAE;EAC3C,MAAMC,UAAU,GAAG,IAAIljE,GAAG,CAAC,CAAC,CAAC,KAAK,EAAEgrD,SAAS,CAACmY,GAAG,CAAC,EAAE,CAAC,MAAM,EAAEnY,SAAS,CAACoY,IAAI,CAAC,CAAC,CAAC;EAC9E,IAAIH,kBAAkB,KAAK,IAAI,EAAE;IAC/B,OAAOjY,SAAS,CAACiO,IAAI;EACvB;EACA,OAAOiK,UAAU,CAAC7hE,GAAG,CAAC4hE,kBAAkB,CAAC,IAAIjY,SAAS,CAACiO,IAAI;AAC7D;AACA,SAASoK,eAAeA,CAACpV,SAAS,EAAE;EAClC,MAAMiV,UAAU,GAAG,IAAIljE,GAAG,CAAC,CAAC,CAAC,KAAK,EAAEgrD,SAAS,CAACmY,GAAG,CAAC,EAAE,CAAC,MAAM,EAAEnY,SAAS,CAACoY,IAAI,CAAC,CAAC,CAAC;EAC9E,KAAK,MAAM,CAACj9D,CAAC,EAAE2jC,CAAC,CAAC,IAAIo5B,UAAU,CAAC3qD,OAAO,CAAC,CAAC,EAAE;IACzC,IAAIuxB,CAAC,KAAKmkB,SAAS,EAAE;MACnB,OAAO9nD,CAAC;IACV;EACF;EACA,OAAO,IAAI;AACb;AACA,SAASm9D,mBAAmBA,CAACC,WAAW,EAAEtV,SAAS,EAAE;EACnD,IAAIA,SAAS,KAAKjD,SAAS,CAACiO,IAAI,EAAE;IAChC,OAAOsK,WAAW;EACpB;EACA,OAAO,IAAIF,eAAe,CAACpV,SAAS,CAAC,IAAIsV,WAAW,EAAE;AACxD;AACA,SAASC,qBAAqBA,CAACnkE,KAAK,EAAE;EACpC,IAAIwX,KAAK,CAACC,OAAO,CAACzX,KAAK,CAAC,EAAE;IACxB,OAAOic,UAAU,CAACjc,KAAK,CAACoC,GAAG,CAAC+hE,qBAAqB,CAAC,CAAC;EACrD;EACA,OAAOxnD,OAAO,CAAC3c,KAAK,CAAC;AACvB;AAEA,SAASokE,oBAAoBA,CAAChE,GAAG,EAAE;EACjC,MAAMiE,oBAAoB,GAAG,IAAI1jE,GAAG,CAAC,CAAC;EACtC,KAAK,MAAMggC,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC2J,kBAAkB,EAAE;QACzC,MAAMjyB,UAAU,GAAGyhC,oBAAoB,CAACriE,GAAG,CAACqW,EAAE,CAAC0f,MAAM,CAAC,IAAI,IAAIusC,iBAAiB,CAAClE,GAAG,CAAC/B,aAAa,CAAC;QAClGgG,oBAAoB,CAACpiE,GAAG,CAACoW,EAAE,CAAC0f,MAAM,EAAE6K,UAAU,CAAC;QAC/CA,UAAU,CAAC0e,GAAG,CAACjpC,EAAE,CAACw1C,WAAW,EAAEx1C,EAAE,CAACtY,IAAI,EAAEsY,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAACu2C,SAAS,EAAEv2C,EAAE,CAACy8C,cAAc,CAAC;QACvFkC,MAAM,CAACiB,MAAM,CAAC5/C,EAAE,CAAC;MACnB;IACF;EACF;EACA,IAAI+nD,GAAG,YAAY1B,uBAAuB,EAAE;IAC1C,KAAK,MAAM/9B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;MAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;QAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,IAAI0R,MAAM,CAACoL,UAAU,EAAE;UAChC,MAAM1zB,UAAU,GAAGyhC,oBAAoB,CAACriE,GAAG,CAACqW,EAAE,CAAC00C,IAAI,CAAC;UACpD,IAAInqB,UAAU,KAAK9U,SAAS,EAAE;YAC5B,MAAMy2C,SAAS,GAAGC,mBAAmB,CAAC5hC,UAAU,CAAC;YACjD,IAAI2hC,SAAS,CAACrrD,OAAO,CAACjb,MAAM,GAAG,CAAC,EAAE;cAChCoa,EAAE,CAACuqB,UAAU,GAAG2hC,SAAS;YAC3B;UACF;QACF,CAAC,MAAM,IAAI5L,sBAAsB,CAACtgD,EAAE,CAAC,EAAE;UACrCA,EAAE,CAACuqB,UAAU,GAAG6hC,aAAa,CAACrE,GAAG,EAAEiE,oBAAoB,EAAEhsD,EAAE,CAAC00C,IAAI,CAAC;UACjE,IAAI10C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC6J,cAAc,IAAI18C,EAAE,CAACkhD,SAAS,KAAK,IAAI,EAAE;YAC9DlhD,EAAE,CAACshD,eAAe,GAAG8K,aAAa,CAACrE,GAAG,EAAEiE,oBAAoB,EAAEhsD,EAAE,CAACkhD,SAAS,CAAC;UAC7E;QACF;MACF;IACF;EACF,CAAC,MAAM,IAAI6G,GAAG,YAAYE,yBAAyB,EAAE;IACnD,KAAK,MAAM,CAACvT,IAAI,EAAEnqB,UAAU,CAAC,IAAIyhC,oBAAoB,CAACnrD,OAAO,CAAC,CAAC,EAAE;MAC/D,IAAI6zC,IAAI,KAAKqT,GAAG,CAACtD,IAAI,CAAC/P,IAAI,EAAE;QAC1B,MAAM,IAAItuD,KAAK,CAAC,4HAA4H,CAAC;MAC/I;MACA,MAAM8lE,SAAS,GAAGC,mBAAmB,CAAC5hC,UAAU,CAAC;MACjD,IAAI2hC,SAAS,CAACrrD,OAAO,CAACjb,MAAM,GAAG,CAAC,EAAE;QAChCmiE,GAAG,CAACtD,IAAI,CAACl6B,UAAU,GAAG2hC,SAAS;MACjC;IACF;EACF;AACF;AACA,SAASE,aAAaA,CAACrE,GAAG,EAAEiE,oBAAoB,EAAEtX,IAAI,EAAE;EACtD,MAAMnqB,UAAU,GAAGyhC,oBAAoB,CAACriE,GAAG,CAAC+qD,IAAI,CAAC;EACjD,IAAInqB,UAAU,KAAK9U,SAAS,EAAE;IAC5B,MAAMy2C,SAAS,GAAGC,mBAAmB,CAAC5hC,UAAU,CAAC;IACjD,IAAI2hC,SAAS,CAACrrD,OAAO,CAACjb,MAAM,GAAG,CAAC,EAAE;MAChC,OAAOmiE,GAAG,CAACX,QAAQ,CAAC8E,SAAS,CAAC;IAChC;EACF;EACA,OAAO,IAAI;AACb;AACA,MAAMG,eAAe,GAAGjgE,MAAM,CAACC,MAAM,CAAC,EAAE,CAAC;AACzC,MAAM4/D,iBAAiB,CAAC;EACtBjG,aAAa;EACbsG,KAAK,GAAG,IAAIhkE,GAAG,CAAC,CAAC;EACjBikE,MAAM,GAAG,IAAIjkE,GAAG,CAAC,CAAC;EAClBkkE,gBAAgB,GAAG,IAAI;EACvBC,SAAS,GAAG,IAAI;EAChB,IAAIliC,UAAUA,CAAA,EAAG;IACf,OAAO,IAAI,CAACgiC,MAAM,CAAC5iE,GAAG,CAACupD,WAAW,CAACsD,SAAS,CAAC,IAAI6V,eAAe;EAClE;EACA,IAAIzgE,OAAOA,CAAA,EAAG;IACZ,OAAO,IAAI,CAAC2gE,MAAM,CAAC5iE,GAAG,CAACupD,WAAW,CAACgX,SAAS,CAAC,IAAImC,eAAe;EAClE;EACA,IAAIK,MAAMA,CAAA,EAAG;IACX,OAAO,IAAI,CAACH,MAAM,CAAC5iE,GAAG,CAACupD,WAAW,CAACiX,aAAa,CAAC,IAAIkC,eAAe;EACtE;EACA,IAAI97B,QAAQA,CAAA,EAAG;IACb,OAAO,IAAI,CAACi8B,gBAAgB,IAAIH,eAAe;EACjD;EACA,IAAIxxD,QAAQA,CAAA,EAAG;IACb,OAAO,IAAI,CAAC0xD,MAAM,CAAC5iE,GAAG,CAACupD,WAAW,CAAC3jB,QAAQ,CAAC,IAAI88B,eAAe;EACjE;EACA,IAAI19C,IAAIA,CAAA,EAAG;IACT,OAAO,IAAI,CAAC49C,MAAM,CAAC5iE,GAAG,CAACupD,WAAW,CAACyK,IAAI,CAAC,IAAI0O,eAAe;EAC7D;EACA3hE,WAAWA,CAACs7D,aAAa,EAAE;IACzB,IAAI,CAACA,aAAa,GAAGA,aAAa;EACpC;EACA2G,OAAOA,CAACxrB,IAAI,EAAEz5C,IAAI,EAAE;IAClB,MAAMklE,WAAW,GAAG,IAAI,CAACN,KAAK,CAAC3iE,GAAG,CAACw3C,IAAI,CAAC,IAAI,IAAI+F,GAAG,CAAC,CAAC;IACrD,IAAI,CAAColB,KAAK,CAAC1iE,GAAG,CAACu3C,IAAI,EAAEyrB,WAAW,CAAC;IACjC,IAAIA,WAAW,CAAC7hE,GAAG,CAACrD,IAAI,CAAC,EAAE;MACzB,OAAO,IAAI;IACb;IACAklE,WAAW,CAAC3jB,GAAG,CAACvhD,IAAI,CAAC;IACrB,OAAO,KAAK;EACd;EACAuhD,GAAGA,CAAC9H,IAAI,EAAEz5C,IAAI,EAAEC,KAAK,EAAE4uD,SAAS,EAAEkG,cAAc,EAAE;IAChD,MAAMoQ,eAAe,GAAG,IAAI,CAAC7G,aAAa,KAAK/S,iBAAiB,CAACsW,yBAAyB,KAAKpoB,IAAI,KAAK+R,WAAW,CAACsD,SAAS,IAAIrV,IAAI,KAAK+R,WAAW,CAACgX,SAAS,IAAI/oB,IAAI,KAAK+R,WAAW,CAACiX,aAAa,CAAC;IACtM,IAAI,CAAC0C,eAAe,IAAI,IAAI,CAACF,OAAO,CAACxrB,IAAI,EAAEz5C,IAAI,CAAC,EAAE;MAChD;IACF;IACA,IAAIA,IAAI,KAAK,aAAa,EAAE;MAC1B,IAAIC,KAAK,KAAK,IAAI,IAAI,EAAEA,KAAK,YAAY0T,WAAW,CAAC,IAAI1T,KAAK,CAACA,KAAK,IAAI,IAAI,IAAI,OAAOA,KAAK,CAACA,KAAK,EAAEE,QAAQ,CAAC,CAAC,KAAK,QAAQ,EAAE;QAC3H,MAAMzB,KAAK,CAAC,8CAA8C,CAAC;MAC7D;MACA,IAAI,CAACqmE,SAAS,GAAG9kE,KAAK,CAACA,KAAK,CAACE,QAAQ,CAAC,CAAC;IACzC;IACA,MAAMilE,KAAK,GAAG,IAAI,CAACC,QAAQ,CAAC5rB,IAAI,CAAC;IACjC2rB,KAAK,CAACjnE,IAAI,CAAC,GAAGmnE,wBAAwB,CAACzW,SAAS,EAAE7uD,IAAI,CAAC,CAAC;IACxD,IAAIy5C,IAAI,KAAK+R,WAAW,CAACsD,SAAS,IAAIrV,IAAI,KAAK+R,WAAW,CAACiX,aAAa,EAAE;MACxE,IAAIxiE,KAAK,KAAK,IAAI,EAAE;QAClB,MAAMvB,KAAK,CAAC,yEAAyE,CAAC;MACxF;MACA,IAAIq2D,cAAc,KAAK,IAAI,EAAE;QAC3B,IAAI,CAACiC,eAAe,CAAC/2D,KAAK,CAAC,EAAE;UAC3B,MAAMvB,KAAK,CAAC,oEAAoE,CAAC;QACnF;QACA0mE,KAAK,CAACjnE,IAAI,CAACwe,cAAc,CAACo4C,cAAc,EAAE,IAAIlhD,mBAAmB,CAAC,CAAC,IAAIK,0BAA0B,CAACjU,KAAK,CAACA,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE8tB,SAAS,EAAE9tB,KAAK,CAACmO,UAAU,CAAC,CAAC;MACrJ,CAAC,MAAM;QACLg3D,KAAK,CAACjnE,IAAI,CAAC8B,KAAK,CAAC;MACnB;IACF;EACF;EACAolE,QAAQA,CAAC5rB,IAAI,EAAE;IACb,IAAIA,IAAI,KAAK+R,WAAW,CAACrZ,QAAQ,IAAIsH,IAAI,KAAK+R,WAAW,CAAC2C,cAAc,EAAE;MACxE,IAAI,CAAC2W,gBAAgB,KAAK,EAAE;MAC5B,OAAO,IAAI,CAACA,gBAAgB;IAC9B,CAAC,MAAM;MACL,IAAI,CAAC,IAAI,CAACD,MAAM,CAACxhE,GAAG,CAACo2C,IAAI,CAAC,EAAE;QAC1B,IAAI,CAACorB,MAAM,CAAC3iE,GAAG,CAACu3C,IAAI,EAAE,EAAE,CAAC;MAC3B;MACA,OAAO,IAAI,CAACorB,MAAM,CAAC5iE,GAAG,CAACw3C,IAAI,CAAC;IAC9B;EACF;AACF;AACA,SAAS6rB,wBAAwBA,CAACzW,SAAS,EAAE7uD,IAAI,EAAE;EACjD,MAAMulE,WAAW,GAAG3oD,OAAO,CAAC5c,IAAI,CAAC;EACjC,IAAI6uD,SAAS,EAAE;IACb,OAAO,CAACjyC,OAAO,CAAC,CAAC,CAAC,EAAEA,OAAO,CAACiyC,SAAS,CAAC,EAAE0W,WAAW,CAAC;EACtD;EACA,OAAO,CAACA,WAAW,CAAC;AACtB;AACA,SAASd,mBAAmBA,CAAC;EAC3B5hC,UAAU;EACVgG,QAAQ;EACR3kC,OAAO;EACP+iB,IAAI;EACJ89C,SAAS;EACTC,MAAM;EACN7xD;AACF,CAAC,EAAE;EACD,MAAMqxD,SAAS,GAAG,CAAC,GAAG3hC,UAAU,CAAC;EACjC,IAAIkiC,SAAS,KAAK,IAAI,EAAE;IACtB,MAAMS,gBAAgB,GAAGhhE,yBAAyB,CAACugE,SAAS,CAAC,CAAC,CAAC,CAAC;IAChEP,SAAS,CAACrmE,IAAI,CAACye,OAAO,CAAC,CAAC,CAAC,EAAEwnD,qBAAqB,CAACoB,gBAAgB,CAAC,CAAC;EACrE;EACA,IAAIthE,OAAO,CAAChG,MAAM,GAAG,CAAC,EAAE;IACtBsmE,SAAS,CAACrmE,IAAI,CAACye,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG1Y,OAAO,CAAC;EACxC;EACA,IAAI8gE,MAAM,CAAC9mE,MAAM,GAAG,CAAC,EAAE;IACrBsmE,SAAS,CAACrmE,IAAI,CAACye,OAAO,CAAC,CAAC,CAAC,EAAE,GAAGooD,MAAM,CAAC;EACvC;EACA,IAAIn8B,QAAQ,CAAC3qC,MAAM,GAAG,CAAC,EAAE;IACvBsmE,SAAS,CAACrmE,IAAI,CAACye,OAAO,CAAC,CAAC,CAAC,EAAE,GAAGisB,QAAQ,CAAC;EACzC;EACA,IAAI11B,QAAQ,CAACjV,MAAM,GAAG,CAAC,EAAE;IACvBsmE,SAAS,CAACrmE,IAAI,CAACye,OAAO,CAAC,CAAC,CAAC,EAAE,GAAGzJ,QAAQ,CAAC;EACzC;EACA,IAAI8T,IAAI,CAAC/oB,MAAM,GAAG,CAAC,EAAE;IACnBsmE,SAAS,CAACrmE,IAAI,CAACye,OAAO,CAAC,CAAC,CAAC,EAAE,GAAGqK,IAAI,CAAC;EACrC;EACA,OAAO/K,UAAU,CAACsoD,SAAS,CAAC;AAC9B;AAEA,SAASiB,eAAeA,CAAC3xD,QAAQ,EAAEk5C,IAAI,EAAE;EACvC,MAAM/4C,EAAE,GAAGH,QAAQ,CAAC7R,GAAG,CAAC+qD,IAAI,CAAC;EAC7B,IAAI/4C,EAAE,KAAK8Z,SAAS,EAAE;IACpB,MAAM,IAAIrvB,KAAK,CAAC,oDAAoD,CAAC;EACvE;EACA,OAAOuV,EAAE;AACX;AACA,SAASyxD,iBAAiBA,CAACrF,GAAG,EAAE;EAC9B,MAAMvsD,QAAQ,GAAG,IAAIlT,GAAG,CAAC,CAAC;EAC1B,KAAK,MAAMggC,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI,CAACpH,sBAAsB,CAACtgD,EAAE,CAAC,EAAE;QAC/B;MACF;MACAxE,QAAQ,CAAC5R,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC;IAC3B;EACF;EACA,KAAK,MAAMsoB,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAAC62B,GAAG,CAAC,CAAC,EAAE;MAC3B,IAAIn/C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACyE,gBAAgB,EAAE;QACvC,MAAMyK,iBAAiB,GAAGsL,cAAc,CAACrtD,EAAE,CAAC;QAC5C,IAAI+nD,GAAG,CAAC5mB,IAAI,KAAKykB,kBAAkB,CAACuC,IAAI,EAAE;UACxC7/B,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAACk8D,iBAAiB,CAAC;QACrC,CAAC,MAAM;UACLpD,MAAM,CAACuB,WAAW,CAAC6B,iBAAiB,EAAEoL,eAAe,CAAC3xD,QAAQ,EAAEwE,EAAE,CAAC0f,MAAM,CAAC,CAAC;QAC7E;QACAi/B,MAAM,CAACiB,MAAM,CAAC5/C,EAAE,CAAC;MACnB;IACF;EACF;AACF;AACA,SAASqtD,cAAcA,CAACrtD,EAAE,EAAE;EAC1B,IAAIA,EAAE,CAACq3C,oBAAoB,KAAK,CAAC,EAAE;IACjC,OAAOyK,uBAAuB,CAAC9hD,EAAE,CAACtY,IAAI,EAAEsY,EAAE,CAAC0f,MAAM,EAAE1f,EAAE,CAACtY,IAAI,KAAK,eAAe,GAAG,OAAO,GAAG,OAAO,EAAEsY,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAACqoB,eAAe,EAAEroB,EAAE,CAAClK,UAAU,CAAC;EACvJ,CAAC,MAAM;IACL,MAAMpH,UAAU,GAAGsR,EAAE,CAACtR,UAAU;IAChC,OAAOqzD,iBAAiB,CAAC/hD,EAAE,CAACtY,IAAI,EAAEsY,EAAE,CAAC0f,MAAM,EAAE1f,EAAE,CAACtY,IAAI,KAAK,eAAe,GAAG,OAAO,GAAG,OAAO,EAAE,CAAC6sD,iBAAiB,CAAC,IAAI9xC,eAAe,CAAC/T,UAAU,EAAEA,UAAU,CAACoH,UAAU,CAAC,CAAC,CAAC,EAAEkK,EAAE,CAACqoB,eAAe,EAAEroB,EAAE,CAAClK,UAAU,CAAC;EAC/M;AACF;AAEA,SAASw3D,mBAAmBA,CAACvF,GAAG,EAAE;EAChC,MAAMwF,oBAAoB,GAAG,IAAIjlE,GAAG,CAAC,CAAC;EACtC,KAAK,MAAMggC,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACsL,cAAc,EAAE;QACrCoP,oBAAoB,CAAC3jE,GAAG,CAACoW,EAAE,CAAC0f,MAAM,EAAE1f,EAAE,CAAC;MACzC;IACF;IACA,KAAK,MAAMA,EAAE,IAAIsoB,IAAI,CAACq/B,MAAM,EAAE;MAC5B,QAAQ3nD,EAAE,CAACmhC,IAAI;QACb,KAAK0R,MAAM,CAAChZ,QAAQ;QACpB,KAAKgZ,MAAM,CAAC2D,SAAS;UACnB,IAAIx2C,EAAE,CAACy1C,WAAW,KAAK,IAAI,EAAE;YAC3B;UACF;UACA,IAAI,EAAEz1C,EAAE,CAACtR,UAAU,YAAY41B,aAAa,CAAC,EAAE;YAC7C;UACF;UACA,MAAMkpC,qBAAqB,GAAGD,oBAAoB,CAAC5jE,GAAG,CAACqW,EAAE,CAAC0f,MAAM,CAAC;UACjE,IAAI8tC,qBAAqB,KAAK/3C,SAAS,EAAE;YACvC,MAAM,IAAIrvB,KAAK,CAAC,gIAAgI,CAAC;UACnJ;UACA,IAAIonE,qBAAqB,CAAC9tC,MAAM,KAAK1f,EAAE,CAAC0f,MAAM,EAAE;YAC9C,MAAM,IAAIt5B,KAAK,CAAC,wFAAwF,CAAC;UAC3G;UACA,MAAM+4D,GAAG,GAAG,EAAE;UACd,KAAK,IAAIn4D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgZ,EAAE,CAACtR,UAAU,CAAC+M,WAAW,CAAC7V,MAAM,EAAEoB,CAAC,EAAE,EAAE;YACzD,MAAMgT,IAAI,GAAGgG,EAAE,CAACtR,UAAU,CAAC+M,WAAW,CAACzU,CAAC,CAAC;YACzC,IAAIgZ,EAAE,CAACtR,UAAU,CAACumD,gBAAgB,CAACrvD,MAAM,KAAKoa,EAAE,CAACtR,UAAU,CAAC+M,WAAW,CAAC7V,MAAM,EAAE;cAC9E,MAAM,IAAIQ,KAAK,CAAC,6HAA6H4Z,EAAE,CAACtR,UAAU,CAACumD,gBAAgB,CAACrvD,MAAM,qBAAqBoa,EAAE,CAACtR,UAAU,CAAC+M,WAAW,CAAC7V,MAAM,cAAc,CAAC;YACxP;YACAu5D,GAAG,CAACt5D,IAAI,CAAC4xD,sBAAsB,CAACz3C,EAAE,CAACy1C,WAAW,EAAE+X,qBAAqB,CAAC9tC,MAAM,EAAE8tC,qBAAqB,CAAC9Y,IAAI,EAAE8Y,qBAAqB,CAAC7V,MAAM,EAAE39C,IAAI,EAAE,IAAI,EAAEgG,EAAE,CAACtR,UAAU,CAACumD,gBAAgB,CAACjuD,CAAC,CAAC,EAAEmsD,uBAAuB,CAACsa,QAAQ,EAAEra,iBAAiB,CAACsa,aAAa,EAAE1tD,EAAE,CAACtY,IAAI,EAAEsY,EAAE,CAAClK,UAAU,CAAC,CAAC;UACpR;UACA6oD,MAAM,CAACe,eAAe,CAAC1/C,EAAE,EAAEm/C,GAAG,CAAC;UAC/B;MACJ;IACF;EACF;AACF;AAEA,SAASwO,kBAAkBA,CAAC5F,GAAG,EAAE;EAC/B,MAAM6F,oBAAoB,GAAG,IAAItlE,GAAG,CAAC,CAAC;EACtC,KAAK,MAAMggC,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAAC62B,GAAG,CAAC,CAAC,EAAE;MAC3B,QAAQn/C,EAAE,CAACmhC,IAAI;QACb,KAAK0R,MAAM,CAAC0C,OAAO;QACnB,KAAK1C,MAAM,CAAChZ,QAAQ;QACpB,KAAKgZ,MAAM,CAAC2D,SAAS;QACrB,KAAK3D,MAAM,CAAC2J,kBAAkB;UAC5B,IAAIx8C,EAAE,CAACs1C,WAAW,KAAK,IAAI,EAAE;YAC3B;UACF;UACA,IAAI,CAACsY,oBAAoB,CAAC7iE,GAAG,CAACiV,EAAE,CAACs1C,WAAW,CAAC,EAAE;YAC7C,MAAMG,WAAW,GAAGwP,mBAAmB,CAACzR,eAAe,CAAC2R,IAAI,EAAE4C,GAAG,CAAC5B,cAAc,CAAC,CAAC,EAAE,IAAI,EAAEnmD,EAAE,CAACs1C,WAAW,EAAE,IAAI,CAAC;YAC/GhtB,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAAC4vD,WAAW,CAAC;YAC7BmY,oBAAoB,CAAChkE,GAAG,CAACoW,EAAE,CAACs1C,WAAW,EAAEG,WAAW,CAACf,IAAI,CAAC;UAC5D;UACA10C,EAAE,CAACy1C,WAAW,GAAGmY,oBAAoB,CAACjkE,GAAG,CAACqW,EAAE,CAACs1C,WAAW,CAAC;UACzD;MACJ;IACF;EACF;EACA,MAAMuY,uBAAuB,GAAG,IAAIvlE,GAAG,CAAC,CAAC;EACzC,KAAK,MAAMggC,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,QAAQ1nD,EAAE,CAACmhC,IAAI;QACb,KAAK0R,MAAM,CAACiL,SAAS;UACnB,IAAI99C,EAAE,CAAC00C,IAAI,KAAK10C,EAAE,CAACykD,IAAI,EAAE;YACvB,MAAMqJ,SAAS,GAAG7I,mBAAmB,CAACzR,eAAe,CAACua,QAAQ,EAAEhG,GAAG,CAAC5B,cAAc,CAAC,CAAC,EAAEnmD,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAACnT,OAAO,EAAE,IAAI,CAAC;YAChHy7B,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAACioE,SAAS,CAAC;YAC3B9tD,EAAE,CAACjS,OAAO,GAAG+/D,SAAS,CAACpZ,IAAI;YAC3BmZ,uBAAuB,CAACjkE,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAEoZ,SAAS,CAAC;UACjD;UACA;MACJ;IACF;EACF;EACA,KAAK,MAAMxlC,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACiL,SAAS,IAAI99C,EAAE,CAAC00C,IAAI,KAAK10C,EAAE,CAACykD,IAAI,EAAE;QACvD,MAAMuJ,WAAW,GAAGH,uBAAuB,CAAClkE,GAAG,CAACqW,EAAE,CAACykD,IAAI,CAAC;QACxD,IAAIuJ,WAAW,KAAKv4C,SAAS,EAAE;UAC7B,MAAMrvB,KAAK,CAAC,wEAAwE,CAAC;QACvF;QACA4Z,EAAE,CAACjS,OAAO,GAAGigE,WAAW,CAACtZ,IAAI;QAC7BmZ,uBAAuB,CAACjkE,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAEsZ,WAAW,CAAC;MACnD;IACF;EACF;EACA,IAAIC,aAAa,GAAG,IAAI;EACxB,KAAK,MAAM3lC,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,QAAQ1nD,EAAE,CAACmhC,IAAI;QACb,KAAK0R,MAAM,CAACiL,SAAS;UACnBmQ,aAAa,GAAGjuD,EAAE;UAClB;QACF,KAAK6yC,MAAM,CAACgL,OAAO;UACjBoQ,aAAa,GAAG,IAAI;UACpB;QACF,KAAKpb,MAAM,CAACmL,QAAQ;UAClB,IAAIiQ,aAAa,KAAK,IAAI,EAAE;YAC1B,MAAM7nE,KAAK,CAAC,0DAA0D,CAAC;UACzE;UACA,IAAI4Z,EAAE,CAACnT,OAAO,CAACC,EAAE,KAAKmhE,aAAa,CAACphE,OAAO,CAACC,EAAE,EAAE;YAC9C,MAAMghE,SAAS,GAAG7I,mBAAmB,CAACzR,eAAe,CAACtjB,GAAG,EAAE63B,GAAG,CAAC5B,cAAc,CAAC,CAAC,EAAE8H,aAAa,CAACxJ,IAAI,EAAEzkD,EAAE,CAACnT,OAAO,EAAE,IAAI,CAAC;YACtHy7B,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAACioE,SAAS,CAAC;YAC3B9tD,EAAE,CAACjS,OAAO,GAAG+/D,SAAS,CAACpZ,IAAI;UAC7B,CAAC,MAAM;YACL10C,EAAE,CAACjS,OAAO,GAAGkgE,aAAa,CAAClgE,OAAO;YAClC8/D,uBAAuB,CAAClkE,GAAG,CAACskE,aAAa,CAACvZ,IAAI,CAAC,CAACwQ,WAAW,GAAG1R,eAAe,CAACtjB,GAAG;UACnF;UACA;MACJ;IACF;EACF;AACF;AAEA,SAASg+B,uBAAuBA,CAACnG,GAAG,EAAE;EACpC,MAAMoG,IAAI,GAAG,IAAI7lE,GAAG,CAAC,CAAC;EACtB,KAAK,MAAMggC,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACq/B,MAAM,CAACpI,QAAQ,CAAC,CAAC,EAAE;MACvC,IAAIv/C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC0C,OAAO,IAAIv1C,EAAE,CAACm1C,eAAe,EAAE;QACpD,MAAMiZ,cAAc,GAAGD,IAAI,CAACxkE,GAAG,CAACqW,EAAE,CAAC0f,MAAM,CAAC,IAAI,IAAIwnB,GAAG,CAAC,CAAC;QACvD,IAAIknB,cAAc,CAACrjE,GAAG,CAACiV,EAAE,CAACtY,IAAI,CAAC,EAAE;UAC/B,IAAIqgE,GAAG,CAAC/B,aAAa,KAAK/S,iBAAiB,CAACsW,yBAAyB,EAAE;YACrE,IAAIvpD,EAAE,CAACtY,IAAI,KAAK,OAAO,IAAIsY,EAAE,CAACtY,IAAI,KAAK,OAAO,EAAE;cAC9Ci3D,MAAM,CAACiB,MAAM,CAAC5/C,EAAE,CAAC;YACnB;UACF;QACF;QACAouD,cAAc,CAACnlB,GAAG,CAACjpC,EAAE,CAACtY,IAAI,CAAC;QAC3BymE,IAAI,CAACvkE,GAAG,CAACoW,EAAE,CAAC0f,MAAM,EAAE0uC,cAAc,CAAC;MACrC;IACF;EACF;AACF;AAEA,SAASC,0BAA0BA,CAACtG,GAAG,EAAE;EACvC,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACiK,KAAK,EAAE;QAC5B;MACF;MACA,IAAI98C,EAAE,CAAC8jD,sBAAsB,KAAK,IAAI,EAAE;QACtC9jD,EAAE,CAACg9C,iBAAiB,GAAG,IAAItB,kBAAkB,CAACoQ,qBAAqB,CAAC,CAAC9rD,EAAE,CAAC8jD,sBAAsB,CAAC,CAAC,CAAC;MACnG;MACA,IAAI9jD,EAAE,CAAC0jD,kBAAkB,KAAK,IAAI,IAAI1jD,EAAE,CAAC2jD,gBAAgB,KAAK,IAAI,EAAE;QAClE3jD,EAAE,CAAC+8C,aAAa,GAAG,IAAIrB,kBAAkB,CAACoQ,qBAAqB,CAAC,CAAC9rD,EAAE,CAAC0jD,kBAAkB,EAAE1jD,EAAE,CAAC2jD,gBAAgB,CAAC,CAAC,CAAC;MAChH;IACF;EACF;AACF;AAEA,SAAS2K,uBAAuBA,CAACvG,GAAG,EAAE;EACpC,MAAMwG,MAAM,GAAG,IAAIjmE,GAAG,CAAC,CAAC;EACxB,SAASkmE,eAAeA,CAACn9D,IAAI,EAAE;IAC7B,IAAIk9D,MAAM,CAACxjE,GAAG,CAACsG,IAAI,CAACqjD,IAAI,CAAC,EAAE;MACzB,OAAO6Z,MAAM,CAAC5kE,GAAG,CAAC0H,IAAI,CAACqjD,IAAI,CAAC;IAC9B;IACA,MAAM+Z,KAAK,GAAG,IAAIC,OAAO,CAAC,CAAC;IAC3B,KAAK,MAAM1uD,EAAE,IAAI3O,IAAI,CAACq2D,MAAM,EAAE;MAC5B,IAAI,CAACpH,sBAAsB,CAACtgD,EAAE,CAAC,IAAIA,EAAE,CAACygD,SAAS,KAAK,IAAI,EAAE;QACxD;MACF;MACA,IAAI,CAACthD,KAAK,CAACC,OAAO,CAACY,EAAE,CAACygD,SAAS,CAAC,EAAE;QAChC,MAAM,IAAIr6D,KAAK,CAAC,6EAA6E,CAAC;MAChG;MACA,KAAK,MAAMw4B,GAAG,IAAI5e,EAAE,CAACygD,SAAS,EAAE;QAC9B,IAAI7hC,GAAG,CAACc,MAAM,KAAK,EAAE,EAAE;UACrB;QACF;QACA+uC,KAAK,CAACE,OAAO,CAAC/kE,GAAG,CAACg1B,GAAG,CAACl3B,IAAI,EAAE;UAC1BgtD,IAAI,EAAE10C,EAAE,CAAC00C,IAAI;UACb4G,IAAI,EAAEt7C,EAAE,CAAC23C;QACX,CAAC,CAAC;MACJ;IACF;IACA4W,MAAM,CAAC3kE,GAAG,CAACyH,IAAI,CAACqjD,IAAI,EAAE+Z,KAAK,CAAC;IAC5B,OAAOA,KAAK;EACd;EACA,SAASG,cAAcA,CAACC,cAAc,EAAE7uD,EAAE,EAAE4jD,eAAe,EAAE;IAC3D,QAAQ5jD,EAAE,CAACgxB,OAAO,CAACmQ,IAAI;MACrB,KAAKoS,gBAAgB,CAACub,IAAI;MAC1B,KAAKvb,gBAAgB,CAACwb,KAAK;MAC3B,KAAKxb,gBAAgB,CAACyb,SAAS;MAC/B,KAAKzb,gBAAgB,CAAC0b,KAAK;QACzB;MACF,KAAK1b,gBAAgB,CAAC2b,KAAK;MAC3B,KAAK3b,gBAAgB,CAAC4b,WAAW;MACjC,KAAK5b,gBAAgB,CAAC6b,QAAQ;QAC5B,IAAIpvD,EAAE,CAACgxB,OAAO,CAACq+B,UAAU,KAAK,IAAI,EAAE;UAClC,IAAIzL,eAAe,KAAK,IAAI,EAAE;YAC5B,MAAM,IAAIx9D,KAAK,CAAC,oEAAoE,CAAC;UACvF;UACA,MAAMkX,WAAW,GAAGyqD,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACi6D,eAAe,CAAC;UAClD,IAAItmD,WAAW,IAAImY,SAAS,EAAE;YAC5B,MAAM,IAAIrvB,KAAK,CAAC,sEAAsE,CAAC;UACzF;UACA,KAAK,MAAMkpE,aAAa,IAAIhyD,WAAW,CAACoqD,MAAM,EAAE;YAC9C,IAAIvT,oBAAoB,CAACmb,aAAa,CAAC,KAAKhP,sBAAsB,CAACgP,aAAa,CAAC,IAAIA,aAAa,CAACnuB,IAAI,KAAK0R,MAAM,CAACoL,UAAU,CAAC,EAAE;cAC9Hj+C,EAAE,CAACgxB,OAAO,CAACu+B,UAAU,GAAGD,aAAa,CAAC5a,IAAI;cAC1C10C,EAAE,CAACgxB,OAAO,CAACw+B,UAAU,GAAG5L,eAAe;cACvC5jD,EAAE,CAACgxB,OAAO,CAACy+B,mBAAmB,GAAG,CAAC,CAAC;cACnCzvD,EAAE,CAACgxB,OAAO,CAACgmB,UAAU,GAAGsY,aAAa,CAAC3X,MAAM;cAC5C;YACF;UACF;UACA;QACF;QACA,IAAItmD,IAAI,GAAGuyD,eAAe,KAAK,IAAI,GAAGmE,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACi6D,eAAe,CAAC,GAAGiL,cAAc;QACrF,IAAIa,IAAI,GAAG9L,eAAe,KAAK,IAAI,GAAG,CAAC,CAAC,GAAG,CAAC;QAC5C,OAAOvyD,IAAI,KAAK,IAAI,EAAE;UACpB,MAAMo9D,KAAK,GAAGD,eAAe,CAACn9D,IAAI,CAAC;UACnC,IAAIo9D,KAAK,CAACE,OAAO,CAAC5jE,GAAG,CAACiV,EAAE,CAACgxB,OAAO,CAACq+B,UAAU,CAAC,EAAE;YAC5C,MAAM;cACJ3a,IAAI;cACJ4G;YACF,CAAC,GAAGmT,KAAK,CAACE,OAAO,CAAChlE,GAAG,CAACqW,EAAE,CAACgxB,OAAO,CAACq+B,UAAU,CAAC;YAC5CrvD,EAAE,CAACgxB,OAAO,CAACu+B,UAAU,GAAG7a,IAAI;YAC5B10C,EAAE,CAACgxB,OAAO,CAACw+B,UAAU,GAAGn+D,IAAI,CAACqjD,IAAI;YACjC10C,EAAE,CAACgxB,OAAO,CAACy+B,mBAAmB,GAAGC,IAAI;YACrC1vD,EAAE,CAACgxB,OAAO,CAACgmB,UAAU,GAAGsE,IAAI;YAC5B;UACF;UACAjqD,IAAI,GAAGA,IAAI,CAAC61D,MAAM,KAAK,IAAI,GAAGa,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAAC0H,IAAI,CAAC61D,MAAM,CAAC,GAAG,IAAI;UAC/DwI,IAAI,EAAE;QACR;QACA;MACF;QACE,MAAM,IAAItpE,KAAK,CAAC,gBAAgB4Z,EAAE,CAACgxB,OAAO,CAACmQ,IAAI,cAAc,CAAC;IAClE;EACF;EACA,KAAK,MAAM7Y,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,MAAMwI,MAAM,GAAG,IAAIrnE,GAAG,CAAC,CAAC;IACxB,KAAK,MAAM0X,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,QAAQ1nD,EAAE,CAACmhC,IAAI;QACb,KAAK0R,MAAM,CAACiK,KAAK;UACf6S,MAAM,CAAC/lE,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC;UACvB;QACF,KAAK6yC,MAAM,CAACyK,OAAO;UACjB,MAAMsS,OAAO,GAAGD,MAAM,CAAChmE,GAAG,CAACqW,EAAE,CAACsK,KAAK,CAAC;UACpCskD,cAAc,CAACtmC,IAAI,EAAEtoB,EAAE,EAAEA,EAAE,CAAC5M,QAAQ,KAAK,SAAS,GAAGw8D,OAAO,CAACrM,QAAQ,GAAGqM,OAAO,CAAChM,eAAe,CAAC;UAChG;MACJ;IACF;EACF;AACF;AACA,IAAI8K,OAAO,GAAG,MAAMmB,KAAK,CAAC;EACxBlB,OAAO,GAAG,IAAIrmE,GAAG,CAAC,CAAC;AACrB,CAAC;AAED,MAAMwnE,YAAY,GAAG,IAAIxnE,GAAG,CAAC,CAAC,CAACuqD,MAAM,CAAC2K,UAAU,EAAE,CAAC3K,MAAM,CAAC4K,YAAY,EAAE5K,MAAM,CAACvoB,OAAO,CAAC,CAAC,EAAE,CAACuoB,MAAM,CAACuK,YAAY,EAAE,CAACvK,MAAM,CAACwK,cAAc,EAAExK,MAAM,CAACjhB,SAAS,CAAC,CAAC,EAAE,CAACihB,MAAM,CAACgL,OAAO,EAAE,CAAChL,MAAM,CAACiL,SAAS,EAAEjL,MAAM,CAAC8K,IAAI,CAAC,CAAC,CAAC,CAAC;AAC/M,MAAMoS,gBAAgB,GAAG,IAAI7oB,GAAG,CAAC,CAAC2L,MAAM,CAACxxB,IAAI,CAAC,CAAC;AAC/C,SAAS2uC,yBAAyBA,CAACjI,GAAG,EAAE;EACtC,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,MAAMuI,cAAc,GAAGH,YAAY,CAACnmE,GAAG,CAACqW,EAAE,CAACmhC,IAAI,CAAC;MAChD,IAAI8uB,cAAc,KAAKx6C,SAAS,EAAE;QAChC;MACF;MACA,MAAM,CAACy6C,SAAS,EAAEC,UAAU,CAAC,GAAGF,cAAc;MAC9C,IAAIG,MAAM,GAAGpwD,EAAE,CAACkrC,IAAI;MACpB,OAAOklB,MAAM,KAAK,IAAI,IAAIL,gBAAgB,CAAChlE,GAAG,CAACqlE,MAAM,CAACjvB,IAAI,CAAC,EAAE;QAC3DivB,MAAM,GAAGA,MAAM,CAACllB,IAAI;MACtB;MACA,IAAIklB,MAAM,KAAK,IAAI,IAAIA,MAAM,CAACjvB,IAAI,KAAK+uB,SAAS,EAAE;QAChDE,MAAM,CAACjvB,IAAI,GAAGgvB,UAAU;QACxBxR,MAAM,CAACiB,MAAM,CAAC5/C,EAAE,CAAC;MACnB;IACF;EACF;AACF;AAEA,SAASqwD,eAAeA,CAACtI,GAAG,EAAE;EAC5B,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAAC62B,GAAG,CAAC,CAAC,EAAE;MAC3BtD,wBAAwB,CAAC77C,EAAE,EAAE7P,CAAC,IAAImgE,aAAa,CAACngE,CAAC,EAAE;QACjD43D;MACF,CAAC,CAAC,EAAEzN,kBAAkB,CAACpnD,IAAI,CAAC;MAC5B2oD,wBAAwB,CAAC77C,EAAE,EAAEuwD,gBAAgB,EAAEjW,kBAAkB,CAACpnD,IAAI,CAAC;IACzE;EACF;AACF;AACA,SAASs9D,0BAA0BA,CAACrgE,CAAC,EAAE;EACrC,IAAIA,CAAC,YAAYoP,iBAAiB,EAAE;IAClC,OAAOixD,0BAA0B,CAACrgE,CAAC,CAAC6J,IAAI,CAAC;EAC3C,CAAC,MAAM,IAAI7J,CAAC,YAAY4G,kBAAkB,EAAE;IAC1C,OAAOy5D,0BAA0B,CAACrgE,CAAC,CAAC0P,GAAG,CAAC,IAAI2wD,0BAA0B,CAACrgE,CAAC,CAAC2G,GAAG,CAAC;EAC/E,CAAC,MAAM,IAAI3G,CAAC,YAAYyG,eAAe,EAAE;IACvC,IAAIzG,CAAC,CAACwG,SAAS,IAAI65D,0BAA0B,CAACrgE,CAAC,CAACwG,SAAS,CAAC,EAAE,OAAO,IAAI;IACvE,OAAO65D,0BAA0B,CAACrgE,CAAC,CAAC+N,SAAS,CAAC,IAAIsyD,0BAA0B,CAACrgE,CAAC,CAACuG,QAAQ,CAAC;EAC1F,CAAC,MAAM,IAAIvG,CAAC,YAAYqO,OAAO,EAAE;IAC/B,OAAOgyD,0BAA0B,CAACrgE,CAAC,CAAC+N,SAAS,CAAC;EAChD,CAAC,MAAM,IAAI/N,CAAC,YAAYgrD,mBAAmB,EAAE;IAC3C,OAAOqV,0BAA0B,CAACrgE,CAAC,CAAC6J,IAAI,CAAC;EAC3C,CAAC,MAAM,IAAI7J,CAAC,YAAY6F,YAAY,EAAE;IACpC,OAAOw6D,0BAA0B,CAACrgE,CAAC,CAACsK,QAAQ,CAAC;EAC/C,CAAC,MAAM,IAAItK,CAAC,YAAY+F,WAAW,EAAE;IACnC,OAAOs6D,0BAA0B,CAACrgE,CAAC,CAACsK,QAAQ,CAAC,IAAI+1D,0BAA0B,CAACrgE,CAAC,CAACgB,KAAK,CAAC;EACtF,CAAC,MAAM,IAAIhB,CAAC,YAAYwP,iBAAiB,EAAE;IACzC,OAAO6wD,0BAA0B,CAACrgE,CAAC,CAAC6J,IAAI,CAAC;EAC3C;EACA,OAAO7J,CAAC,YAAYmG,kBAAkB,IAAInG,CAAC,YAAYyQ,gBAAgB,IAAIzQ,CAAC,YAAY+Q,cAAc,IAAI/Q,CAAC,YAAY6qD,sBAAsB,IAAI7qD,CAAC,YAAYsqD,eAAe;AAC/K;AACA,SAASgW,aAAaA,CAACtgE,CAAC,EAAE;EACxB,MAAMugE,WAAW,GAAG,IAAIxpB,GAAG,CAAC,CAAC;EAC7B6R,gCAAgC,CAAC5oD,CAAC,EAAEA,CAAC,IAAI;IACvC,IAAIA,CAAC,YAAYgrD,mBAAmB,EAAE;MACpCuV,WAAW,CAACznB,GAAG,CAAC94C,CAAC,CAACukD,IAAI,CAAC;IACzB;IACA,OAAOvkD,CAAC;EACV,CAAC,EAAEmqD,kBAAkB,CAACpnD,IAAI,CAAC;EAC3B,OAAOw9D,WAAW;AACpB;AACA,SAASC,6BAA6BA,CAACxgE,CAAC,EAAEygE,IAAI,EAAE/zC,GAAG,EAAE;EACnDk8B,gCAAgC,CAAC5oD,CAAC,EAAEA,CAAC,IAAI;IACvC,IAAIA,CAAC,YAAYgrD,mBAAmB,IAAIyV,IAAI,CAAC7lE,GAAG,CAACoF,CAAC,CAACukD,IAAI,CAAC,EAAE;MACxD,MAAMmc,IAAI,GAAG,IAAIzV,iBAAiB,CAACjrD,CAAC,CAACukD,IAAI,CAAC;MAC1C,OAAO73B,GAAG,CAACkrC,GAAG,CAAC/B,aAAa,KAAK/S,iBAAiB,CAACsW,yBAAyB,GAAG,IAAIpO,mBAAmB,CAAC0V,IAAI,EAAEA,IAAI,CAACnc,IAAI,CAAC,GAAGmc,IAAI;IAChI;IACA,OAAO1gE,CAAC;EACV,CAAC,EAAEmqD,kBAAkB,CAACpnD,IAAI,CAAC;EAC3B,OAAO/C,CAAC;AACV;AACA,SAAS2gE,wBAAwBA,CAAC3yC,KAAK,EAAEjjB,IAAI,EAAE2hB,GAAG,EAAE;EAClD,IAAI/1B,MAAM;EACV,IAAI0pE,0BAA0B,CAACryC,KAAK,CAAC,EAAE;IACrC,MAAMu2B,IAAI,GAAG73B,GAAG,CAACkrC,GAAG,CAAC5B,cAAc,CAAC,CAAC;IACrCr/D,MAAM,GAAG,CAAC,IAAIq0D,mBAAmB,CAACh9B,KAAK,EAAEu2B,IAAI,CAAC,EAAE,IAAI0G,iBAAiB,CAAC1G,IAAI,CAAC,CAAC;EAC9E,CAAC,MAAM;IACL5tD,MAAM,GAAG,CAACq3B,KAAK,EAAEA,KAAK,CAACtkB,KAAK,CAAC,CAAC,CAAC;IAC/B82D,6BAA6B,CAAC7pE,MAAM,CAAC,CAAC,CAAC,EAAE2pE,aAAa,CAAC3pE,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE+1B,GAAG,CAAC;EACzE;EACA,OAAO,IAAIq+B,eAAe,CAACp0D,MAAM,CAAC,CAAC,CAAC,EAAEoU,IAAI,CAACpU,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;AACxD;AACA,SAASiqE,sBAAsBA,CAAC5gE,CAAC,EAAE;EACjC,OAAOA,CAAC,YAAY2qD,oBAAoB,IAAI3qD,CAAC,YAAY4qD,iBAAiB,IAAI5qD,CAAC,YAAY6qD,sBAAsB;AACnH;AACA,SAASgW,wBAAwBA,CAAC7gE,CAAC,EAAE;EACnC,OAAOA,CAAC,YAAY6F,YAAY,IAAI7F,CAAC,YAAY+F,WAAW,IAAI/F,CAAC,YAAYmG,kBAAkB;AACjG;AACA,SAAS26D,kBAAkBA,CAAC9gE,CAAC,EAAE;EAC7B,OAAO4gE,sBAAsB,CAAC5gE,CAAC,CAAC,IAAI6gE,wBAAwB,CAAC7gE,CAAC,CAAC;AACjE;AACA,SAAS+gE,kBAAkBA,CAAC/gE,CAAC,EAAE;EAC7B,IAAI8gE,kBAAkB,CAAC9gE,CAAC,CAAC,IAAIA,CAAC,CAACsK,QAAQ,YAAYygD,eAAe,EAAE;IAClE,IAAIiW,EAAE,GAAGhhE,CAAC,CAACsK,QAAQ;IACnB,OAAO02D,EAAE,CAACn3D,IAAI,YAAYkhD,eAAe,EAAE;MACzCiW,EAAE,GAAGA,EAAE,CAACn3D,IAAI;IACd;IACA,OAAOm3D,EAAE;EACX;EACA,OAAO,IAAI;AACb;AACA,SAASb,aAAaA,CAACngE,CAAC,EAAE0sB,GAAG,EAAE;EAC7B,IAAI,CAACo0C,kBAAkB,CAAC9gE,CAAC,CAAC,EAAE;IAC1B,OAAOA,CAAC;EACV;EACA,MAAMihE,GAAG,GAAGF,kBAAkB,CAAC/gE,CAAC,CAAC;EACjC,IAAIihE,GAAG,EAAE;IACP,IAAIjhE,CAAC,YAAYmG,kBAAkB,EAAE;MACnC86D,GAAG,CAACp3D,IAAI,GAAGo3D,GAAG,CAACp3D,IAAI,CAAC7D,MAAM,CAAChG,CAAC,CAACqK,IAAI,CAAC;MAClC,OAAOrK,CAAC,CAACsK,QAAQ;IACnB;IACA,IAAItK,CAAC,YAAY6F,YAAY,EAAE;MAC7Bo7D,GAAG,CAACp3D,IAAI,GAAGo3D,GAAG,CAACp3D,IAAI,CAACjE,IAAI,CAAC5F,CAAC,CAACzI,IAAI,CAAC;MAChC,OAAOyI,CAAC,CAACsK,QAAQ;IACnB;IACA,IAAItK,CAAC,YAAY+F,WAAW,EAAE;MAC5Bk7D,GAAG,CAACp3D,IAAI,GAAGo3D,GAAG,CAACp3D,IAAI,CAAC/D,GAAG,CAAC9F,CAAC,CAACgB,KAAK,CAAC;MAChC,OAAOhB,CAAC,CAACsK,QAAQ;IACnB;IACA,IAAItK,CAAC,YAAY6qD,sBAAsB,EAAE;MACvCoW,GAAG,CAACp3D,IAAI,GAAG82D,wBAAwB,CAACM,GAAG,CAACp3D,IAAI,EAAE8lB,CAAC,IAAIA,CAAC,CAAC3pB,MAAM,CAAChG,CAAC,CAACqK,IAAI,CAAC,EAAEqiB,GAAG,CAAC;MACzE,OAAO1sB,CAAC,CAACsK,QAAQ;IACnB;IACA,IAAItK,CAAC,YAAY2qD,oBAAoB,EAAE;MACrCsW,GAAG,CAACp3D,IAAI,GAAG82D,wBAAwB,CAACM,GAAG,CAACp3D,IAAI,EAAE8lB,CAAC,IAAIA,CAAC,CAAC/pB,IAAI,CAAC5F,CAAC,CAACzI,IAAI,CAAC,EAAEm1B,GAAG,CAAC;MACvE,OAAO1sB,CAAC,CAACsK,QAAQ;IACnB;IACA,IAAItK,CAAC,YAAY4qD,iBAAiB,EAAE;MAClCqW,GAAG,CAACp3D,IAAI,GAAG82D,wBAAwB,CAACM,GAAG,CAACp3D,IAAI,EAAE8lB,CAAC,IAAIA,CAAC,CAAC7pB,GAAG,CAAC9F,CAAC,CAACgB,KAAK,CAAC,EAAE0rB,GAAG,CAAC;MACvE,OAAO1sB,CAAC,CAACsK,QAAQ;IACnB;EACF,CAAC,MAAM;IACL,IAAItK,CAAC,YAAY6qD,sBAAsB,EAAE;MACvC,OAAO8V,wBAAwB,CAAC3gE,CAAC,CAACsK,QAAQ,EAAEqlB,CAAC,IAAIA,CAAC,CAAC3pB,MAAM,CAAChG,CAAC,CAACqK,IAAI,CAAC,EAAEqiB,GAAG,CAAC;IACzE;IACA,IAAI1sB,CAAC,YAAY2qD,oBAAoB,EAAE;MACrC,OAAOgW,wBAAwB,CAAC3gE,CAAC,CAACsK,QAAQ,EAAEqlB,CAAC,IAAIA,CAAC,CAAC/pB,IAAI,CAAC5F,CAAC,CAACzI,IAAI,CAAC,EAAEm1B,GAAG,CAAC;IACvE;IACA,IAAI1sB,CAAC,YAAY4qD,iBAAiB,EAAE;MAClC,OAAO+V,wBAAwB,CAAC3gE,CAAC,CAACsK,QAAQ,EAAEqlB,CAAC,IAAIA,CAAC,CAAC7pB,GAAG,CAAC9F,CAAC,CAACgB,KAAK,CAAC,EAAE0rB,GAAG,CAAC;IACvE;EACF;EACA,OAAO1sB,CAAC;AACV;AACA,SAASogE,gBAAgBA,CAACpgE,CAAC,EAAE;EAC3B,IAAI,EAAEA,CAAC,YAAY+qD,eAAe,CAAC,EAAE;IACnC,OAAO/qD,CAAC;EACV;EACA,OAAO,IAAIwP,iBAAiB,CAAC,IAAI/I,eAAe,CAAC,IAAIG,kBAAkB,CAAC5B,cAAc,CAAC6B,MAAM,EAAE7G,CAAC,CAACguB,KAAK,EAAE3c,SAAS,CAAC,EAAEA,SAAS,EAAErR,CAAC,CAAC6J,IAAI,CAAC,CAAC;AACzI;AAEA,MAAMq3D,QAAQ,GAAG,QAAQ;AACzB,MAAMC,cAAc,GAAG,GAAG;AAC1B,MAAMC,eAAe,GAAG,GAAG;AAC3B,MAAMC,gBAAgB,GAAG,GAAG;AAC5B,MAAMC,cAAc,GAAG,GAAG;AAC1B,MAAMC,iBAAiB,GAAG,GAAG;AAC7B,MAAMC,eAAe,GAAG,GAAG;AAC3B,MAAMC,cAAc,GAAG,GAAG;AAC1B,SAASC,mBAAmBA,CAAC9J,GAAG,EAAE;EAChC,MAAM+J,qBAAqB,GAAG,IAAIxpE,GAAG,CAAC,CAAC;EACvC,MAAMypE,UAAU,GAAG,IAAIzpE,GAAG,CAAC,CAAC;EAC5B,MAAMigE,YAAY,GAAG,IAAIjgE,GAAG,CAAC,CAAC;EAC9B,KAAK,MAAMggC,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,QAAQ1nD,EAAE,CAACmhC,IAAI;QACb,KAAK0R,MAAM,CAAC+K,WAAW;UACrB,MAAMoU,aAAa,GAAGC,iBAAiB,CAAClK,GAAG,EAAE/nD,EAAE,CAAC;UAChDsoB,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAACmsE,aAAa,CAAC;UAC/BF,qBAAqB,CAACloE,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAEsd,aAAa,CAAC;UACjDzJ,YAAY,CAAC3+D,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC;UAC7B;QACF,KAAK6yC,MAAM,CAACiL,SAAS;UACnBiU,UAAU,CAACnoE,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC;UAC3B;MACJ;IACF;EACF;EACA,IAAIkyD,UAAU,GAAG,IAAI;EACrB,KAAK,MAAM5pC,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,QAAQ1nD,EAAE,CAACmhC,IAAI;QACb,KAAK0R,MAAM,CAACmL,QAAQ;UAClBkU,UAAU,GAAGlyD,EAAE;UACf2+C,MAAM,CAACiB,MAAM,CAAC5/C,EAAE,CAAC;UACjB,MAAMmyD,UAAU,GAAG5J,YAAY,CAAC5+D,GAAG,CAACqW,EAAE,CAACjS,OAAO,CAAC;UAC/C,IAAIokE,UAAU,CAACjN,WAAW,KAAK1R,eAAe,CAACtjB,GAAG,EAAE;YAClD;UACF;UACA,MAAMk0B,SAAS,GAAG2N,UAAU,CAACpoE,GAAG,CAACwoE,UAAU,CAAC/N,SAAS,CAAC;UACtD,IAAIA,SAAS,CAACr2D,OAAO,KAAKokE,UAAU,CAACzd,IAAI,EAAE;YACzC;UACF;UACA,MAAM0d,aAAa,GAAGL,UAAU,CAACpoE,GAAG,CAACy6D,SAAS,CAACK,IAAI,CAAC;UACpD,MAAM4N,WAAW,GAAGP,qBAAqB,CAACnoE,GAAG,CAACyoE,aAAa,CAACrkE,OAAO,CAAC;UACpE,IAAIskE,WAAW,KAAK58C,SAAS,EAAE;YAC7B,MAAMrvB,KAAK,CAAC,kEAAkE,CAAC;UACjF;UACA,MAAMksE,UAAU,GAAGR,qBAAqB,CAACnoE,GAAG,CAACwoE,UAAU,CAACzd,IAAI,CAAC;UAC7D4d,UAAU,CAACjO,kBAAkB,GAAGrkD,EAAE,CAACqkD,kBAAkB;UACrDgO,WAAW,CAAC9N,WAAW,CAAC1+D,IAAI,CAACysE,UAAU,CAAC5d,IAAI,CAAC;UAC7C;QACF,KAAK7B,MAAM,CAACkL,MAAM;UAChBmU,UAAU,GAAG,IAAI;UACjBvT,MAAM,CAACiB,MAAM,CAAC5/C,EAAE,CAAC;UACjB;QACF,KAAK6yC,MAAM,CAAC7gB,cAAc;UACxB,IAAIkgC,UAAU,KAAK,IAAI,IAAIA,UAAU,CAACnkE,OAAO,IAAI,IAAI,EAAE;YACrD,MAAM3H,KAAK,CAAC,oEAAoE,CAAC;UACnF;UACA,MAAM2L,GAAG,GAAG+/D,qBAAqB,CAACnoE,GAAG,CAACuoE,UAAU,CAACnkE,OAAO,CAAC;UACzDgE,GAAG,CAACorD,oBAAoB,CAACvzD,GAAG,CAACoW,EAAE,CAACtY,IAAI,EAAE4c,OAAO,CAACiuD,oBAAoB,CAACvyD,EAAE,CAAC,CAAC,CAAC;UACxE2+C,MAAM,CAACiB,MAAM,CAAC5/C,EAAE,CAAC;UACjB;MACJ;IACF;EACF;AACF;AACA,SAASiyD,iBAAiBA,CAAClK,GAAG,EAAEh6D,OAAO,EAAEs2D,kBAAkB,EAAE;EAC3D,IAAImO,eAAe,GAAGC,YAAY,CAAC1kE,OAAO,CAACqI,MAAM,CAAC;EAClD,MAAMs8D,6BAA6B,GAAGD,YAAY,CAAC1kE,OAAO,CAACovD,oBAAoB,CAAC;EAChF,IAAImH,mBAAmB,GAAG,CAAC,GAAGv2D,OAAO,CAACqI,MAAM,CAACyN,MAAM,CAAC,CAAC,CAAC,CAACwzB,IAAI,CAACs7B,CAAC,IAAIA,CAAC,CAAC/sE,MAAM,GAAG,CAAC,CAAC;EAC9E,OAAOu+D,mBAAmB,CAAC4D,GAAG,CAAC5B,cAAc,CAAC,CAAC,EAAEp4D,OAAO,CAAC2mD,IAAI,EAAE3mD,OAAO,CAACq2D,SAAS,EAAEr2D,OAAO,CAAClB,OAAO,EAAE,IAAI,EAAE2lE,eAAe,EAAEE,6BAA6B,EAAEpO,mBAAmB,CAAC;AAC/K;AACA,SAASiO,oBAAoBA,CAACvyD,EAAE,EAAE;EAChC,IAAIA,EAAE,CAACukB,OAAO,CAAC3+B,MAAM,KAAKoa,EAAE,CAACglD,sBAAsB,CAACp/D,MAAM,GAAG,CAAC,EAAE;IAC9D,MAAMQ,KAAK,CAAC,gDAAgD4Z,EAAE,CAACukB,OAAO,CAAC3+B,MAAM,gBAAgBoa,EAAE,CAACglD,sBAAsB,CAACp/D,MAAM,cAAc,CAAC;EAC9I;EACA,MAAMie,MAAM,GAAG7D,EAAE,CAACglD,sBAAsB,CAACj7D,GAAG,CAAC6oE,WAAW,CAAC;EACzD,OAAO5yD,EAAE,CAACukB,OAAO,CAACsuC,OAAO,CAAC,CAACxjE,GAAG,EAAErI,CAAC,KAAK,CAACqI,GAAG,EAAEwU,MAAM,CAAC7c,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,CAACQ,IAAI,CAAC,EAAE,CAAC;AACxE;AACA,SAASirE,YAAYA,CAACr8D,MAAM,EAAE;EAC5B,MAAMo8D,eAAe,GAAG,IAAIlqE,GAAG,CAAC,CAAC;EACjC,KAAK,MAAM,CAACgV,WAAW,EAAEw1D,iBAAiB,CAAC,IAAI18D,MAAM,EAAE;IACrD,MAAM28D,gBAAgB,GAAGC,iBAAiB,CAACF,iBAAiB,CAAC;IAC7D,IAAIC,gBAAgB,KAAK,IAAI,EAAE;MAC7BP,eAAe,CAAC5oE,GAAG,CAAC0T,WAAW,EAAEgH,OAAO,CAACyuD,gBAAgB,CAAC,CAAC;IAC7D;EACF;EACA,OAAOP,eAAe;AACxB;AACA,SAASQ,iBAAiBA,CAACnvD,MAAM,EAAE;EACjC,IAAIA,MAAM,CAACje,MAAM,KAAK,CAAC,EAAE;IACvB,OAAO,IAAI;EACb;EACA,MAAMmtE,gBAAgB,GAAGlvD,MAAM,CAAC9Z,GAAG,CAACpC,KAAK,IAAIirE,WAAW,CAACjrE,KAAK,CAAC,CAAC;EAChE,OAAOorE,gBAAgB,CAACntE,MAAM,KAAK,CAAC,GAAGmtE,gBAAgB,CAAC,CAAC,CAAC,GAAG,GAAGrB,iBAAiB,GAAGqB,gBAAgB,CAACvrE,IAAI,CAACoqE,cAAc,CAAC,GAAGD,eAAe,EAAE;AAC/I;AACA,SAASiB,WAAWA,CAACjrE,KAAK,EAAE;EAC1B,IAAIA,KAAK,CAACwT,KAAK,GAAGk4C,mBAAmB,CAAC4f,UAAU,IAAItrE,KAAK,CAACwT,KAAK,GAAGk4C,mBAAmB,CAAC6f,WAAW,EAAE;IACjG,IAAI,OAAOvrE,KAAK,CAACA,KAAK,KAAK,QAAQ,EAAE;MACnC,MAAMvB,KAAK,CAAC,gFAAgF,CAAC;IAC/F;IACA,MAAM+sE,YAAY,GAAGP,WAAW,CAAC;MAC/B,GAAGjrE,KAAK;MACRA,KAAK,EAAEA,KAAK,CAACA,KAAK,CAACzC,OAAO;MAC1BiW,KAAK,EAAExT,KAAK,CAACwT,KAAK,GAAG,CAACk4C,mBAAmB,CAAC6f;IAC5C,CAAC,CAAC;IACF,MAAME,aAAa,GAAGR,WAAW,CAAC;MAChC,GAAGjrE,KAAK;MACRA,KAAK,EAAEA,KAAK,CAACA,KAAK,CAACkT,QAAQ;MAC3BM,KAAK,EAAExT,KAAK,CAACwT,KAAK,GAAG,CAACk4C,mBAAmB,CAAC4f;IAC5C,CAAC,CAAC;IACF,IAAItrE,KAAK,CAACwT,KAAK,GAAGk4C,mBAAmB,CAACggB,OAAO,IAAI1rE,KAAK,CAACwT,KAAK,GAAGk4C,mBAAmB,CAACigB,QAAQ,EAAE;MAC3F,OAAO,GAAGF,aAAa,GAAGD,YAAY,GAAGC,aAAa,EAAE;IAC1D;IACA,OAAOzrE,KAAK,CAACwT,KAAK,GAAGk4C,mBAAmB,CAACigB,QAAQ,GAAG,GAAGH,YAAY,GAAGC,aAAa,EAAE,GAAG,GAAGA,aAAa,GAAGD,YAAY,EAAE;EAC3H;EACA,IAAIxrE,KAAK,CAACwT,KAAK,GAAGk4C,mBAAmB,CAACggB,OAAO,IAAI1rE,KAAK,CAACwT,KAAK,GAAGk4C,mBAAmB,CAACigB,QAAQ,EAAE;IAC3F,OAAO,GAAGV,WAAW,CAAC;MACpB,GAAGjrE,KAAK;MACRwT,KAAK,EAAExT,KAAK,CAACwT,KAAK,GAAG,CAACk4C,mBAAmB,CAACigB;IAC5C,CAAC,CAAC,GAAGV,WAAW,CAAC;MACf,GAAGjrE,KAAK;MACRwT,KAAK,EAAExT,KAAK,CAACwT,KAAK,GAAG,CAACk4C,mBAAmB,CAACggB;IAC5C,CAAC,CAAC,EAAE;EACN;EACA,IAAI1rE,KAAK,CAACwT,KAAK,KAAKk4C,mBAAmB,CAACngD,IAAI,EAAE;IAC5C,OAAO,GAAGvL,KAAK,CAACA,KAAK,EAAE;EACzB;EACA,IAAI4rE,SAAS,GAAG,EAAE;EAClB,IAAIC,WAAW,GAAG,EAAE;EACpB,IAAI7rE,KAAK,CAACwT,KAAK,GAAGk4C,mBAAmB,CAAC4f,UAAU,EAAE;IAChDM,SAAS,GAAGjC,cAAc;EAC5B,CAAC,MAAM,IAAI3pE,KAAK,CAACwT,KAAK,GAAGk4C,mBAAmB,CAAC6f,WAAW,EAAE;IACxDK,SAAS,GAAGhC,eAAe;EAC7B;EACA,IAAIgC,SAAS,KAAK,EAAE,EAAE;IACpBC,WAAW,GAAG7rE,KAAK,CAACwT,KAAK,GAAGk4C,mBAAmB,CAACigB,QAAQ,GAAG9B,gBAAgB,GAAG,EAAE;EAClF;EACA,MAAMzjE,OAAO,GAAGpG,KAAK,CAACg9D,gBAAgB,KAAK,IAAI,GAAG,EAAE,GAAG,GAAG8M,cAAc,GAAG9pE,KAAK,CAACg9D,gBAAgB,EAAE;EACnG,OAAO,GAAG0M,QAAQ,GAAGmC,WAAW,GAAGD,SAAS,GAAG5rE,KAAK,CAACA,KAAK,GAAGoG,OAAO,GAAGsjE,QAAQ,EAAE;AACnF;AAEA,SAASoC,eAAeA,CAAC1L,GAAG,EAAE;EAC5B,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,MAAMuM,OAAO,GAAG,IAAIprE,GAAG,CAAC,CAAC;IACzB,KAAK,MAAM0X,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI,CAACvT,oBAAoB,CAACn0C,EAAE,CAAC,EAAE;QAC7B;MACF,CAAC,MAAM,IAAIA,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,KAAK,IAAI,EAAE;QAClC,MAAM,IAAIl1D,KAAK,CAAC,yFAAyF,CAAC;MAC5G;MACAstE,OAAO,CAAC9pE,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,CAAC;IACtC;IACA,IAAIqY,WAAW,GAAG,CAAC;IACnB,KAAK,MAAM3zD,EAAE,IAAIsoB,IAAI,CAACq/B,MAAM,EAAE;MAC5B,IAAIiM,QAAQ,GAAG,IAAI;MACnB,IAAIxf,4BAA4B,CAACp0C,EAAE,CAAC,EAAE;QACpC4zD,QAAQ,GAAG5zD,EAAE;MACf,CAAC,MAAM;QACL47C,oBAAoB,CAAC57C,EAAE,EAAEhG,IAAI,IAAI;UAC/B,IAAI45D,QAAQ,KAAK,IAAI,IAAIxf,4BAA4B,CAACp6C,IAAI,CAAC,EAAE;YAC3D45D,QAAQ,GAAG55D,IAAI;UACjB;QACF,CAAC,CAAC;MACJ;MACA,IAAI45D,QAAQ,KAAK,IAAI,EAAE;QACrB;MACF;MACA,IAAI,CAACF,OAAO,CAAC3oE,GAAG,CAAC6oE,QAAQ,CAACl0C,MAAM,CAAC,EAAE;QACjC,MAAM,IAAIt5B,KAAK,CAAC,wDAAwDwtE,QAAQ,CAACl0C,MAAM,EAAE,CAAC;MAC5F;MACA,MAAM47B,IAAI,GAAGoY,OAAO,CAAC/pE,GAAG,CAACiqE,QAAQ,CAACl0C,MAAM,CAAC;MACzC,IAAIi0C,WAAW,KAAKrY,IAAI,EAAE;QACxB,MAAMhc,KAAK,GAAGgc,IAAI,GAAGqY,WAAW;QAChC,IAAIr0B,KAAK,GAAG,CAAC,EAAE;UACb,MAAM,IAAIl5C,KAAK,CAAC,kEAAkE,CAAC;QACrF;QACAu4D,MAAM,CAACsB,YAAY,CAACxJ,eAAe,CAACnX,KAAK,EAAEs0B,QAAQ,CAAC99D,UAAU,CAAC,EAAEkK,EAAE,CAAC;QACpE2zD,WAAW,GAAGrY,IAAI;MACpB;IACF;EACF;AACF;AAEA,SAASuY,0BAA0BA,CAAC9L,GAAG,EAAE;EACvC,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACq/B,MAAM,EAAE;MAC5B,IAAI3nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACuF,QAAQ,EAAE;QAC/B;MACF;MACA,MAAM/0C,QAAQ,GAAG;QACf89B,IAAI,EAAE6R,oBAAoB,CAAC8gB,UAAU;QACrCpsE,IAAI,EAAE,IAAI;QACVg6C,UAAU,EAAE1hC,EAAE,CAACw4B,YAAY;QAC3Bu7B,KAAK,EAAE;MACT,CAAC;MACDpV,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEy0C,gBAAgB,CAACsT,GAAG,CAAC5B,cAAc,CAAC,CAAC,EAAE9iD,QAAQ,EAAE,IAAIw1C,YAAY,CAAC74C,EAAE,CAAC0f,MAAM,EAAE1f,EAAE,CAACrY,KAAK,EAAEqY,EAAE,CAAClK,UAAU,CAAC,EAAEi9C,aAAa,CAAC7/C,IAAI,CAAC,CAAC;IAChJ;EACF;AACF;AAEA,SAAS8gE,sBAAsBA,CAACjM,GAAG,EAAE;EACnC,MAAMkM,KAAK,GAAGlM,GAAG,CAAC/B,aAAa,KAAK/S,iBAAiB,CAACsW,yBAAyB;EAC/E,MAAM9+D,SAAS,GAAG,EAAE;EACpB,IAAIw4D,mBAAmB,GAAG,CAAC;EAC3B,KAAK,MAAM36B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACoL,UAAU,EAAE;QACjCxzD,SAAS,CAAC5E,IAAI,CAACma,EAAE,CAACza,QAAQ,CAAC;QAC3Bya,EAAE,CAACijD,mBAAmB,GAAGA,mBAAmB,EAAE;MAChD;IACF;EACF;EACA,IAAIx4D,SAAS,CAAC7E,MAAM,GAAG,CAAC,EAAE;IACxB,IAAIsuE,OAAO,GAAG,IAAI;IAClB,IAAIzpE,SAAS,CAAC7E,MAAM,GAAG,CAAC,IAAI6E,SAAS,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;MAChD,MAAMic,GAAG,GAAGjc,SAAS,CAACV,GAAG,CAAC4rB,CAAC,IAAIA,CAAC,KAAK,GAAG,GAAGA,CAAC,GAAGzpB,yBAAyB,CAACypB,CAAC,CAAC,CAAC;MAC5Eu+C,OAAO,GAAGnM,GAAG,CAAChC,IAAI,CAAChgD,eAAe,CAAC+lD,qBAAqB,CAACplD,GAAG,CAAC,EAAEutD,KAAK,CAAC;IACvE;IACAlM,GAAG,CAACf,gBAAgB,GAAGe,GAAG,CAAChC,IAAI,CAAChgD,eAAe,CAAC+lD,qBAAqB,CAACrhE,SAAS,CAAC,EAAEwpE,KAAK,CAAC;IACxFlM,GAAG,CAACtD,IAAI,CAACiD,MAAM,CAACxI,OAAO,CAAC,CAAC4D,qBAAqB,CAACoR,OAAO,CAAC,CAAC,CAAC;EAC3D;AACF;AAEA,SAASC,iBAAiBA,CAACpM,GAAG,EAAE;EAC9BqM,sBAAsB,CAACrM,GAAG,CAACtD,IAAI,EAAE,IAAI,CAAC;AACxC;AACA,SAAS2P,sBAAsBA,CAAC/iE,IAAI,EAAEgjE,WAAW,EAAE;EACjD,MAAM5F,KAAK,GAAGD,eAAe,CAACn9D,IAAI,EAAEgjE,WAAW,CAAC;EAChD,KAAK,MAAMr0D,EAAE,IAAI3O,IAAI,CAACq2D,MAAM,EAAE;IAC5B,QAAQ1nD,EAAE,CAACmhC,IAAI;MACb,KAAK0R,MAAM,CAACyL,iBAAiB;MAC7B,KAAKzL,MAAM,CAAC0L,uBAAuB;MACnC,KAAK1L,MAAM,CAACtjB,QAAQ;QAClB6kC,sBAAsB,CAAC/iE,IAAI,CAAC02D,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAAC00C,IAAI,CAAC,EAAE+Z,KAAK,CAAC;QAC1D;MACF,KAAK5b,MAAM,CAACoL,UAAU;QACpB,IAAIj+C,EAAE,CAACgjD,YAAY,KAAK,IAAI,EAAE;UAC5BoR,sBAAsB,CAAC/iE,IAAI,CAAC02D,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAACgjD,YAAY,CAAC,EAAEyL,KAAK,CAAC;QACpE;QACA;MACF,KAAK5b,MAAM,CAAC6J,cAAc;QACxB0X,sBAAsB,CAAC/iE,IAAI,CAAC02D,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAAC00C,IAAI,CAAC,EAAE+Z,KAAK,CAAC;QAC1D,IAAIzuD,EAAE,CAACkhD,SAAS,EAAE;UAChBkT,sBAAsB,CAAC/iE,IAAI,CAAC02D,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAACkhD,SAAS,CAAC,EAAEuN,KAAK,CAAC;QACjE;QACA,IAAIzuD,EAAE,CAAC28C,UAAU,KAAK,IAAI,EAAE;UAC1B38C,EAAE,CAAC28C,UAAU,CAACuC,OAAO,CAACoV,+BAA+B,CAACjjE,IAAI,EAAEo9D,KAAK,EAAE,KAAK,CAAC,CAAC;QAC5E;QACA;MACF,KAAK5b,MAAM,CAACqJ,SAAS;MACrB,KAAKrJ,MAAM,CAACsJ,iBAAiB;MAC7B,KAAKtJ,MAAM,CAACuJ,QAAQ;MACpB,KAAKvJ,MAAM,CAACwJ,cAAc;QACxBr8C,EAAE,CAACu8C,UAAU,CAAC2C,OAAO,CAACoV,+BAA+B,CAACjjE,IAAI,EAAEo9D,KAAK,EAAE,IAAI,CAAC,CAAC;QACzE;IACJ;EACF;EACAp9D,IAAI,CAACs2D,MAAM,CAACzI,OAAO,CAACoV,+BAA+B,CAACjjE,IAAI,EAAEo9D,KAAK,EAAE,KAAK,CAAC,CAAC;AAC1E;AACA,SAASD,eAAeA,CAACn9D,IAAI,EAAE61D,MAAM,EAAE;EACrC,MAAMuH,KAAK,GAAG;IACZp9D,IAAI,EAAEA,IAAI,CAACqjD,IAAI;IACf6f,mBAAmB,EAAE;MACnBpzB,IAAI,EAAE6R,oBAAoB,CAACmG,OAAO;MAClCzxD,IAAI,EAAE,IAAI;MACV2J,IAAI,EAAEA,IAAI,CAACqjD;IACb,CAAC;IACDxmB,gBAAgB,EAAE,IAAI5lC,GAAG,CAAC,CAAC;IAC3B0/D,OAAO,EAAE32D,IAAI,CAAC22D,OAAO;IACrBr9B,UAAU,EAAE,EAAE;IACd6pC,eAAe,EAAE,EAAE;IACnBtN;EACF,CAAC;EACD,KAAK,MAAMxlB,UAAU,IAAIrwC,IAAI,CAAC68B,gBAAgB,CAAC3/B,IAAI,CAAC,CAAC,EAAE;IACrDkgE,KAAK,CAACvgC,gBAAgB,CAACtkC,GAAG,CAAC83C,UAAU,EAAE;MACrCP,IAAI,EAAE6R,oBAAoB,CAAC8gB,UAAU;MACrCpsE,IAAI,EAAE,IAAI;MACVg6C,UAAU;MACVqyB,KAAK,EAAE;IACT,CAAC,CAAC;EACJ;EACA,KAAK,MAAM/zD,EAAE,IAAI3O,IAAI,CAACq2D,MAAM,EAAE;IAC5B,QAAQ1nD,EAAE,CAACmhC,IAAI;MACb,KAAK0R,MAAM,CAAC4K,YAAY;MACxB,KAAK5K,MAAM,CAACyL,iBAAiB;MAC7B,KAAKzL,MAAM,CAAC0L,uBAAuB;MACnC,KAAK1L,MAAM,CAACtjB,QAAQ;QAClB,IAAI,CAACpwB,KAAK,CAACC,OAAO,CAACY,EAAE,CAACygD,SAAS,CAAC,EAAE;UAChC,MAAM,IAAIr6D,KAAK,CAAC,mDAAmD,CAAC;QACtE;QACA,KAAK,IAAIg5C,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGp/B,EAAE,CAACygD,SAAS,CAAC76D,MAAM,EAAEw5C,MAAM,EAAE,EAAE;UAC3DqvB,KAAK,CAAC9jC,UAAU,CAAC9kC,IAAI,CAAC;YACpB6B,IAAI,EAAEsY,EAAE,CAACygD,SAAS,CAACrhB,MAAM,CAAC,CAAC13C,IAAI;YAC/B+sE,QAAQ,EAAEz0D,EAAE,CAAC00C,IAAI;YACjBsC,UAAU,EAAEh3C,EAAE,CAAC23C,MAAM;YACrBvY,MAAM;YACN/7B,QAAQ,EAAE;cACR89B,IAAI,EAAE6R,oBAAoB,CAAC8gB,UAAU;cACrCpsE,IAAI,EAAE,IAAI;cACVg6C,UAAU,EAAE1hC,EAAE,CAACygD,SAAS,CAACrhB,MAAM,CAAC,CAAC13C,IAAI;cACrCqsE,KAAK,EAAE;YACT;UACF,CAAC,CAAC;QACJ;QACA;MACF,KAAKlhB,MAAM,CAACuL,UAAU;QACpBqQ,KAAK,CAAC+F,eAAe,CAAC3uE,IAAI,CAAC;UACzB4uE,QAAQ,EAAEz0D,EAAE,CAAC00C,IAAI;UACjBsC,UAAU,EAAEh3C,EAAE,CAAC23C,MAAM;UACrBt0C,QAAQ,EAAE;YACR89B,IAAI,EAAE6R,oBAAoB,CAAC8gB,UAAU;YACrCpsE,IAAI,EAAE,IAAI;YACVg6C,UAAU,EAAE1hC,EAAE,CAACw4B,YAAY;YAC3Bu7B,KAAK,EAAE;UACT;QACF,CAAC,CAAC;QACF;IACJ;EACF;EACA,OAAOtF,KAAK;AACd;AACA,SAAS6F,+BAA+BA,CAACjjE,IAAI,EAAEo9D,KAAK,EAAEiG,UAAU,EAAE;EAChE,MAAM/U,MAAM,GAAG,EAAE;EACjB,IAAI8O,KAAK,CAACp9D,IAAI,KAAKA,IAAI,CAACqjD,IAAI,EAAE;IAC5BiL,MAAM,CAAC95D,IAAI,CAAC4uD,gBAAgB,CAACpjD,IAAI,CAAC02D,GAAG,CAAC5B,cAAc,CAAC,CAAC,EAAEsI,KAAK,CAAC8F,mBAAmB,EAAE,IAAIjb,eAAe,CAAC,CAAC,EAAEvG,aAAa,CAAC7/C,IAAI,CAAC,CAAC;EAChI;EACA,MAAMyhE,SAAS,GAAGtjE,IAAI,CAAC02D,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAAC8kE,KAAK,CAACp9D,IAAI,CAAC;EAChD,KAAK,MAAM,CAAC3J,IAAI,EAAEC,KAAK,CAAC,IAAIgtE,SAAS,CAACzmC,gBAAgB,EAAE;IACtD,MAAMngC,OAAO,GAAG,IAAImrD,WAAW,CAACuV,KAAK,CAACp9D,IAAI,CAAC;IAC3C,MAAMgS,QAAQ,GAAG1b,KAAK,KAAKg+D,OAAO,GAAG53D,OAAO,GAAG,IAAIiI,YAAY,CAACjI,OAAO,EAAEpG,KAAK,CAAC;IAC/Eg4D,MAAM,CAAC95D,IAAI,CAAC4uD,gBAAgB,CAACpjD,IAAI,CAAC02D,GAAG,CAAC5B,cAAc,CAAC,CAAC,EAAEsI,KAAK,CAACvgC,gBAAgB,CAACvkC,GAAG,CAACjC,IAAI,CAAC,EAAE2b,QAAQ,EAAE0vC,aAAa,CAAC7/C,IAAI,CAAC,CAAC;EAC1H;EACA,KAAK,MAAMsoD,KAAK,IAAImZ,SAAS,CAAC3M,OAAO,EAAE;IACrCrI,MAAM,CAAC95D,IAAI,CAAC4uD,gBAAgB,CAACpjD,IAAI,CAAC02D,GAAG,CAAC5B,cAAc,CAAC,CAAC,EAAE3K,KAAK,EAAEA,KAAK,CAAC9sD,UAAU,CAACmL,KAAK,CAAC,CAAC,EAAEk5C,aAAa,CAAC6hB,YAAY,CAAC,CAAC;EACvH;EACA,KAAK,MAAMh2C,GAAG,IAAI6vC,KAAK,CAAC9jC,UAAU,EAAE;IAClCg1B,MAAM,CAAC95D,IAAI,CAAC4uD,gBAAgB,CAACpjD,IAAI,CAAC02D,GAAG,CAAC5B,cAAc,CAAC,CAAC,EAAEvnC,GAAG,CAACvb,QAAQ,EAAE,IAAIu1C,aAAa,CAACh6B,GAAG,CAAC61C,QAAQ,EAAE71C,GAAG,CAACo4B,UAAU,EAAEp4B,GAAG,CAACwgB,MAAM,CAAC,EAAE2T,aAAa,CAAC7/C,IAAI,CAAC,CAAC;EACzJ;EACA,IAAIu7D,KAAK,CAACp9D,IAAI,KAAKA,IAAI,CAACqjD,IAAI,IAAIggB,UAAU,EAAE;IAC1C,KAAK,MAAMzjC,IAAI,IAAIw9B,KAAK,CAAC+F,eAAe,EAAE;MACxC7U,MAAM,CAAC95D,IAAI,CAAC4uD,gBAAgB,CAACpjD,IAAI,CAAC02D,GAAG,CAAC5B,cAAc,CAAC,CAAC,EAAEl1B,IAAI,CAAC5tB,QAAQ,EAAE,IAAI21C,uBAAuB,CAAC/nB,IAAI,CAACwjC,QAAQ,EAAExjC,IAAI,CAAC+lB,UAAU,CAAC,EAAEjE,aAAa,CAAC7/C,IAAI,CAAC,CAAC;IAC1J;EACF;EACA,IAAIu7D,KAAK,CAACvH,MAAM,KAAK,IAAI,EAAE;IACzBvH,MAAM,CAAC95D,IAAI,CAAC,GAAGyuE,+BAA+B,CAACjjE,IAAI,EAAEo9D,KAAK,CAACvH,MAAM,EAAE,KAAK,CAAC,CAAC;EAC5E;EACA,OAAOvH,MAAM;AACf;AAEA,SAASkV,uBAAuBA,CAAC9M,GAAG,EAAE;EACpC,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAAC62B,GAAG,CAAC,CAAC,EAAE;MAC3BtD,wBAAwB,CAAC77C,EAAE,EAAEhG,IAAI,IAAI;QACnC,IAAI,EAAEA,IAAI,YAAY0hD,kBAAkB,CAAC,EAAE;UACzC,OAAO1hD,IAAI;QACb;QACA,OAAOsK,OAAO,CAACyjD,GAAG,CAACX,QAAQ,CAACptD,IAAI,CAACA,IAAI,CAAC,CAAC;MACzC,CAAC,EAAEsgD,kBAAkB,CAACpnD,IAAI,CAAC;IAC7B;EACF;AACF;AAEA,MAAM4hE,SAAS,GAAG,QAAQ;AAC1B,MAAMC,SAAS,GAAG,QAAQ;AAC1B,MAAMC,UAAU,GAAG,QAAQ;AAC3B,MAAMC,UAAU,GAAG,QAAQ;AAC3B,MAAMC,cAAc,GAAG,YAAY;AACnC,SAASC,wBAAwBA,CAACpN,GAAG,EAAE;EACrC,KAAK,MAAM/nD,EAAE,IAAI+nD,GAAG,CAACtD,IAAI,CAACkD,MAAM,EAAE;IAChC,IAAI,EAAE3nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC0C,OAAO,IAAIv1C,EAAE,CAACw1C,WAAW,KAAKtC,WAAW,CAACrZ,QAAQ,CAAC,EAAE;MAC5E;IACF;IACA,IAAI75B,EAAE,CAACtY,IAAI,CAAC0tE,QAAQ,CAACF,cAAc,CAAC,EAAE;MACpCl1D,EAAE,CAACtY,IAAI,GAAGsY,EAAE,CAACtY,IAAI,CAAC+3C,SAAS,CAAC,CAAC,EAAEz/B,EAAE,CAACtY,IAAI,CAAC9B,MAAM,GAAGsvE,cAAc,CAACtvE,MAAM,CAAC;IACxE;IACA,IAAIoa,EAAE,CAACtY,IAAI,CAACsvB,UAAU,CAAC89C,SAAS,CAAC,EAAE;MACjC90D,EAAE,CAACw1C,WAAW,GAAGtC,WAAW,CAACiX,aAAa;MAC1CnqD,EAAE,CAACtY,IAAI,GAAGsY,EAAE,CAACtY,IAAI,CAAC+3C,SAAS,CAACq1B,SAAS,CAAClvE,MAAM,CAAC;MAC7C,IAAI,CAACyvE,mBAAmB,CAACr1D,EAAE,CAACtY,IAAI,CAAC,EAAE;QACjCsY,EAAE,CAACtY,IAAI,GAAG4tE,WAAW,CAACt1D,EAAE,CAACtY,IAAI,CAAC;MAChC;MACA,MAAM;QACJ0mB,QAAQ;QACRijC;MACF,CAAC,GAAGkkB,aAAa,CAACv1D,EAAE,CAACtY,IAAI,CAAC;MAC1BsY,EAAE,CAACtY,IAAI,GAAG0mB,QAAQ;MAClBpO,EAAE,CAACsoB,IAAI,GAAG+oB,MAAM;IAClB,CAAC,MAAM,IAAIrxC,EAAE,CAACtY,IAAI,CAACsvB,UAAU,CAACg+C,UAAU,CAAC,EAAE;MACzCh1D,EAAE,CAACw1C,WAAW,GAAGtC,WAAW,CAACiX,aAAa;MAC1CnqD,EAAE,CAACtY,IAAI,GAAG,OAAO;IACnB,CAAC,MAAM,IAAIsY,EAAE,CAACtY,IAAI,CAACsvB,UAAU,CAAC+9C,SAAS,CAAC,EAAE;MACxC/0D,EAAE,CAACw1C,WAAW,GAAGtC,WAAW,CAACgX,SAAS;MACtClqD,EAAE,CAACtY,IAAI,GAAG6tE,aAAa,CAACv1D,EAAE,CAACtY,IAAI,CAAC+3C,SAAS,CAACs1B,SAAS,CAACnvE,MAAM,CAAC,CAAC,CAACwoB,QAAQ;IACvE,CAAC,MAAM,IAAIpO,EAAE,CAACtY,IAAI,CAACsvB,UAAU,CAACi+C,UAAU,CAAC,EAAE;MACzCj1D,EAAE,CAACw1C,WAAW,GAAGtC,WAAW,CAACgX,SAAS;MACtClqD,EAAE,CAACtY,IAAI,GAAG6tE,aAAa,CAACv1D,EAAE,CAACtY,IAAI,CAAC+3C,SAAS,CAACw1B,UAAU,CAACrvE,MAAM,CAAC,CAAC,CAACwoB,QAAQ;IACxE;EACF;AACF;AACA,SAASinD,mBAAmBA,CAAC3tE,IAAI,EAAE;EACjC,OAAOA,IAAI,CAACsvB,UAAU,CAAC,IAAI,CAAC;AAC9B;AACA,SAASs+C,WAAWA,CAAC3tE,KAAK,EAAE;EAC1B,OAAOA,KAAK,CAACP,OAAO,CAAC,aAAa,EAAEurE,CAAC,IAAI;IACvC,OAAOA,CAAC,CAACzrE,MAAM,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGyrE,CAAC,CAACzrE,MAAM,CAAC,CAAC,CAAC;EACxC,CAAC,CAAC,CAACU,WAAW,CAAC,CAAC;AAClB;AACA,SAAS2tE,aAAaA,CAAC7tE,IAAI,EAAE;EAC3B,MAAM8tE,aAAa,GAAG9tE,IAAI,CAAC2tB,OAAO,CAAC,YAAY,CAAC;EAChD,IAAImgD,aAAa,KAAK,CAAC,CAAC,EAAE;IACxB9tE,IAAI,GAAG8tE,aAAa,GAAG,CAAC,GAAG9tE,IAAI,CAAC+3C,SAAS,CAAC,CAAC,EAAE+1B,aAAa,CAAC,GAAG,EAAE;EAClE;EACA,IAAInkB,MAAM,GAAG,IAAI;EACjB,IAAIjjC,QAAQ,GAAG1mB,IAAI;EACnB,MAAM+tE,SAAS,GAAG/tE,IAAI,CAACg4C,WAAW,CAAC,GAAG,CAAC;EACvC,IAAI+1B,SAAS,GAAG,CAAC,EAAE;IACjBpkB,MAAM,GAAG3pD,IAAI,CAAClB,KAAK,CAACivE,SAAS,GAAG,CAAC,CAAC;IAClCrnD,QAAQ,GAAG1mB,IAAI,CAAC+3C,SAAS,CAAC,CAAC,EAAEg2B,SAAS,CAAC;EACzC;EACA,OAAO;IACLrnD,QAAQ;IACRijC;EACF,CAAC;AACH;AAEA,SAASqkB,UAAUA,CAACC,GAAG,EAAE10D,MAAM,GAAG,KAAK,EAAE;EACvC,OAAO6C,UAAU,CAAC1X,MAAM,CAACmC,IAAI,CAAConE,GAAG,CAAC,CAAC5rE,GAAG,CAACkM,GAAG,KAAK;IAC7CA,GAAG;IACHgL,MAAM;IACNtZ,KAAK,EAAEguE,GAAG,CAAC1/D,GAAG;EAChB,CAAC,CAAC,CAAC,CAAC;AACN;AAEA,MAAM2/D,oBAAoB,CAAC;EACzB/nE,SAASA,CAACC,IAAI,EAAE;IACd,OAAOA,IAAI,CAACnG,KAAK;EACnB;EACAqG,cAAcA,CAACC,SAAS,EAAE;IACxB,OAAOA,SAAS,CAACC,QAAQ,CAACnE,GAAG,CAACoE,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC,CAAClG,IAAI,CAAC,EAAE,CAAC;EACpE;EACA4G,QAAQA,CAACC,GAAG,EAAE;IACZ,MAAMC,QAAQ,GAAGlC,MAAM,CAACmC,IAAI,CAACF,GAAG,CAACG,KAAK,CAAC,CAACzE,GAAG,CAAC0E,CAAC,IAAI,GAAGA,CAAC,KAAKJ,GAAG,CAACG,KAAK,CAACC,CAAC,CAAC,CAACf,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC;IACtF,MAAM5G,MAAM,GAAG,IAAIuH,GAAG,CAACwjC,qBAAqB,KAAKxjC,GAAG,CAACM,IAAI,KAAKL,QAAQ,CAAC9G,IAAI,CAAC,GAAG,CAAC,GAAG;IACnF,OAAOV,MAAM;EACf;EACA8H,mBAAmBA,CAACC,EAAE,EAAE;IACtB,OAAOA,EAAE,CAACC,MAAM,GAAG,IAAI,CAAC+mE,QAAQ,CAAChnE,EAAE,CAACE,SAAS,CAAC,GAAG,GAAG,IAAI,CAAC8mE,QAAQ,CAAChnE,EAAE,CAACE,SAAS,CAAC,GAAGF,EAAE,CAACX,QAAQ,CAACnE,GAAG,CAACoE,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC,CAAClG,IAAI,CAAC,EAAE,CAAC,GAAG,IAAI,CAACquE,QAAQ,CAAChnE,EAAE,CAACG,SAAS,CAAC,EAAE;EACxK;EACAC,gBAAgBA,CAACJ,EAAE,EAAE;IACnB,OAAO,IAAI,CAACgnE,QAAQ,CAAChnE,EAAE,CAACnH,IAAI,CAAC;EAC/B;EACAyH,qBAAqBA,CAACN,EAAE,EAAE;IACxB,OAAO,GAAG,IAAI,CAACgnE,QAAQ,CAAChnE,EAAE,CAACE,SAAS,CAAC,GAAGF,EAAE,CAACX,QAAQ,CAACnE,GAAG,CAACoE,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC,CAAClG,IAAI,CAAC,EAAE,CAAC,GAAG,IAAI,CAACquE,QAAQ,CAAChnE,EAAE,CAACG,SAAS,CAAC,EAAE;EAC9H;EACAE,mBAAmBA,CAACL,EAAE,EAAEd,OAAO,EAAE;IAC/B,OAAO,IAAI,CAAC8nE,QAAQ,CAAChnE,EAAE,CAACnH,IAAI,CAAC;EAC/B;EACAmuE,QAAQA,CAACluE,KAAK,EAAE;IACd,OAAO,IAAI+vC,yBAAyB,CAAC/vC,KAAK,EAAE,KAAK,CAAC,GAAG;EACvD;AACF;AACA,MAAMmuE,UAAU,GAAG,IAAIF,oBAAoB,CAAC,CAAC;AAC7C,SAASG,gBAAgBA,CAAC1nE,GAAG,EAAE;EAC7B,OAAOA,GAAG,CAACX,KAAK,CAACooE,UAAU,CAAC;AAC9B;AAEA,MAAME,YAAY,CAAC;EACjBlgE,UAAU;EACV6Y,IAAI;EACJjkB,WAAWA,CAACoL,UAAU,EAAE6Y,IAAI,EAAE;IAC5B,IAAI,CAAC7Y,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAC6Y,IAAI,GAAGA,IAAI;EAClB;AACF;AACA,MAAM2a,IAAI,SAAS0sC,YAAY,CAAC;EAC9BruE,KAAK;EACLsuE,MAAM;EACNvrE,WAAWA,CAAC/C,KAAK,EAAEmO,UAAU,EAAEmgE,MAAM,EAAEtnD,IAAI,EAAE;IAC3C,KAAK,CAAC7Y,UAAU,EAAE6Y,IAAI,CAAC;IACvB,IAAI,CAAChnB,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACsuE,MAAM,GAAGA,MAAM;EACtB;EACAvoE,KAAKA,CAACJ,OAAO,EAAES,OAAO,EAAE;IACtB,OAAOT,OAAO,CAACO,SAAS,CAAC,IAAI,EAAEE,OAAO,CAAC;EACzC;AACF;AACA,MAAMmoE,SAAS,SAASF,YAAY,CAAC;EACnCG,WAAW;EACXxnE,IAAI;EACJH,KAAK;EACL4nE,qBAAqB;EACrB1rE,WAAWA,CAACyrE,WAAW,EAAExnE,IAAI,EAAEH,KAAK,EAAEsH,UAAU,EAAEsgE,qBAAqB,EAAEznD,IAAI,EAAE;IAC7E,KAAK,CAAC7Y,UAAU,EAAE6Y,IAAI,CAAC;IACvB,IAAI,CAACwnD,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACxnE,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACH,KAAK,GAAGA,KAAK;IAClB,IAAI,CAAC4nE,qBAAqB,GAAGA,qBAAqB;EACpD;EACA1oE,KAAKA,CAACJ,OAAO,EAAES,OAAO,EAAE;IACtB,OAAOT,OAAO,CAAC+oE,cAAc,CAAC,IAAI,EAAEtoE,OAAO,CAAC;EAC9C;AACF;AACA,MAAMuoE,aAAa,CAAC;EAClB3uE,KAAK;EACL+G,UAAU;EACVoH,UAAU;EACVygE,eAAe;EACfC,aAAa;EACb9rE,WAAWA,CAAC/C,KAAK,EAAE+G,UAAU,EAAEoH,UAAU,EAAEygE,eAAe,EAAEC,aAAa,EAAE;IACzE,IAAI,CAAC7uE,KAAK,GAAGA,KAAK;IAClB,IAAI,CAAC+G,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACoH,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACygE,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,aAAa,GAAGA,aAAa;EACpC;EACA9oE,KAAKA,CAACJ,OAAO,EAAES,OAAO,EAAE;IACtB,OAAOT,OAAO,CAACmpE,kBAAkB,CAAC,IAAI,EAAE1oE,OAAO,CAAC;EAClD;AACF;AACA,MAAMyoD,SAAS,SAASwf,YAAY,CAAC;EACnCtuE,IAAI;EACJC,KAAK;EACL0/B,OAAO;EACPC,SAAS;EACTovC,WAAW;EACXhsE,WAAWA,CAAChD,IAAI,EAAEC,KAAK,EAAEmO,UAAU,EAAEuxB,OAAO,EAAEC,SAAS,EAAEovC,WAAW,EAAE/nD,IAAI,EAAE;IAC1E,KAAK,CAAC7Y,UAAU,EAAE6Y,IAAI,CAAC;IACvB,IAAI,CAACjnB,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAAC0/B,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACovC,WAAW,GAAGA,WAAW;EAChC;EACAhpE,KAAKA,CAACJ,OAAO,EAAES,OAAO,EAAE;IACtB,OAAOT,OAAO,CAACqpE,cAAc,CAAC,IAAI,EAAE5oE,OAAO,CAAC;EAC9C;AACF;AACA,MAAMu8B,OAAO,SAAS0rC,YAAY,CAAC;EACjCtuE,IAAI;EACJtC,KAAK;EACLslC,UAAU;EACVx8B,QAAQ;EACR08B,aAAa;EACbC,eAAe;EACfC,aAAa;EACbh8B,MAAM;EACNpE,WAAWA,CAAChD,IAAI,EAAEtC,KAAK,EAAEslC,UAAU,EAAEx8B,QAAQ,EAAE08B,aAAa,EAAE90B,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,GAAG,IAAI,EAAEh8B,MAAM,EAAE6f,IAAI,EAAE;IAC7H,KAAK,CAAC7Y,UAAU,EAAE6Y,IAAI,CAAC;IACvB,IAAI,CAACjnB,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACtC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACslC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACx8B,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC08B,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACh8B,MAAM,GAAGA,MAAM;EACtB;EACApB,KAAKA,CAACJ,OAAO,EAAES,OAAO,EAAE;IACtB,OAAOT,OAAO,CAACy9B,YAAY,CAAC,IAAI,EAAEh9B,OAAO,CAAC;EAC5C;AACF;AACA,MAAMo7B,OAAO,CAAC;EACZxhC,KAAK;EACLmO,UAAU;EACVpL,WAAWA,CAAC/C,KAAK,EAAEmO,UAAU,EAAE;IAC7B,IAAI,CAACnO,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACmO,UAAU,GAAGA,UAAU;EAC9B;EACApI,KAAKA,CAACJ,OAAO,EAAES,OAAO,EAAE;IACtB,OAAOT,OAAO,CAACspE,YAAY,CAAC,IAAI,EAAE7oE,OAAO,CAAC;EAC5C;AACF;AACA,MAAM8oE,KAAK,SAASb,YAAY,CAAC;EAC/BtuE,IAAI;EACJ+f,UAAU;EACVvZ,QAAQ;EACRq0B,QAAQ;EACRsI,eAAe;EACfC,aAAa;EACbpgC,WAAWA,CAAChD,IAAI,EAAE+f,UAAU,EAAEvZ,QAAQ,EAAE4H,UAAU,EAAEysB,QAAQ,EAAEsI,eAAe,EAAEC,aAAa,GAAG,IAAI,EAAEnc,IAAI,EAAE;IACzG,KAAK,CAAC7Y,UAAU,EAAE6Y,IAAI,CAAC;IACvB,IAAI,CAACjnB,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC+f,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACvZ,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACq0B,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACsI,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,aAAa,GAAGA,aAAa;EACpC;EACAp9B,KAAKA,CAACJ,OAAO,EAAES,OAAO,EAAE;IACtB,OAAOT,OAAO,CAACwpE,UAAU,CAAC,IAAI,EAAE/oE,OAAO,CAAC;EAC1C;AACF;AACA,MAAM8zB,SAAS,SAASm0C,YAAY,CAAC;EACnC7mC,aAAa;EACbtqB,OAAO;EACPkkB,QAAQ;EACR3jC,KAAK;EACLslC,UAAU;EACVx8B,QAAQ;EACR08B,aAAa;EACbC,eAAe;EACfC,aAAa;EACbpgC,WAAWA,CAACykC,aAAa,EAAEtqB,OAAO,EAAEkkB,QAAQ,EAAE3jC,KAAK,EAAEslC,UAAU,EAAEx8B,QAAQ,EAAE08B,aAAa,EAAE90B,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,GAAG,IAAI,EAAEnc,IAAI,EAAE;IACjJ,KAAK,CAAC7Y,UAAU,EAAE6Y,IAAI,CAAC;IACvB,IAAI,CAACwgB,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACtqB,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACkkB,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC3jC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACslC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACx8B,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC08B,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,aAAa,GAAGA,aAAa;EACpC;EACAp9B,KAAKA,CAACJ,OAAO,EAAES,OAAO,EAAE;IACtB,OAAOT,OAAO,CAAC8hC,cAAc,CAAC,IAAI,EAAErhC,OAAO,CAAC;EAC9C;AACF;AACA,MAAM+zB,SAAS,CAAC;EACdp6B,IAAI;EACJtC,KAAK;EACL0Q,UAAU;EACV+0B,eAAe;EACfC,aAAa;EACbpgC,WAAWA,CAAChD,IAAI,EAAEtC,KAAK,EAAE0Q,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,GAAG,IAAI,EAAE;IAC1E,IAAI,CAACpjC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACtC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAAC0Q,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAC+0B,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,aAAa,GAAGA,aAAa;EACpC;EACAp9B,KAAKA,CAACJ,OAAO,EAAES,OAAO,EAAE;IACtB,OAAOT,OAAO,CAACgiC,cAAc,CAAC,IAAI,EAAEvhC,OAAO,CAAC;EAC9C;AACF;AACA,MAAMgpE,cAAc,CAAC;EACnBroE,UAAU;EACVoH,UAAU;EACVpL,WAAWA,CAACgE,UAAU,EAAEoH,UAAU,EAAE;IAClC,IAAI,CAACpH,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACoH,UAAU,GAAGA,UAAU;EAC9B;EACApI,KAAKA,CAACJ,OAAO,EAAES,OAAO,EAAE;IACtB,OAAOT,OAAO,CAAC0pE,mBAAmB,CAAC,IAAI,EAAEjpE,OAAO,CAAC;EACnD;AACF;AACA,MAAMihC,cAAc,CAAC;EACnBtnC,IAAI;EACJC,KAAK;EACLmO,UAAU;EACVysB,QAAQ;EACR+E,SAAS;EACT58B,WAAWA,CAAChD,IAAI,EAAEC,KAAK,EAAEmO,UAAU,EAAEysB,QAAQ,EAAE+E,SAAS,EAAE;IACxD,IAAI,CAAC5/B,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACmO,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACysB,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC+E,SAAS,GAAGA,SAAS;EAC5B;EACA55B,KAAKA,CAACJ,OAAO,EAAES,OAAO,EAAE;IACtB,OAAOT,OAAO,CAAC2hC,mBAAmB,CAAC,IAAI,EAAElhC,OAAO,CAAC;EACnD;AACF;AACA,SAASm5B,QAAQA,CAAC55B,OAAO,EAAEJ,KAAK,EAAEa,OAAO,GAAG,IAAI,EAAE;EAChD,MAAMjH,MAAM,GAAG,EAAE;EACjB,MAAM4G,KAAK,GAAGJ,OAAO,CAACI,KAAK,GAAGqV,GAAG,IAAIzV,OAAO,CAACI,KAAK,CAACqV,GAAG,EAAEhV,OAAO,CAAC,IAAIgV,GAAG,CAACrV,KAAK,CAACJ,OAAO,EAAES,OAAO,CAAC,GAAGgV,GAAG,IAAIA,GAAG,CAACrV,KAAK,CAACJ,OAAO,EAAES,OAAO,CAAC;EACpIb,KAAK,CAACpF,OAAO,CAACib,GAAG,IAAI;IACnB,MAAMk0D,SAAS,GAAGvpE,KAAK,CAACqV,GAAG,CAAC;IAC5B,IAAIk0D,SAAS,EAAE;MACbnwE,MAAM,CAACjB,IAAI,CAACoxE,SAAS,CAAC;IACxB;EACF,CAAC,CAAC;EACF,OAAOnwE,MAAM;AACf;AACA,MAAM4pC,gBAAgB,CAAC;EACrBhmC,WAAWA,CAAA,EAAG,CAAC;EACfqgC,YAAYA,CAAChoB,GAAG,EAAEhV,OAAO,EAAE;IACzB,IAAI,CAACmpE,aAAa,CAACnpE,OAAO,EAAEL,KAAK,IAAI;MACnCA,KAAK,CAACqV,GAAG,CAAC3d,KAAK,CAAC;MAChBsI,KAAK,CAACqV,GAAG,CAAC2nB,UAAU,CAAC;MACrBh9B,KAAK,CAACqV,GAAG,CAAC7U,QAAQ,CAAC;IACrB,CAAC,CAAC;EACJ;EACAyoE,cAAcA,CAAC5zD,GAAG,EAAEhV,OAAO,EAAE,CAAC;EAC9BF,SAASA,CAACkV,GAAG,EAAEhV,OAAO,EAAE,CAAC;EACzB6oE,YAAYA,CAAC7zD,GAAG,EAAEhV,OAAO,EAAE,CAAC;EAC5BsoE,cAAcA,CAACtzD,GAAG,EAAEhV,OAAO,EAAE;IAC3B,OAAO,IAAI,CAACmpE,aAAa,CAACnpE,OAAO,EAAEL,KAAK,IAAI;MAC1CA,KAAK,CAACqV,GAAG,CAACvU,KAAK,CAAC;IAClB,CAAC,CAAC;EACJ;EACAioE,kBAAkBA,CAAC1zD,GAAG,EAAEhV,OAAO,EAAE,CAAC;EAClC+oE,UAAUA,CAAClmC,KAAK,EAAE7iC,OAAO,EAAE;IACzB,IAAI,CAACmpE,aAAa,CAACnpE,OAAO,EAAEL,KAAK,IAAI;MACnCA,KAAK,CAACkjC,KAAK,CAACnpB,UAAU,CAAC;MACvB/Z,KAAK,CAACkjC,KAAK,CAAC1iC,QAAQ,CAAC;IACvB,CAAC,CAAC;EACJ;EACA8oE,mBAAmBA,CAACj0D,GAAG,EAAEhV,OAAO,EAAE,CAAC;EACnCkhC,mBAAmBA,CAACgC,IAAI,EAAEljC,OAAO,EAAE,CAAC;EACpCqhC,cAAcA,CAAC0B,SAAS,EAAE/iC,OAAO,EAAE;IACjC,IAAI,CAACmpE,aAAa,CAACnpE,OAAO,EAAEL,KAAK,IAAI;MACnCA,KAAK,CAACojC,SAAS,CAAC1rC,KAAK,CAAC;MACtBsI,KAAK,CAACojC,SAAS,CAAC5iC,QAAQ,CAAC;IAC3B,CAAC,CAAC;EACJ;EACAohC,cAAcA,CAACyB,SAAS,EAAEhjC,OAAO,EAAE;IACjC,IAAI,CAACmpE,aAAa,CAACnpE,OAAO,EAAEL,KAAK,IAAI;MACnCA,KAAK,CAACqjC,SAAS,CAAC3rC,KAAK,CAAC;IACxB,CAAC,CAAC;EACJ;EACA8xE,aAAaA,CAACnpE,OAAO,EAAEopE,EAAE,EAAE;IACzB,IAAI3xE,OAAO,GAAG,EAAE;IAChB,IAAI25B,CAAC,GAAG,IAAI;IACZ,SAASzxB,KAAKA,CAACQ,QAAQ,EAAE;MACvB,IAAIA,QAAQ,EAAE1I,OAAO,CAACK,IAAI,CAACqhC,QAAQ,CAAC/H,CAAC,EAAEjxB,QAAQ,EAAEH,OAAO,CAAC,CAAC;IAC5D;IACAopE,EAAE,CAACzpE,KAAK,CAAC;IACT,OAAOyR,KAAK,CAAC6hC,SAAS,CAACv5C,MAAM,CAAC2vE,KAAK,CAAC,EAAE,EAAE5xE,OAAO,CAAC;EAClD;AACF;AAEA,MAAM6xE,cAAc,GAAG;EACrB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,cAAc;EACrB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,eAAe,EAAE,QAAQ;EACzB,IAAI,EAAE,QAAQ;EACd,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,WAAW,EAAE,QAAQ;EACrB,UAAU,EAAE,QAAQ;EACpB,OAAO,EAAE,QAAQ;EACjB,eAAe,EAAE,QAAQ;EACzB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,gBAAgB,EAAE,QAAQ;EAC1B,KAAK,EAAE,QAAQ;EACf,SAAS,EAAE,QAAQ;EACnB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,YAAY,EAAE,QAAQ;EACtB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,cAAc;EACrB,MAAM,EAAE,cAAc;EACtB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,cAAc,EAAE,QAAQ;EACxB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,sBAAsB,EAAE,QAAQ;EAChC,IAAI,EAAE,QAAQ;EACd,SAAS,EAAE,QAAQ;EACnB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,QAAQ;EAChB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,WAAW,EAAE,QAAQ;EACrB,WAAW,EAAE,QAAQ;EACrB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,WAAW,EAAE,QAAQ;EACrB,MAAM,EAAE,QAAQ;EAChB,aAAa,EAAE,QAAQ;EACvB,QAAQ,EAAE,QAAQ;EAClB,YAAY,EAAE,QAAQ;EACtB,OAAO,EAAE,QAAQ;EACjB,aAAa,EAAE,QAAQ;EACvB,QAAQ,EAAE,QAAQ;EAClB,0BAA0B,EAAE,QAAQ;EACpC,UAAU,EAAE,QAAQ;EACpB,uBAAuB,EAAE,QAAQ;EACjC,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,iBAAiB,EAAE,QAAQ;EAC3B,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,YAAY,EAAE,QAAQ;EACtB,QAAQ,EAAE,QAAQ;EAClB,WAAW,EAAE,QAAQ;EACrB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,uBAAuB,EAAE,QAAQ;EACjC,iBAAiB,EAAE,QAAQ;EAC3B,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,WAAW,EAAE,QAAQ;EACrB,WAAW,EAAE,QAAQ;EACrB,QAAQ,EAAE,QAAQ;EAClB,iCAAiC,EAAE,QAAQ;EAC3C,UAAU,EAAE,QAAQ;EACpB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,UAAU,EAAE,QAAQ;EACpB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,eAAe,EAAE,QAAQ;EACzB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,cAAc;EACrB,kBAAkB,EAAE,QAAQ;EAC5B,OAAO,EAAE,QAAQ;EACjB,gBAAgB,EAAE,QAAQ;EAC1B,KAAK,EAAE,QAAQ;EACf,wBAAwB,EAAE,QAAQ;EAClC,OAAO,EAAE,QAAQ;EACjB,kBAAkB,EAAE,QAAQ;EAC5B,OAAO,EAAE,QAAQ;EACjB,kBAAkB,EAAE,QAAQ;EAC5B,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,QAAQ;EAChB,SAAS,EAAE,QAAQ;EACnB,eAAe,EAAE,QAAQ;EACzB,IAAI,EAAE,QAAQ;EACd,MAAM,EAAE,cAAc;EACtB,KAAK,EAAE,QAAQ;EACf,WAAW,EAAE,QAAQ;EACrB,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,QAAQ;EACpB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,iBAAiB,EAAE,QAAQ;EAC3B,WAAW,EAAE,QAAQ;EACrB,MAAM,EAAE,QAAQ;EAChB,iBAAiB,EAAE,QAAQ;EAC3B,WAAW,EAAE,QAAQ;EACrB,MAAM,EAAE,QAAQ;EAChB,sBAAsB,EAAE,QAAQ;EAChC,gBAAgB,EAAE,QAAQ;EAC1B,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,QAAQ;EACf,qBAAqB,EAAE,QAAQ;EAC/B,eAAe,EAAE,QAAQ;EACzB,OAAO,EAAE,QAAQ;EACjB,0BAA0B,EAAE,QAAQ;EACpC,oBAAoB,EAAE,QAAQ;EAC9B,OAAO,EAAE,QAAQ;EACjB,sBAAsB,EAAE,QAAQ;EAChC,gBAAgB,EAAE,QAAQ;EAC1B,OAAO,EAAE,QAAQ;EACjB,kBAAkB,EAAE,QAAQ;EAC5B,SAAS,EAAE,QAAQ;EACnB,YAAY,EAAE,QAAQ;EACtB,MAAM,EAAE,QAAQ;EAChB,gBAAgB,EAAE,QAAQ;EAC1B,OAAO,EAAE,QAAQ;EACjB,eAAe,EAAE,QAAQ;EACzB,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,QAAQ;EAChB,mBAAmB,EAAE,QAAQ;EAC7B,aAAa,EAAE,QAAQ;EACvB,MAAM,EAAE,QAAQ;EAChB,mBAAmB,EAAE,QAAQ;EAC7B,KAAK,EAAE,QAAQ;EACf,UAAU,EAAE,QAAQ;EACpB,eAAe,EAAE,QAAQ;EACzB,MAAM,EAAE,QAAQ;EAChB,WAAW,EAAE,QAAQ;EACrB,gBAAgB,EAAE,QAAQ;EAC1B,MAAM,EAAE,QAAQ;EAChB,WAAW,EAAE,QAAQ;EACrB,cAAc,EAAE,QAAQ;EACxB,kBAAkB,EAAE,QAAQ;EAC5B,OAAO,EAAE,QAAQ;EACjB,WAAW,EAAE,QAAQ;EACrB,qBAAqB,EAAE,QAAQ;EAC/B,mBAAmB,EAAE,QAAQ;EAC7B,gBAAgB,EAAE,QAAQ;EAC1B,iBAAiB,EAAE,QAAQ;EAC3B,OAAO,EAAE,QAAQ;EACjB,mBAAmB,EAAE,QAAQ;EAC7B,oBAAoB,EAAE,QAAQ;EAC9B,iBAAiB,EAAE,QAAQ;EAC3B,OAAO,EAAE,QAAQ;EACjB,kBAAkB,EAAE,QAAQ;EAC5B,oBAAoB,EAAE,QAAQ;EAC9B,SAAS,EAAE,QAAQ;EACnB,KAAK,EAAE,QAAQ;EACf,cAAc,EAAE,QAAQ;EACxB,YAAY,EAAE,QAAQ;EACtB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,cAAc;EACrB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,IAAI,EAAE,QAAQ;EACd,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,kBAAkB,EAAE,QAAQ;EAC5B,sBAAsB,EAAE,QAAQ;EAChC,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,YAAY,EAAE,QAAQ;EACtB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,aAAa,EAAE,QAAQ;EACvB,mBAAmB,EAAE,QAAQ;EAC7B,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,aAAa,EAAE,QAAQ;EACvB,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,cAAc,EAAE,QAAQ;EACxB,IAAI,EAAE,QAAQ;EACd,cAAc,EAAE,QAAQ;EACxB,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,cAAc;EACrB,mBAAmB,EAAE,QAAQ;EAC7B,uBAAuB,EAAE,QAAQ;EACjC,aAAa,EAAE,QAAQ;EACvB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,YAAY,EAAE,QAAQ;EACtB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,IAAI,EAAE,QAAQ;EACd,IAAI,EAAE,QAAQ;EACd,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,cAAc;EACrB,IAAI,EAAE,QAAQ;EACd,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,cAAc;EACtB,cAAc,EAAE,QAAQ;EACxB,IAAI,EAAE,QAAQ;EACd,KAAK,EAAE,QAAQ;EACf,kBAAkB,EAAE,QAAQ;EAC5B,KAAK,EAAE,QAAQ;EACf,WAAW,EAAE,QAAQ;EACrB,kBAAkB,EAAE,QAAQ;EAC5B,IAAI,EAAE,QAAQ;EACd,MAAM,EAAE,QAAQ;EAChB,gBAAgB,EAAE,QAAQ;EAC1B,aAAa,EAAE,QAAQ;EACvB,IAAI,EAAE,QAAQ;EACd,SAAS,EAAE,QAAQ;EACnB,mBAAmB,EAAE,QAAQ;EAC7B,UAAU,EAAE,QAAQ;EACpB,KAAK,EAAE,QAAQ;EACf,cAAc,EAAE,QAAQ;EACxB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,cAAc;EACtB,IAAI,EAAE,QAAQ;EACd,sBAAsB,EAAE,QAAQ;EAChC,IAAI,EAAE,QAAQ;EACd,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,eAAe,EAAE,QAAQ;EACzB,cAAc,EAAE,QAAQ;EACxB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,aAAa,EAAE,QAAQ;EACvB,gBAAgB,EAAE,QAAQ;EAC1B,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,WAAW,EAAE,QAAQ;EACrB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,QAAQ;EACf,IAAI,EAAE,QAAQ;EACd,OAAO,EAAE,QAAQ;EACjB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,YAAY,EAAE,QAAQ;EACtB,IAAI,EAAE,QAAQ;EACd,KAAK,EAAE,QAAQ;EACf,UAAU,EAAE,QAAQ;EACpB,KAAK,EAAE,QAAQ;EACf,cAAc,EAAE,QAAQ;EACxB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,gBAAgB,EAAE,QAAQ;EAC1B,IAAI,EAAE,QAAQ;EACd,gBAAgB,EAAE,QAAQ;EAC1B,IAAI,EAAE,QAAQ;EACd,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,cAAc;EACrB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,cAAc;EACrB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,QAAQ;EAChB,IAAI,EAAE,QAAQ;EACd,IAAI,EAAE,QAAQ;EACd,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,YAAY,EAAE,QAAQ;EACtB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,kBAAkB,EAAE,QAAQ;EAC5B,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,kBAAkB,EAAE,QAAQ;EAC5B,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,WAAW,EAAE,QAAQ;EACrB,gBAAgB,EAAE,QAAQ;EAC1B,MAAM,EAAE,QAAQ;EAChB,WAAW,EAAE,QAAQ;EACrB,OAAO,EAAE,QAAQ;EACjB,cAAc,EAAE,QAAQ;EACxB,OAAO,EAAE,QAAQ;EACjB,qBAAqB,EAAE,QAAQ;EAC/B,iBAAiB,EAAE,QAAQ;EAC3B,OAAO,EAAE,QAAQ;EACjB,aAAa,EAAE,QAAQ;EACvB,OAAO,EAAE,QAAQ;EACjB,mBAAmB,EAAE,QAAQ;EAC7B,OAAO,EAAE,QAAQ;EACjB,mBAAmB,EAAE,QAAQ;EAC7B,gBAAgB,EAAE,QAAQ;EAC1B,OAAO,EAAE,QAAQ;EACjB,iBAAiB,EAAE,QAAQ;EAC3B,mBAAmB,EAAE,QAAQ;EAC7B,WAAW,EAAE,QAAQ;EACrB,QAAQ,EAAE,QAAQ;EAClB,gBAAgB,EAAE,QAAQ;EAC1B,MAAM,EAAE,QAAQ;EAChB,gBAAgB,EAAE,QAAQ;EAC1B,iBAAiB,EAAE,QAAQ;EAC3B,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,cAAc,EAAE,QAAQ;EACxB,YAAY,EAAE,QAAQ;EACtB,eAAe,EAAE,QAAQ;EACzB,cAAc,EAAE,QAAQ;EACxB,iBAAiB,EAAE,QAAQ;EAC3B,OAAO,EAAE,QAAQ;EACjB,iBAAiB,EAAE,QAAQ;EAC3B,mBAAmB,EAAE,QAAQ;EAC7B,OAAO,EAAE,QAAQ;EACjB,gBAAgB,EAAE,QAAQ;EAC1B,kBAAkB,EAAE,QAAQ;EAC5B,iBAAiB,EAAE,QAAQ;EAC3B,cAAc,EAAE,QAAQ;EACxB,OAAO,EAAE,QAAQ;EACjB,eAAe,EAAE,QAAQ;EACzB,iBAAiB,EAAE,QAAQ;EAC3B,YAAY,EAAE,QAAQ;EACtB,eAAe,EAAE,QAAQ;EACzB,OAAO,EAAE,QAAQ;EACjB,eAAe,EAAE,QAAQ;EACzB,kBAAkB,EAAE,QAAQ;EAC5B,KAAK,EAAE,QAAQ;EACf,WAAW,EAAE,QAAQ;EACrB,eAAe,EAAE,QAAQ;EACzB,IAAI,EAAE,QAAQ;EACd,MAAM,EAAE,QAAQ;EAChB,aAAa,EAAE,QAAQ;EACvB,SAAS,EAAE,QAAQ;EACnB,IAAI,EAAE,QAAQ;EACd,UAAU,EAAE,QAAQ;EACpB,gBAAgB,EAAE,QAAQ;EAC1B,UAAU,EAAE,QAAQ;EACpB,KAAK,EAAE,QAAQ;EACf,WAAW,EAAE,QAAQ;EACrB,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,cAAc;EACrB,IAAI,EAAE,QAAQ;EACd,YAAY,EAAE,QAAQ;EACtB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,eAAe,EAAE,QAAQ;EACzB,eAAe,EAAE,QAAQ;EACzB,OAAO,EAAE,QAAQ;EACjB,oBAAoB,EAAE,QAAQ;EAC9B,oBAAoB,EAAE,QAAQ;EAC9B,OAAO,EAAE,QAAQ;EACjB,gBAAgB,EAAE,QAAQ;EAC1B,gBAAgB,EAAE,QAAQ;EAC1B,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,gBAAgB,EAAE,QAAQ;EAC1B,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,iBAAiB,EAAE,QAAQ;EAC3B,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,IAAI,EAAE,QAAQ;EACd,gBAAgB,EAAE,QAAQ;EAC1B,IAAI,EAAE,QAAQ;EACd,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,QAAQ;EACf,aAAa,EAAE,QAAQ;EACvB,WAAW,EAAE,QAAQ;EACrB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,cAAc;EACrB,WAAW,EAAE,QAAQ;EACrB,QAAQ,EAAE,QAAQ;EAClB,IAAI,EAAE,QAAQ;EACd,MAAM,EAAE,cAAc;EACtB,IAAI,EAAE,QAAQ;EACd,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,qBAAqB,EAAE,QAAQ;EAC/B,oBAAoB,EAAE,QAAQ;EAC9B,mBAAmB,EAAE,QAAQ;EAC7B,uBAAuB,EAAE,QAAQ;EACjC,gBAAgB,EAAE,QAAQ;EAC1B,SAAS,EAAE,QAAQ;EACnB,KAAK,EAAE,cAAc;EACrB,SAAS,EAAE,QAAQ;EACnB,kBAAkB,EAAE,QAAQ;EAC5B,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,UAAU,EAAE,QAAQ;EACpB,KAAK,EAAE,QAAQ;EACf,cAAc,EAAE,QAAQ;EACxB,QAAQ,EAAE,QAAQ;EAClB,WAAW,EAAE,QAAQ;EACrB,sBAAsB,EAAE,QAAQ;EAChC,MAAM,EAAE,QAAQ;EAChB,WAAW,EAAE,QAAQ;EACrB,gBAAgB,EAAE,QAAQ;EAC1B,OAAO,EAAE,QAAQ;EACjB,YAAY,EAAE,QAAQ;EACtB,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,UAAU,EAAE,QAAQ;EACpB,IAAI,EAAE,QAAQ;EACd,eAAe,EAAE,cAAc;EAC/B,OAAO,EAAE,cAAc;EACvB,WAAW,EAAE,QAAQ;EACrB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,YAAY,EAAE,QAAQ;EACtB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,iBAAiB,EAAE,QAAQ;EAC3B,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,qBAAqB,EAAE,cAAc;EACrC,KAAK,EAAE,cAAc;EACrB,OAAO,EAAE,cAAc;EACvB,mBAAmB,EAAE,cAAc;EACnC,MAAM,EAAE,cAAc;EACtB,gBAAgB,EAAE,QAAQ;EAC1B,MAAM,EAAE,QAAQ;EAChB,sBAAsB,EAAE,cAAc;EACtC,WAAW,EAAE,cAAc;EAC3B,MAAM,EAAE,cAAc;EACtB,iBAAiB,EAAE,QAAQ;EAC3B,OAAO,EAAE,QAAQ;EACjB,iBAAiB,EAAE,cAAc;EACjC,OAAO,EAAE,cAAc;EACvB,cAAc,EAAE,cAAc;EAC9B,QAAQ,EAAE,cAAc;EACxB,iBAAiB,EAAE,QAAQ;EAC3B,OAAO,EAAE,QAAQ;EACjB,eAAe,EAAE,QAAQ;EACzB,oBAAoB,EAAE,cAAc;EACpC,sBAAsB,EAAE,QAAQ;EAChC,QAAQ,EAAE,QAAQ;EAClB,iBAAiB,EAAE,QAAQ;EAC3B,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,cAAc,EAAE,QAAQ;EACxB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,gBAAgB,EAAE,QAAQ;EAC1B,MAAM,EAAE,QAAQ;EAChB,aAAa,EAAE,cAAc;EAC7B,MAAM,EAAE,cAAc;EACtB,mBAAmB,EAAE,cAAc;EACnC,WAAW,EAAE,cAAc;EAC3B,MAAM,EAAE,cAAc;EACtB,cAAc,EAAE,QAAQ;EACxB,OAAO,EAAE,QAAQ;EACjB,yBAAyB,EAAE,cAAc;EACzC,mBAAmB,EAAE,cAAc;EACnC,aAAa,EAAE,QAAQ;EACvB,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,kBAAkB,EAAE,cAAc;EAClC,MAAM,EAAE,cAAc;EACtB,SAAS,EAAE,cAAc;EACzB,uBAAuB,EAAE,QAAQ;EACjC,QAAQ,EAAE,QAAQ;EAClB,mBAAmB,EAAE,QAAQ;EAC7B,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,kBAAkB,EAAE,QAAQ;EAC5B,OAAO,EAAE,QAAQ;EACjB,gBAAgB,EAAE,QAAQ;EAC1B,qBAAqB,EAAE,cAAc;EACrC,uBAAuB,EAAE,QAAQ;EACjC,QAAQ,EAAE,QAAQ;EAClB,kBAAkB,EAAE,QAAQ;EAC5B,iBAAiB,EAAE,cAAc;EACjC,sBAAsB,EAAE,QAAQ;EAChC,SAAS,EAAE,QAAQ;EACnB,mBAAmB,EAAE,cAAc;EACnC,wBAAwB,EAAE,QAAQ;EAClC,SAAS,EAAE,QAAQ;EACnB,WAAW,EAAE,cAAc;EAC3B,SAAS,EAAE,cAAc;EACzB,OAAO,EAAE,cAAc;EACvB,gBAAgB,EAAE,QAAQ;EAC1B,OAAO,EAAE,QAAQ;EACjB,WAAW,EAAE,QAAQ;EACrB,aAAa,EAAE,QAAQ;EACvB,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,kBAAkB,EAAE,cAAc;EAClC,MAAM,EAAE,cAAc;EACtB,SAAS,EAAE,cAAc;EACzB,uBAAuB,EAAE,QAAQ;EACjC,QAAQ,EAAE,QAAQ;EAClB,kBAAkB,EAAE,cAAc;EAClC,aAAa,EAAE,cAAc;EAC7B,SAAS,EAAE,cAAc;EACzB,OAAO,EAAE,cAAc;EACvB,kBAAkB,EAAE,QAAQ;EAC5B,OAAO,EAAE,QAAQ;EACjB,WAAW,EAAE,QAAQ;EACrB,UAAU,EAAE,QAAQ;EACpB,MAAM,EAAE,QAAQ;EAChB,eAAe,EAAE,QAAQ;EACzB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,mBAAmB,EAAE,QAAQ;EAC7B,OAAO,EAAE,QAAQ;EACjB,eAAe,EAAE,QAAQ;EACzB,KAAK,EAAE,QAAQ;EACf,SAAS,EAAE,QAAQ;EACnB,gBAAgB,EAAE,QAAQ;EAC1B,MAAM,EAAE,QAAQ;EAChB,WAAW,EAAE,QAAQ;EACrB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,IAAI,EAAE,QAAQ;EACd,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,cAAc;EACrB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,cAAc;EACtB,sBAAsB,EAAE,QAAQ;EAChC,OAAO,EAAE,QAAQ;EACjB,gBAAgB,EAAE,QAAQ;EAC1B,OAAO,EAAE,QAAQ;EACjB,IAAI,EAAE,QAAQ;EACd,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,WAAW,EAAE,QAAQ;EACrB,aAAa,EAAE,QAAQ;EACvB,MAAM,EAAE,QAAQ;EAChB,iBAAiB,EAAE,QAAQ;EAC3B,UAAU,EAAE,QAAQ;EACpB,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,cAAc;EACrB,KAAK,EAAE,QAAQ;EACf,IAAI,EAAE,QAAQ;EACd,WAAW,EAAE,QAAQ;EACrB,QAAQ,EAAE,QAAQ;EAClB,IAAI,EAAE,QAAQ;EACd,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,IAAI,EAAE,QAAQ;EACd,UAAU,EAAE,QAAQ;EACpB,IAAI,EAAE,QAAQ;EACd,MAAM,EAAE,QAAQ;EAChB,eAAe,EAAE,QAAQ;EACzB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,oBAAoB,EAAE,QAAQ;EAC9B,OAAO,EAAE,QAAQ;EACjB,aAAa,EAAE,QAAQ;EACvB,eAAe,EAAE,QAAQ;EACzB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,QAAQ;EAChB,cAAc,EAAE,QAAQ;EACxB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,WAAW,EAAE,QAAQ;EACrB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,cAAc;EACrB,MAAM,EAAE,QAAQ;EAChB,WAAW,EAAE,QAAQ;EACrB,MAAM,EAAE,cAAc;EACtB,OAAO,EAAE,QAAQ;EACjB,UAAU,EAAE,QAAQ;EACpB,KAAK,EAAE,QAAQ;EACf,UAAU,EAAE,QAAQ;EACpB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,mBAAmB,EAAE,QAAQ;EAC7B,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,IAAI,EAAE,QAAQ;EACd,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,UAAU,EAAE,QAAQ;EACpB,gBAAgB,EAAE,QAAQ;EAC1B,UAAU,EAAE,QAAQ;EACpB,IAAI,EAAE,QAAQ;EACd,KAAK,EAAE,QAAQ;EACf,oBAAoB,EAAE,QAAQ;EAC9B,mBAAmB,EAAE,QAAQ;EAC7B,OAAO,EAAE,QAAQ;EACjB,sBAAsB,EAAE,QAAQ;EAChC,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,mBAAmB,EAAE,QAAQ;EAC7B,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,YAAY,EAAE,QAAQ;EACtB,iBAAiB,EAAE,QAAQ;EAC3B,MAAM,EAAE,QAAQ;EAChB,YAAY,EAAE,QAAQ;EACtB,OAAO,EAAE,QAAQ;EACjB,eAAe,EAAE,QAAQ;EACzB,OAAO,EAAE,QAAQ;EACjB,qBAAqB,EAAE,QAAQ;EAC/B,iBAAiB,EAAE,QAAQ;EAC3B,OAAO,EAAE,QAAQ;EACjB,cAAc,EAAE,QAAQ;EACxB,OAAO,EAAE,QAAQ;EACjB,oBAAoB,EAAE,QAAQ;EAC9B,OAAO,EAAE,QAAQ;EACjB,oBAAoB,EAAE,QAAQ;EAC9B,iBAAiB,EAAE,QAAQ;EAC3B,OAAO,EAAE,QAAQ;EACjB,kBAAkB,EAAE,QAAQ;EAC5B,oBAAoB,EAAE,QAAQ;EAC9B,YAAY,EAAE,QAAQ;EACtB,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,QAAQ;EACpB,OAAO,EAAE,QAAQ;EACjB,eAAe,EAAE,QAAQ;EACzB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,gBAAgB,EAAE,QAAQ;EAC1B,eAAe,EAAE,QAAQ;EACzB,kBAAkB,EAAE,QAAQ;EAC5B,OAAO,EAAE,QAAQ;EACjB,kBAAkB,EAAE,QAAQ;EAC5B,oBAAoB,EAAE,QAAQ;EAC9B,OAAO,EAAE,QAAQ;EACjB,iBAAiB,EAAE,QAAQ;EAC3B,mBAAmB,EAAE,QAAQ;EAC7B,kBAAkB,EAAE,QAAQ;EAC5B,eAAe,EAAE,QAAQ;EACzB,OAAO,EAAE,QAAQ;EACjB,gBAAgB,EAAE,QAAQ;EAC1B,kBAAkB,EAAE,QAAQ;EAC5B,aAAa,EAAE,QAAQ;EACvB,OAAO,EAAE,QAAQ;EACjB,gBAAgB,EAAE,QAAQ;EAC1B,gBAAgB,EAAE,QAAQ;EAC1B,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,cAAc,EAAE,QAAQ;EACxB,aAAa,EAAE,QAAQ;EACvB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,SAAS,EAAE,QAAQ;EACnB,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,QAAQ;EACf,aAAa,EAAE,QAAQ;EACvB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,IAAI,EAAE,QAAQ;EACd,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,cAAc;EACrB,cAAc,EAAE,QAAQ;EACxB,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,QAAQ;EAChB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,aAAa,EAAE,QAAQ;EACvB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,oBAAoB,EAAE,QAAQ;EAC9B,OAAO,EAAE,QAAQ;EACjB,cAAc,EAAE,QAAQ;EACxB,OAAO,EAAE,QAAQ;EACjB,UAAU,EAAE,QAAQ;EACpB,mBAAmB,EAAE,QAAQ;EAC7B,QAAQ,EAAE,QAAQ;EAClB,YAAY,EAAE,QAAQ;EACtB,gBAAgB,EAAE,QAAQ;EAC1B,OAAO,EAAE,QAAQ;EACjB,UAAU,EAAE,QAAQ;EACpB,qBAAqB,EAAE,QAAQ;EAC/B,QAAQ,EAAE,QAAQ;EAClB,YAAY,EAAE,QAAQ;EACtB,aAAa,EAAE,QAAQ;EACvB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,aAAa,EAAE,QAAQ;EACvB,MAAM,EAAE,QAAQ;EAChB,UAAU,EAAE,QAAQ;EACpB,UAAU,EAAE,QAAQ;EACpB,IAAI,EAAE,QAAQ;EACd,MAAM,EAAE,QAAQ;EAChB,eAAe,EAAE,QAAQ;EACzB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,oBAAoB,EAAE,QAAQ;EAC9B,OAAO,EAAE,QAAQ;EACjB,aAAa,EAAE,QAAQ;EACvB,eAAe,EAAE,QAAQ;EACzB,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,QAAQ;EACpB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,eAAe,EAAE,QAAQ;EACzB,MAAM,EAAE,QAAQ;EAChB,UAAU,EAAE,QAAQ;EACpB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,cAAc;EACrB,WAAW,EAAE,QAAQ;EACrB,QAAQ,EAAE,QAAQ;EAClB,WAAW,EAAE,QAAQ;EACrB,OAAO,EAAE,QAAQ;EACjB,YAAY,EAAE,cAAc;EAC5B,WAAW,EAAE,QAAQ;EACrB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,YAAY,EAAE,QAAQ;EACtB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,gBAAgB,EAAE,QAAQ;EAC1B,MAAM,EAAE,QAAQ;EAChB,YAAY,EAAE,QAAQ;EACtB,IAAI,EAAE,QAAQ;EACd,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,aAAa,EAAE,QAAQ;EACvB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,WAAW,EAAE,QAAQ;EACrB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,UAAU,EAAE,QAAQ;EACpB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,cAAc;EACrB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,YAAY,EAAE,QAAQ;EACtB,cAAc,EAAE,QAAQ;EACxB,MAAM,EAAE,QAAQ;EAChB,kBAAkB,EAAE,QAAQ;EAC5B,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,WAAW,EAAE,QAAQ;EACrB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,YAAY,EAAE,QAAQ;EACtB,kBAAkB,EAAE,QAAQ;EAC5B,OAAO,EAAE,QAAQ;EACjB,aAAa,EAAE,QAAQ;EACvB,aAAa,EAAE,QAAQ;EACvB,MAAM,EAAE,QAAQ;EAChB,eAAe,EAAE,QAAQ;EACzB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,YAAY,EAAE,QAAQ;EACtB,UAAU,EAAE,QAAQ;EACpB,gBAAgB,EAAE,QAAQ;EAC1B,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,iBAAiB,EAAE,QAAQ;EAC3B,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,aAAa,EAAE,QAAQ;EACvB,KAAK,EAAE,QAAQ;EACf,UAAU,EAAE,QAAQ;EACpB,MAAM,EAAE,QAAQ;EAChB,cAAc,EAAE,QAAQ;EACxB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,mBAAmB,EAAE,QAAQ;EAC7B,eAAe,EAAE,QAAQ;EACzB,IAAI,EAAE,QAAQ;EACd,QAAQ,EAAE,QAAQ;EAClB,eAAe,EAAE,QAAQ;EACzB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,cAAc;EACrB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,cAAc;EACrB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,cAAc;EACtB,KAAK,EAAE,cAAc;EACrB,IAAI,EAAE,QAAQ;EACd,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,cAAc;EACrB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,UAAU,EAAE,QAAQ;EACpB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,IAAI,EAAE,QAAQ;EACd,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,cAAc;EACrB,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,cAAc;EACrB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,UAAU,EAAE,QAAQ;EACpB,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,eAAe,EAAE,QAAQ;EACzB,UAAU,EAAE,QAAQ;EACpB,UAAU,EAAE,QAAQ;EACpB,UAAU,EAAE,QAAQ;EACpB,UAAU,EAAE,QAAQ;EACpB,UAAU,EAAE,QAAQ;EACpB,UAAU,EAAE,QAAQ;EACpB,UAAU,EAAE,QAAQ;EACpB,UAAU,EAAE,QAAQ;EACpB,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,UAAU,EAAE,QAAQ;EACpB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,UAAU,EAAE,QAAQ;EACpB,OAAO,EAAE,QAAQ;EACjB,aAAa,EAAE,QAAQ;EACvB,OAAO,EAAE,QAAQ;EACjB,WAAW,EAAE,QAAQ;EACrB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,QAAQ;EAChB,WAAW,EAAE,QAAQ;EACrB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,QAAQ;EACpB,UAAU,EAAE,QAAQ;EACpB,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,cAAc;EACrB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,WAAW,EAAE,QAAQ;EACrB,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,iBAAiB,EAAE,QAAQ;EAC3B,OAAO,EAAE,QAAQ;EACjB,eAAe,EAAE,QAAQ;EACzB,OAAO,EAAE,QAAQ;EACjB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,cAAc,EAAE,QAAQ;EACxB,MAAM,EAAE,QAAQ;EAChB,eAAe,EAAE,QAAQ;EACzB,OAAO,EAAE,QAAQ;EACjB,mBAAmB,EAAE,QAAQ;EAC7B,OAAO,EAAE,QAAQ;EACjB,mBAAmB,EAAE,QAAQ;EAC7B,OAAO,EAAE,QAAQ;EACjB,oBAAoB,EAAE,QAAQ;EAC9B,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,cAAc;EACrB,SAAS,EAAE,cAAc;EACzB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,cAAc;EACtB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,UAAU,EAAE,QAAQ;EACpB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,cAAc;EACtB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,QAAQ;EAChB,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,cAAc;EACrB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,WAAW,EAAE,QAAQ;EACrB,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,iBAAiB,EAAE,QAAQ;EAC3B,OAAO,EAAE,QAAQ;EACjB,kBAAkB,EAAE,QAAQ;EAC5B,OAAO,EAAE,QAAQ;EACjB,UAAU,EAAE,QAAQ;EACpB,IAAI,EAAE,QAAQ;EACd,YAAY,EAAE,QAAQ;EACtB,MAAM,EAAE,QAAQ;EAChB,aAAa,EAAE,QAAQ;EACvB,MAAM,EAAE,QAAQ;EAChB,aAAa,EAAE,QAAQ;EACvB,OAAO,EAAE,QAAQ;EACjB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,UAAU,EAAE,QAAQ;EACpB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,YAAY,EAAE,QAAQ;EACtB,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,aAAa,EAAE,QAAQ;EACvB,OAAO,EAAE,QAAQ;EACjB,aAAa,EAAE,QAAQ;EACvB,QAAQ,EAAE,QAAQ;EAClB,gBAAgB,EAAE,QAAQ;EAC1B,SAAS,EAAE,QAAQ;EACnB,KAAK,EAAE,QAAQ;EACf,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,iBAAiB,EAAE,QAAQ;EAC3B,SAAS,EAAE,QAAQ;EACnB,UAAU,EAAE,QAAQ;EACpB,OAAO,EAAE,QAAQ;EACjB,YAAY,EAAE,QAAQ;EACtB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,gBAAgB,EAAE,QAAQ;EAC1B,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,cAAc;EACrB,aAAa,EAAE,QAAQ;EACvB,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,eAAe,EAAE,QAAQ;EACzB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,cAAc;EACtB,UAAU,EAAE,QAAQ;EACpB,MAAM,EAAE,QAAQ;EAChB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,QAAQ,EAAE,QAAQ;EAClB,WAAW,EAAE,QAAQ;EACrB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,cAAc,EAAE,QAAQ;EACxB,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,QAAQ;EAChB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,eAAe,EAAE,QAAQ;EACzB,KAAK,EAAE,cAAc;EACrB,IAAI,EAAE,QAAQ;EACd,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,YAAY,EAAE,QAAQ;EACtB,QAAQ,EAAE,QAAQ;EAClB,IAAI,EAAE,QAAQ;EACd,UAAU,EAAE,QAAQ;EACpB,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,QAAQ;EACf,aAAa,EAAE,QAAQ;EACvB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,YAAY,EAAE,QAAQ;EACtB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,iBAAiB,EAAE,QAAQ;EAC3B,YAAY,EAAE,QAAQ;EACtB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,SAAS,EAAE,QAAQ;EACnB,UAAU,EAAE,QAAQ;EACpB,OAAO,EAAE,QAAQ;EACjB,cAAc,EAAE,QAAQ;EACxB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,cAAc;EACrB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,cAAc;EACvB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,QAAQ;EAChB,WAAW,EAAE,QAAQ;EACrB,OAAO,EAAE,QAAQ;EACjB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,cAAc;EACtB,KAAK,EAAE,QAAQ;EACf,YAAY,EAAE,QAAQ;EACtB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,WAAW,EAAE,QAAQ;EACrB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,UAAU,EAAE,QAAQ;EACpB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,cAAc;EACrB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,UAAU,EAAE,QAAQ;EACpB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,QAAQ,EAAE,QAAQ;EAClB,WAAW,EAAE,cAAc;EAC3B,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,qBAAqB,EAAE,QAAQ;EAC/B,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,WAAW,EAAE,QAAQ;EACrB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,cAAc;EACrB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,eAAe,EAAE,QAAQ;EACzB,QAAQ,EAAE,QAAQ;EAClB,gBAAgB,EAAE,QAAQ;EAC1B,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,cAAc;EACrB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,QAAQ;EACpB,UAAU,EAAE,QAAQ;EACpB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,cAAc;EACtB,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,cAAc;EACrB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,cAAc;EACrB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,YAAY,EAAE,QAAQ;EACtB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,YAAY,EAAE,QAAQ;EACtB,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,eAAe,EAAE,QAAQ;EACzB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,QAAQ,EAAE,QAAQ;EAClB,eAAe,EAAE,QAAQ;EACzB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,cAAc;EACvB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,SAAS,EAAE,QAAQ;EACnB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,SAAS,EAAE,QAAQ;EACnB,UAAU,EAAE,QAAQ;EACpB,MAAM,EAAE,QAAQ;EAChB,IAAI,EAAE,QAAQ;EACd,KAAK,EAAE,QAAQ;EACf,gBAAgB,EAAE,QAAQ;EAC1B,OAAO,EAAE,QAAQ;EACjB,gBAAgB,EAAE,QAAQ;EAC1B,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,UAAU,EAAE,QAAQ;EACpB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,cAAc;EACrB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,YAAY,EAAE,QAAQ;EACtB,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,UAAU,EAAE,QAAQ;EACpB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,YAAY,EAAE,QAAQ;EACtB,MAAM,EAAE,QAAQ;EAChB,gBAAgB,EAAE,QAAQ;EAC1B,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,cAAc;EACtB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,cAAc,EAAE,QAAQ;EACxB,UAAU,EAAE,QAAQ;EACpB,SAAS,EAAE,QAAQ;EACnB,WAAW,EAAE,cAAc;EAC3B,MAAM,EAAE,cAAc;EACtB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,SAAS,EAAE,QAAQ;EACnB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,cAAc;EACrB,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,cAAc;EACtB,IAAI,EAAE,QAAQ;EACd,UAAU,EAAE,QAAQ;EACpB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,cAAc;EACrB,KAAK,EAAE,cAAc;EACrB,YAAY,EAAE,QAAQ;EACtB,OAAO,EAAE,QAAQ;EACjB,iBAAiB,EAAE,QAAQ;EAC3B,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,cAAc;EACrB,KAAK,EAAE,cAAc;EACrB,aAAa,EAAE,QAAQ;EACvB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,cAAc;EACtB,OAAO,EAAE,cAAc;EACvB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,cAAc;EAC1B,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,cAAc;EACvB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,cAAc;EACrB,OAAO,EAAE,QAAQ;EACjB,iBAAiB,EAAE,QAAQ;EAC3B,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,cAAc;EACrB,OAAO,EAAE,cAAc;EACvB,OAAO,EAAE,QAAQ;EACjB,YAAY,EAAE,QAAQ;EACtB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,cAAc;EACtB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,cAAc;EACxB,UAAU,EAAE,cAAc;EAC1B,SAAS,EAAE,QAAQ;EACnB,SAAS,EAAE,QAAQ;EACnB,SAAS,EAAE,QAAQ;EACnB,SAAS,EAAE,QAAQ;EACnB,QAAQ,EAAE,cAAc;EACxB,OAAO,EAAE,cAAc;EACvB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,aAAa,EAAE,QAAQ;EACvB,QAAQ,EAAE,cAAc;EACxB,QAAQ,EAAE,cAAc;EACxB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,cAAc;EACvB,YAAY,EAAE,cAAc;EAC5B,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,cAAc;EACvB,YAAY,EAAE,cAAc;EAC5B,QAAQ,EAAE,QAAQ;EAClB,IAAI,EAAE,QAAQ;EACd,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,cAAc;EACtB,SAAS,EAAE,QAAQ;EACnB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,cAAc;EACtB,SAAS,EAAE,cAAc;EACzB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,cAAc;EACzB,OAAO,EAAE,cAAc;EACvB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,cAAc;EACrB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,IAAI,EAAE,QAAQ;EACd,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,SAAS,EAAE,QAAQ;EACnB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,QAAQ;EACpB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,KAAK,EAAE,cAAc;EACrB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,aAAa,EAAE,QAAQ;EACvB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,IAAI,EAAE,QAAQ;EACd,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,QAAQ;EAChB,UAAU,EAAE,QAAQ;EACpB,SAAS,EAAE,QAAQ;EACnB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,SAAS,EAAE,QAAQ;EACnB,UAAU,EAAE,QAAQ;EACpB,MAAM,EAAE,cAAc;EACtB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,YAAY,EAAE,QAAQ;EACtB,aAAa,EAAE,QAAQ;EACvB,OAAO,EAAE,QAAQ;EACjB,UAAU,EAAE,QAAQ;EACpB,MAAM,EAAE,QAAQ;EAChB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,UAAU,EAAE,QAAQ;EACpB,UAAU,EAAE,QAAQ;EACpB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,cAAc;EACtB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,cAAc;EACrB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,cAAc;EACtB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,QAAQ;EACpB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,QAAQ,EAAE,QAAQ;EAClB,gBAAgB,EAAE,QAAQ;EAC1B,OAAO,EAAE,QAAQ;EACjB,iBAAiB,EAAE,QAAQ;EAC3B,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,SAAS,EAAE,QAAQ;EACnB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,cAAc;EACrB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,kBAAkB,EAAE,QAAQ;EAC5B,OAAO,EAAE,QAAQ;EACjB,iBAAiB,EAAE,QAAQ;EAC3B,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,YAAY,EAAE,QAAQ;EACtB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,eAAe,EAAE,QAAQ;EACzB,UAAU,EAAE,QAAQ;EACpB,SAAS,EAAE,QAAQ;EACnB,IAAI,EAAE,QAAQ;EACd,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,YAAY,EAAE,QAAQ;EACtB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,UAAU,EAAE,QAAQ;EACpB,OAAO,EAAE,QAAQ;EACjB,aAAa,EAAE,QAAQ;EACvB,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,QAAQ;EACpB,UAAU,EAAE,QAAQ;EACpB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,cAAc;EACrB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,QAAQ;EACf,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,SAAS,EAAE,QAAQ;EACnB,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,QAAQ;EACpB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,cAAc;EACvB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,WAAW,EAAE,QAAQ;EACrB,QAAQ,EAAE,cAAc;EACxB,QAAQ,EAAE,cAAc;EACxB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,WAAW,EAAE,QAAQ;EACrB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,YAAY,EAAE,QAAQ;EACtB,OAAO,EAAE,QAAQ;EACjB,WAAW,EAAE,QAAQ;EACrB,SAAS,EAAE,QAAQ;EACnB,SAAS,EAAE,QAAQ;EACnB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,WAAW,EAAE,QAAQ;EACrB,QAAQ,EAAE,QAAQ;EAClB,SAAS,EAAE,QAAQ;EACnB,SAAS,EAAE,QAAQ;EACnB,SAAS,EAAE,QAAQ;EACnB,SAAS,EAAE,QAAQ;EACnB,SAAS,EAAE,QAAQ;EACnB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,YAAY,EAAE,QAAQ;EACtB,OAAO,EAAE,QAAQ;EACjB,WAAW,EAAE,QAAQ;EACrB,SAAS,EAAE,QAAQ;EACnB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,cAAc;EACrB,OAAO,EAAE,QAAQ;EACjB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,QAAQ;EACpB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,cAAc;EACtB,SAAS,EAAE,QAAQ;EACnB,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,QAAQ;EACpB,MAAM,EAAE,QAAQ;EAChB,WAAW,EAAE,QAAQ;EACrB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,QAAQ;EACpB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE,QAAQ;EACnB,UAAU,EAAE,QAAQ;EACpB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,cAAc;EACrB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,QAAQ;EAChB,SAAS,EAAE,QAAQ;EACnB,YAAY,EAAE,QAAQ;EACtB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,UAAU,EAAE,QAAQ;EACpB,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,cAAc;EACtB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,cAAc,EAAE,cAAc;EAC9B,QAAQ,EAAE,cAAc;EACxB,eAAe,EAAE,cAAc;EAC/B,QAAQ,EAAE,cAAc;EACxB,cAAc,EAAE,cAAc;EAC9B,QAAQ,EAAE,cAAc;EACxB,eAAe,EAAE,cAAc;EAC/B,QAAQ,EAAE,cAAc;EACxB,KAAK,EAAE,QAAQ;EACf,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,cAAc;EACrB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,cAAc;EACtB,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,IAAI,EAAE,QAAQ;EACd,KAAK,EAAE,cAAc;EACrB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,cAAc;EACtB,KAAK,EAAE,cAAc;EACrB,IAAI,EAAE,QAAQ;EACd,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,cAAc;EACtB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE,QAAQ;EAChB,OAAO,EAAE,QAAQ;EACjB,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,QAAQ;EACf,KAAK,EAAE,cAAc;EACrB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,QAAQ,EAAE,QAAQ;EAClB,QAAQ,EAAE,QAAQ;EAClB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE,QAAQ;EAChB,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,cAAc;EACrB,MAAM,EAAE,QAAQ;EAChB,SAAS,EAAE,QAAQ;EACnB,MAAM,EAAE,cAAc;EACtB,MAAM,EAAE,cAAc;EACtB,KAAK,EAAE,QAAQ;EACf,MAAM,EAAE;AACV,CAAC;AACD,MAAMC,YAAY,GAAG,QAAQ;AAC7BD,cAAc,CAAC,MAAM,CAAC,GAAGC,YAAY;AAErC,MAAMC,cAAc,CAAC;EACnBtB,MAAM;EACNnvC,MAAM;EACN0wC,2BAA2B;EAC3B9sE,WAAWA,CAACurE,MAAM,EAAEnvC,MAAM,EAAE0wC,2BAA2B,EAAE;IACvD,IAAI,CAACvB,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACnvC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAAC0wC,2BAA2B,GAAGA,2BAA2B;EAChE;AACF;AACA,SAASC,QAAQA,CAACz7C,MAAM,EAAE3d,GAAG,EAAEq5D,gBAAgB,EAAE1rC,OAAO,GAAG,CAAC,CAAC,EAAE;EAC7D,MAAM2rC,SAAS,GAAG,IAAIC,UAAU,CAAC,IAAIv3B,eAAe,CAACrkB,MAAM,EAAE3d,GAAG,CAAC,EAAEq5D,gBAAgB,EAAE1rC,OAAO,CAAC;EAC7F2rC,SAAS,CAACF,QAAQ,CAAC,CAAC;EACpB,OAAO,IAAIF,cAAc,CAACM,eAAe,CAACF,SAAS,CAAC1B,MAAM,CAAC,EAAE0B,SAAS,CAAC7wC,MAAM,EAAE6wC,SAAS,CAACH,2BAA2B,CAAC;AACvH;AACA,MAAMM,kBAAkB,GAAG,QAAQ;AACnC,SAASC,4BAA4BA,CAAC5sB,QAAQ,EAAE;EAC9C,MAAMlkD,IAAI,GAAGkkD,QAAQ,KAAKnQ,IAAI,GAAG,KAAK,GAAGjmC,MAAM,CAAC4qC,YAAY,CAACwL,QAAQ,CAAC;EACtE,OAAO,yBAAyBlkD,IAAI,GAAG;AACzC;AACA,SAAS+wE,sBAAsBA,CAACC,SAAS,EAAE;EACzC,OAAO,mBAAmBA,SAAS,mDAAmD;AACxF;AACA,SAASC,yBAAyBA,CAACvpE,IAAI,EAAEwpE,SAAS,EAAE;EAClD,OAAO,2BAA2BA,SAAS,OAAOxpE,IAAI,iDAAiD;AACzG;AACA,IAAIypE,sBAAsB;AAC1B,CAAC,UAAUA,sBAAsB,EAAE;EACjCA,sBAAsB,CAAC,KAAK,CAAC,GAAG,aAAa;EAC7CA,sBAAsB,CAAC,KAAK,CAAC,GAAG,SAAS;AAC3C,CAAC,EAAEA,sBAAsB,KAAKA,sBAAsB,GAAG,CAAC,CAAC,CAAC,CAAC;AAC3D,MAAMC,gBAAgB,GAAG,CAAC,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,UAAU,EAAE,QAAQ,EAAE,QAAQ,EAAE,cAAc,EAAE,UAAU,EAAE,QAAQ,CAAC;AAC3I,MAAMC,aAAa,GAAG;EACpBr8C,KAAK,EAAE,IAAI;EACXhqB,GAAG,EAAE;AACP,CAAC;AACD,MAAM2lE,UAAU,CAAC;EACfW,iBAAiB;EACjBC,OAAO;EACPC,YAAY;EACZC,wBAAwB;EACxBC,kBAAkB,GAAG,IAAI;EACzBC,iBAAiB,GAAG,IAAI;EACxBC,mBAAmB,GAAG,EAAE;EACxBC,mBAAmB,GAAG,CAAC;EACvBC,gBAAgB,GAAG,KAAK;EACxBC,oBAAoB;EACpBC,+BAA+B;EAC/BC,eAAe;EACfC,YAAY;EACZC,oBAAoB;EACpBnD,MAAM,GAAG,EAAE;EACXnvC,MAAM,GAAG,EAAE;EACX0wC,2BAA2B,GAAG,EAAE;EAChC9sE,WAAWA,CAAC2uE,KAAK,EAAEd,iBAAiB,EAAEvsC,OAAO,EAAE;IAC7C,IAAI,CAACusC,iBAAiB,GAAGA,iBAAiB;IAC1C,IAAI,CAACE,YAAY,GAAGzsC,OAAO,CAACstC,sBAAsB,IAAI,KAAK;IAC3D,IAAI,CAACZ,wBAAwB,GAAG1sC,OAAO,CAACutC,kBAAkB,IAAIvtC,OAAO,CAACutC,kBAAkB,CAACxvE,GAAG,CAACkG,CAAC,IAAIA,CAAC,CAACupE,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;IACxH,MAAM77D,KAAK,GAAGquB,OAAO,CAACruB,KAAK,IAAI;MAC7B87D,MAAM,EAAEJ,KAAK,CAAC1hD,OAAO,CAAC/xB,MAAM;MAC5B8zE,QAAQ,EAAE,CAAC;MACXnoC,SAAS,EAAE,CAAC;MACZC,QAAQ,EAAE;IACZ,CAAC;IACD,IAAI,CAACgnC,OAAO,GAAGxsC,OAAO,CAAColB,aAAa,GAAG,IAAIuoB,sBAAsB,CAACN,KAAK,EAAE17D,KAAK,CAAC,GAAG,IAAIi8D,oBAAoB,CAACP,KAAK,EAAE17D,KAAK,CAAC;IACxH,IAAI,CAACq7D,oBAAoB,GAAGhtC,OAAO,CAAC6tC,mBAAmB,IAAI,KAAK;IAChE,IAAI,CAACZ,+BAA+B,GAAGjtC,OAAO,CAAC8tC,8BAA8B,IAAI,KAAK;IACtF,IAAI,CAACZ,eAAe,GAAGltC,OAAO,CAAC+tC,cAAc,IAAI,IAAI;IACrD,IAAI,CAACZ,YAAY,GAAGntC,OAAO,CAACguC,WAAW,IAAI,IAAI;IAC/C,IAAI,CAACZ,oBAAoB,GAAGptC,OAAO,CAACiuC,mBAAmB,IAAI,KAAK;IAChE,IAAI;MACF,IAAI,CAACzB,OAAO,CAAC0B,IAAI,CAAC,CAAC;IACrB,CAAC,CAAC,OAAO/pE,CAAC,EAAE;MACV,IAAI,CAACgqE,WAAW,CAAChqE,CAAC,CAAC;IACrB;EACF;EACAiqE,uBAAuBA,CAACziD,OAAO,EAAE;IAC/B,IAAI,IAAI,CAACqhD,oBAAoB,EAAE;MAC7B,OAAOrhD,OAAO;IAChB;IACA,OAAOA,OAAO,CAACvwB,OAAO,CAAC0wE,kBAAkB,EAAE,IAAI,CAAC;EAClD;EACAL,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI,CAACe,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAKr/B,IAAI,EAAE;MACnC,MAAM/e,KAAK,GAAG,IAAI,CAACu8C,OAAO,CAAC3+D,KAAK,CAAC,CAAC;MAClC,IAAI;QACF,IAAI,IAAI,CAACygE,gBAAgB,CAAC79B,GAAG,CAAC,EAAE;UAC9B,IAAI,IAAI,CAAC69B,gBAAgB,CAAC9+B,KAAK,CAAC,EAAE;YAChC,IAAI,IAAI,CAAC8+B,gBAAgB,CAACj9B,SAAS,CAAC,EAAE;cACpC,IAAI,CAACk9B,aAAa,CAACt+C,KAAK,CAAC;YAC3B,CAAC,MAAM,IAAI,IAAI,CAACq+C,gBAAgB,CAACl+B,MAAM,CAAC,EAAE;cACxC,IAAI,CAACo+B,eAAe,CAACv+C,KAAK,CAAC;YAC7B,CAAC,MAAM;cACL,IAAI,CAACw+C,eAAe,CAACx+C,KAAK,CAAC;YAC7B;UACF,CAAC,MAAM,IAAI,IAAI,CAACq+C,gBAAgB,CAACh+B,MAAM,CAAC,EAAE;YACxC,IAAI,CAACo+B,gBAAgB,CAACz+C,KAAK,CAAC;UAC9B,CAAC,MAAM;YACL,IAAI,CAAC0+C,eAAe,CAAC1+C,KAAK,CAAC;UAC7B;QACF,CAAC,MAAM,IAAI,IAAI,CAACk9C,YAAY,IAAI,IAAI,CAACX,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAK57B,GAAG,IAAI,CAAC,IAAI,CAACs6B,gBAAgB,IAAI,IAAI,CAAC6B,WAAW,CAAC,CAAC,EAAE;UAC3G,IAAI,CAACC,sBAAsB,CAAC5+C,KAAK,CAAC;QACpC,CAAC,MAAM,IAAI,IAAI,CAACi9C,eAAe,IAAI,IAAI,CAAC4B,aAAa,CAAC,CAAC,EAAE;UACvD,IAAI,CAACC,kBAAkB,CAAC9+C,KAAK,CAAC;QAChC,CAAC,MAAM,IAAI,IAAI,CAACi9C,eAAe,IAAI,CAAC,IAAI,CAACH,gBAAgB,IAAI,CAAC,IAAI,CAACiC,kBAAkB,CAAC,CAAC,IAAI,CAAC,IAAI,CAACC,kBAAkB,CAAC,CAAC,IAAI,IAAI,CAACX,gBAAgB,CAAC/7B,OAAO,CAAC,EAAE;UACvJ,IAAI,CAAC28B,gBAAgB,CAACj/C,KAAK,CAAC;QAC9B,CAAC,MAAM,IAAI,EAAE,IAAI,CAACw8C,YAAY,IAAI,IAAI,CAAC0C,sBAAsB,CAAC,CAAC,CAAC,EAAE;UAChE,IAAI,CAACC,yBAAyB,CAAC,CAAC,EAAE,CAAC,EAAE,MAAM,IAAI,CAACC,UAAU,CAAC,CAAC,EAAE,MAAM,IAAI,CAACC,WAAW,CAAC,CAAC,CAAC;QACzF;MACF,CAAC,CAAC,OAAOnrE,CAAC,EAAE;QACV,IAAI,CAACgqE,WAAW,CAAChqE,CAAC,CAAC;MACrB;IACF;IACA,IAAI,CAACorE,WAAW,CAAC,EAAE,CAAC;IACpB,IAAI,CAACC,SAAS,CAAC,EAAE,CAAC;EACpB;EACAC,aAAaA,CAAA,EAAG;IACd,IAAIC,mBAAmB,GAAG,KAAK;IAC/B,MAAMC,UAAU,GAAG,IAAI,CAACnD,OAAO,CAAC3+D,KAAK,CAAC,CAAC;IACvC,IAAI,CAAC+hE,uBAAuB,CAACh9B,IAAI,IAAI;MACnC,IAAID,YAAY,CAACC,IAAI,CAAC,EAAE;QACtB,OAAO,CAAC88B,mBAAmB;MAC7B;MACA,IAAIG,eAAe,CAACj9B,IAAI,CAAC,EAAE;QACzB88B,mBAAmB,GAAG,IAAI;QAC1B,OAAO,KAAK;MACd;MACA,OAAO,IAAI;IACb,CAAC,CAAC;IACF,OAAO,IAAI,CAAClD,OAAO,CAACsD,QAAQ,CAACH,UAAU,CAAC,CAACrmD,IAAI,CAAC,CAAC;EACjD;EACAylD,kBAAkBA,CAAC9+C,KAAK,EAAE;IACxB,IAAI,CAAC8/C,gBAAgB,CAACt9B,GAAG,CAAC;IAC1B,IAAI,CAAC88B,WAAW,CAAC,EAAE,EAAEt/C,KAAK,CAAC;IAC3B,MAAM+/C,UAAU,GAAG,IAAI,CAACR,SAAS,CAAC,CAAC,IAAI,CAACC,aAAa,CAAC,CAAC,CAAC,CAAC;IACzD,IAAI,IAAI,CAACjD,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAKt+B,OAAO,EAAE;MACnC,IAAI,CAACy8B,OAAO,CAACzvD,OAAO,CAAC,CAAC;MACtB,IAAI,CAACkzD,uBAAuB,CAAC,CAAC;MAC9B,IAAI,CAACL,uBAAuB,CAACM,eAAe,CAAC;MAC7C,IAAI,IAAI,CAAC5B,gBAAgB,CAACt+B,OAAO,CAAC,EAAE;QAClC,IAAI,CAAC4/B,uBAAuB,CAACM,eAAe,CAAC;MAC/C,CAAC,MAAM;QACLF,UAAU,CAACrtE,IAAI,GAAG,EAAE;QACpB;MACF;IACF;IACA,IAAI,IAAI,CAAC2rE,gBAAgB,CAACj8B,OAAO,CAAC,EAAE;MAClC,IAAI,CAACk9B,WAAW,CAAC,EAAE,CAAC;MACpB,IAAI,CAACC,SAAS,CAAC,EAAE,CAAC;IACpB,CAAC,MAAM;MACLQ,UAAU,CAACrtE,IAAI,GAAG,EAAE;IACtB;EACF;EACAusE,gBAAgBA,CAACj/C,KAAK,EAAE;IACtB,IAAI,CAACs/C,WAAW,CAAC,EAAE,EAAEt/C,KAAK,CAAC;IAC3B,IAAI,CAACu/C,SAAS,CAAC,EAAE,CAAC;EACpB;EACAS,uBAAuBA,CAAA,EAAG;IACxB,IAAI,CAACL,uBAAuB,CAACO,oBAAoB,CAAC;IAClD,OAAO,IAAI,CAAC3D,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAKr+B,OAAO,IAAI,IAAI,CAACw8B,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAKr/B,IAAI,EAAE;MACtE,IAAI,CAACugC,WAAW,CAAC,EAAE,CAAC;MACpB,MAAMt/C,KAAK,GAAG,IAAI,CAACu8C,OAAO,CAAC3+D,KAAK,CAAC,CAAC;MAClC,IAAIuiE,OAAO,GAAG,IAAI;MAClB,IAAIC,UAAU,GAAG,CAAC;MAClB,OAAO,IAAI,CAAC7D,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAK79B,UAAU,IAAI,IAAI,CAACg8B,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAKr/B,IAAI,IAAIohC,OAAO,KAAK,IAAI,EAAE;QAC7F,MAAMn1E,IAAI,GAAG,IAAI,CAACuxE,OAAO,CAAC6B,IAAI,CAAC,CAAC;QAChC,IAAIpzE,IAAI,KAAKq2C,UAAU,EAAE;UACvB,IAAI,CAACk7B,OAAO,CAACzvD,OAAO,CAAC,CAAC;QACxB,CAAC,MAAM,IAAI9hB,IAAI,KAAKm1E,OAAO,EAAE;UAC3BA,OAAO,GAAG,IAAI;QAChB,CAAC,MAAM,IAAIA,OAAO,KAAK,IAAI,IAAIl9B,OAAO,CAACj4C,IAAI,CAAC,EAAE;UAC5Cm1E,OAAO,GAAGn1E,IAAI;QAChB,CAAC,MAAM,IAAIA,IAAI,KAAK80C,OAAO,IAAIqgC,OAAO,KAAK,IAAI,EAAE;UAC/CC,UAAU,EAAE;QACd,CAAC,MAAM,IAAIp1E,IAAI,KAAK+0C,OAAO,IAAIogC,OAAO,KAAK,IAAI,EAAE;UAC/C,IAAIC,UAAU,KAAK,CAAC,EAAE;YACpB;UACF,CAAC,MAAM,IAAIA,UAAU,GAAG,CAAC,EAAE;YACzBA,UAAU,EAAE;UACd;QACF;QACA,IAAI,CAAC7D,OAAO,CAACzvD,OAAO,CAAC,CAAC;MACxB;MACA,IAAI,CAACyyD,SAAS,CAAC,CAAC,IAAI,CAAChD,OAAO,CAACsD,QAAQ,CAAC7/C,KAAK,CAAC,CAAC,CAAC;MAC9C,IAAI,CAAC2/C,uBAAuB,CAACO,oBAAoB,CAAC;IACpD;EACF;EACAtB,sBAAsBA,CAAC5+C,KAAK,EAAE;IAC5B,IAAI,CAACqgD,WAAW,CAAC,MAAM,CAAC;IACxB,IAAI,CAACf,WAAW,CAAC,EAAE,EAAEt/C,KAAK,CAAC;IAC3B,IAAI0iB,YAAY,CAAC,IAAI,CAAC65B,OAAO,CAAC6B,IAAI,CAAC,CAAC,CAAC,EAAE;MACrC,IAAI,CAACuB,uBAAuB,CAACM,eAAe,CAAC;IAC/C,CAAC,MAAM;MACL,MAAMjmD,KAAK,GAAG,IAAI,CAACulD,SAAS,CAAC,CAAC,IAAI,CAAChD,OAAO,CAACsD,QAAQ,CAAC7/C,KAAK,CAAC,CAAC,CAAC;MAC5DhG,KAAK,CAACtnB,IAAI,GAAG,EAAE;MACf;IACF;IACA,MAAMqtE,UAAU,GAAG,IAAI,CAACR,SAAS,CAAC,CAAC,IAAI,CAACe,sBAAsB,CAAC,CAAC,CAAC,CAAC;IAClE,IAAI,CAACX,uBAAuB,CAACM,eAAe,CAAC;IAC7C,IAAI,CAAC,IAAI,CAAC5B,gBAAgB,CAAC59B,GAAG,CAAC,EAAE;MAC/Bs/B,UAAU,CAACrtE,IAAI,GAAG,EAAE;MACpB;IACF;IACA,IAAI,CAACitE,uBAAuB,CAACh9B,IAAI,IAAIs9B,eAAe,CAACt9B,IAAI,CAAC,IAAI,CAACI,SAAS,CAACJ,IAAI,CAAC,CAAC;IAC/E,IAAI,CAAC49B,2BAA2B,CAAC,CAAC;IAClC,MAAMC,OAAO,GAAG,IAAI,CAACjE,OAAO,CAAC6B,IAAI,CAAC,CAAC;IACnC,IAAIoC,OAAO,KAAKjgC,UAAU,EAAE;MAC1B,IAAI,CAAC++B,WAAW,CAAC,EAAE,CAAC;MACpB,IAAI,CAACC,SAAS,CAAC,EAAE,CAAC;MAClB,IAAI,CAAChD,OAAO,CAACzvD,OAAO,CAAC,CAAC;IACxB,CAAC,MAAM;MACLizD,UAAU,CAACrtE,IAAI,GAAG,EAAE;MACpBqtE,UAAU,CAAClmE,UAAU,GAAG,IAAI,CAAC0iE,OAAO,CAACkE,OAAO,CAACzgD,KAAK,CAAC;IACrD;EACF;EACAsgD,sBAAsBA,CAAA,EAAG;IACvB,MAAMZ,UAAU,GAAG,IAAI,CAACnD,OAAO,CAAC3+D,KAAK,CAAC,CAAC;IACvC,IAAI8iE,UAAU,GAAG,KAAK;IACtB,IAAI,CAACf,uBAAuB,CAACh9B,IAAI,IAAI;MACnC,IAAIE,aAAa,CAACF,IAAI,CAAC,IAAIA,IAAI,KAAKjD,EAAE,IAAIiD,IAAI,KAAKnB,EAAE,IAAIk/B,UAAU,IAAI99B,OAAO,CAACD,IAAI,CAAC,EAAE;QACpF+9B,UAAU,GAAG,IAAI;QACjB,OAAO,KAAK;MACd;MACA,OAAO,IAAI;IACb,CAAC,CAAC;IACF,OAAO,IAAI,CAACnE,OAAO,CAACsD,QAAQ,CAACH,UAAU,CAAC,CAACrmD,IAAI,CAAC,CAAC;EACjD;EACAknD,2BAA2BA,CAAA,EAAG;IAC5B,MAAMvgD,KAAK,GAAG,IAAI,CAACu8C,OAAO,CAAC3+D,KAAK,CAAC,CAAC;IAClC,IAAI,CAAC0hE,WAAW,CAAC,EAAE,EAAEt/C,KAAK,CAAC;IAC3B,OAAO,IAAI,CAACu8C,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAKr/B,IAAI,EAAE;MACnC,MAAM/zC,IAAI,GAAG,IAAI,CAACuxE,OAAO,CAAC6B,IAAI,CAAC,CAAC;MAChC,IAAIpzE,IAAI,KAAKu1C,UAAU,EAAE;QACvB;MACF;MACA,IAAI0C,OAAO,CAACj4C,IAAI,CAAC,EAAE;QACjB,IAAI,CAACuxE,OAAO,CAACzvD,OAAO,CAAC,CAAC;QACtB,IAAI,CAAC6yD,uBAAuB,CAACgB,KAAK,IAAI;UACpC,IAAIA,KAAK,KAAKt/B,UAAU,EAAE;YACxB,IAAI,CAACk7B,OAAO,CAACzvD,OAAO,CAAC,CAAC;YACtB,OAAO,KAAK;UACd;UACA,OAAO6zD,KAAK,KAAK31E,IAAI;QACvB,CAAC,CAAC;MACJ;MACA,IAAI,CAACuxE,OAAO,CAACzvD,OAAO,CAAC,CAAC;IACxB;IACA,IAAI,CAACyyD,SAAS,CAAC,CAAC,IAAI,CAAChD,OAAO,CAACsD,QAAQ,CAAC7/C,KAAK,CAAC,CAAC,CAAC;EAChD;EACAk/C,sBAAsBA,CAAA,EAAG;IACvB,IAAI,IAAI,CAAC0B,oBAAoB,CAAC,CAAC,EAAE;MAC/B,IAAI,CAACC,0BAA0B,CAAC,CAAC;MACjC,OAAO,IAAI;IACb;IACA,IAAIC,oBAAoB,CAAC,IAAI,CAACvE,OAAO,CAAC6B,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,CAACY,kBAAkB,CAAC,CAAC,EAAE;MAC1E,IAAI,CAAC+B,0BAA0B,CAAC,CAAC;MACjC,OAAO,IAAI;IACb;IACA,IAAI,IAAI,CAACxE,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAK97B,OAAO,EAAE;MACnC,IAAI,IAAI,CAACy8B,kBAAkB,CAAC,CAAC,EAAE;QAC7B,IAAI,CAACiC,wBAAwB,CAAC,CAAC;QAC/B,OAAO,IAAI;MACb;MACA,IAAI,IAAI,CAAChC,kBAAkB,CAAC,CAAC,EAAE;QAC7B,IAAI,CAACiC,wBAAwB,CAAC,CAAC;QAC/B,OAAO,IAAI;MACb;IACF;IACA,OAAO,KAAK;EACd;EACA3B,WAAWA,CAAC5sE,IAAI,EAAEstB,KAAK,GAAG,IAAI,CAACu8C,OAAO,CAAC3+D,KAAK,CAAC,CAAC,EAAE;IAC9C,IAAI,CAAC8+D,kBAAkB,GAAG18C,KAAK;IAC/B,IAAI,CAAC28C,iBAAiB,GAAGjqE,IAAI;EAC/B;EACA6sE,SAASA,CAAChuE,KAAK,EAAEyE,GAAG,EAAE;IACpB,IAAI,IAAI,CAAC0mE,kBAAkB,KAAK,IAAI,EAAE;MACpC,MAAM,IAAIj4B,UAAU,CAAC,IAAI,CAAC83B,OAAO,CAACkE,OAAO,CAACzqE,GAAG,CAAC,EAAE,mFAAmF,CAAC;IACtI;IACA,IAAI,IAAI,CAAC2mE,iBAAiB,KAAK,IAAI,EAAE;MACnC,MAAM,IAAIl4B,UAAU,CAAC,IAAI,CAAC83B,OAAO,CAACkE,OAAO,CAAC,IAAI,CAAC/D,kBAAkB,CAAC,EAAE,sEAAsE,CAAC;IAC7I;IACA,MAAM1iD,KAAK,GAAG;MACZtnB,IAAI,EAAE,IAAI,CAACiqE,iBAAiB;MAC5BprE,KAAK;MACLsI,UAAU,EAAE,CAAC7D,GAAG,IAAI,IAAI,CAACumE,OAAO,EAAEkE,OAAO,CAAC,IAAI,CAAC/D,kBAAkB,EAAE,IAAI,CAACD,wBAAwB;IAClG,CAAC;IACD,IAAI,CAACzC,MAAM,CAACpwE,IAAI,CAACowB,KAAK,CAAC;IACvB,IAAI,CAAC0iD,kBAAkB,GAAG,IAAI;IAC9B,IAAI,CAACC,iBAAiB,GAAG,IAAI;IAC7B,OAAO3iD,KAAK;EACd;EACAknD,YAAYA,CAACprE,GAAG,EAAEgqB,IAAI,EAAE;IACtB,IAAI,IAAI,CAACk/C,kBAAkB,CAAC,CAAC,EAAE;MAC7BlpE,GAAG,IAAI,kFAAkF;IAC3F;IACA,MAAM66B,KAAK,GAAG,IAAI8T,UAAU,CAAC3kB,IAAI,EAAEhqB,GAAG,CAAC;IACvC,IAAI,CAAC4mE,kBAAkB,GAAG,IAAI;IAC9B,IAAI,CAACC,iBAAiB,GAAG,IAAI;IAC7B,OAAOhsC,KAAK;EACd;EACAutC,WAAWA,CAAChqE,CAAC,EAAE;IACb,IAAIA,CAAC,YAAYitE,WAAW,EAAE;MAC5BjtE,CAAC,GAAG,IAAI,CAACgtE,YAAY,CAAChtE,CAAC,CAAC4B,GAAG,EAAE,IAAI,CAACymE,OAAO,CAACkE,OAAO,CAACvsE,CAAC,CAACktE,MAAM,CAAC,CAAC;IAC9D;IACA,IAAIltE,CAAC,YAAYuwC,UAAU,EAAE;MAC3B,IAAI,CAAC5Z,MAAM,CAACjhC,IAAI,CAACsK,CAAC,CAAC;IACrB,CAAC,MAAM;MACL,MAAMA,CAAC;IACT;EACF;EACAmqE,gBAAgBA,CAACnvB,QAAQ,EAAE;IACzB,IAAI,IAAI,CAACqtB,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAKlvB,QAAQ,EAAE;MACpC,IAAI,CAACqtB,OAAO,CAACzvD,OAAO,CAAC,CAAC;MACtB,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd;EACAu0D,+BAA+BA,CAACnyB,QAAQ,EAAE;IACxC,IAAIoyB,8BAA8B,CAAC,IAAI,CAAC/E,OAAO,CAAC6B,IAAI,CAAC,CAAC,EAAElvB,QAAQ,CAAC,EAAE;MACjE,IAAI,CAACqtB,OAAO,CAACzvD,OAAO,CAAC,CAAC;MACtB,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd;EACAgzD,gBAAgBA,CAAC5wB,QAAQ,EAAE;IACzB,MAAMtkB,QAAQ,GAAG,IAAI,CAAC2xC,OAAO,CAAC3+D,KAAK,CAAC,CAAC;IACrC,IAAI,CAAC,IAAI,CAACygE,gBAAgB,CAACnvB,QAAQ,CAAC,EAAE;MACpC,MAAM,IAAI,CAACgyB,YAAY,CAACpF,4BAA4B,CAAC,IAAI,CAACS,OAAO,CAAC6B,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC7B,OAAO,CAACkE,OAAO,CAAC71C,QAAQ,CAAC,CAAC;IAC5G;EACF;EACA22C,WAAWA,CAACC,KAAK,EAAE;IACjB,MAAM5tE,GAAG,GAAG4tE,KAAK,CAAC73E,MAAM;IACxB,IAAI,IAAI,CAAC4yE,OAAO,CAACkF,SAAS,CAAC,CAAC,GAAG7tE,GAAG,EAAE;MAClC,OAAO,KAAK;IACd;IACA,MAAM8tE,eAAe,GAAG,IAAI,CAACnF,OAAO,CAAC3+D,KAAK,CAAC,CAAC;IAC5C,KAAK,IAAI7S,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6I,GAAG,EAAE7I,CAAC,EAAE,EAAE;MAC5B,IAAI,CAAC,IAAI,CAACszE,gBAAgB,CAACmD,KAAK,CAAC1nD,UAAU,CAAC/uB,CAAC,CAAC,CAAC,EAAE;QAC/C,IAAI,CAACwxE,OAAO,GAAGmF,eAAe;QAC9B,OAAO,KAAK;MACd;IACF;IACA,OAAO,IAAI;EACb;EACAC,0BAA0BA,CAACH,KAAK,EAAE;IAChC,KAAK,IAAIz2E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGy2E,KAAK,CAAC73E,MAAM,EAAEoB,CAAC,EAAE,EAAE;MACrC,IAAI,CAAC,IAAI,CAACs2E,+BAA+B,CAACG,KAAK,CAAC1nD,UAAU,CAAC/uB,CAAC,CAAC,CAAC,EAAE;QAC9D,OAAO,KAAK;MACd;IACF;IACA,OAAO,IAAI;EACb;EACAs1E,WAAWA,CAACmB,KAAK,EAAE;IACjB,MAAM52C,QAAQ,GAAG,IAAI,CAAC2xC,OAAO,CAAC3+D,KAAK,CAAC,CAAC;IACrC,IAAI,CAAC,IAAI,CAAC2jE,WAAW,CAACC,KAAK,CAAC,EAAE;MAC5B,MAAM,IAAI,CAACN,YAAY,CAACpF,4BAA4B,CAAC,IAAI,CAACS,OAAO,CAAC6B,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC7B,OAAO,CAACkE,OAAO,CAAC71C,QAAQ,CAAC,CAAC;IAC5G;EACF;EACA+0C,uBAAuBA,CAACiC,SAAS,EAAE;IACjC,OAAO,CAACA,SAAS,CAAC,IAAI,CAACrF,OAAO,CAAC6B,IAAI,CAAC,CAAC,CAAC,EAAE;MACtC,IAAI,CAAC7B,OAAO,CAACzvD,OAAO,CAAC,CAAC;IACxB;EACF;EACA+0D,uBAAuBA,CAACD,SAAS,EAAEhuE,GAAG,EAAE;IACtC,MAAMosB,KAAK,GAAG,IAAI,CAACu8C,OAAO,CAAC3+D,KAAK,CAAC,CAAC;IAClC,IAAI,CAAC+hE,uBAAuB,CAACiC,SAAS,CAAC;IACvC,IAAI,IAAI,CAACrF,OAAO,CAACuF,IAAI,CAAC9hD,KAAK,CAAC,GAAGpsB,GAAG,EAAE;MAClC,MAAM,IAAI,CAACstE,YAAY,CAACpF,4BAA4B,CAAC,IAAI,CAACS,OAAO,CAAC6B,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC7B,OAAO,CAACkE,OAAO,CAACzgD,KAAK,CAAC,CAAC;IACzG;EACF;EACA+hD,iBAAiBA,CAAC/2E,IAAI,EAAE;IACtB,OAAO,IAAI,CAACuxE,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAKpzE,IAAI,EAAE;MACnC,IAAI,CAACuxE,OAAO,CAACzvD,OAAO,CAAC,CAAC;IACxB;EACF;EACAk1D,SAASA,CAAA,EAAG;IACV,MAAMh3E,IAAI,GAAG8N,MAAM,CAACmpE,aAAa,CAAC,IAAI,CAAC1F,OAAO,CAAC6B,IAAI,CAAC,CAAC,CAAC;IACtD,IAAI,CAAC7B,OAAO,CAACzvD,OAAO,CAAC,CAAC;IACtB,OAAO9hB,IAAI;EACb;EACAk3E,QAAQA,CAACV,KAAK,EAAE;IACd,MAAM5tE,GAAG,GAAG4tE,KAAK,CAAC73E,MAAM;IACxB,IAAI,IAAI,CAAC4yE,OAAO,CAACkF,SAAS,CAAC,CAAC,GAAG7tE,GAAG,EAAE;MAClC,OAAO,KAAK;IACd;IACA,MAAMwtE,MAAM,GAAG,IAAI,CAAC7E,OAAO,CAAC3+D,KAAK,CAAC,CAAC;IACnC,KAAK,IAAI7S,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6I,GAAG,EAAE7I,CAAC,EAAE,EAAE;MAC5B,IAAIq2E,MAAM,CAAChD,IAAI,CAAC,CAAC,KAAKoD,KAAK,CAAC1nD,UAAU,CAAC/uB,CAAC,CAAC,EAAE;QACzC,OAAO,KAAK;MACd;MACAq2E,MAAM,CAACt0D,OAAO,CAAC,CAAC;IAClB;IACA,OAAO,IAAI;EACb;EACA+xD,aAAaA,CAAA,EAAG;IACd,OAAO,IAAI,CAACtC,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAK57B,GAAG,IAAI45B,gBAAgB,CAAChhC,IAAI,CAAC+mC,SAAS,IAAI,IAAI,CAACD,QAAQ,CAACC,SAAS,CAAC,CAAC;EACpG;EACAxD,WAAWA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACpC,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAK57B,GAAG,IAAI,IAAI,CAAC0/B,QAAQ,CAAC,MAAM,CAAC;EAC7D;EACAE,cAAcA,CAACC,aAAa,EAAE;IAC5B,IAAI,CAAC/C,WAAW,CAAC,CAAC,CAAC;IACnB,MAAMt/C,KAAK,GAAG,IAAI,CAACu8C,OAAO,CAAC3+D,KAAK,CAAC,CAAC;IAClC,IAAI,CAAC2+D,OAAO,CAACzvD,OAAO,CAAC,CAAC;IACtB,IAAI,IAAI,CAACuxD,gBAAgB,CAAC5+B,KAAK,CAAC,EAAE;MAChC,MAAM6iC,KAAK,GAAG,IAAI,CAACjE,gBAAgB,CAACn8B,EAAE,CAAC,IAAI,IAAI,CAACm8B,gBAAgB,CAACn9B,EAAE,CAAC;MACpE,MAAMqhC,SAAS,GAAG,IAAI,CAAChG,OAAO,CAAC3+D,KAAK,CAAC,CAAC;MACtC,IAAI,CAAC+hE,uBAAuB,CAAC6C,gBAAgB,CAAC;MAC9C,IAAI,IAAI,CAACjG,OAAO,CAAC6B,IAAI,CAAC,CAAC,IAAI79B,UAAU,EAAE;QACrC,IAAI,CAACg8B,OAAO,CAACzvD,OAAO,CAAC,CAAC;QACtB,MAAM21D,UAAU,GAAGH,KAAK,GAAGnG,sBAAsB,CAACuG,GAAG,GAAGvG,sBAAsB,CAACwG,GAAG;QAClF,MAAM,IAAI,CAACzB,YAAY,CAACjF,yBAAyB,CAACwG,UAAU,EAAE,IAAI,CAAClG,OAAO,CAACsD,QAAQ,CAAC7/C,KAAK,CAAC,CAAC,EAAE,IAAI,CAACu8C,OAAO,CAACkE,OAAO,CAAC,CAAC,CAAC;MACtH;MACA,MAAMmC,MAAM,GAAG,IAAI,CAACrG,OAAO,CAACsD,QAAQ,CAAC0C,SAAS,CAAC;MAC/C,IAAI,CAAChG,OAAO,CAACzvD,OAAO,CAAC,CAAC;MACtB,IAAI;QACF,MAAMoiC,QAAQ,GAAG2zB,QAAQ,CAACD,MAAM,EAAEN,KAAK,GAAG,EAAE,GAAG,EAAE,CAAC;QAClD,IAAI,CAAC/C,SAAS,CAAC,CAACzmE,MAAM,CAACmpE,aAAa,CAAC/yB,QAAQ,CAAC,EAAE,IAAI,CAACqtB,OAAO,CAACsD,QAAQ,CAAC7/C,KAAK,CAAC,CAAC,CAAC;MAChF,CAAC,CAAC,MAAM;QACN,MAAM,IAAI,CAACkhD,YAAY,CAACnF,sBAAsB,CAAC,IAAI,CAACQ,OAAO,CAACsD,QAAQ,CAAC7/C,KAAK,CAAC,CAAC,EAAE,IAAI,CAACu8C,OAAO,CAACkE,OAAO,CAAC,CAAC,CAAC;MACvG;IACF,CAAC,MAAM;MACL,MAAMqC,SAAS,GAAG,IAAI,CAACvG,OAAO,CAAC3+D,KAAK,CAAC,CAAC;MACtC,IAAI,CAAC+hE,uBAAuB,CAACoD,gBAAgB,CAAC;MAC9C,IAAI,IAAI,CAACxG,OAAO,CAAC6B,IAAI,CAAC,CAAC,IAAI79B,UAAU,EAAE;QACrC,IAAI,CAAC++B,WAAW,CAAC+C,aAAa,EAAEriD,KAAK,CAAC;QACtC,IAAI,CAACu8C,OAAO,GAAGuG,SAAS;QACxB,IAAI,CAACvD,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;MACvB,CAAC,MAAM;QACL,MAAM9zE,IAAI,GAAG,IAAI,CAAC8wE,OAAO,CAACsD,QAAQ,CAACiD,SAAS,CAAC;QAC7C,IAAI,CAACvG,OAAO,CAACzvD,OAAO,CAAC,CAAC;QACtB,MAAM9hB,IAAI,GAAGowE,cAAc,CAACpkC,cAAc,CAACvrC,IAAI,CAAC,IAAI2vE,cAAc,CAAC3vE,IAAI,CAAC;QACxE,IAAI,CAACT,IAAI,EAAE;UACT,MAAM,IAAI,CAACk2E,YAAY,CAACnF,sBAAsB,CAACtwE,IAAI,CAAC,EAAE,IAAI,CAAC8wE,OAAO,CAACkE,OAAO,CAACzgD,KAAK,CAAC,CAAC;QACpF;QACA,IAAI,CAACu/C,SAAS,CAAC,CAACv0E,IAAI,EAAE,IAAIS,IAAI,GAAG,CAAC,CAAC;MACrC;IACF;EACF;EACAu3E,eAAeA,CAACC,eAAe,EAAEC,kBAAkB,EAAE;IACnD,IAAI,CAAC5D,WAAW,CAAC2D,eAAe,GAAG,CAAC,GAAG,CAAC,CAAC;IACzC,MAAM1xE,KAAK,GAAG,EAAE;IAChB,OAAO,IAAI,EAAE;MACX,MAAM4xE,aAAa,GAAG,IAAI,CAAC5G,OAAO,CAAC3+D,KAAK,CAAC,CAAC;MAC1C,MAAMwlE,cAAc,GAAGF,kBAAkB,CAAC,CAAC;MAC3C,IAAI,CAAC3G,OAAO,GAAG4G,aAAa;MAC5B,IAAIC,cAAc,EAAE;QAClB;MACF;MACA,IAAIH,eAAe,IAAI,IAAI,CAAC1G,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAKx+B,UAAU,EAAE;QACzD,IAAI,CAAC2/B,SAAS,CAAC,CAAC,IAAI,CAACpB,uBAAuB,CAAC5sE,KAAK,CAAChG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QAC9DgG,KAAK,CAAC5H,MAAM,GAAG,CAAC;QAChB,IAAI,CAACy4E,cAAc,CAAC,CAAC,CAAC;QACtB,IAAI,CAAC9C,WAAW,CAAC,CAAC,CAAC;MACrB,CAAC,MAAM;QACL/tE,KAAK,CAAC3H,IAAI,CAAC,IAAI,CAACo4E,SAAS,CAAC,CAAC,CAAC;MAC9B;IACF;IACA,IAAI,CAACzC,SAAS,CAAC,CAAC,IAAI,CAACpB,uBAAuB,CAAC5sE,KAAK,CAAChG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;EAChE;EACAgzE,eAAeA,CAACv+C,KAAK,EAAE;IACrB,IAAI,CAACs/C,WAAW,CAAC,EAAE,EAAEt/C,KAAK,CAAC;IAC3B,IAAI,CAAC8/C,gBAAgB,CAAC3/B,MAAM,CAAC;IAC7B,IAAI,CAACo/B,SAAS,CAAC,EAAE,CAAC;IAClB,IAAI,CAACyD,eAAe,CAAC,KAAK,EAAE,MAAM,IAAI,CAACzB,WAAW,CAAC,KAAK,CAAC,CAAC;IAC1D,IAAI,CAACjC,WAAW,CAAC,EAAE,CAAC;IACpB,IAAI,CAACe,WAAW,CAAC,KAAK,CAAC;IACvB,IAAI,CAACd,SAAS,CAAC,EAAE,CAAC;EACpB;EACAjB,aAAaA,CAACt+C,KAAK,EAAE;IACnB,IAAI,CAACs/C,WAAW,CAAC,EAAE,EAAEt/C,KAAK,CAAC;IAC3B,IAAI,CAACqgD,WAAW,CAAC,QAAQ,CAAC;IAC1B,IAAI,CAACd,SAAS,CAAC,EAAE,CAAC;IAClB,IAAI,CAACyD,eAAe,CAAC,KAAK,EAAE,MAAM,IAAI,CAACzB,WAAW,CAAC,KAAK,CAAC,CAAC;IAC1D,IAAI,CAACjC,WAAW,CAAC,EAAE,CAAC;IACpB,IAAI,CAACe,WAAW,CAAC,KAAK,CAAC;IACvB,IAAI,CAACd,SAAS,CAAC,EAAE,CAAC;EACpB;EACAf,eAAeA,CAACx+C,KAAK,EAAE;IACrB,IAAI,CAACs/C,WAAW,CAAC,EAAE,EAAEt/C,KAAK,CAAC;IAC3B,MAAMqjD,YAAY,GAAG,IAAI,CAAC9G,OAAO,CAAC3+D,KAAK,CAAC,CAAC;IACzC,IAAI,CAACmkE,iBAAiB,CAACrhC,GAAG,CAAC;IAC3B,MAAMhlB,OAAO,GAAG,IAAI,CAAC6gD,OAAO,CAACsD,QAAQ,CAACwD,YAAY,CAAC;IACnD,IAAI,CAAC9G,OAAO,CAACzvD,OAAO,CAAC,CAAC;IACtB,IAAI,CAACyyD,SAAS,CAAC,CAAC7jD,OAAO,CAAC,CAAC;EAC3B;EACA4nD,qBAAqBA,CAACC,YAAY,EAAE;IAClC,MAAMC,iBAAiB,GAAG,IAAI,CAACjH,OAAO,CAAC3+D,KAAK,CAAC,CAAC;IAC9C,IAAIvT,MAAM,GAAG,EAAE;IACf,OAAO,IAAI,CAACkyE,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAK99B,MAAM,IAAI,CAACmjC,WAAW,CAAC,IAAI,CAAClH,OAAO,CAAC6B,IAAI,CAAC,CAAC,CAAC,EAAE;MAC1E,IAAI,CAAC7B,OAAO,CAACzvD,OAAO,CAAC,CAAC;IACxB;IACA,IAAIg2D,SAAS;IACb,IAAI,IAAI,CAACvG,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAK99B,MAAM,EAAE;MAClCj2C,MAAM,GAAG,IAAI,CAACkyE,OAAO,CAACsD,QAAQ,CAAC2D,iBAAiB,CAAC;MACjD,IAAI,CAACjH,OAAO,CAACzvD,OAAO,CAAC,CAAC;MACtBg2D,SAAS,GAAG,IAAI,CAACvG,OAAO,CAAC3+D,KAAK,CAAC,CAAC;IAClC,CAAC,MAAM;MACLklE,SAAS,GAAGU,iBAAiB;IAC/B;IACA,IAAI,CAAC3B,uBAAuB,CAAC0B,YAAY,EAAEl5E,MAAM,KAAK,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;IACjE,MAAMoB,IAAI,GAAG,IAAI,CAAC8wE,OAAO,CAACsD,QAAQ,CAACiD,SAAS,CAAC;IAC7C,OAAO,CAACz4E,MAAM,EAAEoB,IAAI,CAAC;EACvB;EACAizE,eAAeA,CAAC1+C,KAAK,EAAE;IACrB,IAAIpX,OAAO;IACX,IAAIve,MAAM;IACV,IAAIq5E,cAAc;IAClB,IAAIC,SAAS;IACb,IAAI;MACF,IAAI,IAAI,CAACxG,oBAAoB,IAAIyG,uBAAuB,CAAC,IAAI,CAACrH,OAAO,CAAC6B,IAAI,CAAC,CAAC,CAAC,EAAE;QAC7EuF,SAAS,GAAG,IAAI,CAACE,0BAA0B,CAAC7jD,KAAK,CAAC;QAClD,CAAC0jD,cAAc,EAAEr5E,MAAM,EAAEue,OAAO,CAAC,GAAG+6D,SAAS,CAACpyE,KAAK;QACnD,IAAIlH,MAAM,EAAE;UACVq5E,cAAc,IAAI,IAAIr5E,MAAM,EAAE;QAChC;QACA,IAAIue,OAAO,EAAE;UACX86D,cAAc,IAAI,IAAI96D,OAAO,EAAE;QACjC;QACA,IAAI,CAAC+2D,uBAAuB,CAACM,eAAe,CAAC;MAC/C,CAAC,MAAM;QACL,IAAI,CAACp9B,aAAa,CAAC,IAAI,CAAC05B,OAAO,CAAC6B,IAAI,CAAC,CAAC,CAAC,EAAE;UACvC,MAAM,IAAI,CAAC8C,YAAY,CAACpF,4BAA4B,CAAC,IAAI,CAACS,OAAO,CAAC6B,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC7B,OAAO,CAACkE,OAAO,CAACzgD,KAAK,CAAC,CAAC;QACzG;QACA2jD,SAAS,GAAG,IAAI,CAACG,oBAAoB,CAAC9jD,KAAK,CAAC;QAC5C31B,MAAM,GAAGs5E,SAAS,CAACpyE,KAAK,CAAC,CAAC,CAAC;QAC3BqX,OAAO,GAAG86D,cAAc,GAAGC,SAAS,CAACpyE,KAAK,CAAC,CAAC,CAAC;QAC7C,IAAI,CAACouE,uBAAuB,CAACM,eAAe,CAAC;MAC/C;MACA,OAAO,CAAC8D,qBAAqB,CAAC,IAAI,CAACxH,OAAO,CAAC6B,IAAI,CAAC,CAAC,CAAC,EAAE;QAClD,IAAI,IAAI,CAACjB,oBAAoB,IAAI,IAAI,CAACZ,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAK57B,GAAG,EAAE;UAC5D,MAAMxiB,KAAK,GAAG,IAAI,CAACu8C,OAAO,CAAC3+D,KAAK,CAAC,CAAC;UAClC,MAAMklE,SAAS,GAAG9iD,KAAK,CAACpiB,KAAK,CAAC,CAAC;UAC/BklE,SAAS,CAACh2D,OAAO,CAAC,CAAC;UACnB,IAAI82D,uBAAuB,CAACd,SAAS,CAAC1E,IAAI,CAAC,CAAC,CAAC,EAAE;YAC7C,IAAI,CAAC4F,iBAAiB,CAAChkD,KAAK,EAAE8iD,SAAS,CAAC;UAC1C;QACF,CAAC,MAAM;UACL,IAAI,CAACmB,iBAAiB,CAAC,CAAC;QAC1B;MACF;MACA,IAAIN,SAAS,CAACjxE,IAAI,KAAK,EAAE,EAAE;QACzB,IAAI,CAACwxE,wBAAwB,CAAC,CAAC;MACjC,CAAC,MAAM;QACL,IAAI,CAACC,kBAAkB,CAAC,CAAC;MAC3B;IACF,CAAC,CAAC,OAAOjwE,CAAC,EAAE;MACV,IAAIA,CAAC,YAAYuwC,UAAU,EAAE;QAC3B,IAAIk/B,SAAS,EAAE;UACbA,SAAS,CAACjxE,IAAI,GAAGixE,SAAS,CAACjxE,IAAI,KAAK,EAAE,GAAG,EAAE,GAAG,CAAC;QACjD,CAAC,MAAM;UACL,IAAI,CAAC4sE,WAAW,CAAC,CAAC,EAAEt/C,KAAK,CAAC;UAC1B,IAAI,CAACu/C,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;QACvB;QACA;MACF;MACA,MAAMrrE,CAAC;IACT;IACA,MAAMkwE,gBAAgB,GAAG,IAAI,CAAC9H,iBAAiB,CAAC1zD,OAAO,CAAC,CAACy7D,cAAc,CAACh6E,MAAM,CAAC;IAC/E,IAAI+5E,gBAAgB,KAAK93C,cAAc,CAACg4C,QAAQ,EAAE;MAChD,IAAI,CAACC,2BAA2B,CAACZ,SAAS,EAAED,cAAc,EAAE,KAAK,CAAC;IACpE,CAAC,MAAM,IAAIU,gBAAgB,KAAK93C,cAAc,CAACk4C,kBAAkB,EAAE;MACjE,IAAI,CAACD,2BAA2B,CAACZ,SAAS,EAAED,cAAc,EAAE,IAAI,CAAC;IACnE;EACF;EACAa,2BAA2BA,CAACZ,SAAS,EAAE/6D,OAAO,EAAEq6D,eAAe,EAAE;IAC/D,IAAI,CAACD,eAAe,CAACC,eAAe,EAAE,MAAM;MAC1C,IAAI,CAAC,IAAI,CAAC5E,gBAAgB,CAAC79B,GAAG,CAAC,EAAE,OAAO,KAAK;MAC7C,IAAI,CAAC,IAAI,CAAC69B,gBAAgB,CAACh+B,MAAM,CAAC,EAAE,OAAO,KAAK;MAChD,IAAI,CAACs/B,uBAAuB,CAACM,eAAe,CAAC;MAC7C,IAAI,CAAC,IAAI,CAAC0B,0BAA0B,CAAC/4D,OAAO,CAAC,EAAE,OAAO,KAAK;MAC3D,IAAI,CAAC+2D,uBAAuB,CAACM,eAAe,CAAC;MAC7C,OAAO,IAAI,CAAC5B,gBAAgB,CAAC39B,GAAG,CAAC;IACnC,CAAC,CAAC;IACF,IAAI,CAAC4+B,WAAW,CAACqE,SAAS,CAACjxE,IAAI,KAAK,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;IAChD,IAAI,CAACmvE,uBAAuB,CAACl/B,IAAI,IAAIA,IAAI,KAAKjC,GAAG,EAAE,CAAC,CAAC;IACrD,IAAI,CAAC67B,OAAO,CAACzvD,OAAO,CAAC,CAAC;IACtB,IAAI,CAACyyD,SAAS,CAACoE,SAAS,CAACpyE,KAAK,CAAC;EACjC;EACAuyE,oBAAoBA,CAAC9jD,KAAK,EAAE;IAC1B,IAAI,CAACs/C,WAAW,CAAC,CAAC,EAAEt/C,KAAK,CAAC;IAC1B,MAAMzuB,KAAK,GAAG,IAAI,CAAC+xE,qBAAqB,CAACmB,SAAS,CAAC;IACnD,OAAO,IAAI,CAAClF,SAAS,CAAChuE,KAAK,CAAC;EAC9B;EACAsyE,0BAA0BA,CAAC7jD,KAAK,EAAE;IAChC,IAAI,CAACs/C,WAAW,CAAC,EAAE,EAAEt/C,KAAK,CAAC;IAC3B,MAAMzuB,KAAK,GAAG,IAAI,CAACmzE,qBAAqB,CAAC,CAAC;IAC1C,OAAO,IAAI,CAACnF,SAAS,CAAChuE,KAAK,CAAC;EAC9B;EACAmzE,qBAAqBA,CAAA,EAAG;IACtB,MAAM5B,SAAS,GAAG,IAAI,CAACvG,OAAO,CAAC3+D,KAAK,CAAC,CAAC;IACtC,OAAO+mE,sBAAsB,CAAC,IAAI,CAACpI,OAAO,CAAC6B,IAAI,CAAC,CAAC,CAAC,EAAE;MAClD,IAAI,CAAC7B,OAAO,CAACzvD,OAAO,CAAC,CAAC;IACxB;IACA,MAAMrhB,IAAI,GAAG,IAAI,CAAC8wE,OAAO,CAACsD,QAAQ,CAACiD,SAAS,CAAC;IAC7C,IAAIz4E,MAAM,GAAG,EAAE;IACf,IAAIue,OAAO,GAAG,EAAE;IAChB,IAAI,IAAI,CAAC2zD,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAK99B,MAAM,EAAE;MAClC,IAAI,CAACi8B,OAAO,CAACzvD,OAAO,CAAC,CAAC;MACtB,CAACziB,MAAM,EAAEue,OAAO,CAAC,GAAG,IAAI,CAAC06D,qBAAqB,CAACmB,SAAS,CAAC;IAC3D;IACA,OAAO,CAACh5E,IAAI,EAAEpB,MAAM,EAAEue,OAAO,CAAC;EAChC;EACAq7D,iBAAiBA,CAAA,EAAG;IAClB,IAAI,CAACW,qBAAqB,CAAC,CAAC;IAC5B,IAAI,CAACjF,uBAAuB,CAACM,eAAe,CAAC;IAC7C,IAAI,IAAI,CAAC5B,gBAAgB,CAAC59B,GAAG,CAAC,EAAE;MAC9B,IAAI,CAACk/B,uBAAuB,CAACM,eAAe,CAAC;MAC7C,IAAI,CAAC4E,sBAAsB,CAAC,CAAC;IAC/B;IACA,IAAI,CAAClF,uBAAuB,CAACM,eAAe,CAAC;EAC/C;EACA2E,qBAAqBA,CAAA,EAAG;IACtB,MAAME,aAAa,GAAG,IAAI,CAACvI,OAAO,CAAC6B,IAAI,CAAC,CAAC;IACzC,IAAI0G,aAAa,KAAKjlC,GAAG,IAAIilC,aAAa,KAAKtlC,GAAG,EAAE;MAClD,MAAM,IAAI,CAAC0hC,YAAY,CAACpF,4BAA4B,CAACgJ,aAAa,CAAC,EAAE,IAAI,CAACvI,OAAO,CAACkE,OAAO,CAAC,CAAC,CAAC;IAC9F;IACA,IAAI,CAACnB,WAAW,CAAC,EAAE,CAAC;IACpB,IAAIyF,gBAAgB;IACpB,IAAI,IAAI,CAAClI,mBAAmB,GAAG,CAAC,EAAE;MAChC,IAAIuD,UAAU,GAAG,CAAC;MAClB2E,gBAAgB,GAAGpiC,IAAI,IAAI;QACzB,IAAI,IAAI,CAACk6B,mBAAmB,GAAG,CAAC,EAAE;UAChC,IAAIl6B,IAAI,KAAK7C,OAAO,EAAE;YACpBsgC,UAAU,EAAE;UACd,CAAC,MAAM,IAAIz9B,IAAI,KAAK5C,OAAO,EAAE;YAC3B,IAAIqgC,UAAU,KAAK,CAAC,EAAE;cACpB,OAAO,IAAI;YACb;YACAA,UAAU,EAAE;UACd;QACF;QACA,OAAOqE,SAAS,CAAC9hC,IAAI,CAAC;MACxB,CAAC;IACH,CAAC,MAAM,IAAImiC,aAAa,KAAK1jC,SAAS,EAAE;MACtC,IAAI4jC,YAAY,GAAG,CAAC;MACpBD,gBAAgB,GAAGpiC,IAAI,IAAI;QACzB,IAAIA,IAAI,KAAKvB,SAAS,EAAE;UACtB4jC,YAAY,EAAE;QAChB,CAAC,MAAM,IAAIriC,IAAI,KAAKrB,SAAS,EAAE;UAC7B0jC,YAAY,EAAE;QAChB;QACA,OAAOA,YAAY,IAAI,CAAC,GAAGP,SAAS,CAAC9hC,IAAI,CAAC,GAAGI,SAAS,CAACJ,IAAI,CAAC;MAC9D,CAAC;IACH,CAAC,MAAM;MACLoiC,gBAAgB,GAAGN,SAAS;IAC9B;IACA,MAAMQ,aAAa,GAAG,IAAI,CAAC3B,qBAAqB,CAACyB,gBAAgB,CAAC;IAClE,IAAI,CAACxF,SAAS,CAAC0F,aAAa,CAAC;EAC/B;EACAJ,sBAAsBA,CAAA,EAAG;IACvB,IAAI,IAAI,CAACtI,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAKv+B,GAAG,IAAI,IAAI,CAAC08B,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAK5+B,GAAG,EAAE;MAC9D,MAAM0lC,SAAS,GAAG,IAAI,CAAC3I,OAAO,CAAC6B,IAAI,CAAC,CAAC;MACrC,IAAI,CAAC+G,aAAa,CAACD,SAAS,CAAC;MAC7B,MAAM3B,YAAY,GAAGA,CAAA,KAAM,IAAI,CAAChH,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAK8G,SAAS;MAC5D,IAAI,CAAC/F,yBAAyB,CAAC,EAAE,EAAE,EAAE,EAAEoE,YAAY,EAAEA,YAAY,CAAC;MAClE,IAAI,CAAC4B,aAAa,CAACD,SAAS,CAAC;IAC/B,CAAC,MAAM;MACL,MAAM3B,YAAY,GAAGA,CAAA,KAAMkB,SAAS,CAAC,IAAI,CAAClI,OAAO,CAAC6B,IAAI,CAAC,CAAC,CAAC;MACzD,IAAI,CAACe,yBAAyB,CAAC,EAAE,EAAE,EAAE,EAAEoE,YAAY,EAAEA,YAAY,CAAC;IACpE;EACF;EACA4B,aAAaA,CAACD,SAAS,EAAE;IACvB,IAAI,CAAC5F,WAAW,CAAC,EAAE,CAAC;IACpB,IAAI,CAACQ,gBAAgB,CAACoF,SAAS,CAAC;IAChC,IAAI,CAAC3F,SAAS,CAAC,CAACzmE,MAAM,CAACmpE,aAAa,CAACiD,SAAS,CAAC,CAAC,CAAC;EACnD;EACAf,kBAAkBA,CAAA,EAAG;IACnB,MAAMiB,SAAS,GAAG,IAAI,CAAC/G,gBAAgB,CAACh+B,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC;IACvD,IAAI,CAACi/B,WAAW,CAAC8F,SAAS,CAAC;IAC3B,IAAI,CAACtF,gBAAgB,CAACp/B,GAAG,CAAC;IAC1B,IAAI,CAAC6+B,SAAS,CAAC,EAAE,CAAC;EACpB;EACA2E,wBAAwBA,CAAA,EAAG;IACzB,MAAMkB,SAAS,GAAG,IAAI,CAAC/G,gBAAgB,CAACh+B,MAAM,CAAC,GAAG,EAAE,GAAG,EAAE;IACzD,IAAI,CAACi/B,WAAW,CAAC8F,SAAS,CAAC;IAC3B,IAAI,CAACtF,gBAAgB,CAACp/B,GAAG,CAAC;IAC1B,IAAI,CAAC6+B,SAAS,CAAC,EAAE,CAAC;EACpB;EACAd,gBAAgBA,CAACz+C,KAAK,EAAE;IACtB,IAAI,IAAI,CAACm9C,oBAAoB,EAAE;MAC7B,MAAMv/D,KAAK,GAAGoiB,KAAK,CAACpiB,KAAK,CAAC,CAAC;MAC3B,OAAOA,KAAK,CAACwgE,IAAI,CAAC,CAAC,KAAK19B,GAAG,IAAI,CAACkjC,uBAAuB,CAAChmE,KAAK,CAACwgE,IAAI,CAAC,CAAC,CAAC,EAAE;QACrExgE,KAAK,CAACkP,OAAO,CAAC,CAAC;MACjB;MACA,IAAI82D,uBAAuB,CAAChmE,KAAK,CAACwgE,IAAI,CAAC,CAAC,CAAC,EAAE;QACzC,IAAI,CAACkB,WAAW,CAAC,EAAE,EAAEt/C,KAAK,CAAC;QAC3B,MAAMzuB,KAAK,GAAG,IAAI,CAACmzE,qBAAqB,CAAC,CAAC;QAC1C,IAAI,CAAC/E,uBAAuB,CAACM,eAAe,CAAC;QAC7C,IAAI,CAACH,gBAAgB,CAACp/B,GAAG,CAAC;QAC1B,IAAI,CAAC6+B,SAAS,CAAChuE,KAAK,CAAC;QACrB;MACF;IACF;IACA,IAAI,CAAC+tE,WAAW,CAAC,CAAC,EAAEt/C,KAAK,CAAC;IAC1B,IAAI,CAAC2/C,uBAAuB,CAACM,eAAe,CAAC;IAC7C,MAAMgF,aAAa,GAAG,IAAI,CAAC3B,qBAAqB,CAACmB,SAAS,CAAC;IAC3D,IAAI,CAAC9E,uBAAuB,CAACM,eAAe,CAAC;IAC7C,IAAI,CAACH,gBAAgB,CAACp/B,GAAG,CAAC;IAC1B,IAAI,CAAC6+B,SAAS,CAAC0F,aAAa,CAAC;EAC/B;EACApE,0BAA0BA,CAAA,EAAG;IAC3B,IAAI,CAACvB,WAAW,CAAC,EAAE,CAAC;IACpB,IAAI,CAACQ,gBAAgB,CAAC19B,OAAO,CAAC;IAC9B,IAAI,CAACm9B,SAAS,CAAC,EAAE,CAAC;IAClB,IAAI,CAAC3C,mBAAmB,CAAChzE,IAAI,CAAC,EAAE,CAAC;IACjC,IAAI,CAAC01E,WAAW,CAAC,CAAC,CAAC;IACnB,MAAMr9D,SAAS,GAAG,IAAI,CAACojE,UAAU,CAACnlC,MAAM,CAAC;IACzC,MAAMolC,mBAAmB,GAAG,IAAI,CAACnH,uBAAuB,CAACl8D,SAAS,CAAC;IACnE,IAAI,IAAI,CAAC+6D,+BAA+B,EAAE;MACxC,IAAI,CAACuC,SAAS,CAAC,CAAC+F,mBAAmB,CAAC,CAAC;IACvC,CAAC,MAAM;MACL,MAAMC,cAAc,GAAG,IAAI,CAAChG,SAAS,CAAC,CAACt9D,SAAS,CAAC,CAAC;MAClD,IAAIqjE,mBAAmB,KAAKrjE,SAAS,EAAE;QACrC,IAAI,CAACs5D,2BAA2B,CAAC3xE,IAAI,CAAC27E,cAAc,CAAC;MACvD;IACF;IACA,IAAI,CAACzF,gBAAgB,CAAC5/B,MAAM,CAAC;IAC7B,IAAI,CAACy/B,uBAAuB,CAACM,eAAe,CAAC;IAC7C,IAAI,CAACX,WAAW,CAAC,CAAC,CAAC;IACnB,MAAM5sE,IAAI,GAAG,IAAI,CAAC2yE,UAAU,CAACnlC,MAAM,CAAC;IACpC,IAAI,CAACq/B,SAAS,CAAC,CAAC7sE,IAAI,CAAC,CAAC;IACtB,IAAI,CAACotE,gBAAgB,CAAC5/B,MAAM,CAAC;IAC7B,IAAI,CAACy/B,uBAAuB,CAACM,eAAe,CAAC;EAC/C;EACAc,0BAA0BA,CAAA,EAAG;IAC3B,IAAI,CAACzB,WAAW,CAAC,EAAE,CAAC;IACpB,MAAM5zE,KAAK,GAAG,IAAI,CAAC25E,UAAU,CAACjjC,OAAO,CAAC,CAAC/oB,IAAI,CAAC,CAAC;IAC7C,IAAI,CAACkmD,SAAS,CAAC,CAAC7zE,KAAK,CAAC,CAAC;IACvB,IAAI,CAACi0E,uBAAuB,CAACM,eAAe,CAAC;IAC7C,IAAI,CAACX,WAAW,CAAC,EAAE,CAAC;IACpB,IAAI,CAACQ,gBAAgB,CAAC19B,OAAO,CAAC;IAC9B,IAAI,CAACm9B,SAAS,CAAC,EAAE,CAAC;IAClB,IAAI,CAACI,uBAAuB,CAACM,eAAe,CAAC;IAC7C,IAAI,CAACrD,mBAAmB,CAAChzE,IAAI,CAAC,EAAE,CAAC;EACnC;EACAo3E,wBAAwBA,CAAA,EAAG;IACzB,IAAI,CAAC1B,WAAW,CAAC,EAAE,CAAC;IACpB,IAAI,CAACQ,gBAAgB,CAACx9B,OAAO,CAAC;IAC9B,IAAI,CAACi9B,SAAS,CAAC,EAAE,CAAC;IAClB,IAAI,CAACI,uBAAuB,CAACM,eAAe,CAAC;IAC7C,IAAI,CAACrD,mBAAmB,CAAC99C,GAAG,CAAC,CAAC;EAChC;EACAmiD,wBAAwBA,CAAA,EAAG;IACzB,IAAI,CAAC3B,WAAW,CAAC,EAAE,CAAC;IACpB,IAAI,CAACQ,gBAAgB,CAACx9B,OAAO,CAAC;IAC9B,IAAI,CAACi9B,SAAS,CAAC,EAAE,CAAC;IAClB,IAAI,CAAC3C,mBAAmB,CAAC99C,GAAG,CAAC,CAAC;EAChC;EACAqgD,yBAAyBA,CAACkD,aAAa,EAAEmD,sBAAsB,EAAEjC,YAAY,EAAEkC,gBAAgB,EAAE;IAC/F,IAAI,CAACnG,WAAW,CAAC+C,aAAa,CAAC;IAC/B,MAAM9wE,KAAK,GAAG,EAAE;IAChB,OAAO,CAACgyE,YAAY,CAAC,CAAC,EAAE;MACtB,MAAMx5E,OAAO,GAAG,IAAI,CAACwyE,OAAO,CAAC3+D,KAAK,CAAC,CAAC;MACpC,IAAI,IAAI,CAAC2jE,WAAW,CAAClF,aAAa,CAACr8C,KAAK,CAAC,EAAE;QACzC,IAAI,CAACu/C,SAAS,CAAC,CAAC,IAAI,CAACpB,uBAAuB,CAAC5sE,KAAK,CAAChG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,EAAExB,OAAO,CAAC;QACvEwH,KAAK,CAAC5H,MAAM,GAAG,CAAC;QAChB,IAAI,CAAC+7E,qBAAqB,CAACF,sBAAsB,EAAEz7E,OAAO,EAAE07E,gBAAgB,CAAC;QAC7E,IAAI,CAACnG,WAAW,CAAC+C,aAAa,CAAC;MACjC,CAAC,MAAM,IAAI,IAAI,CAAC9F,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAKx+B,UAAU,EAAE;QAC7C,IAAI,CAAC2/B,SAAS,CAAC,CAAC,IAAI,CAACpB,uBAAuB,CAAC5sE,KAAK,CAAChG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QAC9DgG,KAAK,CAAC5H,MAAM,GAAG,CAAC;QAChB,IAAI,CAACy4E,cAAc,CAACC,aAAa,CAAC;QAClC,IAAI,CAAC/C,WAAW,CAAC+C,aAAa,CAAC;MACjC,CAAC,MAAM;QACL9wE,KAAK,CAAC3H,IAAI,CAAC,IAAI,CAACo4E,SAAS,CAAC,CAAC,CAAC;MAC9B;IACF;IACA,IAAI,CAAClF,gBAAgB,GAAG,KAAK;IAC7B,IAAI,CAACyC,SAAS,CAAC,CAAC,IAAI,CAACpB,uBAAuB,CAAC5sE,KAAK,CAAChG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;EAChE;EACAm6E,qBAAqBA,CAACF,sBAAsB,EAAEG,kBAAkB,EAAEC,qBAAqB,EAAE;IACvF,MAAMr0E,KAAK,GAAG,EAAE;IAChB,IAAI,CAAC+tE,WAAW,CAACkG,sBAAsB,EAAEG,kBAAkB,CAAC;IAC5Dp0E,KAAK,CAAC3H,IAAI,CAACyyE,aAAa,CAACr8C,KAAK,CAAC;IAC/B,MAAM6lD,eAAe,GAAG,IAAI,CAACtJ,OAAO,CAAC3+D,KAAK,CAAC,CAAC;IAC5C,IAAIuiE,OAAO,GAAG,IAAI;IAClB,IAAI2F,SAAS,GAAG,KAAK;IACrB,OAAO,IAAI,CAACvJ,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAKr/B,IAAI,KAAK6mC,qBAAqB,KAAK,IAAI,IAAI,CAACA,qBAAqB,CAAC,CAAC,CAAC,EAAE;MACnG,MAAM77E,OAAO,GAAG,IAAI,CAACwyE,OAAO,CAAC3+D,KAAK,CAAC,CAAC;MACpC,IAAI,IAAI,CAACyhE,WAAW,CAAC,CAAC,EAAE;QACtB,IAAI,CAAC9C,OAAO,GAAGxyE,OAAO;QACtBwH,KAAK,CAAC3H,IAAI,CAAC,IAAI,CAACm8E,kBAAkB,CAACF,eAAe,EAAE97E,OAAO,CAAC,CAAC;QAC7D,IAAI,CAACw1E,SAAS,CAAChuE,KAAK,CAAC;QACrB;MACF;MACA,IAAI4uE,OAAO,KAAK,IAAI,EAAE;QACpB,IAAI,IAAI,CAACoB,WAAW,CAAClF,aAAa,CAACrmE,GAAG,CAAC,EAAE;UACvCzE,KAAK,CAAC3H,IAAI,CAAC,IAAI,CAACm8E,kBAAkB,CAACF,eAAe,EAAE97E,OAAO,CAAC,CAAC;UAC7DwH,KAAK,CAAC3H,IAAI,CAACyyE,aAAa,CAACrmE,GAAG,CAAC;UAC7B,IAAI,CAACupE,SAAS,CAAChuE,KAAK,CAAC;UACrB;QACF,CAAC,MAAM,IAAI,IAAI,CAACgwE,WAAW,CAAC,IAAI,CAAC,EAAE;UACjCuE,SAAS,GAAG,IAAI;QAClB;MACF;MACA,MAAM96E,IAAI,GAAG,IAAI,CAACuxE,OAAO,CAAC6B,IAAI,CAAC,CAAC;MAChC,IAAI,CAAC7B,OAAO,CAACzvD,OAAO,CAAC,CAAC;MACtB,IAAI9hB,IAAI,KAAKq2C,UAAU,EAAE;QACvB,IAAI,CAACk7B,OAAO,CAACzvD,OAAO,CAAC,CAAC;MACxB,CAAC,MAAM,IAAI9hB,IAAI,KAAKm1E,OAAO,EAAE;QAC3BA,OAAO,GAAG,IAAI;MAChB,CAAC,MAAM,IAAI,CAAC2F,SAAS,IAAI3F,OAAO,KAAK,IAAI,IAAIl9B,OAAO,CAACj4C,IAAI,CAAC,EAAE;QAC1Dm1E,OAAO,GAAGn1E,IAAI;MAChB;IACF;IACAuG,KAAK,CAAC3H,IAAI,CAAC,IAAI,CAACm8E,kBAAkB,CAACF,eAAe,EAAE,IAAI,CAACtJ,OAAO,CAAC,CAAC;IAClE,IAAI,CAACgD,SAAS,CAAChuE,KAAK,CAAC;EACvB;EACAyyE,iBAAiBA,CAAChkD,KAAK,EAAE8iD,SAAS,EAAE;IAClC,IAAI,CAAChD,gBAAgB,CAACt9B,GAAG,CAAC;IAC1B,IAAI,CAAC+5B,OAAO,CAACzvD,OAAO,CAAC,CAAC;IACtB,OAAO63D,sBAAsB,CAAC,IAAI,CAACpI,OAAO,CAAC6B,IAAI,CAAC,CAAC,CAAC,EAAE;MAClD,IAAI,CAAC7B,OAAO,CAACzvD,OAAO,CAAC,CAAC;IACxB;IACA,IAAI,CAACwyD,WAAW,CAAC,EAAE,EAAEt/C,KAAK,CAAC;IAC3B,MAAMv0B,IAAI,GAAG,IAAI,CAAC8wE,OAAO,CAACsD,QAAQ,CAACiD,SAAS,CAAC;IAC7C,IAAI,CAACvD,SAAS,CAAC,CAAC9zE,IAAI,CAAC,CAAC;IACtB,IAAI,CAACk0E,uBAAuB,CAACM,eAAe,CAAC;IAC7C,IAAI,IAAI,CAAC1D,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAKt+B,OAAO,EAAE;MACnC;IACF;IACA,IAAI,CAAC+8B,mBAAmB,EAAE;IAC1B,IAAI,CAACyC,WAAW,CAAC,EAAE,CAAC;IACpB,IAAI,CAAC/C,OAAO,CAACzvD,OAAO,CAAC,CAAC;IACtB,IAAI,CAACyyD,SAAS,CAAC,EAAE,CAAC;IAClB,IAAI,CAACI,uBAAuB,CAACM,eAAe,CAAC;IAC7C,OAAO,CAAC8D,qBAAqB,CAAC,IAAI,CAACxH,OAAO,CAAC6B,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC7B,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAKr+B,OAAO,EAAE;MACrF,IAAI,CAACkkC,iBAAiB,CAAC,CAAC;IAC1B;IACA,IAAI,CAACtE,uBAAuB,CAACM,eAAe,CAAC;IAC7C,IAAI,CAACpD,mBAAmB,EAAE;IAC1B,IAAI,IAAI,CAACN,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAKr+B,OAAO,EAAE;MACnC,IAAI,IAAI,CAACw8B,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAK19B,GAAG,IAAI,IAAI,CAAC67B,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAK/9B,MAAM,EAAE;QACjE;MACF;MACA,MAAM,IAAI,CAAC6gC,YAAY,CAACpF,4BAA4B,CAAC,IAAI,CAACS,OAAO,CAAC6B,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC7B,OAAO,CAACkE,OAAO,CAACzgD,KAAK,CAAC,CAAC;IACzG;IACA,IAAI,CAACs/C,WAAW,CAAC,EAAE,CAAC;IACpB,IAAI,CAAC/C,OAAO,CAACzvD,OAAO,CAAC,CAAC;IACtB,IAAI,CAACyyD,SAAS,CAAC,EAAE,CAAC;IAClB,IAAI,CAACI,uBAAuB,CAACM,eAAe,CAAC;EAC/C;EACA8F,kBAAkBA,CAAC/lD,KAAK,EAAEhqB,GAAG,EAAE;IAC7B,OAAO,IAAI,CAACmoE,uBAAuB,CAACnoE,GAAG,CAAC6pE,QAAQ,CAAC7/C,KAAK,CAAC,CAAC;EAC1D;EACAo/C,UAAUA,CAAA,EAAG;IACX,IAAI,IAAI,CAACC,WAAW,CAAC,CAAC,IAAI,IAAI,CAAC9C,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAKr/B,IAAI,EAAE;MACtD,OAAO,IAAI;IACb;IACA,IAAI,IAAI,CAACy9B,YAAY,IAAI,CAAC,IAAI,CAACM,gBAAgB,EAAE;MAC/C,IAAI,IAAI,CAAC8D,oBAAoB,CAAC,CAAC,EAAE;QAC/B,OAAO,IAAI;MACb;MACA,IAAI,IAAI,CAACrE,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAK97B,OAAO,IAAI,IAAI,CAACy8B,kBAAkB,CAAC,CAAC,EAAE;QAChE,OAAO,IAAI;MACb;IACF;IACA,IAAI,IAAI,CAAC9B,eAAe,IAAI,CAAC,IAAI,CAACH,gBAAgB,IAAI,CAAC,IAAI,CAACkJ,cAAc,CAAC,CAAC,KAAK,IAAI,CAACnH,aAAa,CAAC,CAAC,IAAI,IAAI,CAACF,WAAW,CAAC,CAAC,IAAI,IAAI,CAACpC,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAK97B,OAAO,CAAC,EAAE;MAC/J,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd;EACA+8B,WAAWA,CAAA,EAAG;IACZ,IAAI,IAAI,CAAC9C,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAK59B,GAAG,EAAE;MAC/B,MAAMwuB,GAAG,GAAG,IAAI,CAACuN,OAAO,CAAC3+D,KAAK,CAAC,CAAC;MAChCoxD,GAAG,CAACliD,OAAO,CAAC,CAAC;MACb,MAAM61B,IAAI,GAAGqsB,GAAG,CAACoP,IAAI,CAAC,CAAC;MACvB,IAAI38B,EAAE,IAAIkB,IAAI,IAAIA,IAAI,IAAIR,EAAE,IAAIpB,EAAE,IAAI4B,IAAI,IAAIA,IAAI,IAAIxB,EAAE,IAAIwB,IAAI,KAAKtC,MAAM,IAAIsC,IAAI,KAAKpD,KAAK,EAAE;QAC7F,OAAO,IAAI;MACb;IACF;IACA,OAAO,KAAK;EACd;EACA8lC,UAAUA,CAACr6E,IAAI,EAAE;IACf,MAAMg1B,KAAK,GAAG,IAAI,CAACu8C,OAAO,CAAC3+D,KAAK,CAAC,CAAC;IAClC,IAAI,CAACmkE,iBAAiB,CAAC/2E,IAAI,CAAC;IAC5B,OAAO,IAAI,CAACuxE,OAAO,CAACsD,QAAQ,CAAC7/C,KAAK,CAAC;EACrC;EACAgmD,cAAcA,CAAA,EAAG;IACf,OAAO,IAAI,CAACjH,kBAAkB,CAAC,CAAC,IAAI,IAAI,CAACC,kBAAkB,CAAC,CAAC;EAC/D;EACAD,kBAAkBA,CAAA,EAAG;IACnB,OAAO,IAAI,CAACnC,mBAAmB,CAACjzE,MAAM,GAAG,CAAC,IAAI,IAAI,CAACizE,mBAAmB,CAAC,IAAI,CAACA,mBAAmB,CAACjzE,MAAM,GAAG,CAAC,CAAC,KAAK,EAAE;EACpH;EACAq1E,kBAAkBA,CAAA,EAAG;IACnB,OAAO,IAAI,CAACpC,mBAAmB,CAACjzE,MAAM,GAAG,CAAC,IAAI,IAAI,CAACizE,mBAAmB,CAAC,IAAI,CAACA,mBAAmB,CAACjzE,MAAM,GAAG,CAAC,CAAC,KAAK,EAAE;EACpH;EACAi3E,oBAAoBA,CAAA,EAAG;IACrB,IAAI,IAAI,CAACrE,OAAO,CAAC6B,IAAI,CAAC,CAAC,KAAKh8B,OAAO,EAAE;MACnC,OAAO,KAAK;IACd;IACA,MAAMpiB,KAAK,GAAG,IAAI,CAACu8C,OAAO,CAAC3+D,KAAK,CAAC,CAAC;IAClC,MAAMqoE,eAAe,GAAG,IAAI,CAAC1E,WAAW,CAAClF,aAAa,CAACr8C,KAAK,CAAC;IAC7D,IAAI,CAACu8C,OAAO,GAAGv8C,KAAK;IACpB,OAAO,CAACimD,eAAe;EACzB;AACF;AACA,SAAShG,eAAeA,CAACt9B,IAAI,EAAE;EAC7B,OAAO,CAACD,YAAY,CAACC,IAAI,CAAC,IAAIA,IAAI,KAAK5D,IAAI;AAC7C;AACA,SAAS0lC,SAASA,CAAC9hC,IAAI,EAAE;EACvB,OAAOD,YAAY,CAACC,IAAI,CAAC,IAAIA,IAAI,KAAKjC,GAAG,IAAIiC,IAAI,KAAKnC,GAAG,IAAImC,IAAI,KAAKtC,MAAM,IAAIsC,IAAI,KAAK9C,GAAG,IAAI8C,IAAI,KAAKnD,GAAG,IAAImD,IAAI,KAAKlC,GAAG,IAAIkC,IAAI,KAAK5D,IAAI;AAC/I;AACA,SAAS0kC,WAAWA,CAAC9gC,IAAI,EAAE;EACzB,OAAO,CAACA,IAAI,GAAGlB,EAAE,IAAIU,EAAE,GAAGQ,IAAI,MAAMA,IAAI,GAAG5B,EAAE,IAAII,EAAE,GAAGwB,IAAI,CAAC,KAAKA,IAAI,GAAG/B,EAAE,IAAI+B,IAAI,GAAG7B,EAAE,CAAC;AACzF;AACA,SAAS0hC,gBAAgBA,CAAC7/B,IAAI,EAAE;EAC9B,OAAOA,IAAI,KAAKpC,UAAU,IAAIoC,IAAI,KAAK5D,IAAI,IAAI,CAAC+D,eAAe,CAACH,IAAI,CAAC;AACvE;AACA,SAASogC,gBAAgBA,CAACpgC,IAAI,EAAE;EAC9B,OAAOA,IAAI,KAAKpC,UAAU,IAAIoC,IAAI,KAAK5D,IAAI,IAAI,CAAC8D,aAAa,CAACF,IAAI,CAAC;AACrE;AACA,SAASm+B,oBAAoBA,CAAC1C,IAAI,EAAE;EAClC,OAAOA,IAAI,KAAK97B,OAAO;AACzB;AACA,SAASg/B,8BAA8BA,CAAC4E,KAAK,EAAEC,KAAK,EAAE;EACpD,OAAOC,mBAAmB,CAACF,KAAK,CAAC,KAAKE,mBAAmB,CAACD,KAAK,CAAC;AAClE;AACA,SAASC,mBAAmBA,CAACzjC,IAAI,EAAE;EACjC,OAAOA,IAAI,IAAIlB,EAAE,IAAIkB,IAAI,IAAIR,EAAE,GAAGQ,IAAI,GAAGlB,EAAE,GAAGV,EAAE,GAAG4B,IAAI;AACzD;AACA,SAASi9B,eAAeA,CAACj9B,IAAI,EAAE;EAC7B,OAAOE,aAAa,CAACF,IAAI,CAAC,IAAIC,OAAO,CAACD,IAAI,CAAC,IAAIA,IAAI,KAAKnB,EAAE;AAC5D;AACA,SAAS0+B,oBAAoBA,CAACv9B,IAAI,EAAE;EAClC,OAAOA,IAAI,KAAKpC,UAAU,IAAI0/B,eAAe,CAACt9B,IAAI,CAAC;AACrD;AACA,SAASihC,uBAAuBA,CAACjhC,IAAI,EAAE;EACrC,OAAOA,IAAI,KAAKnB,EAAE,IAAImB,IAAI,IAAI5B,EAAE,IAAI4B,IAAI,IAAIxB,EAAE;AAChD;AACA,SAASwjC,sBAAsBA,CAAChiC,IAAI,EAAE;EACpC,OAAOE,aAAa,CAACF,IAAI,CAAC,IAAIC,OAAO,CAACD,IAAI,CAAC,IAAIA,IAAI,KAAKnB,EAAE;AAC5D;AACA,SAASuiC,qBAAqBA,CAACphC,IAAI,EAAE;EACnC,OAAOA,IAAI,KAAKtC,MAAM,IAAIsC,IAAI,KAAKjC,GAAG,IAAIiC,IAAI,KAAKnC,GAAG,IAAImC,IAAI,KAAK5D,IAAI;AACzE;AACA,SAAS68B,eAAeA,CAACyK,SAAS,EAAE;EAClC,MAAMC,SAAS,GAAG,EAAE;EACpB,IAAIC,YAAY,GAAG/sD,SAAS;EAC5B,KAAK,IAAIzuB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGs7E,SAAS,CAAC18E,MAAM,EAAEoB,CAAC,EAAE,EAAE;IACzC,MAAMivB,KAAK,GAAGqsD,SAAS,CAACt7E,CAAC,CAAC;IAC1B,IAAIw7E,YAAY,IAAIA,YAAY,CAAC7zE,IAAI,KAAK,CAAC,IAAIsnB,KAAK,CAACtnB,IAAI,KAAK,CAAC,IAAI6zE,YAAY,IAAIA,YAAY,CAAC7zE,IAAI,KAAK,EAAE,IAAIsnB,KAAK,CAACtnB,IAAI,KAAK,EAAE,EAAE;MAChI6zE,YAAY,CAACh1E,KAAK,CAAC,CAAC,CAAC,IAAIyoB,KAAK,CAACzoB,KAAK,CAAC,CAAC,CAAC;MACvCg1E,YAAY,CAAC1sE,UAAU,CAAC7D,GAAG,GAAGgkB,KAAK,CAACngB,UAAU,CAAC7D,GAAG;IACpD,CAAC,MAAM;MACLuwE,YAAY,GAAGvsD,KAAK;MACpBssD,SAAS,CAAC18E,IAAI,CAAC28E,YAAY,CAAC;IAC9B;EACF;EACA,OAAOD,SAAS;AAClB;AACA,MAAM3I,oBAAoB,CAAC;EACzBhR,KAAK;EACLvxC,IAAI;EACJzC,KAAK;EACL3iB,GAAG;EACHvH,WAAWA,CAAC+3E,YAAY,EAAE9kE,KAAK,EAAE;IAC/B,IAAI8kE,YAAY,YAAY7I,oBAAoB,EAAE;MAChD,IAAI,CAACviD,IAAI,GAAGorD,YAAY,CAACprD,IAAI;MAC7B,IAAI,CAACzC,KAAK,GAAG6tD,YAAY,CAAC7tD,KAAK;MAC/B,IAAI,CAAC3iB,GAAG,GAAGwwE,YAAY,CAACxwE,GAAG;MAC3B,MAAM22D,KAAK,GAAG6Z,YAAY,CAAC7Z,KAAK;MAChC,IAAI,CAACA,KAAK,GAAG;QACXyR,IAAI,EAAEzR,KAAK,CAACyR,IAAI;QAChBj7B,MAAM,EAAEwpB,KAAK,CAACxpB,MAAM;QACpBzjB,IAAI,EAAEitC,KAAK,CAACjtC,IAAI;QAChBW,MAAM,EAAEssC,KAAK,CAACtsC;MAChB,CAAC;IACH,CAAC,MAAM;MACL,IAAI,CAAC3e,KAAK,EAAE;QACV,MAAM,IAAIvX,KAAK,CAAC,8EAA8E,CAAC;MACjG;MACA,IAAI,CAACixB,IAAI,GAAGorD,YAAY;MACxB,IAAI,CAAC7tD,KAAK,GAAG6tD,YAAY,CAAC9qD,OAAO;MACjC,IAAI,CAAC1lB,GAAG,GAAG0L,KAAK,CAAC87D,MAAM;MACvB,IAAI,CAAC7Q,KAAK,GAAG;QACXyR,IAAI,EAAE,CAAC,CAAC;QACRj7B,MAAM,EAAEzhC,KAAK,CAAC+7D,QAAQ;QACtB/9C,IAAI,EAAEhe,KAAK,CAAC4zB,SAAS;QACrBjV,MAAM,EAAE3e,KAAK,CAAC6zB;MAChB,CAAC;IACH;EACF;EACA33B,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI+/D,oBAAoB,CAAC,IAAI,CAAC;EACvC;EACAS,IAAIA,CAAA,EAAG;IACL,OAAO,IAAI,CAACzR,KAAK,CAACyR,IAAI;EACxB;EACAqD,SAASA,CAAA,EAAG;IACV,OAAO,IAAI,CAACzrE,GAAG,GAAG,IAAI,CAAC22D,KAAK,CAACxpB,MAAM;EACrC;EACA2+B,IAAIA,CAACzoE,KAAK,EAAE;IACV,OAAO,IAAI,CAACszD,KAAK,CAACxpB,MAAM,GAAG9pC,KAAK,CAACszD,KAAK,CAACxpB,MAAM;EAC/C;EACAr2B,OAAOA,CAAA,EAAG;IACR,IAAI,CAAC25D,YAAY,CAAC,IAAI,CAAC9Z,KAAK,CAAC;EAC/B;EACAsR,IAAIA,CAAA,EAAG;IACL,IAAI,CAACyI,UAAU,CAAC,IAAI,CAAC/Z,KAAK,CAAC;EAC7B;EACA8T,OAAOA,CAACzgD,KAAK,EAAE2mD,uBAAuB,EAAE;IACtC3mD,KAAK,GAAGA,KAAK,IAAI,IAAI;IACrB,IAAIskB,SAAS,GAAGtkB,KAAK;IACrB,IAAI2mD,uBAAuB,EAAE;MAC3B,OAAO,IAAI,CAAC7E,IAAI,CAAC9hD,KAAK,CAAC,GAAG,CAAC,IAAI2mD,uBAAuB,CAACvtD,OAAO,CAAC4G,KAAK,CAACo+C,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;QACnF,IAAI95B,SAAS,KAAKtkB,KAAK,EAAE;UACvBA,KAAK,GAAGA,KAAK,CAACpiB,KAAK,CAAC,CAAC;QACvB;QACAoiB,KAAK,CAAClT,OAAO,CAAC,CAAC;MACjB;IACF;IACA,MAAM85D,aAAa,GAAG,IAAI,CAACC,kBAAkB,CAAC7mD,KAAK,CAAC;IACpD,MAAM8mD,WAAW,GAAG,IAAI,CAACD,kBAAkB,CAAC,IAAI,CAAC;IACjD,MAAME,iBAAiB,GAAGziC,SAAS,KAAKtkB,KAAK,GAAG,IAAI,CAAC6mD,kBAAkB,CAACviC,SAAS,CAAC,GAAGsiC,aAAa;IAClG,OAAO,IAAIviC,eAAe,CAACuiC,aAAa,EAAEE,WAAW,EAAEC,iBAAiB,CAAC;EAC3E;EACAlH,QAAQA,CAAC7/C,KAAK,EAAE;IACd,OAAO,IAAI,CAACrH,KAAK,CAAC6qB,SAAS,CAACxjB,KAAK,CAAC2sC,KAAK,CAACxpB,MAAM,EAAE,IAAI,CAACwpB,KAAK,CAACxpB,MAAM,CAAC;EACpE;EACAl4C,MAAMA,CAAC+7E,GAAG,EAAE;IACV,OAAO,IAAI,CAACruD,KAAK,CAACmB,UAAU,CAACktD,GAAG,CAAC;EACnC;EACAP,YAAYA,CAAC9Z,KAAK,EAAE;IAClB,IAAIA,KAAK,CAACxpB,MAAM,IAAI,IAAI,CAACntC,GAAG,EAAE;MAC5B,IAAI,CAAC22D,KAAK,GAAGA,KAAK;MAClB,MAAM,IAAIwU,WAAW,CAAC,4BAA4B,EAAE,IAAI,CAAC;IAC3D;IACA,MAAM8F,WAAW,GAAG,IAAI,CAACh8E,MAAM,CAAC0hE,KAAK,CAACxpB,MAAM,CAAC;IAC7C,IAAI8jC,WAAW,KAAK/nC,GAAG,EAAE;MACvBytB,KAAK,CAACjtC,IAAI,EAAE;MACZitC,KAAK,CAACtsC,MAAM,GAAG,CAAC;IAClB,CAAC,MAAM,IAAI,CAAC0iB,SAAS,CAACkkC,WAAW,CAAC,EAAE;MAClCta,KAAK,CAACtsC,MAAM,EAAE;IAChB;IACAssC,KAAK,CAACxpB,MAAM,EAAE;IACd,IAAI,CAACujC,UAAU,CAAC/Z,KAAK,CAAC;EACxB;EACA+Z,UAAUA,CAAC/Z,KAAK,EAAE;IAChBA,KAAK,CAACyR,IAAI,GAAGzR,KAAK,CAACxpB,MAAM,IAAI,IAAI,CAACntC,GAAG,GAAG+oC,IAAI,GAAG,IAAI,CAAC9zC,MAAM,CAAC0hE,KAAK,CAACxpB,MAAM,CAAC;EAC1E;EACA0jC,kBAAkBA,CAACzF,MAAM,EAAE;IACzB,OAAO,IAAIl+B,aAAa,CAACk+B,MAAM,CAAChmD,IAAI,EAAEgmD,MAAM,CAACzU,KAAK,CAACxpB,MAAM,EAAEi+B,MAAM,CAACzU,KAAK,CAACjtC,IAAI,EAAE0hD,MAAM,CAACzU,KAAK,CAACtsC,MAAM,CAAC;EACpG;AACF;AACA,MAAMq9C,sBAAsB,SAASC,oBAAoB,CAAC;EACxDuJ,aAAa;EACbz4E,WAAWA,CAAC+3E,YAAY,EAAE9kE,KAAK,EAAE;IAC/B,IAAI8kE,YAAY,YAAY9I,sBAAsB,EAAE;MAClD,KAAK,CAAC8I,YAAY,CAAC;MACnB,IAAI,CAACU,aAAa,GAAG;QACnB,GAAGV,YAAY,CAACU;MAClB,CAAC;IACH,CAAC,MAAM;MACL,KAAK,CAACV,YAAY,EAAE9kE,KAAK,CAAC;MAC1B,IAAI,CAACwlE,aAAa,GAAG,IAAI,CAACva,KAAK;IACjC;EACF;EACA7/C,OAAOA,CAAA,EAAG;IACR,IAAI,CAAC6/C,KAAK,GAAG,IAAI,CAACua,aAAa;IAC/B,KAAK,CAACp6D,OAAO,CAAC,CAAC;IACf,IAAI,CAACq6D,qBAAqB,CAAC,CAAC;EAC9B;EACAlJ,IAAIA,CAAA,EAAG;IACL,KAAK,CAACA,IAAI,CAAC,CAAC;IACZ,IAAI,CAACkJ,qBAAqB,CAAC,CAAC;EAC9B;EACAvpE,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI8/D,sBAAsB,CAAC,IAAI,CAAC;EACzC;EACAmC,QAAQA,CAAC7/C,KAAK,EAAE;IACd,MAAMohD,MAAM,GAAGphD,KAAK,CAACpiB,KAAK,CAAC,CAAC;IAC5B,IAAI4jE,KAAK,GAAG,EAAE;IACd,OAAOJ,MAAM,CAAC8F,aAAa,CAAC/jC,MAAM,GAAG,IAAI,CAAC+jC,aAAa,CAAC/jC,MAAM,EAAE;MAC9Dq+B,KAAK,IAAI1oE,MAAM,CAACmpE,aAAa,CAACb,MAAM,CAAChD,IAAI,CAAC,CAAC,CAAC;MAC5CgD,MAAM,CAACt0D,OAAO,CAAC,CAAC;IAClB;IACA,OAAO00D,KAAK;EACd;EACA2F,qBAAqBA,CAAA,EAAG;IACtB,MAAM/I,IAAI,GAAGA,CAAA,KAAM,IAAI,CAAC8I,aAAa,CAAC9I,IAAI;IAC1C,IAAIA,IAAI,CAAC,CAAC,KAAK/8B,UAAU,EAAE;MACzB,IAAI,CAAC6lC,aAAa,GAAG;QACnB,GAAG,IAAI,CAACva;MACV,CAAC;MACD,IAAI,CAAC8Z,YAAY,CAAC,IAAI,CAACS,aAAa,CAAC;MACrC,IAAI9I,IAAI,CAAC,CAAC,KAAKv8B,EAAE,EAAE;QACjB,IAAI,CAAC8qB,KAAK,CAACyR,IAAI,GAAGl/B,GAAG;MACvB,CAAC,MAAM,IAAIk/B,IAAI,CAAC,CAAC,KAAKt8B,EAAE,EAAE;QACxB,IAAI,CAAC6qB,KAAK,CAACyR,IAAI,GAAG/+B,GAAG;MACvB,CAAC,MAAM,IAAI++B,IAAI,CAAC,CAAC,KAAKn8B,EAAE,EAAE;QACxB,IAAI,CAAC0qB,KAAK,CAACyR,IAAI,GAAGj/B,KAAK;MACzB,CAAC,MAAM,IAAIi/B,IAAI,CAAC,CAAC,KAAKr8B,EAAE,EAAE;QACxB,IAAI,CAAC4qB,KAAK,CAACyR,IAAI,GAAGn/B,IAAI;MACxB,CAAC,MAAM,IAAIm/B,IAAI,CAAC,CAAC,KAAK18B,EAAE,EAAE;QACxB,IAAI,CAACirB,KAAK,CAACyR,IAAI,GAAGp/B,OAAO;MAC3B,CAAC,MAAM,IAAIo/B,IAAI,CAAC,CAAC,KAAKx8B,EAAE,EAAE;QACxB,IAAI,CAAC+qB,KAAK,CAACyR,IAAI,GAAGh/B,GAAG;MACvB,CAAC,MAAM,IAAIg/B,IAAI,CAAC,CAAC,KAAKp8B,EAAE,EAAE;QACxB,IAAI,CAACykC,YAAY,CAAC,IAAI,CAACS,aAAa,CAAC;QACrC,IAAI9I,IAAI,CAAC,CAAC,KAAKh8B,OAAO,EAAE;UACtB,IAAI,CAACqkC,YAAY,CAAC,IAAI,CAACS,aAAa,CAAC;UACrC,MAAME,UAAU,GAAG,IAAI,CAACxpE,KAAK,CAAC,CAAC;UAC/B,IAAIjU,MAAM,GAAG,CAAC;UACd,OAAOy0E,IAAI,CAAC,CAAC,KAAK97B,OAAO,EAAE;YACzB,IAAI,CAACmkC,YAAY,CAAC,IAAI,CAACS,aAAa,CAAC;YACrCv9E,MAAM,EAAE;UACV;UACA,IAAI,CAACgjE,KAAK,CAACyR,IAAI,GAAG,IAAI,CAACiJ,eAAe,CAACD,UAAU,EAAEz9E,MAAM,CAAC;QAC5D,CAAC,MAAM;UACL,MAAMy9E,UAAU,GAAG,IAAI,CAACxpE,KAAK,CAAC,CAAC;UAC/B,IAAI,CAAC6oE,YAAY,CAAC,IAAI,CAACS,aAAa,CAAC;UACrC,IAAI,CAACT,YAAY,CAAC,IAAI,CAACS,aAAa,CAAC;UACrC,IAAI,CAACT,YAAY,CAAC,IAAI,CAACS,aAAa,CAAC;UACrC,IAAI,CAACva,KAAK,CAACyR,IAAI,GAAG,IAAI,CAACiJ,eAAe,CAACD,UAAU,EAAE,CAAC,CAAC;QACvD;MACF,CAAC,MAAM,IAAIhJ,IAAI,CAAC,CAAC,KAAKl8B,EAAE,EAAE;QACxB,IAAI,CAACukC,YAAY,CAAC,IAAI,CAACS,aAAa,CAAC;QACrC,MAAME,UAAU,GAAG,IAAI,CAACxpE,KAAK,CAAC,CAAC;QAC/B,IAAI,CAAC6oE,YAAY,CAAC,IAAI,CAACS,aAAa,CAAC;QACrC,IAAI,CAACva,KAAK,CAACyR,IAAI,GAAG,IAAI,CAACiJ,eAAe,CAACD,UAAU,EAAE,CAAC,CAAC;MACvD,CAAC,MAAM,IAAIpkC,YAAY,CAACo7B,IAAI,CAAC,CAAC,CAAC,EAAE;QAC/B,IAAIkJ,KAAK,GAAG,EAAE;QACd,IAAI39E,MAAM,GAAG,CAAC;QACd,IAAI49E,QAAQ,GAAG,IAAI,CAAC3pE,KAAK,CAAC,CAAC;QAC3B,OAAOolC,YAAY,CAACo7B,IAAI,CAAC,CAAC,CAAC,IAAIz0E,MAAM,GAAG,CAAC,EAAE;UACzC49E,QAAQ,GAAG,IAAI,CAAC3pE,KAAK,CAAC,CAAC;UACvB0pE,KAAK,IAAIxuE,MAAM,CAACmpE,aAAa,CAAC7D,IAAI,CAAC,CAAC,CAAC;UACrC,IAAI,CAACqI,YAAY,CAAC,IAAI,CAACS,aAAa,CAAC;UACrCv9E,MAAM,EAAE;QACV;QACA,IAAI,CAACgjE,KAAK,CAACyR,IAAI,GAAGyE,QAAQ,CAACyE,KAAK,EAAE,CAAC,CAAC;QACpC,IAAI,CAACJ,aAAa,GAAGK,QAAQ,CAACL,aAAa;MAC7C,CAAC,MAAM,IAAInkC,SAAS,CAAC,IAAI,CAACmkC,aAAa,CAAC9I,IAAI,CAAC,EAAE;QAC7C,IAAI,CAACqI,YAAY,CAAC,IAAI,CAACS,aAAa,CAAC;QACrC,IAAI,CAACva,KAAK,GAAG,IAAI,CAACua,aAAa;MACjC,CAAC,MAAM;QACL,IAAI,CAACva,KAAK,CAACyR,IAAI,GAAG,IAAI,CAAC8I,aAAa,CAAC9I,IAAI;MAC3C;IACF;EACF;EACAiJ,eAAeA,CAACrnD,KAAK,EAAEr2B,MAAM,EAAE;IAC7B,MAAM69E,GAAG,GAAG,IAAI,CAAC7uD,KAAK,CAACpuB,KAAK,CAACy1B,KAAK,CAACknD,aAAa,CAAC/jC,MAAM,EAAEnjB,KAAK,CAACknD,aAAa,CAAC/jC,MAAM,GAAGx5C,MAAM,CAAC;IAC7F,MAAMulD,QAAQ,GAAG2zB,QAAQ,CAAC2E,GAAG,EAAE,EAAE,CAAC;IAClC,IAAI,CAACC,KAAK,CAACv4B,QAAQ,CAAC,EAAE;MACpB,OAAOA,QAAQ;IACjB,CAAC,MAAM;MACLlvB,KAAK,CAAC2sC,KAAK,GAAG3sC,KAAK,CAACknD,aAAa;MACjC,MAAM,IAAI/F,WAAW,CAAC,qCAAqC,EAAEnhD,KAAK,CAAC;IACrE;EACF;AACF;AACA,MAAMmhD,WAAW,SAASh3E,KAAK,CAAC;EAC9B2L,GAAG;EACHsrE,MAAM;EACN3yE,WAAWA,CAACqH,GAAG,EAAEsrE,MAAM,EAAE;IACvB,KAAK,CAACtrE,GAAG,CAAC;IACV,IAAI,CAACA,GAAG,GAAGA,GAAG;IACd,IAAI,CAACsrE,MAAM,GAAGA,MAAM;IACpBjxE,MAAM,CAAC00C,cAAc,CAAC,IAAI,EAAEC,GAAG,CAACrhB,MAAM,CAACshB,SAAS,CAAC;EACnD;AACF;AAEA,MAAM2iC,SAAS,SAASjjC,UAAU,CAAC;EACjC70C,WAAW;EACX,OAAO67D,MAAMA,CAAC77D,WAAW,EAAEkwB,IAAI,EAAEhqB,GAAG,EAAE;IACpC,OAAO,IAAI4xE,SAAS,CAAC93E,WAAW,EAAEkwB,IAAI,EAAEhqB,GAAG,CAAC;EAC9C;EACArH,WAAWA,CAACmB,WAAW,EAAEkwB,IAAI,EAAEhqB,GAAG,EAAE;IAClC,KAAK,CAACgqB,IAAI,EAAEhqB,GAAG,CAAC;IAChB,IAAI,CAAClG,WAAW,GAAGA,WAAW;EAChC;AACF;AACA,MAAM+3E,eAAe,CAAC;EACpBC,SAAS;EACT/8C,MAAM;EACNp8B,WAAWA,CAACm5E,SAAS,EAAE/8C,MAAM,EAAE;IAC7B,IAAI,CAAC+8C,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAAC/8C,MAAM,GAAGA,MAAM;EACtB;AACF;AACA,IAAIg9C,QAAQ,GAAG,MAAMC,MAAM,CAAC;EAC1BrM,gBAAgB;EAChBhtE,WAAWA,CAACgtE,gBAAgB,EAAE;IAC5B,IAAI,CAACA,gBAAgB,GAAGA,gBAAgB;EAC1C;EACApyE,KAAKA,CAAC02B,MAAM,EAAE3d,GAAG,EAAE2tB,OAAO,EAAE;IAC1B,MAAMg4C,cAAc,GAAGvM,QAAQ,CAACz7C,MAAM,EAAE3d,GAAG,EAAE,IAAI,CAACq5D,gBAAgB,EAAE1rC,OAAO,CAAC;IAC5E,MAAMi4C,MAAM,GAAG,IAAIC,YAAY,CAACF,cAAc,CAAC/N,MAAM,EAAE,IAAI,CAACyB,gBAAgB,CAAC;IAC7EuM,MAAM,CAACE,KAAK,CAAC,CAAC;IACd,OAAO,IAAIP,eAAe,CAACK,MAAM,CAACJ,SAAS,EAAE,CAAC,GAAGG,cAAc,CAACl9C,MAAM,EAAE,GAAGm9C,MAAM,CAACn9C,MAAM,CAAC,CAAC;EAC5F;AACF,CAAC;AACD,MAAMo9C,YAAY,CAAC;EACjBjO,MAAM;EACNmO,qBAAqB;EACrBC,MAAM,GAAG,CAAC,CAAC;EACXC,KAAK;EACLC,eAAe,GAAG,EAAE;EACpBV,SAAS,GAAG,EAAE;EACd/8C,MAAM,GAAG,EAAE;EACXp8B,WAAWA,CAACurE,MAAM,EAAEmO,qBAAqB,EAAE;IACzC,IAAI,CAACnO,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACmO,qBAAqB,GAAGA,qBAAqB;IAClD,IAAI,CAACI,QAAQ,CAAC,CAAC;EACjB;EACAL,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI,CAACG,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;MAC7B,IAAI,IAAI,CAAC21E,KAAK,CAAC31E,IAAI,KAAK,CAAC,IAAI,IAAI,CAAC21E,KAAK,CAAC31E,IAAI,KAAK,CAAC,EAAE;QAClD,IAAI,CAAC81E,uBAAuB,CAAC,IAAI,CAACD,QAAQ,CAAC,CAAC,CAAC;MAC/C,CAAC,MAAM,IAAI,IAAI,CAACF,KAAK,CAAC31E,IAAI,KAAK,CAAC,EAAE;QAChC,IAAI,CAAC+1E,qBAAqB,CAAC,IAAI,CAACF,QAAQ,CAAC,CAAC,CAAC;MAC7C,CAAC,MAAM,IAAI,IAAI,CAACF,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;QACjC,IAAI,CAACg2E,iBAAiB,CAAC,CAAC;QACxB,IAAI,CAACpK,aAAa,CAAC,IAAI,CAACiK,QAAQ,CAAC,CAAC,CAAC;MACrC,CAAC,MAAM,IAAI,IAAI,CAACF,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;QACjC,IAAI,CAACg2E,iBAAiB,CAAC,CAAC;QACxB,IAAI,CAACnK,eAAe,CAAC,IAAI,CAACgK,QAAQ,CAAC,CAAC,CAAC;MACvC,CAAC,MAAM,IAAI,IAAI,CAACF,KAAK,CAAC31E,IAAI,KAAK,CAAC,IAAI,IAAI,CAAC21E,KAAK,CAAC31E,IAAI,KAAK,CAAC,IAAI,IAAI,CAAC21E,KAAK,CAAC31E,IAAI,KAAK,CAAC,EAAE;QAClF,IAAI,CAACg2E,iBAAiB,CAAC,CAAC;QACxB,IAAI,CAACC,YAAY,CAAC,IAAI,CAACJ,QAAQ,CAAC,CAAC,CAAC;MACpC,CAAC,MAAM,IAAI,IAAI,CAACF,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;QACjC,IAAI,CAACk2E,iBAAiB,CAAC,IAAI,CAACL,QAAQ,CAAC,CAAC,CAAC;MACzC,CAAC,MAAM,IAAI,IAAI,CAACF,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;QACjC,IAAI,CAACg2E,iBAAiB,CAAC,CAAC;QACxB,IAAI,CAACG,iBAAiB,CAAC,IAAI,CAACN,QAAQ,CAAC,CAAC,CAAC;MACzC,CAAC,MAAM,IAAI,IAAI,CAACF,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;QACjC,IAAI,CAACg2E,iBAAiB,CAAC,CAAC;QACxB,IAAI,CAACI,kBAAkB,CAAC,IAAI,CAACP,QAAQ,CAAC,CAAC,CAAC;MAC1C,CAAC,MAAM,IAAI,IAAI,CAACF,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;QACjC,IAAI,CAACg2E,iBAAiB,CAAC,CAAC;QACxB,IAAI,CAACK,uBAAuB,CAAC,IAAI,CAACR,QAAQ,CAAC,CAAC,CAAC;MAC/C,CAAC,MAAM,IAAI,IAAI,CAACF,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;QACjC,IAAI,CAACg2E,iBAAiB,CAAC,CAAC;QACxB,IAAI,CAACM,WAAW,CAAC,IAAI,CAACT,QAAQ,CAAC,CAAC,CAAC;MACnC,CAAC,MAAM,IAAI,IAAI,CAACF,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;QACjC,IAAI,CAACg2E,iBAAiB,CAAC,CAAC;QACxB,IAAI,CAACO,qBAAqB,CAAC,IAAI,CAACV,QAAQ,CAAC,CAAC,CAAC;MAC7C,CAAC,MAAM,IAAI,IAAI,CAACF,KAAK,CAAC31E,IAAI,KAAK,EAAE,IAAI,IAAI,CAAC21E,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;QAC3D,IAAI,CAACw2E,yBAAyB,CAAC,IAAI,CAACX,QAAQ,CAAC,CAAC,CAAC;MACjD,CAAC,MAAM,IAAI,IAAI,CAACF,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;QACjC,IAAI,CAACy2E,uBAAuB,CAAC,IAAI,CAACZ,QAAQ,CAAC,CAAC,CAAC;MAC/C,CAAC,MAAM;QACL,IAAI,CAACA,QAAQ,CAAC,CAAC;MACjB;IACF;IACA,KAAK,MAAMa,iBAAiB,IAAI,IAAI,CAACd,eAAe,EAAE;MACpD,IAAIc,iBAAiB,YAAYxO,KAAK,EAAE;QACtC,IAAI,CAAC/vC,MAAM,CAACjhC,IAAI,CAAC89E,SAAS,CAACjc,MAAM,CAAC2d,iBAAiB,CAAC39E,IAAI,EAAE29E,iBAAiB,CAACvvE,UAAU,EAAE,mBAAmBuvE,iBAAiB,CAAC39E,IAAI,GAAG,CAAC,CAAC;MACxI;IACF;EACF;EACA88E,QAAQA,CAAA,EAAG;IACT,MAAMt5B,IAAI,GAAG,IAAI,CAACo5B,KAAK;IACvB,IAAI,IAAI,CAACD,MAAM,GAAG,IAAI,CAACpO,MAAM,CAACrwE,MAAM,GAAG,CAAC,EAAE;MACxC,IAAI,CAACy+E,MAAM,EAAE;IACf;IACA,IAAI,CAACC,KAAK,GAAG,IAAI,CAACrO,MAAM,CAAC,IAAI,CAACoO,MAAM,CAAC;IACrC,OAAOn5B,IAAI;EACb;EACAo6B,UAAUA,CAAC32E,IAAI,EAAE;IACf,IAAI,IAAI,CAAC21E,KAAK,CAAC31E,IAAI,KAAKA,IAAI,EAAE;MAC5B,OAAO,IAAI,CAAC61E,QAAQ,CAAC,CAAC;IACxB;IACA,OAAO,IAAI;EACb;EACAjK,aAAaA,CAACgL,WAAW,EAAE;IACzB,IAAI,CAACX,YAAY,CAAC,IAAI,CAACJ,QAAQ,CAAC,CAAC,CAAC;IAClC,IAAI,CAACc,UAAU,CAAC,EAAE,CAAC;EACrB;EACA9K,eAAeA,CAACvkD,KAAK,EAAE;IACrB,MAAMnoB,IAAI,GAAG,IAAI,CAACw3E,UAAU,CAAC,CAAC,CAAC;IAC/B,MAAME,QAAQ,GAAG,IAAI,CAACF,UAAU,CAAC,EAAE,CAAC;IACpC,MAAM39E,KAAK,GAAGmG,IAAI,IAAI,IAAI,GAAGA,IAAI,CAACN,KAAK,CAAC,CAAC,CAAC,CAAC8nB,IAAI,CAAC,CAAC,GAAG,IAAI;IACxD,MAAMxf,UAAU,GAAG0vE,QAAQ,IAAI,IAAI,GAAGvvD,KAAK,CAACngB,UAAU,GAAG,IAAIwqC,eAAe,CAACrqB,KAAK,CAACngB,UAAU,CAACmmB,KAAK,EAAEupD,QAAQ,CAAC1vE,UAAU,CAAC7D,GAAG,EAAEgkB,KAAK,CAACngB,UAAU,CAACyqC,SAAS,CAAC;IACzJ,IAAI,CAACklC,YAAY,CAAC,IAAIt8C,OAAO,CAACxhC,KAAK,EAAEmO,UAAU,CAAC,CAAC;EACnD;EACA+uE,iBAAiBA,CAAC5uD,KAAK,EAAE;IACvB,MAAMkgD,WAAW,GAAG,IAAI,CAACqO,QAAQ,CAAC,CAAC;IACnC,MAAM71E,IAAI,GAAG,IAAI,CAAC61E,QAAQ,CAAC,CAAC;IAC5B,MAAMh2E,KAAK,GAAG,EAAE;IAChB,OAAO,IAAI,CAAC81E,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;MAC7B,MAAM+2E,OAAO,GAAG,IAAI,CAACC,mBAAmB,CAAC,CAAC;MAC1C,IAAI,CAACD,OAAO,EAAE;MACdl3E,KAAK,CAAC3I,IAAI,CAAC6/E,OAAO,CAAC;IACrB;IACA,IAAI,IAAI,CAACpB,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;MAC1B,IAAI,CAACm4B,MAAM,CAACjhC,IAAI,CAAC89E,SAAS,CAACjc,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC4c,KAAK,CAACxuE,UAAU,EAAE,mCAAmC,CAAC,CAAC;MACpG;IACF;IACA,MAAMA,UAAU,GAAG,IAAIwqC,eAAe,CAACrqB,KAAK,CAACngB,UAAU,CAACmmB,KAAK,EAAE,IAAI,CAACqoD,KAAK,CAACxuE,UAAU,CAAC7D,GAAG,EAAEgkB,KAAK,CAACngB,UAAU,CAACyqC,SAAS,CAAC;IACrH,IAAI,CAACklC,YAAY,CAAC,IAAIvP,SAAS,CAACC,WAAW,CAAC3oE,KAAK,CAAC,CAAC,CAAC,EAAEmB,IAAI,CAACnB,KAAK,CAAC,CAAC,CAAC,EAAEgB,KAAK,EAAEsH,UAAU,EAAEqgE,WAAW,CAACrgE,UAAU,CAAC,CAAC;IAChH,IAAI,CAAC0uE,QAAQ,CAAC,CAAC;EACjB;EACAmB,mBAAmBA,CAAA,EAAG;IACpB,MAAMh+E,KAAK,GAAG,IAAI,CAAC68E,QAAQ,CAAC,CAAC;IAC7B,IAAI,IAAI,CAACF,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;MAC1B,IAAI,CAACm4B,MAAM,CAACjhC,IAAI,CAAC89E,SAAS,CAACjc,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC4c,KAAK,CAACxuE,UAAU,EAAE,mCAAmC,CAAC,CAAC;MACpG,OAAO,IAAI;IACb;IACA,MAAMmmB,KAAK,GAAG,IAAI,CAACuoD,QAAQ,CAAC,CAAC;IAC7B,MAAM9/D,GAAG,GAAG,IAAI,CAACkhE,0BAA0B,CAAC3pD,KAAK,CAAC;IAClD,IAAI,CAACvX,GAAG,EAAE,OAAO,IAAI;IACrB,MAAMzS,GAAG,GAAG,IAAI,CAACuyE,QAAQ,CAAC,CAAC;IAC3B9/D,GAAG,CAAC7e,IAAI,CAAC;MACP8I,IAAI,EAAE,EAAE;MACRnB,KAAK,EAAE,EAAE;MACTsI,UAAU,EAAE7D,GAAG,CAAC6D;IAClB,CAAC,CAAC;IACF,MAAM+vE,mBAAmB,GAAG,IAAI3B,YAAY,CAACx/D,GAAG,EAAE,IAAI,CAAC0/D,qBAAqB,CAAC;IAC7EyB,mBAAmB,CAAC1B,KAAK,CAAC,CAAC;IAC3B,IAAI0B,mBAAmB,CAAC/+C,MAAM,CAAClhC,MAAM,GAAG,CAAC,EAAE;MACzC,IAAI,CAACkhC,MAAM,GAAG,IAAI,CAACA,MAAM,CAACr/B,MAAM,CAACo+E,mBAAmB,CAAC/+C,MAAM,CAAC;MAC5D,OAAO,IAAI;IACb;IACA,MAAMhxB,UAAU,GAAG,IAAIwqC,eAAe,CAAC34C,KAAK,CAACmO,UAAU,CAACmmB,KAAK,EAAEhqB,GAAG,CAAC6D,UAAU,CAAC7D,GAAG,EAAEtK,KAAK,CAACmO,UAAU,CAACyqC,SAAS,CAAC;IAC9G,MAAMi2B,aAAa,GAAG,IAAIl2B,eAAe,CAACrkB,KAAK,CAACnmB,UAAU,CAACmmB,KAAK,EAAEhqB,GAAG,CAAC6D,UAAU,CAAC7D,GAAG,EAAEgqB,KAAK,CAACnmB,UAAU,CAACyqC,SAAS,CAAC;IACjH,OAAO,IAAI+1B,aAAa,CAAC3uE,KAAK,CAAC6F,KAAK,CAAC,CAAC,CAAC,EAAEq4E,mBAAmB,CAAChC,SAAS,EAAE/tE,UAAU,EAAEnO,KAAK,CAACmO,UAAU,EAAE0gE,aAAa,CAAC;EACtH;EACAoP,0BAA0BA,CAAC3pD,KAAK,EAAE;IAChC,MAAMvX,GAAG,GAAG,EAAE;IACd,MAAMohE,kBAAkB,GAAG,CAAC,EAAE,CAAC;IAC/B,OAAO,IAAI,EAAE;MACX,IAAI,IAAI,CAACxB,KAAK,CAAC31E,IAAI,KAAK,EAAE,IAAI,IAAI,CAAC21E,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;QACpDm3E,kBAAkB,CAACjgF,IAAI,CAAC,IAAI,CAACy+E,KAAK,CAAC31E,IAAI,CAAC;MAC1C;MACA,IAAI,IAAI,CAAC21E,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;QAC1B,IAAIo3E,WAAW,CAACD,kBAAkB,EAAE,EAAE,CAAC,EAAE;UACvCA,kBAAkB,CAAC/qD,GAAG,CAAC,CAAC;UACxB,IAAI+qD,kBAAkB,CAAClgF,MAAM,KAAK,CAAC,EAAE,OAAO8e,GAAG;QACjD,CAAC,MAAM;UACL,IAAI,CAACoiB,MAAM,CAACjhC,IAAI,CAAC89E,SAAS,CAACjc,MAAM,CAAC,IAAI,EAAEzrC,KAAK,CAACnmB,UAAU,EAAE,mCAAmC,CAAC,CAAC;UAC/F,OAAO,IAAI;QACb;MACF;MACA,IAAI,IAAI,CAACwuE,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;QAC1B,IAAIo3E,WAAW,CAACD,kBAAkB,EAAE,EAAE,CAAC,EAAE;UACvCA,kBAAkB,CAAC/qD,GAAG,CAAC,CAAC;QAC1B,CAAC,MAAM;UACL,IAAI,CAAC+L,MAAM,CAACjhC,IAAI,CAAC89E,SAAS,CAACjc,MAAM,CAAC,IAAI,EAAEzrC,KAAK,CAACnmB,UAAU,EAAE,mCAAmC,CAAC,CAAC;UAC/F,OAAO,IAAI;QACb;MACF;MACA,IAAI,IAAI,CAACwuE,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;QAC1B,IAAI,CAACm4B,MAAM,CAACjhC,IAAI,CAAC89E,SAAS,CAACjc,MAAM,CAAC,IAAI,EAAEzrC,KAAK,CAACnmB,UAAU,EAAE,mCAAmC,CAAC,CAAC;QAC/F,OAAO,IAAI;MACb;MACA4O,GAAG,CAAC7e,IAAI,CAAC,IAAI,CAAC2+E,QAAQ,CAAC,CAAC,CAAC;IAC3B;EACF;EACAI,YAAYA,CAAC3uD,KAAK,EAAE;IAClB,MAAMggD,MAAM,GAAG,CAAChgD,KAAK,CAAC;IACtB,MAAM+vD,SAAS,GAAG/vD,KAAK,CAACngB,UAAU;IAClC,IAAIhI,IAAI,GAAGmoB,KAAK,CAACzoB,KAAK,CAAC,CAAC,CAAC;IACzB,IAAIM,IAAI,CAAClI,MAAM,GAAG,CAAC,IAAIkI,IAAI,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;MACvC,MAAMo5D,MAAM,GAAG,IAAI,CAAC+e,aAAa,CAAC,CAAC;MACnC,IAAI/e,MAAM,IAAI,IAAI,IAAIA,MAAM,CAACh5D,QAAQ,CAACtI,MAAM,KAAK,CAAC,IAAI,IAAI,CAAC2yE,iBAAiB,CAACrR,MAAM,CAAC,EAAEgf,aAAa,EAAE;QACnGp4E,IAAI,GAAGA,IAAI,CAAC2xC,SAAS,CAAC,CAAC,CAAC;QACxBw2B,MAAM,CAAC,CAAC,CAAC,GAAG;UACVtnE,IAAI,EAAEsnB,KAAK,CAACtnB,IAAI;UAChBmH,UAAU,EAAEmgB,KAAK,CAACngB,UAAU;UAC5BtI,KAAK,EAAE,CAACM,IAAI;QACd,CAAC;MACH;IACF;IACA,OAAO,IAAI,CAACw2E,KAAK,CAAC31E,IAAI,KAAK,CAAC,IAAI,IAAI,CAAC21E,KAAK,CAAC31E,IAAI,KAAK,CAAC,IAAI,IAAI,CAAC21E,KAAK,CAAC31E,IAAI,KAAK,CAAC,EAAE;MAC9EsnB,KAAK,GAAG,IAAI,CAACuuD,QAAQ,CAAC,CAAC;MACvBvO,MAAM,CAACpwE,IAAI,CAACowB,KAAK,CAAC;MAClB,IAAIA,KAAK,CAACtnB,IAAI,KAAK,CAAC,EAAE;QACpBb,IAAI,IAAImoB,KAAK,CAACzoB,KAAK,CAAChG,IAAI,CAAC,EAAE,CAAC,CAACJ,OAAO,CAAC,YAAY,EAAE++E,YAAY,CAAC;MAClE,CAAC,MAAM,IAAIlwD,KAAK,CAACtnB,IAAI,KAAK,CAAC,EAAE;QAC3Bb,IAAI,IAAImoB,KAAK,CAACzoB,KAAK,CAAC,CAAC,CAAC;MACxB,CAAC,MAAM;QACLM,IAAI,IAAImoB,KAAK,CAACzoB,KAAK,CAAChG,IAAI,CAAC,EAAE,CAAC;MAC9B;IACF;IACA,IAAIsG,IAAI,CAAClI,MAAM,GAAG,CAAC,EAAE;MACnB,MAAMwgF,OAAO,GAAGnwD,KAAK,CAACngB,UAAU;MAChC,IAAI,CAAC2vE,YAAY,CAAC,IAAIn8C,IAAI,CAACx7B,IAAI,EAAE,IAAIwyC,eAAe,CAAC0lC,SAAS,CAAC/pD,KAAK,EAAEmqD,OAAO,CAACn0E,GAAG,EAAE+zE,SAAS,CAACzlC,SAAS,EAAEylC,SAAS,CAACxlC,OAAO,CAAC,EAAEy1B,MAAM,CAAC,CAAC;IACtI;EACF;EACA0O,iBAAiBA,CAAA,EAAG;IAClB,MAAMhpE,EAAE,GAAG,IAAI,CAACsqE,aAAa,CAAC,CAAC;IAC/B,IAAItqE,EAAE,KAAK,IAAI,IAAI,IAAI,CAAC48D,iBAAiB,CAAC58D,EAAE,CAAC,EAAE7M,MAAM,EAAE;MACrD,IAAI,CAACy1E,eAAe,CAACxpD,GAAG,CAAC,CAAC;IAC5B;EACF;EACA0pD,uBAAuBA,CAAC4B,aAAa,EAAE;IACrC,MAAMjhF,KAAK,GAAG,EAAE;IAChB,MAAMslC,UAAU,GAAG,EAAE;IACrB,IAAI,CAAC47C,+BAA+B,CAAClhF,KAAK,EAAEslC,UAAU,CAAC;IACvD,MAAM3B,QAAQ,GAAG,IAAI,CAACw9C,mBAAmB,CAACF,aAAa,EAAE,IAAI,CAACG,4BAA4B,CAAC,CAAC,CAAC;IAC7F,MAAMC,MAAM,GAAG,IAAI,CAAClO,iBAAiB,CAACxvC,QAAQ,CAAC;IAC/C,IAAI29C,WAAW,GAAG,KAAK;IACvB,IAAI,IAAI,CAACpC,KAAK,CAAC31E,IAAI,KAAK,CAAC,EAAE;MACzB,IAAI,CAAC61E,QAAQ,CAAC,CAAC;MACfkC,WAAW,GAAG,IAAI;MAClB,IAAI,EAAED,MAAM,EAAEE,YAAY,IAAI79C,WAAW,CAACC,QAAQ,CAAC,KAAK,IAAI,IAAI09C,MAAM,EAAE33E,MAAM,CAAC,EAAE;QAC/E,IAAI,CAACg4B,MAAM,CAACjhC,IAAI,CAAC89E,SAAS,CAACjc,MAAM,CAAC3+B,QAAQ,EAAEs9C,aAAa,CAACvwE,UAAU,EAAE,8DAA8DuwE,aAAa,CAAC74E,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;MACjK;IACF,CAAC,MAAM,IAAI,IAAI,CAAC82E,KAAK,CAAC31E,IAAI,KAAK,CAAC,EAAE;MAChC,IAAI,CAAC61E,QAAQ,CAAC,CAAC;MACfkC,WAAW,GAAG,KAAK;IACrB;IACA,MAAMz0E,GAAG,GAAG,IAAI,CAACqyE,KAAK,CAACxuE,UAAU,CAACyqC,SAAS;IAC3C,MAAMxkB,IAAI,GAAG,IAAIukB,eAAe,CAAC+lC,aAAa,CAACvwE,UAAU,CAACmmB,KAAK,EAAEhqB,GAAG,EAAEo0E,aAAa,CAACvwE,UAAU,CAACyqC,SAAS,CAAC;IACzG,MAAMylC,SAAS,GAAG,IAAI1lC,eAAe,CAAC+lC,aAAa,CAACvwE,UAAU,CAACmmB,KAAK,EAAEhqB,GAAG,EAAEo0E,aAAa,CAACvwE,UAAU,CAACyqC,SAAS,CAAC;IAC9G,MAAM5kC,EAAE,GAAG,IAAI2uB,OAAO,CAACvB,QAAQ,EAAE3jC,KAAK,EAAEslC,UAAU,EAAE,EAAE,EAAEg8C,WAAW,EAAE3qD,IAAI,EAAEiqD,SAAS,EAAEvwD,SAAS,EAAEgxD,MAAM,EAAE33E,MAAM,IAAI,KAAK,CAAC;IACzH,MAAMo4D,MAAM,GAAG,IAAI,CAAC+e,aAAa,CAAC,CAAC;IACnC,MAAMW,eAAe,GAAG1f,MAAM,KAAK,IAAI,IAAI,CAAC,CAAC,IAAI,CAACqR,iBAAiB,CAACrR,MAAM,CAAC,EAAE0f,eAAe,CAACjrE,EAAE,CAACjU,IAAI,CAAC;IACrG,IAAI,CAACm/E,cAAc,CAAClrE,EAAE,EAAEirE,eAAe,CAAC;IACxC,IAAIF,WAAW,EAAE;MACf,IAAI,CAACI,aAAa,CAAC/9C,QAAQ,EAAEuB,OAAO,EAAEvO,IAAI,CAAC;IAC7C,CAAC,MAAM,IAAIsqD,aAAa,CAAC13E,IAAI,KAAK,CAAC,EAAE;MACnC,IAAI,CAACm4E,aAAa,CAAC/9C,QAAQ,EAAEuB,OAAO,EAAE,IAAI,CAAC;MAC3C,IAAI,CAACxD,MAAM,CAACjhC,IAAI,CAAC89E,SAAS,CAACjc,MAAM,CAAC3+B,QAAQ,EAAEhN,IAAI,EAAE,gBAAgBgN,QAAQ,mBAAmB,CAAC,CAAC;IACjG;EACF;EACAo8C,yBAAyBA,CAACnJ,UAAU,EAAE;IACpC,MAAM7sC,aAAa,GAAG6sC,UAAU,CAACxuE,KAAK,CAAC,CAAC,CAAC;IACzC,MAAMpI,KAAK,GAAG,EAAE;IAChB,MAAMslC,UAAU,GAAG,EAAE;IACrB,IAAI,CAAC47C,+BAA+B,CAAClhF,KAAK,EAAEslC,UAAU,CAAC;IACvD,MAAMq8C,cAAc,GAAG,IAAI,CAACP,4BAA4B,CAAC,CAAC;IAC1D,MAAM3hE,OAAO,GAAG,IAAI,CAACmiE,oBAAoB,CAAChL,UAAU,EAAE+K,cAAc,CAAC;IACrE,MAAMh+C,QAAQ,GAAG,IAAI,CAACk+C,qBAAqB,CAACjL,UAAU,EAAE+K,cAAc,CAAC;IACvE,MAAML,WAAW,GAAG,IAAI,CAACpC,KAAK,CAAC31E,IAAI,KAAK,EAAE;IAC1C,IAAI,CAAC61E,QAAQ,CAAC,CAAC;IACf,MAAMvyE,GAAG,GAAG,IAAI,CAACqyE,KAAK,CAACxuE,UAAU,CAACyqC,SAAS;IAC3C,MAAMxkB,IAAI,GAAG,IAAIukB,eAAe,CAAC07B,UAAU,CAAClmE,UAAU,CAACmmB,KAAK,EAAEhqB,GAAG,EAAE+pE,UAAU,CAAClmE,UAAU,CAACyqC,SAAS,CAAC;IACnG,MAAMylC,SAAS,GAAG,IAAI1lC,eAAe,CAAC07B,UAAU,CAAClmE,UAAU,CAACmmB,KAAK,EAAEhqB,GAAG,EAAE+pE,UAAU,CAAClmE,UAAU,CAACyqC,SAAS,CAAC;IACxG,MAAMlmC,IAAI,GAAG,IAAIwnB,SAAS,CAACsN,aAAa,EAAEtqB,OAAO,EAAEkkB,QAAQ,EAAE3jC,KAAK,EAAEslC,UAAU,EAAE,EAAE,EAAEg8C,WAAW,EAAE3qD,IAAI,EAAEiqD,SAAS,EAAEvwD,SAAS,CAAC;IAC5H,MAAMyxC,MAAM,GAAG,IAAI,CAAC+e,aAAa,CAAC,CAAC;IACnC,MAAMW,eAAe,GAAG1f,MAAM,KAAK,IAAI,IAAI7sD,IAAI,CAACwK,OAAO,KAAK,IAAI,IAAI,CAAC,CAAC,IAAI,CAAC0zD,iBAAiB,CAACrR,MAAM,CAAC,EAAE0f,eAAe,CAACvsE,IAAI,CAACwK,OAAO,CAAC;IACnI,IAAI,CAACgiE,cAAc,CAACxsE,IAAI,EAAEusE,eAAe,CAAC;IAC1C,IAAIF,WAAW,EAAE;MACf,IAAI,CAACI,aAAa,CAAC/9C,QAAQ,EAAElH,SAAS,EAAE9F,IAAI,CAAC;IAC/C,CAAC,MAAM,IAAIigD,UAAU,CAACrtE,IAAI,KAAK,EAAE,EAAE;MACjC,IAAI,CAACm4E,aAAa,CAAC/9C,QAAQ,EAAElH,SAAS,EAAE,IAAI,CAAC;MAC7C,IAAI,CAACiF,MAAM,CAACjhC,IAAI,CAAC89E,SAAS,CAACjc,MAAM,CAAC3+B,QAAQ,EAAEhN,IAAI,EAAE,gBAAgBgN,QAAQ,mBAAmB,CAAC,CAAC;IACjG;EACF;EACAu9C,+BAA+BA,CAACY,gBAAgB,EAAEC,gBAAgB,EAAE;IAClE,OAAO,IAAI,CAAC7C,KAAK,CAAC31E,IAAI,KAAK,EAAE,IAAI,IAAI,CAAC21E,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;MACvD,IAAI,IAAI,CAAC21E,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;QAC1Bw4E,gBAAgB,CAACthF,IAAI,CAAC,IAAI,CAACo6E,iBAAiB,CAAC,IAAI,CAACqE,KAAK,CAAC,CAAC;MAC3D,CAAC,MAAM;QACL4C,gBAAgB,CAACrhF,IAAI,CAAC,IAAI,CAACuhF,YAAY,CAAC,IAAI,CAAC5C,QAAQ,CAAC,CAAC,CAAC,CAAC;MAC3D;IACF;EACF;EACAY,uBAAuBA,CAACI,QAAQ,EAAE;IAChC,MAAMz8C,QAAQ,GAAG,IAAI,CAACk+C,qBAAqB,CAACzB,QAAQ,EAAE,IAAI,CAACgB,4BAA4B,CAAC,CAAC,CAAC;IAC1F,IAAI,CAAC,IAAI,CAACM,aAAa,CAAC/9C,QAAQ,EAAElH,SAAS,EAAE2jD,QAAQ,CAAC1vE,UAAU,CAAC,EAAE;MACjE,MAAM7H,SAAS,GAAG,IAAI,CAACs2E,eAAe,CAAC,IAAI,CAACA,eAAe,CAAC3+E,MAAM,GAAG,CAAC,CAAC;MACvE,IAAIyrD,MAAM;MACV,IAAIpjD,SAAS,YAAY4zB,SAAS,IAAI5zB,SAAS,CAACkhC,aAAa,KAAKq2C,QAAQ,CAACh4E,KAAK,CAAC,CAAC,CAAC,EAAE;QACnF6jD,MAAM,GAAG,mBAAmBpjD,SAAS,CAAC86B,QAAQ,IAAI;MACpD,CAAC,MAAM;QACLsoB,MAAM,GAAG,sEAAsE;MACjF;MACA,MAAMg2B,MAAM,GAAG,2BAA2Bt+C,QAAQ,IAAIsoB,MAAM,EAAE;MAC9D,IAAI,CAACvqB,MAAM,CAACjhC,IAAI,CAAC89E,SAAS,CAACjc,MAAM,CAAC3+B,QAAQ,EAAEy8C,QAAQ,CAAC1vE,UAAU,EAAEuxE,MAAM,CAAC,CAAC;IAC3E;EACF;EACA9O,iBAAiBA,CAAC+O,UAAU,EAAE;IAC5B,IAAI,OAAOA,UAAU,KAAK,QAAQ,EAAE;MAClC,OAAO,IAAI,CAAClD,qBAAqB,CAACkD,UAAU,CAAC;IAC/C,CAAC,MAAM,IAAIA,UAAU,YAAYh9C,OAAO,EAAE;MACxC,OAAO,IAAI,CAAC85C,qBAAqB,CAACkD,UAAU,CAAC5/E,IAAI,CAAC;IACpD,CAAC,MAAM,IAAI4/E,UAAU,YAAYzlD,SAAS,IAAIylD,UAAU,CAACziE,OAAO,KAAK,IAAI,EAAE;MACzE,OAAO,IAAI,CAACu/D,qBAAqB,CAACkD,UAAU,CAACziE,OAAO,CAAC;IACvD,CAAC,MAAM;MACL,OAAO,IAAI;IACb;EACF;EACAgiE,cAAcA,CAACxsE,IAAI,EAAEusE,eAAe,EAAE;IACpC,IAAIA,eAAe,EAAE;MACnB,IAAI,CAACrC,eAAe,CAACxpD,GAAG,CAAC,CAAC;IAC5B;IACA,IAAI,CAAC0qD,YAAY,CAACprE,IAAI,CAAC;IACvB,IAAI,CAACkqE,eAAe,CAAC1+E,IAAI,CAACwU,IAAI,CAAC;EACjC;EACAqqE,qBAAqBA,CAAC6C,WAAW,EAAE;IACjC,MAAMx+C,QAAQ,GAAG,IAAI,CAACw9C,mBAAmB,CAACgB,WAAW,EAAE,IAAI,CAACf,4BAA4B,CAAC,CAAC,CAAC;IAC3F,IAAI,IAAI,CAACjO,iBAAiB,CAACxvC,QAAQ,CAAC,EAAEj6B,MAAM,EAAE;MAC5C,IAAI,CAACg4B,MAAM,CAACjhC,IAAI,CAAC89E,SAAS,CAACjc,MAAM,CAAC3+B,QAAQ,EAAEw+C,WAAW,CAACzxE,UAAU,EAAE,uCAAuCyxE,WAAW,CAAC/5E,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IACtI,CAAC,MAAM,IAAI,CAAC,IAAI,CAACs5E,aAAa,CAAC/9C,QAAQ,EAAEuB,OAAO,EAAEi9C,WAAW,CAACzxE,UAAU,CAAC,EAAE;MACzE,MAAMuxE,MAAM,GAAG,2BAA2Bt+C,QAAQ,6KAA6K;MAC/N,IAAI,CAACjC,MAAM,CAACjhC,IAAI,CAAC89E,SAAS,CAACjc,MAAM,CAAC3+B,QAAQ,EAAEw+C,WAAW,CAACzxE,UAAU,EAAEuxE,MAAM,CAAC,CAAC;IAC9E;EACF;EACAP,aAAaA,CAACU,YAAY,EAAEC,YAAY,EAAE38C,aAAa,EAAE;IACvD,IAAI48C,0BAA0B,GAAG,KAAK;IACtC,KAAK,IAAIC,UAAU,GAAG,IAAI,CAACpD,eAAe,CAAC3+E,MAAM,GAAG,CAAC,EAAE+hF,UAAU,IAAI,CAAC,EAAEA,UAAU,EAAE,EAAE;MACpF,MAAMttE,IAAI,GAAG,IAAI,CAACkqE,eAAe,CAACoD,UAAU,CAAC;MAC7C,MAAMC,QAAQ,GAAGvtE,IAAI,YAAYwnB,SAAS,GAAGxnB,IAAI,CAAC0uB,QAAQ,GAAG1uB,IAAI,CAAC3S,IAAI;MACtE,IAAI,CAACkgF,QAAQ,KAAKJ,YAAY,IAAIA,YAAY,KAAK,IAAI,KAAKntE,IAAI,YAAYotE,YAAY,EAAE;QACxFptE,IAAI,CAACywB,aAAa,GAAGA,aAAa;QAClCzwB,IAAI,CAACvE,UAAU,CAAC7D,GAAG,GAAG64B,aAAa,KAAK,IAAI,GAAGA,aAAa,CAAC74B,GAAG,GAAGoI,IAAI,CAACvE,UAAU,CAAC7D,GAAG;QACtF,IAAI,CAACsyE,eAAe,CAACvZ,MAAM,CAAC2c,UAAU,EAAE,IAAI,CAACpD,eAAe,CAAC3+E,MAAM,GAAG+hF,UAAU,CAAC;QACjF,OAAO,CAACD,0BAA0B;MACpC;MACA,IAAIrtE,IAAI,YAAYw8D,KAAK,IAAI,CAAC,IAAI,CAAC0B,iBAAiB,CAACl+D,IAAI,CAAC,EAAEwtE,cAAc,EAAE;QAC1EH,0BAA0B,GAAG,IAAI;MACnC;IACF;IACA,OAAO,KAAK;EACd;EACAN,YAAYA,CAACp5B,QAAQ,EAAE;IACrB,MAAMjlB,QAAQ,GAAGC,cAAc,CAACglB,QAAQ,CAACxgD,KAAK,CAAC,CAAC,CAAC,EAAEwgD,QAAQ,CAACxgD,KAAK,CAAC,CAAC,CAAC,CAAC;IACrE,IAAIs6E,OAAO,GAAG95B,QAAQ,CAACl4C,UAAU,CAAC7D,GAAG;IACrC,IAAI,IAAI,CAACqyE,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;MAC1B,IAAI,CAAC61E,QAAQ,CAAC,CAAC;IACjB;IACA,IAAI78E,KAAK,GAAG,EAAE;IACd,MAAM+uE,WAAW,GAAG,EAAE;IACtB,IAAIqR,cAAc,GAAGtyD,SAAS;IAC9B,IAAIuyD,QAAQ,GAAGvyD,SAAS;IACxB,MAAMwyD,aAAa,GAAG,IAAI,CAAC3D,KAAK,CAAC31E,IAAI;IACrC,IAAIs5E,aAAa,KAAK,EAAE,EAAE;MACxBF,cAAc,GAAG,IAAI,CAACzD,KAAK,CAACxuE,UAAU;MACtCkyE,QAAQ,GAAG,IAAI,CAAC1D,KAAK,CAACxuE,UAAU,CAAC7D,GAAG;MACpC,OAAO,IAAI,CAACqyE,KAAK,CAAC31E,IAAI,KAAK,EAAE,IAAI,IAAI,CAAC21E,KAAK,CAAC31E,IAAI,KAAK,EAAE,IAAI,IAAI,CAAC21E,KAAK,CAAC31E,IAAI,KAAK,CAAC,EAAE;QAChF,MAAMu5E,UAAU,GAAG,IAAI,CAAC1D,QAAQ,CAAC,CAAC;QAClC9N,WAAW,CAAC7wE,IAAI,CAACqiF,UAAU,CAAC;QAC5B,IAAIA,UAAU,CAACv5E,IAAI,KAAK,EAAE,EAAE;UAC1BhH,KAAK,IAAIugF,UAAU,CAAC16E,KAAK,CAAChG,IAAI,CAAC,EAAE,CAAC,CAACJ,OAAO,CAAC,YAAY,EAAE++E,YAAY,CAAC;QACxE,CAAC,MAAM,IAAI+B,UAAU,CAACv5E,IAAI,KAAK,CAAC,EAAE;UAChChH,KAAK,IAAIugF,UAAU,CAAC16E,KAAK,CAAC,CAAC,CAAC;QAC9B,CAAC,MAAM;UACL7F,KAAK,IAAIugF,UAAU,CAAC16E,KAAK,CAAChG,IAAI,CAAC,EAAE,CAAC;QACpC;QACAwgF,QAAQ,GAAGF,OAAO,GAAGI,UAAU,CAACpyE,UAAU,CAAC7D,GAAG;MAChD;IACF;IACA,IAAI,IAAI,CAACqyE,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;MAC1B,MAAMw5E,UAAU,GAAG,IAAI,CAAC3D,QAAQ,CAAC,CAAC;MAClCsD,OAAO,GAAGK,UAAU,CAACryE,UAAU,CAAC7D,GAAG;IACrC;IACA,MAAMq1B,SAAS,GAAGygD,cAAc,IAAIC,QAAQ,IAAI,IAAI1nC,eAAe,CAACynC,cAAc,CAAC9rD,KAAK,EAAE+rD,QAAQ,EAAED,cAAc,CAACxnC,SAAS,CAAC;IAC7H,OAAO,IAAIiW,SAAS,CAACztB,QAAQ,EAAEphC,KAAK,EAAE,IAAI24C,eAAe,CAAC0N,QAAQ,CAACl4C,UAAU,CAACmmB,KAAK,EAAE6rD,OAAO,EAAE95B,QAAQ,CAACl4C,UAAU,CAACyqC,SAAS,CAAC,EAAEyN,QAAQ,CAACl4C,UAAU,EAAEwxB,SAAS,EAAEovC,WAAW,CAAC9wE,MAAM,GAAG,CAAC,GAAG8wE,WAAW,GAAGjhD,SAAS,EAAEA,SAAS,CAAC;EAC5N;EACAwqD,iBAAiBA,CAACmI,SAAS,EAAE;IAC3B,MAAM79C,UAAU,GAAG,EAAE;IACrB,IAAI89C,kBAAkB,GAAGD,SAAS,CAACtyE,UAAU,CAAC7D,GAAG;IACjD,IAAI64B,aAAa,GAAG,IAAI;IACxB,IAAI,CAAC05C,QAAQ,CAAC,CAAC;IACf,IAAI,IAAI,CAACF,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;MAC1B05E,kBAAkB,GAAG,IAAI,CAAC/D,KAAK,CAACxuE,UAAU,CAAC7D,GAAG;MAC9C,IAAI,CAACuyE,QAAQ,CAAC,CAAC;MACf,OAAO,IAAI,CAACF,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;QAC7B47B,UAAU,CAAC1kC,IAAI,CAAC,IAAI,CAACuhF,YAAY,CAAC,IAAI,CAAC5C,QAAQ,CAAC,CAAC,CAAC,CAAC;MACrD;MACA,IAAI,IAAI,CAACF,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;QAC1Bm8B,aAAa,GAAG,IAAI,CAACw5C,KAAK,CAACxuE,UAAU;QACrC,IAAI,CAAC0uE,QAAQ,CAAC,CAAC;MACjB,CAAC,MAAM;QACL,IAAI,CAAC19C,MAAM,CAACjhC,IAAI,CAAC89E,SAAS,CAACjc,MAAM,CAAC,IAAI,EAAE0gB,SAAS,CAACtyE,UAAU,EAAE,mCAAmC,CAAC,CAAC;MACrG;IACF;IACA,MAAM+0B,eAAe,GAAG,IAAIyV,eAAe,CAAC8nC,SAAS,CAACtyE,UAAU,CAACmmB,KAAK,EAAEosD,kBAAkB,EAAED,SAAS,CAACtyE,UAAU,CAACyqC,SAAS,CAAC;IAC3H,MAAMzqC,UAAU,GAAG,IAAIwqC,eAAe,CAACzV,eAAe,CAAC5O,KAAK,EAAE6O,aAAa,KAAK,IAAI,GAAGs9C,SAAS,CAACtyE,UAAU,CAAC7D,GAAG,GAAG64B,aAAa,CAAC74B,GAAG,EAAE44B,eAAe,CAAC0V,SAAS,CAAC;IAC/J,OAAO,IAAIze,SAAS,CAACsmD,SAAS,CAAC56E,KAAK,CAAC,CAAC,CAAC,EAAE+8B,UAAU,EAAEz0B,UAAU,EAAE+0B,eAAe,EAAEC,aAAa,CAAC;EAClG;EACAg6C,iBAAiBA,CAAC7uD,KAAK,EAAE;IACvB,MAAMxO,UAAU,GAAG,EAAE;IACrB,OAAO,IAAI,CAAC68D,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;MAC7B,MAAM25E,UAAU,GAAG,IAAI,CAAC9D,QAAQ,CAAC,CAAC;MAClC/8D,UAAU,CAAC5hB,IAAI,CAAC,IAAIkxE,cAAc,CAACuR,UAAU,CAAC96E,KAAK,CAAC,CAAC,CAAC,EAAE86E,UAAU,CAACxyE,UAAU,CAAC,CAAC;IACjF;IACA,IAAI,IAAI,CAACwuE,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;MAC1B,IAAI,CAAC61E,QAAQ,CAAC,CAAC;IACjB;IACA,MAAMvyE,GAAG,GAAG,IAAI,CAACqyE,KAAK,CAACxuE,UAAU,CAACyqC,SAAS;IAC3C,MAAMxkB,IAAI,GAAG,IAAIukB,eAAe,CAACrqB,KAAK,CAACngB,UAAU,CAACmmB,KAAK,EAAEhqB,GAAG,EAAEgkB,KAAK,CAACngB,UAAU,CAACyqC,SAAS,CAAC;IACzF,MAAMylC,SAAS,GAAG,IAAI1lC,eAAe,CAACrqB,KAAK,CAACngB,UAAU,CAACmmB,KAAK,EAAEhqB,GAAG,EAAEgkB,KAAK,CAACngB,UAAU,CAACyqC,SAAS,CAAC;IAC9F,MAAM3P,KAAK,GAAG,IAAIimC,KAAK,CAAC5gD,KAAK,CAACzoB,KAAK,CAAC,CAAC,CAAC,EAAEia,UAAU,EAAE,EAAE,EAAEsU,IAAI,EAAE9F,KAAK,CAACngB,UAAU,EAAEkwE,SAAS,CAAC;IAC1F,IAAI,CAACa,cAAc,CAACj2C,KAAK,EAAE,KAAK,CAAC;EACnC;EACAm0C,kBAAkBA,CAAC9uD,KAAK,EAAE;IACxB,IAAI,CAAC,IAAI,CAAC6wD,aAAa,CAAC,IAAI,EAAEjQ,KAAK,EAAE5gD,KAAK,CAACngB,UAAU,CAAC,EAAE;MACtD,IAAI,CAACgxB,MAAM,CAACjhC,IAAI,CAAC89E,SAAS,CAACjc,MAAM,CAAC,IAAI,EAAEzxC,KAAK,CAACngB,UAAU,EAAE,oEAAoE,GAAG,qEAAqE,GAAG,sBAAsB,CAAC,CAAC;IACnO;EACF;EACAkvE,uBAAuBA,CAAC/uD,KAAK,EAAE;IAC7B,MAAMxO,UAAU,GAAG,EAAE;IACrB,OAAO,IAAI,CAAC68D,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;MAC7B,MAAM25E,UAAU,GAAG,IAAI,CAAC9D,QAAQ,CAAC,CAAC;MAClC/8D,UAAU,CAAC5hB,IAAI,CAAC,IAAIkxE,cAAc,CAACuR,UAAU,CAAC96E,KAAK,CAAC,CAAC,CAAC,EAAE86E,UAAU,CAACxyE,UAAU,CAAC,CAAC;IACjF;IACA,MAAM7D,GAAG,GAAG,IAAI,CAACqyE,KAAK,CAACxuE,UAAU,CAACyqC,SAAS;IAC3C,MAAMxkB,IAAI,GAAG,IAAIukB,eAAe,CAACrqB,KAAK,CAACngB,UAAU,CAACmmB,KAAK,EAAEhqB,GAAG,EAAEgkB,KAAK,CAACngB,UAAU,CAACyqC,SAAS,CAAC;IACzF,MAAMylC,SAAS,GAAG,IAAI1lC,eAAe,CAACrqB,KAAK,CAACngB,UAAU,CAACmmB,KAAK,EAAEhqB,GAAG,EAAEgkB,KAAK,CAACngB,UAAU,CAACyqC,SAAS,CAAC;IAC9F,MAAM3P,KAAK,GAAG,IAAIimC,KAAK,CAAC5gD,KAAK,CAACzoB,KAAK,CAAC,CAAC,CAAC,EAAEia,UAAU,EAAE,EAAE,EAAEsU,IAAI,EAAE9F,KAAK,CAACngB,UAAU,EAAEkwE,SAAS,CAAC;IAC1F,IAAI,CAACa,cAAc,CAACj2C,KAAK,EAAE,KAAK,CAAC;IACjC,IAAI,CAACk2C,aAAa,CAAC,IAAI,EAAEjQ,KAAK,EAAE,IAAI,CAAC;IACrC,IAAI,CAAC/vC,MAAM,CAACjhC,IAAI,CAAC89E,SAAS,CAACjc,MAAM,CAACzxC,KAAK,CAACzoB,KAAK,CAAC,CAAC,CAAC,EAAEuuB,IAAI,EAAE,qBAAqB9F,KAAK,CAACzoB,KAAK,CAAC,CAAC,CAAC,4CAA4C,GAAG,iDAAiD,CAAC,CAAC;EAC/L;EACAy3E,WAAWA,CAACjJ,UAAU,EAAE;IACtB,MAAMt0E,IAAI,GAAGs0E,UAAU,CAACxuE,KAAK,CAAC,CAAC,CAAC;IAChC,IAAI06E,UAAU;IACd,IAAI1C,QAAQ;IACZ,IAAI,IAAI,CAAClB,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;MAC1B,IAAI,CAACm4B,MAAM,CAACjhC,IAAI,CAAC89E,SAAS,CAACjc,MAAM,CAACsU,UAAU,CAACxuE,KAAK,CAAC,CAAC,CAAC,EAAEwuE,UAAU,CAAClmE,UAAU,EAAE,6BAA6BpO,IAAI,mCAAmC,CAAC,CAAC;MACpJ;IACF,CAAC,MAAM;MACLwgF,UAAU,GAAG,IAAI,CAAC1D,QAAQ,CAAC,CAAC;IAC9B;IACA,IAAI,IAAI,CAACF,KAAK,CAAC31E,IAAI,KAAK,EAAE,EAAE;MAC1B,IAAI,CAACm4B,MAAM,CAACjhC,IAAI,CAAC89E,SAAS,CAACjc,MAAM,CAACsU,UAAU,CAACxuE,KAAK,CAAC,CAAC,CAAC,EAAEwuE,UAAU,CAAClmE,UAAU,EAAE,kCAAkCpO,IAAI,qDAAqD,CAAC,CAAC;MAC3K;IACF,CAAC,MAAM;MACL89E,QAAQ,GAAG,IAAI,CAAChB,QAAQ,CAAC,CAAC;IAC5B;IACA,MAAMvyE,GAAG,GAAGuzE,QAAQ,CAAC1vE,UAAU,CAACyqC,SAAS;IACzC,MAAMxkB,IAAI,GAAG,IAAIukB,eAAe,CAAC07B,UAAU,CAAClmE,UAAU,CAACmmB,KAAK,EAAEhqB,GAAG,EAAE+pE,UAAU,CAAClmE,UAAU,CAACyqC,SAAS,CAAC;IACnG,MAAMR,WAAW,GAAGi8B,UAAU,CAAClmE,UAAU,CAACjO,QAAQ,CAAC,CAAC,CAAC63C,WAAW,CAACh4C,IAAI,CAAC;IACtE,MAAMq3E,SAAS,GAAG/C,UAAU,CAAClmE,UAAU,CAACmmB,KAAK,CAACojB,MAAM,CAACU,WAAW,CAAC;IACjE,MAAMxd,QAAQ,GAAG,IAAI+d,eAAe,CAACy+B,SAAS,EAAE/C,UAAU,CAAClmE,UAAU,CAAC7D,GAAG,CAAC;IAC1E,MAAMoI,IAAI,GAAG,IAAI20B,cAAc,CAACtnC,IAAI,EAAEwgF,UAAU,CAAC16E,KAAK,CAAC,CAAC,CAAC,EAAEuuB,IAAI,EAAEwG,QAAQ,EAAE2lD,UAAU,CAACpyE,UAAU,CAAC;IACjG,IAAI,CAAC2vE,YAAY,CAACprE,IAAI,CAAC;EACzB;EACA6qE,qBAAqBA,CAACjvD,KAAK,EAAE;IAC3B,MAAMvuB,IAAI,GAAGuuB,KAAK,CAACzoB,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE;IACjC,MAAM+6E,UAAU,GAAG7gF,IAAI,GAAG,KAAKA,IAAI,GAAG,GAAG,EAAE;IAC3C,IAAIA,IAAI,CAAC9B,MAAM,GAAG,CAAC,EAAE;MACnB,MAAMm6C,WAAW,GAAG9pB,KAAK,CAACngB,UAAU,CAACjO,QAAQ,CAAC,CAAC,CAAC63C,WAAW,CAACh4C,IAAI,CAAC;MACjE,MAAMq3E,SAAS,GAAG9oD,KAAK,CAACngB,UAAU,CAACmmB,KAAK,CAACojB,MAAM,CAACU,WAAW,CAAC;MAC5D,MAAMxd,QAAQ,GAAG,IAAI+d,eAAe,CAACy+B,SAAS,EAAE9oD,KAAK,CAACngB,UAAU,CAAC7D,GAAG,CAAC;MACrE,MAAMq1B,SAAS,GAAG,IAAIgZ,eAAe,CAACrqB,KAAK,CAACngB,UAAU,CAACmmB,KAAK,EAAEhG,KAAK,CAACngB,UAAU,CAACmmB,KAAK,CAACojB,MAAM,CAAC,CAAC,CAAC,CAAC;MAC/F,MAAMhlC,IAAI,GAAG,IAAI20B,cAAc,CAACtnC,IAAI,EAAE,EAAE,EAAEuuB,KAAK,CAACngB,UAAU,EAAEysB,QAAQ,EAAE+E,SAAS,CAAC;MAChF,IAAI,CAACm+C,YAAY,CAACprE,IAAI,CAAC;IACzB;IACA,IAAI,CAACysB,MAAM,CAACjhC,IAAI,CAAC89E,SAAS,CAACjc,MAAM,CAACzxC,KAAK,CAACzoB,KAAK,CAAC,CAAC,CAAC,EAAEyoB,KAAK,CAACngB,UAAU,EAAE,8BAA8ByyE,UAAU,IAAI,GAAG,iEAAiE,CAAC,CAAC;EACxL;EACAtC,aAAaA,CAAA,EAAG;IACd,OAAO,IAAI,CAAC1B,eAAe,CAAC3+E,MAAM,GAAG,CAAC,GAAG,IAAI,CAAC2+E,eAAe,CAAC,IAAI,CAACA,eAAe,CAAC3+E,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI;EACvG;EACA4gF,4BAA4BA,CAAA,EAAG;IAC7B,KAAK,IAAIx/E,CAAC,GAAG,IAAI,CAACu9E,eAAe,CAAC3+E,MAAM,GAAG,CAAC,EAAEoB,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,EAAE,EAAE;MACzD,MAAMhB,OAAO,GAAG,IAAI,CAACu+E,eAAe,CAACv9E,CAAC,CAAC;MACvC,IAAIhB,OAAO,YAAYskC,OAAO,IAAItkC,OAAO,YAAY67B,SAAS,EAAE;QAC9D,OAAO77B,OAAO;MAChB;IACF;IACA,OAAO,IAAI;EACb;EACAy/E,YAAYA,CAACprE,IAAI,EAAE;IACjB,MAAM6sD,MAAM,GAAG,IAAI,CAAC+e,aAAa,CAAC,CAAC;IACnC,IAAI/e,MAAM,KAAK,IAAI,EAAE;MACnB,IAAI,CAAC2c,SAAS,CAACh+E,IAAI,CAACwU,IAAI,CAAC;IAC3B,CAAC,MAAM;MACL6sD,MAAM,CAACh5D,QAAQ,CAACrI,IAAI,CAACwU,IAAI,CAAC;IAC5B;EACF;EACAksE,mBAAmBA,CAACtwD,KAAK,EAAEixC,MAAM,EAAE;IACjC,MAAM5gE,MAAM,GAAG,IAAI,CAACkiF,UAAU,CAACvyD,KAAK,EAAEixC,MAAM,CAAC;IAC7C,OAAOl+B,cAAc,CAAC1iC,MAAM,EAAE2vB,KAAK,CAACzoB,KAAK,CAAC,CAAC,CAAC,CAAC;EAC/C;EACAy5E,qBAAqBA,CAAChxD,KAAK,EAAEixC,MAAM,EAAE;IACnC,MAAM/3B,aAAa,GAAGlZ,KAAK,CAACzoB,KAAK,CAAC,CAAC,CAAC;IACpC,MAAMqX,OAAO,GAAG,IAAI,CAACmiE,oBAAoB,CAAC/wD,KAAK,EAAEixC,MAAM,CAAC;IACxD,IAAIriD,OAAO,KAAK,IAAI,EAAE;MACpB,OAAOsqB,aAAa;IACtB;IACA,OAAOtqB,OAAO,CAACmS,UAAU,CAAC,GAAG,CAAC,GAAGmY,aAAa,GAAGtqB,OAAO,GAAG,GAAGsqB,aAAa,IAAItqB,OAAO,EAAE;EAC1F;EACAmiE,oBAAoBA,CAAC/wD,KAAK,EAAEixC,MAAM,EAAE;IAClC,MAAM5gE,MAAM,GAAG,IAAI,CAACkiF,UAAU,CAACvyD,KAAK,EAAEixC,MAAM,CAAC;IAC7C,MAAMriD,OAAO,GAAGoR,KAAK,CAACzoB,KAAK,CAAC,CAAC,CAAC;IAC9B,IAAI,CAAClH,MAAM,IAAI,CAACue,OAAO,EAAE;MACvB,OAAO,IAAI;IACb,CAAC,MAAM,IAAI,CAACve,MAAM,IAAIue,OAAO,EAAE;MAC7B,OAAOA,OAAO;IAChB,CAAC,MAAM;MACL,OAAOmkB,cAAc,CAAC1iC,MAAM,EAAEue,OAAO,IAAI,cAAc,CAAC;IAC1D;EACF;EACA2jE,UAAUA,CAACvyD,KAAK,EAAEixC,MAAM,EAAE;IACxB,IAAI5gE,MAAM;IACV,IAAIue,OAAO;IACX,IAAIoR,KAAK,CAACtnB,IAAI,KAAK,EAAE,IAAIsnB,KAAK,CAACtnB,IAAI,KAAK,EAAE,IAAIsnB,KAAK,CAACtnB,IAAI,KAAK,EAAE,EAAE;MAC/DrI,MAAM,GAAG2vB,KAAK,CAACzoB,KAAK,CAAC,CAAC,CAAC;MACvBqX,OAAO,GAAGoR,KAAK,CAACzoB,KAAK,CAAC,CAAC,CAAC;IAC1B,CAAC,MAAM;MACLlH,MAAM,GAAG2vB,KAAK,CAACzoB,KAAK,CAAC,CAAC,CAAC;MACvBqX,OAAO,GAAGoR,KAAK,CAACzoB,KAAK,CAAC,CAAC,CAAC;IAC1B;IACAlH,MAAM,GAAGA,MAAM,IAAI,IAAI,CAACiyE,iBAAiB,CAAC1zD,OAAO,CAAC,EAAE4jE,uBAAuB,IAAI,EAAE;IACjF,IAAI,CAACniF,MAAM,IAAI4gE,MAAM,EAAE;MACrB,MAAMwhB,UAAU,GAAGxhB,MAAM,YAAY58B,OAAO,GAAG48B,MAAM,CAACx/D,IAAI,GAAGw/D,MAAM,CAACriD,OAAO;MAC3E,IAAI6jE,UAAU,KAAK,IAAI,EAAE;QACvB,MAAMC,aAAa,GAAGngD,WAAW,CAACkgD,UAAU,CAAC,CAAC,CAAC,CAAC;QAChD,MAAME,mBAAmB,GAAG,IAAI,CAACrQ,iBAAiB,CAACoQ,aAAa,CAAC;QACjE,IAAIC,mBAAmB,KAAK,IAAI,IAAI,CAACA,mBAAmB,CAACC,2BAA2B,EAAE;UACpFviF,MAAM,GAAGwiC,WAAW,CAAC4/C,UAAU,CAAC;QAClC;MACF;IACF;IACA,OAAOpiF,MAAM;EACf;AACF;AACA,SAASy/E,WAAWA,CAAC+C,KAAK,EAAE5jF,OAAO,EAAE;EACnC,OAAO4jF,KAAK,CAACljF,MAAM,GAAG,CAAC,IAAIkjF,KAAK,CAACA,KAAK,CAACljF,MAAM,GAAG,CAAC,CAAC,KAAKV,OAAO;AAChE;AACA,SAASihF,YAAYA,CAACpgF,KAAK,EAAEgjF,MAAM,EAAE;EACnC,IAAI1R,cAAc,CAAC0R,MAAM,CAAC,KAAKtzD,SAAS,EAAE;IACxC,OAAO4hD,cAAc,CAAC0R,MAAM,CAAC,IAAIhjF,KAAK;EACxC;EACA,IAAI,gBAAgB,CAACkxB,IAAI,CAAC8xD,MAAM,CAAC,EAAE;IACjC,OAAOh0E,MAAM,CAACmpE,aAAa,CAACY,QAAQ,CAACiK,MAAM,CAACviF,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;EAC5D;EACA,IAAI,QAAQ,CAACywB,IAAI,CAAC8xD,MAAM,CAAC,EAAE;IACzB,OAAOh0E,MAAM,CAACmpE,aAAa,CAACY,QAAQ,CAACiK,MAAM,CAACviF,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;EAC5D;EACA,OAAOT,KAAK;AACd;AAEA,MAAMijF,qBAAqB,GAAG,uBAAuB;AACrD,MAAMC,iBAAiB,GAAG,IAAI/hC,GAAG,CAAC,CAAC,KAAK,EAAE,UAAU,EAAE,UAAU,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;AACrF,MAAMgiC,QAAQ,GAAG,0EAA0E;AAC3F,MAAMC,YAAY,GAAG,IAAInkF,MAAM,CAAC,KAAKkkF,QAAQ,GAAG,CAAC;AACjD,MAAME,iBAAiB,GAAG,IAAIpkF,MAAM,CAAC,IAAIkkF,QAAQ,OAAO,EAAE,GAAG,CAAC;AAC9D,SAASG,0BAA0BA,CAACjkF,KAAK,EAAE;EACzC,OAAOA,KAAK,CAACiyC,IAAI,CAACxwC,IAAI,IAAIA,IAAI,CAACa,IAAI,KAAKshF,qBAAqB,CAAC;AAChE;AACA,SAASM,WAAWA,CAAC3hF,KAAK,EAAE;EAC1B,OAAOA,KAAK,CAACP,OAAO,CAAC,IAAIpC,MAAM,CAACsyE,YAAY,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC;AAC1D;AACA,MAAMiS,iBAAiB,CAAC;EACtBC,6BAA6B;EAC7BC,eAAe;EACfC,cAAc;EACdC,iBAAiB,GAAG,CAAC;EACrBj/E,WAAWA,CAAC8+E,6BAA6B,EAAEC,eAAe,EAAEC,cAAc,GAAG,IAAI,EAAE;IACjF,IAAI,CAACF,6BAA6B,GAAGA,6BAA6B;IAClE,IAAI,CAACC,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,cAAc,GAAGA,cAAc;EACtC;EACA3+C,YAAYA,CAAC7lC,OAAO,EAAE6I,OAAO,EAAE;IAC7B,IAAIk7E,iBAAiB,CAACl+E,GAAG,CAAC7F,OAAO,CAACwC,IAAI,CAAC,IAAI2hF,0BAA0B,CAACnkF,OAAO,CAACE,KAAK,CAAC,EAAE;MACpF,MAAMwkF,UAAU,GAAG,IAAIt/C,OAAO,CAACplC,OAAO,CAACwC,IAAI,EAAEmiF,oBAAoB,CAAC,IAAI,EAAE3kF,OAAO,CAACE,KAAK,CAAC,EAAEykF,oBAAoB,CAAC,IAAI,EAAE3kF,OAAO,CAACwlC,UAAU,CAAC,EAAExlC,OAAO,CAACgJ,QAAQ,EAAEhJ,OAAO,CAAC0lC,aAAa,EAAE1lC,OAAO,CAAC4Q,UAAU,EAAE5Q,OAAO,CAAC2lC,eAAe,EAAE3lC,OAAO,CAAC4lC,aAAa,EAAE5lC,OAAO,CAAC4J,MAAM,EAAE5J,OAAO,CAACypB,IAAI,CAAC;MAClR,IAAI,CAAC86D,eAAe,EAAE7/E,GAAG,CAACggF,UAAU,EAAE1kF,OAAO,CAAC;MAC9C,OAAO0kF,UAAU;IACnB;IACA,MAAMA,UAAU,GAAG,IAAIt/C,OAAO,CAACplC,OAAO,CAACwC,IAAI,EAAExC,OAAO,CAACE,KAAK,EAAEF,OAAO,CAACwlC,UAAU,EAAEm/C,oBAAoB,CAAC,IAAI,EAAE3kF,OAAO,CAACgJ,QAAQ,CAAC,EAAEhJ,OAAO,CAAC0lC,aAAa,EAAE1lC,OAAO,CAAC4Q,UAAU,EAAE5Q,OAAO,CAAC2lC,eAAe,EAAE3lC,OAAO,CAAC4lC,aAAa,EAAE5lC,OAAO,CAAC4J,MAAM,EAAE5J,OAAO,CAACypB,IAAI,CAAC;IACtP,IAAI,CAAC86D,eAAe,EAAE7/E,GAAG,CAACggF,UAAU,EAAE1kF,OAAO,CAAC;IAC9C,OAAO0kF,UAAU;EACnB;EACAjT,cAAcA,CAAChwE,SAAS,EAAEoH,OAAO,EAAE;IACjC,OAAOpH,SAAS,CAACe,IAAI,KAAKshF,qBAAqB,GAAGriF,SAAS,GAAG,IAAI;EACpE;EACAkH,SAASA,CAACC,IAAI,EAAEC,OAAO,EAAE;IACvB,MAAM+7E,UAAU,GAAGh8E,IAAI,CAACnG,KAAK,CAAC5B,KAAK,CAACojF,YAAY,CAAC;IACjD,MAAMY,mBAAmB,GAAGh8E,OAAO,KAAKA,OAAO,CAACm9C,IAAI,YAAYgrB,SAAS,IAAInoE,OAAO,CAAC8mD,IAAI,YAAYqhB,SAAS,CAAC;IAC/G,MAAM8T,cAAc,GAAG,IAAI,CAACL,iBAAiB,GAAG,CAAC;IACjD,IAAIK,cAAc,IAAI,IAAI,CAACR,6BAA6B,EAAE,OAAO17E,IAAI;IACrE,IAAIg8E,UAAU,IAAIC,mBAAmB,EAAE;MACrC,MAAM9T,MAAM,GAAGnoE,IAAI,CAACmoE,MAAM,CAAClsE,GAAG,CAACksB,KAAK,IAAIA,KAAK,CAACtnB,IAAI,KAAK,CAAC,GAAGs7E,kCAAkC,CAACh0D,KAAK,CAAC,GAAGA,KAAK,CAAC;MAC7G,IAAI,CAAC,IAAI,CAACuzD,6BAA6B,IAAIvT,MAAM,CAACrwE,MAAM,GAAG,CAAC,EAAE;QAC5D,MAAMskF,UAAU,GAAGjU,MAAM,CAAC,CAAC,CAAC;QAC5BA,MAAM,CAACjL,MAAM,CAAC,CAAC,EAAE,CAAC,EAAEmf,qBAAqB,CAACD,UAAU,EAAEn8E,OAAO,CAAC,CAAC;QAC/D,MAAMq8E,SAAS,GAAGnU,MAAM,CAACA,MAAM,CAACrwE,MAAM,GAAG,CAAC,CAAC;QAC3CqwE,MAAM,CAACjL,MAAM,CAACiL,MAAM,CAACrwE,MAAM,GAAG,CAAC,EAAE,CAAC,EAAEykF,sBAAsB,CAACD,SAAS,EAAEr8E,OAAO,CAAC,CAAC;MACjF;MACA,MAAM8oD,SAAS,GAAGyzB,iBAAiB,CAACx8E,IAAI,CAACnG,KAAK,CAAC;MAC/C,MAAMA,KAAK,GAAG,IAAI,CAAC6hF,6BAA6B,GAAG3yB,SAAS,GAAG0zB,gCAAgC,CAAC1zB,SAAS,EAAE9oD,OAAO,CAAC;MACnH,MAAMjH,MAAM,GAAG,IAAIwiC,IAAI,CAAC3hC,KAAK,EAAEmG,IAAI,CAACgI,UAAU,EAAEmgE,MAAM,EAAEnoE,IAAI,CAAC6gB,IAAI,CAAC;MAClE,IAAI,CAAC86D,eAAe,EAAE7/E,GAAG,CAAC9C,MAAM,EAAEgH,IAAI,CAAC;MACvC,OAAOhH,MAAM;IACf;IACA,OAAO,IAAI;EACb;EACA8vE,YAAYA,CAAC95C,OAAO,EAAE/uB,OAAO,EAAE;IAC7B,OAAO+uB,OAAO;EAChB;EACAu5C,cAAcA,CAACmU,SAAS,EAAEz8E,OAAO,EAAE;IACjC,IAAI,CAAC47E,iBAAiB,EAAE;IACxB,IAAIc,YAAY;IAChB,IAAI;MACFA,YAAY,GAAG,IAAIvU,SAAS,CAACsU,SAAS,CAACrU,WAAW,EAAEqU,SAAS,CAAC77E,IAAI,EAAEk7E,oBAAoB,CAAC,IAAI,EAAEW,SAAS,CAACh8E,KAAK,CAAC,EAAEg8E,SAAS,CAAC10E,UAAU,EAAE00E,SAAS,CAACpU,qBAAqB,EAAEoU,SAAS,CAAC77D,IAAI,CAAC;IACzL,CAAC,SAAS;MACR,IAAI,CAACg7D,iBAAiB,EAAE;IAC1B;IACA,IAAI,CAACF,eAAe,EAAE7/E,GAAG,CAAC6gF,YAAY,EAAED,SAAS,CAAC;IAClD,OAAOC,YAAY;EACrB;EACAhU,kBAAkBA,CAACiU,aAAa,EAAE38E,OAAO,EAAE;IACzC,MAAM48E,gBAAgB,GAAG,IAAIrU,aAAa,CAACoU,aAAa,CAAC/iF,KAAK,EAAEkiF,oBAAoB,CAAC,IAAI,EAAEa,aAAa,CAACh8E,UAAU,CAAC,EAAEg8E,aAAa,CAAC50E,UAAU,EAAE40E,aAAa,CAACnU,eAAe,EAAEmU,aAAa,CAAClU,aAAa,CAAC;IAC3M,IAAI,CAACiT,eAAe,EAAE7/E,GAAG,CAAC+gF,gBAAgB,EAAED,aAAa,CAAC;IAC1D,OAAOC,gBAAgB;EACzB;EACA7T,UAAUA,CAAClmC,KAAK,EAAE7iC,OAAO,EAAE;IACzB,MAAM68E,QAAQ,GAAG,IAAI/T,KAAK,CAACjmC,KAAK,CAAClpC,IAAI,EAAEkpC,KAAK,CAACnpB,UAAU,EAAEoiE,oBAAoB,CAAC,IAAI,EAAEj5C,KAAK,CAAC1iC,QAAQ,CAAC,EAAE0iC,KAAK,CAAC96B,UAAU,EAAE86B,KAAK,CAACrO,QAAQ,EAAEqO,KAAK,CAAC/F,eAAe,EAAE+F,KAAK,CAAC9F,aAAa,CAAC;IAClL,IAAI,CAAC2+C,eAAe,EAAE7/E,GAAG,CAACghF,QAAQ,EAAEh6C,KAAK,CAAC;IAC1C,OAAOg6C,QAAQ;EACjB;EACA5T,mBAAmBA,CAAC6T,SAAS,EAAE98E,OAAO,EAAE;IACtC,OAAO88E,SAAS;EAClB;EACA57C,mBAAmBA,CAACgC,IAAI,EAAEljC,OAAO,EAAE;IACjC,OAAOkjC,IAAI;EACb;EACA7B,cAAcA,CAAC/0B,IAAI,EAAEtM,OAAO,EAAE;IAC5B,IAAIsM,IAAI,CAACwK,OAAO,IAAIokE,iBAAiB,CAACl+E,GAAG,CAACsP,IAAI,CAACwK,OAAO,CAAC,IAAIwkE,0BAA0B,CAAChvE,IAAI,CAACjV,KAAK,CAAC,EAAE;MACjG,MAAMwkF,UAAU,GAAG,IAAI/nD,SAAS,CAACxnB,IAAI,CAAC80B,aAAa,EAAE90B,IAAI,CAACwK,OAAO,EAAExK,IAAI,CAAC0uB,QAAQ,EAAE8gD,oBAAoB,CAAC,IAAI,EAAExvE,IAAI,CAACjV,KAAK,CAAC,EAAEykF,oBAAoB,CAAC,IAAI,EAAExvE,IAAI,CAACqwB,UAAU,CAAC,EAAErwB,IAAI,CAACnM,QAAQ,EAAEmM,IAAI,CAACuwB,aAAa,EAAEvwB,IAAI,CAACvE,UAAU,EAAEuE,IAAI,CAACwwB,eAAe,EAAExwB,IAAI,CAACywB,aAAa,EAAEzwB,IAAI,CAACsU,IAAI,CAAC;MAC/Q,IAAI,CAAC86D,eAAe,EAAE7/E,GAAG,CAACggF,UAAU,EAAEvvE,IAAI,CAAC;MAC3C,OAAOuvE,UAAU;IACnB;IACA,MAAMA,UAAU,GAAG,IAAI/nD,SAAS,CAACxnB,IAAI,CAAC80B,aAAa,EAAE90B,IAAI,CAACwK,OAAO,EAAExK,IAAI,CAAC0uB,QAAQ,EAAE1uB,IAAI,CAACjV,KAAK,EAAEiV,IAAI,CAACqwB,UAAU,EAAEm/C,oBAAoB,CAAC,IAAI,EAAExvE,IAAI,CAACnM,QAAQ,CAAC,EAAEmM,IAAI,CAACuwB,aAAa,EAAEvwB,IAAI,CAACvE,UAAU,EAAEuE,IAAI,CAACwwB,eAAe,EAAExwB,IAAI,CAACywB,aAAa,EAAEzwB,IAAI,CAACsU,IAAI,CAAC;IACnP,IAAI,CAAC86D,eAAe,EAAE7/E,GAAG,CAACggF,UAAU,EAAEvvE,IAAI,CAAC;IAC3C,OAAOuvE,UAAU;EACnB;EACAt6C,cAAcA,CAACyB,SAAS,EAAEhjC,OAAO,EAAE;IACjC,OAAOgjC,SAAS;EAClB;EACArjC,KAAKA,CAACo9E,KAAK,EAAE/8E,OAAO,EAAE;IACpB,IAAI,IAAI,CAAC27E,cAAc,IAAI,CAAC37E,OAAO,EAAE;MACnC,MAAM,IAAI3H,KAAK,CAAC,6FAA6F,CAAC;IAChH;IACA,OAAO,KAAK;EACd;AACF;AACA,SAAS+jF,qBAAqBA,CAACl0D,KAAK,EAAEloB,OAAO,EAAE;EAC7C,IAAIkoB,KAAK,CAACtnB,IAAI,KAAK,CAAC,EAAE,OAAOsnB,KAAK;EAClC,MAAM80D,iBAAiB,GAAG,CAACh9E,OAAO,EAAEm9C,IAAI;EACxC,IAAI,CAAC6/B,iBAAiB,EAAE,OAAO90D,KAAK;EACpC,OAAO+0D,kBAAkB,CAAC/0D,KAAK,EAAEnoB,IAAI,IAAIA,IAAI,CAACm9E,SAAS,CAAC,CAAC,CAAC;AAC5D;AACA,SAASZ,sBAAsBA,CAACp0D,KAAK,EAAEloB,OAAO,EAAE;EAC9C,IAAIkoB,KAAK,CAACtnB,IAAI,KAAK,CAAC,EAAE,OAAOsnB,KAAK;EAClC,MAAMi1D,gBAAgB,GAAG,CAACn9E,OAAO,EAAE8mD,IAAI;EACvC,IAAI,CAACq2B,gBAAgB,EAAE,OAAOj1D,KAAK;EACnC,OAAO+0D,kBAAkB,CAAC/0D,KAAK,EAAEnoB,IAAI,IAAIA,IAAI,CAACq9E,OAAO,CAAC,CAAC,CAAC;AAC1D;AACA,SAASZ,gCAAgCA,CAACz8E,IAAI,EAAEC,OAAO,EAAE;EACvD,MAAMg9E,iBAAiB,GAAG,CAACh9E,OAAO,EAAEm9C,IAAI;EACxC,MAAMggC,gBAAgB,GAAG,CAACn9E,OAAO,EAAE8mD,IAAI;EACvC,MAAMu2B,iBAAiB,GAAGL,iBAAiB,GAAGj9E,IAAI,CAACm9E,SAAS,CAAC,CAAC,GAAGn9E,IAAI;EACrE,MAAMu9E,YAAY,GAAGH,gBAAgB,GAAGE,iBAAiB,CAACD,OAAO,CAAC,CAAC,GAAGC,iBAAiB;EACvF,OAAOC,YAAY;AACrB;AACA,SAASpB,kCAAkCA,CAAC;EAC1Ct7E,IAAI;EACJnB,KAAK;EACLsI;AACF,CAAC,EAAE;EACD,OAAO;IACLnH,IAAI;IACJnB,KAAK,EAAE,CAAC88E,iBAAiB,CAAC98E,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IACpCsI;EACF,CAAC;AACH;AACA,SAASk1E,kBAAkBA,CAAC;EAC1Br8E,IAAI;EACJnB,KAAK;EACLsI;AACF,CAAC,EAAEgjD,SAAS,EAAE;EACZ,OAAO;IACLnqD,IAAI;IACJnB,KAAK,EAAE,CAACsrD,SAAS,CAACtrD,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5BsI;EACF,CAAC;AACH;AACA,SAASw0E,iBAAiBA,CAACx8E,IAAI,EAAE;EAC/B,OAAOw7E,WAAW,CAACx7E,IAAI,CAAC,CAAC1G,OAAO,CAACgiF,iBAAiB,EAAE,GAAG,CAAC;AAC1D;AACA,SAASS,oBAAoBA,CAACv8E,OAAO,EAAEJ,KAAK,EAAE;EAC5C,MAAMpG,MAAM,GAAG,EAAE;EACjBoG,KAAK,CAACpF,OAAO,CAAC,CAACib,GAAG,EAAE/b,CAAC,KAAK;IACxB,MAAM+G,OAAO,GAAG;MACdm9C,IAAI,EAAEh+C,KAAK,CAAClG,CAAC,GAAG,CAAC,CAAC;MAClB6tD,IAAI,EAAE3nD,KAAK,CAAClG,CAAC,GAAG,CAAC;IACnB,CAAC;IACD,MAAMiwE,SAAS,GAAGl0D,GAAG,CAACrV,KAAK,CAACJ,OAAO,EAAES,OAAO,CAAC;IAC7C,IAAIkpE,SAAS,EAAE;MACbnwE,MAAM,CAACjB,IAAI,CAACoxE,SAAS,CAAC;IACxB;EACF,CAAC,CAAC;EACF,OAAOnwE,MAAM;AACf;AAEA,IAAIwkF,SAAS;AACb,CAAC,UAAUA,SAAS,EAAE;EACpBA,SAAS,CAACA,SAAS,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;EACnDA,SAAS,CAACA,SAAS,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,GAAG,YAAY;EACrDA,SAAS,CAACA,SAAS,CAAC,mBAAmB,CAAC,GAAG,CAAC,CAAC,GAAG,mBAAmB;EACnEA,SAAS,CAACA,SAAS,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;EAC/CA,SAAS,CAACA,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;EAC7CA,SAAS,CAACA,SAAS,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EACjDA,SAAS,CAACA,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;EAC7CA,SAAS,CAACA,SAAS,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,GAAG,YAAY;EACrDA,SAAS,CAACA,SAAS,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,GAAG,aAAa;EACvDA,SAAS,CAACA,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;AAC7C,CAAC,EAAEA,SAAS,KAAKA,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC;AACjC,IAAIC,eAAe;AACnB,CAAC,UAAUA,eAAe,EAAE;EAC1BA,eAAe,CAACA,eAAe,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;EACvDA,eAAe,CAACA,eAAe,CAAC,qBAAqB,CAAC,GAAG,CAAC,CAAC,GAAG,qBAAqB;EACnFA,eAAe,CAACA,eAAe,CAAC,oBAAoB,CAAC,GAAG,CAAC,CAAC,GAAG,oBAAoB;AACnF,CAAC,EAAEA,eAAe,KAAKA,eAAe,GAAG,CAAC,CAAC,CAAC,CAAC;AAC7C,MAAMC,QAAQ,GAAG,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,WAAW,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,IAAI,CAAC;AACzH,MAAMC,KAAK,CAAC;EACVhU,QAAQA,CAAC3pE,IAAI,EAAE;IACb,OAAO,IAAI49E,QAAQ,CAAC59E,IAAI,CAAC,CAAC69E,IAAI,CAAC,CAAC;EAClC;AACF;AACA,MAAMC,KAAK,CAAC;EACVz6E,KAAK;EACLc,GAAG;EACHtD,IAAI;EACJk9E,QAAQ;EACRC,QAAQ;EACRphF,WAAWA,CAACyG,KAAK,EAAEc,GAAG,EAAEtD,IAAI,EAAEk9E,QAAQ,EAAEC,QAAQ,EAAE;IAChD,IAAI,CAAC36E,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACc,GAAG,GAAGA,GAAG;IACd,IAAI,CAACtD,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACk9E,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;EAC1B;EACAC,WAAWA,CAACntC,IAAI,EAAE;IAChB,OAAO,IAAI,CAACjwC,IAAI,KAAK28E,SAAS,CAACU,SAAS,IAAI,IAAI,CAACH,QAAQ,KAAKjtC,IAAI;EACpE;EACAqtC,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI,CAACt9E,IAAI,KAAK28E,SAAS,CAACz2E,MAAM;EACvC;EACAq3E,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI,CAACv9E,IAAI,KAAK28E,SAAS,CAACv2E,MAAM;EACvC;EACAo3E,UAAUA,CAAC3sE,QAAQ,EAAE;IACnB,OAAO,IAAI,CAAC7Q,IAAI,KAAK28E,SAAS,CAACc,QAAQ,IAAI,IAAI,CAACN,QAAQ,KAAKtsE,QAAQ;EACvE;EACA6sE,YAAYA,CAAA,EAAG;IACb,OAAO,IAAI,CAAC19E,IAAI,KAAK28E,SAAS,CAACxX,UAAU;EAC3C;EACAwY,mBAAmBA,CAAA,EAAG;IACpB,OAAO,IAAI,CAAC39E,IAAI,KAAK28E,SAAS,CAACiB,iBAAiB;EAClD;EACAC,SAASA,CAAA,EAAG;IACV,OAAO,IAAI,CAAC79E,IAAI,KAAK28E,SAAS,CAACmB,OAAO;EACxC;EACAC,YAAYA,CAAA,EAAG;IACb,OAAO,IAAI,CAAC/9E,IAAI,KAAK28E,SAAS,CAACmB,OAAO,IAAI,IAAI,CAACX,QAAQ,KAAK,KAAK;EACnE;EACAa,WAAWA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACh+E,IAAI,KAAK28E,SAAS,CAACmB,OAAO,IAAI,IAAI,CAACX,QAAQ,KAAK,IAAI;EAClE;EACAc,aAAaA,CAAA,EAAG;IACd,OAAO,IAAI,CAACj+E,IAAI,KAAK28E,SAAS,CAACmB,OAAO,IAAI,IAAI,CAACX,QAAQ,KAAK,MAAM;EACpE;EACAe,kBAAkBA,CAAA,EAAG;IACnB,OAAO,IAAI,CAACl+E,IAAI,KAAK28E,SAAS,CAACmB,OAAO,IAAI,IAAI,CAACX,QAAQ,KAAK,WAAW;EACzE;EACAgB,aAAaA,CAAA,EAAG;IACd,OAAO,IAAI,CAACn+E,IAAI,KAAK28E,SAAS,CAACmB,OAAO,IAAI,IAAI,CAACX,QAAQ,KAAK,MAAM;EACpE;EACAiB,cAAcA,CAAA,EAAG;IACf,OAAO,IAAI,CAACp+E,IAAI,KAAK28E,SAAS,CAACmB,OAAO,IAAI,IAAI,CAACX,QAAQ,KAAK,OAAO;EACrE;EACAkB,aAAaA,CAAA,EAAG;IACd,OAAO,IAAI,CAACr+E,IAAI,KAAK28E,SAAS,CAACmB,OAAO,IAAI,IAAI,CAACX,QAAQ,KAAK,MAAM;EACpE;EACAmB,eAAeA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACt+E,IAAI,KAAK28E,SAAS,CAACmB,OAAO,IAAI,IAAI,CAACX,QAAQ,KAAK,QAAQ;EACtE;EACAoB,aAAaA,CAAA,EAAG;IACd,OAAO,IAAI,CAACv+E,IAAI,KAAK28E,SAAS,CAACmB,OAAO,IAAI,IAAI,CAACX,QAAQ,KAAK,MAAM;EACpE;EACAqB,WAAWA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACx+E,IAAI,KAAK28E,SAAS,CAACmB,OAAO,IAAI,IAAI,CAACX,QAAQ,KAAK,IAAI;EAClE;EACAsB,OAAOA,CAAA,EAAG;IACR,OAAO,IAAI,CAACz+E,IAAI,KAAK28E,SAAS,CAACllF,KAAK;EACtC;EACAinF,YAAYA,CAAA,EAAG;IACb,OAAO,IAAI,CAAC1+E,IAAI,KAAK28E,SAAS,CAACgC,UAAU;EAC3C;EACAC,aAAaA,CAAA,EAAG;IACd,OAAO,IAAI,CAAC5+E,IAAI,KAAK28E,SAAS,CAACkC,WAAW;EAC5C;EACAC,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI,CAAC9+E,IAAI,KAAK28E,SAAS,CAACz2E,MAAM,GAAG,IAAI,CAACg3E,QAAQ,GAAG,CAAC,CAAC;EAC5D;EACA6B,qBAAqBA,CAAA,EAAG;IACtB,OAAO,IAAI,CAACxB,QAAQ,CAAC,CAAC,IAAI,IAAI,CAAC/qC,IAAI,KAAKoqC,eAAe,CAACoC,mBAAmB;EAC7E;EACAC,oBAAoBA,CAAA,EAAG;IACrB,OAAO,IAAI,CAAC1B,QAAQ,CAAC,CAAC,IAAI,IAAI,CAAC/qC,IAAI,KAAKoqC,eAAe,CAACsC,kBAAkB;EAC5E;EACAC,mCAAmCA,CAAA,EAAG;IACpC,OAAO,IAAI,CAAC3B,UAAU,CAAC,IAAI,CAAC;EAC9B;EACAtkF,QAAQA,CAAA,EAAG;IACT,QAAQ,IAAI,CAAC8G,IAAI;MACf,KAAK28E,SAAS,CAACU,SAAS;MACxB,KAAKV,SAAS,CAACxX,UAAU;MACzB,KAAKwX,SAAS,CAACmB,OAAO;MACtB,KAAKnB,SAAS,CAACc,QAAQ;MACvB,KAAKd,SAAS,CAACiB,iBAAiB;MAChC,KAAKjB,SAAS,CAACv2E,MAAM;MACrB,KAAKu2E,SAAS,CAACllF,KAAK;MACpB,KAAKklF,SAAS,CAACgC,UAAU;MACzB,KAAKhC,SAAS,CAACkC,WAAW;QACxB,OAAO,IAAI,CAAC1B,QAAQ;MACtB,KAAKR,SAAS,CAACz2E,MAAM;QACnB,OAAO,IAAI,CAACg3E,QAAQ,CAAChkF,QAAQ,CAAC,CAAC;MACjC;QACE,OAAO,IAAI;IACf;EACF;AACF;AACA,MAAMkmF,WAAW,SAASnC,KAAK,CAAC;EAC9BzqC,IAAI;EACJz2C,WAAWA,CAACyG,KAAK,EAAEc,GAAG,EAAE65E,QAAQ,EAAE3qC,IAAI,EAAE;IACtC,KAAK,CAAChwC,KAAK,EAAEc,GAAG,EAAEq5E,SAAS,CAACv2E,MAAM,EAAE,CAAC,EAAE+2E,QAAQ,CAAC;IAChD,IAAI,CAAC3qC,IAAI,GAAGA,IAAI;EAClB;AACF;AACA,SAAS6sC,iBAAiBA,CAAC78E,KAAK,EAAEc,GAAG,EAAE2sC,IAAI,EAAE;EAC3C,OAAO,IAAIgtC,KAAK,CAACz6E,KAAK,EAAEc,GAAG,EAAEq5E,SAAS,CAACU,SAAS,EAAEptC,IAAI,EAAE7pC,MAAM,CAAC4qC,YAAY,CAACf,IAAI,CAAC,CAAC;AACpF;AACA,SAASqvC,kBAAkBA,CAAC98E,KAAK,EAAEc,GAAG,EAAEnE,IAAI,EAAE;EAC5C,OAAO,IAAI89E,KAAK,CAACz6E,KAAK,EAAEc,GAAG,EAAEq5E,SAAS,CAACxX,UAAU,EAAE,CAAC,EAAEhmE,IAAI,CAAC;AAC7D;AACA,SAASogF,yBAAyBA,CAAC/8E,KAAK,EAAEc,GAAG,EAAEnE,IAAI,EAAE;EACnD,OAAO,IAAI89E,KAAK,CAACz6E,KAAK,EAAEc,GAAG,EAAEq5E,SAAS,CAACiB,iBAAiB,EAAE,CAAC,EAAEz+E,IAAI,CAAC;AACpE;AACA,SAASqgF,eAAeA,CAACh9E,KAAK,EAAEc,GAAG,EAAEnE,IAAI,EAAE;EACzC,OAAO,IAAI89E,KAAK,CAACz6E,KAAK,EAAEc,GAAG,EAAEq5E,SAAS,CAACmB,OAAO,EAAE,CAAC,EAAE3+E,IAAI,CAAC;AAC1D;AACA,SAASsgF,gBAAgBA,CAACj9E,KAAK,EAAEc,GAAG,EAAEnE,IAAI,EAAE;EAC1C,OAAO,IAAI89E,KAAK,CAACz6E,KAAK,EAAEc,GAAG,EAAEq5E,SAAS,CAACc,QAAQ,EAAE,CAAC,EAAEt+E,IAAI,CAAC;AAC3D;AACA,SAASugF,cAAcA,CAACl9E,KAAK,EAAEc,GAAG,EAAEmgC,CAAC,EAAE;EACrC,OAAO,IAAIw5C,KAAK,CAACz6E,KAAK,EAAEc,GAAG,EAAEq5E,SAAS,CAACz2E,MAAM,EAAEu9B,CAAC,EAAE,EAAE,CAAC;AACvD;AACA,SAASk8C,aAAaA,CAACn9E,KAAK,EAAEc,GAAG,EAAEpF,OAAO,EAAE;EAC1C,OAAO,IAAI++E,KAAK,CAACz6E,KAAK,EAAEc,GAAG,EAAEq5E,SAAS,CAACllF,KAAK,EAAE,CAAC,EAAEyG,OAAO,CAAC;AAC3D;AACA,SAAS0hF,kBAAkBA,CAACp9E,KAAK,EAAEc,GAAG,EAAEnE,IAAI,EAAE;EAC5C,OAAO,IAAI89E,KAAK,CAACz6E,KAAK,EAAEc,GAAG,EAAEq5E,SAAS,CAACgC,UAAU,EAAE,CAAC,EAAEx/E,IAAI,CAAC;AAC7D;AACA,SAAS0gF,mBAAmBA,CAACr9E,KAAK,EAAEc,GAAG,EAAEnE,IAAI,EAAE;EAC7C,OAAO,IAAI89E,KAAK,CAACz6E,KAAK,EAAEc,GAAG,EAAEq5E,SAAS,CAACkC,WAAW,EAAE,CAAC,EAAE1/E,IAAI,CAAC;AAC9D;AACA,MAAM2gF,GAAG,GAAG,IAAI7C,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEN,SAAS,CAACU,SAAS,EAAE,CAAC,EAAE,EAAE,CAAC;AACzD,MAAMN,QAAQ,CAAC;EACb92D,KAAK;EACLqhD,MAAM,GAAG,EAAE;EACXrwE,MAAM;EACNy0E,IAAI,GAAG,CAAC;EACRlpE,KAAK,GAAG,CAAC,CAAC;EACVu9E,UAAU,GAAG,EAAE;EACfhkF,WAAWA,CAACkqB,KAAK,EAAE;IACjB,IAAI,CAACA,KAAK,GAAGA,KAAK;IAClB,IAAI,CAAChvB,MAAM,GAAGgvB,KAAK,CAAChvB,MAAM;IAC1B,IAAI,CAACmjB,OAAO,CAAC,CAAC;EAChB;EACA4iE,IAAIA,CAAA,EAAG;IACL,IAAI11D,KAAK,GAAG,IAAI,CAAC04D,SAAS,CAAC,CAAC;IAC5B,OAAO14D,KAAK,KAAK,IAAI,EAAE;MACrB,IAAI,CAACggD,MAAM,CAACpwE,IAAI,CAACowB,KAAK,CAAC;MACvBA,KAAK,GAAG,IAAI,CAAC04D,SAAS,CAAC,CAAC;IAC1B;IACA,OAAO,IAAI,CAAC1Y,MAAM;EACpB;EACAltD,OAAOA,CAAA,EAAG;IACR,IAAI,CAACsxD,IAAI,GAAG,EAAE,IAAI,CAAClpE,KAAK,IAAI,IAAI,CAACvL,MAAM,GAAGo1C,IAAI,GAAG,IAAI,CAACpmB,KAAK,CAACmB,UAAU,CAAC,IAAI,CAAC5kB,KAAK,CAAC;EACpF;EACAw9E,SAASA,CAAA,EAAG;IACV,MAAM/5D,KAAK,GAAG,IAAI,CAACA,KAAK;IACxB,MAAMhvB,MAAM,GAAG,IAAI,CAACA,MAAM;IAC1B,IAAIy0E,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAIlpE,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,OAAOkpE,IAAI,IAAI9+B,MAAM,EAAE;MACrB,IAAI,EAAEpqC,KAAK,IAAIvL,MAAM,EAAE;QACrBy0E,IAAI,GAAGr/B,IAAI;QACX;MACF,CAAC,MAAM;QACLq/B,IAAI,GAAGzlD,KAAK,CAACmB,UAAU,CAAC5kB,KAAK,CAAC;MAChC;IACF;IACA,IAAI,CAACkpE,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAClpE,KAAK,GAAGA,KAAK;IAClB,IAAIA,KAAK,IAAIvL,MAAM,EAAE;MACnB,OAAO,IAAI;IACb;IACA,IAAIgpF,iBAAiB,CAACvU,IAAI,CAAC,EAAE;MAC3B,OAAO,IAAI,CAACwU,cAAc,CAAC,CAAC;IAC9B;IACA,IAAIhwC,OAAO,CAACw7B,IAAI,CAAC,EAAE;MACjB,OAAO,IAAI,CAACyU,UAAU,CAAC39E,KAAK,CAAC;IAC/B;IACA,MAAM8qB,KAAK,GAAG9qB,KAAK;IACnB,QAAQkpE,IAAI;MACV,KAAKh+B,OAAO;QACV,IAAI,CAACtzB,OAAO,CAAC,CAAC;QACd,OAAO81B,OAAO,CAAC,IAAI,CAACw7B,IAAI,CAAC,GAAG,IAAI,CAACyU,UAAU,CAAC7yD,KAAK,CAAC,GAAG+xD,iBAAiB,CAAC/xD,KAAK,EAAE,IAAI,CAAC9qB,KAAK,EAAEkrC,OAAO,CAAC;MACpG,KAAKN,OAAO;MACZ,KAAKC,OAAO;MACZ,KAAKqB,SAAS;MACd,KAAKE,SAAS;MACd,KAAKpB,MAAM;MACX,KAAKI,MAAM;MACX,KAAKC,UAAU;QACb,OAAO,IAAI,CAACuyC,aAAa,CAAC9yD,KAAK,EAAEo+C,IAAI,CAAC;MACxC,KAAKh8B,OAAO;QACV,OAAO,IAAI,CAAC2wC,aAAa,CAAC/yD,KAAK,EAAEo+C,IAAI,CAAC;MACxC,KAAK97B,OAAO;QACV,OAAO,IAAI,CAAC0wC,cAAc,CAAChzD,KAAK,EAAEo+C,IAAI,CAAC;MACzC,KAAKv+B,GAAG;MACR,KAAKL,GAAG;QACN,OAAO,IAAI,CAACyzC,UAAU,CAAC,CAAC;MAC1B,KAAKxwC,GAAG;QACN,IAAI,CAAC31B,OAAO,CAAC,CAAC;QACd,OAAO,IAAI,CAAComE,uBAAuB,CAAClzD,KAAK,CAAC;MAC5C,KAAKyf,KAAK;QACR,OAAO,IAAI,CAAC0zC,qBAAqB,CAAC,CAAC;MACrC,KAAKlzC,KAAK;QACR,OAAO,IAAI,CAACmzC,mBAAmB,CAACpzD,KAAK,EAAE,GAAG,EAAEygB,GAAG,EAAE,GAAG,CAAC;MACvD,KAAKN,MAAM;QACT,OAAO,IAAI,CAACizC,mBAAmB,CAACpzD,KAAK,EAAE,GAAG,EAAEygB,GAAG,EAAE,GAAG,CAAC;MACvD,KAAKJ,MAAM;QACT,OAAO,IAAI,CAACgzC,cAAc,CAAC,CAAC,GAAG,IAAI,CAACC,SAAS,CAACp+E,KAAK,CAAC,GAAG,IAAI,CAACk+E,mBAAmB,CAACpzD,KAAK,EAAE,GAAG,EAAEygB,GAAG,EAAE,GAAG,CAAC;MACvG,KAAKd,QAAQ;QACX,OAAO,IAAI,CAACyzC,mBAAmB,CAACpzD,KAAK,EAAE,GAAG,EAAEygB,GAAG,EAAE,GAAG,CAAC;MACvD,KAAKc,MAAM;QACT,OAAO,IAAI,CAACgyC,YAAY,CAACvzD,KAAK,EAAE,GAAG,CAAC;MACtC,KAAKggB,KAAK;QACR,OAAO,IAAI,CAACwzC,QAAQ,CAACxzD,KAAK,CAAC;MAC7B,KAAK2gB,SAAS;QACZ,OAAO,IAAI,CAAC8yC,YAAY,CAACzzD,KAAK,CAAC;MACjC,KAAKwgB,GAAG;MACR,KAAKE,GAAG;QACN,OAAO,IAAI,CAAC0yC,mBAAmB,CAACpzD,KAAK,EAAElnB,MAAM,CAAC4qC,YAAY,CAAC06B,IAAI,CAAC,EAAE39B,GAAG,EAAE,GAAG,CAAC;MAC7E,KAAKlB,KAAK;MACV,KAAKkB,GAAG;QACN,OAAO,IAAI,CAAC2yC,mBAAmB,CAACpzD,KAAK,EAAElnB,MAAM,CAAC4qC,YAAY,CAAC06B,IAAI,CAAC,EAAE39B,GAAG,EAAE,GAAG,EAAEA,GAAG,EAAE,GAAG,CAAC;MACvF,KAAKb,UAAU;QACb,OAAO,IAAI,CAACwzC,mBAAmB,CAACpzD,KAAK,EAAE,GAAG,EAAE4f,UAAU,EAAE,GAAG,EAAEa,GAAG,EAAE,GAAG,CAAC;MACxE,KAAK4B,IAAI;QACP,OAAO,IAAI,CAAC+wC,mBAAmB,CAACpzD,KAAK,EAAE,GAAG,EAAEqiB,IAAI,EAAE,GAAG,EAAE5B,GAAG,EAAE,GAAG,CAAC;MAClE,KAAK8B,KAAK;QACR,OAAOG,YAAY,CAAC,IAAI,CAAC07B,IAAI,CAAC,EAAE,IAAI,CAACtxD,OAAO,CAAC,CAAC;QAC9C,OAAO,IAAI,CAAC4lE,SAAS,CAAC,CAAC;IAC3B;IACA,IAAI,CAAC5lE,OAAO,CAAC,CAAC;IACd,OAAO,IAAI,CAAC6jB,KAAK,CAAC,yBAAyB73B,MAAM,CAAC4qC,YAAY,CAAC06B,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC;EAC7E;EACA0U,aAAaA,CAAC9yD,KAAK,EAAE2iB,IAAI,EAAE;IACzB,IAAI,CAAC71B,OAAO,CAAC,CAAC;IACd,OAAOilE,iBAAiB,CAAC/xD,KAAK,EAAE,IAAI,CAAC9qB,KAAK,EAAEytC,IAAI,CAAC;EACnD;EACA4wC,YAAYA,CAACvzD,KAAK,EAAE5sB,GAAG,EAAE;IACvB,IAAI,CAAC0Z,OAAO,CAAC,CAAC;IACd,OAAOqlE,gBAAgB,CAACnyD,KAAK,EAAE,IAAI,CAAC9qB,KAAK,EAAE9B,GAAG,CAAC;EACjD;EACA2/E,aAAaA,CAAC/yD,KAAK,EAAE2iB,IAAI,EAAE;IACzB,IAAI,CAAC8vC,UAAU,CAAC7oF,IAAI,CAAC,YAAY,CAAC;IAClC,IAAI,CAACkjB,OAAO,CAAC,CAAC;IACd,OAAOilE,iBAAiB,CAAC/xD,KAAK,EAAE,IAAI,CAAC9qB,KAAK,EAAEytC,IAAI,CAAC;EACnD;EACAqwC,cAAcA,CAAChzD,KAAK,EAAE2iB,IAAI,EAAE;IAC1B,IAAI,CAAC71B,OAAO,CAAC,CAAC;IACd,MAAM4mE,YAAY,GAAG,IAAI,CAACjB,UAAU,CAAC3zD,GAAG,CAAC,CAAC;IAC1C,IAAI40D,YAAY,KAAK,eAAe,EAAE;MACpC,IAAI,CAAC1Z,MAAM,CAACpwE,IAAI,CAACmoF,iBAAiB,CAAC/xD,KAAK,EAAE,IAAI,CAAC9qB,KAAK,EAAEotC,OAAO,CAAC,CAAC;MAC/D,OAAO,IAAI,CAAC4wC,uBAAuB,CAAC,IAAI,CAACh+E,KAAK,CAAC;IACjD;IACA,OAAO68E,iBAAiB,CAAC/xD,KAAK,EAAE,IAAI,CAAC9qB,KAAK,EAAEytC,IAAI,CAAC;EACnD;EACAywC,mBAAmBA,CAACpzD,KAAK,EAAE2zD,GAAG,EAAEC,OAAO,EAAEC,GAAG,EAAEC,SAAS,EAAEC,KAAK,EAAE;IAC9D,IAAI,CAACjnE,OAAO,CAAC,CAAC;IACd,IAAI1Z,GAAG,GAAGugF,GAAG;IACb,IAAI,IAAI,CAACvV,IAAI,IAAIwV,OAAO,EAAE;MACxB,IAAI,CAAC9mE,OAAO,CAAC,CAAC;MACd1Z,GAAG,IAAIygF,GAAG;IACZ;IACA,IAAIC,SAAS,IAAI,IAAI,IAAI,IAAI,CAAC1V,IAAI,IAAI0V,SAAS,EAAE;MAC/C,IAAI,CAAChnE,OAAO,CAAC,CAAC;MACd1Z,GAAG,IAAI2gF,KAAK;IACd;IACA,OAAO5B,gBAAgB,CAACnyD,KAAK,EAAE,IAAI,CAAC9qB,KAAK,EAAE9B,GAAG,CAAC;EACjD;EACAw/E,cAAcA,CAAA,EAAG;IACf,MAAM5yD,KAAK,GAAG,IAAI,CAAC9qB,KAAK;IACxB,IAAI,CAAC4X,OAAO,CAAC,CAAC;IACd,OAAOknE,gBAAgB,CAAC,IAAI,CAAC5V,IAAI,CAAC,EAAE,IAAI,CAACtxD,OAAO,CAAC,CAAC;IAClD,MAAM1Z,GAAG,GAAG,IAAI,CAACulB,KAAK,CAAC6qB,SAAS,CAACxjB,KAAK,EAAE,IAAI,CAAC9qB,KAAK,CAAC;IACnD,OAAOq6E,QAAQ,CAACn2D,OAAO,CAAChmB,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG8+E,eAAe,CAAClyD,KAAK,EAAE,IAAI,CAAC9qB,KAAK,EAAE9B,GAAG,CAAC,GAAG4+E,kBAAkB,CAAChyD,KAAK,EAAE,IAAI,CAAC9qB,KAAK,EAAE9B,GAAG,CAAC;EAC1H;EACA+/E,qBAAqBA,CAAA,EAAG;IACtB,MAAMnzD,KAAK,GAAG,IAAI,CAAC9qB,KAAK;IACxB,IAAI,CAAC4X,OAAO,CAAC,CAAC;IACd,IAAI,CAAC6lE,iBAAiB,CAAC,IAAI,CAACvU,IAAI,CAAC,EAAE;MACjC,OAAO,IAAI,CAACztC,KAAK,CAAC,uBAAuB,EAAE,CAAC,CAAC,CAAC;IAChD;IACA,OAAOqjD,gBAAgB,CAAC,IAAI,CAAC5V,IAAI,CAAC,EAAE,IAAI,CAACtxD,OAAO,CAAC,CAAC;IAClD,MAAMy4B,cAAc,GAAG,IAAI,CAAC5sB,KAAK,CAAC6qB,SAAS,CAACxjB,KAAK,EAAE,IAAI,CAAC9qB,KAAK,CAAC;IAC9D,OAAO+8E,yBAAyB,CAACjyD,KAAK,EAAE,IAAI,CAAC9qB,KAAK,EAAEqwC,cAAc,CAAC;EACrE;EACAstC,UAAUA,CAAC7yD,KAAK,EAAE;IAChB,IAAIi0D,MAAM,GAAG,IAAI,CAAC/+E,KAAK,KAAK8qB,KAAK;IACjC,IAAIk0D,aAAa,GAAG,KAAK;IACzB,IAAI,CAACpnE,OAAO,CAAC,CAAC;IACd,OAAO,IAAI,EAAE;MACX,IAAI81B,OAAO,CAAC,IAAI,CAACw7B,IAAI,CAAC,EAAE,CAAC,KAAM,IAAI,IAAI,CAACA,IAAI,KAAK58B,EAAE,EAAE;QACnD,IAAI,CAACoB,OAAO,CAAC,IAAI,CAACjqB,KAAK,CAACmB,UAAU,CAAC,IAAI,CAAC5kB,KAAK,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC0tC,OAAO,CAAC,IAAI,CAACjqB,KAAK,CAACmB,UAAU,CAAC,IAAI,CAAC5kB,KAAK,GAAG,CAAC,CAAC,CAAC,EAAE;UACtG,OAAO,IAAI,CAACy7B,KAAK,CAAC,2BAA2B,EAAE,CAAC,CAAC;QACnD;QACAujD,aAAa,GAAG,IAAI;MACtB,CAAC,MAAM,IAAI,IAAI,CAAC9V,IAAI,KAAKh+B,OAAO,EAAE;QAChC6zC,MAAM,GAAG,KAAK;MAChB,CAAC,MAAM,IAAIE,eAAe,CAAC,IAAI,CAAC/V,IAAI,CAAC,EAAE;QACrC,IAAI,CAACtxD,OAAO,CAAC,CAAC;QACd,IAAIsnE,cAAc,CAAC,IAAI,CAAChW,IAAI,CAAC,EAAE,IAAI,CAACtxD,OAAO,CAAC,CAAC;QAC7C,IAAI,CAAC81B,OAAO,CAAC,IAAI,CAACw7B,IAAI,CAAC,EAAE,OAAO,IAAI,CAACztC,KAAK,CAAC,kBAAkB,EAAE,CAAC,CAAC,CAAC;QAClEsjD,MAAM,GAAG,KAAK;MAChB,CAAC,MAAM;QACL;MACF;MACA,IAAI,CAACnnE,OAAO,CAAC,CAAC;IAChB;IACA,IAAI1Z,GAAG,GAAG,IAAI,CAACulB,KAAK,CAAC6qB,SAAS,CAACxjB,KAAK,EAAE,IAAI,CAAC9qB,KAAK,CAAC;IACjD,IAAIg/E,aAAa,EAAE;MACjB9gF,GAAG,GAAGA,GAAG,CAACjI,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;IAC7B;IACA,MAAMO,KAAK,GAAGuoF,MAAM,GAAGI,iBAAiB,CAACjhF,GAAG,CAAC,GAAGkhF,UAAU,CAAClhF,GAAG,CAAC;IAC/D,OAAOg/E,cAAc,CAACpyD,KAAK,EAAE,IAAI,CAAC9qB,KAAK,EAAExJ,KAAK,CAAC;EACjD;EACAunF,UAAUA,CAAA,EAAG;IACX,MAAMjzD,KAAK,GAAG,IAAI,CAAC9qB,KAAK;IACxB,MAAM23C,KAAK,GAAG,IAAI,CAACuxB,IAAI;IACvB,IAAI,CAACtxD,OAAO,CAAC,CAAC;IACd,IAAIxX,MAAM,GAAG,EAAE;IACf,IAAIi/E,MAAM,GAAG,IAAI,CAACr/E,KAAK;IACvB,MAAMyjB,KAAK,GAAG,IAAI,CAACA,KAAK;IACxB,OAAO,IAAI,CAACylD,IAAI,IAAIvxB,KAAK,EAAE;MACzB,IAAI,IAAI,CAACuxB,IAAI,IAAI/8B,UAAU,EAAE;QAC3B,MAAMx2C,MAAM,GAAG,IAAI,CAAC2pF,mBAAmB,CAACl/E,MAAM,EAAEi/E,MAAM,CAAC;QACvD,IAAI,OAAO1pF,MAAM,KAAK,QAAQ,EAAE;UAC9B,OAAOA,MAAM;QACf;QACAyK,MAAM,GAAGzK,MAAM;QACf0pF,MAAM,GAAG,IAAI,CAACr/E,KAAK;MACrB,CAAC,MAAM,IAAI,IAAI,CAACkpE,IAAI,IAAIr/B,IAAI,EAAE;QAC5B,OAAO,IAAI,CAACpO,KAAK,CAAC,oBAAoB,EAAE,CAAC,CAAC;MAC5C,CAAC,MAAM;QACL,IAAI,CAAC7jB,OAAO,CAAC,CAAC;MAChB;IACF;IACA,MAAMi3C,IAAI,GAAGprC,KAAK,CAAC6qB,SAAS,CAAC+wC,MAAM,EAAE,IAAI,CAACr/E,KAAK,CAAC;IAChD,IAAI,CAAC4X,OAAO,CAAC,CAAC;IACd,OAAO,IAAIglE,WAAW,CAAC9xD,KAAK,EAAE,IAAI,CAAC9qB,KAAK,EAAEI,MAAM,GAAGyuD,IAAI,EAAEurB,eAAe,CAACmF,KAAK,CAAC;EACjF;EACAhB,YAAYA,CAACzzD,KAAK,EAAE;IAClB,IAAI,CAAClT,OAAO,CAAC,CAAC;IACd,IAAIvJ,QAAQ,GAAG,GAAG;IAClB,IAAI,IAAI,CAAC66D,IAAI,KAAKz9B,SAAS,EAAE;MAC3Bp9B,QAAQ,IAAI,GAAG;MACf,IAAI,CAACuJ,OAAO,CAAC,CAAC;MACd,IAAI,IAAI,CAACsxD,IAAI,KAAK39B,GAAG,EAAE;QACrBl9B,QAAQ,IAAI,GAAG;QACf,IAAI,CAACuJ,OAAO,CAAC,CAAC;MAChB;IACF,CAAC,MAAM,IAAI,IAAI,CAACsxD,IAAI,KAAKh+B,OAAO,EAAE;MAChC78B,QAAQ,IAAI,GAAG;MACf,IAAI,CAACuJ,OAAO,CAAC,CAAC;IAChB;IACA,OAAOqlE,gBAAgB,CAACnyD,KAAK,EAAE,IAAI,CAAC9qB,KAAK,EAAEqO,QAAQ,CAAC;EACtD;EACA2vE,uBAAuBA,CAAClzD,KAAK,EAAE;IAC7B,IAAI1qB,MAAM,GAAG,EAAE;IACf,IAAIi/E,MAAM,GAAG,IAAI,CAACr/E,KAAK;IACvB,OAAO,IAAI,CAACkpE,IAAI,KAAK37B,GAAG,EAAE;MACxB,IAAI,IAAI,CAAC27B,IAAI,KAAK/8B,UAAU,EAAE;QAC5B,MAAMx2C,MAAM,GAAG,IAAI,CAAC2pF,mBAAmB,CAACl/E,MAAM,EAAEi/E,MAAM,CAAC;QACvD,IAAI,OAAO1pF,MAAM,KAAK,QAAQ,EAAE;UAC9B,OAAOA,MAAM;QACf;QACAyK,MAAM,GAAGzK,MAAM;QACf0pF,MAAM,GAAG,IAAI,CAACr/E,KAAK;MACrB,CAAC,MAAM,IAAI,IAAI,CAACkpE,IAAI,KAAK1+B,EAAE,EAAE;QAC3B,MAAMg1C,MAAM,GAAG,IAAI,CAACx/E,KAAK;QACzB,IAAI,CAAC4X,OAAO,CAAC,CAAC;QACd,IAAI,IAAI,CAACsxD,IAAI,KAAKh8B,OAAO,EAAE;UACzB,IAAI,CAACqwC,UAAU,CAAC7oF,IAAI,CAAC,eAAe,CAAC;UACrC,IAAI,CAACowE,MAAM,CAACpwE,IAAI,CAAC,IAAIkoF,WAAW,CAAC9xD,KAAK,EAAE00D,MAAM,EAAEp/E,MAAM,GAAG,IAAI,CAACqjB,KAAK,CAAC6qB,SAAS,CAAC+wC,MAAM,EAAEG,MAAM,CAAC,EAAEpF,eAAe,CAACoC,mBAAmB,CAAC,CAAC;UACpI,IAAI,CAAC5kE,OAAO,CAAC,CAAC;UACd,OAAOqlE,gBAAgB,CAACuC,MAAM,EAAE,IAAI,CAACx/E,KAAK,EAAE,IAAI,CAACyjB,KAAK,CAAC6qB,SAAS,CAACkxC,MAAM,EAAE,IAAI,CAACx/E,KAAK,CAAC,CAAC;QACvF;MACF,CAAC,MAAM,IAAI,IAAI,CAACkpE,IAAI,KAAKr/B,IAAI,EAAE;QAC7B,OAAO,IAAI,CAACpO,KAAK,CAAC,+BAA+B,EAAE,CAAC,CAAC;MACvD,CAAC,MAAM;QACL,IAAI,CAAC7jB,OAAO,CAAC,CAAC;MAChB;IACF;IACA,MAAMi3C,IAAI,GAAG,IAAI,CAACprC,KAAK,CAAC6qB,SAAS,CAAC+wC,MAAM,EAAE,IAAI,CAACr/E,KAAK,CAAC;IACrD,IAAI,CAAC4X,OAAO,CAAC,CAAC;IACd,OAAO,IAAIglE,WAAW,CAAC9xD,KAAK,EAAE,IAAI,CAAC9qB,KAAK,EAAEI,MAAM,GAAGyuD,IAAI,EAAEurB,eAAe,CAACsC,kBAAkB,CAAC;EAC9F;EACAjhD,KAAKA,CAAC//B,OAAO,EAAEuyC,MAAM,EAAE;IACrB,MAAMwxC,QAAQ,GAAG,IAAI,CAACz/E,KAAK,GAAGiuC,MAAM;IACpC,OAAOkvC,aAAa,CAACsC,QAAQ,EAAE,IAAI,CAACz/E,KAAK,EAAE,gBAAgBtE,OAAO,cAAc+jF,QAAQ,mBAAmB,IAAI,CAACh8D,KAAK,GAAG,CAAC;EAC3H;EACA67D,mBAAmBA,CAACl/E,MAAM,EAAEi/E,MAAM,EAAE;IAClCj/E,MAAM,IAAI,IAAI,CAACqjB,KAAK,CAAC6qB,SAAS,CAAC+wC,MAAM,EAAE,IAAI,CAACr/E,KAAK,CAAC;IAClD,IAAI0/E,aAAa;IACjB,IAAI,CAAC9nE,OAAO,CAAC,CAAC;IACd,IAAI,IAAI,CAACsxD,IAAI,KAAKp8B,EAAE,EAAE;MACpB,MAAMwlC,GAAG,GAAG,IAAI,CAAC7uD,KAAK,CAAC6qB,SAAS,CAAC,IAAI,CAACtuC,KAAK,GAAG,CAAC,EAAE,IAAI,CAACA,KAAK,GAAG,CAAC,CAAC;MAChE,IAAI,cAAc,CAAC8lB,IAAI,CAACwsD,GAAG,CAAC,EAAE;QAC5BoN,aAAa,GAAG/R,QAAQ,CAAC2E,GAAG,EAAE,EAAE,CAAC;MACnC,CAAC,MAAM;QACL,OAAO,IAAI,CAAC72C,KAAK,CAAC,8BAA8B62C,GAAG,GAAG,EAAE,CAAC,CAAC;MAC5D;MACA,KAAK,IAAIz8E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QAC1B,IAAI,CAAC+hB,OAAO,CAAC,CAAC;MAChB;IACF,CAAC,MAAM;MACL8nE,aAAa,GAAGC,QAAQ,CAAC,IAAI,CAACzW,IAAI,CAAC;MACnC,IAAI,CAACtxD,OAAO,CAAC,CAAC;IAChB;IACAxX,MAAM,IAAIwD,MAAM,CAAC4qC,YAAY,CAACkxC,aAAa,CAAC;IAC5C,OAAOt/E,MAAM;EACf;EACAk+E,QAAQA,CAACxzD,KAAK,EAAE;IACd,IAAI,CAAClT,OAAO,CAAC,CAAC;IACd,IAAIvJ,QAAQ,GAAG,GAAG;IAClB,IAAI,IAAI,CAAC66D,IAAI,KAAKp+B,KAAK,EAAE;MACvBz8B,QAAQ,IAAI,GAAG;MACf,IAAI,CAACuJ,OAAO,CAAC,CAAC;MACd,IAAI,IAAI,CAACsxD,IAAI,KAAK39B,GAAG,EAAE;QACrBl9B,QAAQ,IAAI,GAAG;QACf,IAAI,CAACuJ,OAAO,CAAC,CAAC;MAChB;IACF,CAAC,MAAM,IAAI,IAAI,CAACsxD,IAAI,KAAK39B,GAAG,EAAE;MAC5Bl9B,QAAQ,IAAI,GAAG;MACf,IAAI,CAACuJ,OAAO,CAAC,CAAC;IAChB;IACA,OAAOqlE,gBAAgB,CAACnyD,KAAK,EAAE,IAAI,CAAC9qB,KAAK,EAAEqO,QAAQ,CAAC;EACtD;EACA8vE,cAAcA,CAAA,EAAG;IACf,IAAI,IAAI,CAACrZ,MAAM,CAACrwE,MAAM,KAAK,CAAC,EAAE;MAC5B,OAAO,IAAI;IACb;IACA,MAAMmrF,SAAS,GAAG,IAAI,CAAC9a,MAAM,CAAC,IAAI,CAACA,MAAM,CAACrwE,MAAM,GAAG,CAAC,CAAC;IACrD,IAAImrF,SAAS,CAAC5E,UAAU,CAAC,GAAG,CAAC,EAAE;MAC7B,MAAM6E,eAAe,GAAG,IAAI,CAAC/a,MAAM,CAACrwE,MAAM,GAAG,CAAC,GAAG,IAAI,CAACqwE,MAAM,CAAC,IAAI,CAACA,MAAM,CAACrwE,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI;MAC3F,MAAMqrF,UAAU,GAAGD,eAAe,KAAK,IAAI,IAAIA,eAAe,CAACriF,IAAI,KAAK28E,SAAS,CAACxX,UAAU,IAAI,CAACkd,eAAe,CAACjF,WAAW,CAAC/vC,OAAO,CAAC,IAAI,CAACg1C,eAAe,CAACjF,WAAW,CAACxuC,SAAS,CAAC;MAChL,OAAO0zC,UAAU;IACnB;IACA,OAAOF,SAAS,CAACpiF,IAAI,KAAK28E,SAAS,CAACc,QAAQ,IAAI2E,SAAS,CAAChF,WAAW,CAAChwC,OAAO,CAAC,IAAIg1C,SAAS,CAAChF,WAAW,CAAC1uC,SAAS,CAAC,IAAI0zC,SAAS,CAAChF,WAAW,CAAC5vC,MAAM,CAAC,IAAI40C,SAAS,CAAChF,WAAW,CAACxvC,MAAM,CAAC;EACtL;EACAgzC,SAASA,CAAC2B,UAAU,EAAE;IACpB,IAAI,CAACnoE,OAAO,CAAC,CAAC;IACd,MAAMooE,SAAS,GAAG,IAAI,CAAChgF,KAAK;IAC5B,IAAIigF,QAAQ,GAAG,KAAK;IACpB,IAAIC,gBAAgB,GAAG,KAAK;IAC5B,OAAO,IAAI,EAAE;MACX,MAAMhX,IAAI,GAAG,IAAI,CAACA,IAAI;MACtB,IAAIA,IAAI,KAAKr/B,IAAI,EAAE;QACjB,OAAO,IAAI,CAACpO,KAAK,CAAC,iCAAiC,EAAE,CAAC,CAAC;MACzD;MACA,IAAIwkD,QAAQ,EAAE;QACZA,QAAQ,GAAG,KAAK;MAClB,CAAC,MAAM,IAAI/W,IAAI,KAAK/8B,UAAU,EAAE;QAC9B8zC,QAAQ,GAAG,IAAI;MACjB,CAAC,MAAM,IAAI/W,IAAI,KAAKh9B,SAAS,EAAE;QAC7Bg0C,gBAAgB,GAAG,IAAI;MACzB,CAAC,MAAM,IAAIhX,IAAI,KAAK98B,SAAS,EAAE;QAC7B8zC,gBAAgB,GAAG,KAAK;MAC1B,CAAC,MAAM,IAAIhX,IAAI,KAAK/9B,MAAM,IAAI,CAAC+0C,gBAAgB,EAAE;QAC/C;MACF;MACA,IAAI,CAACtoE,OAAO,CAAC,CAAC;IAChB;IACA,MAAMphB,KAAK,GAAG,IAAI,CAACitB,KAAK,CAAC6qB,SAAS,CAAC0xC,SAAS,EAAE,IAAI,CAAChgF,KAAK,CAAC;IACzD,IAAI,CAAC4X,OAAO,CAAC,CAAC;IACd,MAAMuoE,SAAS,GAAG/C,kBAAkB,CAAC2C,UAAU,EAAE,IAAI,CAAC//E,KAAK,EAAExJ,KAAK,CAAC;IACnE,MAAM4pF,UAAU,GAAG,IAAI,CAACC,cAAc,CAAC,IAAI,CAACrgF,KAAK,CAAC;IAClD,IAAIogF,UAAU,KAAK,IAAI,EAAE;MACvB,IAAI,CAACtb,MAAM,CAACpwE,IAAI,CAACyrF,SAAS,CAAC;MAC3B,OAAOC,UAAU;IACnB;IACA,OAAOD,SAAS;EAClB;EACAE,cAAcA,CAACv1D,KAAK,EAAE;IACpB,IAAI,CAAC6iB,aAAa,CAAC,IAAI,CAACu7B,IAAI,CAAC,EAAE;MAC7B,OAAO,IAAI;IACb;IACA,OAAOv7B,aAAa,CAAC,IAAI,CAACu7B,IAAI,CAAC,EAAE;MAC/B,IAAI,CAACtxD,OAAO,CAAC,CAAC;IAChB;IACA,OAAOylE,mBAAmB,CAACvyD,KAAK,EAAE,IAAI,CAAC9qB,KAAK,EAAE,IAAI,CAACyjB,KAAK,CAAC6qB,SAAS,CAACxjB,KAAK,EAAE,IAAI,CAAC9qB,KAAK,CAAC,CAAC;EACxF;AACF;AACA,SAASy9E,iBAAiBA,CAAChwC,IAAI,EAAE;EAC/B,OAAOlB,EAAE,IAAIkB,IAAI,IAAIA,IAAI,IAAIR,EAAE,IAAIpB,EAAE,IAAI4B,IAAI,IAAIA,IAAI,IAAIxB,EAAE,IAAIwB,IAAI,IAAInB,EAAE,IAAImB,IAAI,IAAIjD,EAAE;AACzF;AACA,SAASs0C,gBAAgBA,CAACrxC,IAAI,EAAE;EAC9B,OAAOE,aAAa,CAACF,IAAI,CAAC,IAAIC,OAAO,CAACD,IAAI,CAAC,IAAIA,IAAI,IAAInB,EAAE,IAAImB,IAAI,IAAIjD,EAAE;AACzE;AACA,SAASy0C,eAAeA,CAACxxC,IAAI,EAAE;EAC7B,OAAOA,IAAI,IAAIhB,EAAE,IAAIgB,IAAI,IAAI3B,EAAE;AACjC;AACA,SAASozC,cAAcA,CAACzxC,IAAI,EAAE;EAC5B,OAAOA,IAAI,IAAIxC,MAAM,IAAIwC,IAAI,IAAI1C,KAAK;AACxC;AACA,SAAS40C,QAAQA,CAAClyC,IAAI,EAAE;EACtB,QAAQA,IAAI;IACV,KAAKd,EAAE;MACL,OAAO3C,GAAG;IACZ,KAAK0C,EAAE;MACL,OAAOxC,GAAG;IACZ,KAAK0C,EAAE;MACL,OAAOzC,GAAG;IACZ,KAAK0C,EAAE;MACL,OAAO9C,IAAI;IACb,KAAKgD,EAAE;MACL,OAAO9C,KAAK;IACd;MACE,OAAOwD,IAAI;EACf;AACF;AACA,SAAS0xC,iBAAiBA,CAACxiF,IAAI,EAAE;EAC/B,MAAMhH,MAAM,GAAGg4E,QAAQ,CAAChxE,IAAI,CAAC;EAC7B,IAAI41E,KAAK,CAAC58E,MAAM,CAAC,EAAE;IACjB,MAAM,IAAIV,KAAK,CAAC,uCAAuC,GAAG0H,IAAI,CAAC;EACjE;EACA,OAAOhH,MAAM;AACf;AAEA,MAAM2qF,kBAAkB,CAAC;EACvBltD,OAAO;EACP9oB,WAAW;EACXi2E,OAAO;EACPhnF,WAAWA,CAAC65B,OAAO,EAAE9oB,WAAW,EAAEi2E,OAAO,EAAE;IACzC,IAAI,CAACntD,OAAO,GAAGA,OAAO;IACtB,IAAI,CAAC9oB,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACi2E,OAAO,GAAGA,OAAO;EACxB;AACF;AACA,MAAMC,0BAA0B,CAAC;EAC/BC,gBAAgB;EAChBC,QAAQ;EACR/qD,MAAM;EACNp8B,WAAWA,CAACknF,gBAAgB,EAAEC,QAAQ,EAAE/qD,MAAM,EAAE;IAC9C,IAAI,CAAC8qD,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC/qD,MAAM,GAAGA,MAAM;EACtB;AACF;AACA,SAASgrD,WAAWA,CAAC/1D,IAAI,EAAE;EACzB,OAAOA,IAAI,CAACE,KAAK,CAACp0B,QAAQ,CAAC,CAAC,IAAI,WAAW;AAC7C;AACA,MAAMk8E,MAAM,CAAC;EACXgO,MAAM;EACNC,6BAA6B;EAC7BtnF,WAAWA,CAACqnF,MAAM,EAAEC,6BAA6B,GAAG,KAAK,EAAE;IACzD,IAAI,CAACD,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,6BAA6B,GAAGA,6BAA6B;EACpE;EACAC,WAAWA,CAACr9D,KAAK,EAAEs9D,eAAe,EAAE/vD,cAAc,EAAE;IAClD,MAAM2E,MAAM,GAAG,EAAE;IACjB,IAAI,CAACqrD,qBAAqB,CAACrrD,MAAM,EAAElS,KAAK,EAAEs9D,eAAe,CAAC;IAC1D,MAAM;MACJE,QAAQ,EAAEC;IACZ,CAAC,GAAG,IAAI,CAACC,cAAc,CAAC19D,KAAK,CAAC;IAC9B,MAAMqhD,MAAM,GAAG,IAAI,CAAC8b,MAAM,CAACta,QAAQ,CAAC4a,WAAW,CAAC;IAChD,MAAMtvE,GAAG,GAAG,IAAIwvE,SAAS,CAAC39D,KAAK,EAAEs9D,eAAe,EAAE/vD,cAAc,EAAE8zC,MAAM,EAAE,CAAC,EAAEnvC,MAAM,EAAE,CAAC,EAAE,IAAI,CAACkrD,6BAA6B,CAAC,CAACQ,UAAU,CAAC,CAAC;IACxI,OAAO,IAAI5rD,aAAa,CAAC7jB,GAAG,EAAE6R,KAAK,EAAEk9D,WAAW,CAACI,eAAe,CAAC,EAAE/vD,cAAc,EAAE2E,MAAM,CAAC;EAC5F;EACA2rD,YAAYA,CAAC79D,KAAK,EAAEs9D,eAAe,EAAE/vD,cAAc,EAAE;IACnD,MAAM2E,MAAM,GAAG,EAAE;IACjB,MAAM/jB,GAAG,GAAG,IAAI,CAAC2vE,gBAAgB,CAAC99D,KAAK,EAAEs9D,eAAe,EAAE/vD,cAAc,EAAE2E,MAAM,CAAC;IACjF,OAAO,IAAIF,aAAa,CAAC7jB,GAAG,EAAE6R,KAAK,EAAEk9D,WAAW,CAACI,eAAe,CAAC,EAAE/vD,cAAc,EAAE2E,MAAM,CAAC;EAC5F;EACA6rD,qBAAqBA,CAAC5vE,GAAG,EAAE;IACzB,MAAM6vE,OAAO,GAAG,IAAIC,uBAAuB,CAAC,CAAC;IAC7C9vE,GAAG,CAACrV,KAAK,CAACklF,OAAO,CAAC;IAClB,OAAOA,OAAO,CAAC9rD,MAAM;EACvB;EACAgsD,kBAAkBA,CAACl+D,KAAK,EAAEs9D,eAAe,EAAE/vD,cAAc,EAAE;IACzD,MAAM2E,MAAM,GAAG,EAAE;IACjB,MAAM/jB,GAAG,GAAG,IAAI,CAAC2vE,gBAAgB,CAAC99D,KAAK,EAAEs9D,eAAe,EAAE/vD,cAAc,EAAE2E,MAAM,CAAC;IACjF,MAAMisD,qBAAqB,GAAG,IAAI,CAACJ,qBAAqB,CAAC5vE,GAAG,CAAC;IAC7D,IAAIgwE,qBAAqB,CAACntF,MAAM,GAAG,CAAC,EAAE;MACpCkhC,MAAM,CAACjhC,IAAI,CAACmtF,aAAa,CAAC,0CAA0CD,qBAAqB,CAACvrF,IAAI,CAAC,GAAG,CAAC,EAAE,EAAEotB,KAAK,EAAE,EAAE,EAAEs9D,eAAe,CAAC,CAAC;IACrI;IACA,OAAO,IAAItrD,aAAa,CAAC7jB,GAAG,EAAE6R,KAAK,EAAEk9D,WAAW,CAACI,eAAe,CAAC,EAAE/vD,cAAc,EAAE2E,MAAM,CAAC;EAC5F;EACA4rD,gBAAgBA,CAAC99D,KAAK,EAAEs9D,eAAe,EAAE/vD,cAAc,EAAE2E,MAAM,EAAE;IAC/D,IAAI,CAACqrD,qBAAqB,CAACrrD,MAAM,EAAElS,KAAK,EAAEs9D,eAAe,CAAC;IAC1D,MAAM;MACJE,QAAQ,EAAEC;IACZ,CAAC,GAAG,IAAI,CAACC,cAAc,CAAC19D,KAAK,CAAC;IAC9B,MAAMqhD,MAAM,GAAG,IAAI,CAAC8b,MAAM,CAACta,QAAQ,CAAC4a,WAAW,CAAC;IAChD,OAAO,IAAIE,SAAS,CAAC39D,KAAK,EAAEs9D,eAAe,EAAE/vD,cAAc,EAAE8zC,MAAM,EAAE,CAAC,EAAEnvC,MAAM,EAAE,CAAC,EAAE,IAAI,CAACkrD,6BAA6B,CAAC,CAACQ,UAAU,CAAC,CAAC;EACrI;EACAS,qBAAqBA,CAACC,WAAW,EAAE9f,aAAa,EAAE8e,eAAe,EAAEiB,iBAAiB,EAAEC,mBAAmB,EAAE;IACzG,MAAMnd,MAAM,GAAG,IAAI,CAAC8b,MAAM,CAACta,QAAQ,CAACrE,aAAa,CAAC;IAClD,MAAMtsC,MAAM,GAAG,EAAE;IACjB,MAAMm9C,MAAM,GAAG,IAAIsO,SAAS,CAACnf,aAAa,EAAE8e,eAAe,EAAEkB,mBAAmB,EAAEnd,MAAM,EAAE,CAAC,EAAEnvC,MAAM,EAAE,CAAC,EAAE,IAAI,CAACkrD,6BAA6B,CAAC;IAC3I,OAAO/N,MAAM,CAACgP,qBAAqB,CAAC;MAClCj3D,MAAM,EAAEk3D,WAAW;MACnBn3D,IAAI,EAAE,IAAIqG,kBAAkB,CAAC+wD,iBAAiB,EAAEA,iBAAiB,GAAGD,WAAW,CAACttF,MAAM;IACxF,CAAC,CAAC;EACJ;EACAytF,kBAAkBA,CAACz+D,KAAK,EAAEs9D,eAAe,EAAE/vD,cAAc,EAAEmxD,kBAAkB,EAAE;IAC7E,MAAMxsD,MAAM,GAAG,EAAE;IACjB,MAAM;MACJvC,OAAO;MACP9oB,WAAW;MACXi2E;IACF,CAAC,GAAG,IAAI,CAAC6B,kBAAkB,CAAC3+D,KAAK,EAAEs9D,eAAe,EAAEprD,MAAM,EAAEwsD,kBAAkB,CAAC;IAC/E,IAAI73E,WAAW,CAAC7V,MAAM,KAAK,CAAC,EAAE,OAAO,IAAI;IACzC,MAAM4tF,eAAe,GAAG,EAAE;IAC1B,KAAK,IAAIxsF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyU,WAAW,CAAC7V,MAAM,EAAE,EAAEoB,CAAC,EAAE;MAC3C,MAAMysF,cAAc,GAAGH,kBAAkB,GAAGtsF,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE8O,UAAU;MAClE,MAAM49E,cAAc,GAAGj4E,WAAW,CAACzU,CAAC,CAAC,CAAC8G,IAAI;MAC1C,MAAM;QACJskF,QAAQ,EAAEC,WAAW;QACrBsB;MACF,CAAC,GAAG,IAAI,CAACrB,cAAc,CAACoB,cAAc,CAAC;MACvC,MAAMzd,MAAM,GAAG,IAAI,CAAC8b,MAAM,CAACta,QAAQ,CAAC4a,WAAW,CAAC;MAChD,IAAIsB,WAAW,IAAItB,WAAW,CAAC/8D,IAAI,CAAC,CAAC,CAAC1vB,MAAM,KAAK,CAAC,IAAIqwE,MAAM,CAACrwE,MAAM,KAAK,CAAC,EAAE;QACzEkhC,MAAM,CAACjhC,IAAI,CAACmtF,aAAa,CAAC,wDAAwD,EAAEp+D,KAAK,EAAE,aAAanZ,WAAW,CAACzU,CAAC,CAAC,CAACi1B,KAAK,KAAK,EAAEi2D,eAAe,CAAC,CAAC;QACpJ;MACF;MACA,MAAMnvE,GAAG,GAAG,IAAIwvE,SAAS,CAACkB,cAAc,GAAGC,cAAc,GAAG9+D,KAAK,EAAE6+D,cAAc,IAAIvB,eAAe,EAAE/vD,cAAc,EAAE8zC,MAAM,EAAE,CAAC,EAAEnvC,MAAM,EAAE4qD,OAAO,CAAC1qF,CAAC,CAAC,EAAE,IAAI,CAACgrF,6BAA6B,CAAC,CAACQ,UAAU,CAAC,CAAC;MACrMgB,eAAe,CAAC3tF,IAAI,CAACkd,GAAG,CAAC;IAC3B;IACA,OAAO,IAAI,CAAC6wE,sBAAsB,CAACrvD,OAAO,CAACx6B,GAAG,CAAC4rB,CAAC,IAAIA,CAAC,CAAC7nB,IAAI,CAAC,EAAE0lF,eAAe,EAAE5+D,KAAK,EAAEk9D,WAAW,CAACI,eAAe,CAAC,EAAE/vD,cAAc,EAAE2E,MAAM,CAAC;EAC5I;EACA+sD,4BAA4BA,CAACnlF,UAAU,EAAEwjF,eAAe,EAAE/vD,cAAc,EAAE;IACxE,MAAM;MACJiwD,QAAQ,EAAEC;IACZ,CAAC,GAAG,IAAI,CAACC,cAAc,CAAC5jF,UAAU,CAAC;IACnC,MAAMunE,MAAM,GAAG,IAAI,CAAC8b,MAAM,CAACta,QAAQ,CAAC4a,WAAW,CAAC;IAChD,MAAMvrD,MAAM,GAAG,EAAE;IACjB,MAAM/jB,GAAG,GAAG,IAAIwvE,SAAS,CAAC7jF,UAAU,EAAEwjF,eAAe,EAAE/vD,cAAc,EAAE8zC,MAAM,EAAE,CAAC,EAAEnvC,MAAM,EAAE,CAAC,EAAE,IAAI,CAACkrD,6BAA6B,CAAC,CAACQ,UAAU,CAAC,CAAC;IAC7I,MAAMjuD,OAAO,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC;IACxB,OAAO,IAAI,CAACqvD,sBAAsB,CAACrvD,OAAO,EAAE,CAACxhB,GAAG,CAAC,EAAErU,UAAU,EAAEojF,WAAW,CAACI,eAAe,CAAC,EAAE/vD,cAAc,EAAE2E,MAAM,CAAC;EACtH;EACA8sD,sBAAsBA,CAACrvD,OAAO,EAAE9oB,WAAW,EAAEmZ,KAAK,EAAEiS,QAAQ,EAAE1E,cAAc,EAAE2E,MAAM,EAAE;IACpF,MAAM/K,IAAI,GAAG,IAAIkG,SAAS,CAAC,CAAC,EAAErN,KAAK,CAAChvB,MAAM,CAAC;IAC3C,MAAMmvD,aAAa,GAAG,IAAI1wB,eAAe,CAACtI,IAAI,EAAEA,IAAI,CAACmG,UAAU,CAACC,cAAc,CAAC,EAAEoC,OAAO,EAAE9oB,WAAW,CAAC;IACtG,OAAO,IAAImrB,aAAa,CAACmuB,aAAa,EAAEngC,KAAK,EAAEiS,QAAQ,EAAE1E,cAAc,EAAE2E,MAAM,CAAC;EAClF;EACAysD,kBAAkBA,CAAC3+D,KAAK,EAAEs9D,eAAe,EAAEprD,MAAM,EAAEwsD,kBAAkB,EAAE;IACrE,MAAM/uD,OAAO,GAAG,EAAE;IAClB,MAAM9oB,WAAW,GAAG,EAAE;IACtB,MAAMi2E,OAAO,GAAG,EAAE;IAClB,MAAMoC,uBAAuB,GAAGR,kBAAkB,GAAGS,8BAA8B,CAACT,kBAAkB,CAAC,GAAG,IAAI;IAC9G,IAAItsF,CAAC,GAAG,CAAC;IACT,IAAIgtF,eAAe,GAAG,KAAK;IAC3B,IAAIC,gBAAgB,GAAG,KAAK;IAC5B,MAAMC,WAAW,GAAG,IAAI;IACxB,MAAMC,SAAS,GAAG,IAAI;IACtB,OAAOntF,CAAC,GAAG4tB,KAAK,CAAChvB,MAAM,EAAE;MACvB,IAAI,CAACouF,eAAe,EAAE;QACpB,MAAM/3D,KAAK,GAAGj1B,CAAC;QACfA,CAAC,GAAG4tB,KAAK,CAACS,OAAO,CAAC6+D,WAAW,EAAEltF,CAAC,CAAC;QACjC,IAAIA,CAAC,KAAK,CAAC,CAAC,EAAE;UACZA,CAAC,GAAG4tB,KAAK,CAAChvB,MAAM;QAClB;QACA,MAAMkI,IAAI,GAAG8mB,KAAK,CAAC6qB,SAAS,CAACxjB,KAAK,EAAEj1B,CAAC,CAAC;QACtCu9B,OAAO,CAAC1+B,IAAI,CAAC;UACXiI,IAAI;UACJmuB,KAAK;UACLhqB,GAAG,EAAEjL;QACP,CAAC,CAAC;QACFgtF,eAAe,GAAG,IAAI;MACxB,CAAC,MAAM;QACL,MAAMzzC,SAAS,GAAGv5C,CAAC;QACnB,MAAMotF,SAAS,GAAG7zC,SAAS,GAAG2zC,WAAW,CAACtuF,MAAM;QAChD,MAAMyuF,OAAO,GAAG,IAAI,CAACC,yBAAyB,CAAC1/D,KAAK,EAAEu/D,SAAS,EAAEC,SAAS,CAAC;QAC3E,IAAIC,OAAO,KAAK,CAAC,CAAC,EAAE;UAClBL,eAAe,GAAG,KAAK;UACvBC,gBAAgB,GAAG,IAAI;UACvB;QACF;QACA,MAAMM,OAAO,GAAGF,OAAO,GAAGF,SAAS,CAACvuF,MAAM;QAC1C,MAAMkI,IAAI,GAAG8mB,KAAK,CAAC6qB,SAAS,CAAC20C,SAAS,EAAEC,OAAO,CAAC;QAChD,IAAIvmF,IAAI,CAACwnB,IAAI,CAAC,CAAC,CAAC1vB,MAAM,KAAK,CAAC,EAAE;UAC5BkhC,MAAM,CAACjhC,IAAI,CAACmtF,aAAa,CAAC,2DAA2D,EAAEp+D,KAAK,EAAE,aAAa5tB,CAAC,KAAK,EAAEkrF,eAAe,CAAC,CAAC;QACtI;QACAz2E,WAAW,CAAC5V,IAAI,CAAC;UACfiI,IAAI;UACJmuB,KAAK,EAAEskB,SAAS;UAChBtuC,GAAG,EAAEsiF;QACP,CAAC,CAAC;QACF,MAAMC,uBAAuB,GAAGV,uBAAuB,EAAEnqF,GAAG,CAAC42C,SAAS,CAAC,IAAIA,SAAS;QACpF,MAAMnB,MAAM,GAAGo1C,uBAAuB,GAAGN,WAAW,CAACtuF,MAAM;QAC3D8rF,OAAO,CAAC7rF,IAAI,CAACu5C,MAAM,CAAC;QACpBp4C,CAAC,GAAGutF,OAAO;QACXP,eAAe,GAAG,KAAK;MACzB;IACF;IACA,IAAI,CAACA,eAAe,EAAE;MACpB,IAAIC,gBAAgB,EAAE;QACpB,MAAMQ,KAAK,GAAGlwD,OAAO,CAACA,OAAO,CAAC3+B,MAAM,GAAG,CAAC,CAAC;QACzC6uF,KAAK,CAAC3mF,IAAI,IAAI8mB,KAAK,CAAC6qB,SAAS,CAACz4C,CAAC,CAAC;QAChCytF,KAAK,CAACxiF,GAAG,GAAG2iB,KAAK,CAAChvB,MAAM;MAC1B,CAAC,MAAM;QACL2+B,OAAO,CAAC1+B,IAAI,CAAC;UACXiI,IAAI,EAAE8mB,KAAK,CAAC6qB,SAAS,CAACz4C,CAAC,CAAC;UACxBi1B,KAAK,EAAEj1B,CAAC;UACRiL,GAAG,EAAE2iB,KAAK,CAAChvB;QACb,CAAC,CAAC;MACJ;IACF;IACA,OAAO,IAAI6rF,kBAAkB,CAACltD,OAAO,EAAE9oB,WAAW,EAAEi2E,OAAO,CAAC;EAC9D;EACAgD,oBAAoBA,CAAC9/D,KAAK,EAAE+/D,oBAAoB,EAAExyD,cAAc,EAAE;IAChE,MAAMpG,IAAI,GAAG,IAAIkG,SAAS,CAAC,CAAC,EAAErN,KAAK,IAAI,IAAI,GAAG,CAAC,GAAGA,KAAK,CAAChvB,MAAM,CAAC;IAC/D,OAAO,IAAIghC,aAAa,CAAC,IAAI7C,gBAAgB,CAAChI,IAAI,EAAEA,IAAI,CAACmG,UAAU,CAACC,cAAc,CAAC,EAAEvN,KAAK,CAAC,EAAEA,KAAK,EAAE,OAAO+/D,oBAAoB,KAAK,QAAQ,GAAGA,oBAAoB,GAAG7C,WAAW,CAAC6C,oBAAoB,CAAC,EAAExyD,cAAc,EAAE,EAAE,CAAC;EAC9N;EACAmwD,cAAcA,CAAC19D,KAAK,EAAE;IACpB,MAAM5tB,CAAC,GAAG,IAAI,CAAC4tF,aAAa,CAAChgE,KAAK,CAAC;IACnC,OAAO5tB,CAAC,IAAI,IAAI,GAAG;MACjBorF,QAAQ,EAAEx9D,KAAK,CAAC6qB,SAAS,CAAC,CAAC,EAAEz4C,CAAC,CAAC;MAC/B2sF,WAAW,EAAE;IACf,CAAC,GAAG;MACFvB,QAAQ,EAAEx9D,KAAK;MACf++D,WAAW,EAAE;IACf,CAAC;EACH;EACAiB,aAAaA,CAAChgE,KAAK,EAAE;IACnB,IAAIigE,UAAU,GAAG,IAAI;IACrB,KAAK,IAAI7tF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4tB,KAAK,CAAChvB,MAAM,GAAG,CAAC,EAAEoB,CAAC,EAAE,EAAE;MACzC,MAAMC,IAAI,GAAG2tB,KAAK,CAACmB,UAAU,CAAC/uB,CAAC,CAAC;MAChC,MAAM8tF,QAAQ,GAAGlgE,KAAK,CAACmB,UAAU,CAAC/uB,CAAC,GAAG,CAAC,CAAC;MACxC,IAAIC,IAAI,KAAKq1C,MAAM,IAAIw4C,QAAQ,IAAIx4C,MAAM,IAAIu4C,UAAU,IAAI,IAAI,EAAE,OAAO7tF,CAAC;MACzE,IAAI6tF,UAAU,KAAK5tF,IAAI,EAAE;QACvB4tF,UAAU,GAAG,IAAI;MACnB,CAAC,MAAM,IAAIA,UAAU,IAAI,IAAI,IAAI31C,OAAO,CAACj4C,IAAI,CAAC,EAAE;QAC9C4tF,UAAU,GAAG5tF,IAAI;MACnB;IACF;IACA,OAAO,IAAI;EACb;EACAkrF,qBAAqBA,CAACrrD,MAAM,EAAElS,KAAK,EAAEs9D,eAAe,EAAE;IACpD,IAAIzmC,UAAU,GAAG,CAAC,CAAC;IACnB,IAAII,QAAQ,GAAG,CAAC,CAAC;IACjB,KAAK,MAAMkpC,SAAS,IAAI,IAAI,CAACC,oBAAoB,CAACpgE,KAAK,EAAE,CAAC,CAAC,EAAE;MAC3D,IAAI62B,UAAU,KAAK,CAAC,CAAC,EAAE;QACrB,IAAI72B,KAAK,CAACoC,UAAU,CAAC,IAAI,CAAC,EAAE;UAC1By0B,UAAU,GAAGspC,SAAS;QACxB;MACF,CAAC,MAAM;QACLlpC,QAAQ,GAAG,IAAI,CAACyoC,yBAAyB,CAAC1/D,KAAK,EAAE,IAAI,EAAEmgE,SAAS,CAAC;QACjE,IAAIlpC,QAAQ,GAAG,CAAC,CAAC,EAAE;UACjB;QACF;MACF;IACF;IACA,IAAIJ,UAAU,GAAG,CAAC,CAAC,IAAII,QAAQ,GAAG,CAAC,CAAC,EAAE;MACpC/kB,MAAM,CAACjhC,IAAI,CAACmtF,aAAa,CAAC,wDAAwD,EAAEp+D,KAAK,EAAE,aAAa62B,UAAU,KAAK,EAAEymC,eAAe,CAAC,CAAC;IAC5I;EACF;EACAoC,yBAAyBA,CAAC1/D,KAAK,EAAEqgE,aAAa,EAAEh5D,KAAK,EAAE;IACrD,KAAK,MAAM84D,SAAS,IAAI,IAAI,CAACC,oBAAoB,CAACpgE,KAAK,EAAEqH,KAAK,CAAC,EAAE;MAC/D,IAAIrH,KAAK,CAACoC,UAAU,CAACi+D,aAAa,EAAEF,SAAS,CAAC,EAAE;QAC9C,OAAOA,SAAS;MAClB;MACA,IAAIngE,KAAK,CAACoC,UAAU,CAAC,IAAI,EAAE+9D,SAAS,CAAC,EAAE;QACrC,OAAOngE,KAAK,CAACS,OAAO,CAAC4/D,aAAa,EAAEF,SAAS,CAAC;MAChD;IACF;IACA,OAAO,CAAC,CAAC;EACX;EACA,CAACC,oBAAoBA,CAACpgE,KAAK,EAAEqH,KAAK,EAAE;IAClC,IAAIi5D,YAAY,GAAG,IAAI;IACvB,IAAIC,WAAW,GAAG,CAAC;IACnB,KAAK,IAAInuF,CAAC,GAAGi1B,KAAK,EAAEj1B,CAAC,GAAG4tB,KAAK,CAAChvB,MAAM,EAAEoB,CAAC,EAAE,EAAE;MACzC,MAAMC,IAAI,GAAG2tB,KAAK,CAAC5tB,CAAC,CAAC;MACrB,IAAIk4C,OAAO,CAACtqB,KAAK,CAACmB,UAAU,CAAC/uB,CAAC,CAAC,CAAC,KAAKkuF,YAAY,KAAK,IAAI,IAAIA,YAAY,KAAKjuF,IAAI,CAAC,IAAIkuF,WAAW,GAAG,CAAC,KAAK,CAAC,EAAE;QAC7GD,YAAY,GAAGA,YAAY,KAAK,IAAI,GAAGjuF,IAAI,GAAG,IAAI;MACpD,CAAC,MAAM,IAAIiuF,YAAY,KAAK,IAAI,EAAE;QAChC,MAAMluF,CAAC;MACT;MACAmuF,WAAW,GAAGluF,IAAI,KAAK,IAAI,GAAGkuF,WAAW,GAAG,CAAC,GAAG,CAAC;IACnD;EACF;AACF;AACA,IAAIC,iBAAiB;AACrB,CAAC,UAAUA,iBAAiB,EAAE;EAC5BA,iBAAiB,CAACA,iBAAiB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EACzDA,iBAAiB,CAACA,iBAAiB,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;AACnE,CAAC,EAAEA,iBAAiB,KAAKA,iBAAiB,GAAG,CAAC,CAAC,CAAC,CAAC;AACjD,MAAMC,qBAAqB,GAAG,IAAInuC,GAAG,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AAC/E,MAAMqrC,SAAS,CAAC;EACd39D,KAAK;EACLs9D,eAAe;EACf/vD,cAAc;EACd8zC,MAAM;EACNqf,UAAU;EACVxuD,MAAM;EACNsY,MAAM;EACNm2C,4BAA4B;EAC5BC,eAAe,GAAG,CAAC;EACnBC,iBAAiB,GAAG,CAAC;EACrBC,eAAe,GAAG,CAAC;EACnB3nF,OAAO,GAAGqnF,iBAAiB,CAACliF,IAAI;EAChCyiF,eAAe,GAAG,IAAIrtF,GAAG,CAAC,CAAC;EAC3B6I,KAAK,GAAG,CAAC;EACTzG,WAAWA,CAACkqB,KAAK,EAAEs9D,eAAe,EAAE/vD,cAAc,EAAE8zC,MAAM,EAAEqf,UAAU,EAAExuD,MAAM,EAAEsY,MAAM,EAAEm2C,4BAA4B,EAAE;IACpH,IAAI,CAAC3gE,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACs9D,eAAe,GAAGA,eAAe;IACtC,IAAI,CAAC/vD,cAAc,GAAGA,cAAc;IACpC,IAAI,CAAC8zC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACqf,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACxuD,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACsY,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACm2C,4BAA4B,GAAGA,4BAA4B;EAClE;EACAlb,IAAIA,CAACj7B,MAAM,EAAE;IACX,MAAMp4C,CAAC,GAAG,IAAI,CAACmK,KAAK,GAAGiuC,MAAM;IAC7B,OAAOp4C,CAAC,GAAG,IAAI,CAACivE,MAAM,CAACrwE,MAAM,GAAG,IAAI,CAACqwE,MAAM,CAACjvE,CAAC,CAAC,GAAGynF,GAAG;EACtD;EACA,IAAI55B,IAAIA,CAAA,EAAG;IACT,OAAO,IAAI,CAACwlB,IAAI,CAAC,CAAC,CAAC;EACrB;EACA,IAAIub,KAAKA,CAAA,EAAG;IACV,OAAO,IAAI,CAACzkF,KAAK,IAAI,IAAI,CAAC8kE,MAAM,CAACrwE,MAAM;EACzC;EACA,IAAIiwF,UAAUA,CAAA,EAAG;IACf,OAAO,IAAI,CAACD,KAAK,GAAG,IAAI,CAACE,eAAe,GAAG,IAAI,CAACjhC,IAAI,CAAC1jD,KAAK,GAAG,IAAI,CAACiuC,MAAM;EAC1E;EACA,IAAI02C,eAAeA,CAAA,EAAG;IACpB,IAAI,IAAI,CAAC3kF,KAAK,GAAG,CAAC,EAAE;MAClB,MAAM4kF,QAAQ,GAAG,IAAI,CAAC1b,IAAI,CAAC,CAAC,CAAC,CAAC;MAC9B,OAAO0b,QAAQ,CAAC9jF,GAAG,GAAG,IAAI,CAACmtC,MAAM;IACnC;IACA,IAAI,IAAI,CAAC62B,MAAM,CAACrwE,MAAM,KAAK,CAAC,EAAE;MAC5B,OAAO,IAAI,CAACgvB,KAAK,CAAChvB,MAAM,GAAG,IAAI,CAACw5C,MAAM;IACxC;IACA,OAAO,IAAI,CAACyV,IAAI,CAAC1jD,KAAK,GAAG,IAAI,CAACiuC,MAAM;EACtC;EACA,IAAI42C,qBAAqBA,CAAA,EAAG;IAC1B,OAAO,IAAI,CAAC7zD,cAAc,GAAG,IAAI,CAAC0zD,UAAU;EAC9C;EACA95D,IAAIA,CAACE,KAAK,EAAEg6D,kBAAkB,EAAE;IAC9B,IAAIpqC,QAAQ,GAAG,IAAI,CAACiqC,eAAe;IACnC,IAAIG,kBAAkB,KAAKxgE,SAAS,IAAIwgE,kBAAkB,GAAG,IAAI,CAACH,eAAe,EAAE;MACjFjqC,QAAQ,GAAGoqC,kBAAkB;IAC/B;IACA,IAAIh6D,KAAK,GAAG4vB,QAAQ,EAAE;MACpB,MAAMof,GAAG,GAAGpf,QAAQ;MACpBA,QAAQ,GAAG5vB,KAAK;MAChBA,KAAK,GAAGgvC,GAAG;IACb;IACA,OAAO,IAAIhpC,SAAS,CAAChG,KAAK,EAAE4vB,QAAQ,CAAC;EACvC;EACA/1C,UAAUA,CAACmmB,KAAK,EAAEg6D,kBAAkB,EAAE;IACpC,MAAMC,MAAM,GAAG,GAAGj6D,KAAK,IAAI,IAAI,CAAC45D,UAAU,IAAII,kBAAkB,EAAE;IAClE,IAAI,CAAC,IAAI,CAACN,eAAe,CAAC5qF,GAAG,CAACmrF,MAAM,CAAC,EAAE;MACrC,IAAI,CAACP,eAAe,CAAC/rF,GAAG,CAACssF,MAAM,EAAE,IAAI,CAACn6D,IAAI,CAACE,KAAK,EAAEg6D,kBAAkB,CAAC,CAAC/zD,UAAU,CAAC,IAAI,CAACC,cAAc,CAAC,CAAC;IACxG;IACA,OAAO,IAAI,CAACwzD,eAAe,CAAChsF,GAAG,CAACusF,MAAM,CAAC;EACzC;EACAntE,OAAOA,CAAA,EAAG;IACR,IAAI,CAAC5X,KAAK,EAAE;EACd;EACAglF,WAAWA,CAACpoF,OAAO,EAAEopE,EAAE,EAAE;IACvB,IAAI,CAACppE,OAAO,IAAIA,OAAO;IACvB,MAAMqoF,GAAG,GAAGjf,EAAE,CAAC,CAAC;IAChB,IAAI,CAACppE,OAAO,IAAIA,OAAO;IACvB,OAAOqoF,GAAG;EACZ;EACAC,wBAAwBA,CAACz3C,IAAI,EAAE;IAC7B,IAAI,IAAI,CAACiW,IAAI,CAACk3B,WAAW,CAACntC,IAAI,CAAC,EAAE;MAC/B,IAAI,CAAC71B,OAAO,CAAC,CAAC;MACd,OAAO,IAAI;IACb,CAAC,MAAM;MACL,OAAO,KAAK;IACd;EACF;EACAutE,cAAcA,CAAA,EAAG;IACf,OAAO,IAAI,CAACzhC,IAAI,CAAC63B,YAAY,CAAC,CAAC;EACjC;EACA6J,aAAaA,CAAA,EAAG;IACd,OAAO,IAAI,CAAC1hC,IAAI,CAAC83B,WAAW,CAAC,CAAC;EAChC;EACA6J,eAAeA,CAAC53C,IAAI,EAAE;IACpB,IAAI,IAAI,CAACy3C,wBAAwB,CAACz3C,IAAI,CAAC,EAAE;IACzC,IAAI,CAAChS,KAAK,CAAC,oBAAoB73B,MAAM,CAAC4qC,YAAY,CAACf,IAAI,CAAC,EAAE,CAAC;EAC7D;EACA63C,uBAAuBA,CAACz2E,EAAE,EAAE;IAC1B,IAAI,IAAI,CAAC60C,IAAI,CAACs3B,UAAU,CAACnsE,EAAE,CAAC,EAAE;MAC5B,IAAI,CAAC+I,OAAO,CAAC,CAAC;MACd,OAAO,IAAI;IACb,CAAC,MAAM;MACL,OAAO,KAAK;IACd;EACF;EACA2tE,oBAAoBA,CAACzgE,KAAK,EAAE;IAC1B,OAAOA,KAAK,CAACtnB,IAAI,KAAK28E,SAAS,CAACc,QAAQ,IAAI3nD,MAAM,CAACK,qBAAqB,CAAC7O,KAAK,CAAC61D,QAAQ,CAAC;EAC1F;EACA6K,cAAcA,CAACn3E,QAAQ,EAAE;IACvB,IAAI,IAAI,CAACi3E,uBAAuB,CAACj3E,QAAQ,CAAC,EAAE;IAC5C,IAAI,CAACotB,KAAK,CAAC,6BAA6BptB,QAAQ,EAAE,CAAC;EACrD;EACAo3E,gBAAgBA,CAACC,GAAG,EAAE;IACpB,OAAOA,GAAG,KAAKpI,GAAG,GAAG,cAAc,GAAG,SAASoI,GAAG,EAAE;EACtD;EACAC,yBAAyBA,CAAA,EAAG;IAC1B,MAAM1kD,CAAC,GAAG,IAAI,CAACyiB,IAAI;IACnB,IAAI,CAACziB,CAAC,CAACi6C,YAAY,CAAC,CAAC,IAAI,CAACj6C,CAAC,CAACo6C,SAAS,CAAC,CAAC,EAAE;MACvC,IAAIp6C,CAAC,CAACk6C,mBAAmB,CAAC,CAAC,EAAE;QAC3B,IAAI,CAACyK,gCAAgC,CAAC3kD,CAAC,EAAE,gCAAgC,CAAC;MAC5E,CAAC,MAAM;QACL,IAAI,CAACxF,KAAK,CAAC,cAAc,IAAI,CAACgqD,gBAAgB,CAACxkD,CAAC,CAAC,kCAAkC,CAAC;MACtF;MACA,OAAO,IAAI;IACb;IACA,IAAI,CAACrpB,OAAO,CAAC,CAAC;IACd,OAAOqpB,CAAC,CAACvqC,QAAQ,CAAC,CAAC;EACrB;EACAmvF,iCAAiCA,CAAA,EAAG;IAClC,MAAM5kD,CAAC,GAAG,IAAI,CAACyiB,IAAI;IACnB,IAAI,CAACziB,CAAC,CAACi6C,YAAY,CAAC,CAAC,IAAI,CAACj6C,CAAC,CAACo6C,SAAS,CAAC,CAAC,IAAI,CAACp6C,CAAC,CAAC85C,QAAQ,CAAC,CAAC,EAAE;MACxD,IAAI95C,CAAC,CAACk6C,mBAAmB,CAAC,CAAC,EAAE;QAC3B,IAAI,CAACyK,gCAAgC,CAAC3kD,CAAC,EAAE,wCAAwC,CAAC;MACpF,CAAC,MAAM;QACL,IAAI,CAACxF,KAAK,CAAC,cAAc,IAAI,CAACgqD,gBAAgB,CAACxkD,CAAC,CAAC,2CAA2C,CAAC;MAC/F;MACA,OAAO,EAAE;IACX;IACA,IAAI,CAACrpB,OAAO,CAAC,CAAC;IACd,OAAOqpB,CAAC,CAACvqC,QAAQ,CAAC,CAAC;EACrB;EACA2qF,UAAUA,CAAA,EAAG;IACX,MAAMtvE,KAAK,GAAG,EAAE;IAChB,MAAM+Y,KAAK,GAAG,IAAI,CAAC45D,UAAU;IAC7B,OAAO,IAAI,CAAC1kF,KAAK,GAAG,IAAI,CAAC8kE,MAAM,CAACrwE,MAAM,EAAE;MACtC,MAAMoU,IAAI,GAAG,IAAI,CAACi9E,SAAS,CAAC,CAAC;MAC7B/zE,KAAK,CAACrd,IAAI,CAACmU,IAAI,CAAC;MAChB,IAAI,IAAI,CAACq8E,wBAAwB,CAAC75C,UAAU,CAAC,EAAE;QAC7C,IAAI,EAAE,IAAI,CAAC84C,UAAU,GAAG,CAAC,CAAC,EAAE;UAC1B,IAAI,CAAC1oD,KAAK,CAAC,sDAAsD,CAAC;QACpE;QACA,OAAO,IAAI,CAACypD,wBAAwB,CAAC75C,UAAU,CAAC,EAAE,CAAC;MACrD,CAAC,MAAM,IAAI,IAAI,CAACrrC,KAAK,GAAG,IAAI,CAAC8kE,MAAM,CAACrwE,MAAM,EAAE;QAC1C,MAAMsxF,UAAU,GAAG,IAAI,CAAC/lF,KAAK;QAC7B,IAAI,CAACy7B,KAAK,CAAC,qBAAqB,IAAI,CAACioB,IAAI,GAAG,CAAC;QAC7C,IAAI,IAAI,CAAC1jD,KAAK,KAAK+lF,UAAU,EAAE;UAC7B;QACF;MACF;IACF;IACA,IAAIh0E,KAAK,CAACtd,MAAM,KAAK,CAAC,EAAE;MACtB,MAAMuxF,eAAe,GAAG,IAAI,CAAC/3C,MAAM;MACnC,MAAMg4C,aAAa,GAAG,IAAI,CAACh4C,MAAM,GAAG,IAAI,CAACxqB,KAAK,CAAChvB,MAAM;MACrD,OAAO,IAAI48B,WAAW,CAAC,IAAI,CAACzG,IAAI,CAACo7D,eAAe,EAAEC,aAAa,CAAC,EAAE,IAAI,CAACthF,UAAU,CAACqhF,eAAe,EAAEC,aAAa,CAAC,CAAC;IACpH;IACA,IAAIl0E,KAAK,CAACtd,MAAM,IAAI,CAAC,EAAE,OAAOsd,KAAK,CAAC,CAAC,CAAC;IACtC,OAAO,IAAI4f,KAAK,CAAC,IAAI,CAAC/G,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAE/Y,KAAK,CAAC;EACnE;EACA+zE,SAASA,CAAA,EAAG;IACV,MAAMh7D,KAAK,GAAG,IAAI,CAAC45D,UAAU;IAC7B,IAAI/uF,MAAM,GAAG,IAAI,CAACuwF,eAAe,CAAC,CAAC;IACnC,IAAI,IAAI,CAACZ,uBAAuB,CAAC,GAAG,CAAC,EAAE;MACrC,IAAI,IAAI,CAACnB,UAAU,GAAG,CAAC,EAAE;QACvB,IAAI,CAAC1oD,KAAK,CAAC,4CAA4C,CAAC;MAC1D;MACA,GAAG;QACD,MAAMmyC,SAAS,GAAG,IAAI,CAAC8W,UAAU;QACjC,IAAIyB,MAAM,GAAG,IAAI,CAACR,yBAAyB,CAAC,CAAC;QAC7C,IAAIv0D,QAAQ;QACZ,IAAIg1D,WAAW,GAAG9hE,SAAS;QAC3B,IAAI6hE,MAAM,KAAK,IAAI,EAAE;UACnB/0D,QAAQ,GAAG,IAAI,CAACzsB,UAAU,CAACipE,SAAS,CAAC;QACvC,CAAC,MAAM;UACLuY,MAAM,GAAG,EAAE;UACXC,WAAW,GAAG,IAAI,CAAC1iC,IAAI,CAAC1jD,KAAK,KAAK,CAAC,CAAC,GAAG,IAAI,CAAC0jD,IAAI,CAAC1jD,KAAK,GAAG,IAAI,CAACyjB,KAAK,CAAChvB,MAAM,GAAG,IAAI,CAACw5C,MAAM;UACxF7c,QAAQ,GAAG,IAAIN,SAAS,CAACs1D,WAAW,EAAEA,WAAW,CAAC,CAACr1D,UAAU,CAAC,IAAI,CAACC,cAAc,CAAC;QACpF;QACA,MAAM3nB,IAAI,GAAG,EAAE;QACf,OAAO,IAAI,CAAC67E,wBAAwB,CAAC95C,MAAM,CAAC,EAAE;UAC5C/hC,IAAI,CAAC3U,IAAI,CAAC,IAAI,CAACwxF,eAAe,CAAC,CAAC,CAAC;QACnC;QACA,IAAI1oF,IAAI;QACR,IAAI,IAAI,CAAC4mF,4BAA4B,EAAE;UACrC,MAAMpqC,QAAQ,GAAGmsC,MAAM,CAACvhE,UAAU,CAAC,CAAC,CAAC;UACrCpnB,IAAI,GAAGw8C,QAAQ,KAAK1N,EAAE,IAAI0N,QAAQ,IAAInO,EAAE,IAAImO,QAAQ,IAAI/N,EAAE,GAAGxZ,eAAe,CAAC4zD,kBAAkB,GAAG5zD,eAAe,CAAC6zD,gBAAgB;QACpI,CAAC,MAAM;UACL9oF,IAAI,GAAGi1B,eAAe,CAAC6zD,gBAAgB;QACzC;QACA3wF,MAAM,GAAG,IAAI+8B,WAAW,CAAC,IAAI,CAAC9H,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,EAAEs7D,WAAW,CAAC,EAAEzwF,MAAM,EAAEwwF,MAAM,EAAE98E,IAAI,EAAE7L,IAAI,EAAE4zB,QAAQ,CAAC;MACvH,CAAC,QAAQ,IAAI,CAACk0D,uBAAuB,CAAC,GAAG,CAAC;IAC5C;IACA,OAAO3vF,MAAM;EACf;EACAuwF,eAAeA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACK,gBAAgB,CAAC,CAAC;EAChC;EACAA,gBAAgBA,CAAA,EAAG;IACjB,MAAMz7D,KAAK,GAAG,IAAI,CAAC45D,UAAU;IAC7B,MAAM/uF,MAAM,GAAG,IAAI,CAAC6wF,cAAc,CAAC,CAAC;IACpC,IAAI,IAAI,CAAClB,uBAAuB,CAAC,GAAG,CAAC,EAAE;MACrC,MAAMmB,GAAG,GAAG,IAAI,CAACX,SAAS,CAAC,CAAC;MAC5B,IAAIY,EAAE;MACN,IAAI,CAAC,IAAI,CAACxB,wBAAwB,CAAC95C,MAAM,CAAC,EAAE;QAC1C,MAAMtqC,GAAG,GAAG,IAAI,CAAC4jF,UAAU;QAC3B,MAAMnnF,UAAU,GAAG,IAAI,CAACkmB,KAAK,CAAC6qB,SAAS,CAACxjB,KAAK,EAAEhqB,GAAG,CAAC;QACnD,IAAI,CAAC26B,KAAK,CAAC,0BAA0Bl+B,UAAU,6BAA6B,CAAC;QAC7EmpF,EAAE,GAAG,IAAIr1D,WAAW,CAAC,IAAI,CAACzG,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,CAAC;MAChE,CAAC,MAAM;QACL47D,EAAE,GAAG,IAAI,CAACZ,SAAS,CAAC,CAAC;MACvB;MACA,OAAO,IAAIj0D,WAAW,CAAC,IAAI,CAACjH,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAEn1B,MAAM,EAAE8wF,GAAG,EAAEC,EAAE,CAAC;IACnF,CAAC,MAAM;MACL,OAAO/wF,MAAM;IACf;EACF;EACA6wF,cAAcA,CAAA,EAAG;IACf,MAAM17D,KAAK,GAAG,IAAI,CAAC45D,UAAU;IAC7B,IAAI/uF,MAAM,GAAG,IAAI,CAACgxF,eAAe,CAAC,CAAC;IACnC,OAAO,IAAI,CAACrB,uBAAuB,CAAC,IAAI,CAAC,EAAE;MACzC,MAAM7xD,KAAK,GAAG,IAAI,CAACkzD,eAAe,CAAC,CAAC;MACpChxF,MAAM,GAAG,IAAI29B,MAAM,CAAC,IAAI,CAAC1I,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAE,IAAI,EAAEn1B,MAAM,EAAE89B,KAAK,CAAC;IACpF;IACA,OAAO99B,MAAM;EACf;EACAgxF,eAAeA,CAAA,EAAG;IAChB,MAAM77D,KAAK,GAAG,IAAI,CAAC45D,UAAU;IAC7B,IAAI/uF,MAAM,GAAG,IAAI,CAACixF,sBAAsB,CAAC,CAAC;IAC1C,OAAO,IAAI,CAACtB,uBAAuB,CAAC,IAAI,CAAC,EAAE;MACzC,MAAM7xD,KAAK,GAAG,IAAI,CAACmzD,sBAAsB,CAAC,CAAC;MAC3CjxF,MAAM,GAAG,IAAI29B,MAAM,CAAC,IAAI,CAAC1I,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAE,IAAI,EAAEn1B,MAAM,EAAE89B,KAAK,CAAC;IACpF;IACA,OAAO99B,MAAM;EACf;EACAixF,sBAAsBA,CAAA,EAAG;IACvB,MAAM97D,KAAK,GAAG,IAAI,CAAC45D,UAAU;IAC7B,IAAI/uF,MAAM,GAAG,IAAI,CAACkxF,aAAa,CAAC,CAAC;IACjC,OAAO,IAAI,CAACvB,uBAAuB,CAAC,IAAI,CAAC,EAAE;MACzC,MAAM7xD,KAAK,GAAG,IAAI,CAACozD,aAAa,CAAC,CAAC;MAClClxF,MAAM,GAAG,IAAI29B,MAAM,CAAC,IAAI,CAAC1I,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAE,IAAI,EAAEn1B,MAAM,EAAE89B,KAAK,CAAC;IACpF;IACA,OAAO99B,MAAM;EACf;EACAkxF,aAAaA,CAAA,EAAG;IACd,MAAM/7D,KAAK,GAAG,IAAI,CAAC45D,UAAU;IAC7B,IAAI/uF,MAAM,GAAG,IAAI,CAACmxF,eAAe,CAAC,CAAC;IACnC,OAAO,IAAI,CAACpjC,IAAI,CAAClmD,IAAI,IAAI28E,SAAS,CAACc,QAAQ,EAAE;MAC3C,MAAM5sE,QAAQ,GAAG,IAAI,CAACq1C,IAAI,CAACi3B,QAAQ;MACnC,QAAQtsE,QAAQ;QACd,KAAK,IAAI;QACT,KAAK,KAAK;QACV,KAAK,IAAI;QACT,KAAK,KAAK;UACR,IAAI,CAACuJ,OAAO,CAAC,CAAC;UACd,MAAM6b,KAAK,GAAG,IAAI,CAACqzD,eAAe,CAAC,CAAC;UACpCnxF,MAAM,GAAG,IAAI29B,MAAM,CAAC,IAAI,CAAC1I,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAEzc,QAAQ,EAAE1Y,MAAM,EAAE89B,KAAK,CAAC;UACtF;MACJ;MACA;IACF;IACA,OAAO99B,MAAM;EACf;EACAmxF,eAAeA,CAAA,EAAG;IAChB,MAAMh8D,KAAK,GAAG,IAAI,CAAC45D,UAAU;IAC7B,IAAI/uF,MAAM,GAAG,IAAI,CAACoxF,aAAa,CAAC,CAAC;IACjC,OAAO,IAAI,CAACrjC,IAAI,CAAClmD,IAAI,IAAI28E,SAAS,CAACc,QAAQ,IAAI,IAAI,CAACv3B,IAAI,CAACs4B,WAAW,EAAE;MACpE,MAAM3tE,QAAQ,GAAG,IAAI,CAACq1C,IAAI,CAACi3B,QAAQ;MACnC,QAAQtsE,QAAQ;QACd,KAAK,GAAG;QACR,KAAK,GAAG;QACR,KAAK,IAAI;QACT,KAAK,IAAI;QACT,KAAK,IAAI;UACP,IAAI,CAACuJ,OAAO,CAAC,CAAC;UACd,MAAM6b,KAAK,GAAG,IAAI,CAACszD,aAAa,CAAC,CAAC;UAClCpxF,MAAM,GAAG,IAAI29B,MAAM,CAAC,IAAI,CAAC1I,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAEzc,QAAQ,EAAE1Y,MAAM,EAAE89B,KAAK,CAAC;UACtF;MACJ;MACA;IACF;IACA,OAAO99B,MAAM;EACf;EACAoxF,aAAaA,CAAA,EAAG;IACd,MAAMj8D,KAAK,GAAG,IAAI,CAAC45D,UAAU;IAC7B,IAAI/uF,MAAM,GAAG,IAAI,CAACqxF,mBAAmB,CAAC,CAAC;IACvC,OAAO,IAAI,CAACtjC,IAAI,CAAClmD,IAAI,IAAI28E,SAAS,CAACc,QAAQ,EAAE;MAC3C,MAAM5sE,QAAQ,GAAG,IAAI,CAACq1C,IAAI,CAACi3B,QAAQ;MACnC,QAAQtsE,QAAQ;QACd,KAAK,GAAG;QACR,KAAK,GAAG;UACN,IAAI,CAACuJ,OAAO,CAAC,CAAC;UACd,IAAI6b,KAAK,GAAG,IAAI,CAACuzD,mBAAmB,CAAC,CAAC;UACtCrxF,MAAM,GAAG,IAAI29B,MAAM,CAAC,IAAI,CAAC1I,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAEzc,QAAQ,EAAE1Y,MAAM,EAAE89B,KAAK,CAAC;UACtF;MACJ;MACA;IACF;IACA,OAAO99B,MAAM;EACf;EACAqxF,mBAAmBA,CAAA,EAAG;IACpB,MAAMl8D,KAAK,GAAG,IAAI,CAAC45D,UAAU;IAC7B,IAAI/uF,MAAM,GAAG,IAAI,CAACsxF,mBAAmB,CAAC,CAAC;IACvC,OAAO,IAAI,CAACvjC,IAAI,CAAClmD,IAAI,IAAI28E,SAAS,CAACc,QAAQ,EAAE;MAC3C,MAAM5sE,QAAQ,GAAG,IAAI,CAACq1C,IAAI,CAACi3B,QAAQ;MACnC,QAAQtsE,QAAQ;QACd,KAAK,GAAG;QACR,KAAK,GAAG;QACR,KAAK,GAAG;UACN,IAAI,CAACuJ,OAAO,CAAC,CAAC;UACd,MAAM6b,KAAK,GAAG,IAAI,CAACwzD,mBAAmB,CAAC,CAAC;UACxCtxF,MAAM,GAAG,IAAI29B,MAAM,CAAC,IAAI,CAAC1I,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAEzc,QAAQ,EAAE1Y,MAAM,EAAE89B,KAAK,CAAC;UACtF;MACJ;MACA;IACF;IACA,OAAO99B,MAAM;EACf;EACAsxF,mBAAmBA,CAAA,EAAG;IACpB,MAAMn8D,KAAK,GAAG,IAAI,CAAC45D,UAAU;IAC7B,IAAI/uF,MAAM,GAAG,IAAI,CAACuxF,WAAW,CAAC,CAAC;IAC/B,OAAO,IAAI,CAACxjC,IAAI,CAAClmD,IAAI,IAAI28E,SAAS,CAACc,QAAQ,IAAI,IAAI,CAACv3B,IAAI,CAACi3B,QAAQ,KAAK,IAAI,EAAE;MAC1E,IAAIhlF,MAAM,YAAYi+B,KAAK,IAAIj+B,MAAM,YAAYw+B,SAAS,IAAIx+B,MAAM,YAAY0+B,gBAAgB,IAAI1+B,MAAM,YAAY4+B,cAAc,EAAE;QACpI,IAAI,CAACkH,KAAK,CAAC,gIAAgI,CAAC;MAC9I;MACA,IAAI,CAAC7jB,OAAO,CAAC,CAAC;MACd,MAAM6b,KAAK,GAAG,IAAI,CAACwzD,mBAAmB,CAAC,CAAC;MACxCtxF,MAAM,GAAG,IAAI29B,MAAM,CAAC,IAAI,CAAC1I,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAE,IAAI,EAAEn1B,MAAM,EAAE89B,KAAK,CAAC;IACpF;IACA,OAAO99B,MAAM;EACf;EACAuxF,WAAWA,CAAA,EAAG;IACZ,IAAI,IAAI,CAACxjC,IAAI,CAAClmD,IAAI,IAAI28E,SAAS,CAACc,QAAQ,EAAE;MACxC,MAAMnwD,KAAK,GAAG,IAAI,CAAC45D,UAAU;MAC7B,MAAMr2E,QAAQ,GAAG,IAAI,CAACq1C,IAAI,CAACi3B,QAAQ;MACnC,IAAIhlF,MAAM;MACV,QAAQ0Y,QAAQ;QACd,KAAK,GAAG;UACN,IAAI,CAACuJ,OAAO,CAAC,CAAC;UACdjiB,MAAM,GAAG,IAAI,CAACuxF,WAAW,CAAC,CAAC;UAC3B,OAAOtzD,KAAK,CAACE,UAAU,CAAC,IAAI,CAAClJ,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAEn1B,MAAM,CAAC;QAC3E,KAAK,GAAG;UACN,IAAI,CAACiiB,OAAO,CAAC,CAAC;UACdjiB,MAAM,GAAG,IAAI,CAACuxF,WAAW,CAAC,CAAC;UAC3B,OAAOtzD,KAAK,CAACC,WAAW,CAAC,IAAI,CAACjJ,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAEn1B,MAAM,CAAC;QAC5E,KAAK,GAAG;UACN,IAAI,CAACiiB,OAAO,CAAC,CAAC;UACdjiB,MAAM,GAAG,IAAI,CAACuxF,WAAW,CAAC,CAAC;UAC3B,OAAO,IAAI/yD,SAAS,CAAC,IAAI,CAACvJ,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAEn1B,MAAM,CAAC;MAC1E;IACF,CAAC,MAAM,IAAI,IAAI,CAAC+tD,IAAI,CAACo4B,eAAe,CAAC,CAAC,EAAE;MACtC,IAAI,CAAClkE,OAAO,CAAC,CAAC;MACd,MAAMkT,KAAK,GAAG,IAAI,CAAC45D,UAAU;MAC7B,IAAI/uF,MAAM,GAAG,IAAI,CAACuxF,WAAW,CAAC,CAAC;MAC/B,OAAO,IAAI7yD,gBAAgB,CAAC,IAAI,CAACzJ,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAEn1B,MAAM,CAAC;IAC/E,CAAC,MAAM,IAAI,IAAI,CAAC+tD,IAAI,CAACq4B,aAAa,CAAC,CAAC,EAAE;MACpC,IAAI,CAACnkE,OAAO,CAAC,CAAC;MACd,MAAMkT,KAAK,GAAG,IAAI,CAAC45D,UAAU;MAC7B,IAAI/uF,MAAM,GAAG,IAAI,CAACuxF,WAAW,CAAC,CAAC;MAC/B,OAAO,IAAI3yD,cAAc,CAAC,IAAI,CAAC3J,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAEn1B,MAAM,CAAC;IAC7E;IACA,OAAO,IAAI,CAACwxF,cAAc,CAAC,CAAC;EAC9B;EACAA,cAAcA,CAAA,EAAG;IACf,MAAMr8D,KAAK,GAAG,IAAI,CAAC45D,UAAU;IAC7B,IAAI/uF,MAAM,GAAG,IAAI,CAACyxF,YAAY,CAAC,CAAC;IAChC,OAAO,IAAI,EAAE;MACX,IAAI,IAAI,CAAClC,wBAAwB,CAACh6C,OAAO,CAAC,EAAE;QAC1Cv1C,MAAM,GAAG,IAAI,CAAC0xF,iBAAiB,CAAC1xF,MAAM,EAAEm1B,KAAK,EAAE,KAAK,CAAC;MACvD,CAAC,MAAM,IAAI,IAAI,CAACw6D,uBAAuB,CAAC,IAAI,CAAC,EAAE;QAC7C,IAAI,IAAI,CAACJ,wBAAwB,CAACt6C,OAAO,CAAC,EAAE;UAC1Cj1C,MAAM,GAAG,IAAI,CAAC2xF,SAAS,CAAC3xF,MAAM,EAAEm1B,KAAK,EAAE,IAAI,CAAC;QAC9C,CAAC,MAAM;UACLn1B,MAAM,GAAG,IAAI,CAACuvF,wBAAwB,CAACh5C,SAAS,CAAC,GAAG,IAAI,CAACq7C,qBAAqB,CAAC5xF,MAAM,EAAEm1B,KAAK,EAAE,IAAI,CAAC,GAAG,IAAI,CAACu8D,iBAAiB,CAAC1xF,MAAM,EAAEm1B,KAAK,EAAE,IAAI,CAAC;QACnJ;MACF,CAAC,MAAM,IAAI,IAAI,CAACo6D,wBAAwB,CAACh5C,SAAS,CAAC,EAAE;QACnDv2C,MAAM,GAAG,IAAI,CAAC4xF,qBAAqB,CAAC5xF,MAAM,EAAEm1B,KAAK,EAAE,KAAK,CAAC;MAC3D,CAAC,MAAM,IAAI,IAAI,CAACo6D,wBAAwB,CAACt6C,OAAO,CAAC,EAAE;QACjDj1C,MAAM,GAAG,IAAI,CAAC2xF,SAAS,CAAC3xF,MAAM,EAAEm1B,KAAK,EAAE,KAAK,CAAC;MAC/C,CAAC,MAAM,IAAI,IAAI,CAACw6D,uBAAuB,CAAC,GAAG,CAAC,EAAE;QAC5C3vF,MAAM,GAAG,IAAI8+B,aAAa,CAAC,IAAI,CAAC7J,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAEn1B,MAAM,CAAC;MAC9E,CAAC,MAAM,IAAI,IAAI,CAAC+tD,IAAI,CAAC+4B,oBAAoB,CAAC,CAAC,EAAE;QAC3C9mF,MAAM,GAAG,IAAI,CAAC6xF,yCAAyC,CAAC7xF,MAAM,EAAEm1B,KAAK,CAAC;MACxE,CAAC,MAAM,IAAI,IAAI,CAAC44B,IAAI,CAAC64B,qBAAqB,CAAC,CAAC,EAAE;QAC5C5mF,MAAM,GAAG,IAAI,CAAC8xF,0BAA0B,CAAC9xF,MAAM,EAAEm1B,KAAK,CAAC;MACzD,CAAC,MAAM;QACL,OAAOn1B,MAAM;MACf;IACF;EACF;EACAyxF,YAAYA,CAAA,EAAG;IACb,MAAMt8D,KAAK,GAAG,IAAI,CAAC45D,UAAU;IAC7B,IAAI,IAAI,CAACQ,wBAAwB,CAACt6C,OAAO,CAAC,EAAE;MAC1C,IAAI,CAACy5C,eAAe,EAAE;MACtB,MAAM1uF,MAAM,GAAG,IAAI,CAACmwF,SAAS,CAAC,CAAC;MAC/B,IAAI,CAAC,IAAI,CAACZ,wBAAwB,CAACr6C,OAAO,CAAC,EAAE;QAC3C,IAAI,CAACpP,KAAK,CAAC,6BAA6B,CAAC;QACzC,IAAI,CAACypD,wBAAwB,CAACr6C,OAAO,CAAC;MACxC;MACA,IAAI,CAACw5C,eAAe,EAAE;MACtB,OAAO,IAAI/uD,uBAAuB,CAAC,IAAI,CAAC1K,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAEn1B,MAAM,CAAC;IACtF,CAAC,MAAM,IAAI,IAAI,CAAC+tD,IAAI,CAAC+3B,aAAa,CAAC,CAAC,EAAE;MACpC,IAAI,CAAC7jE,OAAO,CAAC,CAAC;MACd,OAAO,IAAIgb,gBAAgB,CAAC,IAAI,CAAChI,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAE,IAAI,CAAC;IAC7E,CAAC,MAAM,IAAI,IAAI,CAAC44B,IAAI,CAACg4B,kBAAkB,CAAC,CAAC,EAAE;MACzC,IAAI,CAAC9jE,OAAO,CAAC,CAAC;MACd,OAAO,IAAIgb,gBAAgB,CAAC,IAAI,CAAChI,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAE,KAAK,CAAC,CAAC;IAC/E,CAAC,MAAM,IAAI,IAAI,CAAC44B,IAAI,CAACi4B,aAAa,CAAC,CAAC,EAAE;MACpC,IAAI,CAAC/jE,OAAO,CAAC,CAAC;MACd,OAAO,IAAIgb,gBAAgB,CAAC,IAAI,CAAChI,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAE,IAAI,CAAC;IAC7E,CAAC,MAAM,IAAI,IAAI,CAAC44B,IAAI,CAACk4B,cAAc,CAAC,CAAC,EAAE;MACrC,IAAI,CAAChkE,OAAO,CAAC,CAAC;MACd,OAAO,IAAIgb,gBAAgB,CAAC,IAAI,CAAChI,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAE,KAAK,CAAC;IAC9E,CAAC,MAAM,IAAI,IAAI,CAAC44B,IAAI,CAACs4B,WAAW,CAAC,CAAC,EAAE;MAClC,IAAI,CAACpkE,OAAO,CAAC,CAAC;MACd,OAAO,IAAIgb,gBAAgB,CAAC,IAAI,CAAChI,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAE,IAAI,CAAC;IAC7E,CAAC,MAAM,IAAI,IAAI,CAAC44B,IAAI,CAACm4B,aAAa,CAAC,CAAC,EAAE;MACpC,IAAI,CAACjkE,OAAO,CAAC,CAAC;MACd,OAAO,IAAI6Z,YAAY,CAAC,IAAI,CAAC7G,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,CAAC;IACnE,CAAC,MAAM,IAAI,IAAI,CAACo6D,wBAAwB,CAACh5C,SAAS,CAAC,EAAE;MACnD,IAAI,CAACo4C,iBAAiB,EAAE;MACxB,MAAMj6E,QAAQ,GAAG,IAAI,CAACq9E,mBAAmB,CAACt7C,SAAS,CAAC;MACpD,IAAI,CAACk4C,iBAAiB,EAAE;MACxB,IAAI,CAACe,eAAe,CAACj5C,SAAS,CAAC;MAC/B,OAAO,IAAItZ,YAAY,CAAC,IAAI,CAAClI,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAEzgB,QAAQ,CAAC;IAC7E,CAAC,MAAM,IAAI,IAAI,CAACq5C,IAAI,CAACk3B,WAAW,CAAC1tC,OAAO,CAAC,EAAE;MACzC,OAAO,IAAI,CAACy6C,eAAe,CAAC,CAAC;IAC/B,CAAC,MAAM,IAAI,IAAI,CAACjkC,IAAI,CAACw3B,YAAY,CAAC,CAAC,EAAE;MACnC,OAAO,IAAI,CAACmM,iBAAiB,CAAC,IAAI91D,gBAAgB,CAAC,IAAI,CAAC3G,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,CAAC,EAAEA,KAAK,EAAE,KAAK,CAAC;IAC7G,CAAC,MAAM,IAAI,IAAI,CAAC44B,IAAI,CAACo3B,QAAQ,CAAC,CAAC,EAAE;MAC/B,MAAMtkF,KAAK,GAAG,IAAI,CAACktD,IAAI,CAAC44B,QAAQ,CAAC,CAAC;MAClC,IAAI,CAAC1kE,OAAO,CAAC,CAAC;MACd,OAAO,IAAIgb,gBAAgB,CAAC,IAAI,CAAChI,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAEt0B,KAAK,CAAC;IAC9E,CAAC,MAAM,IAAI,IAAI,CAACktD,IAAI,CAAC+4B,oBAAoB,CAAC,CAAC,EAAE;MAC3C,OAAO,IAAI,CAACmL,mCAAmC,CAAC,CAAC;IACnD,CAAC,MAAM,IAAI,IAAI,CAAClkC,IAAI,CAAC64B,qBAAqB,CAAC,CAAC,EAAE;MAC5C,OAAO,IAAI,CAACsL,oBAAoB,CAAC,CAAC;IACpC,CAAC,MAAM,IAAI,IAAI,CAACnkC,IAAI,CAACq3B,QAAQ,CAAC,CAAC,IAAI,IAAI,CAACr3B,IAAI,CAAC1T,IAAI,KAAKoqC,eAAe,CAACmF,KAAK,EAAE;MAC3E,MAAMuI,YAAY,GAAG,IAAI,CAACpkC,IAAI,CAAChtD,QAAQ,CAAC,CAAC;MACzC,IAAI,CAACkhB,OAAO,CAAC,CAAC;MACd,OAAO,IAAIgb,gBAAgB,CAAC,IAAI,CAAChI,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAEg9D,YAAY,CAAC;IACrF,CAAC,MAAM,IAAI,IAAI,CAACpkC,IAAI,CAACy3B,mBAAmB,CAAC,CAAC,EAAE;MAC1C,IAAI,CAACyK,gCAAgC,CAAC,IAAI,CAACliC,IAAI,EAAE,IAAI,CAAC;MACtD,OAAO,IAAIryB,WAAW,CAAC,IAAI,CAACzG,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,CAAC;IAClE,CAAC,MAAM,IAAI,IAAI,CAAC44B,IAAI,CAACw4B,YAAY,CAAC,CAAC,EAAE;MACnC,OAAO,IAAI,CAAC6L,6BAA6B,CAAC,CAAC;IAC7C,CAAC,MAAM,IAAI,IAAI,CAAC/nF,KAAK,IAAI,IAAI,CAAC8kE,MAAM,CAACrwE,MAAM,EAAE;MAC3C,IAAI,CAACgnC,KAAK,CAAC,iCAAiC,IAAI,CAAChY,KAAK,EAAE,CAAC;MACzD,OAAO,IAAI4N,WAAW,CAAC,IAAI,CAACzG,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,CAAC;IAClE,CAAC,MAAM;MACL,IAAI,CAAC2Q,KAAK,CAAC,oBAAoB,IAAI,CAACioB,IAAI,EAAE,CAAC;MAC3C,OAAO,IAAIryB,WAAW,CAAC,IAAI,CAACzG,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,CAAC;IAClE;EACF;EACA48D,mBAAmBA,CAACM,UAAU,EAAE;IAC9B,MAAMryF,MAAM,GAAG,EAAE;IACjB,GAAG;MACD,IAAI,CAAC,IAAI,CAAC+tD,IAAI,CAACk3B,WAAW,CAACoN,UAAU,CAAC,EAAE;QACtCryF,MAAM,CAACjB,IAAI,CAAC,IAAI,CAACoxF,SAAS,CAAC,CAAC,CAAC;MAC/B,CAAC,MAAM;QACL;MACF;IACF,CAAC,QAAQ,IAAI,CAACZ,wBAAwB,CAACl6C,MAAM,CAAC;IAC9C,OAAOr1C,MAAM;EACf;EACAgyF,eAAeA,CAAA,EAAG;IAChB,MAAMvqF,IAAI,GAAG,EAAE;IACf,MAAMsV,MAAM,GAAG,EAAE;IACjB,MAAMoY,KAAK,GAAG,IAAI,CAAC45D,UAAU;IAC7B,IAAI,CAACW,eAAe,CAACn4C,OAAO,CAAC;IAC7B,IAAI,CAAC,IAAI,CAACg4C,wBAAwB,CAAC93C,OAAO,CAAC,EAAE;MAC3C,IAAI,CAACm3C,eAAe,EAAE;MACtB,GAAG;QACD,MAAM0D,QAAQ,GAAG,IAAI,CAACvD,UAAU;QAChC,MAAM50E,MAAM,GAAG,IAAI,CAAC4zC,IAAI,CAACq3B,QAAQ,CAAC,CAAC;QACnC,MAAMj2E,GAAG,GAAG,IAAI,CAAC+gF,iCAAiC,CAAC,CAAC;QACpD,MAAMqC,aAAa,GAAG;UACpBpjF,GAAG;UACHgL;QACF,CAAC;QACD1S,IAAI,CAAC1I,IAAI,CAACwzF,aAAa,CAAC;QACxB,IAAIp4E,MAAM,EAAE;UACV,IAAI,CAACu1E,eAAe,CAACj6C,MAAM,CAAC;UAC5B14B,MAAM,CAAChe,IAAI,CAAC,IAAI,CAACoxF,SAAS,CAAC,CAAC,CAAC;QAC/B,CAAC,MAAM,IAAI,IAAI,CAACZ,wBAAwB,CAAC95C,MAAM,CAAC,EAAE;UAChD14B,MAAM,CAAChe,IAAI,CAAC,IAAI,CAACoxF,SAAS,CAAC,CAAC,CAAC;QAC/B,CAAC,MAAM;UACLoC,aAAa,CAACC,sBAAsB,GAAG,IAAI;UAC3C,MAAMv9D,IAAI,GAAG,IAAI,CAACA,IAAI,CAACq9D,QAAQ,CAAC;UAChC,MAAMtjF,UAAU,GAAG,IAAI,CAACA,UAAU,CAACsjF,QAAQ,CAAC;UAC5Cv1E,MAAM,CAAChe,IAAI,CAAC,IAAIu9B,YAAY,CAACrH,IAAI,EAAEjmB,UAAU,EAAEA,UAAU,EAAE,IAAI4sB,gBAAgB,CAAC3G,IAAI,EAAEjmB,UAAU,CAAC,EAAEG,GAAG,CAAC,CAAC;QAC1G;MACF,CAAC,QAAQ,IAAI,CAACogF,wBAAwB,CAACl6C,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC0Y,IAAI,CAACk3B,WAAW,CAACxtC,OAAO,CAAC;MACjF,IAAI,CAACm3C,eAAe,EAAE;MACtB,IAAI,CAACc,eAAe,CAACj4C,OAAO,CAAC;IAC/B;IACA,OAAO,IAAIpa,UAAU,CAAC,IAAI,CAACpI,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAE1tB,IAAI,EAAEsV,MAAM,CAAC;EAC/E;EACA20E,iBAAiBA,CAACe,YAAY,EAAEt9D,KAAK,EAAEu9D,MAAM,EAAE;IAC7C,MAAMza,SAAS,GAAG,IAAI,CAAC8W,UAAU;IACjC,MAAM/oF,EAAE,GAAG,IAAI,CAACqpF,WAAW,CAACf,iBAAiB,CAACqE,QAAQ,EAAE,MAAM;MAC5D,MAAM3sF,EAAE,GAAG,IAAI,CAACgqF,yBAAyB,CAAC,CAAC,IAAI,EAAE;MACjD,IAAIhqF,EAAE,CAAClH,MAAM,KAAK,CAAC,EAAE;QACnB,IAAI,CAACgnC,KAAK,CAAC,yCAAyC,EAAE2sD,YAAY,CAACx9D,IAAI,CAAC9pB,GAAG,CAAC;MAC9E;MACA,OAAOnF,EAAE;IACX,CAAC,CAAC;IACF,MAAMy1B,QAAQ,GAAG,IAAI,CAACzsB,UAAU,CAACipE,SAAS,CAAC;IAC3C,IAAIya,MAAM,EAAE;MACV,IAAI,IAAI,CAAC9C,oBAAoB,CAAC,IAAI,CAAC7hC,IAAI,CAAC,EAAE;QACxC,IAAI,CAAC9rC,OAAO,CAAC,CAAC;QACd,IAAI,CAAC6jB,KAAK,CAAC,oDAAoD,CAAC;QAChE,OAAO,IAAIpK,WAAW,CAAC,IAAI,CAACzG,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,CAAC;MAClE,CAAC,MAAM;QACL,OAAO,IAAIqH,gBAAgB,CAAC,IAAI,CAACvH,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAEsG,QAAQ,EAAEg3D,YAAY,EAAEzsF,EAAE,CAAC;MACnG;IACF,CAAC,MAAM;MACL,IAAI,IAAI,CAAC4pF,oBAAoB,CAAC,IAAI,CAAC7hC,IAAI,CAAC,EAAE;QACxC,MAAMnwB,SAAS,GAAG,IAAI,CAACmwB,IAAI,CAACi3B,QAAQ;QACpC,IAAI,EAAE,IAAI,CAACwJ,UAAU,GAAG,CAAC,CAAC,EAAE;UAC1B,IAAI,CAACvsE,OAAO,CAAC,CAAC;UACd,IAAI,CAAC6jB,KAAK,CAAC,qCAAqC,CAAC;UACjD,OAAO,IAAIpK,WAAW,CAAC,IAAI,CAACzG,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,CAAC;QAClE;QACA,MAAMxhB,QAAQ,GAAG,IAAI2oB,YAAY,CAAC,IAAI,CAACrH,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAEsG,QAAQ,EAAEg3D,YAAY,EAAEzsF,EAAE,CAAC;QACvG,IAAI,CAACic,OAAO,CAAC,CAAC;QACd,MAAMphB,KAAK,GAAG,IAAI,CAAC+vF,gBAAgB,CAAC,CAAC;QACrC,OAAO,IAAIjzD,MAAM,CAAC,IAAI,CAAC1I,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAEyI,SAAS,EAAEjqB,QAAQ,EAAE9S,KAAK,CAAC;MACzF,CAAC,MAAM;QACL,OAAO,IAAIy7B,YAAY,CAAC,IAAI,CAACrH,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAEsG,QAAQ,EAAEg3D,YAAY,EAAEzsF,EAAE,CAAC;MAC/F;IACF;EACF;EACA2rF,SAASA,CAACh+E,QAAQ,EAAEwhB,KAAK,EAAEu9D,MAAM,EAAE;IACjC,MAAME,aAAa,GAAG,IAAI,CAAC7D,UAAU;IACrC,IAAI,CAACL,eAAe,EAAE;IACtB,MAAMh7E,IAAI,GAAG,IAAI,CAACm/E,kBAAkB,CAAC,CAAC;IACtC,MAAM5zD,YAAY,GAAG,IAAI,CAAChK,IAAI,CAAC29D,aAAa,EAAE,IAAI,CAAC7D,UAAU,CAAC,CAAC3zD,UAAU,CAAC,IAAI,CAACC,cAAc,CAAC;IAC9F,IAAI,CAACq0D,eAAe,CAACx6C,OAAO,CAAC;IAC7B,IAAI,CAACw5C,eAAe,EAAE;IACtB,MAAMz5D,IAAI,GAAG,IAAI,CAACA,IAAI,CAACE,KAAK,CAAC;IAC7B,MAAMnmB,UAAU,GAAG,IAAI,CAACA,UAAU,CAACmmB,KAAK,CAAC;IACzC,OAAOu9D,MAAM,GAAG,IAAIvzD,QAAQ,CAAClK,IAAI,EAAEjmB,UAAU,EAAE2E,QAAQ,EAAED,IAAI,EAAEurB,YAAY,CAAC,GAAG,IAAID,IAAI,CAAC/J,IAAI,EAAEjmB,UAAU,EAAE2E,QAAQ,EAAED,IAAI,EAAEurB,YAAY,CAAC;EACzI;EACA4zD,kBAAkBA,CAAA,EAAG;IACnB,IAAI,IAAI,CAAC9kC,IAAI,CAACk3B,WAAW,CAAC/vC,OAAO,CAAC,EAAE,OAAO,EAAE;IAC7C,MAAM49C,WAAW,GAAG,EAAE;IACtB,GAAG;MACDA,WAAW,CAAC/zF,IAAI,CAAC,IAAI,CAACoxF,SAAS,CAAC,CAAC,CAAC;IACpC,CAAC,QAAQ,IAAI,CAACZ,wBAAwB,CAACl6C,MAAM,CAAC;IAC9C,OAAOy9C,WAAW;EACpB;EACAC,wBAAwBA,CAAA,EAAG;IACzB,IAAI/yF,MAAM,GAAG,EAAE;IACf,IAAIgzF,aAAa,GAAG,KAAK;IACzB,MAAM79D,KAAK,GAAG,IAAI,CAAC+5D,qBAAqB;IACxC,GAAG;MACDlvF,MAAM,IAAI,IAAI,CAACkwF,iCAAiC,CAAC,CAAC;MAClD8C,aAAa,GAAG,IAAI,CAACrD,uBAAuB,CAAC,GAAG,CAAC;MACjD,IAAIqD,aAAa,EAAE;QACjBhzF,MAAM,IAAI,GAAG;MACf;IACF,CAAC,QAAQgzF,aAAa;IACtB,OAAO;MACL99D,MAAM,EAAEl1B,MAAM;MACdi1B,IAAI,EAAE,IAAIqG,kBAAkB,CAACnG,KAAK,EAAEA,KAAK,GAAGn1B,MAAM,CAAClB,MAAM;IAC3D,CAAC;EACH;EACAqtF,qBAAqBA,CAACC,WAAW,EAAE;IACjC,MAAM3iD,QAAQ,GAAG,EAAE;IACnBA,QAAQ,CAAC1qC,IAAI,CAAC,GAAG,IAAI,CAACk0F,6BAA6B,CAAC7G,WAAW,CAAC,CAAC;IACjE,OAAO,IAAI,CAAC/hF,KAAK,GAAG,IAAI,CAAC8kE,MAAM,CAACrwE,MAAM,EAAE;MACtC,MAAMo0F,UAAU,GAAG,IAAI,CAACC,eAAe,CAAC,CAAC;MACzC,IAAID,UAAU,EAAE;QACdzpD,QAAQ,CAAC1qC,IAAI,CAACm0F,UAAU,CAAC;MAC3B,CAAC,MAAM;QACL,MAAM/jF,GAAG,GAAG,IAAI,CAAC4jF,wBAAwB,CAAC,CAAC;QAC3C,MAAMK,OAAO,GAAG,IAAI,CAACC,cAAc,CAAClkF,GAAG,CAAC;QACxC,IAAIikF,OAAO,EAAE;UACX3pD,QAAQ,CAAC1qC,IAAI,CAACq0F,OAAO,CAAC;QACxB,CAAC,MAAM;UACLjkF,GAAG,CAAC+lB,MAAM,GAAGk3D,WAAW,CAACl3D,MAAM,GAAG/lB,GAAG,CAAC+lB,MAAM,CAAC90B,MAAM,CAAC,CAAC,CAAC,CAAC4tB,WAAW,CAAC,CAAC,GAAG7e,GAAG,CAAC+lB,MAAM,CAACyjB,SAAS,CAAC,CAAC,CAAC;UAC9FlP,QAAQ,CAAC1qC,IAAI,CAAC,GAAG,IAAI,CAACk0F,6BAA6B,CAAC9jF,GAAG,CAAC,CAAC;QAC3D;MACF;MACA,IAAI,CAACmkF,0BAA0B,CAAC,CAAC;IACnC;IACA,OAAO,IAAIzI,0BAA0B,CAACphD,QAAQ,EAAE,EAAE,EAAE,IAAI,CAACzJ,MAAM,CAAC;EAClE;EACA4xD,qBAAqBA,CAACj+E,QAAQ,EAAEwhB,KAAK,EAAEu9D,MAAM,EAAE;IAC7C,OAAO,IAAI,CAACrD,WAAW,CAACf,iBAAiB,CAACqE,QAAQ,EAAE,MAAM;MACxD,IAAI,CAAChE,iBAAiB,EAAE;MACxB,MAAMx/E,GAAG,GAAG,IAAI,CAACghF,SAAS,CAAC,CAAC;MAC5B,IAAIhhF,GAAG,YAAYusB,WAAW,EAAE;QAC9B,IAAI,CAACoK,KAAK,CAAC,4BAA4B,CAAC;MAC1C;MACA,IAAI,CAAC6oD,iBAAiB,EAAE;MACxB,IAAI,CAACe,eAAe,CAACj5C,SAAS,CAAC;MAC/B,IAAI,IAAI,CAACm5C,oBAAoB,CAAC,IAAI,CAAC7hC,IAAI,CAAC,EAAE;QACxC,MAAMnwB,SAAS,GAAG,IAAI,CAACmwB,IAAI,CAACi3B,QAAQ;QACpC,IAAI0N,MAAM,EAAE;UACV,IAAI,CAACzwE,OAAO,CAAC,CAAC;UACd,IAAI,CAAC6jB,KAAK,CAAC,oDAAoD,CAAC;QAClE,CAAC,MAAM;UACL,MAAMytD,cAAc,GAAG,IAAI72D,SAAS,CAAC,IAAI,CAACzH,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAExhB,QAAQ,EAAExE,GAAG,CAAC;UAC7F,IAAI,CAAC8S,OAAO,CAAC,CAAC;UACd,MAAMphB,KAAK,GAAG,IAAI,CAAC+vF,gBAAgB,CAAC,CAAC;UACrC,OAAO,IAAIjzD,MAAM,CAAC,IAAI,CAAC1I,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAEyI,SAAS,EAAE21D,cAAc,EAAE1yF,KAAK,CAAC;QAC/F;MACF,CAAC,MAAM;QACL,OAAO6xF,MAAM,GAAG,IAAI91D,aAAa,CAAC,IAAI,CAAC3H,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAExhB,QAAQ,EAAExE,GAAG,CAAC,GAAG,IAAIutB,SAAS,CAAC,IAAI,CAACzH,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAExhB,QAAQ,EAAExE,GAAG,CAAC;MACrK;MACA,OAAO,IAAIusB,WAAW,CAAC,IAAI,CAACzG,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,CAAC;IAClE,CAAC,CAAC;EACJ;EACA89D,6BAA6BA,CAAC9jF,GAAG,EAAE;IACjC,MAAMs6B,QAAQ,GAAG,EAAE;IACnB,IAAI,CAAC8lD,wBAAwB,CAAC95C,MAAM,CAAC;IACrC,MAAM50C,KAAK,GAAG,IAAI,CAAC2yF,uBAAuB,CAAC,CAAC;IAC5C,IAAIC,OAAO,GAAG,IAAI,CAACvE,qBAAqB;IACxC,MAAMwE,SAAS,GAAG,IAAI,CAACL,cAAc,CAAClkF,GAAG,CAAC;IAC1C,IAAI,CAACukF,SAAS,EAAE;MACd,IAAI,CAACJ,0BAA0B,CAAC,CAAC;MACjCG,OAAO,GAAG,IAAI,CAACvE,qBAAqB;IACtC;IACA,MAAMlgF,UAAU,GAAG,IAAIssB,kBAAkB,CAACnsB,GAAG,CAAC8lB,IAAI,CAACE,KAAK,EAAEs+D,OAAO,CAAC;IAClEhqD,QAAQ,CAAC1qC,IAAI,CAAC,IAAIohC,iBAAiB,CAACnxB,UAAU,EAAEG,GAAG,EAAEtO,KAAK,CAAC,CAAC;IAC5D,IAAI6yF,SAAS,EAAE;MACbjqD,QAAQ,CAAC1qC,IAAI,CAAC20F,SAAS,CAAC;IAC1B;IACA,OAAOjqD,QAAQ;EACjB;EACA+pD,uBAAuBA,CAAA,EAAG;IACxB,IAAI,IAAI,CAACzlC,IAAI,KAAK45B,GAAG,IAAI,IAAI,CAAC8H,aAAa,CAAC,CAAC,IAAI,IAAI,CAACD,cAAc,CAAC,CAAC,EAAE;MACtE,OAAO,IAAI;IACb;IACA,MAAMvzE,GAAG,GAAG,IAAI,CAACk0E,SAAS,CAAC,CAAC;IAC5B,MAAM;MACJh7D,KAAK;MACLhqB;IACF,CAAC,GAAG8Q,GAAG,CAACgZ,IAAI;IACZ,MAAMp0B,KAAK,GAAG,IAAI,CAACitB,KAAK,CAAC6qB,SAAS,CAACxjB,KAAK,EAAEhqB,GAAG,CAAC;IAC9C,OAAO,IAAI20B,aAAa,CAAC7jB,GAAG,EAAEpb,KAAK,EAAEmqF,WAAW,CAAC,IAAI,CAACI,eAAe,CAAC,EAAE,IAAI,CAAC/vD,cAAc,GAAGlG,KAAK,EAAE,IAAI,CAAC6K,MAAM,CAAC;EACnH;EACAqzD,cAAcA,CAACxyF,KAAK,EAAE;IACpB,IAAI,CAAC,IAAI,CAAC4uF,aAAa,CAAC,CAAC,EAAE;MACzB,OAAO,IAAI;IACb;IACA,IAAI,CAACxtE,OAAO,CAAC,CAAC;IACd,MAAM9S,GAAG,GAAG,IAAI,CAAC4jF,wBAAwB,CAAC,CAAC;IAC3C,IAAI,CAACO,0BAA0B,CAAC,CAAC;IACjC,MAAMtkF,UAAU,GAAG,IAAIssB,kBAAkB,CAACz6B,KAAK,CAACo0B,IAAI,CAACE,KAAK,EAAE,IAAI,CAAC+5D,qBAAqB,CAAC;IACvF,OAAO,IAAIhvD,eAAe,CAAClxB,UAAU,EAAEG,GAAG,EAAEtO,KAAK,CAAC;EACpD;EACAsyF,eAAeA,CAAA,EAAG;IAChB,IAAI,CAAC,IAAI,CAAC3D,cAAc,CAAC,CAAC,EAAE;MAC1B,OAAO,IAAI;IACb;IACA,MAAMmE,SAAS,GAAG,IAAI,CAACzE,qBAAqB;IAC5C,IAAI,CAACjtE,OAAO,CAAC,CAAC;IACd,MAAM9S,GAAG,GAAG,IAAI,CAAC4jF,wBAAwB,CAAC,CAAC;IAC3C,IAAIlyF,KAAK,GAAG,IAAI;IAChB,IAAI,IAAI,CAAC8uF,uBAAuB,CAAC,GAAG,CAAC,EAAE;MACrC9uF,KAAK,GAAG,IAAI,CAACkyF,wBAAwB,CAAC,CAAC;IACzC;IACA,IAAI,CAACO,0BAA0B,CAAC,CAAC;IACjC,MAAMtkF,UAAU,GAAG,IAAIssB,kBAAkB,CAACq4D,SAAS,EAAE,IAAI,CAACzE,qBAAqB,CAAC;IAChF,OAAO,IAAIhvD,eAAe,CAAClxB,UAAU,EAAEG,GAAG,EAAEtO,KAAK,CAAC;EACpD;EACAgxF,yCAAyCA,CAACtyF,GAAG,EAAE41B,KAAK,EAAE;IACpD,MAAMphB,QAAQ,GAAG,IAAI,CAACk+E,mCAAmC,CAAC,CAAC;IAC3D,OAAO,IAAI5yD,qBAAqB,CAAC,IAAI,CAACpK,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAE51B,GAAG,EAAEwU,QAAQ,CAAC;EAC3F;EACAk+E,mCAAmCA,CAAA,EAAG;IACpC,MAAMjrF,IAAI,GAAG,IAAI,CAAC+mD,IAAI,CAACi3B,QAAQ;IAC/B,MAAM7vD,KAAK,GAAG,IAAI,CAAC45D,UAAU;IAC7B,IAAI,CAAC9sE,OAAO,CAAC,CAAC;IACd,MAAMgT,IAAI,GAAG,IAAI,CAACA,IAAI,CAACE,KAAK,CAAC;IAC7B,MAAMnmB,UAAU,GAAG,IAAI,CAACA,UAAU,CAACmmB,KAAK,CAAC;IACzC,OAAO,IAAIoK,eAAe,CAACtK,IAAI,EAAEjmB,UAAU,EAAE,CAAC,IAAIywB,sBAAsB,CAACxK,IAAI,EAAEjmB,UAAU,EAAEhI,IAAI,CAAC,CAAC,EAAE,EAAE,CAAC;EACxG;EACA8qF,0BAA0BA,CAACvyF,GAAG,EAAE41B,KAAK,EAAE;IACrC,MAAMphB,QAAQ,GAAG,IAAI,CAACm+E,oBAAoB,CAAC,CAAC;IAC5C,OAAO,IAAI7yD,qBAAqB,CAAC,IAAI,CAACpK,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAE51B,GAAG,EAAEwU,QAAQ,CAAC;EAC3F;EACAm+E,oBAAoBA,CAAA,EAAG;IACrB,MAAMx9E,QAAQ,GAAG,EAAE;IACnB,MAAMC,WAAW,GAAG,EAAE;IACtB,MAAMwgB,KAAK,GAAG,IAAI,CAAC45D,UAAU;IAC7B,OAAO,IAAI,CAAChhC,IAAI,KAAK45B,GAAG,EAAE;MACxB,MAAMx4D,KAAK,GAAG,IAAI,CAAC4+B,IAAI;MACvB,IAAI5+B,KAAK,CAACy3D,qBAAqB,CAAC,CAAC,IAAIz3D,KAAK,CAAC23D,oBAAoB,CAAC,CAAC,EAAE;QACjE,MAAM8M,SAAS,GAAG,IAAI,CAAC7E,UAAU;QACjC,IAAI,CAAC9sE,OAAO,CAAC,CAAC;QACdvN,QAAQ,CAAC3V,IAAI,CAAC,IAAI0gC,sBAAsB,CAAC,IAAI,CAACxK,IAAI,CAAC2+D,SAAS,CAAC,EAAE,IAAI,CAAC5kF,UAAU,CAAC4kF,SAAS,CAAC,EAAEzkE,KAAK,CAAC61D,QAAQ,CAAC,CAAC;QAC3G,IAAI71D,KAAK,CAAC23D,oBAAoB,CAAC,CAAC,EAAE;UAChC;QACF;MACF,CAAC,MAAM,IAAI33D,KAAK,CAAC63D,mCAAmC,CAAC,CAAC,EAAE;QACtD,IAAI,CAAC/kE,OAAO,CAAC,CAAC;QACd,IAAI,CAAC2sE,eAAe,EAAE;QACtB,MAAMhnF,UAAU,GAAG,IAAI,CAACuoF,SAAS,CAAC,CAAC;QACnC,IAAIvoF,UAAU,YAAY8zB,WAAW,EAAE;UACrC,IAAI,CAACoK,KAAK,CAAC,gDAAgD,CAAC;QAC9D,CAAC,MAAM;UACLnxB,WAAW,CAAC5V,IAAI,CAAC6I,UAAU,CAAC;QAC9B;QACA,IAAI,CAACgnF,eAAe,EAAE;MACxB,CAAC,MAAM;QACL,IAAI,CAAC3sE,OAAO,CAAC,CAAC;MAChB;IACF;IACA,OAAO,IAAIsd,eAAe,CAAC,IAAI,CAACtK,IAAI,CAACE,KAAK,CAAC,EAAE,IAAI,CAACnmB,UAAU,CAACmmB,KAAK,CAAC,EAAEzgB,QAAQ,EAAEC,WAAW,CAAC;EAC7F;EACAy9E,6BAA6BA,CAAA,EAAG;IAC9B,MAAM5H,SAAS,GAAG,IAAI,CAACz8B,IAAI;IAC3B,IAAI,CAAC9rC,OAAO,CAAC,CAAC;IACd,IAAI,CAACuoE,SAAS,CAACjE,YAAY,CAAC,CAAC,EAAE;MAC7B,OAAO,IAAI7qD,WAAW,CAAC,IAAI,CAACzG,IAAI,CAAC,IAAI,CAAC85D,UAAU,CAAC,EAAE,IAAI,CAAC//E,UAAU,CAAC,IAAI,CAAC+/E,UAAU,CAAC,CAAC;IACtF;IACA,IAAItE,UAAU,GAAG,IAAI;IACrB,IAAI,IAAI,CAAC18B,IAAI,CAAC04B,aAAa,CAAC,CAAC,EAAE;MAC7BgE,UAAU,GAAG,IAAI,CAAC18B,IAAI;MACtB,IAAI,CAAC9rC,OAAO,CAAC,CAAC;MACd,MAAM4xE,SAAS,GAAG,IAAIzzC,GAAG,CAAC,CAAC;MAC3B,KAAK,IAAIlgD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuqF,UAAU,CAACzF,QAAQ,CAAClmF,MAAM,EAAEoB,CAAC,EAAE,EAAE;QACnD,MAAMC,IAAI,GAAGsqF,UAAU,CAACzF,QAAQ,CAAC9kF,CAAC,CAAC;QACnC,IAAI,CAACquF,qBAAqB,CAACtqF,GAAG,CAAC9D,IAAI,CAAC,EAAE;UACpC,IAAI,CAAC2lC,KAAK,CAAC,wCAAwC3lC,IAAI,8BAA8B,GAAGkY,KAAK,CAACmZ,IAAI,CAAC+8D,qBAAqB,EAAExkF,CAAC,IAAI,IAAIA,CAAC,GAAG,CAAC,CAACrJ,IAAI,CAAC,IAAI,CAAC,EAAE+pF,UAAU,CAACpgF,KAAK,GAAGnK,CAAC,CAAC;QAC5K,CAAC,MAAM,IAAI2zF,SAAS,CAAC5vF,GAAG,CAAC9D,IAAI,CAAC,EAAE;UAC9B,IAAI,CAAC2lC,KAAK,CAAC,sCAAsC3lC,IAAI,GAAG,EAAEsqF,UAAU,CAACpgF,KAAK,GAAGnK,CAAC,CAAC;QACjF,CAAC,MAAM;UACL2zF,SAAS,CAAC1xC,GAAG,CAAChiD,IAAI,CAAC;QACrB;MACF;IACF;IACA,MAAMg1B,KAAK,GAAGq1D,SAAS,CAACngF,KAAK;IAC7B,MAAMc,GAAG,GAAGs/E,UAAU,GAAGA,UAAU,CAACt/E,GAAG,GAAGq/E,SAAS,CAACr/E,GAAG;IACvD,OAAO,IAAI00B,wBAAwB,CAAC,IAAI,CAAC5K,IAAI,CAACE,KAAK,EAAEhqB,GAAG,CAAC,EAAE,IAAI,CAAC6D,UAAU,CAACmmB,KAAK,EAAEhqB,GAAG,CAAC,EAAEq/E,SAAS,CAACxF,QAAQ,EAAEyF,UAAU,GAAGA,UAAU,CAACzF,QAAQ,GAAG,IAAI,CAAC;EACtJ;EACAsO,0BAA0BA,CAAA,EAAG;IAC3B,IAAI,CAAC/D,wBAAwB,CAAC75C,UAAU,CAAC,IAAI,IAAI,CAAC65C,wBAAwB,CAACl6C,MAAM,CAAC;EACpF;EACAvP,KAAKA,CAAC//B,OAAO,EAAEsE,KAAK,GAAG,IAAI,CAACA,KAAK,EAAE;IACjC,IAAI,CAAC21B,MAAM,CAACjhC,IAAI,CAACmtF,aAAa,CAACnmF,OAAO,EAAE,IAAI,CAAC+nB,KAAK,EAAE,IAAI,CAACgmE,oBAAoB,CAACzpF,KAAK,CAAC,EAAE,IAAI,CAAC+gF,eAAe,CAAC,CAAC;IAC5G,IAAI,CAAC2I,IAAI,CAAC,CAAC;EACb;EACAD,oBAAoBA,CAACzpF,KAAK,EAAE;IAC1B,OAAOA,KAAK,GAAG,IAAI,CAAC8kE,MAAM,CAACrwE,MAAM,GAAG,aAAa,IAAI,CAACqwE,MAAM,CAAC9kE,KAAK,CAAC,CAACA,KAAK,GAAG,CAAC,KAAK,GAAG,8BAA8B;EACrH;EACA4lF,gCAAgCA,CAAC9gE,KAAK,EAAE6kE,YAAY,EAAE;IACpD,IAAIC,YAAY,GAAG,yEAAyE9kE,KAAK,EAAE;IACnG,IAAI6kE,YAAY,KAAK,IAAI,EAAE;MACzBC,YAAY,IAAI,KAAKD,YAAY,EAAE;IACrC;IACA,IAAI,CAACluD,KAAK,CAACmuD,YAAY,CAAC;EAC1B;EACAF,IAAIA,CAAA,EAAG;IACL,IAAIzoD,CAAC,GAAG,IAAI,CAACyiB,IAAI;IACjB,OAAO,IAAI,CAAC1jD,KAAK,GAAG,IAAI,CAAC8kE,MAAM,CAACrwE,MAAM,IAAI,CAACwsC,CAAC,CAAC25C,WAAW,CAACvvC,UAAU,CAAC,IAAI,CAACpK,CAAC,CAAC+5C,UAAU,CAAC,GAAG,CAAC,KAAK,IAAI,CAACqJ,eAAe,IAAI,CAAC,IAAI,CAACpjD,CAAC,CAAC25C,WAAW,CAAC/vC,OAAO,CAAC,CAAC,KAAK,IAAI,CAAC05C,eAAe,IAAI,CAAC,IAAI,CAACtjD,CAAC,CAAC25C,WAAW,CAACxtC,OAAO,CAAC,CAAC,KAAK,IAAI,CAACk3C,iBAAiB,IAAI,CAAC,IAAI,CAACrjD,CAAC,CAAC25C,WAAW,CAACxuC,SAAS,CAAC,CAAC,KAAK,EAAE,IAAI,CAACxvC,OAAO,GAAGqnF,iBAAiB,CAACqE,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC/C,oBAAoB,CAACtkD,CAAC,CAAC,CAAC,EAAE;MAC/V,IAAI,IAAI,CAACyiB,IAAI,CAACu4B,OAAO,CAAC,CAAC,EAAE;QACvB,IAAI,CAACtmD,MAAM,CAACjhC,IAAI,CAACmtF,aAAa,CAAC,IAAI,CAACn+B,IAAI,CAAChtD,QAAQ,CAAC,CAAC,EAAE,IAAI,CAAC+sB,KAAK,EAAE,IAAI,CAACgmE,oBAAoB,CAAC,IAAI,CAAC/lC,IAAI,CAAC1jD,KAAK,CAAC,EAAE,IAAI,CAAC+gF,eAAe,CAAC,CAAC;MACrI;MACA,IAAI,CAACnpE,OAAO,CAAC,CAAC;MACdqpB,CAAC,GAAG,IAAI,CAACyiB,IAAI;IACf;EACF;AACF;AACA,SAASm+B,aAAaA,CAACnmF,OAAO,EAAE+nB,KAAK,EAAEomE,YAAY,EAAE9I,eAAe,EAAE;EACpE,IAAI8I,YAAY,CAACp1F,MAAM,GAAG,CAAC,EAAE;IAC3Bo1F,YAAY,GAAG,IAAIA,YAAY,GAAG;EACpC;EACA,MAAMn0D,QAAQ,GAAGirD,WAAW,CAACI,eAAe,CAAC;EAC7C,MAAMtlD,KAAK,GAAG,iBAAiB//B,OAAO,GAAGmuF,YAAY,IAAIpmE,KAAK,QAAQiS,QAAQ,EAAE;EAChF,OAAO,IAAI6Z,UAAU,CAACwxC,eAAe,EAAEtlD,KAAK,CAAC;AAC/C;AACA,MAAMimD,uBAAuB,SAAS/vE,mBAAmB,CAAC;EACxDgkB,MAAM,GAAG,EAAE;EACXhD,SAASA,CAAA,EAAG;IACV,IAAI,CAACgD,MAAM,CAACjhC,IAAI,CAAC,OAAO,CAAC;EAC3B;AACF;AACA,SAASkuF,8BAA8BA,CAACT,kBAAkB,EAAE;EAC1D,IAAI2H,SAAS,GAAG,IAAI3yF,GAAG,CAAC,CAAC;EACzB,IAAI4yF,0BAA0B,GAAG,CAAC;EAClC,IAAIC,eAAe,GAAG,CAAC;EACvB,IAAIC,UAAU,GAAG,CAAC;EAClB,OAAOA,UAAU,GAAG9H,kBAAkB,CAAC1tF,MAAM,EAAE;IAC7C,MAAMy1F,YAAY,GAAG/H,kBAAkB,CAAC8H,UAAU,CAAC;IACnD,IAAIC,YAAY,CAAC1sF,IAAI,KAAK,CAAC,EAAE;MAC3B,MAAM,CAAC2sF,OAAO,EAAEzlE,OAAO,CAAC,GAAGwlE,YAAY,CAAC7tF,KAAK;MAC7C0tF,0BAA0B,IAAIrlE,OAAO,CAACjwB,MAAM;MAC5Cu1F,eAAe,IAAIG,OAAO,CAAC11F,MAAM;IACnC,CAAC,MAAM;MACL,MAAM21F,aAAa,GAAGF,YAAY,CAAC7tF,KAAK,CAACuD,MAAM,CAAC,CAACyqF,GAAG,EAAEx1F,OAAO,KAAKw1F,GAAG,GAAGx1F,OAAO,CAACJ,MAAM,EAAE,CAAC,CAAC;MAC1Fu1F,eAAe,IAAII,aAAa;MAChCL,0BAA0B,IAAIK,aAAa;IAC7C;IACAN,SAAS,CAACrxF,GAAG,CAACuxF,eAAe,EAAED,0BAA0B,CAAC;IAC1DE,UAAU,EAAE;EACd;EACA,OAAOH,SAAS;AAClB;AAEA,SAASrlD,SAASA,CAAClnC,UAAU,EAAE;EAC7B,OAAOA,UAAU,CAAChB,KAAK,CAAC,IAAI+tF,0BAA0B,CAAC,CAAC,CAAC;AAC3D;AACA,MAAMA,0BAA0B,CAAC;EAC/Bp2D,UAAUA,CAACtiB,GAAG,EAAEhV,OAAO,EAAE;IACvB,OAAO,GAAGgV,GAAG,CAACvD,QAAQ,GAAGuD,GAAG,CAAC/I,IAAI,CAACtM,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,EAAE;EAC1D;EACA82B,WAAWA,CAAC9hB,GAAG,EAAEhV,OAAO,EAAE;IACxB,OAAO,GAAGgV,GAAG,CAAC4hB,IAAI,CAACj3B,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,IAAIgV,GAAG,CAAC2hB,SAAS,IAAI3hB,GAAG,CAAC6hB,KAAK,CAACl3B,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,EAAE;EAC9F;EACAg1B,UAAUA,CAAChgB,GAAG,EAAEhV,OAAO,EAAE;IACvB,OAAOgV,GAAG,CAACtH,WAAW,CAAC1R,GAAG,CAACoG,CAAC,IAAIA,CAAC,CAACzC,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,CAAC,CAACvG,IAAI,CAAC,IAAI,CAAC;EACpE;EACA27B,gBAAgBA,CAACpgB,GAAG,EAAEhV,OAAO,EAAE;IAC7B,OAAO,GAAGgV,GAAG,CAAC7E,SAAS,CAACxQ,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,MAAMgV,GAAG,CAACkgB,OAAO,CAACv1B,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,MAAMgV,GAAG,CAACmgB,QAAQ,CAACx1B,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,EAAE;EAC7H;EACA80B,iBAAiBA,CAAA,EAAG;IAClB,OAAO,MAAM;EACf;EACAF,qBAAqBA,CAAA,EAAG;IACtB,OAAO,EAAE;EACX;EACA6B,kBAAkBA,CAACzhB,GAAG,EAAEhV,OAAO,EAAE;IAC/B,OAAO2tF,UAAU,CAAC34E,GAAG,CAACwhB,OAAO,EAAExhB,GAAG,CAACtH,WAAW,CAAC1R,GAAG,CAACoG,CAAC,IAAIA,CAAC,CAACzC,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,CAAC,CAAC,CAACvG,IAAI,CAAC,EAAE,CAAC;EAC3F;EACAi8B,cAAcA,CAAC1gB,GAAG,EAAEhV,OAAO,EAAE;IAC3B,OAAO,GAAGgV,GAAG,CAACtI,QAAQ,CAAC/M,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,IAAIgV,GAAG,CAAC9M,GAAG,CAACvI,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,GAAG;EAChF;EACAm2B,iBAAiBA,CAACnhB,GAAG,EAAEhV,OAAO,EAAE;IAC9B,OAAO,IAAIgV,GAAG,CAACtH,WAAW,CAAC1R,GAAG,CAACoG,CAAC,IAAIA,CAAC,CAACzC,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,CAAC,CAACvG,IAAI,CAAC,IAAI,CAAC,GAAG;EAC3E;EACA48B,eAAeA,CAACrhB,GAAG,EAAEhV,OAAO,EAAE;IAC5B,OAAO,IAAI4tF,GAAG,CAAC54E,GAAG,CAACxU,IAAI,CAACxE,GAAG,CAACua,OAAO,IAAIA,OAAO,CAACrD,MAAM,GAAG,IAAIqD,OAAO,CAACrO,GAAG,GAAG,GAAGqO,OAAO,CAACrO,GAAG,CAAC,EAAE8M,GAAG,CAACc,MAAM,CAAC9Z,GAAG,CAACpC,KAAK,IAAIA,KAAK,CAAC+F,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,CAAC,CAAC,CAAChE,GAAG,CAAC,CAAC,CAACkM,GAAG,EAAEtO,KAAK,CAAC,KAAK,GAAGsO,GAAG,KAAKtO,KAAK,EAAE,CAAC,CAACH,IAAI,CAAC,IAAI,CAAC,GAAG;EACzM;EACAw8B,qBAAqBA,CAACjhB,GAAG,EAAE;IACzB,IAAIA,GAAG,CAACpb,KAAK,KAAK,IAAI,EAAE,OAAO,MAAM;IACrC,QAAQ,OAAOob,GAAG,CAACpb,KAAK;MACtB,KAAK,QAAQ;MACb,KAAK,SAAS;QACZ,OAAOob,GAAG,CAACpb,KAAK,CAACE,QAAQ,CAAC,CAAC;MAC7B,KAAK,WAAW;QACd,OAAO,WAAW;MACpB,KAAK,QAAQ;QACX,OAAO,IAAIkb,GAAG,CAACpb,KAAK,CAACP,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,GAAG;MAC9C;QACE,MAAM,IAAIhB,KAAK,CAAC,+BAA+B2c,GAAG,CAACpb,KAAK,EAAE,CAAC;IAC/D;EACF;EACAm8B,SAASA,CAAC/gB,GAAG,EAAEhV,OAAO,EAAE;IACtB,OAAO,GAAGgV,GAAG,CAAC2B,GAAG,CAAChX,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,MAAMgV,GAAG,CAACrb,IAAI,EAAE;EACxD;EACA69B,cAAcA,CAACxiB,GAAG,EAAEhV,OAAO,EAAE;IAC3B,OAAO,IAAIgV,GAAG,CAACrU,UAAU,CAAChB,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,EAAE;EAClD;EACA83B,kBAAkBA,CAAC9iB,GAAG,EAAEhV,OAAO,EAAE;IAC/B,OAAO,GAAGgV,GAAG,CAACrU,UAAU,CAAChB,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,GAAG;EAClD;EACAs1B,iBAAiBA,CAACtgB,GAAG,EAAEhV,OAAO,EAAE;IAC9B,IAAIgV,GAAG,CAACtI,QAAQ,YAAYioB,gBAAgB,EAAE;MAC5C,OAAO3f,GAAG,CAACrb,IAAI;IACjB,CAAC,MAAM;MACL,OAAO,GAAGqb,GAAG,CAACtI,QAAQ,CAAC/M,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,IAAIgV,GAAG,CAACrb,IAAI,EAAE;IAC3D;EACF;EACA67B,qBAAqBA,CAACxgB,GAAG,EAAEhV,OAAO,EAAE;IAClC,OAAO,GAAGgV,GAAG,CAACtI,QAAQ,CAAC/M,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,KAAKgV,GAAG,CAACrb,IAAI,EAAE;EAC5D;EACAi8B,kBAAkBA,CAAC5gB,GAAG,EAAEhV,OAAO,EAAE;IAC/B,OAAO,GAAGgV,GAAG,CAACtI,QAAQ,CAAC/M,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,MAAMgV,GAAG,CAAC9M,GAAG,CAACvI,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,GAAG;EAClF;EACAi4B,SAASA,CAACjjB,GAAG,EAAEhV,OAAO,EAAE;IACtB,OAAO,GAAGgV,GAAG,CAACtI,QAAQ,CAAC/M,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,IAAIgV,GAAG,CAACvI,IAAI,CAACzQ,GAAG,CAACoG,CAAC,IAAIA,CAAC,CAACzC,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,CAAC,CAACvG,IAAI,CAAC,IAAI,CAAC,GAAG;EACxG;EACA0+B,aAAaA,CAACnjB,GAAG,EAAEhV,OAAO,EAAE;IAC1B,OAAO,GAAGgV,GAAG,CAACtI,QAAQ,CAAC/M,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,MAAMgV,GAAG,CAACvI,IAAI,CAACzQ,GAAG,CAACoG,CAAC,IAAIA,CAAC,CAACzC,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,CAAC,CAACvG,IAAI,CAAC,IAAI,CAAC,GAAG;EAC1G;EACAi+B,qBAAqBA,CAAC1iB,GAAG,EAAEhV,OAAO,EAAE;IAClC,OAAO,UAAUgV,GAAG,CAACrU,UAAU,CAAChB,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,EAAE;EACxD;EACA43B,mBAAmBA,CAAC5iB,GAAG,EAAEhV,OAAO,EAAE;IAChC,OAAO,QAAQgV,GAAG,CAACrU,UAAU,CAAChB,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,EAAE;EACtD;EACAqN,6BAA6BA,CAAC2H,GAAG,EAAEhV,OAAO,EAAE;IAC1C,OAAO,IAAIgV,GAAG,CAAC7H,IAAI,IAAI6H,GAAG,CAAC5H,KAAK,IAAI,EAAE,EAAE;EAC1C;EACA4rB,kBAAkBA,CAAChkB,GAAG,EAAEhV,OAAO,EAAE;IAC/B,OAAOgV,GAAG,CAACA,GAAG,CAACrV,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC;EACrC;EACAu4B,oBAAoBA,CAACvjB,GAAG,EAAEhV,OAAO,EAAE;IACjC,IAAIjH,MAAM,GAAG,EAAE;IACf,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+b,GAAG,CAACvH,QAAQ,CAAC5V,MAAM,EAAEoB,CAAC,EAAE,EAAE;MAC5CF,MAAM,IAAIic,GAAG,CAACvH,QAAQ,CAACxU,CAAC,CAAC,CAAC0G,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC;MAC9C,MAAMW,UAAU,GAAG1H,CAAC,GAAG+b,GAAG,CAACtH,WAAW,CAAC7V,MAAM,GAAGmd,GAAG,CAACtH,WAAW,CAACzU,CAAC,CAAC,GAAG,IAAI;MACzE,IAAI0H,UAAU,KAAK,IAAI,EAAE;QACvB5H,MAAM,IAAI,IAAI,GAAG4H,UAAU,CAAChB,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,GAAG,GAAG;MACxD;IACF;IACA,OAAO,GAAG,GAAGjH,MAAM,GAAG,GAAG;EAC3B;EACA0/B,2BAA2BA,CAACzjB,GAAG,EAAEhV,OAAO,EAAE;IACxC,OAAOgV,GAAG,CAACjV,IAAI;EACjB;EACAs4B,0BAA0BA,CAACrjB,GAAG,EAAEhV,OAAO,EAAE;IACvC,OAAOgV,GAAG,CAAC1c,GAAG,CAACqH,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,GAAGgV,GAAG,CAAClI,QAAQ,CAACnN,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC;EACzE;EACA24B,4BAA4BA,CAAC3jB,GAAG,EAAEhV,OAAO,EAAE;IACzC,OAAO,GAAG,GAAGgV,GAAG,CAACrU,UAAU,CAAChB,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,GAAG,GAAG;EACxD;AACF;AACA,SAAS4tF,GAAGA,CAACh3D,IAAI,EAAEC,KAAK,EAAE;EACxB,IAAID,IAAI,CAAC/+B,MAAM,KAAKg/B,KAAK,CAACh/B,MAAM,EAAE,MAAM,IAAIQ,KAAK,CAAC,0BAA0B,CAAC;EAC7E,OAAOu+B,IAAI,CAAC56B,GAAG,CAAC,CAACqxB,CAAC,EAAEp0B,CAAC,KAAK,CAACo0B,CAAC,EAAEwJ,KAAK,CAAC59B,CAAC,CAAC,CAAC,CAAC;AAC1C;AACA,SAAS00F,UAAUA,CAAC/2D,IAAI,EAAEC,KAAK,EAAE;EAC/B,MAAM99B,MAAM,GAAG,EAAE;EACjB,KAAK,IAAIqK,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGu6D,IAAI,CAACkwB,GAAG,CAACj3D,IAAI,CAAC/+B,MAAM,EAAEg/B,KAAK,CAACh/B,MAAM,CAAC,EAAEuL,KAAK,EAAE,EAAE;IACxE,IAAIA,KAAK,GAAGwzB,IAAI,CAAC/+B,MAAM,EAAEkB,MAAM,CAACjB,IAAI,CAAC8+B,IAAI,CAACxzB,KAAK,CAAC,CAAC;IACjD,IAAIA,KAAK,GAAGyzB,KAAK,CAACh/B,MAAM,EAAEkB,MAAM,CAACjB,IAAI,CAAC++B,KAAK,CAACzzB,KAAK,CAAC,CAAC;EACrD;EACA,OAAOrK,MAAM;AACf;AAEA,IAAI+0F,gBAAgB;AACpB,SAASC,eAAeA,CAAA,EAAG;EACzB,IAAI,CAACD,gBAAgB,EAAE;IACrBA,gBAAgB,GAAG,CAAC,CAAC;IACrBE,eAAe,CAACtwF,eAAe,CAAC81D,IAAI,EAAE,CAAC,eAAe,EAAE,aAAa,EAAE,aAAa,CAAC,CAAC;IACtFw6B,eAAe,CAACtwF,eAAe,CAAC+9D,KAAK,EAAE,CAAC,SAAS,CAAC,CAAC;IACnDuyB,eAAe,CAACtwF,eAAe,CAACuwF,GAAG,EAAE,CAAC,cAAc,EAAE,WAAW,EAAE,WAAW,EAAE,WAAW,EAAE,QAAQ,EAAE,QAAQ,EAAE,iBAAiB,EAAE,iBAAiB,EAAE,UAAU,EAAE,aAAa,EAAE,SAAS,EAAE,WAAW,EAAE,UAAU,EAAE,QAAQ,EAAE,YAAY,EAAE,WAAW,EAAE,cAAc,EAAE,WAAW,CAAC,CAAC;IACxRD,eAAe,CAACtwF,eAAe,CAACwwF,YAAY,EAAE,CAAC,aAAa,EAAE,iBAAiB,EAAE,WAAW,EAAE,WAAW,EAAE,WAAW,EAAE,cAAc,EAAE,eAAe,EAAE,YAAY,EAAE,WAAW,EAAE,WAAW,EAAE,iBAAiB,EAAE,aAAa,EAAE,YAAY,CAAC,CAAC;EACnP;EACA,OAAOJ,gBAAgB;AACzB;AACA,SAASE,eAAeA,CAACl/D,GAAG,EAAEq/D,KAAK,EAAE;EACnC,KAAK,MAAMC,IAAI,IAAID,KAAK,EAAEL,gBAAgB,CAACM,IAAI,CAACv0F,WAAW,CAAC,CAAC,CAAC,GAAGi1B,GAAG;AACtE;AACA,MAAMu/D,+BAA+B,GAAG,IAAIl1C,GAAG,CAAC,CAAC,SAAS,EAAE,OAAO,EAAE,iBAAiB,EAAE,gBAAgB,EAAE,KAAK,EAAE,eAAe,CAAC,CAAC;AAClI,SAASm1C,6BAA6BA,CAACruC,QAAQ,EAAE;EAC/C,OAAOouC,+BAA+B,CAACrxF,GAAG,CAACijD,QAAQ,CAACpmD,WAAW,CAAC,CAAC,CAAC;AACpE;AAEA,MAAM00F,qBAAqB,CAAC;AAE5B,MAAMC,OAAO,GAAG,SAAS;AACzB,MAAMC,MAAM,GAAG,QAAQ;AACvB,MAAMC,MAAM,GAAG,QAAQ;AACvB,MAAMC,MAAM,GAAG,QAAQ;AACvB,MAAMC,MAAM,GAAG,CAAC,i/BAAi/B,GAAG,kKAAkK,EAAE,uvCAAuvC,EAAE,q7CAAq7C,EAAE,+OAA+O,EAAE,ykCAAykC,EAAE,sBAAsB,EAAE,0CAA0C,EAAE,sBAAsB,EAAE,uCAAuC,EAAE,sBAAsB,EAAE,iCAAiC,EAAE,wCAAwC,EAAE,2LAA2L,EAAE,sKAAsK,EAAE,cAAc,EAAE,wBAAwB,EAAE,gCAAgC,EAAE,uSAAuS,EAAE,6GAA6G,EAAE,qCAAqC,EAAE,8BAA8B,EAAE,2BAA2B,EAAE,0BAA0B,EAAE,yBAAyB,EAAE,6BAA6B,EAAE,wCAAwC,EAAE,4BAA4B,EAAE,yBAAyB,EAAE,sDAAsD,EAAE,uCAAuC,EAAE,oCAAoC,EAAE,sGAAsG,EAAE,gGAAgG,EAAE,4QAA4Q,EAAE,kDAAkD,EAAE,qBAAqB,EAAE,uCAAuC,EAAE,4BAA4B,EAAE,iMAAiM,EAAE,oKAAoK,EAAE,6ZAA6Z,EAAE,8BAA8B,EAAE,6BAA6B,EAAE,4BAA4B,EAAE,8JAA8J,EAAE,wBAAwB,EAAE,2HAA2H,EAAE,6BAA6B,EAAE,wDAAwD,EAAE,0DAA0D,EAAE,qCAAqC,EAAE,iDAAiD,EAAE,sIAAsI,EAAE,wCAAwC,EAAE,4EAA4E,EAAE,uDAAuD,EAAE,uBAAuB,EAAE,+CAA+C,EAAE,wBAAwB,EAAE,0BAA0B,EAAE,oCAAoC,EAAE,kCAAkC,EAAE,yHAAyH,EAAE,yGAAyG,EAAE,gCAAgC,EAAE,yBAAyB,EAAE,iEAAiE,EAAE,qBAAqB,EAAE,0CAA0C,EAAE,uBAAuB,EAAE,6BAA6B,EAAE,kHAAkH,EAAE,8DAA8D,EAAE,mHAAmH,EAAE,gDAAgD,EAAE,uDAAuD,EAAE,yBAAyB,EAAE,uMAAuM,EAAE,6BAA6B,EAAE,0BAA0B,EAAE,qDAAqD,EAAE,gCAAgC,EAAE,wBAAwB,EAAE,uHAAuH,EAAE,uBAAuB,EAAE,8BAA8B,EAAE,oCAAoC,EAAE,uCAAuC,EAAE,4BAA4B,EAAE,8BAA8B,EAAE,0BAA0B,EAAE,kBAAkB,EAAE,qBAAqB,EAAE,6BAA6B,EAAE,qBAAqB,EAAE,2BAA2B,EAAE,iCAAiC,EAAE,yBAAyB,EAAE,8BAA8B,EAAE,+BAA+B,EAAE,+BAA+B,EAAE,4BAA4B,EAAE,0BAA0B,EAAE,qBAAqB,EAAE,8CAA8C,EAAE,8CAA8C,EAAE,8CAA8C,EAAE,8CAA8C,EAAE,4BAA4B,EAAE,qBAAqB,EAAE,qBAAqB,EAAE,yBAAyB,EAAE,0BAA0B,EAAE,sBAAsB,EAAE,0BAA0B,EAAE,gCAAgC,EAAE,yBAAyB,EAAE,oBAAoB,EAAE,0BAA0B,EAAE,oBAAoB,EAAE,mCAAmC,EAAE,uBAAuB,EAAE,mCAAmC,EAAE,0BAA0B,EAAE,oCAAoC,EAAE,mBAAmB,EAAE,oBAAoB,EAAE,kBAAkB,EAAE,sBAAsB,EAAE,0BAA0B,EAAE,qBAAqB,EAAE,6BAA6B,EAAE,8BAA8B,EAAE,oCAAoC,EAAE,0BAA0B,EAAE,kDAAkD,EAAE,wBAAwB,EAAE,0BAA0B,EAAE,kBAAkB,EAAE,6CAA6C,EAAE,4BAA4B,EAAE,oBAAoB,EAAE,kCAAkC,EAAE,iCAAiC,EAAE,iCAAiC,EAAE,mBAAmB,EAAE,yBAAyB,EAAE,6BAA6B,EAAE,0BAA0B,EAAE,uEAAuE,EAAE,+EAA+E,EAAE,wBAAwB,EAAE,6BAA6B,EAAE,oBAAoB,EAAE,6rCAA6rC,EAAE,oBAAoB,EAAE,uBAAuB,EAAE,wBAAwB,EAAE,sBAAsB,EAAE,uBAAuB,EAAE,qBAAqB,EAAE,kBAAkB,EAAE,6BAA6B,EAAE,kBAAkB,EAAE,kBAAkB,EAAE,qBAAqB,EAAE,uBAAuB,EAAE,wBAAwB,EAAE,qBAAqB,EAAE,oBAAoB,EAAE,kBAAkB,EAAE,sBAAsB,EAAE,qBAAqB,EAAE,sBAAsB,EAAE,oBAAoB,EAAE,uBAAuB,EAAE,oBAAoB,EAAE,sBAAsB,EAAE,mBAAmB,EAAE,qBAAqB,EAAE,mBAAmB,EAAE,sBAAsB,EAAE,0BAA0B,EAAE,yBAAyB,CAAC;AACx+c,MAAMC,aAAa,GAAG,IAAIt0F,GAAG,CAAC8D,MAAM,CAACyU,OAAO,CAAC;EAC3C,OAAO,EAAE,WAAW;EACpB,KAAK,EAAE,SAAS;EAChB,YAAY,EAAE,YAAY;EAC1B,WAAW,EAAE,WAAW;EACxB,UAAU,EAAE,UAAU;EACtB,UAAU,EAAE,UAAU;EACtB,uBAAuB,EAAE,6BAA6B;EACtD,aAAa,EAAE,YAAY;EAC3B,mBAAmB,EAAE,kBAAkB;EACvC,WAAW,EAAE,UAAU;EACvB,cAAc,EAAE,aAAa;EAC7B,eAAe,EAAE,cAAc;EAC/B,eAAe,EAAE,cAAc;EAC/B,mBAAmB,EAAE,kBAAkB;EACvC,cAAc,EAAE,aAAa;EAC7B,eAAe,EAAE,sBAAsB;EACvC,cAAc,EAAE,aAAa;EAC7B,kBAAkB,EAAE,yBAAyB;EAC7C,kBAAkB,EAAE,iBAAiB;EACrC,cAAc,EAAE,qBAAqB;EACrC,eAAe,EAAE,cAAc;EAC/B,mBAAmB,EAAE,0BAA0B;EAC/C,eAAe,EAAE,cAAc;EAC/B,aAAa,EAAE,oBAAoB;EACnC,eAAe,EAAE,cAAc;EAC/B,aAAa,EAAE,YAAY;EAC3B,cAAc,EAAE,aAAa;EAC7B,mBAAmB,EAAE,kBAAkB;EACvC,YAAY,EAAE,WAAW;EACzB,iBAAiB,EAAE,wBAAwB;EAC3C,YAAY,EAAE,WAAW;EACzB,WAAW,EAAE,UAAU;EACvB,YAAY,EAAE,WAAW;EACzB,gBAAgB,EAAE,eAAe;EACjC,sBAAsB,EAAE,qBAAqB;EAC7C,kBAAkB,EAAE,iBAAiB;EACrC,WAAW,EAAE,kBAAkB;EAC/B,kBAAkB,EAAE,iBAAiB;EACrC,eAAe,EAAE,cAAc;EAC/B,cAAc,EAAE,aAAa;EAC7B,eAAe,EAAE,cAAc;EAC/B,eAAe,EAAE,cAAc;EAC/B,sBAAsB,EAAE,qBAAqB;EAC7C,eAAe,EAAE,cAAc;EAC/B,eAAe,EAAE,cAAc;EAC/B,mBAAmB,EAAE,kBAAkB;EACvC,cAAc,EAAE,aAAa;EAC7B,eAAe,EAAE,cAAc;EAC/B,cAAc,EAAE,aAAa;EAC7B,WAAW,EAAE,UAAU;EACvB,eAAe,EAAE,cAAc;EAC/B,eAAe,EAAE,cAAc;EAC/B,eAAe,EAAE,cAAc;EAC/B,gBAAgB,EAAE;AACpB,CAAC,CAAC,CAAC;AACH,MAAMg8E,aAAa,GAAG19E,KAAK,CAACmZ,IAAI,CAACskE,aAAa,CAAC,CAAC7rF,MAAM,CAAC,CAAC+rF,QAAQ,EAAE,CAACC,YAAY,EAAEC,aAAa,CAAC,KAAK;EAClGF,QAAQ,CAAClzF,GAAG,CAACmzF,YAAY,EAAEC,aAAa,CAAC;EACzC,OAAOF,QAAQ;AACjB,CAAC,EAAE,IAAIx0F,GAAG,CAAC,CAAC,CAAC;AACb,MAAM20F,wBAAwB,SAASX,qBAAqB,CAAC;EAC3DY,OAAO,GAAG,IAAI50F,GAAG,CAAC,CAAC;EACnB60F,YAAY,GAAG,IAAI70F,GAAG,CAAC,CAAC;EACxBoC,WAAWA,CAAA,EAAG;IACZ,KAAK,CAAC,CAAC;IACPiyF,MAAM,CAAC70F,OAAO,CAACs1F,WAAW,IAAI;MAC5B,MAAMzuF,IAAI,GAAG,IAAIrG,GAAG,CAAC,CAAC;MACtB,MAAM+0F,MAAM,GAAG,IAAIn2C,GAAG,CAAC,CAAC;MACxB,MAAM,CAACo2C,OAAO,EAAEC,aAAa,CAAC,GAAGH,WAAW,CAAC1mE,KAAK,CAAC,GAAG,CAAC;MACvD,MAAM8mE,UAAU,GAAGD,aAAa,CAAC7mE,KAAK,CAAC,GAAG,CAAC;MAC3C,MAAM,CAAC+mE,SAAS,EAAEC,SAAS,CAAC,GAAGJ,OAAO,CAAC5mE,KAAK,CAAC,GAAG,CAAC;MACjD+mE,SAAS,CAAC/mE,KAAK,CAAC,GAAG,CAAC,CAAC5uB,OAAO,CAACzB,GAAG,IAAI;QAClC,IAAI,CAAC62F,OAAO,CAACtzF,GAAG,CAACvD,GAAG,CAACuB,WAAW,CAAC,CAAC,EAAE+G,IAAI,CAAC;QACzC,IAAI,CAACwuF,YAAY,CAACvzF,GAAG,CAACvD,GAAG,CAACuB,WAAW,CAAC,CAAC,EAAEy1F,MAAM,CAAC;MAClD,CAAC,CAAC;MACF,MAAMM,SAAS,GAAGD,SAAS,IAAI,IAAI,CAACR,OAAO,CAACvzF,GAAG,CAAC+zF,SAAS,CAAC91F,WAAW,CAAC,CAAC,CAAC;MACxE,IAAI+1F,SAAS,EAAE;QACb,KAAK,MAAM,CAAC5nF,IAAI,EAAEpO,KAAK,CAAC,IAAIg2F,SAAS,EAAE;UACrChvF,IAAI,CAAC/E,GAAG,CAACmM,IAAI,EAAEpO,KAAK,CAAC;QACvB;QACA,KAAK,MAAMi2F,UAAU,IAAI,IAAI,CAACT,YAAY,CAACxzF,GAAG,CAAC+zF,SAAS,CAAC91F,WAAW,CAAC,CAAC,CAAC,EAAE;UACvEy1F,MAAM,CAACp0C,GAAG,CAAC20C,UAAU,CAAC;QACxB;MACF;MACAJ,UAAU,CAAC11F,OAAO,CAACsmB,QAAQ,IAAI;QAC7B,IAAIA,QAAQ,CAACxoB,MAAM,GAAG,CAAC,EAAE;UACvB,QAAQwoB,QAAQ,CAAC,CAAC,CAAC;YACjB,KAAK,GAAG;cACNivE,MAAM,CAACp0C,GAAG,CAAC76B,QAAQ,CAACqxB,SAAS,CAAC,CAAC,CAAC,CAAC;cACjC;YACF,KAAK,GAAG;cACN9wC,IAAI,CAAC/E,GAAG,CAACwkB,QAAQ,CAACqxB,SAAS,CAAC,CAAC,CAAC,EAAE88C,OAAO,CAAC;cACxC;YACF,KAAK,GAAG;cACN5tF,IAAI,CAAC/E,GAAG,CAACwkB,QAAQ,CAACqxB,SAAS,CAAC,CAAC,CAAC,EAAE+8C,MAAM,CAAC;cACvC;YACF,KAAK,GAAG;cACN7tF,IAAI,CAAC/E,GAAG,CAACwkB,QAAQ,CAACqxB,SAAS,CAAC,CAAC,CAAC,EAAEi9C,MAAM,CAAC;cACvC;YACF;cACE/tF,IAAI,CAAC/E,GAAG,CAACwkB,QAAQ,EAAEquE,MAAM,CAAC;UAC9B;QACF;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EACAoB,WAAWA,CAACh5E,OAAO,EAAEi5E,QAAQ,EAAEC,WAAW,EAAE;IAC1C,IAAIA,WAAW,CAAC1mD,IAAI,CAAC2mD,MAAM,IAAIA,MAAM,CAACt2F,IAAI,KAAK4D,gBAAgB,CAAC5D,IAAI,CAAC,EAAE;MACrE,OAAO,IAAI;IACb;IACA,IAAImd,OAAO,CAACwQ,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE;MAC7B,IAAIsT,aAAa,CAAC9jB,OAAO,CAAC,IAAI+jB,WAAW,CAAC/jB,OAAO,CAAC,EAAE;QAClD,OAAO,KAAK;MACd;MACA,IAAIk5E,WAAW,CAAC1mD,IAAI,CAAC2mD,MAAM,IAAIA,MAAM,CAACt2F,IAAI,KAAK2D,sBAAsB,CAAC3D,IAAI,CAAC,EAAE;QAC3E,OAAO,IAAI;MACb;IACF;IACA,MAAMu2F,iBAAiB,GAAG,IAAI,CAACf,OAAO,CAACvzF,GAAG,CAACkb,OAAO,CAACjd,WAAW,CAAC,CAAC,CAAC,IAAI,IAAI,CAACs1F,OAAO,CAACvzF,GAAG,CAAC,SAAS,CAAC;IAChG,OAAOs0F,iBAAiB,CAAClzF,GAAG,CAAC+yF,QAAQ,CAAC;EACxC;EACAI,UAAUA,CAACr5E,OAAO,EAAEk5E,WAAW,EAAE;IAC/B,IAAIA,WAAW,CAAC1mD,IAAI,CAAC2mD,MAAM,IAAIA,MAAM,CAACt2F,IAAI,KAAK4D,gBAAgB,CAAC5D,IAAI,CAAC,EAAE;MACrE,OAAO,IAAI;IACb;IACA,IAAImd,OAAO,CAACwQ,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE;MAC7B,IAAIsT,aAAa,CAAC9jB,OAAO,CAAC,IAAI+jB,WAAW,CAAC/jB,OAAO,CAAC,EAAE;QAClD,OAAO,IAAI;MACb;MACA,IAAIk5E,WAAW,CAAC1mD,IAAI,CAAC2mD,MAAM,IAAIA,MAAM,CAACt2F,IAAI,KAAK2D,sBAAsB,CAAC3D,IAAI,CAAC,EAAE;QAC3E,OAAO,IAAI;MACb;IACF;IACA,OAAO,IAAI,CAACw1F,OAAO,CAACnyF,GAAG,CAAC8Z,OAAO,CAACjd,WAAW,CAAC,CAAC,CAAC;EAChD;EACAygC,eAAeA,CAACxjB,OAAO,EAAEi5E,QAAQ,EAAEK,WAAW,EAAE;IAC9C,IAAIA,WAAW,EAAE;MACfL,QAAQ,GAAG,IAAI,CAACM,iBAAiB,CAACN,QAAQ,CAAC;IAC7C;IACAj5E,OAAO,GAAGA,OAAO,CAACjd,WAAW,CAAC,CAAC;IAC/Bk2F,QAAQ,GAAGA,QAAQ,CAACl2F,WAAW,CAAC,CAAC;IACjC,IAAIi1B,GAAG,GAAGi/D,eAAe,CAAC,CAAC,CAACj3E,OAAO,GAAG,GAAG,GAAGi5E,QAAQ,CAAC;IACrD,IAAIjhE,GAAG,EAAE;MACP,OAAOA,GAAG;IACZ;IACAA,GAAG,GAAGi/D,eAAe,CAAC,CAAC,CAAC,IAAI,GAAGgC,QAAQ,CAAC;IACxC,OAAOjhE,GAAG,GAAGA,GAAG,GAAGpxB,eAAe,CAACi+D,IAAI;EACzC;EACA00B,iBAAiBA,CAACN,QAAQ,EAAE;IAC1B,OAAOlB,aAAa,CAACjzF,GAAG,CAACm0F,QAAQ,CAAC,IAAIA,QAAQ;EAChD;EACAO,8BAA8BA,CAAA,EAAG;IAC/B,OAAO,cAAc;EACvB;EACAC,gBAAgBA,CAAC52F,IAAI,EAAE;IACrB,IAAIA,IAAI,CAACE,WAAW,CAAC,CAAC,CAACovB,UAAU,CAAC,IAAI,CAAC,EAAE;MACvC,MAAMjlB,GAAG,GAAG,8BAA8BrK,IAAI,wCAAwC,GAAG,eAAeA,IAAI,CAAClB,KAAK,CAAC,CAAC,CAAC,OAAO,GAAG,SAASkB,IAAI,oEAAoE,GAAG,kBAAkB;MACrO,OAAO;QACLklC,KAAK,EAAE,IAAI;QACX76B,GAAG,EAAEA;MACP,CAAC;IACH,CAAC,MAAM;MACL,OAAO;QACL66B,KAAK,EAAE;MACT,CAAC;IACH;EACF;EACA2xD,iBAAiBA,CAAC72F,IAAI,EAAE;IACtB,IAAIA,IAAI,CAACE,WAAW,CAAC,CAAC,CAACovB,UAAU,CAAC,IAAI,CAAC,EAAE;MACvC,MAAMjlB,GAAG,GAAG,+BAA+BrK,IAAI,wCAAwC,GAAG,eAAeA,IAAI,CAAClB,KAAK,CAAC,CAAC,CAAC,OAAO;MAC7H,OAAO;QACLomC,KAAK,EAAE,IAAI;QACX76B,GAAG,EAAEA;MACP,CAAC;IACH,CAAC,MAAM;MACL,OAAO;QACL66B,KAAK,EAAE;MACT,CAAC;IACH;EACF;EACA4xD,oBAAoBA,CAAA,EAAG;IACrB,OAAOr/E,KAAK,CAACmZ,IAAI,CAAC,IAAI,CAAC4kE,OAAO,CAAC3uF,IAAI,CAAC,CAAC,CAAC;EACxC;EACAkwF,2BAA2BA,CAAC55E,OAAO,EAAE;IACnC,MAAMo5E,iBAAiB,GAAG,IAAI,CAACf,OAAO,CAACvzF,GAAG,CAACkb,OAAO,CAACjd,WAAW,CAAC,CAAC,CAAC,IAAI,IAAI,CAACs1F,OAAO,CAACvzF,GAAG,CAAC,SAAS,CAAC;IAChG,OAAOwV,KAAK,CAACmZ,IAAI,CAAC2lE,iBAAiB,CAAC1vF,IAAI,CAAC,CAAC,CAAC,CAACxE,GAAG,CAACgM,IAAI,IAAI8mF,aAAa,CAAClzF,GAAG,CAACoM,IAAI,CAAC,IAAIA,IAAI,CAAC;EAC1F;EACA2oF,uBAAuBA,CAAC75E,OAAO,EAAE;IAC/B,OAAO1F,KAAK,CAACmZ,IAAI,CAAC,IAAI,CAAC6kE,YAAY,CAACxzF,GAAG,CAACkb,OAAO,CAACjd,WAAW,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;EACvE;EACA+2F,+BAA+BA,CAACb,QAAQ,EAAE;IACxC,OAAOnpE,mBAAmB,CAACmpE,QAAQ,CAAC;EACtC;EACAc,4BAA4BA,CAACC,aAAa,EAAEC,gBAAgB,EAAEtpE,GAAG,EAAE;IACjE,IAAI8S,IAAI,GAAG,EAAE;IACb,MAAMy2D,MAAM,GAAGvpE,GAAG,CAAC3tB,QAAQ,CAAC,CAAC,CAACytB,IAAI,CAAC,CAAC;IACpC,IAAI0pE,QAAQ,GAAG,IAAI;IACnB,IAAIC,sBAAsB,CAACJ,aAAa,CAAC,IAAIrpE,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,GAAG,EAAE;MACrE,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;QAC3B8S,IAAI,GAAG,IAAI;MACb,CAAC,MAAM;QACL,MAAM42D,iBAAiB,GAAG1pE,GAAG,CAACzvB,KAAK,CAAC,wBAAwB,CAAC;QAC7D,IAAIm5F,iBAAiB,IAAIA,iBAAiB,CAAC,CAAC,CAAC,CAACt5F,MAAM,IAAI,CAAC,EAAE;UACzDo5F,QAAQ,GAAG,uCAAuCF,gBAAgB,IAAItpE,GAAG,EAAE;QAC7E;MACF;IACF;IACA,OAAO;MACLoX,KAAK,EAAEoyD,QAAQ;MACfr3F,KAAK,EAAEo3F,MAAM,GAAGz2D;IAClB,CAAC;EACH;AACF;AACA,SAAS22D,sBAAsBA,CAAClpF,IAAI,EAAE;EACpC,QAAQA,IAAI;IACV,KAAK,OAAO;IACZ,KAAK,QAAQ;IACb,KAAK,UAAU;IACf,KAAK,WAAW;IAChB,KAAK,UAAU;IACf,KAAK,WAAW;IAChB,KAAK,MAAM;IACX,KAAK,KAAK;IACV,KAAK,QAAQ;IACb,KAAK,OAAO;IACZ,KAAK,UAAU;IACf,KAAK,cAAc;IACnB,KAAK,eAAe;IACpB,KAAK,YAAY;IACjB,KAAK,aAAa;IAClB,KAAK,eAAe;IACpB,KAAK,cAAc;IACnB,KAAK,WAAW;IAChB,KAAK,YAAY;IACjB,KAAK,cAAc;IACnB,KAAK,aAAa;IAClB,KAAK,cAAc;IACnB,KAAK,aAAa;IAClB,KAAK,gBAAgB;IACrB,KAAK,iBAAiB;IACtB,KAAK,kBAAkB;IACvB,KAAK,mBAAmB;IACxB,KAAK,YAAY;MACf,OAAO,IAAI;IACb;MACE,OAAO,KAAK;EAChB;AACF;AAEA,MAAMopF,iBAAiB,CAAC;EACtBC,gBAAgB,GAAG,CAAC,CAAC;EACrBC,WAAW;EACXxX,cAAc,GAAG,KAAK;EACtBY,uBAAuB;EACvB35E,MAAM;EACNo3E,aAAa;EACbS,YAAY;EACZkC,2BAA2B;EAC3Bn+E,WAAWA,CAAC;IACV00F,gBAAgB;IAChB3W,uBAAuB;IACvB4W,WAAW,GAAG92D,cAAc,CAAC+2D,aAAa;IAC1CzX,cAAc,GAAG,KAAK;IACtB/4E,MAAM,GAAG,KAAK;IACdo3E,aAAa,GAAG,KAAK;IACrB2C,2BAA2B,GAAG,KAAK;IACnClC,YAAY,GAAG;EACjB,CAAC,GAAG,CAAC,CAAC,EAAE;IACN,IAAIyY,gBAAgB,IAAIA,gBAAgB,CAACx5F,MAAM,GAAG,CAAC,EAAE;MACnDw5F,gBAAgB,CAACt3F,OAAO,CAAC+c,OAAO,IAAI,IAAI,CAACu6E,gBAAgB,CAACv6E,OAAO,CAAC,GAAG,IAAI,CAAC;IAC5E;IACA,IAAI,CAAC/V,MAAM,GAAGA,MAAM;IACpB,IAAI,CAAC+4E,cAAc,GAAGA,cAAc,IAAI/4E,MAAM;IAC9C,IAAI,CAAC25E,uBAAuB,GAAGA,uBAAuB,IAAI,IAAI;IAC9D,IAAI,CAAC4W,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACnZ,aAAa,GAAGA,aAAa;IAClC,IAAI,CAAC2C,2BAA2B,GAAGA,2BAA2B;IAC9D,IAAI,CAAClC,YAAY,GAAGA,YAAY,IAAI73E,MAAM;EAC5C;EACA83E,eAAeA,CAACl/E,IAAI,EAAE;IACpB,OAAO,IAAI,CAACoH,MAAM,IAAIpH,IAAI,CAACE,WAAW,CAAC,CAAC,IAAI,IAAI,CAACw3F,gBAAgB;EACnE;EACA9e,cAAcA,CAACh6E,MAAM,EAAE;IACrB,IAAI,OAAO,IAAI,CAAC+4F,WAAW,KAAK,QAAQ,EAAE;MACxC,MAAME,YAAY,GAAGj5F,MAAM,KAAKmvB,SAAS,GAAGA,SAAS,GAAG,IAAI,CAAC4pE,WAAW,CAAC/4F,MAAM,CAAC;MAChF,OAAOi5F,YAAY,IAAI,IAAI,CAACF,WAAW,CAACG,OAAO;IACjD;IACA,OAAO,IAAI,CAACH,WAAW;EACzB;AACF;AACA,IAAII,sBAAsB;AAC1B,IAAIC,eAAe;AACnB,SAASC,oBAAoBA,CAAC96E,OAAO,EAAE;EACrC,IAAI,CAAC66E,eAAe,EAAE;IACpBD,sBAAsB,GAAG,IAAIN,iBAAiB,CAAC;MAC7CxY,YAAY,EAAE;IAChB,CAAC,CAAC;IACF+Y,eAAe,GAAGtzF,MAAM,CAACwzF,MAAM,CAACxzF,MAAM,CAACs7D,MAAM,CAAC,IAAI,CAAC,EAAE;MACnD,MAAM,EAAE,IAAIy3B,iBAAiB,CAAC;QAC5BrwF,MAAM,EAAE;MACV,CAAC,CAAC;MACF,MAAM,EAAE,IAAIqwF,iBAAiB,CAAC;QAC5BrwF,MAAM,EAAE;MACV,CAAC,CAAC;MACF,MAAM,EAAE,IAAIqwF,iBAAiB,CAAC;QAC5BrwF,MAAM,EAAE;MACV,CAAC,CAAC;MACF,OAAO,EAAE,IAAIqwF,iBAAiB,CAAC;QAC7BrwF,MAAM,EAAE;MACV,CAAC,CAAC;MACF,MAAM,EAAE,IAAIqwF,iBAAiB,CAAC;QAC5BrwF,MAAM,EAAE;MACV,CAAC,CAAC;MACF,KAAK,EAAE,IAAIqwF,iBAAiB,CAAC;QAC3BrwF,MAAM,EAAE;MACV,CAAC,CAAC;MACF,OAAO,EAAE,IAAIqwF,iBAAiB,CAAC;QAC7BrwF,MAAM,EAAE;MACV,CAAC,CAAC;MACF,OAAO,EAAE,IAAIqwF,iBAAiB,CAAC;QAC7BrwF,MAAM,EAAE;MACV,CAAC,CAAC;MACF,IAAI,EAAE,IAAIqwF,iBAAiB,CAAC;QAC1BrwF,MAAM,EAAE;MACV,CAAC,CAAC;MACF,IAAI,EAAE,IAAIqwF,iBAAiB,CAAC;QAC1BrwF,MAAM,EAAE;MACV,CAAC,CAAC;MACF,QAAQ,EAAE,IAAIqwF,iBAAiB,CAAC;QAC9BrwF,MAAM,EAAE;MACV,CAAC,CAAC;MACF,OAAO,EAAE,IAAIqwF,iBAAiB,CAAC;QAC7BrwF,MAAM,EAAE;MACV,CAAC,CAAC;MACF,KAAK,EAAE,IAAIqwF,iBAAiB,CAAC;QAC3BrwF,MAAM,EAAE;MACV,CAAC,CAAC;MACF,GAAG,EAAE,IAAIqwF,iBAAiB,CAAC;QACzBC,gBAAgB,EAAE,CAAC,SAAS,EAAE,SAAS,EAAE,OAAO,EAAE,YAAY,EAAE,KAAK,EAAE,IAAI,EAAE,UAAU,EAAE,QAAQ,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,QAAQ,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,EAAE,IAAI,CAAC;QACnOvX,cAAc,EAAE;MAClB,CAAC,CAAC;MACF,OAAO,EAAE,IAAIsX,iBAAiB,CAAC;QAC7BC,gBAAgB,EAAE,CAAC,OAAO,EAAE,OAAO;MACrC,CAAC,CAAC;MACF,OAAO,EAAE,IAAID,iBAAiB,CAAC;QAC7BC,gBAAgB,EAAE,CAAC,OAAO,EAAE,OAAO,CAAC;QACpCvX,cAAc,EAAE;MAClB,CAAC,CAAC;MACF,OAAO,EAAE,IAAIsX,iBAAiB,CAAC;QAC7BC,gBAAgB,EAAE,CAAC,OAAO,CAAC;QAC3BvX,cAAc,EAAE;MAClB,CAAC,CAAC;MACF,IAAI,EAAE,IAAIsX,iBAAiB,CAAC;QAC1BC,gBAAgB,EAAE,CAAC,IAAI,CAAC;QACxBvX,cAAc,EAAE;MAClB,CAAC,CAAC;MACF,IAAI,EAAE,IAAIsX,iBAAiB,CAAC;QAC1BC,gBAAgB,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC;QAC9BvX,cAAc,EAAE;MAClB,CAAC,CAAC;MACF,IAAI,EAAE,IAAIsX,iBAAiB,CAAC;QAC1BC,gBAAgB,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC;QAC9BvX,cAAc,EAAE;MAClB,CAAC,CAAC;MACF,KAAK,EAAE,IAAIsX,iBAAiB,CAAC;QAC3BrwF,MAAM,EAAE;MACV,CAAC,CAAC;MACF,KAAK,EAAE,IAAIqwF,iBAAiB,CAAC;QAC3B1W,uBAAuB,EAAE;MAC3B,CAAC,CAAC;MACF,eAAe,EAAE,IAAI0W,iBAAiB,CAAC;QACrC1W,uBAAuB,EAAE,KAAK;QAC9BI,2BAA2B,EAAE;MAC/B,CAAC,CAAC;MACF,MAAM,EAAE,IAAIsW,iBAAiB,CAAC;QAC5B1W,uBAAuB,EAAE;MAC3B,CAAC,CAAC;MACF,IAAI,EAAE,IAAI0W,iBAAiB,CAAC;QAC1BC,gBAAgB,EAAE,CAAC,IAAI,CAAC;QACxBvX,cAAc,EAAE;MAClB,CAAC,CAAC;MACF,IAAI,EAAE,IAAIsX,iBAAiB,CAAC;QAC1BC,gBAAgB,EAAE,CAAC,IAAI,EAAE,IAAI;MAC/B,CAAC,CAAC;MACF,IAAI,EAAE,IAAID,iBAAiB,CAAC;QAC1BC,gBAAgB,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC;QAC9BvX,cAAc,EAAE;MAClB,CAAC,CAAC;MACF,IAAI,EAAE,IAAIsX,iBAAiB,CAAC;QAC1BC,gBAAgB,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC;QAC3CvX,cAAc,EAAE;MAClB,CAAC,CAAC;MACF,IAAI,EAAE,IAAIsX,iBAAiB,CAAC;QAC1BC,gBAAgB,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC;QAC3CvX,cAAc,EAAE;MAClB,CAAC,CAAC;MACF,KAAK,EAAE,IAAIsX,iBAAiB,CAAC;QAC3BC,gBAAgB,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC;QACrCvX,cAAc,EAAE;MAClB,CAAC,CAAC;MACF,IAAI,EAAE,IAAIsX,iBAAiB,CAAC;QAC1BC,gBAAgB,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC;QAC3CvX,cAAc,EAAE;MAClB,CAAC,CAAC;MACF,UAAU,EAAE,IAAIsX,iBAAiB,CAAC;QAChCC,gBAAgB,EAAE,CAAC,UAAU,CAAC;QAC9BvX,cAAc,EAAE;MAClB,CAAC,CAAC;MACF,QAAQ,EAAE,IAAIsX,iBAAiB,CAAC;QAC9BC,gBAAgB,EAAE,CAAC,QAAQ,EAAE,UAAU,CAAC;QACxCvX,cAAc,EAAE;MAClB,CAAC,CAAC;MACF,KAAK,EAAE,IAAIsX,iBAAiB,CAAC;QAC3BjZ,aAAa,EAAE;MACjB,CAAC,CAAC;MACF,SAAS,EAAE,IAAIiZ,iBAAiB,CAAC;QAC/BjZ,aAAa,EAAE;MACjB,CAAC,CAAC;MACF,OAAO,EAAE,IAAIiZ,iBAAiB,CAAC;QAC7BE,WAAW,EAAE92D,cAAc,CAACg4C;MAC9B,CAAC,CAAC;MACF,QAAQ,EAAE,IAAI4e,iBAAiB,CAAC;QAC9BE,WAAW,EAAE92D,cAAc,CAACg4C;MAC9B,CAAC,CAAC;MACF,OAAO,EAAE,IAAI4e,iBAAiB,CAAC;QAC7BE,WAAW,EAAE;UACXG,OAAO,EAAEj3D,cAAc,CAACk4C,kBAAkB;UAC1Cof,GAAG,EAAEt3D,cAAc,CAAC+2D;QACtB;MACF,CAAC,CAAC;MACF,UAAU,EAAE,IAAIH,iBAAiB,CAAC;QAChCE,WAAW,EAAE92D,cAAc,CAACk4C,kBAAkB;QAC9CyF,aAAa,EAAE;MACjB,CAAC;IACH,CAAC,CAAC;IACF,IAAI+W,wBAAwB,CAAC,CAAC,CAACuB,oBAAoB,CAAC,CAAC,CAAC12F,OAAO,CAACg4F,YAAY,IAAI;MAC5E,IAAI,CAACJ,eAAe,CAACI,YAAY,CAAC,IAAIh3D,WAAW,CAACg3D,YAAY,CAAC,KAAK,IAAI,EAAE;QACxEJ,eAAe,CAACI,YAAY,CAAC,GAAG,IAAIX,iBAAiB,CAAC;UACpDxY,YAAY,EAAE;QAChB,CAAC,CAAC;MACJ;IACF,CAAC,CAAC;EACJ;EACA,OAAO+Y,eAAe,CAAC76E,OAAO,CAAC,IAAI66E,eAAe,CAAC76E,OAAO,CAACjd,WAAW,CAAC,CAAC,CAAC,IAAI63F,sBAAsB;AACrG;AAEA,MAAMM,wBAAwB,GAAG;EAC/B,GAAG,EAAE,MAAM;EACX,GAAG,EAAE,WAAW;EAChB,IAAI,EAAE,YAAY;EAClB,IAAI,EAAE,iBAAiB;EACvB,IAAI,EAAE,gBAAgB;EACtB,IAAI,EAAE,gBAAgB;EACtB,IAAI,EAAE,gBAAgB;EACtB,IAAI,EAAE,gBAAgB;EACtB,IAAI,EAAE,gBAAgB;EACtB,IAAI,EAAE,gBAAgB;EACtB,IAAI,EAAE,iBAAiB;EACvB,GAAG,EAAE,aAAa;EAClB,IAAI,EAAE,WAAW;EACjB,MAAM,EAAE,YAAY;EACpB,IAAI,EAAE,cAAc;EACpB,GAAG,EAAE,WAAW;EAChB,GAAG,EAAE,WAAW;EAChB,GAAG,EAAE,oBAAoB;EACzB,OAAO,EAAE,YAAY;EACrB,KAAK,EAAE,WAAW;EAClB,KAAK,EAAE,aAAa;EACpB,OAAO,EAAE,YAAY;EACrB,IAAI,EAAE,YAAY;EAClB,OAAO,EAAE,cAAc;EACvB,IAAI,EAAE,mBAAmB;EACzB,OAAO,EAAE,cAAc;EACvB,IAAI,EAAE,WAAW;EACjB,IAAI,EAAE,iBAAiB;EACvB,GAAG,EAAE,iBAAiB;EACtB,IAAI,EAAE;AACR,CAAC;AACD,MAAMC,mBAAmB,CAAC;EACxBC,sBAAsB,GAAG,CAAC,CAAC;EAC3BC,gBAAgB,GAAG,CAAC,CAAC;EACrBC,0BAA0BA,CAAC95F,GAAG,EAAEjB,KAAK,EAAE0J,MAAM,EAAE;IAC7C,MAAMsxF,SAAS,GAAG,IAAI,CAACC,QAAQ,CAACh6F,GAAG,EAAEjB,KAAK,EAAE0J,MAAM,CAAC;IACnD,IAAI,IAAI,CAACoxF,gBAAgB,CAACE,SAAS,CAAC,EAAE;MACpC,OAAO,IAAI,CAACF,gBAAgB,CAACE,SAAS,CAAC;IACzC;IACA,MAAME,QAAQ,GAAGj6F,GAAG,CAACyuB,WAAW,CAAC,CAAC;IAClC,MAAMyrE,QAAQ,GAAGR,wBAAwB,CAACO,QAAQ,CAAC,IAAI,OAAOA,QAAQ,EAAE;IACxE,MAAM54F,IAAI,GAAG,IAAI,CAAC84F,mBAAmB,CAAC1xF,MAAM,GAAGyxF,QAAQ,GAAG,SAASA,QAAQ,EAAE,CAAC;IAC9E,IAAI,CAACL,gBAAgB,CAACE,SAAS,CAAC,GAAG14F,IAAI;IACvC,OAAOA,IAAI;EACb;EACA+4F,0BAA0BA,CAACp6F,GAAG,EAAE;IAC9B,MAAM+5F,SAAS,GAAG,IAAI,CAACM,eAAe,CAACr6F,GAAG,CAAC;IAC3C,IAAI,IAAI,CAAC65F,gBAAgB,CAACE,SAAS,CAAC,EAAE;MACpC,OAAO,IAAI,CAACF,gBAAgB,CAACE,SAAS,CAAC;IACzC;IACA,MAAME,QAAQ,GAAGj6F,GAAG,CAACyuB,WAAW,CAAC,CAAC;IAClC,MAAMyrE,QAAQ,GAAGR,wBAAwB,CAACO,QAAQ,CAAC,IAAI,OAAOA,QAAQ,EAAE;IACxE,MAAM54F,IAAI,GAAG,IAAI,CAAC84F,mBAAmB,CAAC,SAASD,QAAQ,EAAE,CAAC;IAC1D,IAAI,CAACL,gBAAgB,CAACE,SAAS,CAAC,GAAG14F,IAAI;IACvC,OAAOA,IAAI;EACb;EACAi5F,kBAAkBA,CAACj5F,IAAI,EAAEiwB,OAAO,EAAE;IAChC,MAAMipE,SAAS,GAAGl5F,IAAI,CAACotB,WAAW,CAAC,CAAC;IACpC,MAAMsrE,SAAS,GAAG,OAAOQ,SAAS,IAAIjpE,OAAO,EAAE;IAC/C,IAAI,IAAI,CAACuoE,gBAAgB,CAACE,SAAS,CAAC,EAAE;MACpC,OAAO,IAAI,CAACF,gBAAgB,CAACE,SAAS,CAAC;IACzC;IACA,MAAMj5E,UAAU,GAAG,IAAI,CAACq5E,mBAAmB,CAACI,SAAS,CAAC;IACtD,IAAI,CAACV,gBAAgB,CAACE,SAAS,CAAC,GAAGj5E,UAAU;IAC7C,OAAOA,UAAU;EACnB;EACA05E,oBAAoBA,CAACn5F,IAAI,EAAE;IACzB,OAAO,IAAI,CAAC84F,mBAAmB,CAAC94F,IAAI,CAACotB,WAAW,CAAC,CAAC,CAAC;EACrD;EACAgsE,4BAA4BA,CAACp5F,IAAI,EAAE+f,UAAU,EAAE;IAC7C,MAAM24E,SAAS,GAAG,IAAI,CAACW,UAAU,CAACr5F,IAAI,EAAE+f,UAAU,CAAC;IACnD,IAAI,IAAI,CAACy4E,gBAAgB,CAACE,SAAS,CAAC,EAAE;MACpC,OAAO,IAAI,CAACF,gBAAgB,CAACE,SAAS,CAAC;IACzC;IACA,MAAM9iF,WAAW,GAAG,IAAI,CAACkjF,mBAAmB,CAAC,eAAe,IAAI,CAACQ,YAAY,CAACt5F,IAAI,CAAC,EAAE,CAAC;IACtF,IAAI,CAACw4F,gBAAgB,CAACE,SAAS,CAAC,GAAG9iF,WAAW;IAC9C,OAAOA,WAAW;EACpB;EACA2jF,4BAA4BA,CAACv5F,IAAI,EAAE;IACjC,MAAM04F,SAAS,GAAG,IAAI,CAACc,iBAAiB,CAACx5F,IAAI,CAAC;IAC9C,IAAI,IAAI,CAACw4F,gBAAgB,CAACE,SAAS,CAAC,EAAE;MACpC,OAAO,IAAI,CAACF,gBAAgB,CAACE,SAAS,CAAC;IACzC;IACA,MAAM9iF,WAAW,GAAG,IAAI,CAACkjF,mBAAmB,CAAC,eAAe,IAAI,CAACQ,YAAY,CAACt5F,IAAI,CAAC,EAAE,CAAC;IACtF,IAAI,CAACw4F,gBAAgB,CAACE,SAAS,CAAC,GAAG9iF,WAAW;IAC9C,OAAOA,WAAW;EACpB;EACA+iF,QAAQA,CAACh6F,GAAG,EAAEjB,KAAK,EAAE0J,MAAM,EAAE;IAC3B,MAAMmtB,KAAK,GAAG,IAAI51B,GAAG,EAAE;IACvB,MAAMotC,QAAQ,GAAGrnC,MAAM,CAACmC,IAAI,CAACnJ,KAAK,CAAC,CAAC+7F,IAAI,CAAC,CAAC,CAACp3F,GAAG,CAACrC,IAAI,IAAI,IAAIA,IAAI,IAAItC,KAAK,CAACsC,IAAI,CAAC,EAAE,CAAC,CAACF,IAAI,CAAC,EAAE,CAAC;IAC1F,MAAMyK,GAAG,GAAGnD,MAAM,GAAG,IAAI,GAAG,MAAMzI,GAAG,GAAG;IACxC,OAAO41B,KAAK,GAAGwX,QAAQ,GAAGxhC,GAAG;EAC/B;EACAyuF,eAAeA,CAACr6F,GAAG,EAAE;IACnB,OAAO,IAAI,CAACg6F,QAAQ,CAAC,IAAIh6F,GAAG,EAAE,EAAE,CAAC,CAAC,EAAE,KAAK,CAAC;EAC5C;EACA06F,UAAUA,CAACr5F,IAAI,EAAE+f,UAAU,EAAE;IAC3B,MAAMrR,MAAM,GAAGqR,UAAU,CAAC7hB,MAAM,KAAK,CAAC,GAAG,EAAE,GAAG,KAAK6hB,UAAU,CAAC05E,IAAI,CAAC,CAAC,CAAC35F,IAAI,CAAC,IAAI,CAAC,GAAG;IAClF,OAAO,IAAIE,IAAI,GAAG0O,MAAM,KAAK;EAC/B;EACA8qF,iBAAiBA,CAACx5F,IAAI,EAAE;IACtB,OAAO,IAAI,CAACq5F,UAAU,CAAC,SAASr5F,IAAI,EAAE,EAAE,EAAE,CAAC;EAC7C;EACAs5F,YAAYA,CAACt5F,IAAI,EAAE;IACjB,OAAOA,IAAI,CAACotB,WAAW,CAAC,CAAC,CAAC1tB,OAAO,CAAC,YAAY,EAAE,GAAG,CAAC;EACtD;EACAo5F,mBAAmBA,CAACnrF,IAAI,EAAE;IACxB,MAAM84D,IAAI,GAAG,IAAI,CAAC8xB,sBAAsB,CAAChtD,cAAc,CAAC59B,IAAI,CAAC;IAC7D,IAAI,CAAC84D,IAAI,EAAE;MACT,IAAI,CAAC8xB,sBAAsB,CAAC5qF,IAAI,CAAC,GAAG,CAAC;MACrC,OAAOA,IAAI;IACb;IACA,MAAMvI,EAAE,GAAG,IAAI,CAACmzF,sBAAsB,CAAC5qF,IAAI,CAAC;IAC5C,IAAI,CAAC4qF,sBAAsB,CAAC5qF,IAAI,CAAC,GAAGvI,EAAE,GAAG,CAAC;IAC1C,OAAO,GAAGuI,IAAI,IAAIvI,EAAE,EAAE;EACxB;AACF;AAEA,MAAMs0F,UAAU,GAAG,IAAIrd,MAAM,CAAC,IAAI0H,KAAK,CAAC,CAAC,CAAC;AAC1C,SAAS4V,wBAAwBA,CAACC,eAAe,EAAEC,iBAAiB,EAAEC,4BAA4B,EAAE;EAClG,MAAMl0F,OAAO,GAAG,IAAIm0F,YAAY,CAACL,UAAU,EAAEE,eAAe,EAAEC,iBAAiB,EAAEC,4BAA4B,CAAC;EAC9G,OAAO,CAACt0F,KAAK,EAAEC,OAAO,EAAE0P,WAAW,EAAEC,QAAQ,EAAE4kF,WAAW,KAAKp0F,OAAO,CAACq0F,aAAa,CAACz0F,KAAK,EAAEC,OAAO,EAAE0P,WAAW,EAAEC,QAAQ,EAAE4kF,WAAW,CAAC;AAC1I;AACA,SAASE,eAAeA,CAACC,KAAK,EAAElzE,IAAI,EAAE;EACpC,OAAOA,IAAI;AACb;AACA,MAAM8yE,YAAY,CAAC;EACjBK,iBAAiB;EACjBC,gBAAgB;EAChBC,kBAAkB;EAClBC,6BAA6B;EAC7Bv3F,WAAWA,CAACo3F,iBAAiB,EAAEC,gBAAgB,EAAEC,kBAAkB,EAAEC,6BAA6B,EAAE;IAClG,IAAI,CAACH,iBAAiB,GAAGA,iBAAiB;IAC1C,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,kBAAkB,GAAGA,kBAAkB;IAC5C,IAAI,CAACC,6BAA6B,GAAGA,6BAA6B;EACpE;EACAN,aAAaA,CAACz0F,KAAK,EAAEC,OAAO,GAAG,EAAE,EAAE0P,WAAW,GAAG,EAAE,EAAEC,QAAQ,GAAG,EAAE,EAAE4kF,WAAW,EAAE;IAC/E,MAAM3zF,OAAO,GAAG;MACdm0F,KAAK,EAAEh1F,KAAK,CAACtH,MAAM,IAAI,CAAC,IAAIsH,KAAK,CAAC,CAAC,CAAC,YAAYgpE,SAAS;MACzDisB,QAAQ,EAAE,CAAC;MACXC,mBAAmB,EAAE,IAAIpC,mBAAmB,CAAC,CAAC;MAC9CqC,oBAAoB,EAAE,CAAC,CAAC;MACxBjxD,oBAAoB,EAAE,CAAC,CAAC;MACxBswD,WAAW,EAAEA,WAAW,IAAIE;IAC9B,CAAC;IACD,MAAMU,QAAQ,GAAGp7D,QAAQ,CAAC,IAAI,EAAEh6B,KAAK,EAAEa,OAAO,CAAC;IAC/C,OAAO,IAAIojC,OAAO,CAACmxD,QAAQ,EAAEv0F,OAAO,CAACs0F,oBAAoB,EAAEt0F,OAAO,CAACqjC,oBAAoB,EAAEjkC,OAAO,EAAE0P,WAAW,EAAEC,QAAQ,CAAC;EAC1H;EACAiuB,YAAYA,CAACpvB,EAAE,EAAE5N,OAAO,EAAE;IACxB,OAAO,IAAI,CAACw0F,iBAAiB,CAAC5mF,EAAE,EAAE5N,OAAO,CAAC;EAC5C;EACAqhC,cAAcA,CAAC0B,SAAS,EAAE/iC,OAAO,EAAE;IACjC,OAAO,IAAI,CAACw0F,iBAAiB,CAACzxD,SAAS,EAAE/iC,OAAO,CAAC;EACnD;EACAuhC,cAAcA,CAACyB,SAAS,EAAEhjC,OAAO,EAAE;IACjC,MAAM,IAAI3H,KAAK,CAAC,kBAAkB,CAAC;EACrC;EACAuwE,cAAcA,CAAChwE,SAAS,EAAEoH,OAAO,EAAE;IACjC,MAAMsM,IAAI,GAAG1T,SAAS,CAAC+vE,WAAW,KAAKjhD,SAAS,IAAI9uB,SAAS,CAAC+vE,WAAW,CAAC9wE,MAAM,KAAK,CAAC,GAAG,IAAI+rC,MAAM,CAAChrC,SAAS,CAACgB,KAAK,EAAEhB,SAAS,CAAC2gC,SAAS,IAAI3gC,SAAS,CAACmP,UAAU,CAAC,GAAG,IAAI,CAAC0sF,2BAA2B,CAAC77F,SAAS,CAAC+vE,WAAW,EAAE/vE,SAAS,CAAC2gC,SAAS,IAAI3gC,SAAS,CAACmP,UAAU,EAAE/H,OAAO,EAAEpH,SAAS,CAACgoB,IAAI,CAAC;IACjS,OAAO5gB,OAAO,CAAC2zF,WAAW,CAAC/6F,SAAS,EAAE0T,IAAI,CAAC;EAC7C;EACAxM,SAASA,CAACC,IAAI,EAAEC,OAAO,EAAE;IACvB,MAAMsM,IAAI,GAAGvM,IAAI,CAACmoE,MAAM,CAACrwE,MAAM,KAAK,CAAC,GAAG,IAAI+rC,MAAM,CAAC7jC,IAAI,CAACnG,KAAK,EAAEmG,IAAI,CAACgI,UAAU,CAAC,GAAG,IAAI,CAAC0sF,2BAA2B,CAAC10F,IAAI,CAACmoE,MAAM,EAAEnoE,IAAI,CAACgI,UAAU,EAAE/H,OAAO,EAAED,IAAI,CAAC6gB,IAAI,CAAC;IACpK,OAAO5gB,OAAO,CAAC2zF,WAAW,CAAC5zF,IAAI,EAAEuM,IAAI,CAAC;EACxC;EACAu8D,YAAYA,CAAC95C,OAAO,EAAE/uB,OAAO,EAAE;IAC7B,OAAO,IAAI;EACb;EACAsoE,cAAcA,CAAChoE,GAAG,EAAEN,OAAO,EAAE;IAC3BA,OAAO,CAACo0F,QAAQ,EAAE;IAClB,MAAMM,YAAY,GAAG,CAAC,CAAC;IACvB,MAAMC,OAAO,GAAG,IAAIxyD,GAAG,CAAC7hC,GAAG,CAAC8nE,WAAW,EAAE9nE,GAAG,CAACM,IAAI,EAAE8zF,YAAY,EAAEp0F,GAAG,CAACyH,UAAU,CAAC;IAChFzH,GAAG,CAACG,KAAK,CAAC1G,OAAO,CAAC66F,IAAI,IAAI;MACxBF,YAAY,CAACE,IAAI,CAACh7F,KAAK,CAAC,GAAG,IAAIiqC,SAAS,CAAC+wD,IAAI,CAACj0F,UAAU,CAAC3E,GAAG,CAACsQ,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC,CAAC,EAAE40F,IAAI,CAACnsB,aAAa,CAAC;IACtH,CAAC,CAAC;IACFzoE,OAAO,CAACo0F,QAAQ,EAAE;IAClB,IAAIp0F,OAAO,CAACm0F,KAAK,IAAIn0F,OAAO,CAACo0F,QAAQ,GAAG,CAAC,EAAE;MACzC,MAAMS,KAAK,GAAG70F,OAAO,CAACq0F,mBAAmB,CAACvB,oBAAoB,CAAC,OAAOxyF,GAAG,CAACM,IAAI,EAAE,CAAC;MACjF+zF,OAAO,CAAC7wD,qBAAqB,GAAG+wD,KAAK;MACrC70F,OAAO,CAACs0F,oBAAoB,CAACO,KAAK,CAAC,GAAG;QACpC90F,IAAI,EAAEO,GAAG,CAAC8nE,WAAW;QACrBrgE,UAAU,EAAEzH,GAAG,CAAC+nE;MAClB,CAAC;MACD,OAAOroE,OAAO,CAAC2zF,WAAW,CAACrzF,GAAG,EAAEq0F,OAAO,CAAC;IAC1C;IACA,MAAMG,MAAM,GAAG90F,OAAO,CAACq0F,mBAAmB,CAACzB,kBAAkB,CAAC,KAAK,EAAEtyF,GAAG,CAACyH,UAAU,CAACjO,QAAQ,CAAC,CAAC,CAAC;IAC/FkG,OAAO,CAACqjC,oBAAoB,CAACyxD,MAAM,CAAC,GAAG,IAAI,CAAClB,aAAa,CAAC,CAACtzF,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAEonB,SAAS,CAAC;IACvF,MAAMpb,IAAI,GAAG,IAAI23B,cAAc,CAAC0wD,OAAO,EAAEG,MAAM,EAAEx0F,GAAG,CAACyH,UAAU,CAAC;IAChE,OAAO/H,OAAO,CAAC2zF,WAAW,CAACrzF,GAAG,EAAEgM,IAAI,CAAC;EACvC;EACAo8D,kBAAkBA,CAACqsB,QAAQ,EAAEC,QAAQ,EAAE;IACrC,MAAM,IAAI38F,KAAK,CAAC,kBAAkB,CAAC;EACrC;EACA0wE,UAAUA,CAAClmC,KAAK,EAAE7iC,OAAO,EAAE;IACzB,MAAMG,QAAQ,GAAGg5B,QAAQ,CAAC,IAAI,EAAE0J,KAAK,CAAC1iC,QAAQ,EAAEH,OAAO,CAAC;IACxD,IAAI,IAAI,CAACg0F,gBAAgB,CAACh3F,GAAG,CAAC6lC,KAAK,CAAClpC,IAAI,CAAC,EAAE;MACzC,OAAO,IAAIkqC,SAAS,CAAC1jC,QAAQ,EAAE0iC,KAAK,CAAC96B,UAAU,CAAC;IAClD;IACA,MAAM2R,UAAU,GAAGmpB,KAAK,CAACnpB,UAAU,CAAC1d,GAAG,CAAC4U,KAAK,IAAIA,KAAK,CAACjQ,UAAU,CAAC;IAClE,MAAMs0F,WAAW,GAAGj1F,OAAO,CAACq0F,mBAAmB,CAACtB,4BAA4B,CAAClwD,KAAK,CAAClpC,IAAI,EAAE+f,UAAU,CAAC;IACpG,MAAMw7E,WAAW,GAAGl1F,OAAO,CAACq0F,mBAAmB,CAACnB,4BAA4B,CAACrwD,KAAK,CAAClpC,IAAI,CAAC;IACxFqG,OAAO,CAACs0F,oBAAoB,CAACW,WAAW,CAAC,GAAG;MAC1Cl1F,IAAI,EAAE8iC,KAAK,CAAC/F,eAAe,CAAChjC,QAAQ,CAAC,CAAC;MACtCiO,UAAU,EAAE86B,KAAK,CAAC/F;IACpB,CAAC;IACD98B,OAAO,CAACs0F,oBAAoB,CAACY,WAAW,CAAC,GAAG;MAC1Cn1F,IAAI,EAAE8iC,KAAK,CAAC9F,aAAa,GAAG8F,KAAK,CAAC9F,aAAa,CAACjjC,QAAQ,CAAC,CAAC,GAAG,GAAG;MAChEiO,UAAU,EAAE86B,KAAK,CAAC9F,aAAa,IAAI8F,KAAK,CAAC96B;IAC3C,CAAC;IACD,MAAMuE,IAAI,GAAG,IAAI63B,gBAAgB,CAACtB,KAAK,CAAClpC,IAAI,EAAE+f,UAAU,EAAEu7E,WAAW,EAAEC,WAAW,EAAE/0F,QAAQ,EAAE0iC,KAAK,CAAC96B,UAAU,EAAE86B,KAAK,CAAC/F,eAAe,EAAE+F,KAAK,CAAC9F,aAAa,CAAC;IAC3J,OAAO/8B,OAAO,CAAC2zF,WAAW,CAAC9wD,KAAK,EAAEv2B,IAAI,CAAC;EACzC;EACA28D,mBAAmBA,CAACksB,UAAU,EAAEH,QAAQ,EAAE;IACxC,MAAM,IAAI38F,KAAK,CAAC,kBAAkB,CAAC;EACrC;EACA6oC,mBAAmBA,CAACgC,IAAI,EAAEljC,OAAO,EAAE;IACjC,OAAO,IAAI;EACb;EACAw0F,iBAAiBA,CAACloF,IAAI,EAAEtM,OAAO,EAAE;IAC/B,MAAMG,QAAQ,GAAGg5B,QAAQ,CAAC,IAAI,EAAE7sB,IAAI,CAACnM,QAAQ,EAAEH,OAAO,CAAC;IACvD,MAAM3I,KAAK,GAAG,CAAC,CAAC;IAChB,MAAMuxE,cAAc,GAAG9vE,IAAI,IAAI;MAC7BzB,KAAK,CAACyB,IAAI,CAACa,IAAI,CAAC,GAAGb,IAAI,CAACc,KAAK;IAC/B,CAAC;IACD,IAAIigF,QAAQ;IACZ,IAAI94E,MAAM;IACV,IAAIuL,IAAI,YAAYiwB,OAAO,EAAE;MAC3Bs9C,QAAQ,GAAGvtE,IAAI,CAAC3S,IAAI;MACpBoH,MAAM,GAAG6wF,oBAAoB,CAACtlF,IAAI,CAAC3S,IAAI,CAAC,CAACoH,MAAM;IACjD,CAAC,MAAM;MACL84E,QAAQ,GAAGvtE,IAAI,CAAC0uB,QAAQ;MACxBj6B,MAAM,GAAGuL,IAAI,CAACwK,OAAO,GAAG86E,oBAAoB,CAACtlF,IAAI,CAACwK,OAAO,CAAC,CAAC/V,MAAM,GAAG,KAAK;IAC3E;IACAuL,IAAI,CAACjV,KAAK,CAAC0C,OAAO,CAAC6uE,cAAc,CAAC;IAClCt8D,IAAI,CAACqwB,UAAU,CAAC5iC,OAAO,CAACq7F,GAAG,IAAIA,GAAG,CAAC/9F,KAAK,CAAC0C,OAAO,CAAC6uE,cAAc,CAAC,CAAC;IACjE,MAAMqsB,WAAW,GAAGj1F,OAAO,CAACq0F,mBAAmB,CAACjC,0BAA0B,CAACvY,QAAQ,EAAExiF,KAAK,EAAE0J,MAAM,CAAC;IACnGf,OAAO,CAACs0F,oBAAoB,CAACW,WAAW,CAAC,GAAG;MAC1Cl1F,IAAI,EAAEuM,IAAI,CAACwwB,eAAe,CAAChjC,QAAQ,CAAC,CAAC;MACrCiO,UAAU,EAAEuE,IAAI,CAACwwB;IACnB,CAAC;IACD,IAAIo4D,WAAW,GAAG,EAAE;IACpB,IAAI,CAACn0F,MAAM,EAAE;MACXm0F,WAAW,GAAGl1F,OAAO,CAACq0F,mBAAmB,CAAC3B,0BAA0B,CAAC7Y,QAAQ,CAAC;MAC9E75E,OAAO,CAACs0F,oBAAoB,CAACY,WAAW,CAAC,GAAG;QAC1Cn1F,IAAI,EAAE,KAAK85E,QAAQ,GAAG;QACtB9xE,UAAU,EAAEuE,IAAI,CAACywB,aAAa,IAAIzwB,IAAI,CAACvE;MACzC,CAAC;IACH;IACA,MAAMstF,QAAQ,GAAG,IAAItxD,cAAc,CAAC81C,QAAQ,EAAExiF,KAAK,EAAE49F,WAAW,EAAEC,WAAW,EAAE/0F,QAAQ,EAAEY,MAAM,EAAEuL,IAAI,CAACvE,UAAU,EAAEuE,IAAI,CAACwwB,eAAe,EAAExwB,IAAI,CAACywB,aAAa,CAAC;IAC3J,OAAO/8B,OAAO,CAAC2zF,WAAW,CAACrnF,IAAI,EAAE+oF,QAAQ,CAAC;EAC5C;EACAZ,2BAA2BA,CAACvsB,MAAM,EAAEngE,UAAU,EAAE/H,OAAO,EAAEs1F,YAAY,EAAE;IACrE,MAAMn2F,KAAK,GAAG,EAAE;IAChB,IAAIo2F,gBAAgB,GAAG,KAAK;IAC5B,KAAK,MAAMrtE,KAAK,IAAIggD,MAAM,EAAE;MAC1B,QAAQhgD,KAAK,CAACtnB,IAAI;QAChB,KAAK,CAAC;QACN,KAAK,EAAE;UACL20F,gBAAgB,GAAG,IAAI;UACvB,MAAM,CAACC,WAAW,EAAE70F,UAAU,EAAE80F,SAAS,CAAC,GAAGvtE,KAAK,CAACzoB,KAAK;UACxD,MAAM+yF,QAAQ,GAAGkD,sBAAsB,CAAC/0F,UAAU,CAAC,IAAI,eAAe;UACtE,MAAMm0F,MAAM,GAAG90F,OAAO,CAACq0F,mBAAmB,CAACzB,kBAAkB,CAACJ,QAAQ,EAAE7xF,UAAU,CAAC;UACnF,IAAI,IAAI,CAACuzF,6BAA6B,EAAE;YACtCl0F,OAAO,CAACs0F,oBAAoB,CAACQ,MAAM,CAAC,GAAG;cACrC/0F,IAAI,EAAEmoB,KAAK,CAACzoB,KAAK,CAAChG,IAAI,CAAC,EAAE,CAAC;cAC1BsO,UAAU,EAAEmgB,KAAK,CAACngB;YACpB,CAAC;YACD5I,KAAK,CAACrH,IAAI,CAAC,IAAIksC,WAAW,CAACrjC,UAAU,EAAEm0F,MAAM,EAAE5sE,KAAK,CAACngB,UAAU,CAAC,CAAC;UACnE,CAAC,MAAM;YACL,MAAM4tF,UAAU,GAAG,IAAI,CAACC,mBAAmB,CAAC1tE,KAAK,CAAC;YAClDloB,OAAO,CAACs0F,oBAAoB,CAACQ,MAAM,CAAC,GAAG;cACrC/0F,IAAI,EAAE,GAAGy1F,WAAW,GAAGG,UAAU,GAAGF,SAAS,EAAE;cAC/C1tF,UAAU,EAAEmgB,KAAK,CAACngB;YACpB,CAAC;YACD5I,KAAK,CAACrH,IAAI,CAAC,IAAIksC,WAAW,CAAC2xD,UAAU,EAAEb,MAAM,EAAE5sE,KAAK,CAACngB,UAAU,CAAC,CAAC;UACnE;UACA;QACF;UACE,IAAImgB,KAAK,CAACzoB,KAAK,CAAC,CAAC,CAAC,CAAC5H,MAAM,GAAG,CAAC,IAAI,IAAI,CAACo8F,kBAAkB,EAAE;YACxD,MAAMxe,QAAQ,GAAGt2E,KAAK,CAACA,KAAK,CAACtH,MAAM,GAAG,CAAC,CAAC;YACxC,IAAI49E,QAAQ,YAAY7xC,MAAM,EAAE;cAC9B6xC,QAAQ,CAAC77E,KAAK,IAAIsuB,KAAK,CAACzoB,KAAK,CAAC,CAAC,CAAC;cAChCg2E,QAAQ,CAAC1tE,UAAU,GAAG,IAAIwqC,eAAe,CAACkjC,QAAQ,CAAC1tE,UAAU,CAACmmB,KAAK,EAAEhG,KAAK,CAACngB,UAAU,CAAC7D,GAAG,EAAEuxE,QAAQ,CAAC1tE,UAAU,CAACyqC,SAAS,EAAEijC,QAAQ,CAAC1tE,UAAU,CAAC0qC,OAAO,CAAC;YACxJ,CAAC,MAAM;cACLtzC,KAAK,CAACrH,IAAI,CAAC,IAAI8rC,MAAM,CAAC1b,KAAK,CAACzoB,KAAK,CAAC,CAAC,CAAC,EAAEyoB,KAAK,CAACngB,UAAU,CAAC,CAAC;YAC1D;UACF,CAAC,MAAM;YACL,IAAI,IAAI,CAACksF,kBAAkB,EAAE;cAC3B90F,KAAK,CAACrH,IAAI,CAAC,IAAI8rC,MAAM,CAAC1b,KAAK,CAACzoB,KAAK,CAAC,CAAC,CAAC,EAAEyoB,KAAK,CAACngB,UAAU,CAAC,CAAC;YAC1D;UACF;UACA;MACJ;IACF;IACA,IAAIwtF,gBAAgB,EAAE;MACpBM,wBAAwB,CAAC12F,KAAK,EAAEm2F,YAAY,CAAC;MAC7C,OAAO,IAAIzxD,SAAS,CAAC1kC,KAAK,EAAE4I,UAAU,CAAC;IACzC,CAAC,MAAM;MACL,OAAO5I,KAAK,CAAC,CAAC,CAAC;IACjB;EACF;EACAy2F,mBAAmBA,CAAC1tE,KAAK,EAAE;IACzB,MAAMvnB,UAAU,GAAGunB,KAAK,CAACzoB,KAAK,CAAC,CAAC,CAAC;IACjC,MAAMwM,IAAI,GAAG,IAAI,CAAC8nF,iBAAiB,CAACrP,YAAY,CAAC/jF,UAAU,EAAEunB,KAAK,CAACngB,UAAU,EAAEmgB,KAAK,CAACngB,UAAU,CAACmmB,KAAK,CAACmjB,MAAM,CAAC;IAC7G,OAAOxJ,SAAS,CAAC57B,IAAI,CAAC;EACxB;AACF;AACA,SAAS4pF,wBAAwBA,CAAC12F,KAAK,EAAEm2F,YAAY,EAAE;EACrD,IAAIA,YAAY,YAAYlyD,OAAO,EAAE;IACnC0yD,4BAA4B,CAACR,YAAY,CAAC;IAC1CA,YAAY,GAAGA,YAAY,CAACn2F,KAAK,CAAC,CAAC,CAAC;EACtC;EACA,IAAIm2F,YAAY,YAAYzxD,SAAS,EAAE;IACrCkyD,qBAAqB,CAACT,YAAY,CAACn1F,QAAQ,EAAEhB,KAAK,CAAC;IACnD,KAAK,IAAIlG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkG,KAAK,CAACtH,MAAM,EAAEoB,CAAC,EAAE,EAAE;MACrCkG,KAAK,CAAClG,CAAC,CAAC,CAAC8O,UAAU,GAAGutF,YAAY,CAACn1F,QAAQ,CAAClH,CAAC,CAAC,CAAC8O,UAAU;IAC3D;EACF;AACF;AACA,SAAS+tF,4BAA4BA,CAACh3F,OAAO,EAAE;EAC7C,MAAMK,KAAK,GAAGL,OAAO,CAACK,KAAK;EAC3B,IAAIA,KAAK,CAACtH,MAAM,KAAK,CAAC,IAAI,EAAEsH,KAAK,CAAC,CAAC,CAAC,YAAY0kC,SAAS,CAAC,EAAE;IAC1D,MAAM,IAAIxrC,KAAK,CAAC,8FAA8F,CAAC;EACjH;AACF;AACA,SAAS09F,qBAAqBA,CAACC,aAAa,EAAE72F,KAAK,EAAE;EACnD,IAAI62F,aAAa,CAACn+F,MAAM,KAAKsH,KAAK,CAACtH,MAAM,EAAE;IACzC,MAAM,IAAIQ,KAAK,CAAC;AACpB;AACA;AACA,cAAc29F,aAAa,CAACn+F,MAAM;AAClC,EAAEm+F,aAAa,CAACh6F,GAAG,CAACsQ,IAAI,IAAI,IAAIA,IAAI,CAACvE,UAAU,CAACjO,QAAQ,CAAC,CAAC,GAAG,CAAC,CAACL,IAAI,CAAC,IAAI,CAAC;AACzE;AACA,eAAe0F,KAAK,CAACtH,MAAM;AAC3B,EAAEsH,KAAK,CAACnD,GAAG,CAACsQ,IAAI,IAAI,IAAIA,IAAI,CAACvE,UAAU,CAACjO,QAAQ,CAAC,CAAC,GAAG,CAAC,CAACL,IAAI,CAAC,IAAI,CAAC;AACjE,KAAK,CAAC8tB,IAAI,CAAC,CAAC,CAAC;EACX;EACA,IAAIyuE,aAAa,CAAC1sD,IAAI,CAAC,CAACh9B,IAAI,EAAErT,CAAC,KAAKkG,KAAK,CAAClG,CAAC,CAAC,CAAC0D,WAAW,KAAK2P,IAAI,CAAC3P,WAAW,CAAC,EAAE;IAC9E,MAAM,IAAItE,KAAK,CAAC,+EAA+E,CAAC;EAClG;AACF;AACA,MAAM49F,cAAc,GAAG,6EAA6E;AACpG,SAASP,sBAAsBA,CAAC7uE,KAAK,EAAE;EACrC,OAAOA,KAAK,CAAC8B,KAAK,CAACstE,cAAc,CAAC,CAAC,CAAC,CAAC;AACvC;AAEA,MAAMC,8BAA8B,GAAG,CAAC,GAAG,EAAE,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,aAAa,EAAE,OAAO,CAAC;AAC/F,SAASC,0BAA0BA,CAACxiD,UAAU,EAAE/5C,KAAK,EAAE;EACrD,IAAIA,KAAK,IAAI,IAAI,IAAI,EAAEwX,KAAK,CAACC,OAAO,CAACzX,KAAK,CAAC,IAAIA,KAAK,CAAC/B,MAAM,IAAI,CAAC,CAAC,EAAE;IACjE,MAAM,IAAIQ,KAAK,CAAC,aAAas7C,UAAU,iCAAiC,CAAC;EAC3E,CAAC,MAAM,IAAI/5C,KAAK,IAAI,IAAI,EAAE;IACxB,MAAMs0B,KAAK,GAAGt0B,KAAK,CAAC,CAAC,CAAC;IACtB,MAAMsK,GAAG,GAAGtK,KAAK,CAAC,CAAC,CAAC;IACpBs8F,8BAA8B,CAACn8F,OAAO,CAACq8F,MAAM,IAAI;MAC/C,IAAIA,MAAM,CAACltE,IAAI,CAACgF,KAAK,CAAC,IAAIkoE,MAAM,CAACltE,IAAI,CAAChlB,GAAG,CAAC,EAAE;QAC1C,MAAM,IAAI7L,KAAK,CAAC,KAAK61B,KAAK,OAAOhqB,GAAG,4CAA4C,CAAC;MACnF;IACF,CAAC,CAAC;EACJ;AACF;AAEA,MAAMmyF,mBAAmB,CAAC;EACxBnoE,KAAK;EACLhqB,GAAG;EACH,OAAOoyF,SAASA,CAACC,OAAO,EAAE;IACxB,IAAI,CAACA,OAAO,EAAE;MACZ,OAAOC,4BAA4B;IACrC;IACAL,0BAA0B,CAAC,eAAe,EAAEI,OAAO,CAAC;IACpD,OAAO,IAAIF,mBAAmB,CAACE,OAAO,CAAC,CAAC,CAAC,EAAEA,OAAO,CAAC,CAAC,CAAC,CAAC;EACxD;EACA55F,WAAWA,CAACuxB,KAAK,EAAEhqB,GAAG,EAAE;IACtB,IAAI,CAACgqB,KAAK,GAAGA,KAAK;IAClB,IAAI,CAAChqB,GAAG,GAAGA,GAAG;EAChB;AACF;AACA,MAAMsyF,4BAA4B,GAAG,IAAIH,mBAAmB,CAAC,IAAI,EAAE,IAAI,CAAC;AACxE,MAAMI,wBAAwB,GAAG,IAAIt9C,GAAG,CAAC,CAAC,QAAQ,CAAC,CAAC;AAEpD,MAAMu9C,mBAAmB,GAAG,IAAIv9C,GAAG,CAAC,CAAC,eAAe,EAAE,aAAa,EAAE,aAAa,EAAE,WAAW,EAAE,iBAAiB,EAAE,aAAa,CAAC,CAAC;AACnI,SAASw9C,kBAAkBA,CAAC7/E,OAAO,EAAEi5E,QAAQ,EAAE;EAC7Cj5E,OAAO,GAAGA,OAAO,CAACjd,WAAW,CAAC,CAAC;EAC/Bk2F,QAAQ,GAAGA,QAAQ,CAACl2F,WAAW,CAAC,CAAC;EACjC,OAAO68F,mBAAmB,CAAC15F,GAAG,CAAC8Z,OAAO,GAAG,GAAG,GAAGi5E,QAAQ,CAAC,IAAI2G,mBAAmB,CAAC15F,GAAG,CAAC,IAAI,GAAG+yF,QAAQ,CAAC;AACtG;AAEA,MAAM6G,WAAW,GAAGlb,eAAe,IAAI;EACrC,OAAO,CAACmb,WAAW,EAAExB,QAAQ,KAAK;IAChC,MAAMyB,YAAY,GAAGpb,eAAe,CAAC9/E,GAAG,CAACi7F,WAAW,CAAC,IAAIA,WAAW;IACpE,IAAIC,YAAY,YAAY7uB,YAAY,EAAE;MACxC,IAAIotB,QAAQ,YAAYpxD,cAAc,IAAI6yD,YAAY,CAACl2E,IAAI,YAAYwiB,OAAO,EAAE;QAC9EiyD,QAAQ,CAACnxD,eAAe,GAAG4yD,YAAY,CAACl2E,IAAI;MAC9C;MACAk2E,YAAY,CAACl2E,IAAI,GAAGy0E,QAAQ;IAC9B;IACA,OAAOA,QAAQ;EACjB,CAAC;AACH,CAAC;AACD,MAAM0B,eAAe,CAAC;EACpBC,aAAa;EACbC,+BAA+B;EAC/B1D,eAAe;EACf9X,6BAA6B;EAC7B+X,iBAAiB;EACjB0D,WAAW,GAAG,KAAK;EACnBC,OAAO,GAAG,EAAE;EACZx6F,WAAWA,CAACq6F,aAAa,GAAG,KAAK,EAAEC,+BAA+B,GAAG,KAAK,EAAE1D,eAAe,GAAGkD,wBAAwB,EAAEhb,6BAA6B,GAAG,IAAI,EAAE+X,iBAAiB,GAAG,CAAC/X,6BAA6B,EAAE;IAChN,IAAI,CAACub,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,+BAA+B,GAAGA,+BAA+B;IACtE,IAAI,CAAC1D,eAAe,GAAGA,eAAe;IACtC,IAAI,CAAC9X,6BAA6B,GAAGA,6BAA6B;IAClE,IAAI,CAAC+X,iBAAiB,GAAGA,iBAAiB;EAC5C;EACA4D,oBAAoBA,CAACj4F,KAAK,EAAEgyB,IAAI,GAAG,EAAE,EAAEwiE,WAAW,EAAE;IAClD,MAAM;MACJv0F,OAAO;MACP0P,WAAW;MACXC;IACF,CAAC,GAAG,IAAI,CAACsoF,cAAc,CAAClmE,IAAI,CAAC;IAC7B,MAAM+yC,iBAAiB,GAAGovB,wBAAwB,CAAC,IAAI,CAACC,eAAe,EAAE,IAAI,CAACC,iBAAiB,EAAE,IAAI,CAAC/X,6BAA6B,CAAC;IACpI,MAAM38E,OAAO,GAAGolE,iBAAiB,CAAC/kE,KAAK,EAAEC,OAAO,EAAE0P,WAAW,EAAEC,QAAQ,EAAE4kF,WAAW,CAAC;IACrF,IAAI,CAAC2D,aAAa,CAACx4F,OAAO,EAAEqyB,IAAI,CAAC;IACjC,IAAI,CAAComE,aAAa,CAACz4F,OAAO,EAAEqyB,IAAI,CAAC;IACjC,OAAOryB,OAAO;EAChB;EACA04F,kBAAkBA,CAACr4F,KAAK,EAAE;IACxB,MAAMpG,MAAM,GAAGoG,KAAK,CAACnD,GAAG,CAACsQ,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IACxD,OAAO,IAAIk2E,eAAe,CAAC98E,MAAM,EAAE,IAAI,CAACo+F,OAAO,CAAC;EAClD;EACAn6D,YAAYA,CAAC7lC,OAAO,EAAE;IACpB,IAAI,CAACq9F,iBAAiB,CAACr9F,OAAO,CAAC;IAC/B,OAAOA,OAAO;EAChB;EACAkqC,cAAcA,CAAC0B,SAAS,EAAE/iC,OAAO,EAAE;IACjC,IAAI,CAACw0F,iBAAiB,CAACzxD,SAAS,CAAC;IACjC,OAAOA,SAAS;EAClB;EACAulC,cAAcA,CAACmU,SAAS,EAAEgb,cAAc,EAAE;IACxC,IAAI34F,OAAO;IACX,MAAMqyB,IAAI,GAAGsrD,SAAS,CAAC77D,IAAI;IAC3B,IAAI,CAACs2E,WAAW,GAAG,IAAI;IACvB,IAAI/lE,IAAI,YAAY8S,cAAc,EAAE;MAClC,MAAMtqC,IAAI,GAAGw3B,IAAI,CAACx3B,IAAI;MACtBmF,OAAO,GAAG,IAAI,CAACs4F,oBAAoB,CAAC,CAAC3a,SAAS,CAAC,EAAEtrD,IAAI,CAAC;MACtD,MAAM7wB,GAAG,GAAGipC,kBAAkB,CAACzqC,OAAO,CAAC;MACvCwB,GAAG,CAAC3G,IAAI,GAAGA,IAAI;MACf,IAAI89F,cAAc,KAAK,IAAI,EAAE;QAC3BA,cAAc,CAACp0D,oBAAoB,CAAC1pC,IAAI,CAAC,GAAGmF,OAAO;MACrD;IACF,CAAC,MAAM;MACLA,OAAO,GAAG,IAAI,CAACs4F,oBAAoB,CAAC,CAAC3a,SAAS,CAAC,EAAEgb,cAAc,IAAItmE,IAAI,CAAC;IAC1E;IACAsrD,SAAS,CAAC77D,IAAI,GAAG9hB,OAAO;IACxB,OAAO29E,SAAS;EAClB;EACA38E,SAASA,CAACC,IAAI,EAAE;IACd,OAAOA,IAAI;EACb;EACA6oE,cAAcA,CAAChwE,SAAS,EAAE;IACxB,OAAOA,SAAS;EAClB;EACAiwE,YAAYA,CAAC95C,OAAO,EAAE;IACpB,OAAOA,OAAO;EAChB;EACA25C,kBAAkBA,CAACiU,aAAa,EAAE;IAChC,OAAOA,aAAa;EACtB;EACA5T,UAAUA,CAAClmC,KAAK,EAAE7iC,OAAO,EAAE;IACzBm5B,QAAQ,CAAC,IAAI,EAAE0J,KAAK,CAAC1iC,QAAQ,EAAEH,OAAO,CAAC;IACvC,OAAO6iC,KAAK;EACd;EACAomC,mBAAmBA,CAAC6T,SAAS,EAAE98E,OAAO,EAAE;IACtC,OAAO88E,SAAS;EAClB;EACA57C,mBAAmBA,CAACgC,IAAI,EAAEljC,OAAO,EAAE;IACjC,OAAOkjC,IAAI;EACb;EACA3B,cAAcA,CAACyB,SAAS,EAAEhjC,OAAO,EAAE;IACjC,OAAOgjC,SAAS;EAClB;EACAwxD,iBAAiBA,CAACloF,IAAI,EAAE;IACtB,IAAIxN,OAAO,GAAG4oB,SAAS;IACvB,IAAI2hB,YAAY,CAAC/8B,IAAI,CAAC,EAAE;MACtB,IAAI,CAAC4qF,WAAW,GAAG,IAAI;MACvB,MAAM7/F,KAAK,GAAG,EAAE;MAChB,MAAMqgG,SAAS,GAAG,CAAC,CAAC;MACpB,KAAK,MAAM5+F,IAAI,IAAIwT,IAAI,CAACjV,KAAK,EAAE;QAC7B,IAAIyB,IAAI,CAACa,IAAI,KAAKsvC,SAAS,EAAE;UAC3B,MAAMroB,IAAI,GAAGtU,IAAI,CAACsU,IAAI,IAAI9nB,IAAI,CAACc,KAAK;UACpC,MAAM8hF,eAAe,GAAG,IAAInhF,GAAG,CAAC,CAAC;UACjC,MAAMo9F,YAAY,GAAG,IAAI,CAAClc,6BAA6B,GAAGnvE,IAAI,CAACnM,QAAQ,GAAG27E,oBAAoB,CAAC,IAAIN,iBAAiB,CAAC,KAAK,EAAEE,eAAe,CAAC,EAAEpvE,IAAI,CAACnM,QAAQ,CAAC;UAC5JrB,OAAO,GAAG,IAAI,CAACs4F,oBAAoB,CAACO,YAAY,EAAE/2E,IAAI,EAAEg2E,WAAW,CAAClb,eAAe,CAAC,CAAC;UACrF,IAAI58E,OAAO,CAACK,KAAK,CAACtH,MAAM,KAAK,CAAC,EAAE;YAC9BiH,OAAO,GAAG4oB,SAAS;UACrB;UACApb,IAAI,CAACsU,IAAI,GAAG9hB,OAAO;QACrB,CAAC,MAAM,IAAIhG,IAAI,CAACa,IAAI,CAACsvB,UAAU,CAACigB,gBAAgB,CAAC,EAAE;UACjD,MAAMvvC,IAAI,GAAGb,IAAI,CAACa,IAAI,CAAClB,KAAK,CAACywC,gBAAgB,CAACrxC,MAAM,CAAC;UACrD,IAAI+/F,aAAa;UACjB,IAAItrF,IAAI,YAAYwnB,SAAS,EAAE;YAC7B8jE,aAAa,GAAGtrF,IAAI,CAACwK,OAAO,KAAK,IAAI,GAAG,KAAK,GAAG6/E,kBAAkB,CAACrqF,IAAI,CAACwK,OAAO,EAAEnd,IAAI,CAAC;UACxF,CAAC,MAAM;YACLi+F,aAAa,GAAGjB,kBAAkB,CAACrqF,IAAI,CAAC3S,IAAI,EAAEA,IAAI,CAAC;UACrD;UACA,IAAIi+F,aAAa,EAAE;YACjB,IAAI,CAACC,YAAY,CAAC/+F,IAAI,EAAE,0BAA0Ba,IAAI,uCAAuC,CAAC;UAChG,CAAC,MAAM;YACL+9F,SAAS,CAAC/9F,IAAI,CAAC,GAAGb,IAAI,CAACc,KAAK;UAC9B;QACF,CAAC,MAAM;UACLvC,KAAK,CAACS,IAAI,CAACgB,IAAI,CAAC;QAClB;MACF;MACA,IAAIuF,MAAM,CAACmC,IAAI,CAACk3F,SAAS,CAAC,CAAC7/F,MAAM,EAAE;QACjC,KAAK,MAAMiB,IAAI,IAAIzB,KAAK,EAAE;UACxB,MAAM85B,IAAI,GAAGumE,SAAS,CAAC5+F,IAAI,CAACa,IAAI,CAAC;UACjC,IAAIw3B,IAAI,KAAKzJ,SAAS,IAAI5uB,IAAI,CAACc,KAAK,EAAE;YACpCd,IAAI,CAAC8nB,IAAI,GAAG,IAAI,CAACw2E,oBAAoB,CAAC,CAACt+F,IAAI,CAAC,EAAEA,IAAI,CAAC8nB,IAAI,IAAIuQ,IAAI,CAAC;UAClE;QACF;MACF;MACA,IAAI,CAAC,IAAI,CAAC6lE,aAAa,EAAE;QACvB1qF,IAAI,CAACjV,KAAK,GAAGA,KAAK;MACpB;IACF;IACA8hC,QAAQ,CAAC,IAAI,EAAE7sB,IAAI,CAACnM,QAAQ,EAAErB,OAAO,CAAC;EACxC;EACAu4F,cAAcA,CAAClmE,IAAI,EAAE;IACnB,OAAO,OAAOA,IAAI,KAAK,QAAQ,GAAG2mE,aAAa,CAAC3mE,IAAI,CAAC,GAAGA,IAAI,YAAYiS,OAAO,GAAGjS,IAAI,GAAG,CAAC,CAAC;EAC7F;EACAmmE,aAAaA,CAACx4F,OAAO,EAAEqyB,IAAI,EAAE;IAC3B,IAAI,CAACryB,OAAO,CAACC,EAAE,EAAE;MACfD,OAAO,CAACC,EAAE,GAAGoyB,IAAI,YAAYiS,OAAO,IAAIjS,IAAI,CAACpyB,EAAE,IAAIM,aAAa,CAACP,OAAO,CAAC;IAC3E;EACF;EACAy4F,aAAaA,CAACz4F,OAAO,EAAEqyB,IAAI,EAAE;IAC3B,IAAI,IAAI,CAAC8lE,+BAA+B,EAAE;MACxCn4F,OAAO,CAACkQ,SAAS,GAAG,CAAChQ,aAAa,CAACF,OAAO,CAAC,EAAEQ,oBAAoB,CAACR,OAAO,CAAC,CAAC;IAC7E,CAAC,MAAM,IAAI,OAAOqyB,IAAI,KAAK,QAAQ,EAAE;MACnC,MAAM+S,eAAe,GAAG/S,IAAI,YAAYiS,OAAO,GAAGjS,IAAI,GAAGA,IAAI,YAAY8S,cAAc,GAAG9S,IAAI,CAAC+S,eAAe,GAAGxc,SAAS;MAC1H5oB,OAAO,CAACkQ,SAAS,GAAGk1B,eAAe,GAAGA,eAAe,CAACl1B,SAAS,GAAG,EAAE;IACtE;EACF;EACA6oF,YAAYA,CAACvrF,IAAI,EAAEtI,GAAG,EAAE;IACtB,IAAI,CAACmzF,OAAO,CAACr/F,IAAI,CAAC,IAAI66C,UAAU,CAACrmC,IAAI,CAACvE,UAAU,EAAE/D,GAAG,CAAC,CAAC;EACzD;AACF;AACA,MAAM+zF,sBAAsB,GAAG,GAAG;AAClC,MAAMC,iBAAiB,GAAG,IAAI;AAC9B,SAASF,aAAaA,CAAC3mE,IAAI,GAAG,EAAE,EAAE;EAChC,IAAIpiB,QAAQ;EACZ,IAAI3P,OAAO;EACX,IAAI0P,WAAW;EACfqiB,IAAI,GAAGA,IAAI,CAAC5J,IAAI,CAAC,CAAC;EAClB,IAAI4J,IAAI,EAAE;IACR,MAAM8mE,OAAO,GAAG9mE,IAAI,CAAC7J,OAAO,CAAC0wE,iBAAiB,CAAC;IAC/C,MAAME,SAAS,GAAG/mE,IAAI,CAAC7J,OAAO,CAACywE,sBAAsB,CAAC;IACtD,IAAII,cAAc;IAClB,CAACA,cAAc,EAAEppF,QAAQ,CAAC,GAAGkpF,OAAO,GAAG,CAAC,CAAC,GAAG,CAAC9mE,IAAI,CAAC14B,KAAK,CAAC,CAAC,EAAEw/F,OAAO,CAAC,EAAE9mE,IAAI,CAAC14B,KAAK,CAACw/F,OAAO,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC9mE,IAAI,EAAE,EAAE,CAAC;IAC1G,CAAC/xB,OAAO,EAAE0P,WAAW,CAAC,GAAGopF,SAAS,GAAG,CAAC,CAAC,GAAG,CAACC,cAAc,CAAC1/F,KAAK,CAAC,CAAC,EAAEy/F,SAAS,CAAC,EAAEC,cAAc,CAAC1/F,KAAK,CAACy/F,SAAS,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,EAAEC,cAAc,CAAC;EAC5I;EACA,OAAO;IACLppF,QAAQ;IACR3P,OAAO;IACP0P;EACF,CAAC;AACH;AACA,SAASspF,eAAeA,CAACjnE,IAAI,EAAE;EAC7B,MAAMpd,IAAI,GAAG,EAAE;EACf,IAAIod,IAAI,CAACriB,WAAW,EAAE;IACpBiF,IAAI,CAACjc,IAAI,CAAC;MACRgf,OAAO,EAAE,MAAM;MACf/W,IAAI,EAAEoxB,IAAI,CAACriB;IACb,CAAC,CAAC;EACJ,CAAC,MAAM;IACLiF,IAAI,CAACjc,IAAI,CAAC;MACRgf,OAAO,EAAE,UAAU;MACnB/W,IAAI,EAAE;IACR,CAAC,CAAC;EACJ;EACA,IAAIoxB,IAAI,CAAC/xB,OAAO,EAAE;IAChB2U,IAAI,CAACjc,IAAI,CAAC;MACRgf,OAAO,EAAE,SAAS;MAClB/W,IAAI,EAAEoxB,IAAI,CAAC/xB;IACb,CAAC,CAAC;EACJ;EACA,OAAOiW,YAAY,CAACtB,IAAI,CAAC;AAC3B;AAEA,MAAMskF,YAAY,GAAG,aAAa;AAClC,SAASC,4BAA4BA,CAACC,UAAU,EAAEz5F,OAAO,EAAE05F,UAAU,EAAEzzB,iBAAiB,EAAE;EACxF,MAAMt1D,aAAa,GAAGgpF,6BAA6B,CAAC35F,OAAO,CAAC;EAC5D,MAAM2N,IAAI,GAAG,CAAC8J,OAAO,CAAC9G,aAAa,CAAC,CAAC;EACrC,IAAIpR,MAAM,CAACmC,IAAI,CAACukE,iBAAiB,CAAC,CAACltE,MAAM,EAAE;IACzC4U,IAAI,CAAC3U,IAAI,CAAC6vE,UAAU,CAACn+B,+BAA+B,CAACu7B,iBAAiB,EAAE,IAAI,CAAC,EAAE,IAAI,CAAC,CAAC;IACrFt4D,IAAI,CAAC3U,IAAI,CAAC6vE,UAAU,CAAC;MACnB+wB,aAAa,EAAE3iF,UAAU,CAAC1X,MAAM,CAACmC,IAAI,CAACukE,iBAAiB,CAAC,CAAC/oE,GAAG,CAAC4U,KAAK,KAAK;QACrE1I,GAAG,EAAEyhC,yBAAyB,CAAC/4B,KAAK,CAAC;QACrCsC,MAAM,EAAE,IAAI;QACZtZ,KAAK,EAAEkF,OAAO,CAACujC,YAAY,CAACzxB,KAAK,CAAC,GAAG2F,OAAO,CAACzX,OAAO,CAACujC,YAAY,CAACzxB,KAAK,CAAC,CAAC7I,UAAU,CAACjO,QAAQ,CAAC,CAAC,CAAC,GAAGyc,OAAO,CAACzX,OAAO,CAACukC,oBAAoB,CAACzyB,KAAK,CAAC,CAACzR,KAAK,CAACnD,GAAG,CAACsQ,IAAI,IAAIA,IAAI,CAACvE,UAAU,CAACjO,QAAQ,CAAC,CAAC,CAAC,CAACL,IAAI,CAAC,EAAE,CAAC;MACtM,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;EACL;EACA,MAAMk/F,cAAc,GAAG,IAAIpnF,cAAc,CAACinF,UAAU,CAAC7+F,IAAI,EAAE2b,QAAQ,CAAC+iF,YAAY,CAAC,CAACjwF,MAAM,CAACqE,IAAI,CAAC,EAAElG,aAAa,EAAEmN,YAAY,CAAC+E,KAAK,CAAC;EAClIkgF,cAAc,CAACxkF,iBAAiB,CAACikF,eAAe,CAACt5F,OAAO,CAAC,CAAC;EAC1D,MAAM85F,kBAAkB,GAAG,IAAIntF,mBAAmB,CAAC8sF,UAAU,CAAC18F,GAAG,CAAC28F,UAAU,CAAC,CAAC;EAC9E,OAAO,CAACG,cAAc,EAAEC,kBAAkB,CAAC;AAC7C;AACA,MAAMC,uBAAuB,CAAC;EAC5B/wB,QAAQA,CAACluE,KAAK,EAAE;IACd,OAAO,KAAK+vC,yBAAyB,CAAC/vC,KAAK,CAAC,GAAG;EACjD;EACAkG,SAASA,CAACC,IAAI,EAAE;IACd,OAAOA,IAAI,CAACnG,KAAK;EACnB;EACAqG,cAAcA,CAACC,SAAS,EAAE;IACxB,OAAOA,SAAS,CAACC,QAAQ,CAACnE,GAAG,CAACoE,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC,CAAClG,IAAI,CAAC,EAAE,CAAC;EACpE;EACA4G,QAAQA,CAACC,GAAG,EAAE;IACZ,OAAO0nE,gBAAgB,CAAC1nE,GAAG,CAAC;EAC9B;EACAO,mBAAmBA,CAACC,EAAE,EAAE;IACtB,OAAOA,EAAE,CAACC,MAAM,GAAG,IAAI,CAAC+mE,QAAQ,CAAChnE,EAAE,CAACE,SAAS,CAAC,GAAG,GAAG,IAAI,CAAC8mE,QAAQ,CAAChnE,EAAE,CAACE,SAAS,CAAC,GAAGF,EAAE,CAACX,QAAQ,CAACnE,GAAG,CAACoE,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC,CAAClG,IAAI,CAAC,EAAE,CAAC,GAAG,IAAI,CAACquE,QAAQ,CAAChnE,EAAE,CAACG,SAAS,CAAC,EAAE;EACxK;EACAC,gBAAgBA,CAACJ,EAAE,EAAE;IACnB,OAAO,IAAI,CAACgnE,QAAQ,CAAChnE,EAAE,CAACnH,IAAI,CAAC;EAC/B;EACAyH,qBAAqBA,CAACN,EAAE,EAAE;IACxB,OAAO,GAAG,IAAI,CAACgnE,QAAQ,CAAChnE,EAAE,CAACE,SAAS,CAAC,GAAGF,EAAE,CAACX,QAAQ,CAACnE,GAAG,CAACoE,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC,CAAClG,IAAI,CAAC,EAAE,CAAC,GAAG,IAAI,CAACquE,QAAQ,CAAChnE,EAAE,CAACG,SAAS,CAAC,EAAE;EAC9H;EACAE,mBAAmBA,CAACL,EAAE,EAAEd,OAAO,EAAE;IAC/B,OAAO,IAAI,CAAC8nE,QAAQ,CAAChnE,EAAE,CAACnH,IAAI,CAAC;EAC/B;AACF;AACA,MAAMm/F,iBAAiB,GAAG,IAAID,uBAAuB,CAAC,CAAC;AACvD,SAASJ,6BAA6BA,CAAC35F,OAAO,EAAE;EAC9C,OAAOA,OAAO,CAACK,KAAK,CAACnD,GAAG,CAACsQ,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAACm5F,iBAAiB,EAAE,IAAI,CAAC,CAAC,CAACr/F,IAAI,CAAC,EAAE,CAAC;AAChF;AAEA,SAASs/F,wBAAwBA,CAACzjF,QAAQ,EAAExW,OAAO,EAAEuJ,MAAM,EAAE;EAC3D,MAAM;IACJqG,YAAY;IACZsqF;EACF,CAAC,GAAGC,+BAA+B,CAACn6F,OAAO,CAAC;EAC5C,MAAMiJ,UAAU,GAAGmxF,aAAa,CAACp6F,OAAO,CAAC;EACzC,MAAM4O,WAAW,GAAGsrF,YAAY,CAACh9F,GAAG,CAAC8E,EAAE,IAAIuH,MAAM,CAACvH,EAAE,CAACf,IAAI,CAAC,CAAC;EAC3D,MAAMo5F,iBAAiB,GAAG3iF,eAAe,CAAC1X,OAAO,EAAE4P,YAAY,EAAEsqF,YAAY,EAAEtrF,WAAW,EAAE3F,UAAU,CAAC;EACvG,MAAMqxF,sBAAsB,GAAG9jF,QAAQ,CAACzZ,GAAG,CAACs9F,iBAAiB,CAAC;EAC9D,OAAO,CAAC,IAAI1tF,mBAAmB,CAAC2tF,sBAAsB,CAAC,CAAC;AAC1D;AACA,MAAMC,yBAAyB,CAAC;EAC9Bh2D,oBAAoB;EACpBi2D,MAAM;EACN38F,WAAWA,CAAC0mC,oBAAoB,EAAEi2D,MAAM,EAAE;IACxC,IAAI,CAACj2D,oBAAoB,GAAGA,oBAAoB;IAChD,IAAI,CAACi2D,MAAM,GAAGA,MAAM;EACtB;EACAx5F,SAASA,CAACC,IAAI,EAAE;IACd,IAAI,IAAI,CAACu5F,MAAM,CAAC,IAAI,CAACA,MAAM,CAACzhG,MAAM,GAAG,CAAC,CAAC,YAAYqW,YAAY,EAAE;MAC/D,IAAI,CAACorF,MAAM,CAAC,IAAI,CAACA,MAAM,CAACzhG,MAAM,GAAG,CAAC,CAAC,CAACkI,IAAI,IAAIA,IAAI,CAACnG,KAAK;IACxD,CAAC,MAAM;MACL,MAAMmO,UAAU,GAAG,IAAIwqC,eAAe,CAACxyC,IAAI,CAACgI,UAAU,CAACyqC,SAAS,EAAEzyC,IAAI,CAACgI,UAAU,CAAC7D,GAAG,EAAEnE,IAAI,CAACgI,UAAU,CAACyqC,SAAS,EAAEzyC,IAAI,CAACgI,UAAU,CAAC0qC,OAAO,CAAC;MAC1I,IAAI,CAAC6mD,MAAM,CAACxhG,IAAI,CAAC,IAAIoW,YAAY,CAACnO,IAAI,CAACnG,KAAK,EAAEmO,UAAU,CAAC,CAAC;IAC5D;EACF;EACA9H,cAAcA,CAACC,SAAS,EAAE;IACxBA,SAAS,CAACC,QAAQ,CAACpG,OAAO,CAACqG,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC;EACxD;EACAU,QAAQA,CAACC,GAAG,EAAE;IACZ,IAAI,CAACg5F,MAAM,CAACxhG,IAAI,CAAC,IAAIoW,YAAY,CAAC85D,gBAAgB,CAAC1nE,GAAG,CAAC,EAAEA,GAAG,CAACyH,UAAU,CAAC,CAAC;EAC3E;EACAlH,mBAAmBA,CAACC,EAAE,EAAE;IACtB,IAAI,CAACw4F,MAAM,CAACxhG,IAAI,CAAC,IAAI,CAACyhG,sBAAsB,CAACz4F,EAAE,CAACE,SAAS,EAAEF,EAAE,CAACg8B,eAAe,IAAIh8B,EAAE,CAACiH,UAAU,CAAC,CAAC;IAChG,IAAI,CAACjH,EAAE,CAACC,MAAM,EAAE;MACdD,EAAE,CAACX,QAAQ,CAACpG,OAAO,CAACqG,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC;MAC/C,IAAI,CAAC25F,MAAM,CAACxhG,IAAI,CAAC,IAAI,CAACyhG,sBAAsB,CAACz4F,EAAE,CAACG,SAAS,EAAEH,EAAE,CAACi8B,aAAa,IAAIj8B,EAAE,CAACiH,UAAU,CAAC,CAAC;IAChG;EACF;EACA7G,gBAAgBA,CAACJ,EAAE,EAAE;IACnB,IAAI,CAACw4F,MAAM,CAACxhG,IAAI,CAAC,IAAI,CAACyhG,sBAAsB,CAACz4F,EAAE,CAACnH,IAAI,EAAEmH,EAAE,CAACiH,UAAU,CAAC,CAAC;EACvE;EACA3G,qBAAqBA,CAACN,EAAE,EAAE;IACxB,IAAI,CAACw4F,MAAM,CAACxhG,IAAI,CAAC,IAAI,CAACyhG,sBAAsB,CAACz4F,EAAE,CAACE,SAAS,EAAEF,EAAE,CAACg8B,eAAe,IAAIh8B,EAAE,CAACiH,UAAU,CAAC,CAAC;IAChGjH,EAAE,CAACX,QAAQ,CAACpG,OAAO,CAACqG,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC;IAC/C,IAAI,CAAC25F,MAAM,CAACxhG,IAAI,CAAC,IAAI,CAACyhG,sBAAsB,CAACz4F,EAAE,CAACG,SAAS,EAAEH,EAAE,CAACi8B,aAAa,IAAIj8B,EAAE,CAACiH,UAAU,CAAC,CAAC;EAChG;EACA5G,mBAAmBA,CAACL,EAAE,EAAE;IACtB,IAAI,CAACw4F,MAAM,CAACxhG,IAAI,CAAC,IAAI,CAACyhG,sBAAsB,CAACz4F,EAAE,CAACnH,IAAI,EAAEmH,EAAE,CAACiH,UAAU,EAAE,IAAI,CAACs7B,oBAAoB,CAACviC,EAAE,CAACnH,IAAI,CAAC,CAAC,CAAC;EAC3G;EACA4/F,sBAAsBA,CAAC5/F,IAAI,EAAEoO,UAAU,EAAEqG,iBAAiB,EAAE;IAC1D,OAAO,IAAID,gBAAgB,CAACw7B,yBAAyB,CAAChwC,IAAI,EAAE,KAAK,CAAC,EAAEoO,UAAU,EAAEqG,iBAAiB,CAAC;EACpG;AACF;AACA,SAAS6qF,+BAA+BA,CAACn6F,OAAO,EAAE;EAChD,MAAMw6F,MAAM,GAAG,EAAE;EACjB,MAAMR,iBAAiB,GAAG,IAAIO,yBAAyB,CAACv6F,OAAO,CAACukC,oBAAoB,EAAEi2D,MAAM,CAAC;EAC7Fx6F,OAAO,CAACK,KAAK,CAACpF,OAAO,CAACuS,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAACm5F,iBAAiB,CAAC,CAAC;EAC5D,OAAOU,oBAAoB,CAACF,MAAM,CAAC;AACrC;AACA,SAASJ,aAAaA,CAACp6F,OAAO,EAAE;EAC9B,MAAM26F,SAAS,GAAG36F,OAAO,CAACK,KAAK,CAAC,CAAC,CAAC;EAClC,MAAMu6F,OAAO,GAAG56F,OAAO,CAACK,KAAK,CAACL,OAAO,CAACK,KAAK,CAACtH,MAAM,GAAG,CAAC,CAAC;EACvD,OAAO,IAAI06C,eAAe,CAACknD,SAAS,CAAC1xF,UAAU,CAACyqC,SAAS,EAAEknD,OAAO,CAAC3xF,UAAU,CAAC7D,GAAG,EAAEu1F,SAAS,CAAC1xF,UAAU,CAACyqC,SAAS,EAAEinD,SAAS,CAAC1xF,UAAU,CAAC0qC,OAAO,CAAC;AAClJ;AACA,SAAS+mD,oBAAoBA,CAACF,MAAM,EAAE;EACpC,MAAM5qF,YAAY,GAAG,EAAE;EACvB,MAAMsqF,YAAY,GAAG,EAAE;EACvB,IAAIM,MAAM,CAAC,CAAC,CAAC,YAAYnrF,gBAAgB,EAAE;IACzCO,YAAY,CAAC5W,IAAI,CAAC6hG,sBAAsB,CAACL,MAAM,CAAC,CAAC,CAAC,CAACvxF,UAAU,CAACmmB,KAAK,CAAC,CAAC;EACvE;EACA,KAAK,IAAIj1B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqgG,MAAM,CAACzhG,MAAM,EAAEoB,CAAC,EAAE,EAAE;IACtC,MAAM4zB,IAAI,GAAGysE,MAAM,CAACrgG,CAAC,CAAC;IACtB,IAAI4zB,IAAI,YAAY3e,YAAY,EAAE;MAChCQ,YAAY,CAAC5W,IAAI,CAAC+0B,IAAI,CAAC;IACzB,CAAC,MAAM;MACLmsE,YAAY,CAAClhG,IAAI,CAAC+0B,IAAI,CAAC;MACvB,IAAIysE,MAAM,CAACrgG,CAAC,GAAG,CAAC,CAAC,YAAYkV,gBAAgB,EAAE;QAC7CO,YAAY,CAAC5W,IAAI,CAAC6hG,sBAAsB,CAACL,MAAM,CAACrgG,CAAC,GAAG,CAAC,CAAC,CAAC8O,UAAU,CAAC7D,GAAG,CAAC,CAAC;MACzE;IACF;EACF;EACA,IAAIo1F,MAAM,CAACA,MAAM,CAACzhG,MAAM,GAAG,CAAC,CAAC,YAAYsW,gBAAgB,EAAE;IACzDO,YAAY,CAAC5W,IAAI,CAAC6hG,sBAAsB,CAACL,MAAM,CAACA,MAAM,CAACzhG,MAAM,GAAG,CAAC,CAAC,CAACkQ,UAAU,CAAC7D,GAAG,CAAC,CAAC;EACrF;EACA,OAAO;IACLwK,YAAY;IACZsqF;EACF,CAAC;AACH;AACA,SAASW,sBAAsBA,CAAC7gE,QAAQ,EAAE;EACxC,OAAO,IAAI5qB,YAAY,CAAC,EAAE,EAAE,IAAIqkC,eAAe,CAACzZ,QAAQ,EAAEA,QAAQ,CAAC,CAAC;AACtE;AAEA,MAAM8gE,oBAAoB,GAAG,mBAAmB;AAChD,MAAMC,sBAAsB,GAAG,OAAO;AACtC,MAAMC,uBAAuB,GAAG,WAAW;AAC3C,MAAMC,MAAM,GAAG,QAAQ;AACvB,MAAMC,8BAA8B,GAAG,MAAM;AAC7C,SAASC,yBAAyBA,CAACC,KAAK,EAAE;EACxC,OAAO,GAAGF,8BAA8B,GAAGE,KAAK,EAAE,CAACnzE,WAAW,CAAC,CAAC;AAClE;AACA,SAASozE,mBAAmBA,CAAC7kF,QAAQ,EAAE;EACrC,OAAO,IAAI/D,cAAc,CAAC+D,QAAQ,CAAC3b,IAAI,EAAE+tB,SAAS,EAAEnhB,aAAa,EAAEmhB,SAAS,EAAEpS,QAAQ,CAACvN,UAAU,CAAC;AACpG;AACA,SAASqyF,iBAAiBA,CAACpgC,GAAG,EAAE;EAC9B,MAAMqgC,mBAAmB,GAAGrgC,GAAG,CAACzB,uBAAuB,CAACl/D,OAAO,CAAC,eAAe,EAAE,GAAG,CAAC,CAAC0tB,WAAW,CAAC,CAAC,GAAG,GAAG;EACzG,MAAMuzE,gCAAgC,GAAG,IAAI//F,GAAG,CAAC,CAAC;EAClD,MAAMggG,uBAAuB,GAAG,IAAIhgG,GAAG,CAAC,CAAC;EACzC,MAAMigG,wBAAwB,GAAG,IAAIjgG,GAAG,CAAC,CAAC;EAC1C,MAAM+sC,QAAQ,GAAG,IAAI/sC,GAAG,CAAC,CAAC;EAC1B,KAAK,MAAMggC,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAAC62B,GAAG,CAAC,CAAC,EAAE;MAC3B,IAAIn/C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC2J,kBAAkB,IAAIx8C,EAAE,CAACy1C,WAAW,KAAK,IAAI,EAAE;QACpE,MAAMlrB,UAAU,GAAG89D,gCAAgC,CAAC1+F,GAAG,CAACqW,EAAE,CAACy1C,WAAW,CAAC,IAAI,EAAE;QAC7ElrB,UAAU,CAAC1kC,IAAI,CAACma,EAAE,CAAC;QACnBqoF,gCAAgC,CAACz+F,GAAG,CAACoW,EAAE,CAACy1C,WAAW,EAAElrB,UAAU,CAAC;MAClE,CAAC,MAAM,IAAIvqB,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACsL,cAAc,EAAE;QAC5CmqC,uBAAuB,CAAC1+F,GAAG,CAACoW,EAAE,CAAC0f,MAAM,EAAE1f,EAAE,CAAC;MAC5C,CAAC,MAAM,IAAIA,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACkF,cAAc,IAAI/3C,EAAE,CAACuG,KAAK,KAAK6sC,iBAAiB,CAACsa,aAAa,EAAE;QAC5F,MAAMjyD,WAAW,GAAG8sF,wBAAwB,CAAC5+F,GAAG,CAACqW,EAAE,CAAC0f,MAAM,CAAC,IAAI,EAAE;QACjEjkB,WAAW,CAAC5V,IAAI,CAACma,EAAE,CAAC;QACpBuoF,wBAAwB,CAAC3+F,GAAG,CAACoW,EAAE,CAAC0f,MAAM,EAAEjkB,WAAW,CAAC;MACtD,CAAC,MAAM,IAAIuE,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACqK,WAAW,EAAE;QACzC7nB,QAAQ,CAACzrC,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC;MAC3B;IACF;EACF;EACA,MAAMwoF,mBAAmB,GAAG,IAAIlgG,GAAG,CAAC,CAAC;EACrC,MAAMmgG,mBAAmB,GAAG,IAAIngG,GAAG,CAAC,CAAC;EACrC,KAAK,MAAMggC,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACqK,WAAW,EAAE;QAClC,IAAIl9C,EAAE,CAACqkD,kBAAkB,KAAK,IAAI,EAAE;UAClC,MAAM;YACJqkC,OAAO;YACP7pF;UACF,CAAC,GAAG8pF,cAAc,CAAC5gC,GAAG,EAAEqgC,mBAAmB,EAAE/yD,QAAQ,EAAEr1B,EAAE,CAAC;UAC1D,IAAIA,EAAE,CAACokD,SAAS,KAAK,IAAI,EAAE;YACzB,MAAMwkC,SAAS,GAAG7gC,GAAG,CAACX,QAAQ,CAACshC,OAAO,EAAE7pF,UAAU,CAAC;YACnD4pF,mBAAmB,CAAC7+F,GAAG,CAACoW,EAAE,CAACokD,SAAS,EAAEwkC,SAAS,CAAC;UAClD,CAAC,MAAM;YACL7gC,GAAG,CAACP,kBAAkB,CAAC3hE,IAAI,CAAC,GAAGgZ,UAAU,CAAC;YAC1C2pF,mBAAmB,CAAC5+F,GAAG,CAACoW,EAAE,CAACy1C,WAAW,EAAEizC,OAAO,CAAC;YAChD,MAAMG,oBAAoB,GAAGR,gCAAgC,CAAC1+F,GAAG,CAACqW,EAAE,CAACy1C,WAAW,CAAC;YACjF,IAAIozC,oBAAoB,KAAKpzE,SAAS,EAAE;cACtC,KAAK,MAAM5uB,IAAI,IAAIgiG,oBAAoB,EAAE;gBACvChiG,IAAI,CAAC6H,UAAU,GAAGg6F,OAAO,CAAC7uF,KAAK,CAAC,CAAC;cACnC;YACF;UACF;QACF;QACA8kD,MAAM,CAACiB,MAAM,CAAC5/C,EAAE,CAAC;MACnB;IACF;EACF;EACA,KAAK,MAAMsoB,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAM2hC,IAAI,IAAIxgE,IAAI,CAACo/B,MAAM,EAAE;MAC9B,IAAIpH,sBAAsB,CAACwoC,IAAI,CAAC,EAAE;QAChC,MAAMl6E,cAAc,GAAG05E,uBAAuB,CAAC3+F,GAAG,CAACm/F,IAAI,CAACp0C,IAAI,CAAC;QAC7D,IAAI9lC,cAAc,KAAK6G,SAAS,EAAE;UAChC;QACF;QACA,IAAIszE,eAAe,GAAGR,wBAAwB,CAAC5+F,GAAG,CAACm/F,IAAI,CAACp0C,IAAI,CAAC;QAC7D,IAAIq0C,eAAe,KAAKtzE,SAAS,EAAE;UACjC,MAAM,IAAIrvB,KAAK,CAAC,mGAAmG,CAAC;QACtH;QACA,MAAM4iG,iBAAiB,GAAG,IAAI9hD,GAAG,CAAC,CAAC;QACnC6hD,eAAe,GAAGA,eAAe,CAACxhF,MAAM,CAAC0hF,QAAQ,IAAI;UACnD,MAAM96B,IAAI,GAAG66B,iBAAiB,CAACj+F,GAAG,CAACk+F,QAAQ,CAACvhG,IAAI,CAAC;UACjDshG,iBAAiB,CAAC//C,GAAG,CAACggD,QAAQ,CAACvhG,IAAI,CAAC;UACpC,OAAO,CAACymE,IAAI;QACd,CAAC,CAAC;QACF,MAAM+6B,mBAAmB,GAAGH,eAAe,CAACl2B,OAAO,CAACo2B,QAAQ,IAAI;UAC9D,MAAME,aAAa,GAAGX,mBAAmB,CAAC7+F,GAAG,CAACs/F,QAAQ,CAACl7F,OAAO,CAAC;UAC/D,IAAIo7F,aAAa,KAAK1zE,SAAS,EAAE;YAC/B,MAAM,IAAIrvB,KAAK,CAAC,wDAAwD,CAAC;UAC3E;UACA,OAAO,CAACke,OAAO,CAAC2kF,QAAQ,CAACvhG,IAAI,CAAC,EAAEyhG,aAAa,CAAC;QAChD,CAAC,CAAC;QACFv6E,cAAc,CAACy2C,oBAAoB,GAAG0C,GAAG,CAACX,QAAQ,CAAC,IAAIxmD,gBAAgB,CAACsoF,mBAAmB,CAAC,CAAC;MAC/F;IACF;EACF;EACA,KAAK,MAAM5gE,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACiL,SAAS,EAAE;QAChC,MAAMsrC,QAAQ,GAAGX,mBAAmB,CAAC9+F,GAAG,CAACqW,EAAE,CAACykD,IAAI,CAAC;QACjD,IAAI2kC,QAAQ,KAAK3zE,SAAS,EAAE;UAC1B,MAAM,IAAIrvB,KAAK,CAAC,8JAA8J,CAAC;QACjL;QACA4Z,EAAE,CAAC0kD,YAAY,GAAG0kC,QAAQ;MAC5B;IACF;EACF;AACF;AACA,SAAST,cAAcA,CAAC5gC,GAAG,EAAEqgC,mBAAmB,EAAE/yD,QAAQ,EAAEg0D,SAAS,EAAE;EACrE,MAAMxqF,UAAU,GAAG,EAAE;EACrB,MAAMyqF,sBAAsB,GAAG,IAAIhhG,GAAG,CAAC,CAAC;EACxC,KAAK,MAAMihG,YAAY,IAAIF,SAAS,CAAC9kC,WAAW,EAAE;IAChD,MAAM+N,UAAU,GAAGj9B,QAAQ,CAAC1rC,GAAG,CAAC4/F,YAAY,CAAC;IAC7C,MAAM;MACJb,OAAO,EAAEc,aAAa;MACtB3qF,UAAU,EAAE4qF;IACd,CAAC,GAAGd,cAAc,CAAC5gC,GAAG,EAAEqgC,mBAAmB,EAAE/yD,QAAQ,EAAEi9B,UAAU,CAAC;IAClEzzD,UAAU,CAAChZ,IAAI,CAAC,GAAG4jG,oBAAoB,CAAC;IACxC,MAAMllC,WAAW,GAAG+kC,sBAAsB,CAAC3/F,GAAG,CAAC2oE,UAAU,CAACjO,kBAAkB,CAAC,IAAI,EAAE;IACnFE,WAAW,CAAC1+D,IAAI,CAAC2jG,aAAa,CAAC;IAC/BF,sBAAsB,CAAC1/F,GAAG,CAAC0oE,UAAU,CAACjO,kBAAkB,EAAEE,WAAW,CAAC;EACxE;EACAmlC,mBAAmB,CAACL,SAAS,EAAEC,sBAAsB,CAAC;EACtDD,SAAS,CAACjzF,MAAM,GAAG,IAAI9N,GAAG,CAAC,CAAC,GAAG+gG,SAAS,CAACjzF,MAAM,CAACyK,OAAO,CAAC,CAAC,CAAC,CAACsgF,IAAI,CAAC,CAAC,CAAC;EAClE,MAAMuH,OAAO,GAAGrlF,QAAQ,CAAC0kD,GAAG,CAAChC,IAAI,CAAC5+C,UAAU,CAACygF,sBAAsB,CAAC,CAAC;EACrE,MAAMrB,UAAU,GAAGoD,sBAAsB,CAAC5hC,GAAG,CAAChC,IAAI,EAAEsjC,SAAS,CAACx8F,OAAO,CAACC,EAAE,EAAEs7F,mBAAmB,EAAErgC,GAAG,CAACxB,kBAAkB,CAAC;EACtH,IAAIqjC,WAAW,GAAGn0E,SAAS;EAC3B,IAAI4zE,SAAS,CAAC/kC,mBAAmB,IAAI+kC,SAAS,CAAClsC,oBAAoB,CAACvqD,IAAI,GAAG,CAAC,EAAE;IAC5E,MAAMuqD,oBAAoB,GAAG/wD,MAAM,CAACy9F,WAAW,CAAC,CAAC,GAAGR,SAAS,CAAClsC,oBAAoB,CAACt8C,OAAO,CAAC,CAAC,CAAC,CAACsgF,IAAI,CAAC,CAAC,CAAC;IACrG,MAAMzuB,6BAA6B,GAAGn7B,+BAA+B,CAAC4lB,oBAAoB,EAAE,KAAK,CAAC;IAClG,MAAM2sC,sBAAsB,GAAG,EAAE;IACjC,IAAIT,SAAS,CAAClsC,oBAAoB,CAACvqD,IAAI,GAAG,CAAC,EAAE;MAC3Ck3F,sBAAsB,CAACjkG,IAAI,CAAC6vE,UAAU,CAAChD,6BAA6B,EAAE,IAAI,CAAC,CAAC;IAC9E;IACAk3B,WAAW,GAAG5vF,IAAI,IAAIsJ,UAAU,CAACwE,WAAW,CAACmH,eAAe,CAAC,CAAC9Y,MAAM,CAAC,CAAC6D,IAAI,EAAE,GAAG8vF,sBAAsB,CAAC,CAAC;EACzG;EACAjrF,UAAU,CAAChZ,IAAI,CAAC,GAAGkkG,uBAAuB,CAACV,SAAS,CAACx8F,OAAO,EAAE67F,OAAO,EAAEnC,UAAU,EAAE8C,SAAS,CAACjzF,MAAM,EAAEwzF,WAAW,CAAC,CAAC;EAClH,OAAO;IACLlB,OAAO;IACP7pF;EACF,CAAC;AACH;AACA,SAAS6qF,mBAAmBA,CAACL,SAAS,EAAEC,sBAAsB,EAAE;EAC9D,KAAK,MAAM,CAAChsF,WAAW,EAAEinD,WAAW,CAAC,IAAI+kC,sBAAsB,EAAE;IAC/D,IAAI/kC,WAAW,CAAC3+D,MAAM,KAAK,CAAC,EAAE;MAC5ByjG,SAAS,CAACjzF,MAAM,CAACxM,GAAG,CAAC0T,WAAW,EAAEinD,WAAW,CAAC,CAAC,CAAC,CAAC;IACnD,CAAC,MAAM;MACL8kC,SAAS,CAACjzF,MAAM,CAACxM,GAAG,CAAC0T,WAAW,EAAEgH,OAAO,CAAC,GAAGwjF,MAAM,GAAGD,uBAAuB,GAAGvqF,WAAW,GAAGwqF,MAAM,EAAE,CAAC,CAAC;MACxGuB,SAAS,CAAClsC,oBAAoB,CAACvzD,GAAG,CAAC0T,WAAW,EAAEsG,UAAU,CAAC2gD,WAAW,CAAC,CAAC;IAC1E;EACF;AACF;AACA,SAASwlC,uBAAuBA,CAACl9F,OAAO,EAAEwW,QAAQ,EAAEkjF,UAAU,EAAEnwF,MAAM,EAAEwzF,WAAW,EAAE;EACnF,MAAMI,YAAY,GAAG59F,MAAM,CAACy9F,WAAW,CAACzzF,MAAM,CAAC;EAC/C,MAAMyI,UAAU,GAAG,CAACqpF,mBAAmB,CAAC7kF,QAAQ,CAAC,EAAEa,MAAM,CAAC+lF,sBAAsB,CAAC,CAAC,EAAE5D,4BAA4B,CAAChjF,QAAQ,EAAExW,OAAO,EAAE05F,UAAU,EAAEyD,YAAY,CAAC,EAAElD,wBAAwB,CAACzjF,QAAQ,EAAExW,OAAO,EAAE0qC,+BAA+B,CAACyyD,YAAY,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;EAClQ,IAAIJ,WAAW,EAAE;IACf/qF,UAAU,CAAChZ,IAAI,CAAC,IAAI2T,mBAAmB,CAAC6J,QAAQ,CAACzZ,GAAG,CAACggG,WAAW,CAACvmF,QAAQ,CAAC,CAAC,CAAC,CAAC;EAC/E;EACA,OAAOxE,UAAU;AACnB;AACA,SAASorF,sBAAsBA,CAAA,EAAG;EAChC,OAAOtmF,UAAU,CAACN,QAAQ,CAACskF,oBAAoB,CAAC,CAAC,CAACtwF,YAAY,CAACiN,OAAO,CAAC,WAAW,EAAExP,WAAW,CAAC,CAAC,CAACqD,GAAG,CAACkL,QAAQ,CAACskF,oBAAoB,CAAC,CAAC;AACvI;AACA,SAASgC,sBAAsBA,CAAC5jC,IAAI,EAAEmkC,SAAS,EAAE9B,mBAAmB,EAAE+B,cAAc,EAAE;EACpF,IAAIziG,IAAI;EACR,MAAM2pD,MAAM,GAAG+2C,mBAAmB;EAClC,IAAI+B,cAAc,EAAE;IAClB,MAAM7jG,MAAM,GAAG0hG,yBAAyB,CAAC,WAAW,CAAC;IACrD,MAAMoC,YAAY,GAAGrkC,IAAI,CAAC5+C,UAAU,CAACkqC,MAAM,CAAC;IAC5C3pD,IAAI,GAAG,GAAGpB,MAAM,GAAGq7C,kBAAkB,CAACuoD,SAAS,CAAC,KAAKE,YAAY,EAAE;EACrE,CAAC,MAAM;IACL,MAAM9jG,MAAM,GAAG0hG,yBAAyB,CAAC32C,MAAM,CAAC;IAChD3pD,IAAI,GAAGq+D,IAAI,CAAC5+C,UAAU,CAAC7gB,MAAM,CAAC;EAChC;EACA,OAAO+c,QAAQ,CAAC3b,IAAI,CAAC;AACvB;AAEA,SAAS2iG,eAAeA,CAACtiC,GAAG,EAAE;EAC5B,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,IAAImjC,WAAW,GAAG,IAAI;IACtB,IAAIp4B,UAAU,GAAG,IAAI;IACrB,MAAMq4B,kBAAkB,GAAG,IAAIjiG,GAAG,CAAC,CAAC;IACpC,MAAMkiG,YAAY,GAAG,IAAIliG,GAAG,CAAC,CAAC;IAC9B,MAAMmiG,oBAAoB,GAAG,IAAIniG,GAAG,CAAC,CAAC;IACtC,KAAK,MAAM0X,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,QAAQ1nD,EAAE,CAACmhC,IAAI;QACb,KAAK0R,MAAM,CAACiL,SAAS;UACnB,IAAI99C,EAAE,CAACjS,OAAO,KAAK,IAAI,EAAE;YACvB,MAAM3H,KAAK,CAAC,sCAAsC,CAAC;UACrD;UACAkkG,WAAW,GAAGtqF,EAAE;UAChB;QACF,KAAK6yC,MAAM,CAACgL,OAAO;UACjBysC,WAAW,GAAG,IAAI;UAClB;QACF,KAAKz3C,MAAM,CAACmL,QAAQ;UAClB,IAAIh+C,EAAE,CAACjS,OAAO,KAAK,IAAI,EAAE;YACvB,MAAM3H,KAAK,CAAC,qCAAqC,CAAC;UACpD;UACA8rE,UAAU,GAAGlyD,EAAE;UACf;QACF,KAAK6yC,MAAM,CAACkL,MAAM;UAChBmU,UAAU,GAAG,IAAI;UACjB;QACF,KAAKrf,MAAM,CAACvpB,IAAI;UACd,IAAIghE,WAAW,KAAK,IAAI,EAAE;YACxBC,kBAAkB,CAAC3gG,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAE41C,WAAW,CAAC;YAC5CE,YAAY,CAAC5gG,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAEwd,UAAU,CAAC;YACrC,IAAIlyD,EAAE,CAAC43C,cAAc,KAAK,IAAI,EAAE;cAC9B,MAAM8yC,gBAAgB,GAAG3lC,sBAAsB,CAACgD,GAAG,CAAC5B,cAAc,CAAC,CAAC,EAAEnmD,EAAE,CAAC43C,cAAc,EAAE,CAAC53C,EAAE,CAAC6hD,YAAY,CAAC,CAAC;cAC3GlD,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAE0qF,gBAAgB,CAAC;cACpCD,oBAAoB,CAAC7gG,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAEg2C,gBAAgB,CAAC;YACrD,CAAC,MAAM;cACL/rC,MAAM,CAACiB,MAAM,CAAC5/C,EAAE,CAAC;YACnB;UACF;UACA;MACJ;IACF;IACA,KAAK,MAAMA,EAAE,IAAIsoB,IAAI,CAACq/B,MAAM,EAAE;MAC5B,QAAQ3nD,EAAE,CAACmhC,IAAI;QACb,KAAK0R,MAAM,CAACmC,eAAe;UACzB,IAAI,CAACu1C,kBAAkB,CAACx/F,GAAG,CAACiV,EAAE,CAAC0f,MAAM,CAAC,EAAE;YACtC;UACF;UACA,MAAMirE,MAAM,GAAGJ,kBAAkB,CAAC5gG,GAAG,CAACqW,EAAE,CAAC0f,MAAM,CAAC;UAChD,MAAMkrE,KAAK,GAAGJ,YAAY,CAAC7gG,GAAG,CAACqW,EAAE,CAAC0f,MAAM,CAAC;UACzC,MAAMk4B,cAAc,GAAG6yC,oBAAoB,CAAC9gG,GAAG,CAACqW,EAAE,CAAC0f,MAAM,CAAC;UAC1D,MAAMmrE,SAAS,GAAGD,KAAK,GAAGA,KAAK,CAAC78F,OAAO,GAAG48F,MAAM,CAAC58F,OAAO;UACxD,MAAM+pD,cAAc,GAAG8yC,KAAK,GAAGz3C,uBAAuB,CAAC23C,eAAe,GAAG33C,uBAAuB,CAACsa,QAAQ;UACzG,MAAMtO,GAAG,GAAG,EAAE;UACd,KAAK,IAAIn4D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgZ,EAAE,CAAC+0C,aAAa,CAACt5C,WAAW,CAAC7V,MAAM,EAAEoB,CAAC,EAAE,EAAE;YAC5D,MAAMgT,IAAI,GAAGgG,EAAE,CAAC+0C,aAAa,CAACt5C,WAAW,CAACzU,CAAC,CAAC;YAC5Cm4D,GAAG,CAACt5D,IAAI,CAAC4xD,sBAAsB,CAACozC,SAAS,EAAEF,MAAM,CAACj2C,IAAI,EAAEi2C,MAAM,CAACj2C,IAAI,EAAEi2C,MAAM,CAAChzC,MAAM,EAAE39C,IAAI,EAAE49C,cAAc,EAAElD,IAAI,IAAI,IAAI,EAAE10C,EAAE,CAAC+0C,aAAa,CAACE,gBAAgB,CAACjuD,CAAC,CAAC,IAAI,IAAI,EAAE8wD,cAAc,EAAE1E,iBAAiB,CAAC4V,QAAQ,EAAE,EAAE,EAAEhvD,IAAI,CAAClE,UAAU,IAAIkK,EAAE,CAAClK,UAAU,CAAC,CAAC;UAC1P;UACA6oD,MAAM,CAACe,eAAe,CAAC1/C,EAAE,EAAEm/C,GAAG,CAAC;UAC/B,IAAIvH,cAAc,KAAKniC,SAAS,EAAE;YAChCmiC,cAAc,CAACrzB,OAAO,GAAGvkB,EAAE,CAAC+0C,aAAa,CAACxwB,OAAO;UACnD;UACA;MACJ;IACF;EACF;AACF;AAEA,SAASwmE,aAAaA,CAAChjC,GAAG,EAAE;EAC1B,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,QAAQ1nD,EAAE,CAACmhC,IAAI;QACb,KAAK0R,MAAM,CAAC4K,YAAY;QACxB,KAAK5K,MAAM,CAACyL,iBAAiB;QAC7B,KAAKzL,MAAM,CAAC0L,uBAAuB;QACnC,KAAK1L,MAAM,CAACtjB,QAAQ;UAClB,IAAI,CAACpwB,KAAK,CAACC,OAAO,CAACY,EAAE,CAACygD,SAAS,CAAC,EAAE;YAChC,MAAM,IAAIr6D,KAAK,CAAC,yDAAyD,CAAC;UAC5E;UACA4Z,EAAE,CAACg0C,YAAY,IAAIh0C,EAAE,CAACygD,SAAS,CAAC76D,MAAM;UACtC,IAAIoa,EAAE,CAACygD,SAAS,CAAC76D,MAAM,GAAG,CAAC,EAAE;YAC3B,MAAM66D,SAAS,GAAGuqC,kBAAkB,CAAChrF,EAAE,CAACygD,SAAS,CAAC;YAClDzgD,EAAE,CAACygD,SAAS,GAAGsH,GAAG,CAACX,QAAQ,CAAC3G,SAAS,CAAC;UACxC,CAAC,MAAM;YACLzgD,EAAE,CAACygD,SAAS,GAAG,IAAI;UACrB;UACA;MACJ;IACF;EACF;AACF;AACA,SAASuqC,kBAAkBA,CAACtsE,IAAI,EAAE;EAChC,MAAMusE,SAAS,GAAG,EAAE;EACpB,KAAK,MAAMrsE,GAAG,IAAIF,IAAI,EAAE;IACtBusE,SAAS,CAACplG,IAAI,CAACye,OAAO,CAACsa,GAAG,CAACl3B,IAAI,CAAC,EAAE4c,OAAO,CAACsa,GAAG,CAACc,MAAM,CAAC,CAAC;EACxD;EACA,OAAO9b,UAAU,CAACqnF,SAAS,CAAC;AAC9B;AAEA,SAASC,oBAAoBA,CAACnjC,GAAG,EAAE;EACjC,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,IAAIgkC,eAAe,GAAG73C,SAAS,CAACiO,IAAI;IACpC,KAAK,MAAMvhD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC4K,YAAY,EAAE;QACnC;MACF;MACA,IAAIz9C,EAAE,CAACu2C,SAAS,KAAK40C,eAAe,EAAE;QACpCxsC,MAAM,CAACsB,YAAY,CAAC2C,iBAAiB,CAAC5iD,EAAE,CAACu2C,SAAS,CAAC,EAAEv2C,EAAE,CAAC;QACxDmrF,eAAe,GAAGnrF,EAAE,CAACu2C,SAAS;MAChC;IACF;EACF;AACF;AAEA,SAASjxD,KAAKA,CAACqC,KAAK,EAAE;EACpB,MAAM+kE,MAAM,GAAG,EAAE;EACjB,IAAI1lE,CAAC,GAAG,CAAC;EACT,IAAIokG,UAAU,GAAG,CAAC;EAClB,IAAItiD,KAAK,GAAG,CAAC;EACb,IAAIuiD,UAAU,GAAG,CAAC;EAClB,IAAIC,SAAS,GAAG,CAAC;EACjB,IAAIC,WAAW,GAAG,IAAI;EACtB,OAAOvkG,CAAC,GAAGW,KAAK,CAAC/B,MAAM,EAAE;IACvB,MAAMqwB,KAAK,GAAGtuB,KAAK,CAACouB,UAAU,CAAC/uB,CAAC,EAAE,CAAC;IACnC,QAAQivB,KAAK;MACX,KAAK,EAAE;QACLm1E,UAAU,EAAE;QACZ;MACF,KAAK,EAAE;QACLA,UAAU,EAAE;QACZ;MACF,KAAK,EAAE;QACL,IAAItiD,KAAK,KAAK,CAAC,EAAE;UACfA,KAAK,GAAG,EAAE;QACZ,CAAC,MAAM,IAAIA,KAAK,KAAK,EAAE,IAAInhD,KAAK,CAACouB,UAAU,CAAC/uB,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;UACzD8hD,KAAK,GAAG,CAAC;QACX;QACA;MACF,KAAK,EAAE;QACL,IAAIA,KAAK,KAAK,CAAC,EAAE;UACfA,KAAK,GAAG,EAAE;QACZ,CAAC,MAAM,IAAIA,KAAK,KAAK,EAAE,IAAInhD,KAAK,CAACouB,UAAU,CAAC/uB,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;UACzD8hD,KAAK,GAAG,CAAC;QACX;QACA;MACF,KAAK,EAAE;QACL,IAAI,CAACyiD,WAAW,IAAIH,UAAU,KAAK,CAAC,IAAItiD,KAAK,KAAK,CAAC,EAAE;UACnDyiD,WAAW,GAAGC,SAAS,CAAC7jG,KAAK,CAAC83C,SAAS,CAAC6rD,SAAS,EAAEtkG,CAAC,GAAG,CAAC,CAAC,CAACsuB,IAAI,CAAC,CAAC,CAAC;UACjE+1E,UAAU,GAAGrkG,CAAC;QAChB;QACA;MACF,KAAK,EAAE;QACL,IAAIukG,WAAW,IAAIF,UAAU,GAAG,CAAC,IAAID,UAAU,KAAK,CAAC,IAAItiD,KAAK,KAAK,CAAC,EAAE;UACpE,MAAM2iD,QAAQ,GAAG9jG,KAAK,CAAC83C,SAAS,CAAC4rD,UAAU,EAAErkG,CAAC,GAAG,CAAC,CAAC,CAACsuB,IAAI,CAAC,CAAC;UAC1Do3C,MAAM,CAAC7mE,IAAI,CAAC0lG,WAAW,EAAEE,QAAQ,CAAC;UAClCH,SAAS,GAAGtkG,CAAC;UACbqkG,UAAU,GAAG,CAAC;UACdE,WAAW,GAAG,IAAI;QACpB;QACA;IACJ;EACF;EACA,IAAIA,WAAW,IAAIF,UAAU,EAAE;IAC7B,MAAMI,QAAQ,GAAG9jG,KAAK,CAACnB,KAAK,CAAC6kG,UAAU,CAAC,CAAC/1E,IAAI,CAAC,CAAC;IAC/Co3C,MAAM,CAAC7mE,IAAI,CAAC0lG,WAAW,EAAEE,QAAQ,CAAC;EACpC;EACA,OAAO/+B,MAAM;AACf;AACA,SAAS8+B,SAASA,CAAC7jG,KAAK,EAAE;EACxB,OAAOA,KAAK,CAACP,OAAO,CAAC,aAAa,EAAEurE,CAAC,IAAI;IACvC,OAAOA,CAAC,CAACzrE,MAAM,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGyrE,CAAC,CAACzrE,MAAM,CAAC,CAAC,CAAC;EACxC,CAAC,CAAC,CAACU,WAAW,CAAC,CAAC;AAClB;AACA,SAAS8jG,oBAAoBA,CAAC3jC,GAAG,EAAE;EACjC,MAAMvsD,QAAQ,GAAG,IAAIlT,GAAG,CAAC,CAAC;EAC1B,KAAK,MAAMggC,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAIpH,sBAAsB,CAACtgD,EAAE,CAAC,EAAE;QAC9BxE,QAAQ,CAAC5R,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC;MAC3B;IACF;EACF;EACA,KAAK,MAAMsoB,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC2J,kBAAkB,IAAIx8C,EAAE,CAACw1C,WAAW,KAAKtC,WAAW,CAACsD,SAAS,IAAIkI,eAAe,CAAC1+C,EAAE,CAACtR,UAAU,CAAC,EAAE;QACvH,MAAMgxB,MAAM,GAAGlkB,QAAQ,CAAC7R,GAAG,CAACqW,EAAE,CAAC0f,MAAM,CAAC;QACtC,IAAIA,MAAM,KAAKjK,SAAS,KAAKiK,MAAM,CAACyhB,IAAI,KAAK0R,MAAM,CAACtjB,QAAQ,IAAI7P,MAAM,CAACyhB,IAAI,KAAK0R,MAAM,CAACyL,iBAAiB,IAAI5+B,MAAM,CAACyhB,IAAI,KAAK0R,MAAM,CAAC0L,uBAAuB,CAAC,IAAI7+B,MAAM,CAAC21B,YAAY,KAAK5B,YAAY,CAACk4C,UAAU,EAAE;UAC9M;QACF;QACA,IAAI3rF,EAAE,CAACtY,IAAI,KAAK,OAAO,EAAE;UACvB,MAAMkkG,YAAY,GAAGtmG,KAAK,CAAC0a,EAAE,CAACtR,UAAU,CAAC/G,KAAK,CAAC;UAC/C,KAAK,IAAIX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4kG,YAAY,CAAChmG,MAAM,GAAG,CAAC,EAAEoB,CAAC,IAAI,CAAC,EAAE;YACnD23D,MAAM,CAACsB,YAAY,CAACiD,0BAA0B,CAACljD,EAAE,CAAC0f,MAAM,EAAEwzB,WAAW,CAACiX,aAAa,EAAE,IAAI,EAAEyhC,YAAY,CAAC5kG,CAAC,CAAC,EAAEsd,OAAO,CAACsnF,YAAY,CAAC5kG,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,EAAEyE,eAAe,CAAC+9D,KAAK,CAAC,EAAExpD,EAAE,CAAC;UACnL;UACA2+C,MAAM,CAACiB,MAAM,CAAC5/C,EAAE,CAAC;QACnB,CAAC,MAAM,IAAIA,EAAE,CAACtY,IAAI,KAAK,OAAO,EAAE;UAC9B,MAAMmkG,aAAa,GAAG7rF,EAAE,CAACtR,UAAU,CAAC/G,KAAK,CAAC2tB,IAAI,CAAC,CAAC,CAACoB,KAAK,CAAC,MAAM,CAAC;UAC9D,KAAK,MAAMo1E,WAAW,IAAID,aAAa,EAAE;YACvCltC,MAAM,CAACsB,YAAY,CAACiD,0BAA0B,CAACljD,EAAE,CAAC0f,MAAM,EAAEwzB,WAAW,CAACgX,SAAS,EAAE,IAAI,EAAE4hC,WAAW,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAErgG,eAAe,CAACi+D,IAAI,CAAC,EAAE1pD,EAAE,CAAC;UAClJ;UACA2+C,MAAM,CAACiB,MAAM,CAAC5/C,EAAE,CAAC;QACnB;MACF;IACF;EACF;AACF;AAEA,SAAS+rF,yBAAyBA,CAAChkC,GAAG,EAAE;EACtCikC,cAAc,CAACjkC,GAAG,CAACtD,IAAI,EAAEsD,GAAG,CAAC54B,aAAa,EAAE;IAC1Ch+B,KAAK,EAAE;EACT,CAAC,EAAE42D,GAAG,CAAC/B,aAAa,KAAK/S,iBAAiB,CAACsW,yBAAyB,CAAC;AACvE;AACA,SAASyiC,cAAcA,CAAC1jE,IAAI,EAAEi4D,QAAQ,EAAE33B,KAAK,EAAE5C,aAAa,EAAE;EAC5D,IAAI19B,IAAI,CAACs/B,MAAM,KAAK,IAAI,EAAE;IACxBt/B,IAAI,CAACs/B,MAAM,GAAGt/B,IAAI,CAACy/B,GAAG,CAAChC,IAAI,CAAC5+C,UAAU,CAACw6B,kBAAkB,CAAC,GAAG4+C,QAAQ,IAAIj4D,IAAI,CAACy/B,GAAG,CAAChB,QAAQ,EAAE,CAAC,EAAE,KAAK,CAAC;EACvG;EACA,MAAM5F,QAAQ,GAAG,IAAI74D,GAAG,CAAC,CAAC;EAC1B,KAAK,MAAM0X,EAAE,IAAIsoB,IAAI,CAAC62B,GAAG,CAAC,CAAC,EAAE;IAC3B,QAAQn/C,EAAE,CAACmhC,IAAI;MACb,KAAK0R,MAAM,CAAChZ,QAAQ;MACpB,KAAKgZ,MAAM,CAACmJ,WAAW;QACrB,IAAIh8C,EAAE,CAACw1C,WAAW,KAAKtC,WAAW,CAAC/oB,eAAe,EAAE;UAClDnqB,EAAE,CAACtY,IAAI,GAAG,GAAG,GAAGsY,EAAE,CAACtY,IAAI;QACzB;QACA;MACF,KAAKmrD,MAAM,CAACqJ,SAAS;QACnB,IAAIl8C,EAAE,CAACiiD,aAAa,KAAK,IAAI,EAAE;UAC7B,MAAM7K,aAAa,GAAGp3C,EAAE,CAACtY,IAAI,CAACN,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC;UAC9C4Y,EAAE,CAACiiD,aAAa,GAAG,GAAG35B,IAAI,CAACs/B,MAAM,IAAIxQ,aAAa,KAAK;UACvDp3C,EAAE,CAACiiD,aAAa,GAAGtgB,kBAAkB,CAAC3hC,EAAE,CAACiiD,aAAa,CAAC;QACzD;QACA;MACF,KAAKpP,MAAM,CAACsJ,iBAAiB;QAC3B,IAAIn8C,EAAE,CAACiiD,aAAa,KAAK,IAAI,EAAE;UAC7B;QACF;QACA,IAAI,CAACjiD,EAAE,CAACqiD,YAAY,IAAIriD,EAAE,CAACg3C,UAAU,CAACsE,IAAI,KAAK,IAAI,EAAE;UACnD,MAAM,IAAIl1D,KAAK,CAAC,gCAAgC,CAAC;QACnD;QACA,MAAMgxD,aAAa,GAAGp3C,EAAE,CAACtY,IAAI,CAACN,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC;QAC9C,IAAI4Y,EAAE,CAACqiD,YAAY,EAAE;UACnBriD,EAAE,CAACiiD,aAAa,GAAG,GAAGs+B,QAAQ,IAAInpC,aAAa,qBAAqB;QACtE,CAAC,MAAM;UACLp3C,EAAE,CAACiiD,aAAa,GAAG,GAAG35B,IAAI,CAACs/B,MAAM,IAAI5nD,EAAE,CAAC3Z,GAAG,CAACe,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,IAAIgwD,aAAa,IAAIp3C,EAAE,CAACg3C,UAAU,CAACsE,IAAI,WAAW;QACjH;QACAt7C,EAAE,CAACiiD,aAAa,GAAGtgB,kBAAkB,CAAC3hC,EAAE,CAACiiD,aAAa,CAAC;QACvD;MACF,KAAKpP,MAAM,CAACuJ,QAAQ;QAClB,IAAIp8C,EAAE,CAACiiD,aAAa,KAAK,IAAI,EAAE;UAC7B;QACF;QACA,IAAI,CAACjiD,EAAE,CAACqiD,YAAY,IAAIriD,EAAE,CAACg3C,UAAU,CAACsE,IAAI,KAAK,IAAI,EAAE;UACnD,MAAM,IAAIl1D,KAAK,CAAC,gCAAgC,CAAC;QACnD;QACA,IAAI6lG,SAAS,GAAG,EAAE;QAClB,IAAIjsF,EAAE,CAACwiD,yBAAyB,EAAE;UAChCxiD,EAAE,CAACtY,IAAI,GAAG,IAAIsY,EAAE,CAACtY,IAAI,IAAIsY,EAAE,CAACmiD,oBAAoB,EAAE;UAClD8pC,SAAS,GAAG,WAAW;QACzB;QACA,IAAIjsF,EAAE,CAACqiD,YAAY,EAAE;UACnBriD,EAAE,CAACiiD,aAAa,GAAG,GAAGs+B,QAAQ,IAAI0L,SAAS,GAAGjsF,EAAE,CAACtY,IAAI,qBAAqB;QAC5E,CAAC,MAAM;UACLsY,EAAE,CAACiiD,aAAa,GAAG,GAAG35B,IAAI,CAACs/B,MAAM,IAAI5nD,EAAE,CAAC3Z,GAAG,CAACe,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,IAAI6kG,SAAS,GAAGjsF,EAAE,CAACtY,IAAI,IAAIsY,EAAE,CAACg3C,UAAU,CAACsE,IAAI,WAAW;QACvH;QACAt7C,EAAE,CAACiiD,aAAa,GAAGtgB,kBAAkB,CAAC3hC,EAAE,CAACiiD,aAAa,CAAC;QACvD;MACF,KAAKpP,MAAM,CAACwJ,cAAc;QACxB,IAAIr8C,EAAE,CAACiiD,aAAa,KAAK,IAAI,EAAE;UAC7B;QACF;QACA,IAAIjiD,EAAE,CAACg3C,UAAU,CAACsE,IAAI,KAAK,IAAI,EAAE;UAC/B,MAAM,IAAIl1D,KAAK,CAAC,gCAAgC,CAAC;QACnD;QACA4Z,EAAE,CAACiiD,aAAa,GAAGtgB,kBAAkB,CAAC,GAAGrZ,IAAI,CAACs/B,MAAM,IAAI5nD,EAAE,CAAC3Z,GAAG,CAACe,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,IAAI4Y,EAAE,CAACtY,IAAI,IAAIsY,EAAE,CAACg3C,UAAU,CAACsE,IAAI,WAAW,CAAC;QAC7H;MACF,KAAKzI,MAAM,CAAChjB,QAAQ;QAClBsxB,QAAQ,CAACv3D,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAEw3C,eAAe,CAAC5jE,IAAI,EAAEtoB,EAAE,CAACqD,QAAQ,EAAEulD,KAAK,CAAC,CAAC;QAChE;MACF,KAAK/V,MAAM,CAAC6J,cAAc;QACxB,IAAI,EAAEp0B,IAAI,YAAYs+B,mBAAmB,CAAC,EAAE;UAC1C,MAAM,IAAIxgE,KAAK,CAAC,+CAA+C,CAAC;QAClE;QACA,IAAI4Z,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,KAAK,IAAI,EAAE;UAC3B,MAAM,IAAIl1D,KAAK,CAAC,8BAA8B,CAAC;QACjD;QACA,IAAI4Z,EAAE,CAACkhD,SAAS,KAAK,IAAI,EAAE;UACzB,MAAMA,SAAS,GAAG54B,IAAI,CAACy/B,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAACkhD,SAAS,CAAC;UAClD8qC,cAAc,CAAC9qC,SAAS,EAAE,GAAGq/B,QAAQ,IAAIvgF,EAAE,CAAC4gD,kBAAkB,SAAS5gD,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,GAAG,CAAC,EAAE,EAAEsN,KAAK,EAAE5C,aAAa,CAAC;QACpH;QACAgmC,cAAc,CAAC1jE,IAAI,CAACy/B,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAAC00C,IAAI,CAAC,EAAE,GAAG6rC,QAAQ,IAAIvgF,EAAE,CAAC4gD,kBAAkB,IAAI5gD,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,GAAG,CAAC,EAAE,EAAEsN,KAAK,EAAE5C,aAAa,CAAC;QAC/H;MACF,KAAKnT,MAAM,CAACoL,UAAU;QACpB,IAAI,EAAE31B,IAAI,YAAYs+B,mBAAmB,CAAC,EAAE;UAC1C,MAAM,IAAIxgE,KAAK,CAAC,+CAA+C,CAAC;QAClE;QACA,IAAI4Z,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,KAAK,IAAI,EAAE;UAC3B,MAAM,IAAIl1D,KAAK,CAAC,8BAA8B,CAAC;QACjD;QACA,IAAI4Z,EAAE,CAACgjD,YAAY,KAAK,IAAI,EAAE;UAC5B,MAAMA,YAAY,GAAG16B,IAAI,CAACy/B,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAACgjD,YAAY,CAAC;UACxDgpC,cAAc,CAAChpC,YAAY,EAAE,GAAGu9B,QAAQ,uBAAuBvgF,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAE,EAAEsN,KAAK,EAAE5C,aAAa,CAAC;QACxG;QACA;MACF,KAAKnT,MAAM,CAACyL,iBAAiB;MAC7B,KAAKzL,MAAM,CAAC0L,uBAAuB;MACnC,KAAK1L,MAAM,CAACtjB,QAAQ;QAClB,IAAI,EAAEjH,IAAI,YAAYs+B,mBAAmB,CAAC,EAAE;UAC1C,MAAM,IAAIxgE,KAAK,CAAC,+CAA+C,CAAC;QAClE;QACA,MAAM+lG,SAAS,GAAG7jE,IAAI,CAACy/B,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAAC00C,IAAI,CAAC;QAC7C,IAAI10C,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,KAAK,IAAI,EAAE;UAC3B,MAAM,IAAIl1D,KAAK,CAAC,8BAA8B,CAAC;QACjD;QACA,MAAMirD,MAAM,GAAGrxC,EAAE,CAAC4gD,kBAAkB,CAACh7D,MAAM,KAAK,CAAC,GAAG,EAAE,GAAG,IAAIoa,EAAE,CAAC4gD,kBAAkB,EAAE;QACpForC,cAAc,CAACG,SAAS,EAAE,GAAG5L,QAAQ,GAAGlvC,MAAM,IAAIrxC,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAE,EAAEsN,KAAK,EAAE5C,aAAa,CAAC;QACzF;MACF,KAAKnT,MAAM,CAACkD,SAAS;QACnB/1C,EAAE,CAACtY,IAAI,GAAG0kG,sBAAsB,CAACpsF,EAAE,CAACtY,IAAI,CAAC;QACzC,IAAIs+D,aAAa,EAAE;UACjBhmD,EAAE,CAACtY,IAAI,GAAG2kG,cAAc,CAACrsF,EAAE,CAACtY,IAAI,CAAC;QACnC;QACA;MACF,KAAKmrD,MAAM,CAACoD,SAAS;QACnB,IAAI+P,aAAa,EAAE;UACjBhmD,EAAE,CAACtY,IAAI,GAAG2kG,cAAc,CAACrsF,EAAE,CAACtY,IAAI,CAAC;QACnC;QACA;IACJ;EACF;EACA,KAAK,MAAMsY,EAAE,IAAIsoB,IAAI,CAAC62B,GAAG,CAAC,CAAC,EAAE;IAC3BvD,oBAAoB,CAAC57C,EAAE,EAAEhG,IAAI,IAAI;MAC/B,IAAI,EAAEA,IAAI,YAAYigD,gBAAgB,CAAC,IAAIjgD,IAAI,CAACtS,IAAI,KAAK,IAAI,EAAE;QAC7D;MACF;MACA,IAAI,CAACy5D,QAAQ,CAACp2D,GAAG,CAACiP,IAAI,CAAC06C,IAAI,CAAC,EAAE;QAC5B,MAAM,IAAItuD,KAAK,CAAC,YAAY4T,IAAI,CAAC06C,IAAI,gBAAgB,CAAC;MACxD;MACA16C,IAAI,CAACtS,IAAI,GAAGy5D,QAAQ,CAACx3D,GAAG,CAACqQ,IAAI,CAAC06C,IAAI,CAAC;IACrC,CAAC,CAAC;EACJ;AACF;AACA,SAASw3C,eAAeA,CAAC5jE,IAAI,EAAEjlB,QAAQ,EAAEulD,KAAK,EAAE;EAC9C,IAAIvlD,QAAQ,CAAC3b,IAAI,KAAK,IAAI,EAAE;IAC1B,QAAQ2b,QAAQ,CAAC89B,IAAI;MACnB,KAAK6R,oBAAoB,CAACmG,OAAO;QAC/B91C,QAAQ,CAAC3b,IAAI,GAAG,QAAQkhE,KAAK,CAACz3D,KAAK,EAAE,EAAE;QACvC;MACF,KAAK6hD,oBAAoB,CAAC8gB,UAAU;QAClC,IAAIxrC,IAAI,CAACy/B,GAAG,CAAC/B,aAAa,KAAK/S,iBAAiB,CAACsW,yBAAyB,EAAE;UAC1E,MAAM+iC,YAAY,GAAGjpF,QAAQ,CAACq+B,UAAU,KAAK,KAAK,GAAG,GAAG,GAAG,EAAE;UAC7Dr+B,QAAQ,CAAC3b,IAAI,GAAG,GAAG2b,QAAQ,CAACq+B,UAAU,IAAI4qD,YAAY,IAAI,EAAE1jC,KAAK,CAACz3D,KAAK,EAAE;QAC3E,CAAC,MAAM;UACLkS,QAAQ,CAAC3b,IAAI,GAAG,GAAG2b,QAAQ,CAACq+B,UAAU,KAAKknB,KAAK,CAACz3D,KAAK,EAAE,EAAE;QAC5D;QACA;MACF;QACEkS,QAAQ,CAAC3b,IAAI,GAAG,KAAK,EAAEkhE,KAAK,CAACz3D,KAAK,EAAE;QACpC;IACJ;EACF;EACA,OAAOkS,QAAQ,CAAC3b,IAAI;AACtB;AACA,SAAS0kG,sBAAsBA,CAAC1kG,IAAI,EAAE;EACpC,OAAOA,IAAI,CAACsvB,UAAU,CAAC,IAAI,CAAC,GAAGtvB,IAAI,GAAG8jG,SAAS,CAAC9jG,IAAI,CAAC;AACvD;AACA,SAAS2kG,cAAcA,CAAC3kG,IAAI,EAAE;EAC5B,MAAM6kG,cAAc,GAAG7kG,IAAI,CAAC2tB,OAAO,CAAC,YAAY,CAAC;EACjD,IAAIk3E,cAAc,GAAG,CAAC,CAAC,EAAE;IACvB,OAAO7kG,IAAI,CAAC+3C,SAAS,CAAC,CAAC,EAAE8sD,cAAc,CAAC;EAC1C;EACA,OAAO7kG,IAAI;AACb;AAEA,SAAS8kG,2BAA2BA,CAACzkC,GAAG,EAAE;EACxC,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACuJ,QAAQ,IAAIp8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACqJ,SAAS,IAAIl8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACsJ,iBAAiB,IAAIn8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACwJ,cAAc,EAAE;QAC5IowC,sBAAsB,CAACzsF,EAAE,CAACu8C,UAAU,CAAC;MACvC;IACF;IACAkwC,sBAAsB,CAACnkE,IAAI,CAACq/B,MAAM,CAAC;EACrC;AACF;AACA,SAAS8kC,sBAAsBA,CAACttC,GAAG,EAAE;EACnC,KAAK,MAAMn/C,EAAE,IAAIm/C,GAAG,EAAE;IACpB,IAAIn/C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC7wC,SAAS,IAAI,EAAEhC,EAAE,CAACmkC,SAAS,YAAY3qC,mBAAmB,CAAC,IAAI,EAAEwG,EAAE,CAACmkC,SAAS,CAACnqC,IAAI,YAAYs/C,eAAe,CAAC,EAAE;MACrI;IACF;IACA,MAAMozC,UAAU,GAAG1sF,EAAE,CAACmkC,SAAS,CAACnqC,IAAI,CAACw/C,KAAK;IAC1C,IAAImzC,UAAU,GAAG,IAAI;IACrB,KAAK,IAAIC,SAAS,GAAG5sF,EAAE,CAAC60C,IAAI,EAAE+3C,SAAS,CAACzrD,IAAI,KAAK0R,MAAM,CAACgM,OAAO,IAAI8tC,UAAU,EAAEC,SAAS,GAAGA,SAAS,CAAC/3C,IAAI,EAAE;MACzG+G,oBAAoB,CAACgxC,SAAS,EAAE,CAAC5yF,IAAI,EAAEmB,KAAK,KAAK;QAC/C,IAAI,CAACo9C,cAAc,CAACv+C,IAAI,CAAC,EAAE;UACzB,OAAOA,IAAI;QACb;QACA,IAAI,CAAC2yF,UAAU,EAAE;UACf;QACF;QACA,IAAIxxF,KAAK,GAAGm/C,kBAAkB,CAACC,gBAAgB,EAAE;UAC/C;QACF;QACA,QAAQvgD,IAAI,CAACmnC,IAAI;UACf,KAAK2R,cAAc,CAACyG,WAAW;YAC7Bv/C,IAAI,CAACw/C,KAAK,IAAIkzC,UAAU;YACxB/tC,MAAM,CAACiB,MAAM,CAAC5/C,EAAE,CAAC;YACjB2sF,UAAU,GAAG,KAAK;YAClB;UACF,KAAK75C,cAAc,CAAC4G,cAAc;UAClC,KAAK5G,cAAc,CAAC/iB,SAAS;UAC7B,KAAK+iB,cAAc,CAACmG,mBAAmB;YACrC0zC,UAAU,GAAG,KAAK;YAClB;QACJ;QACA;MACF,CAAC,CAAC;IACJ;EACF;AACF;AAEA,MAAME,aAAa,GAAG,cAAc;AACpC,SAASC,sBAAsBA,CAAC/kC,GAAG,EAAE;EACnC,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,MAAM4lC,mBAAmB,GAAG,IAAI7lD,GAAG,CAAC,CAAC;IACrC,KAAK,MAAMlnC,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC4K,YAAY,IAAIz9C,EAAE,CAAC3Z,GAAG,KAAKwmG,aAAa,EAAE;QAC/D7sF,EAAE,CAACmhC,IAAI,GAAG0R,MAAM,CAACwK,cAAc;QAC/B0vC,mBAAmB,CAAC9jD,GAAG,CAACjpC,EAAE,CAAC00C,IAAI,CAAC;MAClC;MACA,IAAI10C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC2K,UAAU,IAAIuvC,mBAAmB,CAAChiG,GAAG,CAACiV,EAAE,CAAC00C,IAAI,CAAC,EAAE;QACrE10C,EAAE,CAACmhC,IAAI,GAAG0R,MAAM,CAACuK,YAAY;MAC/B;IACF;EACF;AACF;AAEA,SAAS4vC,aAAaA,CAACxxF,QAAQ,EAAEk5C,IAAI,EAAE;EACrC,MAAM/4C,EAAE,GAAGH,QAAQ,CAAC7R,GAAG,CAAC+qD,IAAI,CAAC;EAC7B,IAAI/4C,EAAE,KAAK8Z,SAAS,EAAE;IACpB,MAAM,IAAIrvB,KAAK,CAAC,oDAAoD,CAAC;EACvE;EACA,OAAOuV,EAAE;AACX;AACA,SAASsxF,iBAAiBA,CAACllC,GAAG,EAAE;EAC9B,MAAMvsD,QAAQ,GAAG,IAAIlT,GAAG,CAAC,CAAC;EAC1B,KAAK,MAAM+I,IAAI,IAAI02D,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAI3O,IAAI,CAACq2D,MAAM,EAAE;MAC5B,IAAI,CAACpH,sBAAsB,CAACtgD,EAAE,CAAC,EAAE;QAC/B;MACF;MACAxE,QAAQ,CAAC5R,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC;IAC3B;EACF;EACA,KAAK,MAAMsoB,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI,CAAC1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC4K,YAAY,IAAIz9C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACwK,cAAc,KAAKr9C,EAAE,CAAC0gD,WAAW,EAAE;QAC5F/B,MAAM,CAACuB,WAAW,CAACwB,uBAAuB,CAAC1hD,EAAE,CAAC00C,IAAI,CAAC,EAAE10C,EAAE,CAAC;MAC1D;MACA,IAAI,CAACA,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC2K,UAAU,IAAIx9C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACuK,YAAY,KAAK4vC,aAAa,CAACxxF,QAAQ,EAAEwE,EAAE,CAAC00C,IAAI,CAAC,CAACgM,WAAW,EAAE;QACtH/B,MAAM,CAACsB,YAAY,CAAC0B,sBAAsB,CAAC3hD,EAAE,CAAC00C,IAAI,CAAC,EAAE10C,EAAE,CAAC;MAC1D;IACF;EACF;AACF;AAEA,SAASktF,QAAQA,CAAC/rD,IAAI,EAAE;EACtB,OAAOnhC,EAAE,IAAIA,EAAE,CAACmhC,IAAI,KAAKA,IAAI;AAC/B;AACA,SAASgsD,yBAAyBA,CAAChsD,IAAI,EAAE4T,aAAa,EAAE;EACtD,OAAO/0C,EAAE,IAAI;IACX,OAAOA,EAAE,CAACmhC,IAAI,KAAKA,IAAI,IAAI4T,aAAa,KAAK/0C,EAAE,CAACtR,UAAU,YAAY41B,aAAa;EACrF,CAAC;AACH;AACA,SAAS8oE,qBAAqBA,CAACptF,EAAE,EAAE;EACjC,OAAOA,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACuJ,QAAQ,IAAI,EAAEp8C,EAAE,CAACqiD,YAAY,IAAIriD,EAAE,CAACwiD,yBAAyB,CAAC,IAAIxiD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACwJ,cAAc,IAAIr8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACqJ,SAAS,IAAIl8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACsJ,iBAAiB;AACvM;AACA,SAASkxC,gCAAgCA,CAACrtF,EAAE,EAAE;EAC5C,OAAO,CAACA,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAChZ,QAAQ,IAAI75B,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACgD,cAAc,KAAK,EAAE71C,EAAE,CAACtR,UAAU,YAAY41B,aAAa,CAAC;AACxH;AACA,MAAMgpE,eAAe,GAAG,CAAC;EACvBr2E,IAAI,EAAEjX,EAAE,IAAIA,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACuJ,QAAQ,IAAIp8C,EAAE,CAACqiD,YAAY,IAAIriD,EAAE,CAACwiD;AACnE,CAAC,EAAE;EACDvrC,IAAI,EAAEm2E;AACR,CAAC,CAAC;AACF,MAAMG,eAAe,GAAG,CAAC;EACvBt2E,IAAI,EAAEi2E,QAAQ,CAACr6C,MAAM,CAACsD,QAAQ,CAAC;EAC/B2C,SAAS,EAAE00C;AACb,CAAC,EAAE;EACDv2E,IAAI,EAAEi2E,QAAQ,CAACr6C,MAAM,CAACwD,QAAQ,CAAC;EAC/ByC,SAAS,EAAE00C;AACb,CAAC,EAAE;EACDv2E,IAAI,EAAEi2E,QAAQ,CAACr6C,MAAM,CAACkD,SAAS;AACjC,CAAC,EAAE;EACD9+B,IAAI,EAAEi2E,QAAQ,CAACr6C,MAAM,CAACoD,SAAS;AACjC,CAAC,EAAE;EACDh/B,IAAI,EAAEk2E,yBAAyB,CAACt6C,MAAM,CAAC2D,SAAS,EAAE,IAAI;AACxD,CAAC,EAAE;EACDv/B,IAAI,EAAEk2E,yBAAyB,CAACt6C,MAAM,CAAChZ,QAAQ,EAAE,IAAI;AACvD,CAAC,EAAE;EACD5iB,IAAI,EAAEo2E;AACR,CAAC,EAAE;EACDp2E,IAAI,EAAEk2E,yBAAyB,CAACt6C,MAAM,CAAC2D,SAAS,EAAE,KAAK;AACzD,CAAC,CAAC;AACF,MAAMi3C,oBAAoB,GAAG,CAAC;EAC5Bx2E,IAAI,EAAEk2E,yBAAyB,CAACt6C,MAAM,CAACmJ,WAAW,EAAE,IAAI;AAC1D,CAAC,EAAE;EACD/kC,IAAI,EAAEk2E,yBAAyB,CAACt6C,MAAM,CAACmJ,WAAW,EAAE,KAAK;AAC3D,CAAC,EAAE;EACD/kC,IAAI,EAAEi2E,QAAQ,CAACr6C,MAAM,CAAC2D,SAAS;AACjC,CAAC,EAAE;EACDv/B,IAAI,EAAEi2E,QAAQ,CAACr6C,MAAM,CAACsD,QAAQ,CAAC;EAC/B2C,SAAS,EAAE00C;AACb,CAAC,EAAE;EACDv2E,IAAI,EAAEi2E,QAAQ,CAACr6C,MAAM,CAACwD,QAAQ,CAAC;EAC/ByC,SAAS,EAAE00C;AACb,CAAC,EAAE;EACDv2E,IAAI,EAAEi2E,QAAQ,CAACr6C,MAAM,CAACkD,SAAS;AACjC,CAAC,EAAE;EACD9+B,IAAI,EAAEi2E,QAAQ,CAACr6C,MAAM,CAACoD,SAAS;AACjC,CAAC,CAAC;AACF,MAAMy3C,cAAc,GAAG,IAAIxmD,GAAG,CAAC,CAAC2L,MAAM,CAACuJ,QAAQ,EAAEvJ,MAAM,CAACwJ,cAAc,EAAExJ,MAAM,CAACsJ,iBAAiB,EAAEtJ,MAAM,CAACsD,QAAQ,EAAEtD,MAAM,CAACwD,QAAQ,EAAExD,MAAM,CAACkD,SAAS,EAAElD,MAAM,CAACoD,SAAS,EAAEpD,MAAM,CAAChZ,QAAQ,EAAEgZ,MAAM,CAACgD,cAAc,EAAEhD,MAAM,CAACmJ,WAAW,EAAEnJ,MAAM,CAAC2D,SAAS,EAAE3D,MAAM,CAACqJ,SAAS,CAAC,CAAC;AACxQ,SAASyxC,QAAQA,CAAC5lC,GAAG,EAAE;EACrB,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5BymC,WAAW,CAACtlE,IAAI,CAACo/B,MAAM,EAAE4lC,eAAe,CAAC;IACzC,MAAMO,QAAQ,GAAGvlE,IAAI,CAACy/B,GAAG,CAAC5mB,IAAI,KAAKykB,kBAAkB,CAACuC,IAAI,GAAGslC,oBAAoB,GAAGF,eAAe;IACnGK,WAAW,CAACtlE,IAAI,CAACq/B,MAAM,EAAEkmC,QAAQ,CAAC;EACpC;AACF;AACA,SAASD,WAAWA,CAACpjC,MAAM,EAAEqjC,QAAQ,EAAE;EACrC,IAAIC,UAAU,GAAG,EAAE;EACnB,IAAIC,kBAAkB,GAAG,IAAI;EAC7B,KAAK,MAAM/tF,EAAE,IAAIwqD,MAAM,EAAE;IACvB,MAAMwjC,aAAa,GAAG55C,4BAA4B,CAACp0C,EAAE,CAAC,GAAGA,EAAE,CAAC0f,MAAM,GAAG,IAAI;IACzE,IAAI,CAACguE,cAAc,CAAC3iG,GAAG,CAACiV,EAAE,CAACmhC,IAAI,CAAC,IAAI6sD,aAAa,KAAKD,kBAAkB,IAAIA,kBAAkB,KAAK,IAAI,IAAIC,aAAa,KAAK,IAAI,EAAE;MACjIrvC,MAAM,CAACsB,YAAY,CAACguC,OAAO,CAACH,UAAU,EAAED,QAAQ,CAAC,EAAE7tF,EAAE,CAAC;MACtD8tF,UAAU,GAAG,EAAE;MACfC,kBAAkB,GAAG,IAAI;IAC3B;IACA,IAAIL,cAAc,CAAC3iG,GAAG,CAACiV,EAAE,CAACmhC,IAAI,CAAC,EAAE;MAC/B2sD,UAAU,CAACjoG,IAAI,CAACma,EAAE,CAAC;MACnB2+C,MAAM,CAACiB,MAAM,CAAC5/C,EAAE,CAAC;MACjB+tF,kBAAkB,GAAGC,aAAa,IAAID,kBAAkB;IAC1D;EACF;EACAvjC,MAAM,CAAC3kE,IAAI,CAACooG,OAAO,CAACH,UAAU,EAAED,QAAQ,CAAC,CAAC;AAC5C;AACA,SAASI,OAAOA,CAAC9uC,GAAG,EAAE0uC,QAAQ,EAAE;EAC9B,MAAMl7C,MAAM,GAAGxzC,KAAK,CAACmZ,IAAI,CAACu1E,QAAQ,EAAE,MAAM,IAAI1uF,KAAK,CAAC,CAAC,CAAC;EACtD,KAAK,MAAMa,EAAE,IAAIm/C,GAAG,EAAE;IACpB,MAAM+uC,UAAU,GAAGL,QAAQ,CAAC/iC,SAAS,CAAC/wB,CAAC,IAAIA,CAAC,CAAC9iB,IAAI,CAACjX,EAAE,CAAC,CAAC;IACtD2yC,MAAM,CAACu7C,UAAU,CAAC,CAACroG,IAAI,CAACma,EAAE,CAAC;EAC7B;EACA,OAAO2yC,MAAM,CAACkgB,OAAO,CAAC,CAACs7B,KAAK,EAAEnnG,CAAC,KAAK;IAClC,MAAM8xD,SAAS,GAAG+0C,QAAQ,CAAC7mG,CAAC,CAAC,CAAC8xD,SAAS;IACvC,OAAOA,SAAS,GAAGA,SAAS,CAACq1C,KAAK,CAAC,GAAGA,KAAK;EAC7C,CAAC,CAAC;AACJ;AACA,SAASX,QAAQA,CAACruC,GAAG,EAAE;EACrB,OAAOA,GAAG,CAAC34D,KAAK,CAAC24D,GAAG,CAACv5D,MAAM,GAAG,CAAC,CAAC;AAClC;AAEA,SAASwoG,sBAAsBA,CAACrmC,GAAG,EAAE;EACnC,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,MAAM3rD,QAAQ,GAAG2tD,eAAe,CAAC7gC,IAAI,CAAC;IACtC,KAAK,MAAMtoB,EAAE,IAAIsoB,IAAI,CAAC62B,GAAG,CAAC,CAAC,EAAE;MAC3B,QAAQn/C,EAAE,CAACmhC,IAAI;QACb,KAAK0R,MAAM,CAAC0C,OAAO;UACjB,MAAM71B,MAAM,GAAG2uE,eAAe,CAAC7yF,QAAQ,EAAEwE,EAAE,CAAC0f,MAAM,CAAC;UACnD,IAAI4uE,iBAAiB,CAACtuF,EAAE,CAACtY,IAAI,CAAC,IAAIg4B,MAAM,CAACyhB,IAAI,KAAK0R,MAAM,CAACoL,UAAU,EAAE;YACnEU,MAAM,CAACiB,MAAM,CAAC5/C,EAAE,CAAC;UACnB;UACA;MACJ;IACF;EACF;AACF;AACA,SAASsuF,iBAAiBA,CAAC5mG,IAAI,EAAE;EAC/B,OAAOA,IAAI,CAACE,WAAW,CAAC,CAAC,KAAK,QAAQ;AACxC;AACA,SAASymG,eAAeA,CAACtkG,GAAG,EAAE2qD,IAAI,EAAE;EAClC,MAAM/4C,EAAE,GAAG5R,GAAG,CAACJ,GAAG,CAAC+qD,IAAI,CAAC;EACxB,IAAI/4C,EAAE,KAAK8Z,SAAS,EAAE;IACpB,MAAM,IAAIrvB,KAAK,CAAC,iDAAiD,CAAC;EACpE;EACA,OAAOuV,EAAE;AACX;AAEA,SAAS4yF,WAAWA,CAACxmC,GAAG,EAAE;EACxB,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5BqnC,yBAAyB,CAAClmE,IAAI,CAAC;EACjC;AACF;AACA,SAASkmE,yBAAyBA,CAAClmE,IAAI,EAAE;EACvC,KAAK,MAAMogC,QAAQ,IAAIpgC,IAAI,CAACq/B,MAAM,EAAE;IAClC/L,oBAAoB,CAAC8M,QAAQ,EAAE,CAAC1uD,IAAI,EAAEmB,KAAK,KAAK;MAC9C,IAAI,CAACo9C,cAAc,CAACv+C,IAAI,CAAC,EAAE;QACzB;MACF;MACA,IAAIA,IAAI,CAACmnC,IAAI,KAAK2R,cAAc,CAAC4H,WAAW,EAAE;QAC5C;MACF;MACA,IAAIv/C,KAAK,GAAGm/C,kBAAkB,CAACC,gBAAgB,EAAE;QAC/C,MAAM,IAAIn0D,KAAK,CAAC,sEAAsE,CAAC;MACzF;MACA,IAAIkiC,IAAI,CAACy/B,GAAG,CAAC/B,aAAa,EAAE;QAC1B,MAAMyoC,UAAU,GAAG/lC,QAAQ,CAAChpC,MAAM;QAClC,IAAI+uE,UAAU,IAAIh5E,SAAS,EAAE;UAC3B,MAAM,IAAIrvB,KAAK,CAAC,uEAAuE,CAAC;QAC1F;QACAsoG,sBAAsB,CAACpmE,IAAI,EAAEogC,QAAQ,CAAChpC,MAAM,EAAE1lB,IAAI,CAAC;MACrD,CAAC,MAAM;QACLsuB,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAAC88D,YAAY,CAAC3oD,IAAI,CAAC0lB,MAAM,EAAE1lB,IAAI,CAACg9C,UAAU,EAAEh9C,IAAI,CAACtS,IAAI,CAAC,CAAC;MACzE;IACF,CAAC,CAAC;EACJ;AACF;AACA,SAASgnG,sBAAsBA,CAACpmE,IAAI,EAAEqmE,eAAe,EAAEzU,OAAO,EAAE;EAC9D,KAAK,IAAIl6E,EAAE,GAAGsoB,IAAI,CAACo/B,MAAM,CAACxqC,IAAI,CAAC23B,IAAI,EAAE70C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACgM,OAAO,EAAE7+C,EAAE,GAAGA,EAAE,CAAC60C,IAAI,EAAE;IAC7E,IAAI,CAACV,oBAAoB,CAACn0C,EAAE,CAAC,EAAE;MAC7B;IACF;IACA,IAAIA,EAAE,CAAC00C,IAAI,KAAKi6C,eAAe,EAAE;MAC/B;IACF;IACA,OAAO3uF,EAAE,CAAC60C,IAAI,CAAC1T,IAAI,KAAK0R,MAAM,CAACxxB,IAAI,EAAE;MACnCrhB,EAAE,GAAGA,EAAE,CAAC60C,IAAI;IACd;IACA,MAAM3lC,IAAI,GAAGyzC,YAAY,CAACu3B,OAAO,CAACx6D,MAAM,EAAEw6D,OAAO,CAACljC,UAAU,EAAEkjC,OAAO,CAACxyF,IAAI,CAAC;IAC3Ei3D,MAAM,CAACsB,YAAY,CAAC/wC,IAAI,EAAElP,EAAE,CAAC60C,IAAI,CAAC;IAClC;EACF;EACA,MAAM,IAAIzuD,KAAK,CAAC,2DAA2D8zF,OAAO,CAACxyF,IAAI,EAAE,CAAC;AAC5F;AAEA,SAASknG,mBAAmBA,CAAC7mC,GAAG,EAAE;EAChC,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACq/B,MAAM,EAAE;MAC5B9L,wBAAwB,CAAC77C,EAAE,EAAEhG,IAAI,IAAI;QACnC,IAAI,EAAEA,IAAI,YAAYygD,eAAe,CAAC,EAAE;UACtC,OAAOzgD,IAAI;QACb;QACA,IAAIA,IAAI,CAACQ,IAAI,CAAC5U,MAAM,IAAI,CAAC,EAAE;UACzB,OAAOoU,IAAI;QACb;QACA,OAAO,IAAI2gD,uBAAuB,CAAC3gD,IAAI,CAAC0lB,MAAM,EAAE1lB,IAAI,CAACg9C,UAAU,EAAEh9C,IAAI,CAACtS,IAAI,EAAEkc,UAAU,CAAC5J,IAAI,CAACQ,IAAI,CAAC,EAAER,IAAI,CAACQ,IAAI,CAAC5U,MAAM,CAAC;MACtH,CAAC,EAAE00D,kBAAkB,CAACpnD,IAAI,CAAC;IAC7B;EACF;AACF;AAEA,SAAS27F,mBAAmBA,CAAC9mC,GAAG,EAAE;EAChC+mC,8BAA8B,CAAC/mC,GAAG,CAACtD,IAAI,EAAE,CAAC,CAAC;AAC7C;AACA,SAASqqC,8BAA8BA,CAACxmE,IAAI,EAAEq8B,gBAAgB,EAAE;EAC9D,IAAIP,SAAS,GAAG,IAAI;EACpB,KAAK,MAAMpkD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;IAC5B,QAAQ1nD,EAAE,CAACmhC,IAAI;MACb,KAAK0R,MAAM,CAACiL,SAAS;QACnB99C,EAAE,CAAC2kD,gBAAgB,GAAGA,gBAAgB,KAAK,CAAC,GAAG,IAAI,GAAGA,gBAAgB;QACtEP,SAAS,GAAGpkD,EAAE;QACd;MACF,KAAK6yC,MAAM,CAACgL,OAAO;QACjB,IAAIuG,SAAS,CAACO,gBAAgB,KAAK,IAAI,EAAE;UACvCA,gBAAgB,GAAG,CAAC;QACtB;QACAP,SAAS,GAAG,IAAI;QAChB;MACF,KAAKvR,MAAM,CAACyL,iBAAiB;MAC7B,KAAKzL,MAAM,CAAC0L,uBAAuB;MACnC,KAAK1L,MAAM,CAACtjB,QAAQ;QAClBo1B,gBAAgB,GAAGoqC,0BAA0B,CAACzmE,IAAI,CAACy/B,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAAC00C,IAAI,CAAC,EAAE0P,SAAS,EAAEpkD,EAAE,CAAC63C,eAAe,EAAE8M,gBAAgB,CAAC;QAC3H;MACF,KAAK9R,MAAM,CAAC6J,cAAc;QACxB,MAAMsyC,OAAO,GAAG1mE,IAAI,CAACy/B,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAAC00C,IAAI,CAAC;QAC3CiQ,gBAAgB,GAAGoqC,0BAA0B,CAACC,OAAO,EAAE5qC,SAAS,EAAEpkD,EAAE,CAAC63C,eAAe,EAAE8M,gBAAgB,CAAC;QACvG,IAAI3kD,EAAE,CAACkhD,SAAS,KAAK,IAAI,EAAE;UACzByD,gBAAgB,GAAGoqC,0BAA0B,CAACzmE,IAAI,CAACy/B,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAACkhD,SAAS,CAAC,EAAEkD,SAAS,EAAEpkD,EAAE,CAACqhD,oBAAoB,EAAEsD,gBAAgB,CAAC;QACvI;QACA;MACF,KAAK9R,MAAM,CAACoL,UAAU;QACpB,IAAIj+C,EAAE,CAACgjD,YAAY,KAAK,IAAI,EAAE;UAC5B2B,gBAAgB,GAAGoqC,0BAA0B,CAACzmE,IAAI,CAACy/B,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAACgjD,YAAY,CAAC,EAAEoB,SAAS,EAAEpkD,EAAE,CAACivF,2BAA2B,EAAEtqC,gBAAgB,CAAC;QACjJ;QACA;IACJ;EACF;EACA,OAAOA,gBAAgB;AACzB;AACA,SAASoqC,0BAA0BA,CAAC19F,IAAI,EAAE+yD,SAAS,EAAEvM,eAAe,EAAE8M,gBAAgB,EAAE;EACtF,IAAI9M,eAAe,KAAKpiC,SAAS,EAAE;IACjC,IAAI2uC,SAAS,KAAK,IAAI,EAAE;MACtB,MAAMh+D,KAAK,CAAC,iEAAiE,CAAC;IAChF;IACAu+D,gBAAgB,EAAE;IAClBuqC,oBAAoB,CAAC79F,IAAI,EAAE+yD,SAAS,CAAC;EACvC;EACA,OAAO0qC,8BAA8B,CAACz9F,IAAI,EAAEszD,gBAAgB,CAAC;AAC/D;AACA,SAASuqC,oBAAoBA,CAAC5mE,IAAI,EAAE6mE,UAAU,EAAE;EAC9C,IAAI7mE,IAAI,CAACo/B,MAAM,CAACxqC,IAAI,CAAC23B,IAAI,EAAE1T,IAAI,KAAK0R,MAAM,CAACiL,SAAS,EAAE;IACpD,MAAMhxD,EAAE,GAAGw7B,IAAI,CAACy/B,GAAG,CAAC5B,cAAc,CAAC,CAAC;IACpCxH,MAAM,CAACuB,WAAW,CAACsE,iBAAiB,CAAC13D,EAAE,EAAEqiG,UAAU,CAACtiG,OAAO,EAAEsiG,UAAU,CAAC1qC,IAAI,EAAE,IAAI,CAAC,EAAEn8B,IAAI,CAACo/B,MAAM,CAACxqC,IAAI,CAAC;IACtGyhC,MAAM,CAACsB,YAAY,CAAC2E,eAAe,CAAC93D,EAAE,EAAE,IAAI,CAAC,EAAEw7B,IAAI,CAACo/B,MAAM,CAAC5I,IAAI,CAAC;EAClE;AACF;AAEA,SAASswC,oBAAoBA,CAACrnC,GAAG,EAAE;EACjC,KAAK,MAAM12D,IAAI,IAAI02D,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAI3O,IAAI,CAAC8tD,GAAG,CAAC,CAAC,EAAE;MAC3BvD,oBAAoB,CAAC57C,EAAE,EAAEhG,IAAI,IAAI;QAC/B,IAAI,EAAEA,IAAI,YAAYmgD,gBAAgB,CAAC,IAAIngD,IAAI,CAACkB,IAAI,KAAK,IAAI,EAAE;UAC7D;QACF;QACA,MAAMm0F,WAAW,GAAG,IAAIC,oBAAoB,CAACt1F,IAAI,CAACQ,IAAI,CAAC5U,MAAM,CAAC;QAC9DoU,IAAI,CAACO,EAAE,GAAGwtD,GAAG,CAAChC,IAAI,CAACt/C,iBAAiB,CAAC4oF,WAAW,EAAEr1F,IAAI,CAACkB,IAAI,CAAC;QAC5DlB,IAAI,CAACkB,IAAI,GAAG,IAAI;MAClB,CAAC,CAAC;IACJ;EACF;AACF;AACA,MAAMo0F,oBAAoB,SAASppF,YAAY,CAAC;EAC9C00C,OAAO;EACPlwD,WAAWA,CAACkwD,OAAO,EAAE;IACnB,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,OAAO,GAAGA,OAAO;EACxB;EACAx0C,KAAKA,CAACpM,IAAI,EAAE;IACV,IAAIA,IAAI,YAAYwgD,yBAAyB,EAAE;MAC7C,OAAO,SAASxgD,IAAI,CAAC7I,KAAK,GAAG;IAC/B,CAAC,MAAM;MACL,OAAO,KAAK,CAACiV,KAAK,CAACpM,IAAI,CAAC;IAC1B;EACF;EACA2M,2BAA2BA,CAAC4oF,QAAQ,EAAEC,OAAO,EAAE;IAC7C,MAAMC,QAAQ,GAAG,EAAE;IACnB,KAAK,IAAIp1C,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG,IAAI,CAACO,OAAO,EAAEP,GAAG,EAAE,EAAE;MAC3Co1C,QAAQ,CAAC5pG,IAAI,CAAC,IAAI6Y,OAAO,CAAC,GAAG,GAAG27C,GAAG,CAAC,CAAC;IACvC;IACA,MAAMq1C,UAAU,GAAG32C,gCAAgC,CAACy2C,OAAO,EAAEx1F,IAAI,IAAI;MACnE,IAAI,EAAEA,IAAI,YAAYwgD,yBAAyB,CAAC,EAAE;QAChD,OAAOxgD,IAAI;MACb;MACA,OAAOqJ,QAAQ,CAAC,GAAG,GAAGrJ,IAAI,CAAC7I,KAAK,CAAC;IACnC,CAAC,EAAEmpD,kBAAkB,CAACpnD,IAAI,CAAC;IAC3B,OAAO,IAAIoM,cAAc,CAACiwF,QAAQ,EAAE,IAAIrwF,iBAAiB,CAACuwF,QAAQ,EAAEC,UAAU,CAAC,EAAEj6E,SAAS,EAAEhU,YAAY,CAAC+E,KAAK,CAAC;EACjH;AACF;AAEA,SAASmpF,6BAA6BA,CAAC5nC,GAAG,EAAE;EAC1C,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACq/B,MAAM,EAAE;MAC5B9L,wBAAwB,CAAC77C,EAAE,EAAE,CAAChG,IAAI,EAAEmB,KAAK,KAAK;QAC5C,IAAIA,KAAK,GAAGm/C,kBAAkB,CAACC,gBAAgB,EAAE;UAC/C,OAAOvgD,IAAI;QACb;QACA,IAAIA,IAAI,YAAY4G,gBAAgB,EAAE;UACpC,OAAOgvF,qBAAqB,CAAC51F,IAAI,CAAC;QACpC,CAAC,MAAM,IAAIA,IAAI,YAAYkH,cAAc,EAAE;UACzC,OAAO2uF,mBAAmB,CAAC71F,IAAI,CAAC;QAClC;QACA,OAAOA,IAAI;MACb,CAAC,EAAEsgD,kBAAkB,CAACpnD,IAAI,CAAC;IAC7B;EACF;AACF;AACA,SAAS08F,qBAAqBA,CAAC51F,IAAI,EAAE;EACnC,MAAM81F,cAAc,GAAG,EAAE;EACzB,MAAMC,eAAe,GAAG,EAAE;EAC1B,KAAK,MAAM1uF,KAAK,IAAIrH,IAAI,CAAC6G,OAAO,EAAE;IAChC,IAAIQ,KAAK,CAAC3H,UAAU,CAAC,CAAC,EAAE;MACtBo2F,cAAc,CAACjqG,IAAI,CAACwb,KAAK,CAAC;IAC5B,CAAC,MAAM;MACL,MAAMg5C,GAAG,GAAG01C,eAAe,CAACnqG,MAAM;MAClCmqG,eAAe,CAAClqG,IAAI,CAACwb,KAAK,CAAC;MAC3ByuF,cAAc,CAACjqG,IAAI,CAAC,IAAI20D,yBAAyB,CAACH,GAAG,CAAC,CAAC;IACzD;EACF;EACA,OAAO,IAAIF,gBAAgB,CAACv2C,UAAU,CAACksF,cAAc,CAAC,EAAEC,eAAe,CAAC;AAC1E;AACA,SAASF,mBAAmBA,CAAC71F,IAAI,EAAE;EACjC,IAAI81F,cAAc,GAAG,EAAE;EACvB,MAAMC,eAAe,GAAG,EAAE;EAC1B,KAAK,MAAM1uF,KAAK,IAAIrH,IAAI,CAAC6G,OAAO,EAAE;IAChC,IAAIQ,KAAK,CAAC1Z,KAAK,CAAC+R,UAAU,CAAC,CAAC,EAAE;MAC5Bo2F,cAAc,CAACjqG,IAAI,CAACwb,KAAK,CAAC;IAC5B,CAAC,MAAM;MACL,MAAMg5C,GAAG,GAAG01C,eAAe,CAACnqG,MAAM;MAClCmqG,eAAe,CAAClqG,IAAI,CAACwb,KAAK,CAAC1Z,KAAK,CAAC;MACjCmoG,cAAc,CAACjqG,IAAI,CAAC,IAAImb,eAAe,CAACK,KAAK,CAACpL,GAAG,EAAE,IAAIukD,yBAAyB,CAACH,GAAG,CAAC,EAAEh5C,KAAK,CAACJ,MAAM,CAAC,CAAC;IACvG;EACF;EACA,OAAO,IAAIk5C,gBAAgB,CAACr2C,UAAU,CAACgsF,cAAc,CAAC,EAAEC,eAAe,CAAC;AAC1E;AAEA,SAASC,0BAA0BA,CAACjoC,GAAG,EAAE;EACvC,KAAK,MAAM12D,IAAI,IAAI02D,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAI3O,IAAI,CAAC8tD,GAAG,CAAC,CAAC,EAAE;MAC3BtD,wBAAwB,CAAC77C,EAAE,EAAEhG,IAAI,IAAI;QACnC,IAAIA,IAAI,YAAYiB,4BAA4B,KAAKjB,IAAI,CAACmB,KAAK,KAAK,IAAI,IAAI,CAACnB,IAAI,CAACmB,KAAK,CAACgzC,QAAQ,CAAC,GAAG,CAAC,CAAC,EAAE;UACtG,OAAO4Z,GAAG,CAAChC,IAAI,CAACt/C,iBAAiB,CAAC,IAAIwpF,yBAAyB,CAAC,CAAC,EAAEj2F,IAAI,CAAC;QAC1E;QACA,OAAOA,IAAI;MACb,CAAC,EAAEsgD,kBAAkB,CAACpnD,IAAI,CAAC;IAC7B;EACF;AACF;AACA,MAAM+8F,yBAAyB,SAAS/pF,YAAY,CAAC;EACnDS,2BAA2BA,CAAC4oF,QAAQ,EAAEC,OAAO,EAAE;IAC7C,OAAO,IAAIlwF,cAAc,CAACiwF,QAAQ,EAAEC,OAAO,EAAE/5E,SAAS,EAAEhU,YAAY,CAAC+E,KAAK,CAAC;EAC7E;AACF;AAEA,SAASthB,OAAOA,CAACo2D,IAAI,EAAEj1D,GAAG,EAAE6pG,UAAU,EAAEC,aAAa,EAAEr6F,UAAU,EAAE;EACjE,OAAOs6F,sBAAsB,CAACtoF,WAAW,CAAC5iB,OAAO,EAAEo2D,IAAI,EAAEj1D,GAAG,EAAE6pG,UAAU,EAAEC,aAAa,EAAEr6F,UAAU,CAAC;AACtG;AACA,SAASuS,YAAYA,CAACizC,IAAI,EAAEj1D,GAAG,EAAE6pG,UAAU,EAAEC,aAAa,EAAEr6F,UAAU,EAAE;EACtE,OAAOs6F,sBAAsB,CAACtoF,WAAW,CAACO,YAAY,EAAEizC,IAAI,EAAEj1D,GAAG,EAAE6pG,UAAU,EAAEC,aAAa,EAAEr6F,UAAU,CAAC;AAC3G;AACA,SAASs6F,sBAAsBA,CAAC3lC,WAAW,EAAEnP,IAAI,EAAEj1D,GAAG,EAAE6pG,UAAU,EAAEC,aAAa,EAAEr6F,UAAU,EAAE;EAC7F,MAAM0E,IAAI,GAAG,CAAC8J,OAAO,CAACg3C,IAAI,CAAC,CAAC;EAC5B,IAAIj1D,GAAG,KAAK,IAAI,EAAE;IAChBmU,IAAI,CAAC3U,IAAI,CAACye,OAAO,CAACje,GAAG,CAAC,CAAC;EACzB;EACA,IAAI8pG,aAAa,KAAK,IAAI,EAAE;IAC1B31F,IAAI,CAAC3U,IAAI,CAACye,OAAO,CAAC4rF,UAAU,CAAC,EAAE5rF,OAAO,CAAC6rF,aAAa,CAAC,CAAC;EACxD,CAAC,MAAM,IAAID,UAAU,KAAK,IAAI,EAAE;IAC9B11F,IAAI,CAAC3U,IAAI,CAACye,OAAO,CAAC4rF,UAAU,CAAC,CAAC;EAChC;EACA,OAAOG,IAAI,CAAC5lC,WAAW,EAAEjwD,IAAI,EAAE1E,UAAU,CAAC;AAC5C;AACA,SAASw6F,YAAYA,CAAC7lC,WAAW,EAAEnP,IAAI,EAAEi1C,aAAa,EAAE1vC,KAAK,EAAE1wB,IAAI,EAAE9pC,GAAG,EAAE6pG,UAAU,EAAEzvC,SAAS,EAAE3qD,UAAU,EAAE;EAC3G,MAAM0E,IAAI,GAAG,CAAC8J,OAAO,CAACg3C,IAAI,CAAC,EAAEi1C,aAAa,EAAEjsF,OAAO,CAACu8C,KAAK,CAAC,EAAEv8C,OAAO,CAAC6rB,IAAI,CAAC,EAAE7rB,OAAO,CAACje,GAAG,CAAC,EAAEie,OAAO,CAAC4rF,UAAU,CAAC,CAAC;EAC7G,IAAIzvC,SAAS,KAAK,IAAI,EAAE;IACtBjmD,IAAI,CAAC3U,IAAI,CAACye,OAAO,CAACm8C,SAAS,CAAC,CAAC;IAC7BjmD,IAAI,CAAC3U,IAAI,CAACyd,UAAU,CAACwE,WAAW,CAAC6H,oBAAoB,CAAC,CAAC;EACzD;EACA,OAAOnV,IAAI,CAACA,IAAI,CAAC5U,MAAM,GAAG,CAAC,CAAC,CAAC2P,YAAY,CAACiM,SAAS,CAAC,EAAE;IACpDhH,IAAI,CAACugB,GAAG,CAAC,CAAC;EACZ;EACA,OAAOs1E,IAAI,CAAC5lC,WAAW,EAAEjwD,IAAI,EAAE1E,UAAU,CAAC;AAC5C;AACA,SAAS06F,YAAYA,CAAC/lC,WAAW,EAAE/iE,IAAI,EAAEgH,UAAU,EAAEinD,SAAS,EAAE7/C,UAAU,EAAE;EAC1E,MAAM0E,IAAI,GAAG,CAAC8J,OAAO,CAAC5c,IAAI,CAAC,CAAC;EAC5B,IAAIgH,UAAU,YAAY41B,aAAa,EAAE;IACvC9pB,IAAI,CAAC3U,IAAI,CAAC4qG,yBAAyB,CAAC/hG,UAAU,EAAEoH,UAAU,CAAC,CAAC;EAC9D,CAAC,MAAM;IACL0E,IAAI,CAAC3U,IAAI,CAAC6I,UAAU,CAAC;EACvB;EACA,IAAIinD,SAAS,KAAK,IAAI,EAAE;IACtBn7C,IAAI,CAAC3U,IAAI,CAAC8vD,SAAS,CAAC;EACtB;EACA,OAAO06C,IAAI,CAAC5lC,WAAW,EAAEjwD,IAAI,EAAE1E,UAAU,CAAC;AAC5C;AACA,SAASwS,UAAUA,CAACxS,UAAU,EAAE;EAC9B,OAAOu6F,IAAI,CAACvoF,WAAW,CAACQ,UAAU,EAAE,EAAE,EAAExS,UAAU,CAAC;AACrD;AACA,SAASqT,qBAAqBA,CAACmyC,IAAI,EAAE40C,UAAU,EAAEC,aAAa,EAAEr6F,UAAU,EAAE;EAC1E,OAAOs6F,sBAAsB,CAACtoF,WAAW,CAACqB,qBAAqB,EAAEmyC,IAAI,EAAE,IAAI,EAAE40C,UAAU,EAAEC,aAAa,EAAEr6F,UAAU,CAAC;AACrH;AACA,SAASuT,gBAAgBA,CAACiyC,IAAI,EAAE40C,UAAU,EAAEC,aAAa,EAAEr6F,UAAU,EAAE;EACrE,OAAOs6F,sBAAsB,CAACtoF,WAAW,CAACuB,gBAAgB,EAAEiyC,IAAI,EAAE,IAAI,EAAE40C,UAAU,EAAEC,aAAa,EAAEr6F,UAAU,CAAC;AAChH;AACA,SAASsT,mBAAmBA,CAAA,EAAG;EAC7B,OAAOinF,IAAI,CAACvoF,WAAW,CAACsB,mBAAmB,EAAE,EAAE,EAAE,IAAI,CAAC;AACxD;AACA,SAASvO,QAAQA,CAACygD,IAAI,EAAEi1C,aAAa,EAAE1vC,KAAK,EAAE1wB,IAAI,EAAE9pC,GAAG,EAAE6pG,UAAU,EAAEzvC,SAAS,EAAE3qD,UAAU,EAAE;EAC1F,OAAOw6F,YAAY,CAACxoF,WAAW,CAACuC,cAAc,EAAEixC,IAAI,EAAEi1C,aAAa,EAAE1vC,KAAK,EAAE1wB,IAAI,EAAE9pC,GAAG,EAAE6pG,UAAU,EAAEzvC,SAAS,EAAE3qD,UAAU,CAAC;AAC3H;AACA,SAASwW,eAAeA,CAAA,EAAG;EACzB,OAAO+jF,IAAI,CAACvoF,WAAW,CAACwE,eAAe,EAAE,EAAE,EAAE,IAAI,CAAC;AACpD;AACA,SAASD,cAAcA,CAAA,EAAG;EACxB,OAAOgkF,IAAI,CAACvoF,WAAW,CAACuE,cAAc,EAAE,EAAE,EAAE,IAAI,CAAC;AACnD;AACA,SAASgH,QAAQA,CAAC3rB,IAAI,EAAEgpG,SAAS,EAAEC,mBAAmB,EAAEC,aAAa,EAAE96F,UAAU,EAAE;EACjF,MAAM0E,IAAI,GAAG,CAAC8J,OAAO,CAAC5c,IAAI,CAAC,EAAEgpG,SAAS,CAAC;EACvC,IAAIC,mBAAmB,KAAK,IAAI,EAAE;IAChCn2F,IAAI,CAAC3U,IAAI,CAACyd,UAAU,CAACqtF,mBAAmB,CAAC,CAAC;EAC5C;EACA,OAAON,IAAI,CAACO,aAAa,GAAG9oF,WAAW,CAACmB,qBAAqB,GAAGnB,WAAW,CAACuL,QAAQ,EAAE7Y,IAAI,EAAE1E,UAAU,CAAC;AACzG;AACA,SAAS4c,gBAAgBA,CAACgN,MAAM,EAAE/3B,KAAK,EAAE;EACvC,OAAO2b,UAAU,CAACwE,WAAW,CAAC4K,gBAAgB,CAAC,CAACvc,MAAM,CAAC,CAACupB,MAAM,EAAE/3B,KAAK,CAAC,CAAC;AACzE;AACA,SAASgrB,cAAcA,CAACjrB,IAAI,EAAEgpG,SAAS,EAAE56F,UAAU,EAAE;EACnD,OAAOu6F,IAAI,CAACvoF,WAAW,CAAC6K,cAAc,EAAE,CAACrO,OAAO,CAAC5c,IAAI,CAAC,EAAEgpG,SAAS,CAAC,EAAE56F,UAAU,CAAC;AACjF;AACA,SAASoZ,IAAIA,CAACosC,IAAI,EAAE5zD,IAAI,EAAE;EACxB,OAAO2oG,IAAI,CAACvoF,WAAW,CAACoH,IAAI,EAAE,CAAC5K,OAAO,CAACg3C,IAAI,CAAC,EAAEh3C,OAAO,CAAC5c,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC;AACrE;AACA,SAASwgB,aAAaA,CAAA,EAAG;EACvB,OAAOmoF,IAAI,CAACvoF,WAAW,CAACI,aAAa,EAAE,EAAE,EAAE,IAAI,CAAC;AAClD;AACA,SAASE,YAAYA,CAAA,EAAG;EACtB,OAAOioF,IAAI,CAACvoF,WAAW,CAACM,YAAY,EAAE,EAAE,EAAE,IAAI,CAAC;AACjD;AACA,SAASyoF,aAAaA,CAAA,EAAG;EACvB,OAAOR,IAAI,CAACvoF,WAAW,CAACK,eAAe,EAAE,EAAE,EAAE,IAAI,CAAC;AACpD;AACA,SAASY,OAAOA,CAACu2B,KAAK,EAAExpC,UAAU,EAAE;EAClC,OAAOu6F,IAAI,CAACvoF,WAAW,CAACiB,OAAO,EAAEu2B,KAAK,GAAG,CAAC,GAAG,CAACh7B,OAAO,CAACg7B,KAAK,CAAC,CAAC,GAAG,EAAE,EAAExpC,UAAU,CAAC;AACjF;AACA,SAASuZ,SAASA,CAACisC,IAAI,EAAE;EACvB,OAAOh4C,UAAU,CAACwE,WAAW,CAACuH,SAAS,CAAC,CAAClZ,MAAM,CAAC,CAACmO,OAAO,CAACg3C,IAAI,CAAC,CAAC,CAAC;AAClE;AACA,SAASnxC,WAAWA,CAACqvC,KAAK,EAAE;EAC1B,OAAOl2C,UAAU,CAACwE,WAAW,CAACqC,WAAW,CAAC,CAAChU,MAAM,CAACqjD,KAAK,KAAK,CAAC,GAAG,EAAE,GAAG,CAACl1C,OAAO,CAACk1C,KAAK,CAAC,CAAC,CAAC;AACxF;AACA,SAASjtC,cAAcA,CAAA,EAAG;EACxB,OAAOjJ,UAAU,CAACwE,WAAW,CAACyE,cAAc,CAAC,CAACpW,MAAM,CAAC,EAAE,CAAC;AAC1D;AACA,SAAS+W,WAAWA,CAAC4jF,SAAS,EAAE;EAC9B,OAAOxtF,UAAU,CAACwE,WAAW,CAACoF,WAAW,CAAC,CAAC/W,MAAM,CAAC,CAAC26F,SAAS,CAAC,CAAC;AAChE;AACA,SAAS1mF,SAASA,CAAC2mF,WAAW,EAAE;EAC9B,OAAOztF,UAAU,CAACwE,WAAW,CAACsC,SAAS,CAAC,CAACjU,MAAM,CAAC,CAAC46F,WAAW,CAAC,CAAC;AAChE;AACA,SAASjjG,IAAIA,CAACwtD,IAAI,EAAEuG,YAAY,EAAE/rD,UAAU,EAAE;EAC5C,MAAM0E,IAAI,GAAG,CAAC8J,OAAO,CAACg3C,IAAI,EAAE,IAAI,CAAC,CAAC;EAClC,IAAIuG,YAAY,KAAK,EAAE,EAAE;IACvBrnD,IAAI,CAAC3U,IAAI,CAACye,OAAO,CAACu9C,YAAY,CAAC,CAAC;EAClC;EACA,OAAOwuC,IAAI,CAACvoF,WAAW,CAACha,IAAI,EAAE0M,IAAI,EAAE1E,UAAU,CAAC;AACjD;AACA,SAASwU,KAAKA,CAAC0mF,QAAQ,EAAEC,WAAW,EAAEC,oBAAoB,EAAEztC,WAAW,EAAEI,eAAe,EAAEG,SAAS,EAAEjH,aAAa,EAAEC,iBAAiB,EAAEm0C,qBAAqB,EAAEr7F,UAAU,EAAEqF,KAAK,EAAE;EAC/K,MAAMX,IAAI,GAAG,CAAC8J,OAAO,CAAC0sF,QAAQ,CAAC,EAAE1sF,OAAO,CAAC2sF,WAAW,CAAC,EAAEC,oBAAoB,IAAI5sF,OAAO,CAAC,IAAI,CAAC,EAAEA,OAAO,CAACm/C,WAAW,CAAC,EAAEn/C,OAAO,CAACu/C,eAAe,CAAC,EAAEv/C,OAAO,CAAC0/C,SAAS,CAAC,EAAEjH,aAAa,IAAIz4C,OAAO,CAAC,IAAI,CAAC,EAAE04C,iBAAiB,IAAI14C,OAAO,CAAC,IAAI,CAAC,EAAE6sF,qBAAqB,GAAG7tF,UAAU,CAACwE,WAAW,CAAC+D,0BAA0B,CAAC,GAAGvH,OAAO,CAAC,IAAI,CAAC,EAAEA,OAAO,CAACnJ,KAAK,CAAC,CAAC;EACjV,IAAInB,IAAI;EACR,OAAO,CAACA,IAAI,GAAGQ,IAAI,CAACA,IAAI,CAAC5U,MAAM,GAAG,CAAC,CAAC,MAAM,IAAI,IAAIoU,IAAI,YAAYqB,WAAW,IAAIrB,IAAI,CAACrS,KAAK,KAAK,IAAI,EAAE;IACpG6S,IAAI,CAACugB,GAAG,CAAC,CAAC;EACZ;EACA,OAAOs1E,IAAI,CAACvoF,WAAW,CAACwC,KAAK,EAAE9P,IAAI,EAAE1E,UAAU,CAAC;AAClD;AACA,MAAMs7F,sCAAsC,GAAG,IAAI9oG,GAAG,CAAC,CAAC,CAACirD,gBAAgB,CAACub,IAAI,EAAE;EAC9E,CAAC,MAAM,GAAGhnD,WAAW,CAAC0C,WAAW;EACjC,CAAC,UAAU,GAAG1C,WAAW,CAACiD,mBAAmB;EAC7C,CAAC,SAAS,GAAGjD,WAAW,CAACyD;AAC3B,CAAC,CAAC,EAAE,CAACgoC,gBAAgB,CAACyb,SAAS,EAAE;EAC/B,CAAC,MAAM,GAAGlnD,WAAW,CAAC2C,gBAAgB;EACtC,CAAC,UAAU,GAAG3C,WAAW,CAACkD,wBAAwB;EAClD,CAAC,SAAS,GAAGlD,WAAW,CAAC0D;AAC3B,CAAC,CAAC,EAAE,CAAC+nC,gBAAgB,CAAC0b,KAAK,EAAE;EAC3B,CAAC,MAAM,GAAGnnD,WAAW,CAAC4C,YAAY;EAClC,CAAC,UAAU,GAAG5C,WAAW,CAACmD,oBAAoB;EAC9C,CAAC,SAAS,GAAGnD,WAAW,CAAC2D;AAC3B,CAAC,CAAC,EAAE,CAAC8nC,gBAAgB,CAAC2b,KAAK,EAAE;EAC3B,CAAC,MAAM,GAAGpnD,WAAW,CAAC6C,YAAY;EAClC,CAAC,UAAU,GAAG7C,WAAW,CAACoD,oBAAoB;EAC9C,CAAC,SAAS,GAAGpD,WAAW,CAAC4D;AAC3B,CAAC,CAAC,EAAE,CAAC6nC,gBAAgB,CAAC4b,WAAW,EAAE;EACjC,CAAC,MAAM,GAAGrnD,WAAW,CAAC8C,kBAAkB;EACxC,CAAC,UAAU,GAAG9C,WAAW,CAACqD,0BAA0B;EACpD,CAAC,SAAS,GAAGrD,WAAW,CAAC6D;AAC3B,CAAC,CAAC,EAAE,CAAC4nC,gBAAgB,CAAC6b,QAAQ,EAAE;EAC9B,CAAC,MAAM,GAAGtnD,WAAW,CAAC+C,eAAe;EACrC,CAAC,UAAU,GAAG/C,WAAW,CAACsD,uBAAuB;EACjD,CAAC,SAAS,GAAGtD,WAAW,CAAC8D;AAC3B,CAAC,CAAC,EAAE,CAAC2nC,gBAAgB,CAACwb,KAAK,EAAE;EAC3B,CAAC,MAAM,GAAGjnD,WAAW,CAACwD,iBAAiB;EACvC,CAAC,UAAU,GAAGxD,WAAW,CAACwD,iBAAiB;EAC3C,CAAC,SAAS,GAAGxD,WAAW,CAACwD;AAC3B,CAAC,CAAC,CAAC,CAAC;AACJ,SAAS+lF,OAAOA,CAACrgE,OAAO,EAAEx2B,IAAI,EAAEpH,QAAQ,EAAE0C,UAAU,EAAE;EACpD,MAAMw7F,iBAAiB,GAAGF,sCAAsC,CAACznG,GAAG,CAACqnC,OAAO,CAAC,GAAG59B,QAAQ,CAAC;EACzF,IAAIk+F,iBAAiB,KAAK77E,SAAS,EAAE;IACnC,MAAM,IAAIrvB,KAAK,CAAC,+CAA+C4qC,OAAO,EAAE,CAAC;EAC3E;EACA,OAAOq/D,IAAI,CAACiB,iBAAiB,EAAE92F,IAAI,EAAE1E,UAAU,CAAC;AAClD;AACA,SAASsZ,aAAaA,CAAC1I,GAAG,EAAE;EAC1B,OAAO2pF,IAAI,CAACvoF,WAAW,CAACsH,aAAa,EAAE1I,GAAG,GAAG,CAACA,GAAG,CAAC,GAAG,EAAE,EAAE,IAAI,CAAC;AAChE;AACA,SAASyI,UAAUA,CAACmsC,IAAI,EAAE2H,mBAAmB,EAAE14B,UAAU,EAAEgnE,cAAc,EAAEC,aAAa,EAAEC,YAAY,EAAE37F,UAAU,EAAE;EAClH,MAAM0E,IAAI,GAAG,CAAC8J,OAAO,CAACg3C,IAAI,CAAC,CAAC;EAC5B,IAAI2H,mBAAmB,KAAK,CAAC,IAAI14B,UAAU,KAAK,IAAI,IAAIgnE,cAAc,KAAK,IAAI,EAAE;IAC/E/2F,IAAI,CAAC3U,IAAI,CAACye,OAAO,CAAC2+C,mBAAmB,CAAC,CAAC;IACvC,IAAI14B,UAAU,KAAK,IAAI,EAAE;MACvB/vB,IAAI,CAAC3U,IAAI,CAAC0kC,UAAU,CAAC;IACvB;IACA,IAAIgnE,cAAc,KAAK,IAAI,EAAE;MAC3B,IAAIhnE,UAAU,KAAK,IAAI,EAAE;QACvB/vB,IAAI,CAAC3U,IAAI,CAACye,OAAO,CAAC,IAAI,CAAC,CAAC;MAC1B;MACA9J,IAAI,CAAC3U,IAAI,CAACwd,QAAQ,CAACkuF,cAAc,CAAC,EAAEjtF,OAAO,CAACktF,aAAa,CAAC,EAAEltF,OAAO,CAACmtF,YAAY,CAAC,CAAC;IACpF;EACF;EACA,OAAOpB,IAAI,CAACvoF,WAAW,CAACqH,UAAU,EAAE3U,IAAI,EAAE1E,UAAU,CAAC;AACvD;AACA,SAASgZ,SAASA,CAACwsC,IAAI,EAAE40C,UAAU,EAAEvrC,gBAAgB,EAAE7uD,UAAU,EAAE;EACjE,MAAM0E,IAAI,GAAG,CAAC8J,OAAO,CAACg3C,IAAI,CAAC,EAAEh3C,OAAO,CAAC4rF,UAAU,CAAC,CAAC;EACjD,IAAIvrC,gBAAgB,KAAK,IAAI,EAAE;IAC7BnqD,IAAI,CAAC3U,IAAI,CAACye,OAAO,CAACqgD,gBAAgB,CAAC,CAAC;EACtC;EACA,OAAO0rC,IAAI,CAACvoF,WAAW,CAACgH,SAAS,EAAEtU,IAAI,EAAE1E,UAAU,CAAC;AACtD;AACA,SAASgW,iBAAiBA,CAACwvC,IAAI,EAAEi1C,aAAa,EAAE1vC,KAAK,EAAE1wB,IAAI,EAAE9pC,GAAG,EAAE6pG,UAAU,EAAEzvC,SAAS,EAAE3qD,UAAU,EAAE;EACnG,MAAM0E,IAAI,GAAG,CAAC8J,OAAO,CAACg3C,IAAI,CAAC,EAAEi1C,aAAa,EAAEjsF,OAAO,CAACu8C,KAAK,CAAC,EAAEv8C,OAAO,CAAC6rB,IAAI,CAAC,EAAE7rB,OAAO,CAACje,GAAG,CAAC,EAAEie,OAAO,CAAC4rF,UAAU,CAAC,CAAC;EAC7G,IAAIzvC,SAAS,KAAK,IAAI,EAAE;IACtBjmD,IAAI,CAAC3U,IAAI,CAACye,OAAO,CAACm8C,SAAS,CAAC,CAAC;IAC7BjmD,IAAI,CAAC3U,IAAI,CAACyd,UAAU,CAACwE,WAAW,CAAC6H,oBAAoB,CAAC,CAAC;EACzD;EACA,OAAOnV,IAAI,CAACA,IAAI,CAAC5U,MAAM,GAAG,CAAC,CAAC,CAAC2P,YAAY,CAACiM,SAAS,CAAC,EAAE;IACpDhH,IAAI,CAACugB,GAAG,CAAC,CAAC;EACZ;EACA,OAAOs1E,IAAI,CAACvoF,WAAW,CAACgE,iBAAiB,EAAEtR,IAAI,EAAE1E,UAAU,CAAC;AAC9D;AACA,SAASiW,uBAAuBA,CAACuvC,IAAI,EAAEi1C,aAAa,EAAE1vC,KAAK,EAAE1wB,IAAI,EAAE9pC,GAAG,EAAE6pG,UAAU,EAAEzvC,SAAS,EAAE3qD,UAAU,EAAE;EACzG,MAAM0E,IAAI,GAAG,CAAC8J,OAAO,CAACg3C,IAAI,CAAC,EAAEi1C,aAAa,EAAEjsF,OAAO,CAACu8C,KAAK,CAAC,EAAEv8C,OAAO,CAAC6rB,IAAI,CAAC,EAAE7rB,OAAO,CAACje,GAAG,CAAC,EAAEie,OAAO,CAAC4rF,UAAU,CAAC,CAAC;EAC7G,IAAIzvC,SAAS,KAAK,IAAI,EAAE;IACtBjmD,IAAI,CAAC3U,IAAI,CAACye,OAAO,CAACm8C,SAAS,CAAC,CAAC;IAC7BjmD,IAAI,CAAC3U,IAAI,CAACyd,UAAU,CAACwE,WAAW,CAAC6H,oBAAoB,CAAC,CAAC;EACzD;EACA,OAAOnV,IAAI,CAACA,IAAI,CAAC5U,MAAM,GAAG,CAAC,CAAC,CAAC2P,YAAY,CAACiM,SAAS,CAAC,EAAE;IACpDhH,IAAI,CAACugB,GAAG,CAAC,CAAC;EACZ;EACA,OAAOs1E,IAAI,CAACvoF,WAAW,CAACiE,uBAAuB,EAAEvR,IAAI,EAAE1E,UAAU,CAAC;AACpE;AACA,SAASmW,cAAcA,CAACqvC,IAAI,EAAEo2C,UAAU,EAAE7wC,KAAK,EAAE1wB,IAAI,EAAE9pC,GAAG,EAAE6pG,UAAU,EAAErzC,SAAS,EAAE80C,4BAA4B,EAAEC,eAAe,EAAEC,UAAU,EAAEC,SAAS,EAAE1wC,QAAQ,EAAE2wC,eAAe,EAAEj8F,UAAU,EAAE;EAC9L,MAAM0E,IAAI,GAAG,CAAC8J,OAAO,CAACg3C,IAAI,CAAC,EAAEj4C,QAAQ,CAACquF,UAAU,CAAC,EAAEptF,OAAO,CAACu8C,KAAK,CAAC,EAAEv8C,OAAO,CAAC6rB,IAAI,CAAC,EAAE7rB,OAAO,CAACje,GAAG,CAAC,EAAEie,OAAO,CAAC4rF,UAAU,CAAC,EAAErzC,SAAS,CAAC;EAC/H,IAAI80C,4BAA4B,IAAIC,eAAe,KAAK,IAAI,EAAE;IAC5Dp3F,IAAI,CAAC3U,IAAI,CAACye,OAAO,CAACqtF,4BAA4B,CAAC,CAAC;IAChD,IAAIC,eAAe,KAAK,IAAI,EAAE;MAC5Bp3F,IAAI,CAAC3U,IAAI,CAACwd,QAAQ,CAACuuF,eAAe,CAAC,EAAEttF,OAAO,CAACutF,UAAU,CAAC,EAAEvtF,OAAO,CAACwtF,SAAS,CAAC,CAAC;MAC7E,IAAI1wC,QAAQ,KAAK,IAAI,IAAI2wC,eAAe,KAAK,IAAI,EAAE;QACjDv3F,IAAI,CAAC3U,IAAI,CAACye,OAAO,CAAC88C,QAAQ,CAAC,CAAC;MAC9B;MACA,IAAI2wC,eAAe,KAAK,IAAI,EAAE;QAC5Bv3F,IAAI,CAAC3U,IAAI,CAACye,OAAO,CAACytF,eAAe,CAAC,CAAC;MACrC;IACF;EACF;EACA,OAAO1B,IAAI,CAACvoF,WAAW,CAACmE,cAAc,EAAEzR,IAAI,EAAE1E,UAAU,CAAC;AAC3D;AACA,SAASkW,QAAQA,CAACirC,UAAU,EAAEnhD,UAAU,EAAE;EACxC,OAAOu6F,IAAI,CAACvoF,WAAW,CAACkE,QAAQ,EAAE,CAACirC,UAAU,CAAC,EAAEnhD,UAAU,CAAC;AAC7D;AACA,SAASyU,SAASA,CAACnX,QAAQ,EAAE4G,IAAI,EAAElE,UAAU,EAAE;EAC7C,IAAI1C,QAAQ,KAAK,UAAU,EAAE;IAC3B,OAAOi9F,IAAI,CAACvoF,WAAW,CAACgD,iBAAiB,EAAE,CAAC9Q,IAAI,CAAC,EAAElE,UAAU,CAAC;EAChE,CAAC,MAAM,IAAI1C,QAAQ,KAAK,SAAS,EAAE;IACjC,OAAOi9F,IAAI,CAACvoF,WAAW,CAACuD,gBAAgB,EAAE,CAACrR,IAAI,CAAC,EAAElE,UAAU,CAAC;EAC/D;EACA,OAAOu6F,IAAI,CAACvoF,WAAW,CAACyC,SAAS,EAAE,CAACvQ,IAAI,CAAC,EAAElE,UAAU,CAAC;AACxD;AACA,SAAS8c,UAAUA,CAAC0oC,IAAI,EAAExlD,UAAU,EAAE;EACpC,OAAOu6F,IAAI,CAACvoF,WAAW,CAAC8K,UAAU,EAAE,CAACtO,OAAO,CAACg3C,IAAI,CAAC,CAAC,EAAExlD,UAAU,CAAC;AAClE;AACA,SAAS+c,QAAQA,CAAClrB,KAAK,EAAEmO,UAAU,EAAE;EACnC,OAAOwN,UAAU,CAACwE,WAAW,CAAC+K,QAAQ,CAAC,CAAC1c,MAAM,CAAC,CAACxO,KAAK,CAAC,EAAEmO,UAAU,CAAC;AACrE;AACA,SAASgd,cAAcA,CAACwoC,IAAI,EAAE;EAC5B,OAAOh4C,UAAU,CAACwE,WAAW,CAACgL,cAAc,CAAC,CAAC3c,MAAM,CAAC,CAACmO,OAAO,CAACg3C,IAAI,CAAC,CAAC,CAAC;AACvE;AACA,SAAS3sC,IAAIA,CAAC2sC,IAAI,EAAE40C,UAAU,EAAEvrC,gBAAgB,EAAE7uD,UAAU,EAAE;EAC5D,MAAM0E,IAAI,GAAG,CAAC8J,OAAO,CAACg3C,IAAI,CAAC,EAAEh3C,OAAO,CAAC4rF,UAAU,CAAC,CAAC;EACjD,IAAIvrC,gBAAgB,EAAE;IACpBnqD,IAAI,CAAC3U,IAAI,CAACye,OAAO,CAACqgD,gBAAgB,CAAC,CAAC;EACtC;EACA,OAAO0rC,IAAI,CAACvoF,WAAW,CAAC6G,IAAI,EAAEnU,IAAI,EAAE1E,UAAU,CAAC;AACjD;AACA,SAASiZ,OAAOA,CAAC+b,aAAa,EAAE;EAC9B,OAAOulE,IAAI,CAACvoF,WAAW,CAACiH,OAAO,EAAE,EAAE,EAAE+b,aAAa,CAAC;AACrD;AACA,SAASlc,cAAcA,CAAC0sC,IAAI,EAAE+J,oBAAoB,EAAE;EAClD,MAAM7qD,IAAI,GAAG,CAAC8J,OAAO,CAACg3C,IAAI,CAAC,EAAEh3C,OAAO,CAAC+gD,oBAAoB,CAAC,CAAC;EAC3D,OAAOgrC,IAAI,CAACvoF,WAAW,CAAC8G,cAAc,EAAEpU,IAAI,EAAE,IAAI,CAAC;AACrD;AACA,SAAS2T,YAAYA,CAACzmB,IAAI,EAAEgH,UAAU,EAAEoH,UAAU,EAAE;EAClD,OAAO06F,YAAY,CAAC1oF,WAAW,CAACqG,YAAY,EAAEzmB,IAAI,EAAEgH,UAAU,EAAE,IAAI,EAAEoH,UAAU,CAAC;AACnF;AACA,SAASsY,QAAQA,CAAC1mB,IAAI,EAAEgH,UAAU,EAAEinD,SAAS,EAAE7/C,UAAU,EAAE;EACzD,OAAO06F,YAAY,CAAC1oF,WAAW,CAACsG,QAAQ,EAAE1mB,IAAI,EAAEgH,UAAU,EAAEinD,SAAS,EAAE7/C,UAAU,CAAC;AACpF;AACA,SAASuY,OAAOA,CAAC3f,UAAU,EAAEinD,SAAS,EAAE7/C,UAAU,EAAE;EAClD,MAAM0E,IAAI,GAAG,EAAE;EACf,IAAI9L,UAAU,YAAY41B,aAAa,EAAE;IACvC9pB,IAAI,CAAC3U,IAAI,CAAC4qG,yBAAyB,CAAC/hG,UAAU,EAAEoH,UAAU,CAAC,CAAC;EAC9D,CAAC,MAAM;IACL0E,IAAI,CAAC3U,IAAI,CAAC6I,UAAU,CAAC;EACvB;EACA,IAAIinD,SAAS,KAAK,IAAI,EAAE;IACtBn7C,IAAI,CAAC3U,IAAI,CAAC8vD,SAAS,CAAC;EACtB;EACA,OAAO06C,IAAI,CAACvoF,WAAW,CAACuG,OAAO,EAAE7T,IAAI,EAAE1E,UAAU,CAAC;AACpD;AACA,SAASwY,aAAaA,CAACxY,UAAU,EAAE;EACjC,OAAOu6F,IAAI,CAACvoF,WAAW,CAACwG,aAAa,EAAE,EAAE,EAAExY,UAAU,CAAC;AACxD;AACA,SAAS2c,cAAcA,CAAC/qB,IAAI,EAAEgH,UAAU,EAAEinD,SAAS,EAAE7/C,UAAU,EAAE;EAC/D,MAAM0E,IAAI,GAAG,CAAC8J,OAAO,CAAC5c,IAAI,CAAC,EAAEgH,UAAU,CAAC;EACxC,IAAIinD,SAAS,KAAK,IAAI,EAAE;IACtBn7C,IAAI,CAAC3U,IAAI,CAAC8vD,SAAS,CAAC;EACtB;EACA,OAAO06C,IAAI,CAACvoF,WAAW,CAAC2K,cAAc,EAAEjY,IAAI,EAAE1E,UAAU,CAAC;AAC3D;AACA,SAASnP,SAASA,CAACe,IAAI,EAAEgH,UAAU,EAAEinD,SAAS,EAAEY,SAAS,EAAEzgD,UAAU,EAAE;EACrE,MAAM0E,IAAI,GAAG,CAAC8J,OAAO,CAAC5c,IAAI,CAAC,CAAC;EAC5B,IAAIgH,UAAU,YAAY41B,aAAa,EAAE;IACvC9pB,IAAI,CAAC3U,IAAI,CAAC4qG,yBAAyB,CAAC/hG,UAAU,EAAEoH,UAAU,CAAC,CAAC;EAC9D,CAAC,MAAM;IACL0E,IAAI,CAAC3U,IAAI,CAAC6I,UAAU,CAAC;EACvB;EACA,IAAIinD,SAAS,KAAK,IAAI,IAAIY,SAAS,KAAK,IAAI,EAAE;IAC5C/7C,IAAI,CAAC3U,IAAI,CAAC8vD,SAAS,IAAIrxC,OAAO,CAAC,IAAI,CAAC,CAAC;EACvC;EACA,IAAIiyC,SAAS,KAAK,IAAI,EAAE;IACtB/7C,IAAI,CAAC3U,IAAI,CAACye,OAAO,CAACiyC,SAAS,CAAC,CAAC;EAC/B;EACA,OAAO85C,IAAI,CAACvoF,WAAW,CAACnhB,SAAS,EAAE6T,IAAI,EAAE,IAAI,CAAC;AAChD;AACA,SAASgP,SAASA,CAAC9hB,IAAI,EAAEgH,UAAU,EAAE45B,IAAI,EAAExyB,UAAU,EAAE;EACrD,MAAM0E,IAAI,GAAG,CAAC8J,OAAO,CAAC5c,IAAI,CAAC,CAAC;EAC5B,IAAIgH,UAAU,YAAY41B,aAAa,EAAE;IACvC9pB,IAAI,CAAC3U,IAAI,CAAC4qG,yBAAyB,CAAC/hG,UAAU,EAAEoH,UAAU,CAAC,CAAC;EAC9D,CAAC,MAAM;IACL0E,IAAI,CAAC3U,IAAI,CAAC6I,UAAU,CAAC;EACvB;EACA,IAAI45B,IAAI,KAAK,IAAI,EAAE;IACjB9tB,IAAI,CAAC3U,IAAI,CAACye,OAAO,CAACgkB,IAAI,CAAC,CAAC;EAC1B;EACA,OAAO+nE,IAAI,CAACvoF,WAAW,CAAC0B,SAAS,EAAEhP,IAAI,EAAE1E,UAAU,CAAC;AACtD;AACA,SAASoT,SAASA,CAACxhB,IAAI,EAAEgH,UAAU,EAAEoH,UAAU,EAAE;EAC/C,OAAOu6F,IAAI,CAACvoF,WAAW,CAACoB,SAAS,EAAE,CAAC5E,OAAO,CAAC5c,IAAI,CAAC,EAAEgH,UAAU,CAAC,EAAEoH,UAAU,CAAC;AAC7E;AACA,SAASwT,QAAQA,CAAC5a,UAAU,EAAEoH,UAAU,EAAE;EACxC,MAAMnO,KAAK,GAAG+G,UAAU,YAAY41B,aAAa,GAAGmsE,yBAAyB,CAAC/hG,UAAU,EAAEoH,UAAU,CAAC,GAAGpH,UAAU;EAClH,OAAO2hG,IAAI,CAACvoF,WAAW,CAACwB,QAAQ,EAAE,CAAC3hB,KAAK,CAAC,EAAEmO,UAAU,CAAC;AACxD;AACA,SAASyT,QAAQA,CAAC7a,UAAU,EAAEoH,UAAU,EAAE;EACxC,MAAMnO,KAAK,GAAG+G,UAAU,YAAY41B,aAAa,GAAGmsE,yBAAyB,CAAC/hG,UAAU,EAAEoH,UAAU,CAAC,GAAGpH,UAAU;EAClH,OAAO2hG,IAAI,CAACvoF,WAAW,CAACyB,QAAQ,EAAE,CAAC5hB,KAAK,CAAC,EAAEmO,UAAU,CAAC;AACxD;AACA,SAASyS,UAAUA,CAAC+yC,IAAI,EAAEj1D,GAAG,EAAE6pG,UAAU,EAAEC,aAAa,EAAEr6F,UAAU,EAAE;EACpE,OAAOs6F,sBAAsB,CAACtoF,WAAW,CAACS,UAAU,EAAE+yC,IAAI,EAAEj1D,GAAG,EAAE6pG,UAAU,EAAEC,aAAa,EAAEr6F,UAAU,CAAC;AACzG;AACA,SAAS0S,eAAeA,CAAC8yC,IAAI,EAAEj1D,GAAG,EAAE6pG,UAAU,EAAEC,aAAa,EAAEr6F,UAAU,EAAE;EACzE,OAAOs6F,sBAAsB,CAACtoF,WAAW,CAACU,eAAe,EAAE8yC,IAAI,EAAEj1D,GAAG,EAAE6pG,UAAU,EAAEC,aAAa,EAAEr6F,UAAU,CAAC;AAC9G;AACA,SAAS2S,aAAaA,CAAC3S,UAAU,EAAE;EACjC,OAAOu6F,IAAI,CAACvoF,WAAW,CAACW,aAAa,EAAE,EAAE,EAAE3S,UAAU,CAAC;AACxD;AACA,SAAS6S,wBAAwBA,CAAC2yC,IAAI,EAAE40C,UAAU,EAAEC,aAAa,EAAEr6F,UAAU,EAAE;EAC7E,OAAOs6F,sBAAsB,CAACtoF,WAAW,CAACa,wBAAwB,EAAE2yC,IAAI,EAAE,IAAI,EAAE40C,UAAU,EAAEC,aAAa,EAAEr6F,UAAU,CAAC;AACxH;AACA,SAAS4S,mBAAmBA,CAAC4yC,IAAI,EAAE40C,UAAU,EAAEC,aAAa,EAAEr6F,UAAU,EAAE;EACxE,OAAOs6F,sBAAsB,CAACtoF,WAAW,CAACY,mBAAmB,EAAE4yC,IAAI,EAAE,IAAI,EAAE40C,UAAU,EAAEC,aAAa,EAAEr6F,UAAU,CAAC;AACnH;AACA,SAAS8S,sBAAsBA,CAAA,EAAG;EAChC,OAAOynF,IAAI,CAACvoF,WAAW,CAACc,sBAAsB,EAAE,EAAE,EAAE,IAAI,CAAC;AAC3D;AACA,SAASE,WAAWA,CAACphB,IAAI,EAAEgpG,SAAS,EAAEC,mBAAmB,EAAE76F,UAAU,EAAE;EACrE,MAAM0E,IAAI,GAAG,CAAC8J,OAAO,CAAC5c,IAAI,CAAC,EAAEgpG,SAAS,CAAC;EACvC,IAAIC,mBAAmB,KAAK,IAAI,EAAE;IAChCn2F,IAAI,CAAC3U,IAAI,CAACyd,UAAU,CAACqtF,mBAAmB,CAAC,CAAC;EAC5C;EACA,OAAON,IAAI,CAACvoF,WAAW,CAACgB,WAAW,EAAEtO,IAAI,EAAE1E,UAAU,CAAC;AACxD;AACA,SAAS+S,WAAWA,CAACyyC,IAAI,EAAEi1C,aAAa,EAAE1vC,KAAK,EAAE1wB,IAAI,EAAE9pC,GAAG,EAAE6pG,UAAU,EAAEzvC,SAAS,EAAE3qD,UAAU,EAAE;EAC7F,OAAOw6F,YAAY,CAACxoF,WAAW,CAACe,WAAW,EAAEyyC,IAAI,EAAEi1C,aAAa,EAAE1vC,KAAK,EAAE1wB,IAAI,EAAE9pC,GAAG,EAAE6pG,UAAU,EAAEzvC,SAAS,EAAE3qD,UAAU,CAAC;AACxH;AACA,MAAMk8F,aAAa,GAAG,CAAClqF,WAAW,CAAC+F,SAAS,EAAE/F,WAAW,CAACgG,SAAS,EAAEhG,WAAW,CAACiG,SAAS,EAAEjG,WAAW,CAACkG,SAAS,CAAC;AAClH,SAASikF,QAAQA,CAAC32C,IAAI,EAAElB,SAAS,EAAE5/C,IAAI,EAAE;EACvC,IAAIA,IAAI,CAAC5U,MAAM,GAAG,CAAC,IAAI4U,IAAI,CAAC5U,MAAM,GAAGosG,aAAa,CAACpsG,MAAM,EAAE;IACzD,MAAM,IAAIQ,KAAK,CAAC,yCAAyC,CAAC;EAC5D;EACA,MAAMqkE,WAAW,GAAGunC,aAAa,CAACx3F,IAAI,CAAC5U,MAAM,GAAG,CAAC,CAAC;EAClD,OAAO0d,UAAU,CAACmnD,WAAW,CAAC,CAACt0D,MAAM,CAAC,CAACmO,OAAO,CAACg3C,IAAI,CAAC,EAAEh3C,OAAO,CAAC81C,SAAS,CAAC,EAAE,GAAG5/C,IAAI,CAAC,CAAC;AACrF;AACA,SAASyT,SAASA,CAACqtC,IAAI,EAAElB,SAAS,EAAE5/C,IAAI,EAAE;EACxC,OAAO8I,UAAU,CAACwE,WAAW,CAACmG,SAAS,CAAC,CAAC9X,MAAM,CAAC,CAACmO,OAAO,CAACg3C,IAAI,CAAC,EAAEh3C,OAAO,CAAC81C,SAAS,CAAC,EAAE5/C,IAAI,CAAC,CAAC;AAC5F;AACA,SAASgS,eAAeA,CAAC+X,OAAO,EAAE9oB,WAAW,EAAE3F,UAAU,EAAE;EACzD,MAAMo8F,iBAAiB,GAAGC,wBAAwB,CAAC5tE,OAAO,EAAE9oB,WAAW,CAAC;EACxE,OAAO22F,uBAAuB,CAACC,uBAAuB,EAAE,EAAE,EAAEH,iBAAiB,EAAE,EAAE,EAAEp8F,UAAU,CAAC;AAChG;AACA,SAAS+Y,OAAOA,CAAC7U,IAAI,EAAElE,UAAU,EAAE;EACjC,OAAOu6F,IAAI,CAACvoF,WAAW,CAAC+G,OAAO,EAAE,CAAC7U,IAAI,CAAC,EAAElE,UAAU,CAAC;AACtD;AACA,SAASkZ,SAASA,CAACssC,IAAI,EAAExlD,UAAU,EAAE;EACnC,OAAOu6F,IAAI,CAACvoF,WAAW,CAACkH,SAAS,EAAE,CAAC1K,OAAO,CAACg3C,IAAI,CAAC,CAAC,EAAExlD,UAAU,CAAC;AACjE;AACA,SAASoY,WAAWA,CAACxmB,IAAI,EAAEgH,UAAU,EAAEinD,SAAS,EAAE7/C,UAAU,EAAE;EAC5D,OAAO06F,YAAY,CAAC1oF,WAAW,CAACoG,WAAW,EAAExmB,IAAI,EAAEgH,UAAU,EAAEinD,SAAS,EAAE7/C,UAAU,CAAC;AACvF;AACA,SAASm2F,SAASA,CAAC70C,aAAa,EAAEs5C,SAAS,EAAE/6C,SAAS,EAAE7/C,UAAU,EAAE;EAClE,MAAM0E,IAAI,GAAG,CAACk2F,SAAS,CAAC;EACxB,IAAI/6C,SAAS,KAAK,IAAI,EAAE;IACtBn7C,IAAI,CAAC3U,IAAI,CAAC8vD,SAAS,CAAC;EACtB;EACA,MAAMjU,UAAU,GAAG0V,aAAa,KAAK,OAAO,GAAGtvC,WAAW,CAAC2G,cAAc,GAAG3G,WAAW,CAAC4G,cAAc;EACtG,OAAO2hF,IAAI,CAAC3uD,UAAU,EAAElnC,IAAI,EAAE1E,UAAU,CAAC;AAC3C;AACA,SAASw8F,eAAeA,CAACl7C,aAAa,EAAE1oD,UAAU,EAAEinD,SAAS,EAAE7/C,UAAU,EAAE;EACzE,MAAMnO,KAAK,GAAG+G,UAAU,YAAY41B,aAAa,GAAGmsE,yBAAyB,CAAC/hG,UAAU,EAAEoH,UAAU,CAAC,GAAGpH,UAAU;EAClH,MAAM8L,IAAI,GAAG,CAAC7S,KAAK,CAAC;EACpB,IAAIguD,SAAS,KAAK,IAAI,EAAE;IACtBn7C,IAAI,CAAC3U,IAAI,CAAC8vD,SAAS,CAAC;EACtB;EACA,MAAMjU,UAAU,GAAG0V,aAAa,KAAK,OAAO,GAAGtvC,WAAW,CAAC2G,cAAc,GAAG3G,WAAW,CAAC4G,cAAc;EACtG,OAAO2hF,IAAI,CAAC3uD,UAAU,EAAElnC,IAAI,EAAE1E,UAAU,CAAC;AAC3C;AACA,SAASy8F,iBAAiBA,CAACn7C,aAAa,EAAEs5C,SAAS,EAAEC,mBAAmB,EAAE76F,UAAU,EAAE;EACpF,MAAM0E,IAAI,GAAG,CAACk2F,SAAS,CAAC;EACxB,MAAMhvD,UAAU,GAAG0V,aAAa,KAAK,OAAO,GAAGtvC,WAAW,CAACyG,sBAAsB,GAAGzG,WAAW,CAAC0G,sBAAsB;EACtH,OAAO6hF,IAAI,CAAC3uD,UAAU,EAAElnC,IAAI,EAAE1E,UAAU,CAAC;AAC3C;AACA,SAASkT,qBAAqBA,CAACthB,IAAI,EAAEgH,UAAU,EAAEoH,UAAU,EAAE;EAC3D,OAAOu6F,IAAI,CAACvoF,WAAW,CAACkB,qBAAqB,EAAE,CAAC1E,OAAO,CAAC5c,IAAI,CAAC,EAAEgH,UAAU,CAAC,EAAEoH,UAAU,CAAC;AACzF;AACA,SAAS08F,YAAYA,CAACp4C,SAAS,EAAE7/C,EAAE,EAAEC,IAAI,EAAE;EACzC,OAAOi4F,2BAA2B,CAACC,oBAAoB,EAAE,CAACpuF,OAAO,CAAC81C,SAAS,CAAC,EAAE7/C,EAAE,CAAC,EAAEC,IAAI,EAAE,EAAE,EAAE,IAAI,CAAC;AACpG;AACA,SAASm4F,oBAAoBA,CAACptC,YAAY,EAAEC,SAAS,EAAE;EACrD,OAAO6qC,IAAI,CAACvoF,WAAW,CAACiL,qBAAqB,EAAE,CAACzO,OAAO,CAACihD,YAAY,CAAC,EAAEC,SAAS,CAAC,EAAE,IAAI,CAAC;AAC1F;AACA,SAAS2sC,wBAAwBA,CAAC5tE,OAAO,EAAE9oB,WAAW,EAAE;EACtD,IAAI8oB,OAAO,CAAC3+B,MAAM,GAAG,CAAC,IAAI6V,WAAW,CAAC7V,MAAM,KAAK2+B,OAAO,CAAC3+B,MAAM,GAAG,CAAC,EAAE;IACnE,MAAM,IAAIQ,KAAK,CAAC,0FAA0F,CAAC;EAC7G;EACA,MAAM8rG,iBAAiB,GAAG,EAAE;EAC5B,IAAIz2F,WAAW,CAAC7V,MAAM,KAAK,CAAC,IAAI2+B,OAAO,CAAC,CAAC,CAAC,KAAK,EAAE,IAAIA,OAAO,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;IACtE2tE,iBAAiB,CAACrsG,IAAI,CAAC4V,WAAW,CAAC,CAAC,CAAC,CAAC;EACxC,CAAC,MAAM;IACL,IAAI4+C,GAAG;IACP,KAAKA,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG5+C,WAAW,CAAC7V,MAAM,EAAEy0D,GAAG,EAAE,EAAE;MAC7C63C,iBAAiB,CAACrsG,IAAI,CAACye,OAAO,CAACigB,OAAO,CAAC81B,GAAG,CAAC,CAAC,EAAE5+C,WAAW,CAAC4+C,GAAG,CAAC,CAAC;IACjE;IACA63C,iBAAiB,CAACrsG,IAAI,CAACye,OAAO,CAACigB,OAAO,CAAC81B,GAAG,CAAC,CAAC,CAAC;EAC/C;EACA,OAAO63C,iBAAiB;AAC1B;AACA,SAASzB,yBAAyBA,CAAC17C,aAAa,EAAEj/C,UAAU,EAAE;EAC5D,MAAMo8F,iBAAiB,GAAGC,wBAAwB,CAACp9C,aAAa,CAACxwB,OAAO,EAAEwwB,aAAa,CAACt5C,WAAW,CAAC;EACpG,OAAOg3F,2BAA2B,CAACG,wBAAwB,EAAE,EAAE,EAAEV,iBAAiB,EAAE,EAAE,EAAEp8F,UAAU,CAAC;AACrG;AACA,SAASu6F,IAAIA,CAAC5lC,WAAW,EAAEjwD,IAAI,EAAE1E,UAAU,EAAE;EAC3C,MAAMkE,IAAI,GAAGsJ,UAAU,CAACmnD,WAAW,CAAC,CAACt0D,MAAM,CAACqE,IAAI,EAAE1E,UAAU,CAAC;EAC7D,OAAOy+C,iBAAiB,CAAC,IAAI/6C,mBAAmB,CAACQ,IAAI,EAAElE,UAAU,CAAC,CAAC;AACrE;AACA,SAASW,WAAWA,CAACyH,SAAS,EAAE44C,YAAY,EAAEhhD,UAAU,EAAE;EACxD,MAAM0E,IAAI,GAAG,CAAC0D,SAAS,CAAC;EACxB,IAAI44C,YAAY,KAAK,IAAI,EAAE;IACzBt8C,IAAI,CAAC3U,IAAI,CAACixD,YAAY,CAAC;EACzB;EACA,OAAOu5C,IAAI,CAACvoF,WAAW,CAACrR,WAAW,EAAE+D,IAAI,EAAE1E,UAAU,CAAC;AACxD;AACA,MAAMu8F,uBAAuB,GAAG;EAC9BQ,QAAQ,EAAE,CAAC/qF,WAAW,CAAC0E,eAAe,EAAE1E,WAAW,CAAC2E,gBAAgB,EAAE3E,WAAW,CAAC4E,gBAAgB,EAAE5E,WAAW,CAAC6E,gBAAgB,EAAE7E,WAAW,CAAC8E,gBAAgB,EAAE9E,WAAW,CAAC+E,gBAAgB,EAAE/E,WAAW,CAACgF,gBAAgB,EAAEhF,WAAW,CAACiF,gBAAgB,EAAEjF,WAAW,CAACkF,gBAAgB,CAAC;EACvR3J,QAAQ,EAAEyE,WAAW,CAACmF,gBAAgB;EACtC6lF,OAAO,EAAE1gE,CAAC,IAAI;IACZ,IAAIA,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;MACf,MAAM,IAAIhsC,KAAK,CAAC,kCAAkC,CAAC;IACrD;IACA,OAAO,CAACgsC,CAAC,GAAG,CAAC,IAAI,CAAC;EACpB;AACF,CAAC;AACD,MAAMwgE,wBAAwB,GAAG;EAC/BC,QAAQ,EAAE,CAAC/qF,WAAW,CAAC2B,WAAW,EAAE3B,WAAW,CAAC4B,YAAY,EAAE5B,WAAW,CAAC6B,YAAY,EAAE7B,WAAW,CAAC8B,YAAY,EAAE9B,WAAW,CAAC+B,YAAY,EAAE/B,WAAW,CAACgC,YAAY,EAAEhC,WAAW,CAACiC,YAAY,EAAEjC,WAAW,CAACkC,YAAY,EAAElC,WAAW,CAACmC,YAAY,CAAC;EACnP5G,QAAQ,EAAEyE,WAAW,CAACoC,YAAY;EAClC4oF,OAAO,EAAE1gE,CAAC,IAAI;IACZ,IAAIA,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;MACf,MAAM,IAAIhsC,KAAK,CAAC,kCAAkC,CAAC;IACrD;IACA,OAAO,CAACgsC,CAAC,GAAG,CAAC,IAAI,CAAC;EACpB;AACF,CAAC;AACD,MAAMsgE,oBAAoB,GAAG;EAC3BG,QAAQ,EAAE,CAAC/qF,WAAW,CAACqF,aAAa,EAAErF,WAAW,CAACsF,aAAa,EAAEtF,WAAW,CAACuF,aAAa,EAAEvF,WAAW,CAACwF,aAAa,EAAExF,WAAW,CAACyF,aAAa,EAAEzF,WAAW,CAAC0F,aAAa,EAAE1F,WAAW,CAAC2F,aAAa,EAAE3F,WAAW,CAAC4F,aAAa,EAAE5F,WAAW,CAAC6F,aAAa,CAAC;EAC7PtK,QAAQ,EAAEyE,WAAW,CAAC8F,aAAa;EACnCklF,OAAO,EAAE1gE,CAAC,IAAIA;AAChB,CAAC;AACD,SAASqgE,2BAA2BA,CAACM,MAAM,EAAEC,QAAQ,EAAEd,iBAAiB,EAAEe,SAAS,EAAEn9F,UAAU,EAAE;EAC/F,MAAMs8B,CAAC,GAAG2gE,MAAM,CAACD,OAAO,CAACZ,iBAAiB,CAACtsG,MAAM,CAAC;EAClD,MAAMstG,oBAAoB,GAAGhB,iBAAiB,CAACiB,EAAE,CAAC,CAAC,CAAC,CAAC;EACrD,IAAIF,SAAS,CAACrtG,MAAM,KAAK,CAAC,IAAIssG,iBAAiB,CAACtsG,MAAM,GAAG,CAAC,IAAIstG,oBAAoB,YAAY73F,WAAW,IAAI63F,oBAAoB,CAACvrG,KAAK,KAAK,EAAE,EAAE;IAC9IuqG,iBAAiB,CAACn3E,GAAG,CAAC,CAAC;EACzB;EACA,IAAIqX,CAAC,GAAG2gE,MAAM,CAACF,QAAQ,CAACjtG,MAAM,EAAE;IAC9B,OAAO0d,UAAU,CAACyvF,MAAM,CAACF,QAAQ,CAACzgE,CAAC,CAAC,CAAC,CAACj8B,MAAM,CAAC,CAAC,GAAG68F,QAAQ,EAAE,GAAGd,iBAAiB,EAAE,GAAGe,SAAS,CAAC,EAAEn9F,UAAU,CAAC;EAC7G,CAAC,MAAM,IAAIi9F,MAAM,CAAC1vF,QAAQ,KAAK,IAAI,EAAE;IACnC,OAAOC,UAAU,CAACyvF,MAAM,CAAC1vF,QAAQ,CAAC,CAAClN,MAAM,CAAC,CAAC,GAAG68F,QAAQ,EAAEpvF,UAAU,CAACsuF,iBAAiB,CAAC,EAAE,GAAGe,SAAS,CAAC,EAAEn9F,UAAU,CAAC;EACnH,CAAC,MAAM;IACL,MAAM,IAAI1P,KAAK,CAAC,kDAAkD,CAAC;EACrE;AACF;AACA,SAASgsG,uBAAuBA,CAACW,MAAM,EAAEC,QAAQ,EAAEd,iBAAiB,EAAEe,SAAS,EAAEn9F,UAAU,EAAE;EAC3F,OAAOy+C,iBAAiB,CAACk+C,2BAA2B,CAACM,MAAM,EAAEC,QAAQ,EAAEd,iBAAiB,EAAEe,SAAS,EAAEn9F,UAAU,CAAC,CAACyD,MAAM,CAAC,CAAC,CAAC;AAC5H;AAEA,MAAM65F,uBAAuB,GAAG,IAAI9qG,GAAG,CAAC,CAAC,CAAC,QAAQ,EAAEwf,WAAW,CAACqI,aAAa,CAAC,EAAE,CAAC,UAAU,EAAErI,WAAW,CAACsI,eAAe,CAAC,EAAE,CAAC,MAAM,EAAEtI,WAAW,CAACuI,WAAW,CAAC,CAAC,CAAC;AAC9J,MAAMgjF,sBAAsB,GAAG,IAAI/qG,GAAG,CAAC,CAAC,CAAC,OAAO,EAAE,WAAW,CAAC,EAAE,CAAC,KAAK,EAAE,SAAS,CAAC,EAAE,CAAC,YAAY,EAAE,YAAY,CAAC,EAAE,CAAC,WAAW,EAAE,WAAW,CAAC,EAAE,CAAC,UAAU,EAAE,UAAU,CAAC,EAAE,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC,CAAC;AAClM,SAASgrG,KAAKA,CAACvrC,GAAG,EAAE;EAClB,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5BosC,qBAAqB,CAACjrE,IAAI,EAAEA,IAAI,CAACo/B,MAAM,CAAC;IACxC8rC,qBAAqB,CAAClrE,IAAI,EAAEA,IAAI,CAACq/B,MAAM,CAAC;EAC1C;AACF;AACA,SAAS4rC,qBAAqBA,CAACjrE,IAAI,EAAE62B,GAAG,EAAE;EACxC,KAAK,MAAMn/C,EAAE,IAAIm/C,GAAG,EAAE;IACpBtD,wBAAwB,CAAC77C,EAAE,EAAEyzF,iBAAiB,EAAEn5C,kBAAkB,CAACpnD,IAAI,CAAC;IACxE,QAAQ8M,EAAE,CAACmhC,IAAI;MACb,KAAK0R,MAAM,CAACvpB,IAAI;QACdq1B,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAElS,IAAI,CAACkS,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEt7C,EAAE,CAAC6hD,YAAY,EAAE7hD,EAAE,CAAClK,UAAU,CAAC,CAAC;QACxE;MACF,KAAK+8C,MAAM,CAAC4K,YAAY;QACtBkB,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEsoB,IAAI,CAACy/B,GAAG,CAAC9B,IAAI,KAAKJ,uBAAuB,CAACoE,OAAO,GAAGzhD,eAAe,CAACxI,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEt7C,EAAE,CAAC3Z,GAAG,EAAE2Z,EAAE,CAACuqB,UAAU,EAAEvqB,EAAE,CAACygD,SAAS,EAAEzgD,EAAE,CAAC6qB,eAAe,CAAC,GAAGxiB,YAAY,CAACrI,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEt7C,EAAE,CAAC3Z,GAAG,EAAE2Z,EAAE,CAACuqB,UAAU,EAAEvqB,EAAE,CAACygD,SAAS,EAAEzgD,EAAE,CAAC6qB,eAAe,CAAC,CAAC;QACxP;MACF,KAAKgoB,MAAM,CAACvoB,OAAO;QACjBq0B,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEsoB,IAAI,CAACy/B,GAAG,CAAC9B,IAAI,KAAKJ,uBAAuB,CAACoE,OAAO,GAAG1hD,UAAU,CAACvI,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEt7C,EAAE,CAAC3Z,GAAG,EAAE2Z,EAAE,CAACuqB,UAAU,EAAEvqB,EAAE,CAACygD,SAAS,EAAEzgD,EAAE,CAACwgD,eAAe,CAAC,GAAGt7D,OAAO,CAAC8a,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEt7C,EAAE,CAAC3Z,GAAG,EAAE2Z,EAAE,CAACuqB,UAAU,EAAEvqB,EAAE,CAACygD,SAAS,EAAEzgD,EAAE,CAACwgD,eAAe,CAAC,CAAC;QAC9O;MACF,KAAK3N,MAAM,CAAC2K,UAAU;QACpBmB,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEsoB,IAAI,CAACy/B,GAAG,CAAC9B,IAAI,KAAKJ,uBAAuB,CAACoE,OAAO,GAAGxhD,aAAa,CAACzI,EAAE,CAAClK,UAAU,CAAC,GAAGwS,UAAU,CAACtI,EAAE,CAAClK,UAAU,CAAC,CAAC;QAChI;MACF,KAAK+8C,MAAM,CAACwK,cAAc;QACxBsB,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEsoB,IAAI,CAACy/B,GAAG,CAAC9B,IAAI,KAAKJ,uBAAuB,CAACoE,OAAO,GAAGthD,wBAAwB,CAAC3I,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEt7C,EAAE,CAACuqB,UAAU,EAAEvqB,EAAE,CAACygD,SAAS,EAAEzgD,EAAE,CAAC6qB,eAAe,CAAC,GAAG1hB,qBAAqB,CAACnJ,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEt7C,EAAE,CAACuqB,UAAU,EAAEvqB,EAAE,CAACygD,SAAS,EAAEzgD,EAAE,CAAC6qB,eAAe,CAAC,CAAC;QAC1P;MACF,KAAKgoB,MAAM,CAACjhB,SAAS;QACnB+sB,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEsoB,IAAI,CAACy/B,GAAG,CAAC9B,IAAI,KAAKJ,uBAAuB,CAACoE,OAAO,GAAGvhD,mBAAmB,CAAC1I,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEt7C,EAAE,CAACuqB,UAAU,EAAEvqB,EAAE,CAACygD,SAAS,EAAEzgD,EAAE,CAACwgD,eAAe,CAAC,GAAGn3C,gBAAgB,CAACrJ,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEt7C,EAAE,CAACuqB,UAAU,EAAEvqB,EAAE,CAACygD,SAAS,EAAEzgD,EAAE,CAACwgD,eAAe,CAAC,CAAC;QAChP;MACF,KAAK3N,MAAM,CAACuK,YAAY;QACtBuB,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEsoB,IAAI,CAACy/B,GAAG,CAAC9B,IAAI,KAAKJ,uBAAuB,CAACoE,OAAO,GAAGrhD,sBAAsB,CAAC,CAAC,GAAGQ,mBAAmB,CAAC,CAAC,CAAC;QACxH;MACF,KAAKypC,MAAM,CAACiL,SAAS;QACnBa,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAE8O,SAAS,CAAC9O,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEt7C,EAAE,CAAC0kD,YAAY,EAAE1kD,EAAE,CAAC2kD,gBAAgB,EAAE3kD,EAAE,CAAClK,UAAU,CAAC,CAAC;QAClG;MACF,KAAK+8C,MAAM,CAACgL,OAAO;QACjBc,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAE+O,OAAO,CAAC/O,EAAE,CAAClK,UAAU,CAAC,CAAC;QAC1C;MACF,KAAK+8C,MAAM,CAAC8K,IAAI;QACdgB,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAE2O,IAAI,CAAC3O,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEt7C,EAAE,CAAC0kD,YAAY,EAAE1kD,EAAE,CAAC2kD,gBAAgB,EAAE3kD,EAAE,CAAClK,UAAU,CAAC,CAAC;QAC7F;MACF,KAAK+8C,MAAM,CAACsL,cAAc;QACxB,IAAIn+C,EAAE,CAACqlD,oBAAoB,KAAK,IAAI,EAAE;UACpC,MAAM,IAAIj/D,KAAK,CAAC,kDAAkD,CAAC;QACrE;QACAu4D,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAE4O,cAAc,CAAC5O,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEt7C,EAAE,CAACqlD,oBAAoB,CAAC,CAAC;QAC3E;MACF,KAAKxS,MAAM,CAACtjB,QAAQ;QAClB,IAAI,EAAEjH,IAAI,YAAYs+B,mBAAmB,CAAC,EAAE;UAC1C,MAAM,IAAIxgE,KAAK,CAAC,+CAA+C,CAAC;QAClE;QACA,IAAI+Y,KAAK,CAACC,OAAO,CAACY,EAAE,CAACygD,SAAS,CAAC,EAAE;UAC/B,MAAM,IAAIr6D,KAAK,CAAC,6EAA6E,CAAC;QAChG;QACA,MAAM+lG,SAAS,GAAG7jE,IAAI,CAACy/B,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAAC00C,IAAI,CAAC;QAC7CiK,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEA,EAAE,CAACq1C,YAAY,KAAK5B,YAAY,CAACojB,KAAK,IAAIvuC,IAAI,CAACy/B,GAAG,CAAC9B,IAAI,KAAKJ,uBAAuB,CAACoE,OAAO,GAAGphD,WAAW,CAAC7I,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEj4C,QAAQ,CAAC8oF,SAAS,CAACvkC,MAAM,CAAC,EAAEukC,SAAS,CAACtrC,KAAK,EAAEsrC,SAAS,CAACh8D,IAAI,EAAEnwB,EAAE,CAAC3Z,GAAG,EAAE2Z,EAAE,CAACuqB,UAAU,EAAEvqB,EAAE,CAACygD,SAAS,EAAEzgD,EAAE,CAAC6qB,eAAe,CAAC,GAAGhwB,QAAQ,CAACmF,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEj4C,QAAQ,CAAC8oF,SAAS,CAACvkC,MAAM,CAAC,EAAEukC,SAAS,CAACtrC,KAAK,EAAEsrC,SAAS,CAACh8D,IAAI,EAAEnwB,EAAE,CAAC3Z,GAAG,EAAE2Z,EAAE,CAACuqB,UAAU,EAAEvqB,EAAE,CAACygD,SAAS,EAAEzgD,EAAE,CAAC6qB,eAAe,CAAC,CAAC;QACpZ;MACF,KAAKgoB,MAAM,CAAC0K,eAAe;QACzBoB,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEsM,eAAe,CAAC,CAAC,CAAC;QACrC;MACF,KAAKumC,MAAM,CAAC6K,cAAc;QACxBiB,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEqM,cAAc,CAAC,CAAC,CAAC;QACpC;MACF,KAAKwmC,MAAM,CAACxxB,IAAI;QACds9B,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEkP,IAAI,CAAClP,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEt7C,EAAE,CAACtY,IAAI,CAAC,CAAC;QACjD;MACF,KAAKmrD,MAAM,CAACuL,UAAU;QACpBO,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAE4S,UAAU,CAAC5S,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEt7C,EAAE,CAAClK,UAAU,CAAC,CAAC;QAC7D;MACF,KAAK+8C,MAAM,CAACkJ,eAAe;QACzB4C,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEsyF,eAAe,CAACtyF,EAAE,CAACo3C,aAAa,EAAEp3C,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAAC21C,SAAS,EAAE31C,EAAE,CAAClK,UAAU,CAAC,CAAC;QACjG;MACF,KAAK+8C,MAAM,CAACqJ,SAAS;QACnB,MAAMw3C,mBAAmB,GAAGC,oBAAoB,CAACrrE,IAAI,EAAEtoB,EAAE,CAACiiD,aAAa,EAAEjiD,EAAE,CAACu8C,UAAU,EAAE,KAAK,CAAC;QAC9FoC,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEisF,SAAS,CAACjsF,EAAE,CAACo3C,aAAa,EAAEs8C,mBAAmB,EAAE1zF,EAAE,CAAC21C,SAAS,EAAE31C,EAAE,CAAClK,UAAU,CAAC,CAAC;QACjG;MACF,KAAK+8C,MAAM,CAACsJ,iBAAiB;QAC3B,MAAMy3C,mBAAmB,GAAGD,oBAAoB,CAACrrE,IAAI,EAAEtoB,EAAE,CAACiiD,aAAa,EAAEjiD,EAAE,CAACu8C,UAAU,EAAEv8C,EAAE,CAACuiD,mBAAmB,CAAC;QAC/G5D,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEuyF,iBAAiB,CAACvyF,EAAE,CAACo3C,aAAa,EAAEw8C,mBAAmB,EAAE,IAAI,EAAE5zF,EAAE,CAAClK,UAAU,CAAC,CAAC;QACjG;MACF,KAAK+8C,MAAM,CAACuJ,QAAQ;QAClB,MAAMy3C,UAAU,GAAGF,oBAAoB,CAACrrE,IAAI,EAAEtoB,EAAE,CAACiiD,aAAa,EAAEjiD,EAAE,CAACu8C,UAAU,EAAEv8C,EAAE,CAACuiD,mBAAmB,CAAC;QACtG,MAAMouC,mBAAmB,GAAG3wF,EAAE,CAACoiD,WAAW,GAAGgxC,uBAAuB,CAACzpG,GAAG,CAACqW,EAAE,CAACoiD,WAAW,CAAC,GAAG,IAAI;QAC/F,IAAIuuC,mBAAmB,KAAKl7E,SAAS,EAAE;UACrC,MAAM,IAAIrvB,KAAK,CAAC,6BAA6B4Z,EAAE,CAACoiD,WAAW,kBAAkBpiD,EAAE,CAACtY,IAAI,kEAAkE,CAAC;QACzJ;QACAi3D,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEsoB,IAAI,CAACy/B,GAAG,CAAC9B,IAAI,KAAKJ,uBAAuB,CAACoE,OAAO,IAAI,CAACjqD,EAAE,CAACqiD,YAAY,IAAI,CAACriD,EAAE,CAACwiD,yBAAyB,GAAG15C,WAAW,CAAC9I,EAAE,CAACtY,IAAI,EAAEmsG,UAAU,EAAElD,mBAAmB,EAAE3wF,EAAE,CAAClK,UAAU,CAAC,GAAGud,QAAQ,CAACrT,EAAE,CAACtY,IAAI,EAAEmsG,UAAU,EAAElD,mBAAmB,EAAE3wF,EAAE,CAACqiD,YAAY,IAAIriD,EAAE,CAACwiD,yBAAyB,EAAExiD,EAAE,CAAClK,UAAU,CAAC,CAAC;QACtT;MACF,KAAK+8C,MAAM,CAACwJ,cAAc;QACxBsC,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAE2S,cAAc,CAAC3S,EAAE,CAACtY,IAAI,EAAEisG,oBAAoB,CAACrrE,IAAI,EAAEtoB,EAAE,CAACiiD,aAAa,EAAEjiD,EAAE,CAACu8C,UAAU,EAAE,IAAI,CAAC,EAAEv8C,EAAE,CAAClK,UAAU,CAAC,CAAC;QAC7H;MACF,KAAK+8C,MAAM,CAAChjB,QAAQ;QAClB,IAAI7vB,EAAE,CAACqD,QAAQ,CAAC3b,IAAI,KAAK,IAAI,EAAE;UAC7B,MAAM,IAAItB,KAAK,CAAC,oCAAoC4Z,EAAE,CAAC00C,IAAI,EAAE,CAAC;QAChE;QACAiK,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEu0C,iBAAiB,CAAC,IAAIj1C,cAAc,CAACU,EAAE,CAACqD,QAAQ,CAAC3b,IAAI,EAAEsY,EAAE,CAAC20C,WAAW,EAAEl/B,SAAS,EAAEhU,YAAY,CAAC+E,KAAK,CAAC,CAAC,CAAC;QAC1H;MACF,KAAKqsC,MAAM,CAACS,SAAS;QACnB,QAAQtzC,EAAE,CAAC6iD,MAAM;UACf,KAAKvP,SAAS,CAACiO,IAAI;YACjB5C,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEkI,aAAa,CAAC,CAAC,CAAC;YACnC;UACF,KAAKorC,SAAS,CAACmY,GAAG;YAChB9M,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEoI,YAAY,CAAC,CAAC,CAAC;YAClC;UACF,KAAKkrC,SAAS,CAACoY,IAAI;YACjB/M,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAE6wF,aAAa,CAAC,CAAC,CAAC;YACnC;QACJ;QACA;MACF,KAAKh+C,MAAM,CAACiK,KAAK;QACf,MAAMg3C,eAAe,GAAG,CAAC,CAAC9zF,EAAE,CAAC0jD,kBAAkB,IAAI,CAAC,CAAC1jD,EAAE,CAAC2jD,gBAAgB,IAAI,CAAC,CAAC3jD,EAAE,CAAC8jD,sBAAsB;QACvGnF,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEsK,KAAK,CAACtK,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEt7C,EAAE,CAACqjD,QAAQ,CAAC/H,IAAI,EAAEt7C,EAAE,CAACi9C,UAAU,EAAEj9C,EAAE,CAACyjD,WAAW,EAAEnI,IAAI,IAAI,IAAI,EAAEt7C,EAAE,CAAC6jD,eAAe,EAAEvI,IAAI,IAAI,IAAI,EAAEt7C,EAAE,CAACgkD,SAAS,EAAE1I,IAAI,IAAI,IAAI,EAAEt7C,EAAE,CAAC+8C,aAAa,EAAE/8C,EAAE,CAACg9C,iBAAiB,EAAE82C,eAAe,EAAE9zF,EAAE,CAAClK,UAAU,EAAEkK,EAAE,CAAC7E,KAAK,CAAC,CAAC;QACxP;MACF,KAAK03C,MAAM,CAACyK,OAAO;QACjB,IAAI9iD,IAAI,GAAG,EAAE;QACb,QAAQwF,EAAE,CAACgxB,OAAO,CAACmQ,IAAI;UACrB,KAAKoS,gBAAgB,CAACwb,KAAK;UAC3B,KAAKxb,gBAAgB,CAACub,IAAI;UAC1B,KAAKvb,gBAAgB,CAACyb,SAAS;YAC7B;UACF,KAAKzb,gBAAgB,CAAC0b,KAAK;YACzBz0D,IAAI,GAAG,CAAC8J,OAAO,CAACtE,EAAE,CAACgxB,OAAO,CAACnF,KAAK,CAAC,CAAC;YAClC;UACF,KAAK0nB,gBAAgB,CAAC6b,QAAQ;YAC5B,IAAIpvD,EAAE,CAAC5M,QAAQ,KAAK,SAAS,EAAE;cAC7BoH,IAAI,GAAGwF,EAAE,CAACgxB,OAAO,CAAChF,OAAO,GAAG,CAAChsB,EAAE,CAACgxB,OAAO,CAAChF,OAAO,CAAC,GAAG,EAAE;YACvD,CAAC,MAAM;cACLxxB,IAAI,GAAG,CAAC8J,OAAO,CAACtE,EAAE,CAACgxB,OAAO,CAACgmB,UAAU,EAAEsE,IAAI,IAAI,IAAI,CAAC,CAAC;cACrD,IAAIt7C,EAAE,CAACgxB,OAAO,CAACy+B,mBAAmB,KAAK,CAAC,EAAE;gBACxCj1D,IAAI,CAAC3U,IAAI,CAACye,OAAO,CAACtE,EAAE,CAACgxB,OAAO,CAACy+B,mBAAmB,CAAC,CAAC;cACpD,CAAC,MAAM,IAAIzvD,EAAE,CAACgxB,OAAO,CAAChF,OAAO,EAAE;gBAC7BxxB,IAAI,CAAC3U,IAAI,CAACye,OAAO,CAAC,IAAI,CAAC,CAAC;cAC1B;cACA,IAAItE,EAAE,CAACgxB,OAAO,CAAChF,OAAO,EAAE;gBACtBxxB,IAAI,CAAC3U,IAAI,CAACma,EAAE,CAACgxB,OAAO,CAAChF,OAAO,CAAC;cAC/B;YACF;YACA;UACF,KAAKunB,gBAAgB,CAAC4b,WAAW;UACjC,KAAK5b,gBAAgB,CAAC2b,KAAK;YACzB,IAAIlvD,EAAE,CAAC5M,QAAQ,KAAK,SAAS,EAAE;cAC7BoH,IAAI,GAAG,EAAE;YACX,CAAC,MAAM;cACLA,IAAI,GAAG,CAAC8J,OAAO,CAACtE,EAAE,CAACgxB,OAAO,CAACgmB,UAAU,EAAEsE,IAAI,IAAI,IAAI,CAAC,CAAC;cACrD,IAAIt7C,EAAE,CAACgxB,OAAO,CAACy+B,mBAAmB,KAAK,CAAC,EAAE;gBACxCj1D,IAAI,CAAC3U,IAAI,CAACye,OAAO,CAACtE,EAAE,CAACgxB,OAAO,CAACy+B,mBAAmB,CAAC,CAAC;cACpD;YACF;YACA;UACF;YACE,MAAM,IAAIrpE,KAAK,CAAC,iEAAiE4Z,EAAE,CAACgxB,OAAO,CAACmQ,IAAI,EAAE,CAAC;QACvG;QACAwd,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEqxF,OAAO,CAACrxF,EAAE,CAACgxB,OAAO,CAACmQ,IAAI,EAAE3mC,IAAI,EAAEwF,EAAE,CAAC5M,QAAQ,EAAE4M,EAAE,CAAClK,UAAU,CAAC,CAAC;QAC9E;MACF,KAAK+8C,MAAM,CAACqL,aAAa;QACvBS,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEoP,aAAa,CAACpP,EAAE,CAAC0G,GAAG,CAAC,CAAC;QACzC;MACF,KAAKmsC,MAAM,CAACoL,UAAU;QACpB,IAAIj+C,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,KAAK,IAAI,EAAE;UAC3B,MAAM,IAAIl1D,KAAK,CAAC,8CAA8C,CAAC;QACjE;QACA,IAAI2tG,kBAAkB,GAAG,IAAI;QAC7B,IAAIvC,aAAa,GAAG,IAAI;QACxB,IAAIC,YAAY,GAAG,IAAI;QACvB,IAAIzxF,EAAE,CAACgjD,YAAY,KAAK,IAAI,EAAE;UAC5B,IAAI,EAAE16B,IAAI,YAAYs+B,mBAAmB,CAAC,EAAE;YAC1C,MAAM,IAAIxgE,KAAK,CAAC,+CAA+C,CAAC;UAClE;UACA,MAAM48D,YAAY,GAAG16B,IAAI,CAACy/B,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAACgjD,YAAY,CAAC;UACxD,IAAIA,YAAY,KAAKvtC,SAAS,EAAE;YAC9B,MAAM,IAAIrvB,KAAK,CAAC,oFAAoF,CAAC;UACvG;UACA,IAAI48D,YAAY,CAAC4E,MAAM,KAAK,IAAI,IAAI5E,YAAY,CAACnC,KAAK,KAAK,IAAI,IAAImC,YAAY,CAAC7yB,IAAI,KAAK,IAAI,EAAE;YAC7F,MAAM,IAAI/pC,KAAK,CAAC,kFAAkF,CAAC;UACrG;UACA2tG,kBAAkB,GAAG/wC,YAAY,CAAC4E,MAAM;UACxC4pC,aAAa,GAAGxuC,YAAY,CAACnC,KAAK;UAClC4wC,YAAY,GAAGzuC,YAAY,CAAC7yB,IAAI;QAClC;QACAwuB,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEmP,UAAU,CAACnP,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEt7C,EAAE,CAACijD,mBAAmB,EAAEjjD,EAAE,CAACuqB,UAAU,EAAEwpE,kBAAkB,EAAEvC,aAAa,EAAEC,YAAY,EAAEzxF,EAAE,CAAClK,UAAU,CAAC,CAAC;QACrJ;MACF,KAAK+8C,MAAM,CAACyL,iBAAiB;QAC3B,IAAI,EAAEh2B,IAAI,YAAYs+B,mBAAmB,CAAC,EAAE;UAC1C,MAAM,IAAIxgE,KAAK,CAAC,+CAA+C,CAAC;QAClE;QACA,IAAI+Y,KAAK,CAACC,OAAO,CAACY,EAAE,CAACygD,SAAS,CAAC,EAAE;UAC/B,MAAM,IAAIr6D,KAAK,CAAC,6EAA6E,CAAC;QAChG;QACA,MAAM4tG,0BAA0B,GAAG1rE,IAAI,CAACy/B,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAAC00C,IAAI,CAAC;QAC9DiK,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAE8L,iBAAiB,CAAC9L,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEj4C,QAAQ,CAAC2wF,0BAA0B,CAACpsC,MAAM,CAAC,EAAEosC,0BAA0B,CAACnzC,KAAK,EAAEmzC,0BAA0B,CAAC7jE,IAAI,EAAEnwB,EAAE,CAAC3Z,GAAG,EAAE2Z,EAAE,CAACuqB,UAAU,EAAEvqB,EAAE,CAACygD,SAAS,EAAEzgD,EAAE,CAAC6qB,eAAe,CAAC,CAAC;QAC9N;MACF,KAAKgoB,MAAM,CAAC0L,uBAAuB;QACjC,IAAI,EAAEj2B,IAAI,YAAYs+B,mBAAmB,CAAC,EAAE;UAC1C,MAAM,IAAIxgE,KAAK,CAAC,+CAA+C,CAAC;QAClE;QACA,IAAI+Y,KAAK,CAACC,OAAO,CAACY,EAAE,CAACygD,SAAS,CAAC,EAAE;UAC/B,MAAM,IAAIr6D,KAAK,CAAC,6EAA6E,CAAC;QAChG;QACA,MAAM6tG,gCAAgC,GAAG3rE,IAAI,CAACy/B,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAAC00C,IAAI,CAAC;QACpEiK,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAE+L,uBAAuB,CAAC/L,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEj4C,QAAQ,CAAC4wF,gCAAgC,CAACrsC,MAAM,CAAC,EAAEqsC,gCAAgC,CAACpzC,KAAK,EAAEozC,gCAAgC,CAAC9jE,IAAI,EAAEnwB,EAAE,CAAC3Z,GAAG,EAAE2Z,EAAE,CAACuqB,UAAU,EAAEvqB,EAAE,CAACygD,SAAS,EAAEzgD,EAAE,CAAC6qB,eAAe,CAAC,CAAC;QACtP;MACF,KAAKgoB,MAAM,CAAC6J,cAAc;QACxB,IAAI18C,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,KAAK,IAAI,EAAE;UAC3B,MAAM,IAAIl1D,KAAK,CAAC,+CAA+C,CAAC;QAClE;QACA,IAAI,EAAEkiC,IAAI,YAAYs+B,mBAAmB,CAAC,EAAE;UAC1C,MAAM,IAAIxgE,KAAK,CAAC,+CAA+C,CAAC;QAClE;QACA,MAAM8tG,YAAY,GAAG5rE,IAAI,CAACy/B,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAAC00C,IAAI,CAAC;QAChD,IAAIw/C,YAAY,CAACtsC,MAAM,KAAK,IAAI,EAAE;UAChC,MAAM,IAAIxhE,KAAK,CAAC,mEAAmE,CAAC;QACtF;QACA,IAAIwrG,eAAe,GAAG,IAAI;QAC1B,IAAIC,UAAU,GAAG,IAAI;QACrB,IAAIC,SAAS,GAAG,IAAI;QACpB,IAAI9xF,EAAE,CAACkhD,SAAS,KAAK,IAAI,EAAE;UACzB,MAAMA,SAAS,GAAG54B,IAAI,CAACy/B,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAACkhD,SAAS,CAAC;UAClD,IAAIA,SAAS,KAAKzrC,SAAS,EAAE;YAC3B,MAAM,IAAIrvB,KAAK,CAAC,4EAA4E,CAAC;UAC/F;UACA,IAAI86D,SAAS,CAAC0G,MAAM,KAAK,IAAI,IAAI1G,SAAS,CAACL,KAAK,KAAK,IAAI,IAAIK,SAAS,CAAC/wB,IAAI,KAAK,IAAI,EAAE;YACpF,MAAM,IAAI/pC,KAAK,CAAC,6EAA6E,CAAC;UAChG;UACAwrG,eAAe,GAAG1wC,SAAS,CAAC0G,MAAM;UAClCiqC,UAAU,GAAG3wC,SAAS,CAACL,KAAK;UAC5BixC,SAAS,GAAG5wC,SAAS,CAAC/wB,IAAI;QAC5B;QACAwuB,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEiM,cAAc,CAACjM,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAE44C,YAAY,CAACtsC,MAAM,EAAE5nD,EAAE,CAAC6gD,KAAK,EAAE7gD,EAAE,CAACmwB,IAAI,EAAEnwB,EAAE,CAAC3Z,GAAG,EAAE2Z,EAAE,CAACuqB,UAAU,EAAE4pE,YAAY,CAAC7rE,IAAI,EAAEtoB,EAAE,CAAC,EAAEA,EAAE,CAACwhD,qBAAqB,EAAEowC,eAAe,EAAEC,UAAU,EAAEC,SAAS,EAAE9xF,EAAE,CAACohD,QAAQ,EAAEphD,EAAE,CAACshD,eAAe,EAAEthD,EAAE,CAACwgD,eAAe,CAAC,CAAC;QAChQ;MACF,KAAK3N,MAAM,CAACwL,cAAc;QACxB,MAAM+1C,gBAAgB,GAAGxwF,UAAU,CAAC5D,EAAE,CAACwlD,SAAS,CAACz7D,GAAG,CAAC,CAAC;UACpDitD,UAAU;UACV5X,MAAM;UACNzjB,IAAI;UACJW;QACF,CAAC,KAAK;UACJ,IAAI06B,UAAU,CAACsE,IAAI,KAAK,IAAI,EAAE;YAC5B,MAAM,IAAIl1D,KAAK,CAAC,0CAA0C,CAAC;UAC7D;UACA,OAAOwd,UAAU,CAAC,CAACU,OAAO,CAAC0yC,UAAU,CAACsE,IAAI,CAAC,EAAEh3C,OAAO,CAAC86B,MAAM,CAAC,EAAE96B,OAAO,CAACqX,IAAI,CAAC,EAAErX,OAAO,CAACgY,MAAM,CAAC,CAAC,CAAC;QAChG,CAAC,CAAC,CAAC;QACHqiC,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAE2yF,oBAAoB,CAAC3yF,EAAE,CAACulD,YAAY,EAAE6uC,gBAAgB,CAAC,CAAC;QAC3E;MACF,KAAKvhD,MAAM,CAAC2L,aAAa;QACvBG,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEsO,aAAa,CAACtO,EAAE,CAAClK,UAAU,CAAC,CAAC;QAChD;MACF,KAAK+8C,MAAM,CAAC7wC,SAAS;QACnB;MACF;QACE,MAAM,IAAI5b,KAAK,CAAC,wDAAwDysD,MAAM,CAAC7yC,EAAE,CAACmhC,IAAI,CAAC,EAAE,CAAC;IAC9F;EACF;AACF;AACA,SAASqyD,qBAAqBA,CAAClrE,IAAI,EAAE62B,GAAG,EAAE;EACxC,KAAK,MAAMn/C,EAAE,IAAIm/C,GAAG,EAAE;IACpBtD,wBAAwB,CAAC77C,EAAE,EAAEyzF,iBAAiB,EAAEn5C,kBAAkB,CAACpnD,IAAI,CAAC;IACxE,QAAQ8M,EAAE,CAACmhC,IAAI;MACb,KAAK0R,MAAM,CAAC6D,OAAO;QACjBiI,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAE+I,OAAO,CAAC/I,EAAE,CAACs/B,KAAK,EAAEt/B,EAAE,CAAClK,UAAU,CAAC,CAAC;QACpD;MACF,KAAK+8C,MAAM,CAAChZ,QAAQ;QAClB8kB,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEsoB,IAAI,CAACy/B,GAAG,CAAC9B,IAAI,KAAKJ,uBAAuB,CAACoE,OAAO,IAAIjqD,EAAE,CAACw1C,WAAW,KAAKtC,WAAW,CAAC/oB,eAAe,IAAInqB,EAAE,CAACw1C,WAAW,KAAKtC,WAAW,CAACgJ,SAAS,GAAGm4C,gBAAgB,CAACr0F,EAAE,CAAC,GAAGs0F,aAAa,CAACt0F,EAAE,CAAC,CAAC;QAC9M;MACF,KAAK6yC,MAAM,CAACyF,OAAO;QACjBqG,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEu0F,YAAY,CAACv0F,EAAE,CAAC,CAAC;QACpC;MACF,KAAK6yC,MAAM,CAACgD,cAAc;QACxB8I,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEyS,cAAc,CAACzS,EAAE,CAACtY,IAAI,EAAEsY,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAAC21C,SAAS,EAAE31C,EAAE,CAAClK,UAAU,CAAC,CAAC;QACvF;MACF,KAAK+8C,MAAM,CAACkD,SAAS;QACnB4I,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEwJ,SAAS,CAACxJ,EAAE,CAACtY,IAAI,EAAEsY,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAACsoB,IAAI,EAAEtoB,EAAE,CAAClK,UAAU,CAAC,CAAC;QAC7E;MACF,KAAK+8C,MAAM,CAACoD,SAAS;QACnB0I,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEkJ,SAAS,CAAClJ,EAAE,CAACtY,IAAI,EAAEsY,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAAClK,UAAU,CAAC,CAAC;QACpE;MACF,KAAK+8C,MAAM,CAACsD,QAAQ;QAClBwI,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEsJ,QAAQ,CAACtJ,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAAClK,UAAU,CAAC,CAAC;QAC1D;MACF,KAAK+8C,MAAM,CAACwD,QAAQ;QAClBsI,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEuJ,QAAQ,CAACvJ,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAAClK,UAAU,CAAC,CAAC;QAC1D;MACF,KAAK+8C,MAAM,CAACkF,cAAc;QACxB4G,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAE6O,OAAO,CAAC7O,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAAClK,UAAU,CAAC,CAAC;QACzD;MACF,KAAK+8C,MAAM,CAACqF,SAAS;QACnByG,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEgP,SAAS,CAAChP,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEt7C,EAAE,CAAClK,UAAU,CAAC,CAAC;QAC5D;MACF,KAAK+8C,MAAM,CAACmC,eAAe;QACzB2J,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEwM,eAAe,CAACxM,EAAE,CAAC+0C,aAAa,CAACxwB,OAAO,EAAEvkB,EAAE,CAAC+0C,aAAa,CAACt5C,WAAW,EAAEuE,EAAE,CAAClK,UAAU,CAAC,CAAC;QAC1G;MACF,KAAK+8C,MAAM,CAAC2D,SAAS;QACnBmI,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAErZ,SAAS,CAACqZ,EAAE,CAACtY,IAAI,EAAEsY,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAAC21C,SAAS,EAAE31C,EAAE,CAACu2C,SAAS,EAAEv2C,EAAE,CAAClK,UAAU,CAAC,CAAC;QAChG;MACF,KAAK+8C,MAAM,CAACmJ,WAAW;QACrB,IAAIh8C,EAAE,CAACtR,UAAU,YAAY41B,aAAa,EAAE;UAC1C,MAAM,IAAIl+B,KAAK,CAAC,iBAAiB,CAAC;QACpC,CAAC,MAAM;UACL,IAAI4Z,EAAE,CAACw1C,WAAW,KAAKtC,WAAW,CAAC/oB,eAAe,IAAInqB,EAAE,CAACw1C,WAAW,KAAKtC,WAAW,CAACgJ,SAAS,EAAE;YAC9FyC,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEgJ,qBAAqB,CAAChJ,EAAE,CAACtY,IAAI,EAAEsY,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAAClK,UAAU,CAAC,CAAC;UAClF,CAAC,MAAM;YACL6oD,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEq0F,gBAAgB,CAACr0F,EAAE,CAAC,CAAC;UAC1C;QACF;QACA;MACF,KAAK6yC,MAAM,CAAChjB,QAAQ;QAClB,IAAI7vB,EAAE,CAACqD,QAAQ,CAAC3b,IAAI,KAAK,IAAI,EAAE;UAC7B,MAAM,IAAItB,KAAK,CAAC,oCAAoC4Z,EAAE,CAAC00C,IAAI,EAAE,CAAC;QAChE;QACAiK,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEu0C,iBAAiB,CAAC,IAAIj1C,cAAc,CAACU,EAAE,CAACqD,QAAQ,CAAC3b,IAAI,EAAEsY,EAAE,CAAC20C,WAAW,EAAEl/B,SAAS,EAAEhU,YAAY,CAAC+E,KAAK,CAAC,CAAC,CAAC;QAC1H;MACF,KAAKqsC,MAAM,CAAC7vB,WAAW;QACrB,IAAIhjB,EAAE,CAAC62C,SAAS,KAAK,IAAI,EAAE;UACzB,MAAM,IAAIzwD,KAAK,CAAC,+BAA+B,CAAC;QAClD;QACAu4D,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEvJ,WAAW,CAACuJ,EAAE,CAAC62C,SAAS,EAAE72C,EAAE,CAAC82C,YAAY,EAAE92C,EAAE,CAAClK,UAAU,CAAC,CAAC;QAC7E;MACF,KAAK+8C,MAAM,CAACqE,QAAQ;QAClByH,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEgM,QAAQ,CAAChM,EAAE,CAACi3C,UAAU,EAAEj3C,EAAE,CAAClK,UAAU,CAAC,CAAC;QAC1D;MACF,KAAK+8C,MAAM,CAAC2E,SAAS;QACnBmH,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEuK,SAAS,CAACvK,EAAE,CAAC5M,QAAQ,EAAE4M,EAAE,CAAChG,IAAI,EAAEgG,EAAE,CAAClK,UAAU,CAAC,CAAC;QAClE;MACF,KAAK+8C,MAAM,CAACuF,QAAQ;QAClB,MAAM,IAAIhyD,KAAK,CAAC,uCAAuC4Z,EAAE,CAACw4B,YAAY,EAAE,CAAC;MAC3E,KAAKqa,MAAM,CAAC7wC,SAAS;QACnB;MACF;QACE,MAAM,IAAI5b,KAAK,CAAC,wDAAwDysD,MAAM,CAAC7yC,EAAE,CAACmhC,IAAI,CAAC,EAAE,CAAC;IAC9F;EACF;AACF;AACA,SAASkzD,gBAAgBA,CAACr0F,EAAE,EAAE;EAC5B,OAAOkO,WAAW,CAACmlF,sBAAsB,CAAC1pG,GAAG,CAACqW,EAAE,CAACtY,IAAI,CAAC,IAAIsY,EAAE,CAACtY,IAAI,EAAEsY,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAAC21C,SAAS,EAAE31C,EAAE,CAAClK,UAAU,CAAC;AAChH;AACA,SAASw+F,aAAaA,CAACt0F,EAAE,EAAE;EACzB,OAAO8pD,eAAe,CAAC9pD,EAAE,CAACtY,IAAI,CAAC,GAAGymB,YAAY,CAACnO,EAAE,CAACtY,IAAI,EAAEsY,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAAClK,UAAU,CAAC,GAAGsY,QAAQ,CAACpO,EAAE,CAACtY,IAAI,EAAEsY,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAAC21C,SAAS,EAAE31C,EAAE,CAAClK,UAAU,CAAC;AACvJ;AACA,SAASy+F,YAAYA,CAACv0F,EAAE,EAAE;EACxB,OAAOqO,OAAO,CAACrO,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAAC21C,SAAS,EAAE31C,EAAE,CAAClK,UAAU,CAAC;AAC5D;AACA,SAAS29F,iBAAiBA,CAACz5F,IAAI,EAAE;EAC/B,IAAI,CAACu+C,cAAc,CAACv+C,IAAI,CAAC,EAAE;IACzB,OAAOA,IAAI;EACb;EACA,QAAQA,IAAI,CAACmnC,IAAI;IACf,KAAK2R,cAAc,CAACyG,WAAW;MAC7B,OAAOpvC,WAAW,CAACnQ,IAAI,CAACw/C,KAAK,CAAC;IAChC,KAAK1G,cAAc,CAAC/iB,SAAS;MAC3B,OAAO1gB,SAAS,CAACrV,IAAI,CAACg9C,UAAU,CAACsE,IAAI,GAAG,CAAC,GAAGthD,IAAI,CAAColC,MAAM,CAAC;IAC1D,KAAK0T,cAAc,CAAC4F,WAAW;MAC7B,MAAM,IAAItyD,KAAK,CAAC,6CAA6C4T,IAAI,CAACtS,IAAI,EAAE,CAAC;IAC3E,KAAKorD,cAAc,CAACkH,gBAAgB;MAClC,MAAM,IAAI5zD,KAAK,CAAC,6CAA6C,CAAC;IAChE,KAAK0sD,cAAc,CAAC8G,WAAW;MAC7B,IAAI,OAAO5/C,IAAI,CAAC3I,IAAI,KAAK,QAAQ,EAAE;QACjC,MAAM,IAAIjL,KAAK,CAAC,wCAAwC,CAAC;MAC3D;MACA,OAAO8mB,WAAW,CAAClT,IAAI,CAAC3I,IAAI,CAAC;IAC/B,KAAKyhD,cAAc,CAACgH,SAAS;MAC3B,OAAO1vC,SAAS,CAACpQ,IAAI,CAACA,IAAI,CAAC;IAC7B,KAAK84C,cAAc,CAAC4G,cAAc;MAChC,OAAOntC,cAAc,CAAC,CAAC;IACzB,KAAKumC,cAAc,CAACoH,YAAY;MAC9B,IAAIlgD,IAAI,CAACtS,IAAI,KAAK,IAAI,EAAE;QACtB,MAAM,IAAItB,KAAK,CAAC,4BAA4B4T,IAAI,CAAC06C,IAAI,EAAE,CAAC;MAC1D;MACA,OAAOrxC,QAAQ,CAACrJ,IAAI,CAACtS,IAAI,CAAC;IAC5B,KAAKorD,cAAc,CAACsI,iBAAiB;MACnC,IAAIphD,IAAI,CAACtS,IAAI,KAAK,IAAI,EAAE;QACtB,MAAM,IAAItB,KAAK,CAAC,6BAA6B4T,IAAI,CAAC06C,IAAI,EAAE,CAAC;MAC3D;MACA,OAAOrxC,QAAQ,CAACrJ,IAAI,CAACtS,IAAI,CAAC;IAC5B,KAAKorD,cAAc,CAACqI,mBAAmB;MACrC,IAAInhD,IAAI,CAACtS,IAAI,KAAK,IAAI,EAAE;QACtB,MAAM,IAAItB,KAAK,CAAC,+BAA+B4T,IAAI,CAAC06C,IAAI,EAAE,CAAC;MAC7D;MACA,OAAOrxC,QAAQ,CAACrJ,IAAI,CAACtS,IAAI,CAAC,CAACkC,GAAG,CAACoQ,IAAI,CAACA,IAAI,CAAC;IAC3C,KAAK84C,cAAc,CAACqH,gBAAgB;MAClC,IAAIngD,IAAI,CAACO,EAAE,KAAK,IAAI,EAAE;QACpB,MAAM,IAAInU,KAAK,CAAC,+DAA+D,CAAC;MAClF;MACA,OAAOosG,YAAY,CAACx4F,IAAI,CAACogD,SAAS,EAAEpgD,IAAI,CAACO,EAAE,EAAEP,IAAI,CAACQ,IAAI,CAAC;IACzD,KAAKs4C,cAAc,CAAC0H,yBAAyB;MAC3C,MAAM,IAAIp0D,KAAK,CAAC,2EAA2E,CAAC;IAC9F,KAAK0sD,cAAc,CAAC4H,WAAW;MAC7B,OAAOu3C,QAAQ,CAACj4F,IAAI,CAACg9C,UAAU,CAACsE,IAAI,EAAEthD,IAAI,CAACogD,SAAS,EAAEpgD,IAAI,CAACQ,IAAI,CAAC;IAClE,KAAKs4C,cAAc,CAAC+H,mBAAmB;MACrC,OAAO5sC,SAAS,CAACjU,IAAI,CAACg9C,UAAU,CAACsE,IAAI,EAAEthD,IAAI,CAACogD,SAAS,EAAEpgD,IAAI,CAACQ,IAAI,CAAC;IACnE,KAAKs4C,cAAc,CAACuI,eAAe;MACjC,OAAO/2C,OAAO,CAACtK,IAAI,CAACshD,IAAI,CAACA,IAAI,CAAC;IAChC,KAAKxI,cAAc,CAACmG,mBAAmB;MACrC,OAAOnmC,cAAc,CAAC9Y,IAAI,CAACg9C,UAAU,CAACsE,IAAI,CAAC;IAC7C,KAAKxI,cAAc,CAACsF,QAAQ;MAC1B,OAAOvlC,QAAQ,CAAC7Y,IAAI,CAACrS,KAAK,EAAEqS,IAAI,CAAClE,UAAU,CAAC;IAC9C,KAAKg9C,cAAc,CAACuG,YAAY;MAC9B,OAAOh2C,QAAQ,CAAC,MAAM,CAAC;IACzB;MACE,MAAM,IAAIjd,KAAK,CAAC,kEAAkE0sD,cAAc,CAAC94C,IAAI,CAACmnC,IAAI,CAAC,EAAE,CAAC;EAClH;AACF;AACA,SAASwyD,oBAAoBA,CAACrrE,IAAI,EAAE5gC,IAAI,EAAE60D,UAAU,EAAEgG,mBAAmB,EAAE;EACzEixC,qBAAqB,CAAClrE,IAAI,EAAEi0B,UAAU,CAAC;EACvC,MAAMi4C,YAAY,GAAG,EAAE;EACvB,KAAK,MAAMx0F,EAAE,IAAIu8C,UAAU,EAAE;IAC3B,IAAIv8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC7wC,SAAS,EAAE;MAChC,MAAM,IAAI5b,KAAK,CAAC,6DAA6DysD,MAAM,CAAC7yC,EAAE,CAACmhC,IAAI,CAAC,EAAE,CAAC;IACjG;IACAqzD,YAAY,CAAC3uG,IAAI,CAACma,EAAE,CAACmkC,SAAS,CAAC;EACjC;EACA,MAAM/tC,MAAM,GAAG,EAAE;EACjB,IAAImsD,mBAAmB,EAAE;IACvBnsD,MAAM,CAACvQ,IAAI,CAAC,IAAI6Y,OAAO,CAAC,QAAQ,CAAC,CAAC;EACpC;EACA,OAAOnE,EAAE,CAACnE,MAAM,EAAEo+F,YAAY,EAAE/+E,SAAS,EAAEA,SAAS,EAAE/tB,IAAI,CAAC;AAC7D;AACA,SAASysG,YAAYA,CAAC7rE,IAAI,EAAEtoB,EAAE,EAAE;EAC9B,IAAIA,EAAE,CAAC68C,SAAS,KAAK,IAAI,EAAE;IACzB,OAAO78C,EAAE,CAAC68C,SAAS;EACrB;EACA,MAAMzmD,MAAM,GAAG,CAAC,IAAIsI,OAAO,CAAC,QAAQ,CAAC,EAAE,IAAIA,OAAO,CAAC,OAAO,CAAC,CAAC;EAC5D,IAAI+1F,IAAI;EACR,IAAIz0F,EAAE,CAAC28C,UAAU,KAAK,IAAI,EAAE;IAC1B83C,IAAI,GAAGz0F,EAAE,CAACwhD,qBAAqB,GAAGjnD,EAAE,CAACnE,MAAM,EAAE,CAAC,IAAIqM,eAAe,CAACzC,EAAE,CAAC48C,KAAK,CAAC,CAAC,CAAC,GAAG34C,OAAO,CAAC7N,MAAM,EAAE4J,EAAE,CAAC48C,KAAK,CAAC;EAC3G,CAAC,MAAM;IACL42C,qBAAqB,CAAClrE,IAAI,EAAEtoB,EAAE,CAAC28C,UAAU,CAAC;IAC1C,MAAM99C,UAAU,GAAG,EAAE;IACrB,KAAK,MAAMipD,OAAO,IAAI9nD,EAAE,CAAC28C,UAAU,EAAE;MACnC,IAAImL,OAAO,CAAC3mB,IAAI,KAAK0R,MAAM,CAAC7wC,SAAS,EAAE;QACrC,MAAM,IAAI5b,KAAK,CAAC,6DAA6DysD,MAAM,CAACiV,OAAO,CAAC3mB,IAAI,CAAC,EAAE,CAAC;MACtG;MACAtiC,UAAU,CAAChZ,IAAI,CAACiiE,OAAO,CAAC3jB,SAAS,CAAC;IACpC;IACAswD,IAAI,GAAGz0F,EAAE,CAACwhD,qBAAqB,IAAI3iD,UAAU,CAACjZ,MAAM,KAAK,CAAC,IAAI,EAAEiZ,UAAU,CAAC,CAAC,CAAC,YAAY4D,eAAe,CAAC,GAAGlI,EAAE,CAACnE,MAAM,EAAEyI,UAAU,CAAC,GAAGoF,OAAO,CAAC7N,MAAM,EAAEyI,UAAU,CAAC,CAAC,CAAC,CAAClX,KAAK,CAAC;EAC3K;EACAqY,EAAE,CAAC68C,SAAS,GAAGv0B,IAAI,CAACy/B,GAAG,CAAChC,IAAI,CAAC/+C,0BAA0B,CAACytF,IAAI,EAAE,WAAW,CAAC;EAC1E,OAAOz0F,EAAE,CAAC68C,SAAS;AACrB;AAEA,SAAS63C,mBAAmBA,CAAC3sC,GAAG,EAAE;EAChC,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACq/B,MAAM,EAAE;MAC5B,QAAQ3nD,EAAE,CAACmhC,IAAI;QACb,KAAK0R,MAAM,CAAC2D,SAAS;QACrB,KAAK3D,MAAM,CAAC0C,OAAO;QACnB,KAAK1C,MAAM,CAACoD,SAAS;QACrB,KAAKpD,MAAM,CAACwD,QAAQ;QACpB,KAAKxD,MAAM,CAAChZ,QAAQ;QACpB,KAAKgZ,MAAM,CAACkD,SAAS;QACrB,KAAKlD,MAAM,CAACsD,QAAQ;UAClB,IAAIn2C,EAAE,CAACtR,UAAU,YAAY+zB,SAAS,EAAE;YACtCk8B,MAAM,CAACiB,MAAM,CAAC5/C,EAAE,CAAC;UACnB;UACA;MACJ;IACF;EACF;AACF;AAEA,SAAS20F,kBAAkBA,CAAC5sC,GAAG,EAAE;EAC/B,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,QAAQ1nD,EAAE,CAACmhC,IAAI;QACb,KAAK0R,MAAM,CAAC+K,WAAW;UACrBe,MAAM,CAACiB,MAAM,CAAC5/C,EAAE,CAAC;UACjB;QACF,KAAK6yC,MAAM,CAACiL,SAAS;UACnB99C,EAAE,CAACjS,OAAO,GAAG,IAAI;UACjB;MACJ;IACF;EACF;AACF;AAEA,SAAS6mG,0BAA0BA,CAAC7sC,GAAG,EAAE;EACvC,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACq/B,MAAM,EAAE;MAC5B,IAAI3nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAChjB,QAAQ,IAAI7vB,EAAE,CAACqD,QAAQ,CAAC89B,IAAI,KAAK6R,oBAAoB,CAAC8gB,UAAU,IAAI,EAAE9zD,EAAE,CAAC20C,WAAW,YAAYkE,YAAY,CAAC,EAAE;QACpI;MACF;MACA,MAAMnxD,IAAI,GAAGsY,EAAE,CAACqD,QAAQ,CAACq+B,UAAU;MACnC,IAAI17C,OAAO,GAAGga,EAAE;MAChB,OAAOha,OAAO,IAAIA,OAAO,CAACm7C,IAAI,KAAK0R,MAAM,CAACgM,OAAO,EAAE;QACjDhD,wBAAwB,CAAC71D,OAAO,EAAEgU,IAAI,IAAIA,IAAI,YAAYy+C,eAAe,IAAIz+C,IAAI,CAACtS,IAAI,KAAKA,IAAI,GAAG4c,OAAO,CAACmR,SAAS,CAAC,GAAGzb,IAAI,EAAEsgD,kBAAkB,CAACpnD,IAAI,CAAC;QACrJlN,OAAO,GAAGA,OAAO,CAACklD,IAAI;MACxB;IACF;EACF;AACF;AAEA,SAAS2pD,6BAA6BA,CAAC9sC,GAAG,EAAE;EAC1C,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,MAAM2tC,yBAAyB,GAAG,IAAI5tD,GAAG,CAAC,CAAC;IAC3C,KAAK,MAAMlnC,EAAE,IAAIsoB,IAAI,CAACq/B,MAAM,EAAE;MAC5B,QAAQ3nD,EAAE,CAACmhC,IAAI;QACb,KAAK0R,MAAM,CAACkF,cAAc;UACxB+8C,yBAAyB,CAAC7rD,GAAG,CAACjpC,EAAE,CAAC03C,SAAS,CAAC;MAC/C;IACF;IACA,KAAK,MAAM13C,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,QAAQ1nD,EAAE,CAACmhC,IAAI;QACb,KAAK0R,MAAM,CAACsL,cAAc;UACxB,IAAI22C,yBAAyB,CAAC/pG,GAAG,CAACiV,EAAE,CAAC00C,IAAI,CAAC,EAAE;YAC1C;UACF;UACAiK,MAAM,CAACiB,MAAM,CAAC5/C,EAAE,CAAC;MACrB;IACF;EACF;AACF;AAEA,SAAS+0F,eAAeA,CAAChtC,GAAG,EAAE;EAC5B,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B6tC,qBAAqB,CAAC1sE,IAAI,EAAEA,IAAI,CAACo/B,MAAM,CAAC;IACxCstC,qBAAqB,CAAC1sE,IAAI,EAAEA,IAAI,CAACq/B,MAAM,CAAC;EAC1C;AACF;AACA,SAASqtC,qBAAqBA,CAAC3jG,IAAI,EAAE8tD,GAAG,EAAE;EACxC,MAAMsP,KAAK,GAAG,IAAInmE,GAAG,CAAC,CAAC;EACvBmmE,KAAK,CAAC7kE,GAAG,CAACyH,IAAI,CAACqjD,IAAI,EAAErxC,QAAQ,CAAC,KAAK,CAAC,CAAC;EACrC,KAAK,MAAMrD,EAAE,IAAIm/C,GAAG,EAAE;IACpB,QAAQn/C,EAAE,CAACmhC,IAAI;MACb,KAAK0R,MAAM,CAAChjB,QAAQ;QAClB,QAAQ7vB,EAAE,CAACqD,QAAQ,CAAC89B,IAAI;UACtB,KAAK6R,oBAAoB,CAACmG,OAAO;YAC/BsV,KAAK,CAAC7kE,GAAG,CAACoW,EAAE,CAACqD,QAAQ,CAAChS,IAAI,EAAE,IAAI4oD,gBAAgB,CAACj6C,EAAE,CAAC00C,IAAI,CAAC,CAAC;YAC1D;QACJ;QACA;MACF,KAAK7B,MAAM,CAACqJ,SAAS;MACrB,KAAKrJ,MAAM,CAACsJ,iBAAiB;MAC7B,KAAKtJ,MAAM,CAACuJ,QAAQ;MACpB,KAAKvJ,MAAM,CAACwJ,cAAc;QACxB24C,qBAAqB,CAAC3jG,IAAI,EAAE2O,EAAE,CAACu8C,UAAU,CAAC;QAC1C;MACF,KAAK1J,MAAM,CAAC6J,cAAc;QACxB,IAAI18C,EAAE,CAAC28C,UAAU,KAAK,IAAI,EAAE;UAC1Bq4C,qBAAqB,CAAC3jG,IAAI,EAAE2O,EAAE,CAAC28C,UAAU,CAAC;QAC5C;QACA;IACJ;EACF;EACA,IAAItrD,IAAI,KAAKA,IAAI,CAAC02D,GAAG,CAACtD,IAAI,EAAE;IAC1BgK,KAAK,CAAC7kE,GAAG,CAACyH,IAAI,CAACqjD,IAAI,EAAErxC,QAAQ,CAAC,KAAK,CAAC,CAAC;EACvC;EACA,KAAK,MAAMrD,EAAE,IAAIm/C,GAAG,EAAE;IACpBtD,wBAAwB,CAAC77C,EAAE,EAAEhG,IAAI,IAAI;MACnC,IAAIA,IAAI,YAAYk/C,WAAW,EAAE;QAC/B,IAAI,CAACuV,KAAK,CAAC1jE,GAAG,CAACiP,IAAI,CAAC3I,IAAI,CAAC,EAAE;UACzB,MAAM,IAAIjL,KAAK,CAAC,0CAA0C4T,IAAI,CAAC3I,IAAI,cAAcA,IAAI,CAACqjD,IAAI,EAAE,CAAC;QAC/F;QACA,OAAO+Z,KAAK,CAAC9kE,GAAG,CAACqQ,IAAI,CAAC3I,IAAI,CAAC;MAC7B,CAAC,MAAM;QACL,OAAO2I,IAAI;MACb;IACF,CAAC,EAAEsgD,kBAAkB,CAACpnD,IAAI,CAAC;EAC7B;AACF;AAEA,SAAS+hG,mBAAmBA,CAACltC,GAAG,EAAE;EAChC,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACiK,KAAK,EAAE;QAC5B,IAAI98C,EAAE,CAACi9C,UAAU,KAAK,IAAI,EAAE;UAC1B;QACF;QACA,IAAIj9C,EAAE,CAACsjD,aAAa,KAAK,IAAI,EAAE;UAC7B,IAAItjD,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,KAAK,IAAI,EAAE;YAC3B,MAAM,IAAIl1D,KAAK,CAAC,8EAA8E,CAAC;UACjG;UACA,MAAM8uG,YAAY,GAAG5sE,IAAI,CAACs/B,MAAM,EAAExgE,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC;UAC1D4Y,EAAE,CAACi9C,UAAU,GAAG8K,GAAG,CAAChC,IAAI,CAAC/+C,0BAA0B,CAAChH,EAAE,CAACsjD,aAAa,EAAE,GAAG4xC,YAAY,UAAUl1F,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,SAAS,EAAE,KAAK,CAAC;QAChI;MACF;IACF;EACF;AACF;AAEA,SAAS65C,kBAAkBA,CAACptC,GAAG,EAAE;EAC/B,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5BiuC,oBAAoB,CAAC9sE,IAAI,CAACo/B,MAAM,CAAC;IACjC0tC,oBAAoB,CAAC9sE,IAAI,CAACq/B,MAAM,CAAC;EACnC;AACF;AACA,SAASytC,oBAAoBA,CAACj2C,GAAG,EAAE;EACjC,KAAK,MAAMn/C,EAAE,IAAIm/C,GAAG,EAAE;IACpB,IAAIn/C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACuJ,QAAQ,IAAIp8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACwJ,cAAc,IAAIr8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACsJ,iBAAiB,EAAE;MAC5GN,wBAAwB,CAAC77C,EAAE,EAAEhG,IAAI,IAAI;QACnC,IAAIA,IAAI,YAAYy+C,eAAe,IAAIz+C,IAAI,CAACtS,IAAI,KAAK,QAAQ,EAAE;UAC7D,IAAIsY,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACuJ,QAAQ,IAAIp8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACsJ,iBAAiB,EAAE;YACvEn8C,EAAE,CAACuiD,mBAAmB,GAAG,IAAI;UAC/B;UACA,OAAO,IAAI9oD,WAAW,CAACO,IAAI,CAACtS,IAAI,CAAC;QACnC;QACA,OAAOsS,IAAI;MACb,CAAC,EAAEsgD,kBAAkB,CAACC,gBAAgB,CAAC;IACzC;EACF;AACF;AAEA,SAAS86C,8BAA8BA,CAACttC,GAAG,EAAE;EAC3C,MAAMQ,YAAY,GAAG,IAAIjgE,GAAG,CAAC,CAAC;EAC9B,MAAMkT,QAAQ,GAAG,IAAIlT,GAAG,CAAC,CAAC;EAC1B,KAAK,MAAMggC,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,QAAQ1nD,EAAE,CAACmhC,IAAI;QACb,KAAK0R,MAAM,CAAC+K,WAAW;UACrB2K,YAAY,CAAC3+D,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC;UAC7B;QACF,KAAK6yC,MAAM,CAAC4K,YAAY;UACtBjiD,QAAQ,CAAC5R,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC;UACzB;MACJ;IACF;EACF;EACAs1F,0BAA0B,CAACvtC,GAAG,EAAEA,GAAG,CAACtD,IAAI,EAAE8D,YAAY,EAAE/sD,QAAQ,CAAC;AACnE;AACA,SAAS85F,0BAA0BA,CAACvtC,GAAG,EAAEz/B,IAAI,EAAEigC,YAAY,EAAE/sD,QAAQ,EAAE+5F,0BAA0B,EAAE;EACjG,IAAIC,UAAU,GAAG,IAAI;EACrB,IAAIC,gCAAgC,GAAG,IAAIntG,GAAG,CAAC,CAAC;EAChD,KAAK,MAAM0X,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;IAC5B,QAAQ1nD,EAAE,CAACmhC,IAAI;MACb,KAAK0R,MAAM,CAACiL,SAAS;QACnB,IAAI,CAAC99C,EAAE,CAACjS,OAAO,EAAE;UACf,MAAM3H,KAAK,CAAC,yCAAyC,CAAC;QACxD;QACAovG,UAAU,GAAG;UACXpxC,SAAS,EAAEpkD,EAAE;UACby1C,WAAW,EAAE8S,YAAY,CAAC5+D,GAAG,CAACqW,EAAE,CAACjS,OAAO;QAC1C,CAAC;QACD;MACF,KAAK8kD,MAAM,CAACgL,OAAO;QACjB23C,UAAU,GAAG,IAAI;QACjB;MACF,KAAK3iD,MAAM,CAAC4K,YAAY;QACtB,IAAIz9C,EAAE,CAAC63C,eAAe,KAAKpiC,SAAS,EAAE;UACpC,IAAI+/E,UAAU,KAAK,IAAI,EAAE;YACvB,MAAMpvG,KAAK,CAAC,6DAA6D,CAAC;UAC5E;UACAsvG,kBAAkB,CAAC11F,EAAE,EAAEw1F,UAAU,CAAC//C,WAAW,EAAE+/C,UAAU,CAACpxC,SAAS,EAAEmxC,0BAA0B,CAAC;UAChG,IAAIA,0BAA0B,IAAIv1F,EAAE,CAAC63C,eAAe,CAAC7oD,SAAS,EAAE;YAC9DymG,gCAAgC,CAAC7rG,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAE6gD,0BAA0B,CAAC;UAC3E;UACAA,0BAA0B,GAAG9/E,SAAS;QACxC;QACA;MACF,KAAKo9B,MAAM,CAAC2K,UAAU;QACpB,MAAMm4C,OAAO,GAAGn6F,QAAQ,CAAC7R,GAAG,CAACqW,EAAE,CAAC00C,IAAI,CAAC;QACrC,IAAIihD,OAAO,IAAIA,OAAO,CAAC99C,eAAe,KAAKpiC,SAAS,EAAE;UACpD,IAAI+/E,UAAU,KAAK,IAAI,EAAE;YACvB,MAAMpvG,KAAK,CAAC,6EAA6E,CAAC;UAC5F;UACAwvG,kBAAkB,CAACD,OAAO,EAAEH,UAAU,CAAC//C,WAAW,EAAE+/C,UAAU,CAACpxC,SAAS,EAAEqxC,gCAAgC,CAAC9rG,GAAG,CAACqW,EAAE,CAAC00C,IAAI,CAAC,CAAC;UACxH+gD,gCAAgC,CAACI,MAAM,CAAC71F,EAAE,CAAC00C,IAAI,CAAC;QAClD;QACA;MACF,KAAK7B,MAAM,CAACoL,UAAU;QACpB,IAAIj+C,EAAE,CAAC63C,eAAe,KAAKpiC,SAAS,EAAE;UACpC,IAAI+/E,UAAU,KAAK,IAAI,EAAE;YACvB,MAAMpvG,KAAK,CAAC,6DAA6D,CAAC;UAC5E;UACAsvG,kBAAkB,CAAC11F,EAAE,EAAEw1F,UAAU,CAAC//C,WAAW,EAAE+/C,UAAU,CAACpxC,SAAS,EAAEmxC,0BAA0B,CAAC;UAChGK,kBAAkB,CAAC51F,EAAE,EAAEw1F,UAAU,CAAC//C,WAAW,EAAE+/C,UAAU,CAACpxC,SAAS,EAAEmxC,0BAA0B,CAAC;UAChGA,0BAA0B,GAAG9/E,SAAS;QACxC;QACA,IAAIzV,EAAE,CAACgjD,YAAY,KAAK,IAAI,EAAE;UAC5B,MAAM3xD,IAAI,GAAG02D,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAACgjD,YAAY,CAAC;UAC3C,IAAIhjD,EAAE,CAACivF,2BAA2B,KAAKx5E,SAAS,EAAE;YAChD6/E,0BAA0B,CAACvtC,GAAG,EAAE12D,IAAI,EAAEk3D,YAAY,EAAE/sD,QAAQ,CAAC;UAC/D,CAAC,MAAM;YACL,IAAIg6F,UAAU,KAAK,IAAI,EAAE;cACvB,MAAMpvG,KAAK,CAAC,6DAA6D,CAAC;YAC5E;YACA0vG,mBAAmB,CAAC/tC,GAAG,EAAE12D,IAAI,EAAE2O,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEt7C,EAAE,CAACivF,2BAA2B,EAAEuG,UAAU,CAAC//C,WAAW,EAAE+/C,UAAU,CAACpxC,SAAS,EAAEmxC,0BAA0B,CAAC;YACxJD,0BAA0B,CAACvtC,GAAG,EAAE12D,IAAI,EAAEk3D,YAAY,EAAE/sD,QAAQ,CAAC;YAC7Du6F,mBAAmB,CAAChuC,GAAG,EAAE12D,IAAI,EAAE2O,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEt7C,EAAE,CAACivF,2BAA2B,EAAEuG,UAAU,CAAC//C,WAAW,EAAE+/C,UAAU,CAACpxC,SAAS,EAAEmxC,0BAA0B,CAAC;YACxJA,0BAA0B,GAAG9/E,SAAS;UACxC;QACF;QACA;MACF,KAAKo9B,MAAM,CAACyL,iBAAiB;MAC7B,KAAKzL,MAAM,CAAC0L,uBAAuB;MACnC,KAAK1L,MAAM,CAACtjB,QAAQ;QAClB,MAAMl+B,IAAI,GAAG02D,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAAC00C,IAAI,CAAC;QACnC,IAAI10C,EAAE,CAAC63C,eAAe,KAAKpiC,SAAS,EAAE;UACpC6/E,0BAA0B,CAACvtC,GAAG,EAAE12D,IAAI,EAAEk3D,YAAY,EAAE/sD,QAAQ,CAAC;QAC/D,CAAC,MAAM;UACL,IAAIg6F,UAAU,KAAK,IAAI,EAAE;YACvB,MAAMpvG,KAAK,CAAC,6DAA6D,CAAC;UAC5E;UACA,IAAI4Z,EAAE,CAACq1C,YAAY,KAAK5B,YAAY,CAACk4C,UAAU,EAAE;YAC/C2J,0BAA0B,CAACvtC,GAAG,EAAE12D,IAAI,EAAEk3D,YAAY,EAAE/sD,QAAQ,EAAEwE,EAAE,CAAC;UACnE,CAAC,MAAM;YACL81F,mBAAmB,CAAC/tC,GAAG,EAAE12D,IAAI,EAAE2O,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEt7C,EAAE,CAAC63C,eAAe,EAAE29C,UAAU,CAAC//C,WAAW,EAAE+/C,UAAU,CAACpxC,SAAS,EAAEmxC,0BAA0B,CAAC;YAC5ID,0BAA0B,CAACvtC,GAAG,EAAE12D,IAAI,EAAEk3D,YAAY,EAAE/sD,QAAQ,CAAC;YAC7Du6F,mBAAmB,CAAChuC,GAAG,EAAE12D,IAAI,EAAE2O,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,EAAEt7C,EAAE,CAAC63C,eAAe,EAAE29C,UAAU,CAAC//C,WAAW,EAAE+/C,UAAU,CAACpxC,SAAS,EAAEmxC,0BAA0B,CAAC;YAC5IA,0BAA0B,GAAG9/E,SAAS;UACxC;QACF;QACA;MACF,KAAKo9B,MAAM,CAAC6J,cAAc;QACxB,IAAI64C,0BAA0B,KAAK9/E,SAAS,EAAE;UAC5C,MAAMrvB,KAAK,CAAC,4EAA4E,CAAC;QAC3F;QACA,MAAM4vG,OAAO,GAAGh2F,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,GAAG,CAAC;QAClC,MAAM0zC,OAAO,GAAGjnC,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAAC00C,IAAI,CAAC;QACtC,IAAI10C,EAAE,CAAC63C,eAAe,KAAKpiC,SAAS,EAAE;UACpC6/E,0BAA0B,CAACvtC,GAAG,EAAEinC,OAAO,EAAEzmC,YAAY,EAAE/sD,QAAQ,CAAC;QAClE,CAAC,MAAM;UACL,IAAIg6F,UAAU,KAAK,IAAI,EAAE;YACvB,MAAMpvG,KAAK,CAAC,6DAA6D,CAAC;UAC5E;UACA0vG,mBAAmB,CAAC/tC,GAAG,EAAEinC,OAAO,EAAEgH,OAAO,EAAEh2F,EAAE,CAAC63C,eAAe,EAAE29C,UAAU,CAAC//C,WAAW,EAAE+/C,UAAU,CAACpxC,SAAS,EAAEmxC,0BAA0B,CAAC;UACxID,0BAA0B,CAACvtC,GAAG,EAAEinC,OAAO,EAAEzmC,YAAY,EAAE/sD,QAAQ,CAAC;UAChEu6F,mBAAmB,CAAChuC,GAAG,EAAEinC,OAAO,EAAEgH,OAAO,EAAEh2F,EAAE,CAAC63C,eAAe,EAAE29C,UAAU,CAAC//C,WAAW,EAAE+/C,UAAU,CAACpxC,SAAS,EAAEmxC,0BAA0B,CAAC;UACxIA,0BAA0B,GAAG9/E,SAAS;QACxC;QACA,IAAIzV,EAAE,CAACkhD,SAAS,KAAK,IAAI,EAAE;UACzB,MAAM+0C,SAAS,GAAGj2F,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,GAAG,CAAC;UACpC,MAAM4F,SAAS,GAAG6G,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAACkhD,SAAS,CAAC;UAC7C,IAAIlhD,EAAE,CAACqhD,oBAAoB,KAAK5rC,SAAS,EAAE;YACzC6/E,0BAA0B,CAACvtC,GAAG,EAAE7G,SAAS,EAAEqH,YAAY,EAAE/sD,QAAQ,CAAC;UACpE,CAAC,MAAM;YACL,IAAIg6F,UAAU,KAAK,IAAI,EAAE;cACvB,MAAMpvG,KAAK,CAAC,6DAA6D,CAAC;YAC5E;YACA0vG,mBAAmB,CAAC/tC,GAAG,EAAE7G,SAAS,EAAE+0C,SAAS,EAAEj2F,EAAE,CAACqhD,oBAAoB,EAAEm0C,UAAU,CAAC//C,WAAW,EAAE+/C,UAAU,CAACpxC,SAAS,EAAEmxC,0BAA0B,CAAC;YACjJD,0BAA0B,CAACvtC,GAAG,EAAE7G,SAAS,EAAEqH,YAAY,EAAE/sD,QAAQ,CAAC;YAClEu6F,mBAAmB,CAAChuC,GAAG,EAAE7G,SAAS,EAAE+0C,SAAS,EAAEj2F,EAAE,CAACqhD,oBAAoB,EAAEm0C,UAAU,CAAC//C,WAAW,EAAE+/C,UAAU,CAACpxC,SAAS,EAAEmxC,0BAA0B,CAAC;YACjJA,0BAA0B,GAAG9/E,SAAS;UACxC;QACF;QACA;IACJ;EACF;AACF;AACA,SAASigF,kBAAkBA,CAAC11F,EAAE,EAAEy1C,WAAW,EAAE2O,SAAS,EAAE8xC,mBAAmB,EAAE;EAC3E,MAAM;IACJnnG,SAAS;IACTC;EACF,CAAC,GAAGgR,EAAE,CAAC63C,eAAe;EACtB,IAAI18C,KAAK,GAAGk4C,mBAAmB,CAAC4f,UAAU,GAAG5f,mBAAmB,CAACggB,OAAO;EACxE,IAAI1rE,KAAK,GAAGqY,EAAE,CAAC23C,MAAM,CAAC2D,IAAI;EAC1B,IAAI46C,mBAAmB,KAAKzgF,SAAS,EAAE;IACrCta,KAAK,IAAIk4C,mBAAmB,CAAC6f,WAAW;IACxCvrE,KAAK,GAAG;MACNzC,OAAO,EAAEyC,KAAK;MACdkT,QAAQ,EAAEq7F,mBAAmB,CAACv+C,MAAM,CAAC2D;IACvC,CAAC;EACH;EACA,IAAI,CAACtsD,SAAS,EAAE;IACdmM,KAAK,IAAIk4C,mBAAmB,CAACigB,QAAQ;EACvC;EACA6iC,QAAQ,CAAC1gD,WAAW,CAACr/C,MAAM,EAAErH,SAAS,EAAEpH,KAAK,EAAEy8D,SAAS,CAACO,gBAAgB,EAAExpD,KAAK,CAAC;AACnF;AACA,SAASy6F,kBAAkBA,CAAC51F,EAAE,EAAEy1C,WAAW,EAAE2O,SAAS,EAAE8xC,mBAAmB,EAAE;EAC3E,MAAM;IACJlnG;EACF,CAAC,GAAGgR,EAAE,CAAC63C,eAAe;EACtB,IAAI7oD,SAAS,EAAE;IACb,IAAImM,KAAK,GAAGk4C,mBAAmB,CAAC4f,UAAU,GAAG5f,mBAAmB,CAACigB,QAAQ;IACzE,IAAI3rE,KAAK,GAAGqY,EAAE,CAAC23C,MAAM,CAAC2D,IAAI;IAC1B,IAAI46C,mBAAmB,KAAKzgF,SAAS,EAAE;MACrCta,KAAK,IAAIk4C,mBAAmB,CAAC6f,WAAW;MACxCvrE,KAAK,GAAG;QACNzC,OAAO,EAAEyC,KAAK;QACdkT,QAAQ,EAAEq7F,mBAAmB,CAACv+C,MAAM,CAAC2D;MACvC,CAAC;IACH;IACA66C,QAAQ,CAAC1gD,WAAW,CAACr/C,MAAM,EAAEpH,SAAS,EAAErH,KAAK,EAAEy8D,SAAS,CAACO,gBAAgB,EAAExpD,KAAK,CAAC;EACnF;AACF;AACA,SAAS26F,mBAAmBA,CAAC/tC,GAAG,EAAE12D,IAAI,EAAEiqD,IAAI,EAAEzD,eAAe,EAAEpC,WAAW,EAAE2O,SAAS,EAAE8xC,mBAAmB,EAAE;EAC1G,IAAI;IACFnnG,SAAS;IACTC;EACF,CAAC,GAAG6oD,eAAe;EACnB,IAAI18C,KAAK,GAAGk4C,mBAAmB,CAAC6f,WAAW,GAAG7f,mBAAmB,CAACggB,OAAO;EACzE,IAAI,CAACrkE,SAAS,EAAE;IACdmM,KAAK,IAAIk4C,mBAAmB,CAACigB,QAAQ;EACvC;EACA,IAAI4iC,mBAAmB,KAAKzgF,SAAS,EAAE;IACrC0gF,QAAQ,CAAC1gD,WAAW,CAACr/C,MAAM,EAAErH,SAAS,EAAEmnG,mBAAmB,CAACv+C,MAAM,CAAC2D,IAAI,EAAE8I,SAAS,CAACO,gBAAgB,EAAExpD,KAAK,CAAC;EAC7G;EACAg7F,QAAQ,CAAC1gD,WAAW,CAACr/C,MAAM,EAAErH,SAAS,EAAEusD,IAAI,EAAE86C,iCAAiC,CAACruC,GAAG,EAAE3D,SAAS,EAAE/yD,IAAI,CAAC,EAAE8J,KAAK,CAAC;AAC/G;AACA,SAAS46F,mBAAmBA,CAAChuC,GAAG,EAAE12D,IAAI,EAAEiqD,IAAI,EAAEzD,eAAe,EAAEpC,WAAW,EAAE2O,SAAS,EAAE8xC,mBAAmB,EAAE;EAC1G,MAAM;IACJlnG;EACF,CAAC,GAAG6oD,eAAe;EACnB,MAAM18C,KAAK,GAAGk4C,mBAAmB,CAAC6f,WAAW,GAAG7f,mBAAmB,CAACigB,QAAQ;EAC5E,IAAItkE,SAAS,EAAE;IACbmnG,QAAQ,CAAC1gD,WAAW,CAACr/C,MAAM,EAAEpH,SAAS,EAAEssD,IAAI,EAAE86C,iCAAiC,CAACruC,GAAG,EAAE3D,SAAS,EAAE/yD,IAAI,CAAC,EAAE8J,KAAK,CAAC;IAC7G,IAAI+6F,mBAAmB,KAAKzgF,SAAS,EAAE;MACrC0gF,QAAQ,CAAC1gD,WAAW,CAACr/C,MAAM,EAAEpH,SAAS,EAAEknG,mBAAmB,CAACv+C,MAAM,CAAC2D,IAAI,EAAE8I,SAAS,CAACO,gBAAgB,EAAExpD,KAAK,CAAC;IAC7G;EACF;AACF;AACA,SAASi7F,iCAAiCA,CAACruC,GAAG,EAAE4iC,MAAM,EAAEt5F,IAAI,EAAE;EAC5D,KAAK,MAAMglG,OAAO,IAAIhlG,IAAI,CAACq2D,MAAM,EAAE;IACjC,IAAI2uC,OAAO,CAACl1D,IAAI,KAAK0R,MAAM,CAACiL,SAAS,EAAE;MACrC,OAAOu4C,OAAO,CAAC1xC,gBAAgB;IACjC;EACF;EACA,OAAOgmC,MAAM,CAAChmC,gBAAgB;AAChC;AACA,SAASwxC,QAAQA,CAAC//F,MAAM,EAAEkH,WAAW,EAAE3V,KAAK,EAAEg9D,gBAAgB,EAAExpD,KAAK,EAAE;EACrE,MAAM0I,MAAM,GAAGzN,MAAM,CAACzM,GAAG,CAAC2T,WAAW,CAAC,IAAI,EAAE;EAC5CuG,MAAM,CAAChe,IAAI,CAAC;IACV8B,KAAK;IACLg9D,gBAAgB;IAChBxpD;EACF,CAAC,CAAC;EACF/E,MAAM,CAACxM,GAAG,CAAC0T,WAAW,EAAEuG,MAAM,CAAC;AACjC;AAEA,SAASyyF,iCAAiCA,CAACvuC,GAAG,EAAE;EAC9C,MAAMwuC,kBAAkB,GAAG,IAAIjuG,GAAG,CAAC,CAAC;EACpC,MAAMigE,YAAY,GAAG,IAAIjgE,GAAG,CAAC,CAAC;EAC9B,MAAMkuG,eAAe,GAAG,IAAIluG,GAAG,CAAC,CAAC;EACjC,KAAK,MAAMggC,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,QAAQ1nD,EAAE,CAACmhC,IAAI;QACb,KAAK0R,MAAM,CAACiL,SAAS;UACnBy4C,kBAAkB,CAAC3sG,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC2kD,gBAAgB,CAAC;UACpD;QACF,KAAK9R,MAAM,CAAC+K,WAAW;UACrB2K,YAAY,CAAC3+D,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC;UAC7B;QACF,KAAK6yC,MAAM,CAAC7gB,cAAc;UACxBwkE,eAAe,CAAC5sG,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC;UAChC;MACJ;IACF;EACF;EACA,MAAMy2F,iBAAiB,GAAG,IAAInuG,GAAG,CAAC,CAAC;EACnC,MAAMouG,cAAc,GAAG12F,EAAE,IAAIA,EAAE,CAACuG,KAAK,KAAK6sC,iBAAiB,CAAC4V,QAAQ,GAAGhpD,EAAE,CAAC03C,SAAS,GAAG13C,EAAE,CAACjS,OAAO;EAChG,KAAK,MAAMu6B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACq/B,MAAM,EAAE;MAC5B,IAAI3nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACkF,cAAc,EAAE;QACrC,MAAM5mD,KAAK,GAAGslG,iBAAiB,CAAC9sG,GAAG,CAAC+sG,cAAc,CAAC12F,EAAE,CAAC,CAAC,IAAI,CAAC;QAC5D,MAAM2kD,gBAAgB,GAAG4xC,kBAAkB,CAAC5sG,GAAG,CAACqW,EAAE,CAAC03C,SAAS,CAAC,IAAI,IAAI;QACrE,MAAM/vD,KAAK,GAAG;UACZA,KAAK,EAAEwJ,KAAK;UACZwzD,gBAAgB,EAAEA,gBAAgB;UAClCxpD,KAAK,EAAEk4C,mBAAmB,CAACsjD;QAC7B,CAAC;QACDC,iBAAiB,CAAC52F,EAAE,EAAErY,KAAK,EAAE4gE,YAAY,EAAEiuC,eAAe,CAAC;QAC3DC,iBAAiB,CAAC7sG,GAAG,CAAC8sG,cAAc,CAAC12F,EAAE,CAAC,EAAE7O,KAAK,GAAG,CAAC,CAAC;MACtD;IACF;EACF;AACF;AACA,SAASylG,iBAAiBA,CAAC52F,EAAE,EAAErY,KAAK,EAAE4gE,YAAY,EAAEiuC,eAAe,EAAE;EACnE,IAAIx2F,EAAE,CAAC63C,eAAe,KAAK,IAAI,EAAE;IAC/B,MAAMpC,WAAW,GAAG8S,YAAY,CAAC5+D,GAAG,CAACqW,EAAE,CAACjS,OAAO,CAAC;IAChD,MAAMqI,MAAM,GAAG4J,EAAE,CAAC83C,cAAc,KAAK3E,uBAAuB,CAACsa,QAAQ,GAAGhY,WAAW,CAACr/C,MAAM,GAAGq/C,WAAW,CAAC0H,oBAAoB;IAC7H,MAAMt5C,MAAM,GAAGzN,MAAM,CAACzM,GAAG,CAACqW,EAAE,CAAC63C,eAAe,CAAC,IAAI,EAAE;IACnDh0C,MAAM,CAAChe,IAAI,CAAC8B,KAAK,CAAC;IAClByO,MAAM,CAACxM,GAAG,CAACoW,EAAE,CAAC63C,eAAe,EAAEh0C,MAAM,CAAC;EACxC;EACA,IAAI7D,EAAE,CAAC43C,cAAc,KAAK,IAAI,EAAE;IAC9B,MAAM8yC,gBAAgB,GAAG8L,eAAe,CAAC7sG,GAAG,CAACqW,EAAE,CAAC43C,cAAc,CAAC;IAC/D8yC,gBAAgB,EAAE1lC,sBAAsB,CAACn/D,IAAI,CAAC8B,KAAK,CAAC;EACtD;AACF;AAEA,SAASkvG,YAAYA,CAAC9uC,GAAG,EAAE;EACzB,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B2vC,mBAAmB,CAACxuE,IAAI,EAAEA,IAAI,CAACo/B,MAAM,EAAE,IAAI,CAAC;IAC5CovC,mBAAmB,CAACxuE,IAAI,EAAEA,IAAI,CAACq/B,MAAM,EAAE,IAAI,CAAC;EAC9C;AACF;AACA,SAASmvC,mBAAmBA,CAACxuE,IAAI,EAAE62B,GAAG,EAAE2xC,SAAS,EAAE;EACjD,MAAMriC,KAAK,GAAG,IAAInmE,GAAG,CAAC,CAAC;EACvB,MAAMyuG,gBAAgB,GAAG,IAAIzuG,GAAG,CAAC,CAAC;EAClC,KAAK,MAAM0X,EAAE,IAAIm/C,GAAG,EAAE;IACpB,QAAQn/C,EAAE,CAACmhC,IAAI;MACb,KAAK0R,MAAM,CAAChjB,QAAQ;QAClB,QAAQ7vB,EAAE,CAACqD,QAAQ,CAAC89B,IAAI;UACtB,KAAK6R,oBAAoB,CAAC8gB,UAAU;YAClC,IAAI9zD,EAAE,CAACqD,QAAQ,CAAC0wD,KAAK,EAAE;cACrB,IAAIgjC,gBAAgB,CAAChsG,GAAG,CAACiV,EAAE,CAACqD,QAAQ,CAACq+B,UAAU,CAAC,EAAE;gBAChD;cACF;cACAq1D,gBAAgB,CAACntG,GAAG,CAACoW,EAAE,CAACqD,QAAQ,CAACq+B,UAAU,EAAE1hC,EAAE,CAAC00C,IAAI,CAAC;YACvD,CAAC,MAAM,IAAI+Z,KAAK,CAAC1jE,GAAG,CAACiV,EAAE,CAACqD,QAAQ,CAACq+B,UAAU,CAAC,EAAE;cAC5C;YACF;YACA+sB,KAAK,CAAC7kE,GAAG,CAACoW,EAAE,CAACqD,QAAQ,CAACq+B,UAAU,EAAE1hC,EAAE,CAAC00C,IAAI,CAAC;YAC1C;UACF,KAAK1B,oBAAoB,CAACgkD,KAAK;YAC7B,IAAIvoC,KAAK,CAAC1jE,GAAG,CAACiV,EAAE,CAACqD,QAAQ,CAACq+B,UAAU,CAAC,EAAE;cACrC;YACF;YACA+sB,KAAK,CAAC7kE,GAAG,CAACoW,EAAE,CAACqD,QAAQ,CAACq+B,UAAU,EAAE1hC,EAAE,CAAC00C,IAAI,CAAC;YAC1C;UACF,KAAK1B,oBAAoB,CAACikD,SAAS;YACjCnG,SAAS,GAAG;cACVz/F,IAAI,EAAE2O,EAAE,CAACqD,QAAQ,CAAChS,IAAI;cACtBgS,QAAQ,EAAErD,EAAE,CAAC00C;YACf,CAAC;YACD;QACJ;QACA;MACF,KAAK7B,MAAM,CAACqJ,SAAS;MACrB,KAAKrJ,MAAM,CAACsJ,iBAAiB;MAC7B,KAAKtJ,MAAM,CAACuJ,QAAQ;MACpB,KAAKvJ,MAAM,CAACwJ,cAAc;QACxBy6C,mBAAmB,CAACxuE,IAAI,EAAEtoB,EAAE,CAACu8C,UAAU,EAAEu0C,SAAS,CAAC;QACnD;MACF,KAAKj+C,MAAM,CAAC6J,cAAc;QACxB,IAAI18C,EAAE,CAAC28C,UAAU,KAAK,IAAI,EAAE;UAC1Bm6C,mBAAmB,CAACxuE,IAAI,EAAEtoB,EAAE,CAAC28C,UAAU,EAAEm0C,SAAS,CAAC;QACrD;QACA;IACJ;EACF;EACA,KAAK,MAAM9wF,EAAE,IAAIm/C,GAAG,EAAE;IACpB,IAAIn/C,EAAE,CAACmhC,IAAI,IAAI0R,MAAM,CAACuJ,QAAQ,IAAIp8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACwJ,cAAc,IAAIr8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACqJ,SAAS,IAAIl8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACsJ,iBAAiB,EAAE;MAC3I;IACF;IACAN,wBAAwB,CAAC77C,EAAE,EAAEhG,IAAI,IAAI;MACnC,IAAIA,IAAI,YAAYy+C,eAAe,EAAE;QACnC,IAAIs+C,gBAAgB,CAAChsG,GAAG,CAACiP,IAAI,CAACtS,IAAI,CAAC,EAAE;UACnC,OAAO,IAAIuyD,gBAAgB,CAAC88C,gBAAgB,CAACptG,GAAG,CAACqQ,IAAI,CAACtS,IAAI,CAAC,CAAC;QAC9D,CAAC,MAAM,IAAI+mE,KAAK,CAAC1jE,GAAG,CAACiP,IAAI,CAACtS,IAAI,CAAC,EAAE;UAC/B,OAAO,IAAIuyD,gBAAgB,CAACwU,KAAK,CAAC9kE,GAAG,CAACqQ,IAAI,CAACtS,IAAI,CAAC,CAAC;QACnD,CAAC,MAAM;UACL,OAAO,IAAIsO,YAAY,CAAC,IAAIkjD,WAAW,CAAC5wB,IAAI,CAACy/B,GAAG,CAACtD,IAAI,CAAC/P,IAAI,CAAC,EAAE16C,IAAI,CAACtS,IAAI,CAAC;QACzE;MACF,CAAC,MAAM,IAAIsS,IAAI,YAAY2/C,eAAe,IAAI,OAAO3/C,IAAI,CAAC3I,IAAI,KAAK,QAAQ,EAAE;QAC3E,IAAIy/F,SAAS,KAAK,IAAI,IAAIA,SAAS,CAACz/F,IAAI,KAAK2I,IAAI,CAAC3I,IAAI,EAAE;UACtD,MAAM,IAAIjL,KAAK,CAAC,iCAAiC4T,IAAI,CAAC3I,IAAI,cAAci3B,IAAI,CAACosB,IAAI,EAAE,CAAC;QACtF;QACA16C,IAAI,CAAC3I,IAAI,GAAG,IAAI4oD,gBAAgB,CAAC62C,SAAS,CAACztF,QAAQ,CAAC;QACpD,OAAOrJ,IAAI;MACb,CAAC,MAAM;QACL,OAAOA,IAAI;MACb;IACF,CAAC,EAAEsgD,kBAAkB,CAACpnD,IAAI,CAAC;EAC7B;EACA,KAAK,MAAM8M,EAAE,IAAIm/C,GAAG,EAAE;IACpBvD,oBAAoB,CAAC57C,EAAE,EAAEhG,IAAI,IAAI;MAC/B,IAAIA,IAAI,YAAYy+C,eAAe,EAAE;QACnC,MAAM,IAAIryD,KAAK,CAAC,qEAAqE4T,IAAI,CAACtS,IAAI,EAAE,CAAC;MACnG;IACF,CAAC,CAAC;EACJ;AACF;AAEA,MAAMwvG,YAAY,GAAG,IAAI5uG,GAAG,CAAC,CAAC,CAACmD,eAAe,CAAC81D,IAAI,EAAEz5C,WAAW,CAACyL,YAAY,CAAC,EAAE,CAAC9nB,eAAe,CAACwwF,YAAY,EAAEn0E,WAAW,CAAC2L,mBAAmB,CAAC,EAAE,CAAChoB,eAAe,CAAC0rG,MAAM,EAAErvF,WAAW,CAAC4L,cAAc,CAAC,EAAE,CAACjoB,eAAe,CAAC+9D,KAAK,EAAE1hD,WAAW,CAAC0L,aAAa,CAAC,EAAE,CAAC/nB,eAAe,CAACuwF,GAAG,EAAEl0E,WAAW,CAAC6L,WAAW,CAAC,CAAC,CAAC;AAC3S,MAAMyjF,eAAe,GAAG,IAAI9uG,GAAG,CAAC,CAAC,CAACmD,eAAe,CAAC81D,IAAI,EAAEz5C,WAAW,CAAC+L,iBAAiB,CAAC,EAAE,CAACpoB,eAAe,CAACwwF,YAAY,EAAEn0E,WAAW,CAACgM,wBAAwB,CAAC,CAAC,CAAC;AAC9J,SAASujF,iBAAiBA,CAACtvC,GAAG,EAAE;EAC9B,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,MAAM3rD,QAAQ,GAAG2tD,eAAe,CAAC7gC,IAAI,CAAC;IACtC,IAAIy/B,GAAG,CAAC5mB,IAAI,KAAKykB,kBAAkB,CAACuC,IAAI,EAAE;MACxC,KAAK,MAAMnoD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;QAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC2J,kBAAkB,EAAE;UACzC,MAAMC,cAAc,GAAG26C,eAAe,CAACztG,GAAG,CAAC2tG,sBAAsB,CAACt3F,EAAE,CAACqoB,eAAe,CAAC,CAAC,IAAI,IAAI;UAC9FroB,EAAE,CAACy8C,cAAc,GAAGA,cAAc,KAAK,IAAI,GAAGn5C,UAAU,CAACm5C,cAAc,CAAC,GAAG,IAAI;QACjF;MACF;IACF;IACA,KAAK,MAAMz8C,EAAE,IAAIsoB,IAAI,CAACq/B,MAAM,EAAE;MAC5B,QAAQ3nD,EAAE,CAACmhC,IAAI;QACb,KAAK0R,MAAM,CAAChZ,QAAQ;QACpB,KAAKgZ,MAAM,CAAC2D,SAAS;QACrB,KAAK3D,MAAM,CAACmJ,WAAW;UACrB,IAAIu7C,WAAW,GAAG,IAAI;UACtB,IAAIp4F,KAAK,CAACC,OAAO,CAACY,EAAE,CAACqoB,eAAe,CAAC,IAAIroB,EAAE,CAACqoB,eAAe,CAACziC,MAAM,KAAK,CAAC,IAAIoa,EAAE,CAACqoB,eAAe,CAAChT,OAAO,CAAC5pB,eAAe,CAACuwF,GAAG,CAAC,GAAG,CAAC,CAAC,IAAIh8E,EAAE,CAACqoB,eAAe,CAAChT,OAAO,CAAC5pB,eAAe,CAACwwF,YAAY,CAAC,GAAG,CAAC,CAAC,EAAE;YACjMsb,WAAW,GAAGzvF,WAAW,CAAC8L,wBAAwB;UACpD,CAAC,MAAM;YACL2jF,WAAW,GAAGL,YAAY,CAACvtG,GAAG,CAAC2tG,sBAAsB,CAACt3F,EAAE,CAACqoB,eAAe,CAAC,CAAC,IAAI,IAAI;UACpF;UACAroB,EAAE,CAAC21C,SAAS,GAAG4hD,WAAW,KAAK,IAAI,GAAGj0F,UAAU,CAACi0F,WAAW,CAAC,GAAG,IAAI;UACpE,IAAIv3F,EAAE,CAAC21C,SAAS,KAAK,IAAI,EAAE;YACzB,IAAI6hD,QAAQ,GAAG,KAAK;YACpB,IAAIzvC,GAAG,CAAC5mB,IAAI,KAAKykB,kBAAkB,CAACuC,IAAI,IAAInoD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACmJ,WAAW,EAAE;cAC1Ew7C,QAAQ,GAAG,IAAI;YACjB,CAAC,MAAM;cACL,MAAM5tC,OAAO,GAAGpuD,QAAQ,CAAC7R,GAAG,CAACqW,EAAE,CAAC0f,MAAM,CAAC;cACvC,IAAIkqC,OAAO,KAAKn0C,SAAS,IAAI,CAAC6qC,sBAAsB,CAACsJ,OAAO,CAAC,EAAE;gBAC7D,MAAMxjE,KAAK,CAAC,4CAA4C,CAAC;cAC3D;cACAoxG,QAAQ,GAAGC,eAAe,CAAC7tC,OAAO,CAAC;YACrC;YACA,IAAI4tC,QAAQ,IAAInb,6BAA6B,CAACr8E,EAAE,CAACtY,IAAI,CAAC,EAAE;cACtDsY,EAAE,CAAC21C,SAAS,GAAGryC,UAAU,CAACwE,WAAW,CAACiM,uBAAuB,CAAC;YAChE;UACF;UACA;MACJ;IACF;EACF;AACF;AACA,SAAS0jF,eAAeA,CAACz3F,EAAE,EAAE;EAC3B,OAAOA,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC4K,YAAY,IAAIz9C,EAAE,CAAC3Z,GAAG,EAAEuB,WAAW,CAAC,CAAC,KAAK,QAAQ;AAC9E;AACA,SAAS0vG,sBAAsBA,CAACjvE,eAAe,EAAE;EAC/C,IAAIlpB,KAAK,CAACC,OAAO,CAACipB,eAAe,CAAC,EAAE;IAClC,IAAIA,eAAe,CAACziC,MAAM,GAAG,CAAC,EAAE;MAC9B,MAAMQ,KAAK,CAAC,4CAA4C,CAAC;IAC3D;IACA,OAAOiiC,eAAe,CAAC,CAAC,CAAC,IAAI58B,eAAe,CAACi+D,IAAI;EACnD;EACA,OAAOrhC,eAAe;AACxB;AAEA,SAASqvE,kBAAkBA,CAAC3vC,GAAG,EAAE;EAC/B,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B7+B,IAAI,CAACo/B,MAAM,CAACxI,OAAO,CAAC,CAACzK,gBAAgB,CAACnsB,IAAI,CAACy/B,GAAG,CAAC5B,cAAc,CAAC,CAAC,EAAE;MAC/DhlB,IAAI,EAAE6R,oBAAoB,CAACikD,SAAS;MACpCvvG,IAAI,EAAE,IAAI;MACV2J,IAAI,EAAEi3B,IAAI,CAACosB;IACb,CAAC,EAAE,IAAI+E,kBAAkB,CAAC,CAAC,EAAE1G,aAAa,CAAC7/C,IAAI,CAAC,CAAC,CAAC;IAClD,KAAK,MAAM8M,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACuJ,QAAQ,IAAIp8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACwJ,cAAc,IAAIr8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACqJ,SAAS,IAAIl8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACsJ,iBAAiB,EAAE;QAC5I;MACF;MACA,IAAIw7C,gBAAgB,GAAGrvE,IAAI,KAAKy/B,GAAG,CAACtD,IAAI;MACxC,IAAI,CAACkzC,gBAAgB,EAAE;QACrB,KAAK,MAAMC,SAAS,IAAI53F,EAAE,CAACu8C,UAAU,EAAE;UACrCX,oBAAoB,CAACg8C,SAAS,EAAE59F,IAAI,IAAI;YACtC,IAAIA,IAAI,YAAY4+C,aAAa,IAAI5+C,IAAI,YAAYg/C,uBAAuB,EAAE;cAC5E2+C,gBAAgB,GAAG,IAAI;YACzB;UACF,CAAC,CAAC;QACJ;MACF;MACA,IAAIA,gBAAgB,EAAE;QACpBE,qCAAqC,CAACvvE,IAAI,EAAEtoB,EAAE,CAAC;MACjD;IACF;EACF;AACF;AACA,SAAS63F,qCAAqCA,CAACvvE,IAAI,EAAEtoB,EAAE,EAAE;EACvDA,EAAE,CAACu8C,UAAU,CAAC2C,OAAO,CAAC,CAACzK,gBAAgB,CAACnsB,IAAI,CAACy/B,GAAG,CAAC5B,cAAc,CAAC,CAAC,EAAE;IACjEhlB,IAAI,EAAE6R,oBAAoB,CAACmG,OAAO;IAClCzxD,IAAI,EAAE,IAAI;IACV2J,IAAI,EAAEi3B,IAAI,CAACosB;EACb,CAAC,EAAE,IAAIiF,eAAe,CAACrxB,IAAI,CAACosB,IAAI,CAAC,EAAE3B,aAAa,CAAC7/C,IAAI,CAAC,CAAC,CAAC;EACxD,KAAK,MAAM0kG,SAAS,IAAI53F,EAAE,CAACu8C,UAAU,EAAE;IACrC,IAAIq7C,SAAS,CAACz2D,IAAI,KAAK0R,MAAM,CAAC7wC,SAAS,IAAI41F,SAAS,CAACzzD,SAAS,YAAY1hC,eAAe,EAAE;MACzFm1F,SAAS,CAACzzD,SAAS,CAACx8C,KAAK,GAAG,IAAIkyD,aAAa,CAAC+9C,SAAS,CAACzzD,SAAS,CAACx8C,KAAK,CAAC;IAC1E;EACF;AACF;AAEA,SAASmwG,aAAaA,CAAC/vC,GAAG,EAAE;EAC1B,MAAM2L,OAAO,GAAG,IAAIprE,GAAG,CAAC,CAAC;EACzB,KAAK,MAAMggC,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,IAAI4wC,SAAS,GAAG,CAAC;IACjB,KAAK,MAAM/3F,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI,CAACvT,oBAAoB,CAACn0C,EAAE,CAAC,EAAE;QAC7B;MACF;MACAA,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,GAAGy8C,SAAS;MAC1BrkC,OAAO,CAAC9pE,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC23C,MAAM,CAAC2D,IAAI,CAAC;MACpCy8C,SAAS,IAAI/3F,EAAE,CAACg0C,YAAY;IAC9B;IACA1rB,IAAI,CAACu4B,KAAK,GAAGk3C,SAAS;EACxB;EACA,KAAK,MAAMzvE,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAAC62B,GAAG,CAAC,CAAC,EAAE;MAC3B,IAAIn/C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACtjB,QAAQ,IAAIvvB,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACyL,iBAAiB,IAAIt+C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC0L,uBAAuB,IAAIv+C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC6J,cAAc,EAAE;QAC1J,MAAMyvC,SAAS,GAAGpkC,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAAC00C,IAAI,CAAC;QACxC10C,EAAE,CAAC6gD,KAAK,GAAGsrC,SAAS,CAACtrC,KAAK;MAC5B;IACF;EACF;AACF;AAEA,SAASm3C,gBAAgBA,CAACjwC,GAAG,EAAE;EAC7B,MAAMkwC,iBAAiB,GAAG,IAAI/wD,GAAG,CAAC,CAAC;EACnC,MAAMgxD,aAAa,GAAG,IAAI5vG,GAAG,CAAC,CAAC;EAC/B,KAAK,MAAMggC,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAAC62B,GAAG,CAAC,CAAC,EAAE;MAC3B,IAAIn/C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACuL,UAAU,EAAE;QACjC85C,aAAa,CAACtuG,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC;MAChC;MACA47C,oBAAoB,CAAC57C,EAAE,EAAEhG,IAAI,IAAI;QAC/B,IAAIA,IAAI,YAAYg/C,uBAAuB,EAAE;UAC3Ci/C,iBAAiB,CAAChvD,GAAG,CAACjvC,IAAI,CAAC0lB,MAAM,CAAC;QACpC;MACF,CAAC,CAAC;IACJ;EACF;EACA,KAAK,MAAM4I,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACq/B,MAAM,EAAE;MAC5B9L,wBAAwB,CAAC77C,EAAE,EAAEhG,IAAI,IAAI;QACnC,IAAIA,IAAI,YAAY6+C,YAAY,IAAI,CAACo/C,iBAAiB,CAACltG,GAAG,CAACiP,IAAI,CAAC0lB,MAAM,CAAC,EAAE;UACvE,IAAI,CAACy4E,OAAO,CAACn+F,IAAI,CAAC,EAAE;YAClB2kD,MAAM,CAACiB,MAAM,CAACs4C,aAAa,CAACvuG,GAAG,CAACqQ,IAAI,CAAC0lB,MAAM,CAAC,CAAC;UAC/C;UACA,OAAO1lB,IAAI,CAACrS,KAAK;QACnB;QACA,OAAOqS,IAAI;MACb,CAAC,EAAEsgD,kBAAkB,CAACpnD,IAAI,CAAC;IAC7B;EACF;AACF;AACA,SAASilG,OAAOA,CAAC1zC,IAAI,EAAE;EACrB,IAAI39D,MAAM,GAAG,KAAK;EAClBiyD,gCAAgC,CAAC0L,IAAI,EAAEzqD,IAAI,IAAI;IAC7C,IAAIA,IAAI,YAAYygD,eAAe,IAAIzgD,IAAI,YAAY2gD,uBAAuB,EAAE;MAC9E7zD,MAAM,GAAG,IAAI;IACf;IACA,OAAOkT,IAAI;EACb,CAAC,EAAEsgD,kBAAkB,CAACpnD,IAAI,CAAC;EAC3B,OAAOpM,MAAM;AACf;AAEA,SAASsxG,2BAA2BA,CAACrwC,GAAG,EAAE;EACxC,MAAMswC,cAAc,GAAG,IAAInxD,GAAG,CAAC,CAAC;EAChC,KAAK,MAAM5e,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAAC62B,GAAG,CAAC,CAAC,EAAE;MAC3BvD,oBAAoB,CAAC57C,EAAE,EAAEhG,IAAI,IAAI;QAC/B,IAAIA,IAAI,YAAYjD,kBAAkB,EAAE;UACtC,QAAQiD,IAAI,CAACwF,QAAQ;YACnB,KAAKrK,cAAc,CAAC+C,cAAc;cAChCogG,yBAAyB,CAACt+F,IAAI,EAAEq+F,cAAc,CAAC;cAC/C;YACF,KAAKljG,cAAc,CAACmE,eAAe;cACjCi/F,4BAA4B,CAACv+F,IAAI,EAAEq+F,cAAc,CAAC;cAClD;YACF,KAAKljG,cAAc,CAACiD,GAAG;YACvB,KAAKjD,cAAc,CAACuD,EAAE;cACpB8/F,gBAAgB,CAACx+F,IAAI,EAAEq+F,cAAc,CAAC;UAC1C;QACF;MACF,CAAC,CAAC;IACJ;EACF;EACA,KAAK,MAAM/vE,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAAC62B,GAAG,CAAC,CAAC,EAAE;MAC3BtD,wBAAwB,CAAC77C,EAAE,EAAEhG,IAAI,IAAI;QACnC,IAAIA,IAAI,YAAY2F,iBAAiB,EAAE;UACrC,OAAO04F,cAAc,CAACttG,GAAG,CAACiP,IAAI,CAAC,GAAGA,IAAI,GAAGA,IAAI,CAACA,IAAI;QACpD;QACA,OAAOA,IAAI;MACb,CAAC,EAAEsgD,kBAAkB,CAACpnD,IAAI,CAAC;IAC7B;EACF;AACF;AACA,SAASolG,yBAAyBA,CAACt+F,IAAI,EAAEq+F,cAAc,EAAE;EACvD,IAAIr+F,IAAI,CAAC6F,GAAG,YAAYF,iBAAiB,IAAI3F,IAAI,CAAC6F,GAAG,CAAC7F,IAAI,YAAYuF,iBAAiB,EAAE;IACvF84F,cAAc,CAACpvD,GAAG,CAACjvC,IAAI,CAAC6F,GAAG,CAAC;EAC9B;AACF;AACA,SAAS04F,4BAA4BA,CAACv+F,IAAI,EAAEq+F,cAAc,EAAE;EAC1D,IAAIr+F,IAAI,CAAC6F,GAAG,YAAYF,iBAAiB,KAAK84F,cAAc,CAACz+F,IAAI,CAAC6F,GAAG,CAAC7F,IAAI,CAAC,IAAIA,IAAI,CAAC6F,GAAG,CAAC7F,IAAI,YAAYpD,eAAe,CAAC,EAAE;IACxHyhG,cAAc,CAACpvD,GAAG,CAACjvC,IAAI,CAAC6F,GAAG,CAAC;EAC9B;EACA,IAAI7F,IAAI,CAAClD,GAAG,YAAY6I,iBAAiB,KAAK84F,cAAc,CAACz+F,IAAI,CAAClD,GAAG,CAACkD,IAAI,CAAC,IAAIA,IAAI,CAAClD,GAAG,CAACkD,IAAI,YAAYpD,eAAe,CAAC,EAAE;IACxHyhG,cAAc,CAACpvD,GAAG,CAACjvC,IAAI,CAAClD,GAAG,CAAC;EAC9B;AACF;AACA,SAAS0hG,gBAAgBA,CAACx+F,IAAI,EAAEq+F,cAAc,EAAE;EAC9C,IAAIr+F,IAAI,CAAC6F,GAAG,YAAYF,iBAAiB,IAAI3F,IAAI,CAAC6F,GAAG,CAAC7F,IAAI,YAAYjD,kBAAkB,IAAIiD,IAAI,CAAC6F,GAAG,CAAC7F,IAAI,CAACwF,QAAQ,KAAKrK,cAAc,CAACmE,eAAe,EAAE;IACrJ++F,cAAc,CAACpvD,GAAG,CAACjvC,IAAI,CAAC6F,GAAG,CAAC;EAC9B;AACF;AACA,SAAS44F,cAAcA,CAACz+F,IAAI,EAAE;EAC5B,OAAOA,IAAI,YAAYjD,kBAAkB,KAAKiD,IAAI,CAACwF,QAAQ,KAAKrK,cAAc,CAACiD,GAAG,IAAI4B,IAAI,CAACwF,QAAQ,KAAKrK,cAAc,CAACuD,EAAE,CAAC;AAC5H;AAEA,SAASggG,uBAAuBA,CAAC3wC,GAAG,EAAE;EACpC,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACq/B,MAAM,EAAE;MAC5B,IAAI3nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC0C,OAAO,EAAE;QAC9B;MACF;MACA,QAAQv1C,EAAE,CAACw1C,WAAW;QACpB,KAAKtC,WAAW,CAACgX,SAAS;UACxB,IAAIlqD,EAAE,CAACtR,UAAU,YAAY41B,aAAa,EAAE;YAC1C,MAAM,IAAIl+B,KAAK,CAAC,+CAA+C,CAAC;UAClE;UACAu4D,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEg2C,iBAAiB,CAACh2C,EAAE,CAAC0f,MAAM,EAAE1f,EAAE,CAACtY,IAAI,EAAEsY,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAAClK,UAAU,CAAC,CAAC;UACvF;QACF,KAAKo9C,WAAW,CAACiX,aAAa;UAC5BxL,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAE81C,iBAAiB,CAAC91C,EAAE,CAAC0f,MAAM,EAAE1f,EAAE,CAACtY,IAAI,EAAEsY,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAACsoB,IAAI,EAAEtoB,EAAE,CAAClK,UAAU,CAAC,CAAC;UAChG;QACF,KAAKo9C,WAAW,CAACrZ,QAAQ;QACzB,KAAKqZ,WAAW,CAAC3jB,QAAQ;UACvB,IAAIvvB,EAAE,CAACtY,IAAI,KAAK,OAAO,EAAE;YACvBi3D,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEk2C,gBAAgB,CAACl2C,EAAE,CAAC0f,MAAM,EAAE1f,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAAClK,UAAU,CAAC,CAAC;UAC/E,CAAC,MAAM,IAAIkK,EAAE,CAACtY,IAAI,KAAK,OAAO,EAAE;YAC9Bi3D,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEo2C,gBAAgB,CAACp2C,EAAE,CAAC0f,MAAM,EAAE1f,EAAE,CAACtR,UAAU,EAAEsR,EAAE,CAAClK,UAAU,CAAC,CAAC;UAC/E;UACA;MACJ;IACF;EACF;AACF;AAEA,SAAS6iG,0BAA0BA,CAAC5wC,GAAG,EAAE;EACvC,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B7+B,IAAI,CAACo/B,MAAM,CAACxI,OAAO,CAAC05C,mBAAmB,CAACtwE,IAAI,CAACo/B,MAAM,CAAC,CAAC;IACrDp/B,IAAI,CAACq/B,MAAM,CAACzI,OAAO,CAAC05C,mBAAmB,CAACtwE,IAAI,CAACq/B,MAAM,CAAC,CAAC;EACvD;AACF;AACA,SAASixC,mBAAmBA,CAACz5C,GAAG,EAAE;EAChC,IAAI05C,OAAO,GAAG,CAAC;EACf,IAAIC,mBAAmB,GAAG,EAAE;EAC5B,KAAK,MAAM94F,EAAE,IAAIm/C,GAAG,EAAE;IACpB,MAAM45C,UAAU,GAAG,IAAIzwG,GAAG,CAAC,CAAC;IAC5BszD,oBAAoB,CAAC57C,EAAE,EAAE,CAAChG,IAAI,EAAEg/F,IAAI,KAAK;MACvC,IAAIA,IAAI,GAAG1+C,kBAAkB,CAACC,gBAAgB,EAAE;QAC9C;MACF;MACA,IAAIvgD,IAAI,YAAYohD,iBAAiB,EAAE;QACrC29C,UAAU,CAACnvG,GAAG,CAACoQ,IAAI,CAAC06C,IAAI,EAAE16C,IAAI,CAAC;MACjC;IACF,CAAC,CAAC;IACF,IAAIvH,KAAK,GAAG,CAAC;IACb,MAAMwmG,QAAQ,GAAG,IAAI/xD,GAAG,CAAC,CAAC;IAC1B,MAAMgyD,QAAQ,GAAG,IAAIhyD,GAAG,CAAC,CAAC;IAC1B,MAAMiyD,IAAI,GAAG,IAAI7wG,GAAG,CAAC,CAAC;IACtBszD,oBAAoB,CAAC57C,EAAE,EAAE,CAAChG,IAAI,EAAEg/F,IAAI,KAAK;MACvC,IAAIA,IAAI,GAAG1+C,kBAAkB,CAACC,gBAAgB,EAAE;QAC9C;MACF;MACA,IAAIvgD,IAAI,YAAYmhD,mBAAmB,EAAE;QACvC,IAAI,CAAC89C,QAAQ,CAACluG,GAAG,CAACiP,IAAI,CAAC06C,IAAI,CAAC,EAAE;UAC5BukD,QAAQ,CAAChwD,GAAG,CAACjvC,IAAI,CAAC06C,IAAI,CAAC;UACvBykD,IAAI,CAACvvG,GAAG,CAACoQ,IAAI,CAAC06C,IAAI,EAAE,OAAOmkD,OAAO,IAAIpmG,KAAK,EAAE,EAAE,CAAC;QAClD;QACA2mG,UAAU,CAACD,IAAI,EAAEn/F,IAAI,CAAC;MACxB,CAAC,MAAM,IAAIA,IAAI,YAAYohD,iBAAiB,EAAE;QAC5C,IAAI29C,UAAU,CAACpvG,GAAG,CAACqQ,IAAI,CAAC06C,IAAI,CAAC,KAAK16C,IAAI,EAAE;UACtCk/F,QAAQ,CAACjwD,GAAG,CAACjvC,IAAI,CAAC06C,IAAI,CAAC;UACvBjiD,KAAK,EAAE;QACT;QACA2mG,UAAU,CAACD,IAAI,EAAEn/F,IAAI,CAAC;MACxB;IACF,CAAC,CAAC;IACF8+F,mBAAmB,CAACjzG,IAAI,CAAC,GAAGsZ,KAAK,CAACmZ,IAAI,CAAC,IAAI4uB,GAAG,CAACiyD,IAAI,CAACt1F,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC9Z,GAAG,CAACrC,IAAI,IAAI6sD,iBAAiB,CAAC,IAAIj1C,cAAc,CAAC5X,IAAI,CAAC,CAAC,CAAC,CAAC;IACxHmxG,OAAO,EAAE;IACT,IAAI74F,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACuJ,QAAQ,IAAIp8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACqJ,SAAS,IAAIl8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACsJ,iBAAiB,IAAIn8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACwJ,cAAc,EAAE;MAC5Ir8C,EAAE,CAACu8C,UAAU,CAAC2C,OAAO,CAAC05C,mBAAmB,CAAC54F,EAAE,CAACu8C,UAAU,CAAC,CAAC;IAC3D,CAAC,MAAM,IAAIv8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC6J,cAAc,IAAI18C,EAAE,CAAC28C,UAAU,KAAK,IAAI,EAAE;MACtE38C,EAAE,CAAC28C,UAAU,CAACuC,OAAO,CAAC05C,mBAAmB,CAAC54F,EAAE,CAAC28C,UAAU,CAAC,CAAC;IAC3D;EACF;EACA,OAAOm8C,mBAAmB;AAC5B;AACA,SAASM,UAAUA,CAACC,KAAK,EAAEr/F,IAAI,EAAE;EAC/B,MAAMtS,IAAI,GAAG2xG,KAAK,CAAC1vG,GAAG,CAACqQ,IAAI,CAAC06C,IAAI,CAAC;EACjC,IAAIhtD,IAAI,KAAK+tB,SAAS,EAAE;IACtB,MAAM,IAAIrvB,KAAK,CAAC,oCAAoC4T,IAAI,CAAC06C,IAAI,EAAE,CAAC;EAClE;EACA16C,IAAI,CAACtS,IAAI,GAAGA,IAAI;AAClB;AAEA,SAAS4xG,gBAAgBA,CAACvxC,GAAG,EAAE;EAC7B,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC6J,cAAc,EAAE;QACrC;MACF;MACA,IAAI18C,EAAE,CAAC48C,KAAK,YAAYnjD,WAAW,IAAIuG,EAAE,CAAC48C,KAAK,CAACl1D,IAAI,KAAK,QAAQ,EAAE;QACjEsY,EAAE,CAAC68C,SAAS,GAAGv5C,UAAU,CAACwE,WAAW,CAACoE,oBAAoB,CAAC;MAC7D,CAAC,MAAM,IAAIlM,EAAE,CAAC48C,KAAK,YAAYnjD,WAAW,IAAIuG,EAAE,CAAC48C,KAAK,CAACl1D,IAAI,KAAK,OAAO,EAAE;QACvEsY,EAAE,CAAC68C,SAAS,GAAGv5C,UAAU,CAACwE,WAAW,CAACqE,uBAAuB,CAAC;MAChE,CAAC,MAAM,IAAIotF,qBAAqB,CAACxxC,GAAG,CAACtD,IAAI,CAAC/P,IAAI,EAAE10C,EAAE,CAAC48C,KAAK,CAAC,EAAE;QACzD58C,EAAE,CAACwhD,qBAAqB,GAAG,IAAI;QAC/B,IAAIxhD,EAAE,CAAC48C,KAAK,CAACniD,QAAQ,CAACA,QAAQ,CAACpJ,IAAI,KAAKi3B,IAAI,CAACosB,IAAI,EAAE;UACjD10C,EAAE,CAAC68C,SAAS,GAAG78C,EAAE,CAAC48C,KAAK,CAACniD,QAAQ;QAClC,CAAC,MAAM;UACLuF,EAAE,CAAC68C,SAAS,GAAGv5C,UAAU,CAACwE,WAAW,CAACsE,iBAAiB,CAAC,CAACjW,MAAM,CAAC,EAAE,CAAC,CAACJ,IAAI,CAACiK,EAAE,CAAC48C,KAAK,CAACniD,QAAQ,CAAC/S,IAAI,CAAC;UAChGsY,EAAE,CAAC48C,KAAK,GAAG58C,EAAE,CAAC68C,SAAS;QACzB;MACF,CAAC,MAAM;QACL78C,EAAE,CAAC48C,KAAK,GAAG7D,gCAAgC,CAAC/4C,EAAE,CAAC48C,KAAK,EAAE5iD,IAAI,IAAI;UAC5D,IAAIA,IAAI,YAAYygD,eAAe,IAAIzgD,IAAI,YAAY2gD,uBAAuB,EAAE;YAC9E,MAAM,IAAIv0D,KAAK,CAAC,sDAAsD,CAAC;UACzE,CAAC,MAAM,IAAI4T,IAAI,YAAYk/C,WAAW,EAAE;YACtCl5C,EAAE,CAACwhD,qBAAqB,GAAG,IAAI;YAC/B,OAAO,IAAIpI,gBAAgB,CAACp/C,IAAI,CAAC3I,IAAI,CAAC;UACxC;UACA,OAAO2I,IAAI;QACb,CAAC,EAAEsgD,kBAAkB,CAACpnD,IAAI,CAAC;QAC3B,MAAMsmG,WAAW,GAAG,IAAI76C,MAAM,CAAC,CAAC;QAChC66C,WAAW,CAAC3zG,IAAI,CAAC0uD,iBAAiB,CAAC,IAAI9xC,eAAe,CAACzC,EAAE,CAAC48C,KAAK,EAAE58C,EAAE,CAAC48C,KAAK,CAAC9mD,UAAU,CAAC,CAAC,CAAC;QACvFkK,EAAE,CAAC28C,UAAU,GAAG68C,WAAW;MAC7B;IACF;EACF;AACF;AACA,SAASD,qBAAqBA,CAACE,QAAQ,EAAEz/F,IAAI,EAAE;EAC7C,IAAI,EAAEA,IAAI,YAAY1D,kBAAkB,CAAC,IAAI0D,IAAI,CAACQ,IAAI,CAAC5U,MAAM,KAAK,CAAC,IAAIoU,IAAI,CAACQ,IAAI,CAAC5U,MAAM,GAAG,CAAC,EAAE;IAC3F,OAAO,KAAK;EACd;EACA,IAAI,EAAEoU,IAAI,CAACS,QAAQ,YAAYzE,YAAY,IAAIgE,IAAI,CAACS,QAAQ,CAACA,QAAQ,YAAYy+C,WAAW,CAAC,IAAIl/C,IAAI,CAACS,QAAQ,CAACA,QAAQ,CAACpJ,IAAI,KAAKooG,QAAQ,EAAE;IACzI,OAAO,KAAK;EACd;EACA,MAAM,CAACC,IAAI,EAAEC,IAAI,CAAC,GAAG3/F,IAAI,CAACQ,IAAI;EAC9B,IAAI,EAAEk/F,IAAI,YAAYjgG,WAAW,CAAC,IAAIigG,IAAI,CAAChyG,IAAI,KAAK,QAAQ,EAAE;IAC5D,OAAO,KAAK;EACd,CAAC,MAAM,IAAIsS,IAAI,CAACQ,IAAI,CAAC5U,MAAM,KAAK,CAAC,EAAE;IACjC,OAAO,IAAI;EACb;EACA,IAAI,EAAE+zG,IAAI,YAAYlgG,WAAW,CAAC,IAAIkgG,IAAI,CAACjyG,IAAI,KAAK,OAAO,EAAE;IAC3D,OAAO,KAAK;EACd;EACA,OAAO,IAAI;AACb;AAEA,SAASkyG,sBAAsBA,CAAC7xC,GAAG,EAAE;EACnC,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC6J,cAAc,EAAE;QACrC;MACF;MACA18C,EAAE,CAAC48C,KAAK,GAAG7D,gCAAgC,CAAC/4C,EAAE,CAAC48C,KAAK,EAAE5iD,IAAI,IAAI;QAC5D,IAAIA,IAAI,YAAYy+C,eAAe,EAAE;UACnC,IAAIz4C,EAAE,CAACmhD,QAAQ,CAAC04C,MAAM,CAAC9uG,GAAG,CAACiP,IAAI,CAACtS,IAAI,CAAC,EAAE;YACrC,OAAO2b,QAAQ,CAAC,QAAQ,CAAC;UAC3B,CAAC,MAAM,IAAIrJ,IAAI,CAACtS,IAAI,KAAKsY,EAAE,CAACmhD,QAAQ,CAAC24C,SAAS,EAAE;YAC9C,OAAOz2F,QAAQ,CAAC,OAAO,CAAC;UAC1B;QACF;QACA,OAAOrJ,IAAI;MACb,CAAC,EAAEsgD,kBAAkB,CAACpnD,IAAI,CAAC;IAC7B;EACF;AACF;AAEA,SAAS6mG,yBAAyBA,CAAChyC,GAAG,EAAE;EACtC,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACwJ,cAAc,EAAE;QACrCR,wBAAwB,CAAC77C,EAAE,EAAEhG,IAAI,IAAI;UACnC,IAAI,EAAEA,IAAI,YAAY+/C,oBAAoB,CAAC,EAAE;YAC3C,OAAO//C,IAAI;UACb;UACA,MAAM;YACJ0lB,MAAM;YACN/3B;UACF,CAAC,GAAGqS,IAAI;UACR,IAAI0lB,MAAM,YAAY1pB,YAAY,IAAI0pB,MAAM,YAAYxpB,WAAW,EAAE;YACnE,OAAOwc,gBAAgB,CAACgN,MAAM,EAAE/3B,KAAK,CAAC,CAAC8Q,EAAE,CAACinB,MAAM,CAAC91B,GAAG,CAACjC,KAAK,CAAC,CAAC;UAC9D;UACA,IAAI+3B,MAAM,YAAYu6B,gBAAgB,EAAE;YACtC,OAAOvnC,gBAAgB,CAACgN,MAAM,EAAE/3B,KAAK,CAAC;UACxC;UACA,MAAM,IAAIvB,KAAK,CAAC,mDAAmD,CAAC;QACtE,CAAC,EAAEk0D,kBAAkB,CAACC,gBAAgB,CAAC;MACzC;IACF;EACF;AACF;AAEA,SAASy/C,cAAcA,CAACjyC,GAAG,EAAE;EAC3B,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,IAAI8yC,QAAQ,GAAG,CAAC;IAChB,KAAK,MAAMj6F,EAAE,IAAIsoB,IAAI,CAAC62B,GAAG,CAAC,CAAC,EAAE;MAC3B,IAAI9K,oBAAoB,CAACr0C,EAAE,CAAC,EAAE;QAC5Bi6F,QAAQ,IAAIC,YAAY,CAACl6F,EAAE,CAAC;MAC9B;IACF;IACA,KAAK,MAAMA,EAAE,IAAIsoB,IAAI,CAAC62B,GAAG,CAAC,CAAC,EAAE;MAC3BvD,oBAAoB,CAAC57C,EAAE,EAAEhG,IAAI,IAAI;QAC/B,IAAI,CAACu+C,cAAc,CAACv+C,IAAI,CAAC,EAAE;UACzB;QACF;QACA,IAAI+tD,GAAG,CAAC/B,aAAa,KAAK/S,iBAAiB,CAACsW,yBAAyB,IAAIvvD,IAAI,YAAYmgD,gBAAgB,EAAE;UACzG;QACF;QACA,IAAI7F,qBAAqB,CAACt6C,IAAI,CAAC,EAAE;UAC/BA,IAAI,CAACogD,SAAS,GAAG6/C,QAAQ;QAC3B;QACA,IAAI5lD,oBAAoB,CAACr6C,IAAI,CAAC,EAAE;UAC9BigG,QAAQ,IAAIE,sBAAsB,CAACngG,IAAI,CAAC;QAC1C;MACF,CAAC,CAAC;IACJ;IACA,IAAI+tD,GAAG,CAAC/B,aAAa,KAAK/S,iBAAiB,CAACsW,yBAAyB,EAAE;MACrE,KAAK,MAAMvpD,EAAE,IAAIsoB,IAAI,CAAC62B,GAAG,CAAC,CAAC,EAAE;QAC3BvD,oBAAoB,CAAC57C,EAAE,EAAEhG,IAAI,IAAI;UAC/B,IAAI,CAACu+C,cAAc,CAACv+C,IAAI,CAAC,IAAI,EAAEA,IAAI,YAAYmgD,gBAAgB,CAAC,EAAE;YAChE;UACF;UACA,IAAI7F,qBAAqB,CAACt6C,IAAI,CAAC,EAAE;YAC/BA,IAAI,CAACogD,SAAS,GAAG6/C,QAAQ;UAC3B;UACA,IAAI5lD,oBAAoB,CAACr6C,IAAI,CAAC,EAAE;YAC9BigG,QAAQ,IAAIE,sBAAsB,CAACngG,IAAI,CAAC;UAC1C;QACF,CAAC,CAAC;MACJ;IACF;IACAsuB,IAAI,CAAC6H,IAAI,GAAG8pE,QAAQ;EACtB;EACA,IAAIlyC,GAAG,YAAY1B,uBAAuB,EAAE;IAC1C,KAAK,MAAM/9B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;MAC5B,KAAK,MAAMnnD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;QAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACtjB,QAAQ,IAAIvvB,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC6J,cAAc,IAAI18C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACyL,iBAAiB,IAAIt+C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC0L,uBAAuB,EAAE;UAC1J;QACF;QACA,MAAM4tC,SAAS,GAAGpkC,GAAG,CAAClB,KAAK,CAACl9D,GAAG,CAACqW,EAAE,CAAC00C,IAAI,CAAC;QACxC10C,EAAE,CAACmwB,IAAI,GAAGg8D,SAAS,CAACh8D,IAAI;MAC1B;IACF;EACF;AACF;AACA,SAAS+pE,YAAYA,CAACl6F,EAAE,EAAE;EACxB,IAAIo6F,KAAK;EACT,QAAQp6F,EAAE,CAACmhC,IAAI;IACb,KAAK0R,MAAM,CAAC2D,SAAS;MACnB4jD,KAAK,GAAG,CAAC;MACT,IAAIp6F,EAAE,CAACtR,UAAU,YAAY41B,aAAa,IAAI,CAAC+1E,wBAAwB,CAACr6F,EAAE,CAACtR,UAAU,CAAC,EAAE;QACtF0rG,KAAK,IAAIp6F,EAAE,CAACtR,UAAU,CAAC+M,WAAW,CAAC7V,MAAM;MAC3C;MACA,OAAOw0G,KAAK;IACd,KAAKvnD,MAAM,CAAChZ,QAAQ;IACpB,KAAKgZ,MAAM,CAACmJ,WAAW;MACrBo+C,KAAK,GAAG,CAAC;MACT,IAAIp6F,EAAE,CAACtR,UAAU,YAAY41B,aAAa,EAAE;QAC1C81E,KAAK,IAAIp6F,EAAE,CAACtR,UAAU,CAAC+M,WAAW,CAAC7V,MAAM;MAC3C;MACA,OAAOw0G,KAAK;IACd,KAAKvnD,MAAM,CAACyF,OAAO;MACjB,OAAO,CAAC;IACV,KAAKzF,MAAM,CAACgD,cAAc;MACxB,OAAO,CAAC;IACV,KAAKhD,MAAM,CAACkD,SAAS;IACrB,KAAKlD,MAAM,CAACoD,SAAS;IACrB,KAAKpD,MAAM,CAACsD,QAAQ;IACpB,KAAKtD,MAAM,CAACwD,QAAQ;MAClB+jD,KAAK,GAAG,CAAC;MACT,IAAIp6F,EAAE,CAACtR,UAAU,YAAY41B,aAAa,EAAE;QAC1C81E,KAAK,IAAIp6F,EAAE,CAACtR,UAAU,CAAC+M,WAAW,CAAC7V,MAAM;MAC3C;MACA,OAAOw0G,KAAK;IACd,KAAKvnD,MAAM,CAACmC,eAAe;MACzB,OAAOh1C,EAAE,CAAC+0C,aAAa,CAACt5C,WAAW,CAAC7V,MAAM;IAC5C,KAAKitD,MAAM,CAACkF,cAAc;IAC1B,KAAKlF,MAAM,CAAC7vB,WAAW;IACvB,KAAK6vB,MAAM,CAAC2E,SAAS;IACrB,KAAK3E,MAAM,CAACuF,QAAQ;MAClB,OAAO,CAAC;IACV,KAAKvF,MAAM,CAAC6J,cAAc;MACxB,OAAO18C,EAAE,CAACkhD,SAAS,GAAG,CAAC,GAAG,CAAC;IAC7B;MACE,MAAM,IAAI96D,KAAK,CAAC,iBAAiBysD,MAAM,CAAC7yC,EAAE,CAACmhC,IAAI,CAAC,EAAE,CAAC;EACvD;AACF;AACA,SAASg5D,sBAAsBA,CAACngG,IAAI,EAAE;EACpC,QAAQA,IAAI,CAACmnC,IAAI;IACf,KAAK2R,cAAc,CAACqH,gBAAgB;MAClC,OAAO,CAAC,GAAGngD,IAAI,CAACQ,IAAI,CAAC5U,MAAM;IAC7B,KAAKktD,cAAc,CAAC4H,WAAW;MAC7B,OAAO,CAAC,GAAG1gD,IAAI,CAACQ,IAAI,CAAC5U,MAAM;IAC7B,KAAKktD,cAAc,CAAC+H,mBAAmB;MACrC,OAAO,CAAC,GAAG7gD,IAAI,CAAC4gD,OAAO;IACzB,KAAK9H,cAAc,CAACsF,QAAQ;MAC1B,OAAO,CAAC;IACV;MACE,MAAM,IAAIhyD,KAAK,CAAC,0DAA0D4T,IAAI,CAACtP,WAAW,CAAChD,IAAI,EAAE,CAAC;EACtG;AACF;AACA,SAAS2yG,wBAAwBA,CAACrgG,IAAI,EAAE;EACtC,IAAIA,IAAI,CAACyB,WAAW,CAAC7V,MAAM,KAAK,CAAC,IAAIoU,IAAI,CAACuqB,OAAO,CAAC3+B,MAAM,KAAK,CAAC,EAAE;IAC9D,OAAO,KAAK;EACd;EACA,IAAIoU,IAAI,CAACuqB,OAAO,CAAC,CAAC,CAAC,KAAK,EAAE,IAAIvqB,IAAI,CAACuqB,OAAO,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;IACpD,OAAO,KAAK;EACd;EACA,OAAO,IAAI;AACb;AAEA,SAAS+1E,iBAAiBA,CAACvyC,GAAG,EAAE;EAC9B,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5BozC,2BAA2B,CAACjyE,IAAI,CAACo/B,MAAM,CAAC;IACxC6yC,2BAA2B,CAACjyE,IAAI,CAACq/B,MAAM,CAAC;IACxC,KAAK,MAAM3nD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACuJ,QAAQ,IAAIp8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACqJ,SAAS,IAAIl8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACsJ,iBAAiB,IAAIn8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACwJ,cAAc,EAAE;QAC5Ik+C,2BAA2B,CAACv6F,EAAE,CAACu8C,UAAU,CAAC;MAC5C,CAAC,MAAM,IAAIv8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC6J,cAAc,IAAI18C,EAAE,CAAC28C,UAAU,KAAK,IAAI,EAAE;QACtE49C,2BAA2B,CAACv6F,EAAE,CAAC28C,UAAU,CAAC;MAC5C;IACF;IACA69C,yBAAyB,CAAClyE,IAAI,CAACo/B,MAAM,EAAEK,GAAG,CAAC/B,aAAa,CAAC;IACzDw0C,yBAAyB,CAAClyE,IAAI,CAACq/B,MAAM,EAAEI,GAAG,CAAC/B,aAAa,CAAC;IACzD,KAAK,MAAMhmD,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACuJ,QAAQ,IAAIp8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACqJ,SAAS,IAAIl8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACsJ,iBAAiB,IAAIn8C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAACwJ,cAAc,EAAE;QAC5Im+C,yBAAyB,CAACx6F,EAAE,CAACu8C,UAAU,EAAEwL,GAAG,CAAC/B,aAAa,CAAC;MAC7D,CAAC,MAAM,IAAIhmD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC6J,cAAc,IAAI18C,EAAE,CAAC28C,UAAU,KAAK,IAAI,EAAE;QACtE69C,yBAAyB,CAACx6F,EAAE,CAAC28C,UAAU,EAAEoL,GAAG,CAAC/B,aAAa,CAAC;MAC7D;IACF;EACF;AACF;AACA,IAAIy0C,KAAK;AACT,CAAC,UAAUA,KAAK,EAAE;EAChBA,KAAK,CAACA,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EACjCA,KAAK,CAACA,KAAK,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC,GAAG,iBAAiB;EACvDA,KAAK,CAACA,KAAK,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,GAAG,kBAAkB;EACzDA,KAAK,CAACA,KAAK,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,GAAG,eAAe;AACrD,CAAC,EAAEA,KAAK,KAAKA,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC;AACzB,SAASF,2BAA2BA,CAACp7C,GAAG,EAAE;EACxC,MAAMhvB,IAAI,GAAG,IAAI7nC,GAAG,CAAC,CAAC;EACtB,KAAK,MAAM0X,EAAE,IAAIm/C,GAAG,EAAE;IACpB,IAAIn/C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAChjB,QAAQ,IAAI7vB,EAAE,CAAC7E,KAAK,GAAG43C,aAAa,CAAC6hB,YAAY,EAAE;MACxEhZ,oBAAoB,CAAC57C,EAAE,EAAEhG,IAAI,IAAI;QAC/B,IAAIu+C,cAAc,CAACv+C,IAAI,CAAC,IAAI0gG,qBAAqB,CAAC1gG,IAAI,CAAC,KAAKygG,KAAK,CAACvnG,IAAI,EAAE;UACtE,MAAM,IAAI9M,KAAK,CAAC,sEAAsE,CAAC;QACzF;MACF,CAAC,CAAC;MACF+pC,IAAI,CAACvmC,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC;IACvB;IACA67C,wBAAwB,CAAC77C,EAAE,EAAEhG,IAAI,IAAI;MACnC,IAAIA,IAAI,YAAYigD,gBAAgB,IAAI9pB,IAAI,CAACplC,GAAG,CAACiP,IAAI,CAAC06C,IAAI,CAAC,EAAE;QAC3D,MAAMimD,KAAK,GAAGxqE,IAAI,CAACxmC,GAAG,CAACqQ,IAAI,CAAC06C,IAAI,CAAC;QACjC,OAAOimD,KAAK,CAAChmD,WAAW,CAAC96C,KAAK,CAAC,CAAC;MAClC;MACA,OAAOG,IAAI;IACb,CAAC,EAAEsgD,kBAAkB,CAACpnD,IAAI,CAAC;EAC7B;EACA,KAAK,MAAM8M,EAAE,IAAImwB,IAAI,CAACtsB,MAAM,CAAC,CAAC,EAAE;IAC9B86C,MAAM,CAACiB,MAAM,CAAC5/C,EAAE,CAAC;EACnB;AACF;AACA,SAASw6F,yBAAyBA,CAACr7C,GAAG,EAAE6G,aAAa,EAAE;EACrD,MAAM40C,QAAQ,GAAG,IAAItyG,GAAG,CAAC,CAAC;EAC1B,MAAMuyG,SAAS,GAAG,IAAIvyG,GAAG,CAAC,CAAC;EAC3B,MAAMwyG,eAAe,GAAG,IAAI5zD,GAAG,CAAC,CAAC;EACjC,MAAM6zD,KAAK,GAAG,IAAIzyG,GAAG,CAAC,CAAC;EACvB,KAAK,MAAM0X,EAAE,IAAIm/C,GAAG,EAAE;IACpB,IAAIn/C,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAChjB,QAAQ,EAAE;MAC/B,IAAI+qE,QAAQ,CAAC7vG,GAAG,CAACiV,EAAE,CAAC00C,IAAI,CAAC,IAAImmD,SAAS,CAAC9vG,GAAG,CAACiV,EAAE,CAAC00C,IAAI,CAAC,EAAE;QACnD,MAAM,IAAItuD,KAAK,CAAC,yDAAyD4Z,EAAE,CAAC00C,IAAI,EAAE,CAAC;MACrF;MACAkmD,QAAQ,CAAChxG,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC;MACzB66F,SAAS,CAACjxG,GAAG,CAACoW,EAAE,CAAC00C,IAAI,EAAE,CAAC,CAAC;IAC3B;IACAqmD,KAAK,CAACnxG,GAAG,CAACoW,EAAE,EAAEg7F,aAAa,CAACh7F,EAAE,CAAC,CAAC;IAChCi7F,mBAAmB,CAACj7F,EAAE,EAAE66F,SAAS,EAAEC,eAAe,CAAC;EACrD;EACA,IAAII,aAAa,GAAG,KAAK;EACzB,KAAK,MAAMl7F,EAAE,IAAIm/C,GAAG,CAACI,QAAQ,CAAC,CAAC,EAAE;IAC/B,MAAM47C,MAAM,GAAGJ,KAAK,CAACpxG,GAAG,CAACqW,EAAE,CAAC;IAC5B,IAAIA,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAChjB,QAAQ,IAAIgrE,SAAS,CAAClxG,GAAG,CAACqW,EAAE,CAAC00C,IAAI,CAAC,KAAK,CAAC,EAAE;MAC/D,IAAIwmD,aAAa,IAAIC,MAAM,CAACC,MAAM,GAAGX,KAAK,CAACY,gBAAgB,IAAIF,MAAM,CAACC,MAAM,GAAGX,KAAK,CAACa,aAAa,EAAE;QAClG,MAAMC,MAAM,GAAGhnD,iBAAiB,CAACv0C,EAAE,CAAC20C,WAAW,CAACp7C,MAAM,CAAC,CAAC,CAAC;QACzDwhG,KAAK,CAACnxG,GAAG,CAAC2xG,MAAM,EAAEJ,MAAM,CAAC;QACzBx8C,MAAM,CAACv3D,OAAO,CAAC4Y,EAAE,EAAEu7F,MAAM,CAAC;MAC5B,CAAC,MAAM;QACLC,qBAAqB,CAACx7F,EAAE,EAAE66F,SAAS,CAAC;QACpCl8C,MAAM,CAACiB,MAAM,CAAC5/C,EAAE,CAAC;MACnB;MACA+6F,KAAK,CAAClF,MAAM,CAAC71F,EAAE,CAAC;MAChB46F,QAAQ,CAAC/E,MAAM,CAAC71F,EAAE,CAAC00C,IAAI,CAAC;MACxBmmD,SAAS,CAAChF,MAAM,CAAC71F,EAAE,CAAC00C,IAAI,CAAC;MACzB;IACF;IACA,IAAIymD,MAAM,CAACC,MAAM,GAAGX,KAAK,CAACgB,eAAe,EAAE;MACzCP,aAAa,GAAG,IAAI;IACtB;EACF;EACA,MAAMQ,QAAQ,GAAG,EAAE;EACnB,KAAK,MAAM,CAAC5uG,EAAE,EAAE2F,KAAK,CAAC,IAAIooG,SAAS,EAAE;IACnC,MAAM5pE,IAAI,GAAG2pE,QAAQ,CAACjxG,GAAG,CAACmD,EAAE,CAAC;IAC7B,MAAM6uG,cAAc,GAAG,CAAC,EAAE1qE,IAAI,CAAC91B,KAAK,GAAG43C,aAAa,CAAC6hB,YAAY,CAAC;IAClE,IAAIniE,KAAK,KAAK,CAAC,IAAIkpG,cAAc,EAAE;MACjC;IACF;IACA,IAAIb,eAAe,CAAC/vG,GAAG,CAAC+B,EAAE,CAAC,EAAE;MAC3B;IACF;IACA4uG,QAAQ,CAAC71G,IAAI,CAACiH,EAAE,CAAC;EACnB;EACA,IAAI8/F,SAAS;EACb,OAAOA,SAAS,GAAG8O,QAAQ,CAAC3gF,GAAG,CAAC,CAAC,EAAE;IACjC,MAAMkW,IAAI,GAAG2pE,QAAQ,CAACjxG,GAAG,CAACijG,SAAS,CAAC;IACpC,MAAMgP,OAAO,GAAGb,KAAK,CAACpxG,GAAG,CAACsnC,IAAI,CAAC;IAC/B,MAAM0qE,cAAc,GAAG,CAAC,EAAE1qE,IAAI,CAAC91B,KAAK,GAAG43C,aAAa,CAAC6hB,YAAY,CAAC;IAClE,IAAI+mC,cAAc,EAAE;MAClB,MAAM,IAAIv1G,KAAK,CAAC,kFAAkF,CAAC;IACrG;IACA,KAAK,IAAIy1G,QAAQ,GAAG5qE,IAAI,CAAC4jB,IAAI,EAAEgnD,QAAQ,CAAC16D,IAAI,KAAK0R,MAAM,CAACgM,OAAO,EAAEg9C,QAAQ,GAAGA,QAAQ,CAAChnD,IAAI,EAAE;MACzF,MAAMsmD,MAAM,GAAGJ,KAAK,CAACpxG,GAAG,CAACkyG,QAAQ,CAAC;MAClC,IAAIV,MAAM,CAACW,aAAa,CAAC/wG,GAAG,CAAC6hG,SAAS,CAAC,EAAE;QACvC,IAAI5mC,aAAa,KAAK/S,iBAAiB,CAACsW,yBAAyB,IAAI,CAACwyC,yBAAyB,CAAC9qE,IAAI,EAAE4qE,QAAQ,CAAC,EAAE;UAC/G;QACF;QACA,IAAIG,4BAA4B,CAACpP,SAAS,EAAE37D,IAAI,CAAC0jB,WAAW,EAAEknD,QAAQ,EAAED,OAAO,CAACR,MAAM,CAAC,EAAE;UACvFD,MAAM,CAACW,aAAa,CAACjG,MAAM,CAACjJ,SAAS,CAAC;UACtC,KAAK,MAAM9/F,EAAE,IAAI8uG,OAAO,CAACE,aAAa,EAAE;YACtCX,MAAM,CAACW,aAAa,CAAC7yD,GAAG,CAACn8C,EAAE,CAAC;UAC9B;UACAquG,MAAM,CAACC,MAAM,IAAIQ,OAAO,CAACR,MAAM;UAC/BR,QAAQ,CAAC/E,MAAM,CAACjJ,SAAS,CAAC;UAC1BiO,SAAS,CAAChF,MAAM,CAACjJ,SAAS,CAAC;UAC3BmO,KAAK,CAAClF,MAAM,CAAC5kE,IAAI,CAAC;UAClB0tB,MAAM,CAACiB,MAAM,CAAC3uB,IAAI,CAAC;QACrB;QACA;MACF;MACA,IAAI,CAACgrE,sBAAsB,CAACd,MAAM,CAACC,MAAM,EAAEQ,OAAO,CAACR,MAAM,CAAC,EAAE;QAC1D;MACF;IACF;EACF;AACF;AACA,SAASV,qBAAqBA,CAAC1gG,IAAI,EAAE;EACnC,QAAQA,IAAI,CAACmnC,IAAI;IACf,KAAK2R,cAAc,CAACyG,WAAW;MAC7B,OAAOkhD,KAAK,CAACgB,eAAe,GAAGhB,KAAK,CAACY,gBAAgB;IACvD,KAAKvoD,cAAc,CAAC8G,WAAW;MAC7B,OAAO6gD,KAAK,CAACgB,eAAe,GAAGhB,KAAK,CAACY,gBAAgB,GAAGZ,KAAK,CAACa,aAAa;IAC7E,KAAKxoD,cAAc,CAACsF,QAAQ;MAC1B,OAAOqiD,KAAK,CAACa,aAAa;IAC5B,KAAKxoD,cAAc,CAAC/iB,SAAS;IAC7B,KAAK+iB,cAAc,CAACmG,mBAAmB;MACrC,OAAOwhD,KAAK,CAACgB,eAAe;IAC9B;MACE,OAAOhB,KAAK,CAACvnG,IAAI;EACrB;AACF;AACA,SAAS8nG,aAAaA,CAACh7F,EAAE,EAAE;EACzB,IAAIo7F,MAAM,GAAGX,KAAK,CAACvnG,IAAI;EACvB,MAAM4oG,aAAa,GAAG,IAAI50D,GAAG,CAAC,CAAC;EAC/B0U,oBAAoB,CAAC57C,EAAE,EAAEhG,IAAI,IAAI;IAC/B,IAAI,CAACu+C,cAAc,CAACv+C,IAAI,CAAC,EAAE;MACzB;IACF;IACA,QAAQA,IAAI,CAACmnC,IAAI;MACf,KAAK2R,cAAc,CAACoH,YAAY;QAC9B4hD,aAAa,CAAC7yD,GAAG,CAACjvC,IAAI,CAAC06C,IAAI,CAAC;QAC5B;MACF;QACE0mD,MAAM,IAAIV,qBAAqB,CAAC1gG,IAAI,CAAC;IACzC;EACF,CAAC,CAAC;EACF,OAAO;IACLohG,MAAM;IACNU;EACF,CAAC;AACH;AACA,SAASb,mBAAmBA,CAACj7F,EAAE,EAAE66F,SAAS,EAAEqB,cAAc,EAAE;EAC1DtgD,oBAAoB,CAAC57C,EAAE,EAAE,CAAChG,IAAI,EAAEmB,KAAK,KAAK;IACxC,IAAI,CAACo9C,cAAc,CAACv+C,IAAI,CAAC,EAAE;MACzB;IACF;IACA,IAAIA,IAAI,CAACmnC,IAAI,KAAK2R,cAAc,CAACoH,YAAY,EAAE;MAC7C;IACF;IACA,MAAMznD,KAAK,GAAGooG,SAAS,CAAClxG,GAAG,CAACqQ,IAAI,CAAC06C,IAAI,CAAC;IACtC,IAAIjiD,KAAK,KAAKgjB,SAAS,EAAE;MACvB;IACF;IACAolF,SAAS,CAACjxG,GAAG,CAACoQ,IAAI,CAAC06C,IAAI,EAAEjiD,KAAK,GAAG,CAAC,CAAC;IACnC,IAAI0I,KAAK,GAAGm/C,kBAAkB,CAACC,gBAAgB,EAAE;MAC/C2hD,cAAc,CAACjzD,GAAG,CAACjvC,IAAI,CAAC06C,IAAI,CAAC;IAC/B;EACF,CAAC,CAAC;AACJ;AACA,SAAS8mD,qBAAqBA,CAACx7F,EAAE,EAAE66F,SAAS,EAAE;EAC5Cj/C,oBAAoB,CAAC57C,EAAE,EAAEhG,IAAI,IAAI;IAC/B,IAAI,CAACu+C,cAAc,CAACv+C,IAAI,CAAC,EAAE;MACzB;IACF;IACA,IAAIA,IAAI,CAACmnC,IAAI,KAAK2R,cAAc,CAACoH,YAAY,EAAE;MAC7C;IACF;IACA,MAAMznD,KAAK,GAAGooG,SAAS,CAAClxG,GAAG,CAACqQ,IAAI,CAAC06C,IAAI,CAAC;IACtC,IAAIjiD,KAAK,KAAKgjB,SAAS,EAAE;MACvB;IACF,CAAC,MAAM,IAAIhjB,KAAK,KAAK,CAAC,EAAE;MACtB,MAAM,IAAIrM,KAAK,CAAC,8BAA8B4T,IAAI,CAAC06C,IAAI,8CAA8C,CAAC;IACxG;IACAmmD,SAAS,CAACjxG,GAAG,CAACoQ,IAAI,CAAC06C,IAAI,EAAEjiD,KAAK,GAAG,CAAC,CAAC;EACrC,CAAC,CAAC;AACJ;AACA,SAASwpG,sBAAsBA,CAACb,MAAM,EAAEe,UAAU,EAAE;EAClD,IAAIf,MAAM,GAAGX,KAAK,CAACY,gBAAgB,EAAE;IACnC,IAAIc,UAAU,GAAG1B,KAAK,CAACgB,eAAe,EAAE;MACtC,OAAO,KAAK;IACd;EACF,CAAC,MAAM,IAAIL,MAAM,GAAGX,KAAK,CAACgB,eAAe,EAAE;IACzC,IAAIU,UAAU,GAAG1B,KAAK,CAACY,gBAAgB,EAAE;MACvC,OAAO,KAAK;IACd;EACF;EACA,OAAO,IAAI;AACb;AACA,SAASW,4BAA4BA,CAAClvG,EAAE,EAAE6nD,WAAW,EAAEj1B,MAAM,EAAEy8E,UAAU,EAAE;EACzE,IAAIC,OAAO,GAAG,KAAK;EACnB,IAAIC,eAAe,GAAG,IAAI;EAC1BxgD,wBAAwB,CAACn8B,MAAM,EAAE,CAAC1lB,IAAI,EAAEmB,KAAK,KAAK;IAChD,IAAI,CAACo9C,cAAc,CAACv+C,IAAI,CAAC,EAAE;MACzB,OAAOA,IAAI;IACb;IACA,IAAIoiG,OAAO,IAAI,CAACC,eAAe,EAAE;MAC/B,OAAOriG,IAAI;IACb,CAAC,MAAM,IAAImB,KAAK,GAAGm/C,kBAAkB,CAACC,gBAAgB,IAAI4hD,UAAU,GAAG1B,KAAK,CAACgB,eAAe,EAAE;MAC5F,OAAOzhG,IAAI;IACb;IACA,QAAQA,IAAI,CAACmnC,IAAI;MACf,KAAK2R,cAAc,CAACoH,YAAY;QAC9B,IAAIlgD,IAAI,CAAC06C,IAAI,KAAK5nD,EAAE,EAAE;UACpBsvG,OAAO,GAAG,IAAI;UACd,OAAOznD,WAAW;QACpB;QACA;MACF;QACE,MAAM2nD,UAAU,GAAG5B,qBAAqB,CAAC1gG,IAAI,CAAC;QAC9CqiG,eAAe,GAAGA,eAAe,IAAIJ,sBAAsB,CAACK,UAAU,EAAEH,UAAU,CAAC;QACnF;IACJ;IACA,OAAOniG,IAAI;EACb,CAAC,EAAEsgD,kBAAkB,CAACpnD,IAAI,CAAC;EAC3B,OAAOkpG,OAAO;AAChB;AACA,SAASL,yBAAyBA,CAAC9qE,IAAI,EAAEvR,MAAM,EAAE;EAC/C,QAAQuR,IAAI,CAAC5tB,QAAQ,CAAC89B,IAAI;IACxB,KAAK6R,oBAAoB,CAAC8gB,UAAU;MAClC,IAAI7iC,IAAI,CAAC0jB,WAAW,YAAYl7C,WAAW,IAAIw3B,IAAI,CAAC0jB,WAAW,CAACjtD,IAAI,KAAK,KAAK,EAAE;QAC9E,OAAO,IAAI;MACb;MACA,OAAO,KAAK;IACd,KAAKsrD,oBAAoB,CAACmG,OAAO;MAC/B,OAAOz5B,MAAM,CAACyhB,IAAI,KAAK0R,MAAM,CAAChjB,QAAQ;IACxC;MACE,OAAO,IAAI;EACf;AACF;AAEA,SAAS0sE,YAAYA,CAACx0C,GAAG,EAAE;EACzB,KAAK,MAAMz/B,IAAI,IAAIy/B,GAAG,CAACZ,KAAK,EAAE;IAC5B,IAAI8G,aAAa,GAAG,IAAI;IACxB,IAAIuuC,WAAW,GAAG,IAAI;IACtB,KAAK,MAAMx8F,EAAE,IAAIsoB,IAAI,CAACo/B,MAAM,EAAE;MAC5B,QAAQ1nD,EAAE,CAACmhC,IAAI;QACb,KAAK0R,MAAM,CAACiL,SAAS;UACnBmQ,aAAa,GAAGjuD,EAAE;UAClB;QACF,KAAK6yC,MAAM,CAACgL,OAAO;UACjBoQ,aAAa,GAAG,IAAI;UACpB;QACF,KAAKpb,MAAM,CAACmL,QAAQ;UAClB,IAAIiQ,aAAa,KAAK,IAAI,EAAE;YAC1BuuC,WAAW,GAAGz0C,GAAG,CAAC5B,cAAc,CAAC,CAAC;YAClCxH,MAAM,CAACsB,YAAY,CAACuE,iBAAiB,CAACg4C,WAAW,EAAEx8F,EAAE,CAACnT,OAAO,EAAE4oB,SAAS,EAAE,IAAI,CAAC,EAAEzV,EAAE,CAAC;UACtF;UACA;QACF,KAAK6yC,MAAM,CAACkL,MAAM;UAChB,IAAIy+C,WAAW,KAAK,IAAI,EAAE;YACxB79C,MAAM,CAACuB,WAAW,CAAC0E,eAAe,CAAC43C,WAAW,EAAE,IAAI,CAAC,EAAEx8F,EAAE,CAAC;YAC1Dw8F,WAAW,GAAG,IAAI;UACpB;UACA;MACJ;IACF;EACF;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,MAAM,GAAG,CAAC;EACdt7D,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAE6zF;AACN,CAAC,EAAE;EACDjtD,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAEy1F;AACN,CAAC,EAAE;EACD7uD,IAAI,EAAEykB,kBAAkB,CAACuC,IAAI;EAC7B5tD,EAAE,EAAE46D;AACN,CAAC,EAAE;EACDh0B,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAE2wF;AACN,CAAC,EAAE;EACD/pD,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEs0F;AACN,CAAC,EAAE;EACD1tD,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEgiG;AACN,CAAC,EAAE;EACDp7D,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAE2zD;AACN,CAAC,EAAE;EACD/sB,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAEm+F;AACN,CAAC,EAAE;EACDv3D,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAEyvD;AACN,CAAC,EAAE;EACD7oB,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAE6yD;AACN,CAAC,EAAE;EACDjsB,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAE6uD;AACN,CAAC,EAAE;EACDjoB,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEozD;AACN,CAAC,EAAE;EACDxsB,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAEmxF;AACN,CAAC,EAAE;EACDvqD,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEm6F;AACN,CAAC,EAAE;EACDvzD,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAEmwD;AACN,CAAC,EAAE;EACDvpB,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAEozF;AACN,CAAC,EAAE;EACDxsD,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEqwD;AACN,CAAC,EAAE;EACDzpB,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEg0F;AACN,CAAC,EAAE;EACDptD,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAE8zD;AACN,CAAC,EAAE;EACDltB,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEq0F;AACN,CAAC,EAAE;EACDztD,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAEo1F;AACN,CAAC,EAAE;EACDxuD,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEy5D;AACN,CAAC,EAAE;EACD7yB,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEs5D;AACN,CAAC,EAAE;EACD1yB,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAE45D;AACN,CAAC,EAAE;EACDhzB,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEm9F;AACN,CAAC,EAAE;EACDv2D,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAE6tD;AACN,CAAC,EAAE;EACDjnB,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAE46F;AACN,CAAC,EAAE;EACDh0D,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEq/F;AACN,CAAC,EAAE;EACDz4D,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEq6F;AACN,CAAC,EAAE;EACDzzD,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAEs8F;AACN,CAAC,EAAE;EACD11D,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAE+zD;AACN,CAAC,EAAE;EACDntB,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEw/F;AACN,CAAC,EAAE;EACD54D,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAE++F;AACN,CAAC,EAAE;EACDn4D,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAEw6F;AACN,CAAC,EAAE;EACD5zD,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAE88F;AACN,CAAC,EAAE;EACDl2D,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEwwF;AACN,CAAC,EAAE;EACD5pD,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAE81D;AACN,CAAC,EAAE;EACDlvB,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAE69F;AACN,CAAC,EAAE;EACDj3D,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAEo+F;AACN,CAAC,EAAE;EACDx3D,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAE+/F;AACN,CAAC,EAAE;EACDn5D,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAEy9F;AACN,CAAC,EAAE;EACD72D,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAE8vF;AACN,CAAC,EAAE;EACDlpD,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAE+yD;AACN,CAAC,EAAE;EACDnsB,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEs6F;AACN,CAAC,EAAE;EACD1zD,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEkuD;AACN,CAAC,EAAE;EACDtnB,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAE+tD;AACN,CAAC,EAAE;EACDnnB,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEu9F;AACN,CAAC,EAAE;EACD32D,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAE86F;AACN,CAAC,EAAE;EACDl0D,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAE+7F;AACN,CAAC,EAAE;EACDn1D,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEs3D;AACN,CAAC,EAAE;EACD1wB,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAE4tF;AACN,CAAC,EAAE;EACDhnD,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEs6D;AACN,CAAC,EAAE;EACD1zB,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAEwxD;AACN,CAAC,EAAE;EACD5qB,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEo6F;AACN,CAAC,EAAE;EACDxzD,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAEy/F;AACN,CAAC,EAAE;EACD74D,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEk5D;AACN,CAAC,EAAE;EACDtyB,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAEwxF;AACN,CAAC,EAAE;EACD5qD,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAE06F;AACN,CAAC,EAAE;EACD9zD,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEiyF;AACN,CAAC,EAAE;EACDrrD,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEuyF;AACN,CAAC,EAAE;EACD3rD,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEy1D;AACN,CAAC,EAAE;EACD7uB,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAEwY;AACN,CAAC,EAAE;EACDouB,IAAI,EAAEykB,kBAAkB,CAACkB,IAAI;EAC7BvsD,EAAE,EAAE0yF;AACN,CAAC,EAAE;EACD9rD,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAE60F;AACN,CAAC,EAAE;EACDjuD,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAE+4F;AACN,CAAC,EAAE;EACDnyD,IAAI,EAAEykB,kBAAkB,CAACM,IAAI;EAC7B3rD,EAAE,EAAE+vD;AACN,CAAC,CAAC;AACF,SAASxR,SAASA,CAACiP,GAAG,EAAE5mB,IAAI,EAAE;EAC5B,KAAK,MAAMpX,KAAK,IAAI0yE,MAAM,EAAE;IAC1B,IAAI1yE,KAAK,CAACoX,IAAI,KAAKA,IAAI,IAAIpX,KAAK,CAACoX,IAAI,KAAKykB,kBAAkB,CAACM,IAAI,EAAE;MACjEn8B,KAAK,CAACxvB,EAAE,CAACwtD,GAAG,CAAC;IACf;EACF;AACF;AACA,SAAS20C,cAAcA,CAACC,GAAG,EAAE52C,IAAI,EAAE;EACjC,MAAM62C,MAAM,GAAGC,QAAQ,CAACF,GAAG,CAACl4C,IAAI,CAAC;EACjCq4C,cAAc,CAACH,GAAG,CAACl4C,IAAI,EAAEsB,IAAI,CAAC;EAC9B,OAAO62C,MAAM;AACf;AACA,SAASE,cAAcA,CAAC51C,MAAM,EAAEnB,IAAI,EAAE;EACpC,KAAK,MAAMz9B,IAAI,IAAI4+B,MAAM,CAACa,GAAG,CAACZ,KAAK,EAAE;IACnC,IAAI7+B,IAAI,CAAC4+B,MAAM,KAAKA,MAAM,CAACxS,IAAI,EAAE;MAC/B;IACF;IACAooD,cAAc,CAACx0E,IAAI,EAAEy9B,IAAI,CAAC;IAC1B,MAAMg3C,MAAM,GAAGF,QAAQ,CAACv0E,IAAI,CAAC;IAC7By9B,IAAI,CAAClnD,UAAU,CAAChZ,IAAI,CAACk3G,MAAM,CAAC/9F,UAAU,CAAC+9F,MAAM,CAACr1G,IAAI,CAAC,CAAC;EACtD;AACF;AACA,SAASm1G,QAAQA,CAACxrG,IAAI,EAAE;EACtB,IAAIA,IAAI,CAACu2D,MAAM,KAAK,IAAI,EAAE;IACxB,MAAM,IAAIxhE,KAAK,CAAC,wBAAwBiL,IAAI,CAACqjD,IAAI,aAAa,CAAC;EACjE;EACA,MAAMsoD,gBAAgB,GAAG,EAAE;EAC3B,KAAK,MAAMh9F,EAAE,IAAI3O,IAAI,CAACq2D,MAAM,EAAE;IAC5B,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC7wC,SAAS,EAAE;MAChC,MAAM,IAAI5b,KAAK,CAAC,0EAA0EysD,MAAM,CAAC7yC,EAAE,CAACmhC,IAAI,CAAC,EAAE,CAAC;IAC9G;IACA67D,gBAAgB,CAACn3G,IAAI,CAACma,EAAE,CAACmkC,SAAS,CAAC;EACrC;EACA,MAAM84D,gBAAgB,GAAG,EAAE;EAC3B,KAAK,MAAMj9F,EAAE,IAAI3O,IAAI,CAACs2D,MAAM,EAAE;IAC5B,IAAI3nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC7wC,SAAS,EAAE;MAChC,MAAM,IAAI5b,KAAK,CAAC,0EAA0EysD,MAAM,CAAC7yC,EAAE,CAACmhC,IAAI,CAAC,EAAE,CAAC;IAC9G;IACA87D,gBAAgB,CAACp3G,IAAI,CAACma,EAAE,CAACmkC,SAAS,CAAC;EACrC;EACA,MAAM+4D,UAAU,GAAGC,oBAAoB,CAAC,CAAC,EAAEH,gBAAgB,CAAC;EAC5D,MAAMI,UAAU,GAAGD,oBAAoB,CAAC,CAAC,EAAEF,gBAAgB,CAAC;EAC5D,OAAO1iG,EAAE,CAAC,CAAC,IAAImE,OAAO,CAAC,IAAI,CAAC,EAAE,IAAIA,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,GAAGw+F,UAAU,EAAE,GAAGE,UAAU,CAAC,EAAE3nF,SAAS,EAAEA,SAAS,EAAEpkB,IAAI,CAACu2D,MAAM,CAAC;AACvH;AACA,SAASu1C,oBAAoBA,CAACnE,IAAI,EAAEn6F,UAAU,EAAE;EAC9C,IAAIA,UAAU,CAACjZ,MAAM,KAAK,CAAC,EAAE;IAC3B,OAAO,EAAE;EACX;EACA,OAAO,CAACse,MAAM,CAAC,IAAInN,kBAAkB,CAAC5B,cAAc,CAACqD,UAAU,EAAE6K,QAAQ,CAAC,IAAI,CAAC,EAAEiB,OAAO,CAAC00F,IAAI,CAAC,CAAC,EAAEn6F,UAAU,CAAC,CAAC;AAC/G;AACA,SAASw+F,uBAAuBA,CAACt1C,GAAG,EAAE;EACpC,IAAIA,GAAG,CAACtD,IAAI,CAACmD,MAAM,KAAK,IAAI,EAAE;IAC5B,MAAM,IAAIxhE,KAAK,CAAC,kDAAkD,CAAC;EACrE;EACA,MAAM42G,gBAAgB,GAAG,EAAE;EAC3B,KAAK,MAAMh9F,EAAE,IAAI+nD,GAAG,CAACtD,IAAI,CAACiD,MAAM,EAAE;IAChC,IAAI1nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC7wC,SAAS,EAAE;MAChC,MAAM,IAAI5b,KAAK,CAAC,0EAA0EysD,MAAM,CAAC7yC,EAAE,CAACmhC,IAAI,CAAC,EAAE,CAAC;IAC9G;IACA67D,gBAAgB,CAACn3G,IAAI,CAACma,EAAE,CAACmkC,SAAS,CAAC;EACrC;EACA,MAAM84D,gBAAgB,GAAG,EAAE;EAC3B,KAAK,MAAMj9F,EAAE,IAAI+nD,GAAG,CAACtD,IAAI,CAACkD,MAAM,EAAE;IAChC,IAAI3nD,EAAE,CAACmhC,IAAI,KAAK0R,MAAM,CAAC7wC,SAAS,EAAE;MAChC,MAAM,IAAI5b,KAAK,CAAC,0EAA0EysD,MAAM,CAAC7yC,EAAE,CAACmhC,IAAI,CAAC,EAAE,CAAC;IAC9G;IACA87D,gBAAgB,CAACp3G,IAAI,CAACma,EAAE,CAACmkC,SAAS,CAAC;EACrC;EACA,IAAI64D,gBAAgB,CAACp3G,MAAM,KAAK,CAAC,IAAIq3G,gBAAgB,CAACr3G,MAAM,KAAK,CAAC,EAAE;IAClE,OAAO,IAAI;EACb;EACA,MAAMs3G,UAAU,GAAGC,oBAAoB,CAAC,CAAC,EAAEH,gBAAgB,CAAC;EAC5D,MAAMI,UAAU,GAAGD,oBAAoB,CAAC,CAAC,EAAEF,gBAAgB,CAAC;EAC5D,OAAO1iG,EAAE,CAAC,CAAC,IAAImE,OAAO,CAAC,IAAI,CAAC,EAAE,IAAIA,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,GAAGw+F,UAAU,EAAE,GAAGE,UAAU,CAAC,EAAE3nF,SAAS,EAAEA,SAAS,EAAEsyC,GAAG,CAACtD,IAAI,CAACmD,MAAM,CAAC;AAC3H;AAEA,MAAM01C,iBAAiB,GAAGrqD,iBAAiB,CAACsW,yBAAyB;AACrE,MAAMg0C,SAAS,GAAG,IAAItgB,wBAAwB,CAAC,CAAC;AAChD,MAAMugB,oBAAoB,GAAG,aAAa;AAC1C,MAAMC,gBAAgB,GAAG,UAAU;AACnC,SAASC,cAAcA,CAACx+E,IAAI,EAAE;EAC5B,OAAOA,IAAI,YAAYiS,OAAO;AAChC;AACA,SAASwsE,eAAeA,CAACz+E,IAAI,EAAE;EAC7B,OAAOw+E,cAAc,CAACx+E,IAAI,CAAC,IAAIA,IAAI,CAAChyB,KAAK,CAACtH,MAAM,KAAK,CAAC,IAAIs5B,IAAI,CAAChyB,KAAK,CAAC,CAAC,CAAC,YAAYgjC,GAAG;AACxF;AACA,SAAS0tE,eAAeA,CAACzuE,aAAa,EAAEt0B,QAAQ,EAAEgjG,YAAY,EAAEC,eAAe,EAAEx3C,uBAAuB,EAAEC,kBAAkB,EAAEC,SAAS,EAAEC,mBAAmB,EAAEC,oBAAoB,EAAEC,oBAAoB,EAAE;EACxM,MAAMoB,GAAG,GAAG,IAAI1B,uBAAuB,CAACl3B,aAAa,EAAE0uE,YAAY,EAAEP,iBAAiB,EAAEQ,eAAe,EAAEx3C,uBAAuB,EAAEC,kBAAkB,EAAEC,SAAS,EAAEC,mBAAmB,EAAEC,oBAAoB,EAAEC,oBAAoB,CAAC;EACjOo3C,WAAW,CAACh2C,GAAG,CAACtD,IAAI,EAAE5pD,QAAQ,CAAC;EAC/B,OAAOktD,GAAG;AACZ;AACA,SAASi2C,iBAAiBA,CAACppF,KAAK,EAAEqpF,aAAa,EAAEJ,YAAY,EAAE;EAC7D,MAAM91C,GAAG,GAAG,IAAIE,yBAAyB,CAACrzC,KAAK,CAACua,aAAa,EAAE0uE,YAAY,EAAEP,iBAAiB,EAAEz3C,uBAAuB,CAACoE,OAAO,CAAC;EAChI,KAAK,MAAM77C,QAAQ,IAAIwG,KAAK,CAAC4oE,UAAU,IAAI,EAAE,EAAE;IAC7C,IAAIhoC,WAAW,GAAGtC,WAAW,CAACrZ,QAAQ;IACtC,IAAIzrB,QAAQ,CAAC1mB,IAAI,CAACsvB,UAAU,CAAC,OAAO,CAAC,EAAE;MACrC5I,QAAQ,CAAC1mB,IAAI,GAAG0mB,QAAQ,CAAC1mB,IAAI,CAAC+3C,SAAS,CAAC,OAAO,CAAC75C,MAAM,CAAC;MACvD4vD,WAAW,GAAGtC,WAAW,CAACsD,SAAS;IACrC;IACA,IAAIpoC,QAAQ,CAACoZ,iBAAiB,EAAE;MAC9BguB,WAAW,GAAGtC,WAAW,CAAC/oB,eAAe;IAC3C;IACA,IAAI/b,QAAQ,CAACqZ,WAAW,EAAE;MACxB+tB,WAAW,GAAGtC,WAAW,CAACgJ,SAAS;IACrC;IACA,MAAMgiD,gBAAgB,GAAGD,aAAa,CAACE,4BAA4B,CAACvpF,KAAK,CAACwpF,iBAAiB,EAAEhwF,QAAQ,CAAC1mB,IAAI,EAAE8tD,WAAW,KAAKtC,WAAW,CAACsD,SAAS,CAAC,CAACjvC,MAAM,CAACxZ,OAAO,IAAIA,OAAO,KAAKtC,eAAe,CAACi+D,IAAI,CAAC;IACtM20C,iBAAiB,CAACt2C,GAAG,EAAE35C,QAAQ,EAAEonC,WAAW,EAAE0oD,gBAAgB,CAAC;EACjE;EACA,KAAK,MAAM,CAACx2G,IAAI,EAAEsS,IAAI,CAAC,IAAI5N,MAAM,CAACyU,OAAO,CAAC+T,KAAK,CAAC2V,UAAU,CAAC,IAAI,EAAE,EAAE;IACjE,MAAM2zE,gBAAgB,GAAGD,aAAa,CAACE,4BAA4B,CAACvpF,KAAK,CAACwpF,iBAAiB,EAAE12G,IAAI,EAAE,IAAI,CAAC,CAAC6f,MAAM,CAACxZ,OAAO,IAAIA,OAAO,KAAKtC,eAAe,CAACi+D,IAAI,CAAC;IAC5J40C,mBAAmB,CAACv2C,GAAG,EAAErgE,IAAI,EAAEsS,IAAI,EAAEkkG,gBAAgB,CAAC;EACxD;EACA,KAAK,MAAMj0E,KAAK,IAAIrV,KAAK,CAACyoE,MAAM,IAAI,EAAE,EAAE;IACtCkhB,eAAe,CAACx2C,GAAG,EAAE99B,KAAK,CAAC;EAC7B;EACA,OAAO89B,GAAG;AACZ;AACA,SAASs2C,iBAAiBA,CAACt2C,GAAG,EAAE35C,QAAQ,EAAEonC,WAAW,EAAE0oD,gBAAgB,EAAE;EACvE,IAAIxvG,UAAU;EACd,MAAMqU,GAAG,GAAGqL,QAAQ,CAAC1f,UAAU,CAACqU,GAAG;EACnC,IAAIA,GAAG,YAAYshB,eAAe,EAAE;IAClC31B,UAAU,GAAG,IAAI41B,aAAa,CAACvhB,GAAG,CAACwhB,OAAO,EAAExhB,GAAG,CAACtH,WAAW,CAAC1R,GAAG,CAACiQ,IAAI,IAAIwkG,UAAU,CAACxkG,IAAI,EAAE+tD,GAAG,EAAE35C,QAAQ,CAACtY,UAAU,CAAC,CAAC,EAAE,EAAE,CAAC;EAC1H,CAAC,MAAM;IACLpH,UAAU,GAAG8vG,UAAU,CAACz7F,GAAG,EAAEglD,GAAG,EAAE35C,QAAQ,CAACtY,UAAU,CAAC;EACxD;EACAiyD,GAAG,CAACtD,IAAI,CAACkD,MAAM,CAAC9hE,IAAI,CAACqvD,eAAe,CAAC6S,GAAG,CAACtD,IAAI,CAAC/P,IAAI,EAAEc,WAAW,EAAEpnC,QAAQ,CAAC1mB,IAAI,EAAEgH,UAAU,EAAE,IAAI,EAAEwvG,gBAAgB,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE9vF,QAAQ,CAACtY,UAAU,CAAC,CAAC;AACrK;AACA,SAASwoG,mBAAmBA,CAACv2C,GAAG,EAAErgE,IAAI,EAAEC,KAAK,EAAEu2G,gBAAgB,EAAE;EAC/D,MAAMO,WAAW,GAAGvpD,eAAe,CAAC6S,GAAG,CAACtD,IAAI,CAAC/P,IAAI,EAAExB,WAAW,CAACsD,SAAS,EAAE9uD,IAAI,EAAEC,KAAK,EAAE,IAAI,EAAEu2G,gBAAgB,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAEv2G,KAAK,CAACmO,UAAU,CAAC;EACzJiyD,GAAG,CAACtD,IAAI,CAACkD,MAAM,CAAC9hE,IAAI,CAAC44G,WAAW,CAAC;AACnC;AACA,SAASF,eAAeA,CAACx2C,GAAG,EAAE99B,KAAK,EAAE;EACnC,IAAIy0E,YAAY;EAChB,IAAIz0E,KAAK,CAACt7B,IAAI,KAAKm5B,eAAe,CAACo0B,SAAS,EAAE;IAC5CwiD,YAAY,GAAGj8C,yBAAyB,CAACsF,GAAG,CAACtD,IAAI,CAAC/P,IAAI,EAAE,IAAI0L,UAAU,CAAC,CAAC,EAAEn2B,KAAK,CAACviC,IAAI,EAAE,IAAI,EAAEi3G,sBAAsB,CAAC52C,GAAG,CAACtD,IAAI,EAAEx6B,KAAK,CAAC3M,OAAO,EAAE2M,KAAK,CAAChC,WAAW,CAAC,EAAEgC,KAAK,CAACviC,IAAI,CAAC0tE,QAAQ,CAAC,OAAO,CAAC,GAAG,OAAO,GAAG,OAAO,EAAEnrC,KAAK,CAACjC,aAAa,EAAE,IAAI,EAAEiC,KAAK,CAACn0B,UAAU,CAAC;EAChQ,CAAC,MAAM;IACL,MAAM,CAACi0B,KAAK,EAAErK,MAAM,CAAC,GAAGuK,KAAK,CAACt7B,IAAI,KAAKm5B,eAAe,CAACqC,eAAe,GAAG,CAAC,IAAI,EAAEF,KAAK,CAACjC,aAAa,CAAC,GAAG,CAACiC,KAAK,CAACjC,aAAa,EAAE,IAAI,CAAC;IAClI02E,YAAY,GAAGx8C,gBAAgB,CAAC6F,GAAG,CAACtD,IAAI,CAAC/P,IAAI,EAAE,IAAI0L,UAAU,CAAC,CAAC,EAAEn2B,KAAK,CAACviC,IAAI,EAAE,IAAI,EAAEi3G,sBAAsB,CAAC52C,GAAG,CAACtD,IAAI,EAAEx6B,KAAK,CAAC3M,OAAO,EAAE2M,KAAK,CAAChC,WAAW,CAAC,EAAE8B,KAAK,EAAErK,MAAM,EAAE,IAAI,EAAEuK,KAAK,CAACn0B,UAAU,CAAC;EAC/L;EACAiyD,GAAG,CAACtD,IAAI,CAACiD,MAAM,CAAC7hE,IAAI,CAAC64G,YAAY,CAAC;AACpC;AACA,SAASX,WAAWA,CAACz1E,IAAI,EAAEztB,QAAQ,EAAE;EACnC,KAAK,MAAMR,IAAI,IAAIQ,QAAQ,EAAE;IAC3B,IAAIR,IAAI,YAAYgwB,SAAS,EAAE;MAC7Bu0E,aAAa,CAACt2E,IAAI,EAAEjuB,IAAI,CAAC;IAC3B,CAAC,MAAM,IAAIA,IAAI,YAAYk1B,QAAQ,EAAE;MACnCsvE,cAAc,CAACv2E,IAAI,EAAEjuB,IAAI,CAAC;IAC5B,CAAC,MAAM,IAAIA,IAAI,YAAYs1B,OAAO,EAAE;MAClCmvE,aAAa,CAACx2E,IAAI,EAAEjuB,IAAI,CAAC;IAC3B,CAAC,MAAM,IAAIA,IAAI,YAAYgvB,MAAM,EAAE;MACjC01E,UAAU,CAACz2E,IAAI,EAAEjuB,IAAI,EAAE,IAAI,CAAC;IAC9B,CAAC,MAAM,IAAIA,IAAI,YAAYkvB,SAAS,EAAE;MACpCy1E,eAAe,CAAC12E,IAAI,EAAEjuB,IAAI,EAAE,IAAI,CAAC;IACnC,CAAC,MAAM,IAAIA,IAAI,YAAYk0B,OAAO,EAAE;MAClC0wE,aAAa,CAAC32E,IAAI,EAAEjuB,IAAI,CAAC;IAC3B,CAAC,MAAM,IAAIA,IAAI,YAAYozB,WAAW,EAAE;MACtCyxE,iBAAiB,CAAC52E,IAAI,EAAEjuB,IAAI,CAAC;IAC/B,CAAC,MAAM,IAAIA,IAAI,YAAYqyB,aAAa,EAAE;MACxCyyE,gBAAgB,CAAC72E,IAAI,EAAEjuB,IAAI,CAAC;IAC9B,CAAC,MAAM,IAAIA,IAAI,YAAY41B,KAAK,EAAE;MAChCmvE,SAAS,CAAC92E,IAAI,EAAEjuB,IAAI,CAAC;IACvB,CAAC,MAAM,IAAIA,IAAI,YAAYyzB,YAAY,EAAE;MACvCuxE,cAAc,CAAC/2E,IAAI,EAAEjuB,IAAI,CAAC;IAC5B,CAAC,MAAM,IAAIA,IAAI,YAAY00B,gBAAgB,EAAE;MAC3CuwE,oBAAoB,CAACh3E,IAAI,EAAEjuB,IAAI,CAAC;IAClC,CAAC,MAAM,IAAIA,IAAI,YAAY60B,WAAW,EAAE,CAAC,KAAM;MAC7C,MAAM,IAAI9oC,KAAK,CAAC,8BAA8BiU,IAAI,CAAC3P,WAAW,CAAChD,IAAI,EAAE,CAAC;IACxE;EACF;AACF;AACA,SAASk3G,aAAaA,CAACt2E,IAAI,EAAEpjC,OAAO,EAAE;EACpC,IAAIA,OAAO,CAACypB,IAAI,KAAK8G,SAAS,IAAI,EAAEvwB,OAAO,CAACypB,IAAI,YAAYwiB,OAAO,IAAIjsC,OAAO,CAACypB,IAAI,YAAYmjB,cAAc,CAAC,EAAE;IAC9G,MAAM1rC,KAAK,CAAC,6CAA6ClB,OAAO,CAACypB,IAAI,CAACjkB,WAAW,CAAChD,IAAI,EAAE,CAAC;EAC3F;EACA,MAAMoF,EAAE,GAAGw7B,IAAI,CAACy/B,GAAG,CAAC5B,cAAc,CAAC,CAAC;EACpC,MAAM,CAACo5C,YAAY,EAAE1zG,WAAW,CAAC,GAAG28B,WAAW,CAACtjC,OAAO,CAACwC,IAAI,CAAC;EAC7D,MAAMiuG,OAAO,GAAGp1C,oBAAoB,CAAC10D,WAAW,EAAEiB,EAAE,EAAEw+D,eAAe,CAACi0C,YAAY,CAAC,EAAEr6G,OAAO,CAACypB,IAAI,YAAYmjB,cAAc,GAAG5sC,OAAO,CAACypB,IAAI,GAAG8G,SAAS,EAAEvwB,OAAO,CAAC2lC,eAAe,EAAE3lC,OAAO,CAAC4Q,UAAU,CAAC;EACpMwyB,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAAC8vG,OAAO,CAAC;EACzB6J,qBAAqB,CAACl3E,IAAI,EAAEqtE,OAAO,EAAEzwG,OAAO,CAAC;EAC7Cu6G,gBAAgB,CAAC9J,OAAO,EAAEzwG,OAAO,CAAC;EAClC,IAAIw6G,WAAW,GAAG,IAAI;EACtB,IAAIx6G,OAAO,CAACypB,IAAI,YAAYwiB,OAAO,EAAE;IACnCuuE,WAAW,GAAGp3E,IAAI,CAACy/B,GAAG,CAAC5B,cAAc,CAAC,CAAC;IACvC79B,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAAC2+D,iBAAiB,CAACk7C,WAAW,EAAEx6G,OAAO,CAACypB,IAAI,EAAE8G,SAAS,EAAEvwB,OAAO,CAAC2lC,eAAe,CAAC,CAAC;EACpG;EACAkzE,WAAW,CAACz1E,IAAI,EAAEpjC,OAAO,CAACgJ,QAAQ,CAAC;EACnC,MAAMyxG,KAAK,GAAGl+C,kBAAkB,CAAC30D,EAAE,EAAE5H,OAAO,CAAC4lC,aAAa,IAAI5lC,OAAO,CAAC2lC,eAAe,CAAC;EACtFvC,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAAC85G,KAAK,CAAC;EACvB,IAAID,WAAW,KAAK,IAAI,EAAE;IACxB/gD,MAAM,CAACsB,YAAY,CAAC2E,eAAe,CAAC86C,WAAW,EAAEx6G,OAAO,CAAC4lC,aAAa,IAAI5lC,OAAO,CAAC2lC,eAAe,CAAC,EAAE80E,KAAK,CAAC;EAC5G;AACF;AACA,SAASd,cAAcA,CAACv2E,IAAI,EAAEs3E,IAAI,EAAE;EAClC,IAAIA,IAAI,CAACjxF,IAAI,KAAK8G,SAAS,IAAI,EAAEmqF,IAAI,CAACjxF,IAAI,YAAYwiB,OAAO,IAAIyuE,IAAI,CAACjxF,IAAI,YAAYmjB,cAAc,CAAC,EAAE;IACrG,MAAM1rC,KAAK,CAAC,8CAA8Cw5G,IAAI,CAACjxF,IAAI,CAACjkB,WAAW,CAAChD,IAAI,EAAE,CAAC;EACzF;EACA,MAAMykG,SAAS,GAAG7jE,IAAI,CAACy/B,GAAG,CAACd,YAAY,CAAC3+B,IAAI,CAACosB,IAAI,CAAC;EAClD,IAAImrD,uBAAuB,GAAGD,IAAI,CAAC/6F,OAAO;EAC1C,IAAIi7F,eAAe,GAAG,EAAE;EACxB,IAAIF,IAAI,CAAC/6F,OAAO,EAAE;IAChB,CAACi7F,eAAe,EAAED,uBAAuB,CAAC,GAAGr3E,WAAW,CAACo3E,IAAI,CAAC/6F,OAAO,CAAC;EACxE;EACA,MAAMgzC,eAAe,GAAG+nD,IAAI,CAACjxF,IAAI,YAAYmjB,cAAc,GAAG8tE,IAAI,CAACjxF,IAAI,GAAG8G,SAAS;EACnF,MAAM8gC,SAAS,GAAG+U,eAAe,CAACw0C,eAAe,CAAC;EAClD,MAAMl/C,kBAAkB,GAAGi/C,uBAAuB,KAAK,IAAI,GAAG,EAAE,GAAGj0C,mBAAmB,CAACi0C,uBAAuB,EAAEtpD,SAAS,CAAC;EAC1H,MAAMlB,YAAY,GAAG0qD,eAAe,CAACH,IAAI,CAAC,GAAGnsD,YAAY,CAACusD,UAAU,GAAGvsD,YAAY,CAACk4C,UAAU;EAC9F,MAAMsU,UAAU,GAAGt/C,gBAAgB,CAACwrC,SAAS,CAACz3C,IAAI,EAAEW,YAAY,EAAEwqD,uBAAuB,EAAEj/C,kBAAkB,EAAErK,SAAS,EAAEsB,eAAe,EAAE+nD,IAAI,CAAC/0E,eAAe,EAAE+0E,IAAI,CAAC9pG,UAAU,CAAC;EACjLwyB,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAACo6G,UAAU,CAAC;EAC5BC,sBAAsB,CAAC53E,IAAI,EAAE23E,UAAU,EAAEL,IAAI,EAAEvqD,YAAY,CAAC;EAC5DoqD,gBAAgB,CAACQ,UAAU,EAAEL,IAAI,CAAC;EAClC7B,WAAW,CAAC5R,SAAS,EAAEyT,IAAI,CAAC1xG,QAAQ,CAAC;EACrC,KAAK,MAAM;IACTxG,IAAI;IACJC;EACF,CAAC,IAAIi4G,IAAI,CAACnwE,SAAS,EAAE;IACnB08D,SAAS,CAACj+D,gBAAgB,CAACtkC,GAAG,CAAClC,IAAI,EAAEC,KAAK,KAAK,EAAE,GAAGA,KAAK,GAAG,WAAW,CAAC;EAC1E;EACA,IAAI0tD,YAAY,KAAK5B,YAAY,CAACusD,UAAU,IAAIJ,IAAI,CAACjxF,IAAI,YAAYwiB,OAAO,EAAE;IAC5E,MAAMrkC,EAAE,GAAGw7B,IAAI,CAACy/B,GAAG,CAAC5B,cAAc,CAAC,CAAC;IACpCxH,MAAM,CAACuB,WAAW,CAACsE,iBAAiB,CAAC13D,EAAE,EAAE8yG,IAAI,CAACjxF,IAAI,EAAE8G,SAAS,EAAEmqF,IAAI,CAAC/0E,eAAe,CAAC,EAAEshE,SAAS,CAACzkC,MAAM,CAACxqC,IAAI,CAAC;IAC5GyhC,MAAM,CAACsB,YAAY,CAAC2E,eAAe,CAAC93D,EAAE,EAAE8yG,IAAI,CAAC90E,aAAa,IAAI80E,IAAI,CAAC/0E,eAAe,CAAC,EAAEshE,SAAS,CAACzkC,MAAM,CAAC5I,IAAI,CAAC;EAC7G;AACF;AACA,SAASggD,aAAaA,CAACx2E,IAAI,EAAE3Q,OAAO,EAAE;EACpC,IAAIA,OAAO,CAAChJ,IAAI,KAAK8G,SAAS,IAAI,EAAEkC,OAAO,CAAChJ,IAAI,YAAYmjB,cAAc,CAAC,EAAE;IAC3E,MAAM1rC,KAAK,CAAC,6CAA6CuxB,OAAO,CAAChJ,IAAI,CAACjkB,WAAW,CAAChD,IAAI,EAAE,CAAC;EAC3F;EACA,IAAIs7D,YAAY,GAAG,IAAI;EACvB,IAAIrrC,OAAO,CAACzpB,QAAQ,CAACmpC,IAAI,CAAClpC,KAAK,IAAI,EAAEA,KAAK,YAAY+6B,SAAS,CAAC,KAAK,EAAE/6B,KAAK,YAAYk7B,MAAM,CAAC,IAAIl7B,KAAK,CAACxG,KAAK,CAAC2tB,IAAI,CAAC,CAAC,CAAC1vB,MAAM,GAAG,CAAC,CAAC,CAAC,EAAE;IAClIo9D,YAAY,GAAG16B,IAAI,CAACy/B,GAAG,CAACd,YAAY,CAAC3+B,IAAI,CAACosB,IAAI,CAAC;IAC/CqpD,WAAW,CAAC/6C,YAAY,EAAErrC,OAAO,CAACzpB,QAAQ,CAAC;EAC7C;EACA,MAAMpB,EAAE,GAAGw7B,IAAI,CAACy/B,GAAG,CAAC5B,cAAc,CAAC,CAAC;EACpC,MAAMnmD,EAAE,GAAG+iD,kBAAkB,CAACj2D,EAAE,EAAE6qB,OAAO,CAACpyB,QAAQ,EAAEoyB,OAAO,CAAChJ,IAAI,EAAEq0C,YAAY,EAAEtO,IAAI,IAAI,IAAI,EAAE/8B,OAAO,CAAC7hB,UAAU,CAAC;EACjH,KAAK,MAAMjP,IAAI,IAAI8wB,OAAO,CAAC4S,UAAU,EAAE;IACrC,MAAMlC,eAAe,GAAGk1E,SAAS,CAACl1E,eAAe,CAAC1Q,OAAO,CAACjwB,IAAI,EAAEb,IAAI,CAACa,IAAI,EAAE,IAAI,CAAC;IAChF4gC,IAAI,CAACq/B,MAAM,CAAC9hE,IAAI,CAACqvD,eAAe,CAACl1C,EAAE,CAAC00C,IAAI,EAAExB,WAAW,CAACsD,SAAS,EAAE3vD,IAAI,CAACa,IAAI,EAAE4c,OAAO,CAACzd,IAAI,CAACc,KAAK,CAAC,EAAE,IAAI,EAAE0gC,eAAe,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE83E,SAAS,CAACt5G,IAAI,CAAC8nB,IAAI,CAAC,EAAE9nB,IAAI,CAACiP,UAAU,CAAC,CAAC;EACpL;EACAwyB,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAACma,EAAE,CAAC;AACtB;AACA,SAAS++F,UAAUA,CAACz2E,IAAI,EAAEx6B,IAAI,EAAE8pD,cAAc,EAAE;EAC9CtvB,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAAC+7D,YAAY,CAACt5B,IAAI,CAACy/B,GAAG,CAAC5B,cAAc,CAAC,CAAC,EAAEr4D,IAAI,CAACnG,KAAK,EAAEiwD,cAAc,EAAE9pD,IAAI,CAACgI,UAAU,CAAC,CAAC;AACxG;AACA,SAASkpG,eAAeA,CAAC12E,IAAI,EAAEx6B,IAAI,EAAE8pD,cAAc,EAAE;EACnD,IAAIjwD,KAAK,GAAGmG,IAAI,CAACnG,KAAK;EACtB,IAAIA,KAAK,YAAYi/B,aAAa,EAAE;IAClCj/B,KAAK,GAAGA,KAAK,CAACob,GAAG;EACnB;EACA,IAAI,EAAEpb,KAAK,YAAY08B,eAAe,CAAC,EAAE;IACvC,MAAM,IAAIj+B,KAAK,CAAC,kEAAkEuB,KAAK,CAAC+C,WAAW,CAAChD,IAAI,EAAE,CAAC;EAC7G;EACA,IAAIoG,IAAI,CAAC6gB,IAAI,KAAK8G,SAAS,IAAI,EAAE3nB,IAAI,CAAC6gB,IAAI,YAAYijB,SAAS,CAAC,EAAE;IAChE,MAAMxrC,KAAK,CAAC,wDAAwD0H,IAAI,CAAC6gB,IAAI,EAAEjkB,WAAW,CAAChD,IAAI,EAAE,CAAC;EACpG;EACA,MAAMutD,gBAAgB,GAAGnnD,IAAI,CAAC6gB,IAAI,YAAYijB,SAAS,GAAG9jC,IAAI,CAAC6gB,IAAI,CAACzgB,QAAQ,CAACqZ,MAAM,CAAClN,IAAI,IAAIA,IAAI,YAAY03B,WAAW,CAAC,CAAChoC,GAAG,CAACuT,WAAW,IAAIA,WAAW,CAAC5V,IAAI,CAAC,GAAG,EAAE;EAClK,IAAIutD,gBAAgB,CAACrvD,MAAM,GAAG,CAAC,IAAIqvD,gBAAgB,CAACrvD,MAAM,KAAK+B,KAAK,CAAC8T,WAAW,CAAC7V,MAAM,EAAE;IACvF,MAAMQ,KAAK,CAAC,2CAA2CuB,KAAK,CAAC8T,WAAW,CAAC7V,MAAM,wBAAwB+B,KAAK,CAAC8T,WAAW,CAAC7V,MAAM,cAAc,CAAC;EAChJ;EACA,MAAMw6G,QAAQ,GAAG93E,IAAI,CAACy/B,GAAG,CAAC5B,cAAc,CAAC,CAAC;EAC1C79B,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAAC+7D,YAAY,CAACw+C,QAAQ,EAAE,EAAE,EAAExoD,cAAc,EAAE9pD,IAAI,CAACgI,UAAU,CAAC,CAAC;EAC7E,MAAMuqG,cAAc,GAAG/3E,IAAI,CAACy/B,GAAG,CAAC/B,aAAa,GAAG,IAAI,GAAGl4D,IAAI,CAACgI,UAAU;EACtEwyB,IAAI,CAACq/B,MAAM,CAAC9hE,IAAI,CAACivD,uBAAuB,CAACsrD,QAAQ,EAAE,IAAI97E,aAAa,CAAC38B,KAAK,CAAC48B,OAAO,EAAE58B,KAAK,CAAC8T,WAAW,CAAC1R,GAAG,CAACiQ,IAAI,IAAIwkG,UAAU,CAACxkG,IAAI,EAAEsuB,IAAI,CAACy/B,GAAG,EAAEs4C,cAAc,CAAC,CAAC,EAAEprD,gBAAgB,CAAC,EAAEnnD,IAAI,CAACgI,UAAU,CAAC,CAAC;AACrM;AACA,SAASmpG,aAAaA,CAAC32E,IAAI,EAAEg4E,OAAO,EAAE;EACpC,IAAIC,SAAS,GAAG,IAAI;EACpB,IAAI3pD,UAAU,GAAG,EAAE;EACnB,KAAK,IAAI5vD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGs5G,OAAO,CAAC9xE,QAAQ,CAAC5oC,MAAM,EAAEoB,CAAC,EAAE,EAAE;IAChD,MAAMw5G,MAAM,GAAGF,OAAO,CAAC9xE,QAAQ,CAACxnC,CAAC,CAAC;IAClC,MAAMy5G,KAAK,GAAGn4E,IAAI,CAACy/B,GAAG,CAACd,YAAY,CAAC3+B,IAAI,CAACosB,IAAI,CAAC;IAC9C,MAAM7vC,OAAO,GAAG67F,+BAA+B,CAACp4E,IAAI,EAAEm4E,KAAK,CAAC/rD,IAAI,EAAE8rD,MAAM,CAAC;IACzE,IAAIA,MAAM,CAAC7xE,eAAe,KAAK,IAAI,EAAE;MACnC8xE,KAAK,CAACvyE,gBAAgB,CAACtkC,GAAG,CAAC42G,MAAM,CAAC7xE,eAAe,CAACjnC,IAAI,EAAEi+D,OAAO,CAAC;IAClE;IACA,IAAIg7C,cAAc,GAAGlrF,SAAS;IAC9B,IAAI+qF,MAAM,CAAC7xF,IAAI,KAAK8G,SAAS,EAAE;MAC7B,IAAI,EAAE+qF,MAAM,CAAC7xF,IAAI,YAAYujB,gBAAgB,CAAC,EAAE;QAC9C,MAAM9rC,KAAK,CAAC,8CAA8Co6G,MAAM,CAAC7xF,IAAI,EAAEjkB,WAAW,CAAChD,IAAI,EAAE,CAAC;MAC5F;MACAi5G,cAAc,GAAGH,MAAM,CAAC7xF,IAAI;IAC9B;IACA,MAAMk6C,QAAQ,GAAG7hE,CAAC,KAAK,CAAC,GAAG85D,yBAAyB,GAAGC,+BAA+B;IACtF,MAAM6/C,mBAAmB,GAAG/3C,QAAQ,CAAC43C,KAAK,CAAC/rD,IAAI,EAAEjB,YAAY,CAACojB,KAAK,EAAEhyD,OAAO,EAAE,aAAa,EAAEyuC,SAAS,CAACiO,IAAI,EAAEo/C,cAAc,EAAEH,MAAM,CAAC31E,eAAe,EAAE21E,MAAM,CAAC1qG,UAAU,CAAC;IACvKwyB,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAAC+6G,mBAAmB,CAAC;IACrC,IAAIL,SAAS,KAAK,IAAI,EAAE;MACtBA,SAAS,GAAGE,KAAK,CAAC/rD,IAAI;IACxB;IACA,MAAMmsD,QAAQ,GAAGL,MAAM,CAAC9xG,UAAU,GAAG8vG,UAAU,CAACgC,MAAM,CAAC9xG,UAAU,EAAE45B,IAAI,CAACy/B,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI;IACzF,MAAM+4C,mBAAmB,GAAG,IAAIvlD,mBAAmB,CAACslD,QAAQ,EAAED,mBAAmB,CAAClsD,IAAI,EAAEksD,mBAAmB,CAACjpD,MAAM,EAAE6oD,MAAM,CAAC7xE,eAAe,CAAC;IAC3IioB,UAAU,CAAC/wD,IAAI,CAACi7G,mBAAmB,CAAC;IACpC/C,WAAW,CAAC0C,KAAK,EAAED,MAAM,CAACtyG,QAAQ,CAAC;EACrC;EACAo6B,IAAI,CAACq/B,MAAM,CAAC9hE,IAAI,CAAC8wD,mBAAmB,CAAC4pD,SAAS,EAAE,IAAI,EAAE3pD,UAAU,EAAE0pD,OAAO,CAACxqG,UAAU,CAAC,CAAC;AACxF;AACA,SAASopG,iBAAiBA,CAAC52E,IAAI,EAAEy4E,WAAW,EAAE;EAC5C,IAAIA,WAAW,CAACvyG,KAAK,CAAC5I,MAAM,KAAK,CAAC,EAAE;IAClC;EACF;EACA,IAAI26G,SAAS,GAAG,IAAI;EACpB,IAAI3pD,UAAU,GAAG,EAAE;EACnB,KAAK,IAAI5vD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+5G,WAAW,CAACvyG,KAAK,CAAC5I,MAAM,EAAEoB,CAAC,EAAE,EAAE;IACjD,MAAMg6G,UAAU,GAAGD,WAAW,CAACvyG,KAAK,CAACxH,CAAC,CAAC;IACvC,MAAMy5G,KAAK,GAAGn4E,IAAI,CAACy/B,GAAG,CAACd,YAAY,CAAC3+B,IAAI,CAACosB,IAAI,CAAC;IAC9C,MAAM7vC,OAAO,GAAG67F,+BAA+B,CAACp4E,IAAI,EAAEm4E,KAAK,CAAC/rD,IAAI,EAAEssD,UAAU,CAAC;IAC7E,IAAIC,kBAAkB,GAAGxrF,SAAS;IAClC,IAAIurF,UAAU,CAACryF,IAAI,KAAK8G,SAAS,EAAE;MACjC,IAAI,EAAEurF,UAAU,CAACryF,IAAI,YAAYujB,gBAAgB,CAAC,EAAE;QAClD,MAAM9rC,KAAK,CAAC,kDAAkD46G,UAAU,CAACryF,IAAI,EAAEjkB,WAAW,CAAChD,IAAI,EAAE,CAAC;MACpG;MACAu5G,kBAAkB,GAAGD,UAAU,CAACryF,IAAI;IACtC;IACA,MAAMk6C,QAAQ,GAAG7hE,CAAC,KAAK,CAAC,GAAG85D,yBAAyB,GAAGC,+BAA+B;IACtF,MAAM6/C,mBAAmB,GAAG/3C,QAAQ,CAAC43C,KAAK,CAAC/rD,IAAI,EAAEjB,YAAY,CAACojB,KAAK,EAAEhyD,OAAO,EAAE,MAAM,EAAEyuC,SAAS,CAACiO,IAAI,EAAE0/C,kBAAkB,EAAED,UAAU,CAACn2E,eAAe,EAAEm2E,UAAU,CAAClrG,UAAU,CAAC;IAC5KwyB,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAAC+6G,mBAAmB,CAAC;IACrC,IAAIL,SAAS,KAAK,IAAI,EAAE;MACtBA,SAAS,GAAGE,KAAK,CAAC/rD,IAAI;IACxB;IACA,MAAMmsD,QAAQ,GAAGG,UAAU,CAACtyG,UAAU,GAAG8vG,UAAU,CAACwC,UAAU,CAACtyG,UAAU,EAAE45B,IAAI,CAACy/B,GAAG,EAAEg5C,WAAW,CAACl2E,eAAe,CAAC,GAAG,IAAI;IACxH,MAAMi2E,mBAAmB,GAAG,IAAIvlD,mBAAmB,CAACslD,QAAQ,EAAED,mBAAmB,CAAClsD,IAAI,EAAEksD,mBAAmB,CAACjpD,MAAM,CAAC;IACnHf,UAAU,CAAC/wD,IAAI,CAACi7G,mBAAmB,CAAC;IACpC/C,WAAW,CAAC0C,KAAK,EAAEO,UAAU,CAAC9yG,QAAQ,CAAC;EACzC;EACAo6B,IAAI,CAACq/B,MAAM,CAAC9hE,IAAI,CAAC8wD,mBAAmB,CAAC4pD,SAAS,EAAE/B,UAAU,CAACuC,WAAW,CAACryG,UAAU,EAAE45B,IAAI,CAACy/B,GAAG,EAAE,IAAI,CAAC,EAAEnR,UAAU,EAAEmqD,WAAW,CAACjrG,UAAU,CAAC,CAAC;AAC1I;AACA,SAASorG,eAAeA,CAAC54E,IAAI,EAAE+oB,MAAM,EAAE8vD,QAAQ,EAAEjzG,QAAQ,EAAE4H,UAAU,EAAE;EACrE,IAAIqrG,QAAQ,KAAK1rF,SAAS,IAAI,EAAE0rF,QAAQ,YAAYjvE,gBAAgB,CAAC,EAAE;IACrE,MAAM9rC,KAAK,CAAC,8CAA8C,CAAC;EAC7D;EACA,IAAI8H,QAAQ,KAAKunB,SAAS,EAAE;IAC1B,OAAO,IAAI;EACb;EACA,MAAM2rF,aAAa,GAAG94E,IAAI,CAACy/B,GAAG,CAACd,YAAY,CAAC3+B,IAAI,CAACosB,IAAI,CAAC;EACtDqpD,WAAW,CAACqD,aAAa,EAAElzG,QAAQ,CAAC;EACpC,MAAM+xG,UAAU,GAAGt/C,gBAAgB,CAACygD,aAAa,CAAC1sD,IAAI,EAAEjB,YAAY,CAACojB,KAAK,EAAE,IAAI,EAAE,QAAQxlB,MAAM,EAAE,EAAEiC,SAAS,CAACiO,IAAI,EAAE4/C,QAAQ,EAAErrG,UAAU,EAAEA,UAAU,CAAC;EACrJwyB,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAACo6G,UAAU,CAAC;EAC5B,OAAOA,UAAU;AACnB;AACA,SAASd,gBAAgBA,CAAC72E,IAAI,EAAE+4E,UAAU,EAAE;EAC1C,IAAI/9C,aAAa,GAAG,IAAI;EACxB,IAAIh7B,IAAI,CAACy/B,GAAG,CAACvB,SAAS,CAACP,IAAI,KAAK,CAAC,EAAE;IACjC,IAAI,CAAC39B,IAAI,CAACy/B,GAAG,CAACvB,SAAS,CAACjV,MAAM,CAACxmD,GAAG,CAACs2G,UAAU,CAAC,EAAE;MAC9C,MAAM,IAAIj7G,KAAK,CAAC,8EAA8E,CAAC;IACjG;IACAk9D,aAAa,GAAGh7B,IAAI,CAACy/B,GAAG,CAACvB,SAAS,CAACjV,MAAM,CAAC5nD,GAAG,CAAC03G,UAAU,CAAC,IAAI,IAAI;EACnE;EACA,MAAMj+C,IAAI,GAAG89C,eAAe,CAAC54E,IAAI,EAAE,EAAE,EAAE+4E,UAAU,CAAC1yF,IAAI,EAAE0yF,UAAU,CAACnzG,QAAQ,EAAEmzG,UAAU,CAACvrG,UAAU,CAAC;EACnG,MAAM62B,OAAO,GAAGu0E,eAAe,CAAC54E,IAAI,EAAE,SAAS,EAAE+4E,UAAU,CAAC10E,OAAO,EAAEhe,IAAI,EAAE0yF,UAAU,CAAC10E,OAAO,EAAEz+B,QAAQ,EAAEmzG,UAAU,CAAC10E,OAAO,EAAE72B,UAAU,CAAC;EACxI,MAAMwH,WAAW,GAAG4jG,eAAe,CAAC54E,IAAI,EAAE,aAAa,EAAE+4E,UAAU,CAAC/jG,WAAW,EAAEqR,IAAI,EAAE0yF,UAAU,CAAC/jG,WAAW,EAAEpP,QAAQ,EAAEmzG,UAAU,CAAC/jG,WAAW,EAAExH,UAAU,CAAC;EAC5J,MAAM82B,KAAK,GAAGs0E,eAAe,CAAC54E,IAAI,EAAE,OAAO,EAAE+4E,UAAU,CAACz0E,KAAK,EAAEje,IAAI,EAAE0yF,UAAU,CAACz0E,KAAK,EAAE1+B,QAAQ,EAAEmzG,UAAU,CAACz0E,KAAK,EAAE92B,UAAU,CAAC;EAC9H,MAAMwrG,SAAS,GAAGh5E,IAAI,CAACy/B,GAAG,CAAC5B,cAAc,CAAC,CAAC;EAC3C,MAAMyJ,OAAO,GAAGzM,aAAa,CAACm+C,SAAS,EAAEl+C,IAAI,CAAC1O,IAAI,EAAE0O,IAAI,CAACzL,MAAM,EAAE2L,aAAa,EAAEh7B,IAAI,CAACy/B,GAAG,CAACtB,mBAAmB,EAAE46C,UAAU,CAACvrG,UAAU,CAAC;EACpI85D,OAAO,CAAChM,eAAe,GAAGtmD,WAAW,EAAEo3C,IAAI,IAAI,IAAI;EACnDkb,OAAO,CAAC/L,eAAe,GAAGvmD,WAAW,EAAEq6C,MAAM,IAAI,IAAI;EACrDiY,OAAO,CAACnM,WAAW,GAAG92B,OAAO,EAAEgrB,MAAM,IAAI,IAAI;EAC7CiY,OAAO,CAAC5L,SAAS,GAAGp3B,KAAK,EAAE+qB,MAAM,IAAI,IAAI;EACzCiY,OAAO,CAAC9L,sBAAsB,GAAGu9C,UAAU,CAAC/jG,WAAW,EAAE6uB,WAAW,IAAI,IAAI;EAC5EyjC,OAAO,CAAClM,kBAAkB,GAAG29C,UAAU,CAAC10E,OAAO,EAAER,WAAW,IAAI,IAAI;EACpEyjC,OAAO,CAACjM,gBAAgB,GAAG09C,UAAU,CAAC10E,OAAO,EAAEL,SAAS,IAAI,IAAI;EAChEsjC,OAAO,CAACz0D,KAAK,GAAGomG,mBAAmB,CAACF,UAAU,CAAC;EAC/C/4E,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAAC+pE,OAAO,CAAC;EACzB,MAAM4xC,UAAU,GAAG,EAAE;EACrB,MAAMC,YAAY,GAAG,EAAE;EACvBC,mBAAmB,CAAC,SAAS,EAAEL,UAAU,CAACr0E,eAAe,EAAEw0E,UAAU,EAAEC,YAAY,EAAEn5E,IAAI,EAAEg5E,SAAS,CAAC;EACrGI,mBAAmB,CAAC,MAAM,EAAEL,UAAU,CAACv0E,QAAQ,EAAE00E,UAAU,EAAEC,YAAY,EAAEn5E,IAAI,EAAEg5E,SAAS,CAAC;EAC3FI,mBAAmB,CAAC,UAAU,EAAEL,UAAU,CAACt0E,gBAAgB,EAAEy0E,UAAU,EAAEC,YAAY,EAAEn5E,IAAI,EAAEg5E,SAAS,CAAC;EACvG,MAAMK,kBAAkB,GAAGH,UAAU,CAACnqE,IAAI,CAACr3B,EAAE,IAAIA,EAAE,CAAC5M,QAAQ,KAAK,MAAM,CAAC,IAAIquG,YAAY,CAACpqE,IAAI,CAACr3B,EAAE,IAAIA,EAAE,CAAC5M,QAAQ,KAAK,MAAM,CAAC;EAC3H,IAAI,CAACuuG,kBAAkB,EAAE;IACvBH,UAAU,CAAC37G,IAAI,CAACo+D,eAAe,CAACq9C,SAAS,EAAE;MACzCngE,IAAI,EAAEoS,gBAAgB,CAACub;IACzB,CAAC,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;EACnB;EACAxmC,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAAC27G,UAAU,CAAC;EAC5Bl5E,IAAI,CAACq/B,MAAM,CAAC9hE,IAAI,CAAC47G,YAAY,CAAC;AAChC;AACA,SAASF,mBAAmBA,CAACK,iBAAiB,EAAE;EAC9C,IAAIx1G,MAAM,CAACmC,IAAI,CAACqzG,iBAAiB,CAAC50E,eAAe,CAAC,CAACpnC,MAAM,GAAG,CAAC,EAAE;IAC7D,OAAO,CAAC;EACV;EACA,OAAO,IAAI;AACb;AACA,SAAS87G,mBAAmBA,CAACtuG,QAAQ,EAAE05B,QAAQ,EAAE+0E,KAAK,EAAEC,OAAO,EAAEx5E,IAAI,EAAEg5E,SAAS,EAAE;EAChF,IAAIx0E,QAAQ,CAACi1E,IAAI,KAAKtsF,SAAS,EAAE;IAC/B,MAAMusF,SAAS,GAAG/9C,eAAe,CAACq9C,SAAS,EAAE;MAC3CngE,IAAI,EAAEoS,gBAAgB,CAACub;IACzB,CAAC,EAAE17D,QAAQ,EAAE05B,QAAQ,CAACi1E,IAAI,CAACjsG,UAAU,CAAC;IACtC+rG,KAAK,CAACh8G,IAAI,CAACm8G,SAAS,CAAC;EACvB;EACA,IAAIl1E,QAAQ,CAACm1E,SAAS,KAAKxsF,SAAS,EAAE;IACpC,MAAMusF,SAAS,GAAG/9C,eAAe,CAACq9C,SAAS,EAAE;MAC3CngE,IAAI,EAAEoS,gBAAgB,CAACyb;IACzB,CAAC,EAAE57D,QAAQ,EAAE05B,QAAQ,CAACm1E,SAAS,CAACnsG,UAAU,CAAC;IAC3C+rG,KAAK,CAACh8G,IAAI,CAACm8G,SAAS,CAAC;EACvB;EACA,IAAIl1E,QAAQ,CAACo1E,KAAK,KAAKzsF,SAAS,EAAE;IAChC,MAAMusF,SAAS,GAAG/9C,eAAe,CAACq9C,SAAS,EAAE;MAC3CngE,IAAI,EAAEoS,gBAAgB,CAAC0b,KAAK;MAC5BpjC,KAAK,EAAEiB,QAAQ,CAACo1E,KAAK,CAACr2E;IACxB,CAAC,EAAEz4B,QAAQ,EAAE05B,QAAQ,CAACo1E,KAAK,CAACpsG,UAAU,CAAC;IACvC+rG,KAAK,CAACh8G,IAAI,CAACm8G,SAAS,CAAC;EACvB;EACA,IAAIl1E,QAAQ,CAACq1E,KAAK,KAAK1sF,SAAS,EAAE;IAChC,MAAMusF,SAAS,GAAG/9C,eAAe,CAACq9C,SAAS,EAAE;MAC3CngE,IAAI,EAAEoS,gBAAgB,CAAC2b,KAAK;MAC5BG,UAAU,EAAEviC,QAAQ,CAACq1E,KAAK,CAAC9yF,SAAS;MACpCkgD,UAAU,EAAE,IAAI;MAChBvY,UAAU,EAAE,IAAI;MAChBwY,UAAU,EAAE,IAAI;MAChBC,mBAAmB,EAAE;IACvB,CAAC,EAAEr8D,QAAQ,EAAE05B,QAAQ,CAACq1E,KAAK,CAACrsG,UAAU,CAAC;IACvC+rG,KAAK,CAACh8G,IAAI,CAACm8G,SAAS,CAAC;EACvB;EACA,IAAIl1E,QAAQ,CAACs1E,WAAW,KAAK3sF,SAAS,EAAE;IACtC,MAAMusF,SAAS,GAAG/9C,eAAe,CAACq9C,SAAS,EAAE;MAC3CngE,IAAI,EAAEoS,gBAAgB,CAAC4b,WAAW;MAClCE,UAAU,EAAEviC,QAAQ,CAACs1E,WAAW,CAAC/yF,SAAS;MAC1CkgD,UAAU,EAAE,IAAI;MAChBvY,UAAU,EAAE,IAAI;MAChBwY,UAAU,EAAE,IAAI;MAChBC,mBAAmB,EAAE;IACvB,CAAC,EAAEr8D,QAAQ,EAAE05B,QAAQ,CAACs1E,WAAW,CAACtsG,UAAU,CAAC;IAC7C+rG,KAAK,CAACh8G,IAAI,CAACm8G,SAAS,CAAC;EACvB;EACA,IAAIl1E,QAAQ,CAACu1E,QAAQ,KAAK5sF,SAAS,EAAE;IACnC,MAAMusF,SAAS,GAAG/9C,eAAe,CAACq9C,SAAS,EAAE;MAC3CngE,IAAI,EAAEoS,gBAAgB,CAAC6b,QAAQ;MAC/BC,UAAU,EAAEviC,QAAQ,CAACu1E,QAAQ,CAAChzF,SAAS;MACvCkgD,UAAU,EAAE,IAAI;MAChBvY,UAAU,EAAE,IAAI;MAChBwY,UAAU,EAAE,IAAI;MAChBC,mBAAmB,EAAE,IAAI;MACzBzjC,OAAO,EAAEc,QAAQ,CAACu1E,QAAQ,CAACr2E,OAAO,GAAGwyE,UAAU,CAAC1xE,QAAQ,CAACu1E,QAAQ,CAACr2E,OAAO,EAAE1D,IAAI,CAACy/B,GAAG,EAAEj7B,QAAQ,CAACu1E,QAAQ,CAACvsG,UAAU,CAAC,GAAG;IACvH,CAAC,EAAE1C,QAAQ,EAAE05B,QAAQ,CAACu1E,QAAQ,CAACvsG,UAAU,CAAC;IAC1C+rG,KAAK,CAACh8G,IAAI,CAACm8G,SAAS,CAAC;EACvB;EACA,IAAIl1E,QAAQ,CAACw1E,KAAK,KAAK7sF,SAAS,EAAE;IAChC,MAAMusF,SAAS,GAAG/9C,eAAe,CAACq9C,SAAS,EAAE;MAC3CngE,IAAI,EAAEoS,gBAAgB,CAACwb;IACzB,CAAC,EAAE37D,QAAQ,EAAE05B,QAAQ,CAACw1E,KAAK,CAACxsG,UAAU,CAAC;IACvC+rG,KAAK,CAACh8G,IAAI,CAACm8G,SAAS,CAAC;EACvB;EACA,IAAIl1E,QAAQ,CAACy1E,IAAI,KAAK9sF,SAAS,EAAE;IAC/B,IAAIqX,QAAQ,CAACy1E,IAAI,CAAC56G,KAAK,YAAY08B,eAAe,EAAE;MAClD,MAAM,IAAIj+B,KAAK,CAAC,sDAAsD,CAAC;IACzE;IACA,MAAM47G,SAAS,GAAGzqD,iBAAiB,CAAC+pD,SAAS,EAAE9C,UAAU,CAAC1xE,QAAQ,CAACy1E,IAAI,CAAC56G,KAAK,EAAE2gC,IAAI,CAACy/B,GAAG,EAAEj7B,QAAQ,CAACy1E,IAAI,CAACzsG,UAAU,CAAC,EAAE1C,QAAQ,EAAE05B,QAAQ,CAACy1E,IAAI,CAACzsG,UAAU,CAAC;IACvJgsG,OAAO,CAACj8G,IAAI,CAACm8G,SAAS,CAAC;EACzB;AACF;AACA,SAAS5C,SAASA,CAAC92E,IAAI,EAAEj6B,GAAG,EAAE;EAC5B,IAAIA,GAAG,CAACsgB,IAAI,YAAYwiB,OAAO,IAAIwsE,eAAe,CAACtvG,GAAG,CAACsgB,IAAI,CAAC,EAAE;IAC5D,MAAM+lC,IAAI,GAAGpsB,IAAI,CAACy/B,GAAG,CAAC5B,cAAc,CAAC,CAAC;IACtC79B,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAACg/D,gBAAgB,CAACnQ,IAAI,EAAErmD,GAAG,CAACsgB,IAAI,EAAE2oB,kBAAkB,CAACjpC,GAAG,CAACsgB,IAAI,CAAC,CAACjnB,IAAI,EAAE,IAAI,CAAC,CAAC;IAC3F,KAAK,MAAM,CAAC4V,WAAW,EAAExP,IAAI,CAAC,IAAI1B,MAAM,CAACyU,OAAO,CAAC;MAC/C,GAAGxS,GAAG,CAAC8hC,IAAI;MACX,GAAG9hC,GAAG,CAAC+hC;IACT,CAAC,CAAC,EAAE;MACF,IAAItiC,IAAI,YAAYy7B,SAAS,EAAE;QAC7By1E,eAAe,CAAC12E,IAAI,EAAEx6B,IAAI,EAAEwP,WAAW,CAAC;MAC1C,CAAC,MAAM;QACLyhG,UAAU,CAACz2E,IAAI,EAAEx6B,IAAI,EAAEwP,WAAW,CAAC;MACrC;IACF;IACAgrB,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAACi/D,cAAc,CAACpQ,IAAI,CAAC,CAAC;EACxC,CAAC,MAAM;IACL,MAAMtuD,KAAK,CAAC,yCAAyCiI,GAAG,CAACsgB,IAAI,EAAEjkB,WAAW,CAAChD,IAAI,EAAE,CAAC;EACpF;AACF;AACA,SAAS23G,cAAcA,CAAC/2E,IAAI,EAAEk6E,QAAQ,EAAE;EACtC,MAAMtO,YAAY,GAAG5rE,IAAI,CAACy/B,GAAG,CAACd,YAAY,CAAC3+B,IAAI,CAACosB,IAAI,CAAC;EACrD,MAAM+tD,SAAS,GAAG,WAAWvO,YAAY,CAACx/C,IAAI,EAAE;EAChD,MAAMguD,SAAS,GAAG,WAAWxO,YAAY,CAACx/C,IAAI,EAAE;EAChD,MAAMiuD,aAAa,GAAG,IAAIz7D,GAAG,CAAC,CAAC;EAC/BgtD,YAAY,CAAChmE,gBAAgB,CAACtkC,GAAG,CAAC44G,QAAQ,CAACz0E,IAAI,CAACrmC,IAAI,EAAE86G,QAAQ,CAACz0E,IAAI,CAACpmC,KAAK,CAAC;EAC1E,KAAK,MAAM0b,QAAQ,IAAIm/F,QAAQ,CAACt0E,gBAAgB,EAAE;IAChD,IAAI7qB,QAAQ,CAAC1b,KAAK,KAAK,QAAQ,EAAE;MAC/Bg7G,aAAa,CAAC15D,GAAG,CAAC5lC,QAAQ,CAAC3b,IAAI,CAAC;IAClC;IACA,IAAI2b,QAAQ,CAAC3b,IAAI,KAAK,QAAQ,EAAE;MAC9BwsG,YAAY,CAAChmE,gBAAgB,CAACtkC,GAAG,CAAC,QAAQ,EAAEyZ,QAAQ,CAAC1b,KAAK,CAAC,CAACiC,GAAG,CAAC64G,SAAS,EAAEp/F,QAAQ,CAAC1b,KAAK,CAAC;IAC5F,CAAC,MAAM,IAAI0b,QAAQ,CAAC3b,IAAI,KAAK,QAAQ,EAAE;MACrCwsG,YAAY,CAAChmE,gBAAgB,CAACtkC,GAAG,CAAC,QAAQ,EAAEyZ,QAAQ,CAAC1b,KAAK,CAAC,CAACiC,GAAG,CAAC84G,SAAS,EAAEr/F,QAAQ,CAAC1b,KAAK,CAAC;IAC5F,CAAC,MAAM;MACLusG,YAAY,CAAClsC,OAAO,CAAC/e,GAAG,CAAC;QACvB9H,IAAI,EAAE6R,oBAAoB,CAACgkD,KAAK;QAChCtvG,IAAI,EAAE,IAAI;QACVg6C,UAAU,EAAEr+B,QAAQ,CAAC3b,IAAI;QACzBgH,UAAU,EAAEk0G,oCAAoC,CAACv/F,QAAQ,EAAEo/F,SAAS,EAAEC,SAAS;MACjF,CAAC,CAAC;IACJ;EACF;EACA,MAAM5sG,UAAU,GAAG+sG,iBAAiB,CAACL,QAAQ,CAACx0E,OAAO,CAACjS,IAAI,EAAEymF,QAAQ,CAAC1sG,UAAU,CAAC;EAChF,MAAM8mD,KAAK,GAAG4hD,UAAU,CAACgE,QAAQ,CAACx0E,OAAO,EAAE1F,IAAI,CAACy/B,GAAG,EAAEjyD,UAAU,CAAC;EAChEioG,WAAW,CAAC7J,YAAY,EAAEsO,QAAQ,CAACt0G,QAAQ,CAAC;EAC5C,IAAIgzD,SAAS,GAAG,IAAI;EACpB,IAAI4hD,YAAY,GAAG,IAAI;EACvB,IAAIN,QAAQ,CAACr0E,KAAK,KAAK,IAAI,EAAE;IAC3B+yB,SAAS,GAAG54B,IAAI,CAACy/B,GAAG,CAACd,YAAY,CAAC3+B,IAAI,CAACosB,IAAI,CAAC;IAC5CqpD,WAAW,CAAC78C,SAAS,EAAEshD,QAAQ,CAACr0E,KAAK,CAACjgC,QAAQ,CAAC;IAC/C40G,YAAY,GAAGpC,+BAA+B,CAACp4E,IAAI,EAAE44B,SAAS,CAACxM,IAAI,EAAE8tD,QAAQ,CAACr0E,KAAK,CAAC;EACtF;EACA,MAAMgzB,QAAQ,GAAG;IACf04C,MAAM,EAAE8I,aAAa;IACrB7I,SAAS,EAAE0I,QAAQ,CAACz0E,IAAI,CAACrmC;EAC3B,CAAC;EACD,IAAI86G,QAAQ,CAAC7zF,IAAI,KAAK8G,SAAS,IAAI,EAAE+sF,QAAQ,CAAC7zF,IAAI,YAAYujB,gBAAgB,CAAC,EAAE;IAC/E,MAAM9rC,KAAK,CAAC,sDAAsD,CAAC;EACrE;EACA,IAAIo8G,QAAQ,CAACr0E,KAAK,EAAExf,IAAI,KAAK8G,SAAS,IAAI,EAAE+sF,QAAQ,CAACr0E,KAAK,CAACxf,IAAI,YAAYujB,gBAAgB,CAAC,EAAE;IAC5F,MAAM9rC,KAAK,CAAC,wDAAwD,CAAC;EACvE;EACA,MAAMyxD,eAAe,GAAG2qD,QAAQ,CAAC7zF,IAAI;EACrC,MAAM0yC,oBAAoB,GAAGmhD,QAAQ,CAACr0E,KAAK,EAAExf,IAAI;EACjD,MAAM9J,OAAO,GAAG67F,+BAA+B,CAACp4E,IAAI,EAAE4rE,YAAY,CAACx/C,IAAI,EAAE8tD,QAAQ,CAAC;EAClF,MAAMv2F,cAAc,GAAG+0C,sBAAsB,CAACkzC,YAAY,CAACx/C,IAAI,EAAEwM,SAAS,EAAExM,IAAI,IAAI,IAAI,EAAE7vC,OAAO,EAAE+3C,KAAK,EAAEuE,QAAQ,EAAE2hD,YAAY,EAAEjrD,eAAe,EAAEwJ,oBAAoB,EAAEmhD,QAAQ,CAAC33E,eAAe,EAAE23E,QAAQ,CAAC1sG,UAAU,CAAC;EACvNwyB,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAAComB,cAAc,CAAC;EAChC,MAAMvd,UAAU,GAAG8vG,UAAU,CAACgE,QAAQ,CAAC9zG,UAAU,EAAE45B,IAAI,CAACy/B,GAAG,EAAE86C,iBAAiB,CAACL,QAAQ,CAAC9zG,UAAU,CAACqtB,IAAI,EAAEymF,QAAQ,CAAC1sG,UAAU,CAAC,CAAC;EAC9H,MAAMkW,QAAQ,GAAG+qC,gBAAgB,CAAC9qC,cAAc,CAACyoC,IAAI,EAAEzoC,cAAc,CAAC0rC,MAAM,EAAEjpD,UAAU,EAAE8zG,QAAQ,CAAC1sG,UAAU,CAAC;EAC9GwyB,IAAI,CAACq/B,MAAM,CAAC9hE,IAAI,CAACmmB,QAAQ,CAAC;AAC5B;AACA,SAAS42F,oCAAoCA,CAACv/F,QAAQ,EAAEo/F,SAAS,EAAEC,SAAS,EAAE;EAC5E,QAAQr/F,QAAQ,CAAC1b,KAAK;IACpB,KAAK,QAAQ;MACX,OAAO,IAAI8wD,eAAe,CAACgqD,SAAS,CAAC;IACvC,KAAK,QAAQ;MACX,OAAO,IAAIhqD,eAAe,CAACiqD,SAAS,CAAC;IACvC,KAAK,QAAQ;MACX,OAAO,IAAIjqD,eAAe,CAACgqD,SAAS,CAAC,CAACtrG,SAAS,CAACmN,OAAO,CAAC,CAAC,CAAC,CAAC;IAC7D,KAAK,OAAO;MACV,OAAO,IAAIm0C,eAAe,CAACgqD,SAAS,CAAC,CAACtrG,SAAS,CAAC,IAAIshD,eAAe,CAACiqD,SAAS,CAAC,CAACnrG,KAAK,CAAC+M,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;IACnG,KAAK,OAAO;MACV,OAAO,IAAIm0C,eAAe,CAACgqD,SAAS,CAAC,CAAC1qG,MAAM,CAACuM,OAAO,CAAC,CAAC,CAAC,CAAC,CAACnN,SAAS,CAACmN,OAAO,CAAC,CAAC,CAAC,CAAC;IAChF,KAAK,MAAM;MACT,OAAO,IAAIm0C,eAAe,CAACgqD,SAAS,CAAC,CAAC1qG,MAAM,CAACuM,OAAO,CAAC,CAAC,CAAC,CAAC,CAACjN,YAAY,CAACiN,OAAO,CAAC,CAAC,CAAC,CAAC;IACnF;MACE,MAAM,IAAIle,KAAK,CAAC,8CAA8Cid,QAAQ,CAAC1b,KAAK,EAAE,CAAC;EACnF;AACF;AACA,SAAS23G,oBAAoBA,CAACh3E,IAAI,EAAEjuB,IAAI,EAAE;EACxC,MAAMqlB,MAAM,GAAG4I,IAAI,CAACy/B,GAAG,CAAC5B,cAAc,CAAC,CAAC;EACxC79B,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAACq+D,kBAAkB,CAACxkC,MAAM,EAAErlB,IAAI,CAAC3S,IAAI,EAAE2S,IAAI,CAACvE,UAAU,CAAC,CAAC;EACxEwyB,IAAI,CAACq/B,MAAM,CAAC9hE,IAAI,CAACsyD,gBAAgB,CAACz4B,MAAM,EAAErlB,IAAI,CAAC3S,IAAI,EAAE82G,UAAU,CAACnkG,IAAI,CAAC1S,KAAK,EAAE2gC,IAAI,CAACy/B,GAAG,EAAE1tD,IAAI,CAACitB,SAAS,CAAC,EAAEjtB,IAAI,CAACvE,UAAU,CAAC,CAAC;AAC1H;AACA,SAAS0oG,UAAUA,CAACz7F,GAAG,EAAEglD,GAAG,EAAEs4C,cAAc,EAAE;EAC5C,IAAIt9F,GAAG,YAAY6jB,aAAa,EAAE;IAChC,OAAO43E,UAAU,CAACz7F,GAAG,CAACA,GAAG,EAAEglD,GAAG,EAAEs4C,cAAc,CAAC;EACjD,CAAC,MAAM,IAAIt9F,GAAG,YAAYqgB,YAAY,EAAE;IACtC,MAAM2/E,kBAAkB,GAAGhgG,GAAG,CAACtI,QAAQ,YAAYioB,gBAAgB,IAAI,EAAE3f,GAAG,CAACtI,QAAQ,YAAYmoB,YAAY,CAAC;IAC9G,IAAImgF,kBAAkB,EAAE;MACtB,OAAO,IAAItqD,eAAe,CAAC11C,GAAG,CAACrb,IAAI,CAAC;IACtC,CAAC,MAAM;MACL,OAAO,IAAIsO,YAAY,CAACwoG,UAAU,CAACz7F,GAAG,CAACtI,QAAQ,EAAEstD,GAAG,EAAEs4C,cAAc,CAAC,EAAEt9F,GAAG,CAACrb,IAAI,EAAE,IAAI,EAAEm7G,iBAAiB,CAAC9/F,GAAG,CAACgZ,IAAI,EAAEskF,cAAc,CAAC,CAAC;IACrI;EACF,CAAC,MAAM,IAAIt9F,GAAG,YAAY+iB,IAAI,EAAE;IAC9B,IAAI/iB,GAAG,CAACtI,QAAQ,YAAYioB,gBAAgB,EAAE;MAC5C,MAAM,IAAIt8B,KAAK,CAAC,6BAA6B,CAAC;IAChD,CAAC,MAAM;MACL,OAAO,IAAIkQ,kBAAkB,CAACkoG,UAAU,CAACz7F,GAAG,CAACtI,QAAQ,EAAEstD,GAAG,EAAEs4C,cAAc,CAAC,EAAEt9F,GAAG,CAACvI,IAAI,CAACzQ,GAAG,CAAC4Q,GAAG,IAAI6jG,UAAU,CAAC7jG,GAAG,EAAEotD,GAAG,EAAEs4C,cAAc,CAAC,CAAC,EAAE5qF,SAAS,EAAEotF,iBAAiB,CAAC9/F,GAAG,CAACgZ,IAAI,EAAEskF,cAAc,CAAC,CAAC;IACjM;EACF,CAAC,MAAM,IAAIt9F,GAAG,YAAYghB,gBAAgB,EAAE;IAC1C,OAAOzf,OAAO,CAACvB,GAAG,CAACpb,KAAK,EAAE8tB,SAAS,EAAEotF,iBAAiB,CAAC9/F,GAAG,CAACgZ,IAAI,EAAEskF,cAAc,CAAC,CAAC;EACnF,CAAC,MAAM,IAAIt9F,GAAG,YAAYgiB,KAAK,EAAE;IAC/B,QAAQhiB,GAAG,CAACvD,QAAQ;MAClB,KAAK,GAAG;QACN,OAAO,IAAID,iBAAiB,CAACrK,aAAa,CAACwC,IAAI,EAAE8mG,UAAU,CAACz7F,GAAG,CAAC/I,IAAI,EAAE+tD,GAAG,EAAEs4C,cAAc,CAAC,EAAE5qF,SAAS,EAAEotF,iBAAiB,CAAC9/F,GAAG,CAACgZ,IAAI,EAAEskF,cAAc,CAAC,CAAC;MACrJ,KAAK,GAAG;QACN,OAAO,IAAI9gG,iBAAiB,CAACrK,aAAa,CAACsC,KAAK,EAAEgnG,UAAU,CAACz7F,GAAG,CAAC/I,IAAI,EAAE+tD,GAAG,EAAEs4C,cAAc,CAAC,EAAE5qF,SAAS,EAAEotF,iBAAiB,CAAC9/F,GAAG,CAACgZ,IAAI,EAAEskF,cAAc,CAAC,CAAC;MACtJ;QACE,MAAM,IAAIj6G,KAAK,CAAC,0CAA0C2c,GAAG,CAACvD,QAAQ,EAAE,CAAC;IAC7E;EACF,CAAC,MAAM,IAAIuD,GAAG,YAAY0hB,MAAM,EAAE;IAChC,MAAMjlB,QAAQ,GAAG6rD,gBAAgB,CAAC1hE,GAAG,CAACoZ,GAAG,CAAC2hB,SAAS,CAAC;IACpD,IAAIllB,QAAQ,KAAKiW,SAAS,EAAE;MAC1B,MAAM,IAAIrvB,KAAK,CAAC,2CAA2C2c,GAAG,CAAC2hB,SAAS,EAAE,CAAC;IAC7E;IACA,OAAO,IAAI3tB,kBAAkB,CAACyI,QAAQ,EAAEg/F,UAAU,CAACz7F,GAAG,CAAC4hB,IAAI,EAAEojC,GAAG,EAAEs4C,cAAc,CAAC,EAAE7B,UAAU,CAACz7F,GAAG,CAAC6hB,KAAK,EAAEmjC,GAAG,EAAEs4C,cAAc,CAAC,EAAE5qF,SAAS,EAAEotF,iBAAiB,CAAC9/F,GAAG,CAACgZ,IAAI,EAAEskF,cAAc,CAAC,CAAC;EACxL,CAAC,MAAM,IAAIt9F,GAAG,YAAY6f,YAAY,EAAE;IACtC,OAAO,IAAIs2B,WAAW,CAAC6O,GAAG,CAACtD,IAAI,CAAC/P,IAAI,CAAC;EACvC,CAAC,MAAM,IAAI3xC,GAAG,YAAYygB,SAAS,EAAE;IACnC,OAAO,IAAIttB,WAAW,CAACsoG,UAAU,CAACz7F,GAAG,CAACtI,QAAQ,EAAEstD,GAAG,EAAEs4C,cAAc,CAAC,EAAE7B,UAAU,CAACz7F,GAAG,CAAC9M,GAAG,EAAE8xD,GAAG,EAAEs4C,cAAc,CAAC,EAAE5qF,SAAS,EAAEotF,iBAAiB,CAAC9/F,GAAG,CAACgZ,IAAI,EAAEskF,cAAc,CAAC,CAAC;EACzK,CAAC,MAAM,IAAIt9F,GAAG,YAAY+f,KAAK,EAAE;IAC/B,MAAM,IAAI18B,KAAK,CAAC,0CAA0C,CAAC;EAC7D,CAAC,MAAM,IAAI2c,GAAG,YAAYohB,UAAU,EAAE;IACpC,MAAMtjB,OAAO,GAAGkC,GAAG,CAACxU,IAAI,CAACxE,GAAG,CAAC,CAACkM,GAAG,EAAEokD,GAAG,KAAK;MACzC,MAAM1yD,KAAK,GAAGob,GAAG,CAACc,MAAM,CAACw2C,GAAG,CAAC;MAC7B,OAAO,IAAIr5C,eAAe,CAAC/K,GAAG,CAACA,GAAG,EAAEuoG,UAAU,CAAC72G,KAAK,EAAEogE,GAAG,EAAEs4C,cAAc,CAAC,EAAEpqG,GAAG,CAACgL,MAAM,CAAC;IACzF,CAAC,CAAC;IACF,OAAO,IAAIC,cAAc,CAACL,OAAO,EAAE4U,SAAS,EAAEotF,iBAAiB,CAAC9/F,GAAG,CAACgZ,IAAI,EAAEskF,cAAc,CAAC,CAAC;EAC5F,CAAC,MAAM,IAAIt9F,GAAG,YAAYkhB,YAAY,EAAE;IACtC,OAAO,IAAIrjB,gBAAgB,CAACmC,GAAG,CAACtH,WAAW,CAAC1R,GAAG,CAACiQ,IAAI,IAAIwkG,UAAU,CAACxkG,IAAI,EAAE+tD,GAAG,EAAEs4C,cAAc,CAAC,CAAC,CAAC;EACjG,CAAC,MAAM,IAAIt9F,GAAG,YAAYigB,WAAW,EAAE;IACrC,OAAO,IAAIpsB,eAAe,CAAC4nG,UAAU,CAACz7F,GAAG,CAAC7E,SAAS,EAAE6pD,GAAG,EAAEs4C,cAAc,CAAC,EAAE7B,UAAU,CAACz7F,GAAG,CAACkgB,OAAO,EAAE8kC,GAAG,EAAEs4C,cAAc,CAAC,EAAE7B,UAAU,CAACz7F,GAAG,CAACmgB,QAAQ,EAAE6kC,GAAG,EAAEs4C,cAAc,CAAC,EAAE5qF,SAAS,EAAEotF,iBAAiB,CAAC9/F,GAAG,CAACgZ,IAAI,EAAEskF,cAAc,CAAC,CAAC;EACjO,CAAC,MAAM,IAAIt9F,GAAG,YAAY6iB,aAAa,EAAE;IACvC,OAAO44E,UAAU,CAACz7F,GAAG,CAACrU,UAAU,EAAEq5D,GAAG,EAAEs4C,cAAc,CAAC;EACxD,CAAC,MAAM,IAAIt9F,GAAG,YAAY8gB,WAAW,EAAE;IACrC,OAAO,IAAI42B,eAAe,CAACsN,GAAG,CAAC5B,cAAc,CAAC,CAAC,EAAE,IAAI/F,UAAU,CAAC,CAAC,EAAEr9C,GAAG,CAACrb,IAAI,EAAE,CAAC82G,UAAU,CAACz7F,GAAG,CAAC2B,GAAG,EAAEqjD,GAAG,EAAEs4C,cAAc,CAAC,EAAE,GAAGt9F,GAAG,CAACvI,IAAI,CAACzQ,GAAG,CAAC4Q,GAAG,IAAI6jG,UAAU,CAAC7jG,GAAG,EAAEotD,GAAG,EAAEs4C,cAAc,CAAC,CAAC,CAAC,CAAC;EACxL,CAAC,MAAM,IAAIt9F,GAAG,YAAY2gB,aAAa,EAAE;IACvC,OAAO,IAAIq3B,iBAAiB,CAACyjD,UAAU,CAACz7F,GAAG,CAACtI,QAAQ,EAAEstD,GAAG,EAAEs4C,cAAc,CAAC,EAAE7B,UAAU,CAACz7F,GAAG,CAAC9M,GAAG,EAAE8xD,GAAG,EAAEs4C,cAAc,CAAC,EAAEwC,iBAAiB,CAAC9/F,GAAG,CAACgZ,IAAI,EAAEskF,cAAc,CAAC,CAAC;EACpK,CAAC,MAAM,IAAIt9F,GAAG,YAAYugB,gBAAgB,EAAE;IAC1C,OAAO,IAAIw3B,oBAAoB,CAAC0jD,UAAU,CAACz7F,GAAG,CAACtI,QAAQ,EAAEstD,GAAG,EAAEs4C,cAAc,CAAC,EAAEt9F,GAAG,CAACrb,IAAI,CAAC;EAC1F,CAAC,MAAM,IAAIqb,GAAG,YAAYkjB,QAAQ,EAAE;IAClC,OAAO,IAAI+0B,sBAAsB,CAACwjD,UAAU,CAACz7F,GAAG,CAACtI,QAAQ,EAAEstD,GAAG,EAAEs4C,cAAc,CAAC,EAAEt9F,GAAG,CAACvI,IAAI,CAACzQ,GAAG,CAAC0D,CAAC,IAAI+wG,UAAU,CAAC/wG,CAAC,EAAEs6D,GAAG,EAAEs4C,cAAc,CAAC,CAAC,CAAC;EACzI,CAAC,MAAM,IAAIt9F,GAAG,YAAYyf,WAAW,EAAE;IACrC,OAAO,IAAIC,SAAS,CAACogF,iBAAiB,CAAC9/F,GAAG,CAACgZ,IAAI,EAAEskF,cAAc,CAAC,CAAC;EACnE,CAAC,MAAM,IAAIt9F,GAAG,YAAYuiB,SAAS,EAAE;IACnC,OAAOthB,GAAG,CAACw6F,UAAU,CAACz7F,GAAG,CAACrU,UAAU,EAAEq5D,GAAG,EAAEs4C,cAAc,CAAC,EAAEwC,iBAAiB,CAAC9/F,GAAG,CAACgZ,IAAI,EAAEskF,cAAc,CAAC,CAAC;EAC1G,CAAC,MAAM,IAAIt9F,GAAG,YAAYyiB,gBAAgB,EAAE;IAC1C,OAAO7hB,UAAU,CAAC66F,UAAU,CAACz7F,GAAG,CAACrU,UAAU,EAAEq5D,GAAG,EAAEs4C,cAAc,CAAC,CAAC;EACpE,CAAC,MAAM,IAAIt9F,GAAG,YAAY2iB,cAAc,EAAE;IACxC,OAAO,IAAIxrB,QAAQ,CAACskG,UAAU,CAACz7F,GAAG,CAACrU,UAAU,EAAEq5D,GAAG,EAAEs4C,cAAc,CAAC,EAAE5qF,SAAS,EAAEotF,iBAAiB,CAAC9/F,GAAG,CAACgZ,IAAI,EAAEskF,cAAc,CAAC,CAAC;EAC9H,CAAC,MAAM,IAAIt9F,GAAG,YAAYsjB,eAAe,EAAE;IACzC,OAAO28E,sBAAsB,CAACjgG,GAAG,EAAEglD,GAAG,EAAEs4C,cAAc,CAAC;EACzD,CAAC,MAAM,IAAIt9F,GAAG,YAAYojB,qBAAqB,EAAE;IAC/C,OAAO,IAAIvrB,yBAAyB,CAAC4jG,UAAU,CAACz7F,GAAG,CAAC1c,GAAG,EAAE0hE,GAAG,EAAEs4C,cAAc,CAAC,EAAE2C,sBAAsB,CAACjgG,GAAG,CAAClI,QAAQ,EAAEktD,GAAG,EAAEs4C,cAAc,CAAC,EAAE5qF,SAAS,EAAEotF,iBAAiB,CAAC9/F,GAAG,CAACgZ,IAAI,EAAEskF,cAAc,CAAC,CAAC;EACnM,CAAC,MAAM,IAAIt9F,GAAG,YAAY0jB,uBAAuB,EAAE;IACjD,OAAO,IAAI9mB,iBAAiB,CAAC6+F,UAAU,CAACz7F,GAAG,CAACrU,UAAU,EAAEq5D,GAAG,EAAEs4C,cAAc,CAAC,EAAE5qF,SAAS,EAAEotF,iBAAiB,CAAC9/F,GAAG,CAACgZ,IAAI,EAAEskF,cAAc,CAAC,CAAC;EACvI,CAAC,MAAM,IAAIt9F,GAAG,YAAY4jB,wBAAwB,EAAE;IAClD,OAAO,IAAI1rB,4BAA4B,CAAC8H,GAAG,CAAC7H,IAAI,EAAE6H,GAAG,CAAC5H,KAAK,EAAEklG,cAAc,CAAC;EAC9E,CAAC,MAAM;IACL,MAAM,IAAIj6G,KAAK,CAAC,8BAA8B2c,GAAG,CAACrY,WAAW,CAAChD,IAAI,cAAc24G,cAAc,EAAEpkF,KAAK,CAAC5E,IAAI,CAAChZ,GAAG,GAAG,CAAC;EACpH;AACF;AACA,SAAS2kG,sBAAsBA,CAACjgG,GAAG,EAAEglD,GAAG,EAAEs4C,cAAc,EAAE;EACxD,OAAO,IAAI9kG,mBAAmB,CAACwH,GAAG,CAACvH,QAAQ,CAACzR,GAAG,CAAC4R,EAAE,IAAI;IACpD,OAAO,IAAIC,0BAA0B,CAACD,EAAE,CAAC7N,IAAI,EAAE+0G,iBAAiB,CAAClnG,EAAE,CAACogB,IAAI,EAAEskF,cAAc,CAAC,CAAC;EAC5F,CAAC,CAAC,EAAEt9F,GAAG,CAACtH,WAAW,CAAC1R,GAAG,CAACiQ,IAAI,IAAIwkG,UAAU,CAACxkG,IAAI,EAAE+tD,GAAG,EAAEs4C,cAAc,CAAC,CAAC,EAAEwC,iBAAiB,CAAC9/F,GAAG,CAACgZ,IAAI,EAAEskF,cAAc,CAAC,CAAC;AACtH;AACA,SAAS4C,2BAA2BA,CAACl7C,GAAG,EAAEpgE,KAAK,EAAEw5G,QAAQ,EAAErrG,UAAU,EAAE;EACrE,IAAIpH,UAAU;EACd,IAAI/G,KAAK,YAAY08B,eAAe,EAAE;IACpC31B,UAAU,GAAG,IAAI41B,aAAa,CAAC38B,KAAK,CAAC48B,OAAO,EAAE58B,KAAK,CAAC8T,WAAW,CAAC1R,GAAG,CAACoG,CAAC,IAAIquG,UAAU,CAACruG,CAAC,EAAE43D,GAAG,EAAE,IAAI,CAAC,CAAC,EAAE37D,MAAM,CAACmC,IAAI,CAAC4xG,SAAS,CAACgB,QAAQ,CAAC,EAAE/wE,YAAY,IAAI,CAAC,CAAC,CAAC,CAAC;EAC3J,CAAC,MAAM,IAAIzoC,KAAK,YAAY06B,GAAG,EAAE;IAC/B3zB,UAAU,GAAG8vG,UAAU,CAAC72G,KAAK,EAAEogE,GAAG,EAAE,IAAI,CAAC;EAC3C,CAAC,MAAM;IACLr5D,UAAU,GAAG4V,OAAO,CAAC3c,KAAK,CAAC;EAC7B;EACA,OAAO+G,UAAU;AACnB;AACA,MAAMw0G,aAAa,GAAG,IAAI56G,GAAG,CAAC,CAAC,CAAC6/B,WAAW,CAAC0R,QAAQ,EAAEqZ,WAAW,CAACrZ,QAAQ,CAAC,EAAE,CAAC1R,WAAW,CAAC2R,MAAM,EAAEoZ,WAAW,CAAC2C,cAAc,CAAC,EAAE,CAAC1tB,WAAW,CAACquB,SAAS,EAAEtD,WAAW,CAACsD,SAAS,CAAC,EAAE,CAACruB,WAAW,CAAC/H,KAAK,EAAE8yB,WAAW,CAACgX,SAAS,CAAC,EAAE,CAAC/hC,WAAW,CAACg7E,KAAK,EAAEjwD,WAAW,CAACiX,aAAa,CAAC,EAAE,CAAChiC,WAAW,CAACgC,eAAe,EAAE+oB,WAAW,CAAC/oB,eAAe,CAAC,EAAE,CAAChC,WAAW,CAAC+zB,SAAS,EAAEhJ,WAAW,CAACgJ,SAAS,CAAC,CAAC,CAAC;AACvX,SAAS6jD,eAAeA,CAACH,IAAI,EAAE;EAC7B,OAAOp3E,WAAW,CAACo3E,IAAI,CAAC/6F,OAAO,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK24F,oBAAoB;AACpE;AACA,SAAS2C,SAASA,CAACgB,QAAQ,EAAE;EAC3B,IAAIA,QAAQ,IAAI,IAAI,EAAE;IACpB,OAAO,IAAI;EACb;EACA,IAAI,EAAEA,QAAQ,YAAYhwE,OAAO,CAAC,EAAE;IAClC,MAAM/qC,KAAK,CAAC,gDAAgD+6G,QAAQ,CAACz2G,WAAW,CAAChD,IAAI,EAAE,CAAC;EAC1F;EACA,OAAOy5G,QAAQ;AACjB;AACA,SAAS3B,qBAAqBA,CAACl3E,IAAI,EAAEtoB,EAAE,EAAE9a,OAAO,EAAE;EAChD,IAAIqrC,QAAQ,GAAG,IAAIpxB,KAAK,CAAC,CAAC;EAC1B,IAAIikG,yBAAyB,GAAG,IAAIl8D,GAAG,CAAC,CAAC;EACzC,KAAK,MAAMrgD,IAAI,IAAI3B,OAAO,CAACqlC,UAAU,EAAE;IACrC,MAAMlC,eAAe,GAAGk1E,SAAS,CAACl1E,eAAe,CAACnjC,OAAO,CAACwC,IAAI,EAAEb,IAAI,CAACa,IAAI,EAAE,IAAI,CAAC;IAChF6oC,QAAQ,CAAC1qC,IAAI,CAACqvD,eAAe,CAACl1C,EAAE,CAAC00C,IAAI,EAAExB,WAAW,CAACsD,SAAS,EAAE3vD,IAAI,CAACa,IAAI,EAAEu7G,2BAA2B,CAAC36E,IAAI,CAACy/B,GAAG,EAAElhE,IAAI,CAACc,KAAK,EAAEd,IAAI,CAAC8nB,IAAI,CAAC,EAAE,IAAI,EAAE0Z,eAAe,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE83E,SAAS,CAACt5G,IAAI,CAAC8nB,IAAI,CAAC,EAAE9nB,IAAI,CAACiP,UAAU,CAAC,CAAC;IACxN,IAAIjP,IAAI,CAAC8nB,IAAI,EAAE;MACby0F,yBAAyB,CAACn6D,GAAG,CAACpiD,IAAI,CAACa,IAAI,CAAC;IAC1C;EACF;EACA,KAAK,MAAMktB,KAAK,IAAI1vB,OAAO,CAACslC,MAAM,EAAE;IAClC,IAAI44E,yBAAyB,CAACr4G,GAAG,CAAC6pB,KAAK,CAACltB,IAAI,CAAC,EAAE;MAC7C27G,OAAO,CAACz2E,KAAK,CAAC,gBAAgBtE,IAAI,CAACy/B,GAAG,CAAC54B,aAAa,iBAAiBva,KAAK,CAACltB,IAAI,6JAA6J,CAAC;IAC/O;IACA6oC,QAAQ,CAAC1qC,IAAI,CAACqvD,eAAe,CAACl1C,EAAE,CAAC00C,IAAI,EAAEwuD,aAAa,CAACv5G,GAAG,CAACirB,KAAK,CAACjmB,IAAI,CAAC,EAAEimB,KAAK,CAACltB,IAAI,EAAEu7G,2BAA2B,CAAC36E,IAAI,CAACy/B,GAAG,EAAEu7C,KAAK,CAAC1uF,KAAK,CAACjtB,KAAK,CAAC,EAAEitB,KAAK,CAACjG,IAAI,CAAC,EAAEiG,KAAK,CAAC0T,IAAI,EAAE1T,KAAK,CAACyT,eAAe,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE83E,SAAS,CAACvrF,KAAK,CAACjG,IAAI,CAAC,IAAI,IAAI,EAAEiG,KAAK,CAAC9e,UAAU,CAAC,CAAC;IACjQ,IAAI8e,KAAK,CAACjmB,IAAI,KAAKw5B,WAAW,CAAC0R,QAAQ,IAAIjlB,KAAK,CAACltB,IAAI,KAAK,OAAO,EAAE;MACjE4gC,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAAC4/D,qBAAqB,CAAC7wC,KAAK,CAAC9e,UAAU,CAAC,CAAC;IAC3D;EACF;EACAwyB,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAAC0qC,QAAQ,CAAChpB,MAAM,CAACvX,CAAC,IAAIA,CAAC,EAAEmxC,IAAI,KAAK0R,MAAM,CAAC2J,kBAAkB,CAAC,CAAC;EAC7El0B,IAAI,CAACq/B,MAAM,CAAC9hE,IAAI,CAAC0qC,QAAQ,CAAChpB,MAAM,CAACvX,CAAC,IAAIA,CAAC,EAAEmxC,IAAI,KAAK0R,MAAM,CAAC0C,OAAO,CAAC,CAAC;EAClE,KAAK,MAAMguD,MAAM,IAAIr+G,OAAO,CAACulC,OAAO,EAAE;IACpC,IAAI84E,MAAM,CAAC50G,IAAI,KAAKm5B,eAAe,CAACqC,eAAe,IAAIo5E,MAAM,CAACx5E,KAAK,KAAK,IAAI,EAAE;MAC5E,MAAM3jC,KAAK,CAAC,wCAAwC,CAAC;IACvD;IACA,IAAIm9G,MAAM,CAAC50G,IAAI,KAAKm5B,eAAe,CAACgS,MAAM,EAAE;MAC1CxR,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAAC68D,sBAAsB,CAAC1iD,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC23C,MAAM,EAAE4rD,MAAM,CAAC77G,IAAI,EAAEsY,EAAE,CAAC3Z,GAAG,EAAEm9G,4BAA4B,CAACl7E,IAAI,EAAEi7E,MAAM,CAACjmF,OAAO,EAAEimF,MAAM,CAACt7E,WAAW,CAAC,EAAEs7E,MAAM,CAACztG,UAAU,CAAC,CAAC;IAC9K,CAAC,MAAM,IAAIytG,MAAM,CAAC50G,IAAI,KAAKm5B,eAAe,CAACo0B,SAAS,EAAE;MACpD5zB,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAAC48D,yBAAyB,CAACziD,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC23C,MAAM,EAAE4rD,MAAM,CAAC77G,IAAI,EAAEsY,EAAE,CAAC3Z,GAAG,EAAEs4G,sBAAsB,CAACr2E,IAAI,EAAEi7E,MAAM,CAACjmF,OAAO,EAAEimF,MAAM,CAACt7E,WAAW,CAAC,EAAEs7E,MAAM,CAAC77G,IAAI,CAAC0tE,QAAQ,CAAC,OAAO,CAAC,GAAG,OAAO,GAAG,OAAO,EAAEmuC,MAAM,CAAC7jF,MAAM,EAAE,KAAK,EAAE6jF,MAAM,CAACztG,UAAU,CAAC,CAAC;IACpP,CAAC,MAAM;MACLwyB,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAACq8D,gBAAgB,CAACliD,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC23C,MAAM,EAAE4rD,MAAM,CAAC77G,IAAI,EAAEsY,EAAE,CAAC3Z,GAAG,EAAEs4G,sBAAsB,CAACr2E,IAAI,EAAEi7E,MAAM,CAACjmF,OAAO,EAAEimF,MAAM,CAACt7E,WAAW,CAAC,EAAEs7E,MAAM,CAACx5E,KAAK,EAAEw5E,MAAM,CAAC7jF,MAAM,EAAE,KAAK,EAAE6jF,MAAM,CAACztG,UAAU,CAAC,CAAC;IACtM;EACF;EACA,IAAIy6B,QAAQ,CAAC8G,IAAI,CAACrnC,CAAC,IAAIA,CAAC,EAAEslD,WAAW,CAAC,KAAK,IAAI,EAAE;IAC/ChtB,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAACu/D,sBAAsB,CAAC98B,IAAI,CAACy/B,GAAG,CAAC5B,cAAc,CAAC,CAAC,EAAE,IAAI/F,UAAU,CAAC,CAAC,EAAEpgD,EAAE,CAAC00C,IAAI,CAAC,CAAC;EAChG;AACF;AACA,SAASwrD,sBAAsBA,CAAC53E,IAAI,EAAEtoB,EAAE,EAAEnF,QAAQ,EAAEw6C,YAAY,EAAE;EAChE,IAAI9kB,QAAQ,GAAG,IAAIpxB,KAAK,CAAC,CAAC;EAC1B,KAAK,MAAMtY,IAAI,IAAIgU,QAAQ,CAAC20B,aAAa,EAAE;IACzC,IAAI3oC,IAAI,YAAY4iC,aAAa,EAAE;MACjC,MAAMpB,eAAe,GAAGk1E,SAAS,CAACl1E,eAAe,CAACm1E,oBAAoB,EAAE32G,IAAI,CAACa,IAAI,EAAE,IAAI,CAAC;MACxF6oC,QAAQ,CAAC1qC,IAAI,CAAC49G,qBAAqB,CAACn7E,IAAI,EAAEtoB,EAAE,CAAC00C,IAAI,EAAEvsB,WAAW,CAACquB,SAAS,EAAE3vD,IAAI,CAACa,IAAI,EAAEb,IAAI,CAACc,KAAK,EAAE,IAAI,EAAE0gC,eAAe,EAAE,IAAI,EAAEgtB,YAAY,EAAE8qD,SAAS,CAACt5G,IAAI,CAAC8nB,IAAI,CAAC,EAAE9nB,IAAI,CAACiP,UAAU,CAAC,CAAC;IACrL,CAAC,MAAM;MACLy6B,QAAQ,CAAC1qC,IAAI,CAAC49G,qBAAqB,CAACn7E,IAAI,EAAEtoB,EAAE,CAAC00C,IAAI,EAAE7tD,IAAI,CAAC8H,IAAI,EAAE9H,IAAI,CAACa,IAAI,EAAE47G,KAAK,CAACz8G,IAAI,CAACc,KAAK,CAAC,EAAEd,IAAI,CAACyhC,IAAI,EAAEzhC,IAAI,CAACwhC,eAAe,EAAE,IAAI,EAAEgtB,YAAY,EAAE8qD,SAAS,CAACt5G,IAAI,CAAC8nB,IAAI,CAAC,EAAE9nB,IAAI,CAACiP,UAAU,CAAC,CAAC;IAC1L;EACF;EACA,KAAK,MAAMjP,IAAI,IAAIgU,QAAQ,CAAC0vB,UAAU,EAAE;IACtC,MAAMlC,eAAe,GAAGk1E,SAAS,CAACl1E,eAAe,CAACm1E,oBAAoB,EAAE32G,IAAI,CAACa,IAAI,EAAE,IAAI,CAAC;IACxF6oC,QAAQ,CAAC1qC,IAAI,CAAC49G,qBAAqB,CAACn7E,IAAI,EAAEtoB,EAAE,CAAC00C,IAAI,EAAEvsB,WAAW,CAACquB,SAAS,EAAE3vD,IAAI,CAACa,IAAI,EAAEb,IAAI,CAACc,KAAK,EAAE,IAAI,EAAE0gC,eAAe,EAAE,KAAK,EAAEgtB,YAAY,EAAE8qD,SAAS,CAACt5G,IAAI,CAAC8nB,IAAI,CAAC,EAAE9nB,IAAI,CAACiP,UAAU,CAAC,CAAC;EACtL;EACA,KAAK,MAAM8e,KAAK,IAAI/Z,QAAQ,CAAC2vB,MAAM,EAAE;IACnC+F,QAAQ,CAAC1qC,IAAI,CAAC49G,qBAAqB,CAACn7E,IAAI,EAAEtoB,EAAE,CAAC00C,IAAI,EAAE9/B,KAAK,CAACjmB,IAAI,EAAEimB,KAAK,CAACltB,IAAI,EAAE47G,KAAK,CAAC1uF,KAAK,CAACjtB,KAAK,CAAC,EAAEitB,KAAK,CAAC0T,IAAI,EAAE1T,KAAK,CAACyT,eAAe,EAAE,KAAK,EAAEgtB,YAAY,EAAE8qD,SAAS,CAACvrF,KAAK,CAACjG,IAAI,CAAC,EAAEiG,KAAK,CAAC9e,UAAU,CAAC,CAAC;EAClM;EACAwyB,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAAC0qC,QAAQ,CAAChpB,MAAM,CAACvX,CAAC,IAAIA,CAAC,EAAEmxC,IAAI,KAAK0R,MAAM,CAAC2J,kBAAkB,CAAC,CAAC;EAC7El0B,IAAI,CAACq/B,MAAM,CAAC9hE,IAAI,CAAC0qC,QAAQ,CAAChpB,MAAM,CAACvX,CAAC,IAAIA,CAAC,EAAEmxC,IAAI,KAAK0R,MAAM,CAAC0C,OAAO,CAAC,CAAC;EAClE,KAAK,MAAMguD,MAAM,IAAI1oG,QAAQ,CAAC4vB,OAAO,EAAE;IACrC,IAAI84E,MAAM,CAAC50G,IAAI,KAAKm5B,eAAe,CAACqC,eAAe,IAAIo5E,MAAM,CAACx5E,KAAK,KAAK,IAAI,EAAE;MAC5E,MAAM3jC,KAAK,CAAC,wCAAwC,CAAC;IACvD;IACA,IAAIivD,YAAY,KAAK5B,YAAY,CAACusD,UAAU,EAAE;MAC5C,IAAIuD,MAAM,CAAC50G,IAAI,KAAKm5B,eAAe,CAACgS,MAAM,EAAE;QAC1CxR,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAAC68D,sBAAsB,CAAC1iD,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC23C,MAAM,EAAE4rD,MAAM,CAAC77G,IAAI,EAAEsY,EAAE,CAAC3Z,GAAG,EAAEm9G,4BAA4B,CAACl7E,IAAI,EAAEi7E,MAAM,CAACjmF,OAAO,EAAEimF,MAAM,CAACt7E,WAAW,CAAC,EAAEs7E,MAAM,CAACztG,UAAU,CAAC,CAAC;MAC9K,CAAC,MAAM;QACLwyB,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAACq8D,gBAAgB,CAACliD,EAAE,CAAC00C,IAAI,EAAE10C,EAAE,CAAC23C,MAAM,EAAE4rD,MAAM,CAAC77G,IAAI,EAAEsY,EAAE,CAAC3Z,GAAG,EAAEs4G,sBAAsB,CAACr2E,IAAI,EAAEi7E,MAAM,CAACjmF,OAAO,EAAEimF,MAAM,CAACt7E,WAAW,CAAC,EAAEs7E,MAAM,CAACx5E,KAAK,EAAEw5E,MAAM,CAAC7jF,MAAM,EAAE,KAAK,EAAE6jF,MAAM,CAACztG,UAAU,CAAC,CAAC;MACtM;IACF;IACA,IAAIu/C,YAAY,KAAK5B,YAAY,CAACk4C,UAAU,IAAI4X,MAAM,CAAC50G,IAAI,KAAKm5B,eAAe,CAACqC,eAAe,EAAE;MAC/F,MAAM9B,eAAe,GAAGk1E,SAAS,CAACl1E,eAAe,CAACm1E,oBAAoB,EAAE+F,MAAM,CAAC77G,IAAI,EAAE,KAAK,CAAC;MAC3F4gC,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAACq9D,0BAA0B,CAACljD,EAAE,CAAC00C,IAAI,EAAExB,WAAW,CAACrZ,QAAQ,EAAE,IAAI,EAAE0pE,MAAM,CAAC77G,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE2gC,eAAe,CAAC,CAAC;IACnI;EACF;EACA,IAAIkI,QAAQ,CAAC8G,IAAI,CAACrnC,CAAC,IAAIA,CAAC,EAAEslD,WAAW,CAAC,KAAK,IAAI,EAAE;IAC/ChtB,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAACu/D,sBAAsB,CAAC98B,IAAI,CAACy/B,GAAG,CAAC5B,cAAc,CAAC,CAAC,EAAE,IAAI/F,UAAU,CAAC,CAAC,EAAEpgD,EAAE,CAAC00C,IAAI,CAAC,CAAC;EAChG;AACF;AACA,SAAS+uD,qBAAqBA,CAACpyG,IAAI,EAAEqjD,IAAI,EAAE/lD,IAAI,EAAEjH,IAAI,EAAEC,KAAK,EAAE2gC,IAAI,EAAED,eAAe,EAAE+sB,6BAA6B,EAAEC,YAAY,EAAEC,WAAW,EAAEx/C,UAAU,EAAE;EACzJ,MAAM4tG,aAAa,GAAG,OAAO/7G,KAAK,KAAK,QAAQ;EAC/C,IAAI0tD,YAAY,KAAK5B,YAAY,CAACk4C,UAAU,EAAE;IAC5C,IAAI,CAACv2C,6BAA6B,EAAE;MAClC,QAAQzmD,IAAI;QACV,KAAKw5B,WAAW,CAAC0R,QAAQ;QACzB,KAAK1R,WAAW,CAAC/H,KAAK;QACtB,KAAK+H,WAAW,CAACg7E,KAAK;UACpB,OAAOjgD,0BAA0B,CAACxO,IAAI,EAAExB,WAAW,CAACrZ,QAAQ,EAAE,IAAI,EAAEnyC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE4tD,WAAW,EAAEjtB,eAAe,CAAC;QACrH,KAAKF,WAAW,CAAC2R,MAAM;UACrB,OAAOopB,0BAA0B,CAACxO,IAAI,EAAExB,WAAW,CAAC2C,cAAc,EAAE,IAAI,EAAEnuD,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE4tD,WAAW,EAAEjtB,eAAe,CAAC;MAC7H;IACF;IACA,IAAI,CAACq7E,aAAa,KAAK/0G,IAAI,KAAKw5B,WAAW,CAACquB,SAAS,IAAI7nD,IAAI,KAAKw5B,WAAW,CAACgC,eAAe,IAAIx7B,IAAI,KAAKw5B,WAAW,CAAC+zB,SAAS,CAAC,EAAE;MAChI,OAAO,IAAI;IACb;EACF;EACA,IAAIynD,WAAW,GAAGT,aAAa,CAACv5G,GAAG,CAACgF,IAAI,CAAC;EACzC,IAAI0mD,YAAY,KAAK5B,YAAY,CAACusD,UAAU,EAAE;IAC5C,IAAIrxG,IAAI,KAAKw5B,WAAW,CAAC/H,KAAK,IAAIzxB,IAAI,KAAKw5B,WAAW,CAACg7E,KAAK,IAAIx0G,IAAI,KAAKw5B,WAAW,CAACquB,SAAS,IAAI,CAACktD,aAAa,EAAE;MAChHC,WAAW,GAAGzwD,WAAW,CAACrZ,QAAQ;IACpC;EACF;EACA,OAAOqb,eAAe,CAACR,IAAI,EAAEivD,WAAW,EAAEj8G,IAAI,EAAEu7G,2BAA2B,CAAC5xG,IAAI,CAAC02D,GAAG,EAAEpgE,KAAK,EAAE2tD,WAAW,CAAC,EAAEhtB,IAAI,EAAED,eAAe,EAAEq7E,aAAa,EAAEtuD,6BAA6B,EAAEC,YAAY,EAAEC,WAAW,EAAEx/C,UAAU,CAAC;AACxN;AACA,SAAS6oG,sBAAsBA,CAACr2E,IAAI,EAAEhL,OAAO,EAAE2K,WAAW,EAAE;EAC1D3K,OAAO,GAAGgmF,KAAK,CAAChmF,OAAO,CAAC;EACxB,MAAMi/B,UAAU,GAAG,IAAIp9C,KAAK,CAAC,CAAC;EAC9B,IAAIykG,YAAY,GAAGtmF,OAAO,YAAYwF,KAAK,GAAGxF,OAAO,CAAC7hB,WAAW,GAAG,CAAC6hB,OAAO,CAAC;EAC7E,IAAIsmF,YAAY,CAACh+G,MAAM,KAAK,CAAC,EAAE;IAC7B,MAAM,IAAIQ,KAAK,CAAC,sDAAsD,CAAC;EACzE;EACA,MAAMqV,WAAW,GAAGmoG,YAAY,CAAC75G,GAAG,CAACiQ,IAAI,IAAIwkG,UAAU,CAACxkG,IAAI,EAAEsuB,IAAI,CAACy/B,GAAG,EAAE9/B,WAAW,CAAC,CAAC;EACrF,MAAMynE,UAAU,GAAGj0F,WAAW,CAACsf,GAAG,CAAC,CAAC;EACpCwhC,UAAU,CAAC12D,IAAI,CAAC,GAAG4V,WAAW,CAAC1R,GAAG,CAACoG,CAAC,IAAIokD,iBAAiB,CAAC,IAAI/6C,mBAAmB,CAACrJ,CAAC,EAAEA,CAAC,CAAC2F,UAAU,CAAC,CAAC,CAAC,CAAC;EACrGymD,UAAU,CAAC12D,IAAI,CAAC0uD,iBAAiB,CAAC,IAAI9xC,eAAe,CAACitF,UAAU,EAAEA,UAAU,CAAC55F,UAAU,CAAC,CAAC,CAAC;EAC1F,OAAOymD,UAAU;AACnB;AACA,SAASinD,4BAA4BA,CAACl7E,IAAI,EAAEhL,OAAO,EAAE2K,WAAW,EAAE;EAChE3K,OAAO,GAAGgmF,KAAK,CAAChmF,OAAO,CAAC;EACxB,MAAMi/B,UAAU,GAAG,IAAIp9C,KAAK,CAAC,CAAC;EAC9B,IAAIme,OAAO,YAAYwF,KAAK,EAAE;IAC5B,IAAIxF,OAAO,CAAC7hB,WAAW,CAAC7V,MAAM,KAAK,CAAC,EAAE;MACpC03B,OAAO,GAAGA,OAAO,CAAC7hB,WAAW,CAAC,CAAC,CAAC;IAClC,CAAC,MAAM;MACL,MAAM,IAAIrV,KAAK,CAAC,wDAAwD,CAAC;IAC3E;EACF;EACA,MAAMy9G,WAAW,GAAGrF,UAAU,CAAClhF,OAAO,EAAEgL,IAAI,CAACy/B,GAAG,EAAE9/B,WAAW,CAAC;EAC9D,MAAM67E,cAAc,GAAG,IAAIrrD,eAAe,CAAC,QAAQ,CAAC;EACpD,MAAMsrD,aAAa,GAAG,IAAIhqD,oBAAoB,CAAC8pD,WAAW,EAAEC,cAAc,CAAC;EAC3EvnD,UAAU,CAAC12D,IAAI,CAAC0uD,iBAAiB,CAAC,IAAI/6C,mBAAmB,CAACuqG,aAAa,CAAC,CAAC,CAAC;EAC1ExnD,UAAU,CAAC12D,IAAI,CAAC0uD,iBAAiB,CAAC,IAAI9xC,eAAe,CAACqhG,cAAc,CAAC,CAAC,CAAC;EACvE,OAAOvnD,UAAU;AACnB;AACA,SAAS+mD,KAAKA,CAACvgG,GAAG,EAAE;EAClB,OAAOA,GAAG,YAAY6jB,aAAa,GAAG7jB,GAAG,CAACA,GAAG,GAAGA,GAAG;AACrD;AACA,SAAS08F,gBAAgBA,CAACz/F,EAAE,EAAE9a,OAAO,EAAE;EACrC8+G,aAAa,CAAChkG,EAAE,CAACygD,SAAS,CAAC;EAC3B,KAAK,MAAM;IACT/4D,IAAI;IACJC;EACF,CAAC,IAAIzC,OAAO,CAACylC,UAAU,EAAE;IACvB3qB,EAAE,CAACygD,SAAS,CAAC56D,IAAI,CAAC;MAChB6B,IAAI;MACJg4B,MAAM,EAAE/3B;IACV,CAAC,CAAC;EACJ;AACF;AACA,SAASq8G,aAAaA,CAACr8G,KAAK,EAAE;EAC5B,IAAI,CAACwX,KAAK,CAACC,OAAO,CAACzX,KAAK,CAAC,EAAE;IACzB,MAAM,IAAIvB,KAAK,CAAC,mCAAmC,CAAC;EACtD;AACF;AACA,SAASy8G,iBAAiBA,CAAC9mF,IAAI,EAAEskF,cAAc,EAAE;EAC/C,IAAIA,cAAc,KAAK,IAAI,EAAE;IAC3B,OAAO,IAAI;EACb;EACA,MAAMpkF,KAAK,GAAGokF,cAAc,CAACpkF,KAAK,CAACojB,MAAM,CAACtjB,IAAI,CAACE,KAAK,CAAC;EACrD,MAAMhqB,GAAG,GAAGouG,cAAc,CAACpkF,KAAK,CAACojB,MAAM,CAACtjB,IAAI,CAAC9pB,GAAG,CAAC;EACjD,MAAMsuC,SAAS,GAAG8/D,cAAc,CAAC9/D,SAAS,CAAClB,MAAM,CAACtjB,IAAI,CAACE,KAAK,CAAC;EAC7D,OAAO,IAAIqkB,eAAe,CAACrkB,KAAK,EAAEhqB,GAAG,EAAEsuC,SAAS,CAAC;AACnD;AACA,SAASmgE,+BAA+BA,CAACp4E,IAAI,EAAEosB,IAAI,EAAEr6C,IAAI,EAAE;EACzD,IAAIoqD,IAAI,GAAG,IAAI;EACf,KAAK,MAAMt2D,KAAK,IAAIkM,IAAI,CAACnM,QAAQ,EAAE;IACjC,IAAIC,KAAK,YAAY+6B,SAAS,IAAI/6B,KAAK,YAAY4gC,gBAAgB,EAAE;MACnE;IACF;IACA,IAAI01B,IAAI,KAAK,IAAI,EAAE;MACjB,OAAO,IAAI;IACb;IACA,IAAIt2D,KAAK,YAAYk8B,SAAS,IAAIl8B,KAAK,YAAYohC,QAAQ,IAAIphC,KAAK,CAAC0W,OAAO,KAAK,IAAI,EAAE;MACrF4/C,IAAI,GAAGt2D,KAAK;IACd,CAAC,MAAM;MACL,OAAO,IAAI;IACb;EACF;EACA,IAAIs2D,IAAI,KAAK,IAAI,EAAE;IACjB,KAAK,MAAM59D,IAAI,IAAI49D,IAAI,CAACl6B,UAAU,EAAE;MAClC,IAAI,CAAC1jC,IAAI,CAACa,IAAI,CAACsvB,UAAU,CAACymF,gBAAgB,CAAC,EAAE;QAC3C,MAAMp1E,eAAe,GAAGk1E,SAAS,CAACl1E,eAAe,CAACm1E,oBAAoB,EAAE32G,IAAI,CAACa,IAAI,EAAE,IAAI,CAAC;QACxF4gC,IAAI,CAACq/B,MAAM,CAAC9hE,IAAI,CAACqvD,eAAe,CAACR,IAAI,EAAExB,WAAW,CAACsD,SAAS,EAAE3vD,IAAI,CAACa,IAAI,EAAE4c,OAAO,CAACzd,IAAI,CAACc,KAAK,CAAC,EAAE,IAAI,EAAE0gC,eAAe,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE83E,SAAS,CAACt5G,IAAI,CAAC8nB,IAAI,CAAC,EAAE9nB,IAAI,CAACiP,UAAU,CAAC,CAAC;MACjL;IACF;IACA,KAAK,MAAMjP,IAAI,IAAI49D,IAAI,CAACj6B,MAAM,EAAE;MAC9B,IAAI3jC,IAAI,CAAC8H,IAAI,KAAKw5B,WAAW,CAACgC,eAAe,IAAItjC,IAAI,CAAC8H,IAAI,KAAKw5B,WAAW,CAAC+zB,SAAS,IAAIr1D,IAAI,CAAC8H,IAAI,KAAKw5B,WAAW,CAACquB,SAAS,EAAE;QAC3H,MAAMnuB,eAAe,GAAGk1E,SAAS,CAACl1E,eAAe,CAACm1E,oBAAoB,EAAE32G,IAAI,CAACa,IAAI,EAAE,IAAI,CAAC;QACxF4gC,IAAI,CAACo/B,MAAM,CAAC7hE,IAAI,CAACq9D,0BAA0B,CAACxO,IAAI,EAAExB,WAAW,CAACrZ,QAAQ,EAAE,IAAI,EAAEhzC,IAAI,CAACa,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE2gC,eAAe,CAAC,CAAC;MAC9H;IACF;IACA,MAAMxjB,OAAO,GAAG4/C,IAAI,YAAYp6B,SAAS,GAAGo6B,IAAI,CAAC/8D,IAAI,GAAG+8D,IAAI,CAAC5/C,OAAO;IACpE,OAAOA,OAAO,KAAK24F,oBAAoB,GAAG,IAAI,GAAG34F,OAAO;EAC1D;EACA,OAAO,IAAI;AACb;AAEA,IAAIo/F,gCAAgC,GAAG,KAAK;AAC5C,SAASC,gCAAgCA,CAACv8G,KAAK,EAAE;EAC/Cs8G,gCAAgC,GAAGt8G,KAAK;AAC1C;AACA,SAASw8G,iCAAiCA,CAAA,EAAG;EAC3C,OAAOF,gCAAgC;AACzC;AAEA,SAASG,qBAAqBA,CAACjpG,KAAK,EAAE0D,UAAU,EAAE;EAChD,OAAOqF,MAAM,CAACb,QAAQ,CAAC40B,YAAY,CAAC,CAAC1/B,UAAU,CAAC+L,OAAO,CAACnJ,KAAK,CAAC,EAAE,IAAI,CAAC,EAAE0D,UAAU,CAAC;AACpF;AACA,SAASwlG,YAAYA,CAACC,KAAK,EAAE;EAC3B,OAAO,CAACA,KAAK,CAACC,WAAW,GAAG,CAAC,GAAG,CAAC,KAAKD,KAAK,CAACE,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC,IAAIF,KAAK,CAACG,uBAAuB,GAAG,CAAC,GAAG,CAAC,CAAC;AACvG;AACA,SAASC,iBAAiBA,CAACJ,KAAK,EAAEzG,YAAY,EAAE;EAC9C,IAAI1+F,KAAK,CAACC,OAAO,CAACklG,KAAK,CAACzmC,SAAS,CAAC,EAAE;IAClC,IAAIA,SAAS,GAAG,EAAE;IAClBymC,KAAK,CAACzmC,SAAS,CAAC/1E,OAAO,CAACvC,QAAQ,IAAI;MAClC,MAAMkF,SAAS,GAAGlF,QAAQ,CAACmxB,KAAK,CAAC,GAAG,CAAC,CAAC3sB,GAAG,CAACksB,KAAK,IAAI3R,OAAO,CAAC2R,KAAK,CAACX,IAAI,CAAC,CAAC,CAAC,CAAC;MACzEuoD,SAAS,CAACh4E,IAAI,CAAC,GAAG4E,SAAS,CAAC;IAC9B,CAAC,CAAC;IACF,OAAOozG,YAAY,CAAC93F,eAAe,CAACnC,UAAU,CAACi6D,SAAS,CAAC,EAAE,IAAI,CAAC;EAClE,CAAC,MAAM;IACL,QAAQymC,KAAK,CAACzmC,SAAS,CAACjuD,UAAU;MAChC,KAAK,CAAC;MACN,KAAK,CAAC;QACJ,OAAO00F,KAAK,CAACzmC,SAAS,CAACnvE,UAAU;MACnC,KAAK,CAAC;QACJ,OAAO4U,UAAU,CAACwE,WAAW,CAAC+H,iBAAiB,CAAC,CAAC1Z,MAAM,CAAC,CAACmuG,KAAK,CAACzmC,SAAS,CAACnvE,UAAU,CAAC,CAAC;IACzF;EACF;AACF;AACA,SAASi2G,qBAAqBA,CAACL,KAAK,EAAEzG,YAAY,EAAE+G,YAAY,EAAEC,aAAa,EAAE;EAC/E,MAAMp9F,UAAU,GAAG,EAAE;EACrB,IAAIo9F,aAAa,KAAKpvF,SAAS,EAAE;IAC/BhO,UAAU,CAAC5hB,IAAI,CAAC,GAAGg/G,aAAa,CAAC;EACnC;EACA,IAAIP,KAAK,CAACtrE,QAAQ,EAAE;IAClBvxB,UAAU,CAAC5hB,IAAI,CAAC,IAAImQ,YAAY,CAACqN,QAAQ,CAAC20B,YAAY,CAAC,EAAEssE,KAAK,CAACvnB,YAAY,CAAC,CAAC;EAC/E;EACAt1E,UAAU,CAAC5hB,IAAI,CAAC6+G,iBAAiB,CAACJ,KAAK,EAAEzG,YAAY,CAAC,EAAEv5F,OAAO,CAAC+/F,YAAY,CAACC,KAAK,CAAC,CAAC,CAAC;EACrF,IAAIA,KAAK,CAACzzC,IAAI,EAAE;IACdppD,UAAU,CAAC5hB,IAAI,CAACy+G,KAAK,CAACzzC,IAAI,CAAC;EAC7B;EACA,MAAMi0C,aAAa,GAAGR,KAAK,CAACtrE,QAAQ,GAAG4rE,YAAY,CAACG,WAAW,GAAGH,YAAY,CAACI,SAAS;EACxF,OAAO1hG,UAAU,CAACwhG,aAAa,CAAC,CAAC3uG,MAAM,CAACsR,UAAU,CAAC;AACrD;AACA,MAAMw9F,uBAAuB,GAAGtxD,MAAM,CAAC,yBAAyB,CAAC;AACjE,SAASuxD,yBAAyBA,CAACrmG,UAAU,EAAE;EAC7C,MAAM/X,MAAM,GAAG,EAAE;EACjB,IAAIq+G,oBAAoB,GAAG,CAAC;EAC5B,MAAMC,iBAAiB,GAAGA,CAAA,KAAM;IAC9B,IAAID,oBAAoB,GAAG,CAAC,EAAE;MAC5Br+G,MAAM,CAACu+G,OAAO,CAAC/hG,UAAU,CAACwE,WAAW,CAAC0K,YAAY,CAAC,CAACrc,MAAM,CAACgvG,oBAAoB,KAAK,CAAC,GAAG,EAAE,GAAG,CAAC7gG,OAAO,CAAC6gG,oBAAoB,CAAC,CAAC,CAAC,CAAC5rG,MAAM,CAAC,CAAC,CAAC;MACvI4rG,oBAAoB,GAAG,CAAC;IAC1B;EACF,CAAC;EACD,KAAK,IAAIn+G,CAAC,GAAG6X,UAAU,CAACjZ,MAAM,GAAG,CAAC,EAAEoB,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC/C,MAAMmqE,EAAE,GAAGtyD,UAAU,CAAC7X,CAAC,CAAC;IACxB,IAAImqE,EAAE,KAAK8zC,uBAAuB,EAAE;MAClCE,oBAAoB,EAAE;IACxB,CAAC,MAAM;MACLC,iBAAiB,CAAC,CAAC;MACnBt+G,MAAM,CAACu+G,OAAO,CAACl0C,EAAE,CAAC;IACpB;EACF;EACAi0C,iBAAiB,CAAC,CAAC;EACnB,OAAOt+G,MAAM;AACf;AACA,SAASw+G,yBAAyBA,CAACC,WAAW,EAAE1H,YAAY,EAAEn2G,IAAI,EAAE;EAClE,MAAMs1G,gBAAgB,GAAG,EAAE;EAC3B,MAAMC,gBAAgB,GAAG,EAAE;EAC3B,MAAMuI,aAAa,GAAGttE,kBAAkB,CAACi5B,EAAE,IAAI8rC,gBAAgB,CAACp3G,IAAI,CAACsrE,EAAE,CAAC,EAAEp5B,cAAc,CAAC;EACzFwtE,WAAW,CAACz9G,OAAO,CAACw8G,KAAK,IAAI;IAC3B,MAAMmB,mBAAmB,GAAGd,qBAAqB,CAACL,KAAK,EAAEzG,YAAY,EAAE;MACrEkH,WAAW,EAAEj9F,WAAW,CAACwK,eAAe;MACxC0yF,SAAS,EAAEl9F,WAAW,CAACqK;IACzB,CAAC,CAAC;IACF6qF,gBAAgB,CAACn3G,IAAI,CAAC4/G,mBAAmB,CAAClsG,MAAM,CAAC,CAAC,CAAC;IACnD,IAAI+qG,KAAK,CAACtrE,QAAQ,EAAE;MAClBikE,gBAAgB,CAACp3G,IAAI,CAACo/G,uBAAuB,CAAC;MAC9C;IACF;IACA,MAAMS,SAAS,GAAGF,aAAa,CAAC,CAAC;IACjC,MAAMG,YAAY,GAAGriG,UAAU,CAACwE,WAAW,CAACsK,SAAS,CAAC,CAACjc,MAAM,CAAC,EAAE,CAAC;IACjE,MAAMyvG,OAAO,GAAGtiG,UAAU,CAACwE,WAAW,CAACoK,YAAY,CAAC,CAAC/b,MAAM,CAAC,CAACuvG,SAAS,CAAC97G,GAAG,CAAC+7G,YAAY,CAAC,CAAC,CAAC;IAC1F,MAAME,eAAe,GAAGxiG,QAAQ,CAAC20B,YAAY,CAAC,CAACjiC,IAAI,CAACuuG,KAAK,CAACvnB,YAAY,CAAC,CAACnzF,GAAG,CAAC06G,KAAK,CAACllD,KAAK,GAAGsmD,SAAS,CAAC3vG,IAAI,CAAC,OAAO,CAAC,GAAG2vG,SAAS,CAAC;IAC9HzI,gBAAgB,CAACp3G,IAAI,CAAC+/G,OAAO,CAACztG,GAAG,CAAC0tG,eAAe,CAAC,CAACtsG,MAAM,CAAC,CAAC,CAAC;EAC9D,CAAC,CAAC;EACF,MAAMusG,eAAe,GAAGp+G,IAAI,GAAG,GAAGA,IAAI,QAAQ,GAAG,IAAI;EACrD,OAAO6S,EAAE,CAAC,CAAC,IAAImE,OAAO,CAACu5B,YAAY,EAAErjC,WAAW,CAAC,EAAE,IAAI8J,OAAO,CAACs5B,YAAY,EAAE,IAAI,CAAC,CAAC,EAAE,CAACosE,qBAAqB,CAAC,CAAC,EAAEpH,gBAAgB,CAAC,EAAEoH,qBAAqB,CAAC,CAAC,EAAEc,yBAAyB,CAACjI,gBAAgB,CAAC,CAAC,CAAC,EAAE3oG,aAAa,EAAE,IAAI,EAAEwxG,eAAe,CAAC;AACjP;AACA,SAASC,4BAA4BA,CAACC,OAAO,EAAEnI,YAAY,EAAEn2G,IAAI,EAAE;EACjE,MAAMs1G,gBAAgB,GAAG,EAAE;EAC3B,MAAMC,gBAAgB,GAAG,EAAE;EAC3B,MAAMuI,aAAa,GAAGttE,kBAAkB,CAACi5B,EAAE,IAAI8rC,gBAAgB,CAACp3G,IAAI,CAACsrE,EAAE,CAAC,EAAEp5B,cAAc,CAAC;EACzF,KAAK,MAAMusE,KAAK,IAAI0B,OAAO,EAAE;IAC3BhJ,gBAAgB,CAACn3G,IAAI,CAAC8+G,qBAAqB,CAACL,KAAK,EAAEzG,YAAY,EAAE;MAC/DmH,SAAS,EAAEl9F,WAAW,CAACuK,YAAY;MACnC0yF,WAAW,EAAEj9F,WAAW,CAACyK;IAC3B,CAAC,EAAE,CAAClP,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC9J,MAAM,CAAC,CAAC,CAAC;IACpC,IAAI+qG,KAAK,CAACtrE,QAAQ,EAAE;MAClBikE,gBAAgB,CAACp3G,IAAI,CAACo/G,uBAAuB,CAAC;MAC9C;IACF;IACA,MAAMS,SAAS,GAAGF,aAAa,CAAC,CAAC;IACjC,MAAMG,YAAY,GAAGriG,UAAU,CAACwE,WAAW,CAACsK,SAAS,CAAC,CAACjc,MAAM,CAAC,EAAE,CAAC;IACjE,MAAMyvG,OAAO,GAAGtiG,UAAU,CAACwE,WAAW,CAACoK,YAAY,CAAC,CAAC/b,MAAM,CAAC,CAACuvG,SAAS,CAAC97G,GAAG,CAAC+7G,YAAY,CAAC,CAAC,CAAC;IAC1F,MAAME,eAAe,GAAGxiG,QAAQ,CAAC20B,YAAY,CAAC,CAACjiC,IAAI,CAACuuG,KAAK,CAACvnB,YAAY,CAAC,CAACnzF,GAAG,CAAC06G,KAAK,CAACllD,KAAK,GAAGsmD,SAAS,CAAC3vG,IAAI,CAAC,OAAO,CAAC,GAAG2vG,SAAS,CAAC;IAC9HzI,gBAAgB,CAACp3G,IAAI,CAAC+/G,OAAO,CAACztG,GAAG,CAAC0tG,eAAe,CAAC,CAACtsG,MAAM,CAAC,CAAC,CAAC;EAC9D;EACA,MAAM0sG,oBAAoB,GAAGv+G,IAAI,GAAG,GAAGA,IAAI,iBAAiB,GAAG,IAAI;EACnE,OAAO6S,EAAE,CAAC,CAAC,IAAImE,OAAO,CAACu5B,YAAY,EAAErjC,WAAW,CAAC,EAAE,IAAI8J,OAAO,CAACs5B,YAAY,EAAE,IAAI,CAAC,EAAE,IAAIt5B,OAAO,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC,EAAE,CAAC0lG,qBAAqB,CAAC,CAAC,EAAEpH,gBAAgB,CAAC,EAAEoH,qBAAqB,CAAC,CAAC,EAAEc,yBAAyB,CAACjI,gBAAgB,CAAC,CAAC,CAAC,EAAE3oG,aAAa,EAAE,IAAI,EAAE2xG,oBAAoB,CAAC;AACrR;AAEA,MAAMC,UAAU,SAASpiC,QAAQ,CAAC;EAChCp5E,WAAWA,CAAA,EAAG;IACZ,KAAK,CAACi1F,oBAAoB,CAAC;EAC7B;EACAr6F,KAAKA,CAAC02B,MAAM,EAAE3d,GAAG,EAAE2tB,OAAO,EAAE;IAC1B,OAAO,KAAK,CAAC1mC,KAAK,CAAC02B,MAAM,EAAE3d,GAAG,EAAE2tB,OAAO,CAAC;EAC1C;AACF;AAEA,MAAMm6E,wBAAwB,GAAG,GAAG;AACpC,MAAMC,gBAAgB,GAAG,MAAM;AAC/B,MAAMC,cAAc,GAAG,SAAS;AAChC,MAAMC,YAAY,GAAG,OAAO;AAC5B,MAAMC,YAAY,GAAG,OAAO;AAC5B,MAAMC,sBAAsB,GAAG,GAAG;AAClC,MAAMC,0BAA0B,GAAG,UAAU;AAC7C,MAAMC,aAAa,CAAC;EAClBC,WAAW;EACXC,eAAe;EACf9/E,MAAM;EACNp8B,WAAWA,CAACi8G,WAAW,EAAEC,eAAe,EAAE9/E,MAAM,EAAE;IAChD,IAAI,CAAC6/E,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,eAAe,GAAGA,eAAe;IACtC,IAAI,CAAC9/E,MAAM,GAAGA,MAAM;EACtB;EACA+/E,yBAAyBA,CAACrpB,UAAU,EAAE1nF,UAAU,EAAE;IAChD,MAAMgxG,UAAU,GAAG,EAAE;IACrB,KAAK,MAAMhpB,QAAQ,IAAI1xF,MAAM,CAACmC,IAAI,CAACivF,UAAU,CAAC,EAAE;MAC9C,MAAM9uF,UAAU,GAAG8uF,UAAU,CAACM,QAAQ,CAAC;MACvC,IAAI,OAAOpvF,UAAU,KAAK,QAAQ,EAAE;QAClC,IAAI,CAACq4G,oBAAoB,CAACjpB,QAAQ,EAAEpvF,UAAU,EAAE,IAAI,EAAE,KAAK,EAAEoH,UAAU,EAAEA,UAAU,CAACmmB,KAAK,CAACmjB,MAAM,EAAE3pB,SAAS,EAAE,EAAE,EAAEqxF,UAAU,EAAEhxG,UAAU,CAAC;MAC1I,CAAC,MAAM;QACL,IAAI,CAAC8vF,YAAY,CAAC,uCAAuC9H,QAAQ,8DAA8DpvF,UAAU,MAAM,OAAOA,UAAU,GAAG,EAAEoH,UAAU,CAAC;MAClL;IACF;IACA,OAAOgxG,UAAU;EACnB;EACAE,4BAA4BA,CAACC,aAAa,EAAEnxG,UAAU,EAAE;IACtD,MAAMoxG,YAAY,GAAG,EAAE;IACvB,KAAK,MAAMppB,QAAQ,IAAI1xF,MAAM,CAACmC,IAAI,CAAC04G,aAAa,CAAC,EAAE;MACjD,MAAMv4G,UAAU,GAAGu4G,aAAa,CAACnpB,QAAQ,CAAC;MAC1C,IAAI,OAAOpvF,UAAU,KAAK,QAAQ,EAAE;QAClC,IAAI,CAACy4G,UAAU,CAACrpB,QAAQ,EAAEpvF,UAAU,EAAE,KAAK,EAAEoH,UAAU,EAAEA,UAAU,EAAE,EAAE,EAAEoxG,YAAY,EAAEpxG,UAAU,CAAC;MACpG,CAAC,MAAM;QACL,IAAI,CAAC8vF,YAAY,CAAC,+BAA+B9H,QAAQ,8DAA8DpvF,UAAU,MAAM,OAAOA,UAAU,GAAG,EAAEoH,UAAU,CAAC;MAC1K;IACF;IACA,OAAOoxG,YAAY;EACrB;EACA7zB,kBAAkBA,CAAC1rF,KAAK,EAAEmO,UAAU,EAAEw9E,kBAAkB,EAAE;IACxD,MAAMnxD,cAAc,GAAGrsB,UAAU,CAACyqC,SAAS,CAACnB,MAAM;IAClD,IAAI;MACF,MAAMr8B,GAAG,GAAG,IAAI,CAAC4jG,WAAW,CAACtzB,kBAAkB,CAAC1rF,KAAK,EAAEmO,UAAU,EAAEqsB,cAAc,EAAEmxD,kBAAkB,CAAC;MACtG,IAAIvwE,GAAG,EAAE;QACP,IAAI,CAAC+jB,MAAM,CAACjhC,IAAI,CAAC,GAAGkd,GAAG,CAAC+jB,MAAM,CAAC;MACjC;MACA,OAAO/jB,GAAG;IACZ,CAAC,CAAC,OAAO5S,CAAC,EAAE;MACV,IAAI,CAACy1F,YAAY,CAAC,GAAGz1F,CAAC,EAAE,EAAE2F,UAAU,CAAC;MACrC,OAAO,IAAI,CAAC6wG,WAAW,CAACjyB,oBAAoB,CAAC,OAAO,EAAE5+E,UAAU,EAAEqsB,cAAc,CAAC;IACnF;EACF;EACA0xD,4BAA4BA,CAACnlF,UAAU,EAAEoH,UAAU,EAAE;IACnD,MAAMqsB,cAAc,GAAGrsB,UAAU,CAACmmB,KAAK,CAACmjB,MAAM;IAC9C,IAAI;MACF,MAAMr8B,GAAG,GAAG,IAAI,CAAC4jG,WAAW,CAAC9yB,4BAA4B,CAACnlF,UAAU,EAAEoH,UAAU,EAAEqsB,cAAc,CAAC;MACjG,IAAIpf,GAAG,EAAE;QACP,IAAI,CAAC+jB,MAAM,CAACjhC,IAAI,CAAC,GAAGkd,GAAG,CAAC+jB,MAAM,CAAC;MACjC;MACA,OAAO/jB,GAAG;IACZ,CAAC,CAAC,OAAO5S,CAAC,EAAE;MACV,IAAI,CAACy1F,YAAY,CAAC,GAAGz1F,CAAC,EAAE,EAAE2F,UAAU,CAAC;MACrC,OAAO,IAAI,CAAC6wG,WAAW,CAACjyB,oBAAoB,CAAC,OAAO,EAAE5+E,UAAU,EAAEqsB,cAAc,CAAC;IACnF;EACF;EACAilF,0BAA0BA,CAACC,MAAM,EAAEC,QAAQ,EAAExxG,UAAU,EAAEs9E,mBAAmB,EAAEm0B,oBAAoB,EAAEC,WAAW,EAAEC,UAAU,EAAEC,QAAQ,EAAE;IACrI,MAAMv0B,iBAAiB,GAAGr9E,UAAU,CAACmmB,KAAK,CAACmjB,MAAM,GAAGonE,sBAAsB,CAAC5gH,MAAM;IACjF,MAAM2qC,QAAQ,GAAG,IAAI,CAACo3E,sBAAsB,CAACN,MAAM,EAAEC,QAAQ,EAAExxG,UAAU,EAAEq9E,iBAAiB,EAAEC,mBAAmB,CAAC;IAClH,KAAK,MAAM8G,OAAO,IAAI3pD,QAAQ,EAAE;MAC9B,MAAMq3E,WAAW,GAAGC,mBAAmB,CAAC/xG,UAAU,EAAEokF,OAAO,CAACpkF,UAAU,CAAC;MACvE,MAAMG,GAAG,GAAGikF,OAAO,CAACjkF,GAAG,CAAC+lB,MAAM;MAC9B,MAAMqL,OAAO,GAAGwgF,mBAAmB,CAAC/xG,UAAU,EAAEokF,OAAO,CAACjkF,GAAG,CAAC8lB,IAAI,CAAC;MACjE,IAAIm+D,OAAO,YAAYlzD,eAAe,EAAE;QACtC,MAAMr/B,KAAK,GAAGuyF,OAAO,CAACvyF,KAAK,GAAGuyF,OAAO,CAACvyF,KAAK,CAACq0B,MAAM,GAAG,WAAW;QAChE,MAAMsL,SAAS,GAAG4yD,OAAO,CAACvyF,KAAK,GAAGkgH,mBAAmB,CAAC/xG,UAAU,EAAEokF,OAAO,CAACvyF,KAAK,CAACo0B,IAAI,CAAC,GAAGtG,SAAS;QACjGgyF,UAAU,CAAC5hH,IAAI,CAAC,IAAIqiC,cAAc,CAACjyB,GAAG,EAAEtO,KAAK,EAAEigH,WAAW,EAAEvgF,OAAO,EAAEC,SAAS,CAAC,CAAC;MAClF,CAAC,MAAM,IAAI4yD,OAAO,CAACvyF,KAAK,EAAE;QACxB,MAAMmgH,OAAO,GAAGJ,QAAQ,GAAGE,WAAW,GAAG9xG,UAAU;QACnD,MAAMwxB,SAAS,GAAGugF,mBAAmB,CAAC/xG,UAAU,EAAEokF,OAAO,CAACvyF,KAAK,CAACob,GAAG,CAACjN,UAAU,CAAC;QAC/E,IAAI,CAACiyG,iBAAiB,CAAC9xG,GAAG,EAAEikF,OAAO,CAACvyF,KAAK,EAAE,KAAK,EAAEmgH,OAAO,EAAEzgF,OAAO,EAAEC,SAAS,EAAEigF,oBAAoB,EAAEC,WAAW,CAAC;MACnH,CAAC,MAAM;QACLD,oBAAoB,CAAC1hH,IAAI,CAAC,CAACoQ,GAAG,EAAE,EAAE,CAAC,CAAC;QACpC,IAAI,CAAC+xG,gBAAgB,CAAC/xG,GAAG,EAAE,IAAI,EAAEoxB,OAAO,EAAE+rD,mBAAmB,EAAE39D,SAAS,EAAE8xF,oBAAoB,EAAEC,WAAW,EAAEngF,OAAO,CAAC;MACvH;IACF;EACF;EACAsgF,sBAAsBA,CAACN,MAAM,EAAEC,QAAQ,EAAExxG,UAAU,EAAEq9E,iBAAiB,EAAEC,mBAAmB,EAAE;IAC3F,IAAI;MACF,MAAM60B,cAAc,GAAG,IAAI,CAACtB,WAAW,CAAC1zB,qBAAqB,CAACo0B,MAAM,EAAEC,QAAQ,EAAExxG,UAAU,EAAEq9E,iBAAiB,EAAEC,mBAAmB,CAAC;MACnI60B,cAAc,CAACnhF,MAAM,CAACh/B,OAAO,CAACqI,CAAC,IAAI,IAAI,CAAC22B,MAAM,CAACjhC,IAAI,CAACsK,CAAC,CAAC,CAAC;MACvD83G,cAAc,CAACp2B,QAAQ,CAAC/pF,OAAO,CAACogH,OAAO,IAAI;QACzC,IAAI,CAACtiB,YAAY,CAACsiB,OAAO,EAAEpyG,UAAU,EAAE2qC,eAAe,CAAC0nE,OAAO,CAAC;MACjE,CAAC,CAAC;MACF,OAAOF,cAAc,CAACr2B,gBAAgB;IACxC,CAAC,CAAC,OAAOzhF,CAAC,EAAE;MACV,IAAI,CAACy1F,YAAY,CAAC,GAAGz1F,CAAC,EAAE,EAAE2F,UAAU,CAAC;MACrC,OAAO,EAAE;IACX;EACF;EACAkyG,gBAAgBA,CAACtgH,IAAI,EAAEC,KAAK,EAAEmO,UAAU,EAAEqsB,cAAc,EAAEmF,SAAS,EAAEigF,oBAAoB,EAAEC,WAAW,EAAEngF,OAAO,EAAE;IAC/G,IAAI+gF,sBAAsB,CAAC1gH,IAAI,CAAC,EAAE;MAChCA,IAAI,GAAGA,IAAI,CAAC+3C,SAAS,CAAC,CAAC,CAAC;MACxB,IAAIpY,OAAO,KAAK5R,SAAS,EAAE;QACzB4R,OAAO,GAAGwgF,mBAAmB,CAACxgF,OAAO,EAAE,IAAIjF,kBAAkB,CAACiF,OAAO,CAACpL,KAAK,CAACmjB,MAAM,GAAG,CAAC,EAAE/X,OAAO,CAACp1B,GAAG,CAACmtC,MAAM,CAAC,CAAC;MAC9G;MACA,IAAIz3C,KAAK,EAAE;QACT,IAAI,CAACi+F,YAAY,CAAC,wFAAwF,GAAG,uGAAuG,EAAE9vF,UAAU,EAAE2qC,eAAe,CAACI,KAAK,CAAC;MAC1P;MACA,IAAI,CAACwnE,qBAAqB,CAAC3gH,IAAI,EAAEC,KAAK,EAAEmO,UAAU,EAAEqsB,cAAc,EAAEkF,OAAO,EAAEC,SAAS,EAAEigF,oBAAoB,EAAEC,WAAW,CAAC;IAC5H,CAAC,MAAM;MACLA,WAAW,CAAC3hH,IAAI,CAAC,IAAIuhC,cAAc,CAAC1/B,IAAI,EAAE,IAAI,CAACi/G,WAAW,CAACjyB,oBAAoB,CAAC/sF,KAAK,EAAE,EAAE,EAAEw6B,cAAc,CAAC,EAAEuF,kBAAkB,CAACC,YAAY,EAAE7xB,UAAU,EAAEuxB,OAAO,EAAEC,SAAS,CAAC,CAAC;IAC/K;EACF;EACAy/E,oBAAoBA,CAACr/G,IAAI,EAAEgH,UAAU,EAAE45G,MAAM,EAAEC,yBAAyB,EAAEzyG,UAAU,EAAEqsB,cAAc,EAAEmF,SAAS,EAAEigF,oBAAoB,EAAEC,WAAW,EAAEngF,OAAO,EAAE;IAC3J,IAAI3/B,IAAI,CAAC9B,MAAM,KAAK,CAAC,EAAE;MACrB,IAAI,CAACggG,YAAY,CAAC,qCAAqC,EAAE9vF,UAAU,CAAC;IACtE;IACA,IAAI0yG,qBAAqB,GAAG,KAAK;IACjC,IAAI9gH,IAAI,CAACsvB,UAAU,CAACyvF,0BAA0B,CAAC,EAAE;MAC/C+B,qBAAqB,GAAG,IAAI;MAC5B9gH,IAAI,GAAGA,IAAI,CAAC+3C,SAAS,CAACgnE,0BAA0B,CAAC7gH,MAAM,CAAC;MACxD,IAAIyhC,OAAO,KAAK5R,SAAS,EAAE;QACzB4R,OAAO,GAAGwgF,mBAAmB,CAACxgF,OAAO,EAAE,IAAIjF,kBAAkB,CAACiF,OAAO,CAACpL,KAAK,CAACmjB,MAAM,GAAGqnE,0BAA0B,CAAC7gH,MAAM,EAAEyhC,OAAO,CAACp1B,GAAG,CAACmtC,MAAM,CAAC,CAAC;MAC9I;IACF,CAAC,MAAM,IAAIgpE,sBAAsB,CAAC1gH,IAAI,CAAC,EAAE;MACvC8gH,qBAAqB,GAAG,IAAI;MAC5B9gH,IAAI,GAAGA,IAAI,CAAC+3C,SAAS,CAAC,CAAC,CAAC;MACxB,IAAIpY,OAAO,KAAK5R,SAAS,EAAE;QACzB4R,OAAO,GAAGwgF,mBAAmB,CAACxgF,OAAO,EAAE,IAAIjF,kBAAkB,CAACiF,OAAO,CAACpL,KAAK,CAACmjB,MAAM,GAAG,CAAC,EAAE/X,OAAO,CAACp1B,GAAG,CAACmtC,MAAM,CAAC,CAAC;MAC9G;IACF;IACA,IAAIopE,qBAAqB,EAAE;MACzB,IAAI,CAACH,qBAAqB,CAAC3gH,IAAI,EAAEgH,UAAU,EAAEoH,UAAU,EAAEqsB,cAAc,EAAEkF,OAAO,EAAEC,SAAS,EAAEigF,oBAAoB,EAAEC,WAAW,CAAC;IACjI,CAAC,MAAM,IAAI9/G,IAAI,CAACsvB,UAAU,CAAC,GAAGqvF,cAAc,GAAGF,wBAAwB,EAAE,CAAC,EAAE;MAC1E,IAAI,CAACsC,eAAe,CAAC/gH,IAAI,EAAE,IAAI,CAAC+qF,YAAY,CAAC/jF,UAAU,EAAE45G,MAAM,EAAEhhF,SAAS,IAAIxxB,UAAU,EAAEqsB,cAAc,CAAC,EAAErsB,UAAU,EAAEuxB,OAAO,EAAEC,SAAS,EAAEigF,oBAAoB,EAAEC,WAAW,CAAC;IAC/K,CAAC,MAAM;MACL,IAAI,CAACO,iBAAiB,CAACrgH,IAAI,EAAE,IAAI,CAAC+qF,YAAY,CAAC/jF,UAAU,EAAE45G,MAAM,EAAEhhF,SAAS,IAAIxxB,UAAU,EAAEqsB,cAAc,CAAC,EAAEomF,yBAAyB,EAAEzyG,UAAU,EAAEuxB,OAAO,EAAEC,SAAS,EAAEigF,oBAAoB,EAAEC,WAAW,CAAC;IAC5M;EACF;EACAkB,0BAA0BA,CAAChhH,IAAI,EAAEC,KAAK,EAAEmO,UAAU,EAAEwxB,SAAS,EAAEigF,oBAAoB,EAAEC,WAAW,EAAEngF,OAAO,EAAEisD,kBAAkB,EAAE;IAC7H,MAAMt5E,IAAI,GAAG,IAAI,CAACq5E,kBAAkB,CAAC1rF,KAAK,EAAE2/B,SAAS,IAAIxxB,UAAU,EAAEw9E,kBAAkB,CAAC;IACxF,IAAIt5E,IAAI,EAAE;MACR,IAAI,CAAC+tG,iBAAiB,CAACrgH,IAAI,EAAEsS,IAAI,EAAE,KAAK,EAAElE,UAAU,EAAEuxB,OAAO,EAAEC,SAAS,EAAEigF,oBAAoB,EAAEC,WAAW,CAAC;MAC5G,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd;EACAO,iBAAiBA,CAACrgH,IAAI,EAAEqb,GAAG,EAAEwlG,yBAAyB,EAAEzyG,UAAU,EAAEuxB,OAAO,EAAEC,SAAS,EAAEigF,oBAAoB,EAAEC,WAAW,EAAE;IACzHD,oBAAoB,CAAC1hH,IAAI,CAAC,CAAC6B,IAAI,EAAEqb,GAAG,CAACiZ,MAAM,CAAC,CAAC;IAC7CwrF,WAAW,CAAC3hH,IAAI,CAAC,IAAIuhC,cAAc,CAAC1/B,IAAI,EAAEqb,GAAG,EAAEwlG,yBAAyB,GAAG7gF,kBAAkB,CAACihF,OAAO,GAAGjhF,kBAAkB,CAACkhF,OAAO,EAAE9yG,UAAU,EAAEuxB,OAAO,EAAEC,SAAS,CAAC,CAAC;EACtK;EACAmhF,eAAeA,CAAC/gH,IAAI,EAAEqb,GAAG,EAAEjN,UAAU,EAAEuxB,OAAO,EAAEC,SAAS,EAAEigF,oBAAoB,EAAEC,WAAW,EAAE;IAC5FD,oBAAoB,CAAC1hH,IAAI,CAAC,CAAC6B,IAAI,EAAEqb,GAAG,CAACiZ,MAAM,CAAC,CAAC;IAC7CwrF,WAAW,CAAC3hH,IAAI,CAAC,IAAIuhC,cAAc,CAAC1/B,IAAI,EAAEqb,GAAG,EAAE2kB,kBAAkB,CAACG,SAAS,EAAE/xB,UAAU,EAAEuxB,OAAO,EAAEC,SAAS,CAAC,CAAC;EAC/G;EACA+gF,qBAAqBA,CAAC3gH,IAAI,EAAEgH,UAAU,EAAEoH,UAAU,EAAEqsB,cAAc,EAAEkF,OAAO,EAAEC,SAAS,EAAEigF,oBAAoB,EAAEC,WAAW,EAAE;IACzH,IAAI9/G,IAAI,CAAC9B,MAAM,KAAK,CAAC,EAAE;MACrB,IAAI,CAACggG,YAAY,CAAC,8BAA8B,EAAE9vF,UAAU,CAAC;IAC/D;IACA,MAAMiN,GAAG,GAAG,IAAI,CAAC0vE,YAAY,CAAC/jF,UAAU,IAAI,WAAW,EAAE,KAAK,EAAE44B,SAAS,IAAIxxB,UAAU,EAAEqsB,cAAc,CAAC;IACxGolF,oBAAoB,CAAC1hH,IAAI,CAAC,CAAC6B,IAAI,EAAEqb,GAAG,CAACiZ,MAAM,CAAC,CAAC;IAC7CwrF,WAAW,CAAC3hH,IAAI,CAAC,IAAIuhC,cAAc,CAAC1/B,IAAI,EAAEqb,GAAG,EAAE2kB,kBAAkB,CAACE,gBAAgB,EAAE9xB,UAAU,EAAEuxB,OAAO,EAAEC,SAAS,CAAC,CAAC;EACtH;EACAmrD,YAAYA,CAAC9qF,KAAK,EAAEkhH,aAAa,EAAE/yG,UAAU,EAAEqsB,cAAc,EAAE;IAC7D,IAAI;MACF,MAAMpf,GAAG,GAAG8lG,aAAa,GAAG,IAAI,CAAClC,WAAW,CAAC7zB,kBAAkB,CAACnrF,KAAK,EAAEmO,UAAU,EAAEqsB,cAAc,CAAC,GAAG,IAAI,CAACwkF,WAAW,CAACl0B,YAAY,CAAC9qF,KAAK,EAAEmO,UAAU,EAAEqsB,cAAc,CAAC;MACrK,IAAIpf,GAAG,EAAE;QACP,IAAI,CAAC+jB,MAAM,CAACjhC,IAAI,CAAC,GAAGkd,GAAG,CAAC+jB,MAAM,CAAC;MACjC;MACA,OAAO/jB,GAAG;IACZ,CAAC,CAAC,OAAO5S,CAAC,EAAE;MACV,IAAI,CAACy1F,YAAY,CAAC,GAAGz1F,CAAC,EAAE,EAAE2F,UAAU,CAAC;MACrC,OAAO,IAAI,CAAC6wG,WAAW,CAACjyB,oBAAoB,CAAC,OAAO,EAAE5+E,UAAU,EAAEqsB,cAAc,CAAC;IACnF;EACF;EACA2mF,0BAA0BA,CAACC,eAAe,EAAEC,SAAS,EAAEC,cAAc,GAAG,KAAK,EAAEC,eAAe,GAAG,IAAI,EAAE;IACrG,IAAIF,SAAS,CAACxhF,iBAAiB,EAAE;MAC/B,OAAO,IAAIY,oBAAoB,CAAC4gF,SAAS,CAACthH,IAAI,EAAEygC,WAAW,CAACgC,eAAe,EAAE1+B,eAAe,CAACi+D,IAAI,EAAEs/C,SAAS,CAACt6G,UAAU,EAAE,IAAI,EAAEs6G,SAAS,CAAClzG,UAAU,EAAEkzG,SAAS,CAAC3hF,OAAO,EAAE2hF,SAAS,CAAC1hF,SAAS,CAAC;IAC9L;IACA,IAAIgB,IAAI,GAAG,IAAI;IACf,IAAIq7E,WAAW,GAAGluF,SAAS;IAC3B,IAAI0zF,iBAAiB,GAAG,IAAI;IAC5B,MAAM37G,KAAK,GAAGw7G,SAAS,CAACthH,IAAI,CAACgvB,KAAK,CAACyvF,wBAAwB,CAAC;IAC5D,IAAIjI,gBAAgB,GAAGzoF,SAAS;IAChC,IAAIjoB,KAAK,CAAC5H,MAAM,GAAG,CAAC,EAAE;MACpB,IAAI4H,KAAK,CAAC,CAAC,CAAC,IAAI44G,gBAAgB,EAAE;QAChC+C,iBAAiB,GAAG37G,KAAK,CAAChH,KAAK,CAAC,CAAC,CAAC,CAACgB,IAAI,CAAC2+G,wBAAwB,CAAC;QACjE,IAAI,CAAC8C,cAAc,EAAE;UACnB,IAAI,CAACG,gCAAgC,CAACD,iBAAiB,EAAEH,SAAS,CAAClzG,UAAU,EAAE,IAAI,CAAC;QACtF;QACAooG,gBAAgB,GAAGC,4BAA4B,CAAC,IAAI,CAACyI,eAAe,EAAEmC,eAAe,EAAEI,iBAAiB,EAAE,IAAI,CAAC;QAC/G,MAAME,cAAc,GAAGF,iBAAiB,CAAC9zF,OAAO,CAAC,GAAG,CAAC;QACrD,IAAIg0F,cAAc,GAAG,CAAC,CAAC,EAAE;UACvB,MAAMC,EAAE,GAAGH,iBAAiB,CAAC1pE,SAAS,CAAC,CAAC,EAAE4pE,cAAc,CAAC;UACzD,MAAM3hH,IAAI,GAAGyhH,iBAAiB,CAAC1pE,SAAS,CAAC4pE,cAAc,GAAG,CAAC,CAAC;UAC5DF,iBAAiB,GAAGngF,cAAc,CAACsgF,EAAE,EAAE5hH,IAAI,CAAC;QAC9C;QACAi8G,WAAW,GAAGx7E,WAAW,CAACquB,SAAS;MACrC,CAAC,MAAM,IAAIhpD,KAAK,CAAC,CAAC,CAAC,IAAI84G,YAAY,EAAE;QACnC6C,iBAAiB,GAAG37G,KAAK,CAAC,CAAC,CAAC;QAC5Bm2G,WAAW,GAAGx7E,WAAW,CAAC/H,KAAK;QAC/B89E,gBAAgB,GAAG,CAACzyG,eAAe,CAACi+D,IAAI,CAAC;MAC3C,CAAC,MAAM,IAAIl8D,KAAK,CAAC,CAAC,CAAC,IAAI+4G,YAAY,EAAE;QACnCj+E,IAAI,GAAG96B,KAAK,CAAC5H,MAAM,GAAG,CAAC,GAAG4H,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI;QACzC27G,iBAAiB,GAAG37G,KAAK,CAAC,CAAC,CAAC;QAC5Bm2G,WAAW,GAAGx7E,WAAW,CAACg7E,KAAK;QAC/BjF,gBAAgB,GAAG,CAACzyG,eAAe,CAAC+9D,KAAK,CAAC;MAC5C,CAAC,MAAM,IAAIh8D,KAAK,CAAC,CAAC,CAAC,IAAI64G,cAAc,EAAE;QACrC8C,iBAAiB,GAAGH,SAAS,CAACthH,IAAI;QAClCi8G,WAAW,GAAGx7E,WAAW,CAAC+zB,SAAS;QACnCgiD,gBAAgB,GAAG,CAACzyG,eAAe,CAACi+D,IAAI,CAAC;MAC3C;IACF;IACA,IAAIy/C,iBAAiB,KAAK,IAAI,EAAE;MAC9B,MAAMI,cAAc,GAAG,IAAI,CAAC3C,eAAe,CAACxoB,iBAAiB,CAAC4qB,SAAS,CAACthH,IAAI,CAAC;MAC7EyhH,iBAAiB,GAAGD,eAAe,GAAGK,cAAc,GAAGP,SAAS,CAACthH,IAAI;MACrEw2G,gBAAgB,GAAGC,4BAA4B,CAAC,IAAI,CAACyI,eAAe,EAAEmC,eAAe,EAAEQ,cAAc,EAAE,KAAK,CAAC;MAC7G5F,WAAW,GAAGqF,SAAS,CAACr6G,IAAI,KAAK+4B,kBAAkB,CAACihF,OAAO,GAAGxgF,WAAW,CAAC2R,MAAM,GAAG3R,WAAW,CAAC0R,QAAQ;MACvG,IAAI,CAACovE,cAAc,EAAE;QACnB,IAAI,CAACG,gCAAgC,CAACG,cAAc,EAAEP,SAAS,CAAClzG,UAAU,EAAE,KAAK,CAAC;MACpF;IACF;IACA,OAAO,IAAIsyB,oBAAoB,CAAC+gF,iBAAiB,EAAExF,WAAW,EAAEzF,gBAAgB,CAAC,CAAC,CAAC,EAAE8K,SAAS,CAACt6G,UAAU,EAAE45B,IAAI,EAAE0gF,SAAS,CAAClzG,UAAU,EAAEkzG,SAAS,CAAC3hF,OAAO,EAAE2hF,SAAS,CAAC1hF,SAAS,CAAC;EAChL;EACA6/E,UAAUA,CAACz/G,IAAI,EAAEgH,UAAU,EAAE86G,iBAAiB,EAAE1zG,UAAU,EAAEmyB,WAAW,EAAEs/E,oBAAoB,EAAEL,YAAY,EAAE7/E,OAAO,EAAE;IACpH,IAAI3/B,IAAI,CAAC9B,MAAM,KAAK,CAAC,EAAE;MACrB,IAAI,CAACggG,YAAY,CAAC,kCAAkC,EAAE9vF,UAAU,CAAC;IACnE;IACA,IAAIsyG,sBAAsB,CAAC1gH,IAAI,CAAC,EAAE;MAChCA,IAAI,GAAGA,IAAI,CAAClB,KAAK,CAAC,CAAC,CAAC;MACpB,IAAI6gC,OAAO,KAAK5R,SAAS,EAAE;QACzB4R,OAAO,GAAGwgF,mBAAmB,CAACxgF,OAAO,EAAE,IAAIjF,kBAAkB,CAACiF,OAAO,CAACpL,KAAK,CAACmjB,MAAM,GAAG,CAAC,EAAE/X,OAAO,CAACp1B,GAAG,CAACmtC,MAAM,CAAC,CAAC;MAC9G;MACA,IAAI,CAACqqE,0BAA0B,CAAC/hH,IAAI,EAAEgH,UAAU,EAAEoH,UAAU,EAAEmyB,WAAW,EAAEi/E,YAAY,EAAE7/E,OAAO,CAAC;IACnG,CAAC,MAAM;MACL,IAAI,CAACqiF,kBAAkB,CAAChiH,IAAI,EAAEgH,UAAU,EAAE86G,iBAAiB,EAAE1zG,UAAU,EAAEmyB,WAAW,EAAEs/E,oBAAoB,EAAEL,YAAY,EAAE7/E,OAAO,CAAC;IACpI;EACF;EACA82E,4BAA4BA,CAAC54G,QAAQ,EAAEu4F,QAAQ,EAAEK,WAAW,EAAE;IAC5D,MAAMpoF,IAAI,GAAG,IAAI,CAAC6wG,eAAe,CAACxoB,iBAAiB,CAACN,QAAQ,CAAC;IAC7D,OAAOqgB,4BAA4B,CAAC,IAAI,CAACyI,eAAe,EAAErhH,QAAQ,EAAEwQ,IAAI,EAAEooF,WAAW,CAAC;EACxF;EACAwrB,sBAAsBA,CAACC,OAAO,EAAE;IAC9B,MAAM,CAAClqF,MAAM,EAAEmqF,SAAS,CAAC,GAAG90F,YAAY,CAAC60F,OAAO,EAAE,CAAC,IAAI,EAAEA,OAAO,CAAC,CAAC;IAClE,OAAO;MACLC,SAAS,EAAEA,SAAS;MACpBnqF;IACF,CAAC;EACH;EACAoqF,6BAA6BA,CAACF,OAAO,EAAE;IACrC,MAAMv7D,OAAO,GAAGn5B,aAAa,CAAC00F,OAAO,EAAE,CAACA,OAAO,EAAE,IAAI,CAAC,CAAC;IACvD,OAAO;MACLC,SAAS,EAAEx7D,OAAO,CAAC,CAAC,CAAC;MACrBtkB,KAAK,EAAEskB,OAAO,CAAC,CAAC,CAAC,KAAK,IAAI,GAAG,IAAI,GAAGA,OAAO,CAAC,CAAC,CAAC,CAACzmD,WAAW,CAAC;IAC7D,CAAC;EACH;EACA6hH,0BAA0BA,CAAC/hH,IAAI,EAAEgH,UAAU,EAAEoH,UAAU,EAAEmyB,WAAW,EAAEi/E,YAAY,EAAE7/E,OAAO,EAAE;IAC3F,MAAM;MACJwiF,SAAS;MACT9/E;IACF,CAAC,GAAG,IAAI,CAAC+/E,6BAA6B,CAACpiH,IAAI,CAAC;IAC5C,MAAMqb,GAAG,GAAG,IAAI,CAACgnG,YAAY,CAACr7G,UAAU,EAAEu5B,WAAW,CAAC;IACtDi/E,YAAY,CAACrhH,IAAI,CAAC,IAAIkiC,WAAW,CAAC8hF,SAAS,EAAE9/E,KAAK,EAAEjC,eAAe,CAACqC,eAAe,EAAEpnB,GAAG,EAAEjN,UAAU,EAAEmyB,WAAW,EAAEZ,OAAO,CAAC,CAAC;IAC5H,IAAIwiF,SAAS,CAACjkH,MAAM,KAAK,CAAC,EAAE;MAC1B,IAAI,CAACggG,YAAY,CAAC,4CAA4C,EAAE9vF,UAAU,CAAC;IAC7E;IACA,IAAIi0B,KAAK,EAAE;MACT,IAAIA,KAAK,KAAK,OAAO,IAAIA,KAAK,KAAK,MAAM,EAAE;QACzC,IAAI,CAAC67D,YAAY,CAAC,8CAA8C77D,KAAK,WAAW8/E,SAAS,wCAAwC,EAAE/zG,UAAU,CAAC;MAChJ;IACF,CAAC,MAAM;MACL,IAAI,CAAC8vF,YAAY,CAAC,wCAAwCikB,SAAS,2EAA2E,EAAE/zG,UAAU,CAAC;IAC7J;EACF;EACA4zG,kBAAkBA,CAAChiH,IAAI,EAAEgH,UAAU,EAAE86G,iBAAiB,EAAE1zG,UAAU,EAAEmyB,WAAW,EAAEs/E,oBAAoB,EAAEL,YAAY,EAAE7/E,OAAO,EAAE;IAC5H,MAAM;MACJwiF,SAAS;MACTnqF;IACF,CAAC,GAAG,IAAI,CAACiqF,sBAAsB,CAACjiH,IAAI,CAAC;IACrC,MAAMsiH,cAAc,GAAG,IAAI,CAACljF,MAAM,CAAClhC,MAAM;IACzC,MAAMmd,GAAG,GAAG,IAAI,CAACgnG,YAAY,CAACr7G,UAAU,EAAEu5B,WAAW,CAAC;IACtD,MAAMgiF,OAAO,GAAG,IAAI,CAACnjF,MAAM,CAAClhC,MAAM,KAAKokH,cAAc;IACrDzC,oBAAoB,CAAC1hH,IAAI,CAAC,CAAC6B,IAAI,EAAEqb,GAAG,CAACiZ,MAAM,CAAC,CAAC;IAC7C,IAAIwtF,iBAAiB,IAAIS,OAAO,IAAI,CAAC,IAAI,CAACC,yBAAyB,CAACnnG,GAAG,CAAC,EAAE;MACxE,IAAI,CAAC6iF,YAAY,CAAC,6CAA6C,EAAE9vF,UAAU,CAAC;IAC9E;IACA,IAAIq0G,SAAS,GAAGriF,eAAe,CAACoC,OAAO;IACvC,IAAIs/E,iBAAiB,EAAE;MACrBW,SAAS,GAAGriF,eAAe,CAACgS,MAAM;IACpC;IACA,IAAIpyC,IAAI,CAACsvB,UAAU,CAAC,GAAGqvF,cAAc,GAAGF,wBAAwB,EAAE,CAAC,EAAE;MACnEgE,SAAS,GAAGriF,eAAe,CAACo0B,SAAS;IACvC;IACAgrD,YAAY,CAACrhH,IAAI,CAAC,IAAIkiC,WAAW,CAAC8hF,SAAS,EAAEnqF,MAAM,EAAEyqF,SAAS,EAAEpnG,GAAG,EAAEjN,UAAU,EAAEmyB,WAAW,EAAEZ,OAAO,CAAC,CAAC;EACzG;EACA0iF,YAAYA,CAACpiH,KAAK,EAAEmO,UAAU,EAAE;IAC9B,MAAMqsB,cAAc,GAAGrsB,UAAU,IAAIA,UAAU,CAACmmB,KAAK,GAAGnmB,UAAU,CAACmmB,KAAK,CAACmjB,MAAM,GAAG,CAAC;IACnF,IAAI;MACF,MAAMr8B,GAAG,GAAG,IAAI,CAAC4jG,WAAW,CAAC10B,WAAW,CAACtqF,KAAK,EAAEmO,UAAU,EAAEqsB,cAAc,CAAC;MAC3E,IAAIpf,GAAG,EAAE;QACP,IAAI,CAAC+jB,MAAM,CAACjhC,IAAI,CAAC,GAAGkd,GAAG,CAAC+jB,MAAM,CAAC;MACjC;MACA,IAAI,CAAC/jB,GAAG,IAAIA,GAAG,CAACA,GAAG,YAAYyf,WAAW,EAAE;QAC1C,IAAI,CAACojE,YAAY,CAAC,mCAAmC,EAAE9vF,UAAU,CAAC;QAClE,OAAO,IAAI,CAAC6wG,WAAW,CAACjyB,oBAAoB,CAAC,OAAO,EAAE5+E,UAAU,EAAEqsB,cAAc,CAAC;MACnF;MACA,OAAOpf,GAAG;IACZ,CAAC,CAAC,OAAO5S,CAAC,EAAE;MACV,IAAI,CAACy1F,YAAY,CAAC,GAAGz1F,CAAC,EAAE,EAAE2F,UAAU,CAAC;MACrC,OAAO,IAAI,CAAC6wG,WAAW,CAACjyB,oBAAoB,CAAC,OAAO,EAAE5+E,UAAU,EAAEqsB,cAAc,CAAC;IACnF;EACF;EACAyjE,YAAYA,CAAC/4F,OAAO,EAAEiJ,UAAU,EAAE6qC,KAAK,GAAGF,eAAe,CAACI,KAAK,EAAE;IAC/D,IAAI,CAAC/Z,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC5qC,UAAU,EAAEjJ,OAAO,EAAE8zC,KAAK,CAAC,CAAC;EAC9D;EACAyoE,gCAAgCA,CAACtrB,QAAQ,EAAEhoF,UAAU,EAAEs0G,MAAM,EAAE;IAC7D,MAAMC,MAAM,GAAGD,MAAM,GAAG,IAAI,CAACxD,eAAe,CAACroB,iBAAiB,CAACT,QAAQ,CAAC,GAAG,IAAI,CAAC8oB,eAAe,CAACtoB,gBAAgB,CAACR,QAAQ,CAAC;IAC1H,IAAIusB,MAAM,CAACz9E,KAAK,EAAE;MAChB,IAAI,CAACg5D,YAAY,CAACykB,MAAM,CAACt4G,GAAG,EAAE+D,UAAU,EAAE2qC,eAAe,CAACI,KAAK,CAAC;IAClE;EACF;EACAqpE,yBAAyBA,CAACnnG,GAAG,EAAE;IAC7B,IAAIA,GAAG,YAAY6jB,aAAa,EAAE;MAChC,OAAO,IAAI,CAACsjF,yBAAyB,CAACnnG,GAAG,CAACA,GAAG,CAAC;IAChD;IACA,IAAIA,GAAG,YAAY6iB,aAAa,EAAE;MAChC,OAAO,IAAI,CAACskF,yBAAyB,CAACnnG,GAAG,CAACrU,UAAU,CAAC;IACvD;IACA,IAAIqU,GAAG,YAAY+iB,IAAI,IAAI/iB,GAAG,CAACvI,IAAI,CAAC5U,MAAM,KAAK,CAAC,IAAImd,GAAG,CAACtI,QAAQ,YAAY2oB,YAAY,IAAIrgB,GAAG,CAACtI,QAAQ,CAAC/S,IAAI,KAAK,MAAM,IAAIqb,GAAG,CAACtI,QAAQ,CAACA,QAAQ,YAAYioB,gBAAgB,IAAI,EAAE3f,GAAG,CAACtI,QAAQ,CAACA,QAAQ,YAAYmoB,YAAY,CAAC,EAAE;MACjO,OAAO,IAAI,CAACsnF,yBAAyB,CAACnnG,GAAG,CAACvI,IAAI,CAAC,CAAC,CAAC,CAAC;IACpD;IACA,IAAIuI,GAAG,YAAYqgB,YAAY,IAAIrgB,GAAG,YAAYygB,SAAS,EAAE;MAC3D,IAAI,CAAC8mF,wBAAwB,CAACvnG,GAAG,CAAC,EAAE;QAClC,OAAO,IAAI;MACb;IACF;IACA,OAAO,KAAK;EACd;AACF;AACA,SAASunG,wBAAwBA,CAACvnG,GAAG,EAAE;EACrC,IAAIA,GAAG,YAAYugB,gBAAgB,IAAIvgB,GAAG,YAAY2gB,aAAa,EAAE;IACnE,OAAO,IAAI;EACb;EACA,IAAI3gB,GAAG,YAAY0jB,uBAAuB,EAAE;IAC1C,OAAO6jF,wBAAwB,CAACvnG,GAAG,CAACrU,UAAU,CAAC;EACjD;EACA,IAAIqU,GAAG,YAAYqgB,YAAY,IAAIrgB,GAAG,YAAYygB,SAAS,IAAIzgB,GAAG,YAAY+iB,IAAI,EAAE;IAClF,OAAOwkF,wBAAwB,CAACvnG,GAAG,CAACtI,QAAQ,CAAC;EAC/C;EACA,OAAO,KAAK;AACd;AACA,SAAS2tG,sBAAsBA,CAAC1gH,IAAI,EAAE;EACpC,OAAOA,IAAI,CAAC,CAAC,CAAC,IAAI,GAAG;AACvB;AACA,SAASy2G,4BAA4BA,CAACrzG,QAAQ,EAAEvF,QAAQ,EAAEu4F,QAAQ,EAAEK,WAAW,EAAE;EAC/E,IAAIosB,IAAI;EACR,MAAMC,aAAa,GAAGC,MAAM,IAAI3/G,QAAQ,CAACu9B,eAAe,CAACoiF,MAAM,EAAE3sB,QAAQ,EAAEK,WAAW,CAAC;EACvF,IAAI54F,QAAQ,KAAK,IAAI,EAAE;IACrBglH,IAAI,GAAGz/G,QAAQ,CAAC0zF,oBAAoB,CAAC,CAAC,CAACz0F,GAAG,CAACygH,aAAa,CAAC;EAC3D,CAAC,MAAM;IACLD,IAAI,GAAG,EAAE;IACTtlH,WAAW,CAACK,KAAK,CAACC,QAAQ,CAAC,CAACuC,OAAO,CAACvC,QAAQ,IAAI;MAC9C,MAAMmlH,YAAY,GAAGnlH,QAAQ,CAACL,OAAO,GAAG,CAACK,QAAQ,CAACL,OAAO,CAAC,GAAG4F,QAAQ,CAAC0zF,oBAAoB,CAAC,CAAC;MAC5F,MAAMmsB,eAAe,GAAG,IAAIzjE,GAAG,CAAC3hD,QAAQ,CAACF,YAAY,CAACkiB,MAAM,CAAChiB,QAAQ,IAAIA,QAAQ,CAAC8B,iBAAiB,CAAC,CAAC,CAAC,CAAC0C,GAAG,CAACxE,QAAQ,IAAIA,QAAQ,CAACL,OAAO,CAAC,CAAC;MACzI,MAAM0lH,oBAAoB,GAAGF,YAAY,CAACnjG,MAAM,CAACkjG,MAAM,IAAI,CAACE,eAAe,CAAC5/G,GAAG,CAAC0/G,MAAM,CAAC,CAAC;MACxFF,IAAI,CAAC1kH,IAAI,CAAC,GAAG+kH,oBAAoB,CAAC7gH,GAAG,CAACygH,aAAa,CAAC,CAAC;IACvD,CAAC,CAAC;EACJ;EACA,OAAOD,IAAI,CAAC3kH,MAAM,KAAK,CAAC,GAAG,CAAC6F,eAAe,CAACi+D,IAAI,CAAC,GAAGvqD,KAAK,CAACmZ,IAAI,CAAC,IAAI4uB,GAAG,CAACqjE,IAAI,CAAC,CAAC,CAACppB,IAAI,CAAC,CAAC;AACtF;AACA,SAAS0mB,mBAAmBA,CAAC/xG,UAAU,EAAE+0G,YAAY,EAAE;EACrD,MAAMC,SAAS,GAAGD,YAAY,CAAC5uF,KAAK,GAAGnmB,UAAU,CAACmmB,KAAK,CAACmjB,MAAM;EAC9D,MAAM2rE,OAAO,GAAGF,YAAY,CAAC54G,GAAG,GAAG6D,UAAU,CAAC7D,GAAG,CAACmtC,MAAM;EACxD,OAAO,IAAIkB,eAAe,CAACxqC,UAAU,CAACmmB,KAAK,CAACojB,MAAM,CAACyrE,SAAS,CAAC,EAAEh1G,UAAU,CAAC7D,GAAG,CAACotC,MAAM,CAAC0rE,OAAO,CAAC,EAAEj1G,UAAU,CAACyqC,SAAS,CAAClB,MAAM,CAACyrE,SAAS,CAAC,EAAEh1G,UAAU,CAAC0qC,OAAO,CAAC;AAC5J;AAEA,SAASwqE,oBAAoBA,CAAC3sG,GAAG,EAAE;EACjC,IAAIA,GAAG,IAAI,IAAI,IAAIA,GAAG,CAACzY,MAAM,KAAK,CAAC,IAAIyY,GAAG,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE,OAAO,KAAK;EAClE,MAAM4sG,WAAW,GAAG5sG,GAAG,CAACtY,KAAK,CAACmlH,sBAAsB,CAAC;EACrD,OAAOD,WAAW,KAAK,IAAI,IAAIA,WAAW,CAAC,CAAC,CAAC,IAAI,SAAS,IAAIA,WAAW,CAAC,CAAC,CAAC,IAAI,OAAO;AACzF;AACA,MAAMC,sBAAsB,GAAG,cAAc;AAE7C,MAAMC,sBAAsB,GAAG,QAAQ;AACvC,MAAMC,YAAY,GAAG,MAAM;AAC3B,MAAMC,mBAAmB,GAAG,KAAK;AACjC,MAAMC,oBAAoB,GAAG,MAAM;AACnC,MAAMC,oBAAoB,GAAG,YAAY;AACzC,MAAMC,aAAa,GAAG,OAAO;AAC7B,MAAMC,cAAc,GAAG,QAAQ;AAC/B,MAAMC,oBAAoB,GAAG,eAAe;AAC5C,MAAMC,aAAa,GAAG,aAAa;AACnC,SAASC,eAAeA,CAAC7oG,GAAG,EAAE;EAC5B,IAAI8oG,UAAU,GAAG,IAAI;EACrB,IAAIC,QAAQ,GAAG,IAAI;EACnB,IAAIC,OAAO,GAAG,IAAI;EAClB,IAAIrrD,WAAW,GAAG,KAAK;EACvB,IAAI+L,SAAS,GAAG,EAAE;EAClB1pD,GAAG,CAAC3d,KAAK,CAAC0C,OAAO,CAACjB,IAAI,IAAI;IACxB,MAAMmlH,UAAU,GAAGnlH,IAAI,CAACa,IAAI,CAACE,WAAW,CAAC,CAAC;IAC1C,IAAIokH,UAAU,IAAIb,sBAAsB,EAAE;MACxCU,UAAU,GAAGhlH,IAAI,CAACc,KAAK;IACzB,CAAC,MAAM,IAAIqkH,UAAU,IAAIV,oBAAoB,EAAE;MAC7CQ,QAAQ,GAAGjlH,IAAI,CAACc,KAAK;IACvB,CAAC,MAAM,IAAIqkH,UAAU,IAAIX,mBAAmB,EAAE;MAC5CU,OAAO,GAAGllH,IAAI,CAACc,KAAK;IACtB,CAAC,MAAM,IAAId,IAAI,CAACa,IAAI,IAAIgkH,oBAAoB,EAAE;MAC5ChrD,WAAW,GAAG,IAAI;IACpB,CAAC,MAAM,IAAI75D,IAAI,CAACa,IAAI,IAAIikH,aAAa,EAAE;MACrC,IAAI9kH,IAAI,CAACc,KAAK,CAAC/B,MAAM,GAAG,CAAC,EAAE;QACzB6mE,SAAS,GAAG5lE,IAAI,CAACc,KAAK;MACxB;IACF;EACF,CAAC,CAAC;EACFkkH,UAAU,GAAGI,wBAAwB,CAACJ,UAAU,CAAC;EACjD,MAAMjkC,QAAQ,GAAG7kE,GAAG,CAACrb,IAAI,CAACE,WAAW,CAAC,CAAC;EACvC,IAAI+G,IAAI,GAAGu9G,oBAAoB,CAACC,KAAK;EACrC,IAAIvjF,WAAW,CAACg/C,QAAQ,CAAC,EAAE;IACzBj5E,IAAI,GAAGu9G,oBAAoB,CAACE,UAAU;EACxC,CAAC,MAAM,IAAIxkC,QAAQ,IAAI4jC,aAAa,EAAE;IACpC78G,IAAI,GAAGu9G,oBAAoB,CAAC1iD,KAAK;EACnC,CAAC,MAAM,IAAIoe,QAAQ,IAAI6jC,cAAc,EAAE;IACrC98G,IAAI,GAAGu9G,oBAAoB,CAAC/U,MAAM;EACpC,CAAC,MAAM,IAAIvvB,QAAQ,IAAIwjC,YAAY,IAAIW,OAAO,IAAIR,oBAAoB,EAAE;IACtE58G,IAAI,GAAGu9G,oBAAoB,CAACG,UAAU;EACxC;EACA,OAAO,IAAIC,gBAAgB,CAAC39G,IAAI,EAAEk9G,UAAU,EAAEC,QAAQ,EAAEprD,WAAW,EAAE+L,SAAS,CAAC;AACjF;AACA,IAAIy/C,oBAAoB;AACxB,CAAC,UAAUA,oBAAoB,EAAE;EAC/BA,oBAAoB,CAACA,oBAAoB,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,GAAG,YAAY;EAC3EA,oBAAoB,CAACA,oBAAoB,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;EACjEA,oBAAoB,CAACA,oBAAoB,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,GAAG,YAAY;EAC3EA,oBAAoB,CAACA,oBAAoB,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;EACnEA,oBAAoB,CAACA,oBAAoB,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;AACnE,CAAC,EAAEA,oBAAoB,KAAKA,oBAAoB,GAAG,CAAC,CAAC,CAAC,CAAC;AACvD,MAAMI,gBAAgB,CAAC;EACrB39G,IAAI;EACJk9G,UAAU;EACVC,QAAQ;EACRprD,WAAW;EACX+L,SAAS;EACT/hE,WAAWA,CAACiE,IAAI,EAAEk9G,UAAU,EAAEC,QAAQ,EAAEprD,WAAW,EAAE+L,SAAS,EAAE;IAC9D,IAAI,CAAC99D,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACk9G,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACprD,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAAC+L,SAAS,GAAGA,SAAS;EAC5B;AACF;AACA,SAASw/C,wBAAwBA,CAACJ,UAAU,EAAE;EAC5C,IAAIA,UAAU,KAAK,IAAI,IAAIA,UAAU,CAACjmH,MAAM,KAAK,CAAC,EAAE;IAClD,OAAO,GAAG;EACZ;EACA,OAAOimH,UAAU;AACnB;AAEA,MAAMU,2BAA2B,GAAG,uCAAuC;AAC3E,MAAMC,sBAAsB,GAAG,oBAAoB;AACnD,MAAMC,yBAAyB,GAAG,cAAc;AAChD,MAAMC,eAAe,GAAG,mBAAmB;AAC3C,MAAMC,oBAAoB,GAAG,kBAAkB;AAC/C,MAAMC,kBAAkB,GAAG,uBAAuB;AAClD,MAAMC,4CAA4C,GAAG,iBAAiB;AACtE,MAAMC,8BAA8B,GAAG,IAAI5lE,GAAG,CAAC,CAAC,QAAQ,EAAE,QAAQ,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC;AACxG,SAAS6lE,uBAAuBA,CAACrlH,IAAI,EAAE;EACrC,OAAOA,IAAI,KAAK,OAAO;AACzB;AACA,SAASslH,sBAAsBA,CAACtlH,IAAI,EAAE;EACpC,OAAOA,IAAI,KAAK,MAAM,IAAIglH,eAAe,CAACz1F,IAAI,CAACvvB,IAAI,CAAC;AACtD;AACA,SAASulH,aAAaA,CAAClqG,GAAG,EAAEmqG,eAAe,EAAE5/G,OAAO,EAAE2wG,aAAa,EAAE;EACnE,MAAMn3E,MAAM,GAAGqmF,yBAAyB,CAACD,eAAe,CAAC;EACzD,MAAM1+E,QAAQ,GAAG,EAAE;EACnB,MAAM4+E,eAAe,GAAGC,+BAA+B,CAACtqG,GAAG,EAAE+jB,MAAM,EAAEm3E,aAAa,CAAC;EACnF,IAAImP,eAAe,KAAK,IAAI,EAAE;IAC5B5+E,QAAQ,CAAC3oC,IAAI,CAAC,IAAI6oC,aAAa,CAAC0+E,eAAe,CAAC1+G,UAAU,EAAEw4B,QAAQ,CAAC55B,OAAO,EAAEyV,GAAG,CAAC7U,QAAQ,EAAE6U,GAAG,CAAC7U,QAAQ,CAAC,EAAEk/G,eAAe,CAACz+E,eAAe,EAAE5rB,GAAG,CAACjN,UAAU,EAAEiN,GAAG,CAAC8nB,eAAe,EAAE9nB,GAAG,CAAC+nB,aAAa,EAAE/nB,GAAG,CAACwf,QAAQ,EAAExf,GAAG,CAAC4L,IAAI,CAAC,CAAC;EAC9N;EACA,KAAK,MAAMiiB,KAAK,IAAIs8E,eAAe,EAAE;IACnC,IAAIR,eAAe,CAACz1F,IAAI,CAAC2Z,KAAK,CAAClpC,IAAI,CAAC,EAAE;MACpC,MAAM0O,MAAM,GAAGi3G,+BAA+B,CAACz8E,KAAK,EAAE9J,MAAM,EAAEm3E,aAAa,CAAC;MAC5E,IAAI7nG,MAAM,KAAK,IAAI,EAAE;QACnB,MAAMlI,QAAQ,GAAGg5B,QAAQ,CAAC55B,OAAO,EAAEsjC,KAAK,CAAC1iC,QAAQ,EAAE0iC,KAAK,CAAC1iC,QAAQ,CAAC;QAClEsgC,QAAQ,CAAC3oC,IAAI,CAAC,IAAI6oC,aAAa,CAACt4B,MAAM,CAAC1H,UAAU,EAAER,QAAQ,EAAEkI,MAAM,CAACu4B,eAAe,EAAEiC,KAAK,CAAC96B,UAAU,EAAE86B,KAAK,CAAC/F,eAAe,EAAE+F,KAAK,CAAC9F,aAAa,EAAE8F,KAAK,CAACrO,QAAQ,EAAEqO,KAAK,CAACjiB,IAAI,CAAC,CAAC;MACjL;IACF,CAAC,MAAM,IAAIiiB,KAAK,CAAClpC,IAAI,KAAK,MAAM,EAAE;MAChC,MAAMwG,QAAQ,GAAGg5B,QAAQ,CAAC55B,OAAO,EAAEsjC,KAAK,CAAC1iC,QAAQ,EAAE0iC,KAAK,CAAC1iC,QAAQ,CAAC;MAClEsgC,QAAQ,CAAC3oC,IAAI,CAAC,IAAI6oC,aAAa,CAAC,IAAI,EAAExgC,QAAQ,EAAE,IAAI,EAAE0iC,KAAK,CAAC96B,UAAU,EAAE86B,KAAK,CAAC/F,eAAe,EAAE+F,KAAK,CAAC9F,aAAa,EAAE8F,KAAK,CAACrO,QAAQ,EAAEqO,KAAK,CAACjiB,IAAI,CAAC,CAAC;IAClJ;EACF;EACA,MAAM2+F,sBAAsB,GAAG9+E,QAAQ,CAAC5oC,MAAM,GAAG,CAAC,GAAG4oC,QAAQ,CAAC,CAAC,CAAC,CAAC3D,eAAe,GAAG9nB,GAAG,CAAC8nB,eAAe;EACtG,MAAM0iF,oBAAoB,GAAG/+E,QAAQ,CAAC5oC,MAAM,GAAG,CAAC,GAAG4oC,QAAQ,CAACA,QAAQ,CAAC5oC,MAAM,GAAG,CAAC,CAAC,CAACklC,aAAa,GAAG/nB,GAAG,CAAC+nB,aAAa;EAClH,IAAI01B,eAAe,GAAGz9C,GAAG,CAACjN,UAAU;EACpC,MAAM03G,UAAU,GAAGh/E,QAAQ,CAACA,QAAQ,CAAC5oC,MAAM,GAAG,CAAC,CAAC;EAChD,IAAI4nH,UAAU,KAAK/3F,SAAS,EAAE;IAC5B+qC,eAAe,GAAG,IAAIlgB,eAAe,CAACgtE,sBAAsB,CAACrxF,KAAK,EAAEuxF,UAAU,CAAC13G,UAAU,CAAC7D,GAAG,CAAC;EAChG;EACA,OAAO;IACLoI,IAAI,EAAE,IAAIk0B,OAAO,CAACC,QAAQ,EAAEgyB,eAAe,EAAEz9C,GAAG,CAAC8nB,eAAe,EAAE0iF,oBAAoB,EAAExqG,GAAG,CAACwf,QAAQ,CAAC;IACrGuE;EACF,CAAC;AACH;AACA,SAAS2mF,aAAaA,CAAC1qG,GAAG,EAAEmqG,eAAe,EAAE5/G,OAAO,EAAE2wG,aAAa,EAAE;EACnE,MAAMn3E,MAAM,GAAG,EAAE;EACjB,MAAM1wB,MAAM,GAAGs3G,sBAAsB,CAAC3qG,GAAG,EAAE+jB,MAAM,EAAEm3E,aAAa,CAAC;EACjE,IAAI5jG,IAAI,GAAG,IAAI;EACf,IAAI8zB,KAAK,GAAG,IAAI;EAChB,KAAK,MAAMyC,KAAK,IAAIs8E,eAAe,EAAE;IACnC,IAAIt8E,KAAK,CAAClpC,IAAI,KAAK,OAAO,EAAE;MAC1B,IAAIymC,KAAK,KAAK,IAAI,EAAE;QAClBrH,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC9P,KAAK,CAAC96B,UAAU,EAAE,0CAA0C,CAAC,CAAC;MAC3F,CAAC,MAAM,IAAI86B,KAAK,CAACnpB,UAAU,CAAC7hB,MAAM,GAAG,CAAC,EAAE;QACtCkhC,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC9P,KAAK,CAAC96B,UAAU,EAAE,qCAAqC,CAAC,CAAC;MACtF,CAAC,MAAM;QACLq4B,KAAK,GAAG,IAAIE,iBAAiB,CAACnH,QAAQ,CAAC55B,OAAO,EAAEsjC,KAAK,CAAC1iC,QAAQ,EAAE0iC,KAAK,CAAC1iC,QAAQ,CAAC,EAAE0iC,KAAK,CAAC96B,UAAU,EAAE86B,KAAK,CAAC/F,eAAe,EAAE+F,KAAK,CAAC9F,aAAa,EAAE8F,KAAK,CAACrO,QAAQ,EAAEqO,KAAK,CAACjiB,IAAI,CAAC;MAC5K;IACF,CAAC,MAAM;MACLmY,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC9P,KAAK,CAAC96B,UAAU,EAAE,iCAAiC86B,KAAK,CAAClpC,IAAI,GAAG,CAAC,CAAC;IAC/F;EACF;EACA,IAAI0O,MAAM,KAAK,IAAI,EAAE;IACnB,IAAIA,MAAM,CAAC43B,OAAO,KAAK,IAAI,EAAE;MAC3BlH,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC39B,GAAG,CAAC8nB,eAAe,EAAE,0CAA0C,CAAC,CAAC;IAC9F,CAAC,MAAM;MACL,MAAMu7C,OAAO,GAAGj4C,KAAK,EAAErD,aAAa,IAAI/nB,GAAG,CAAC+nB,aAAa;MACzD,MAAMh1B,UAAU,GAAG,IAAIwqC,eAAe,CAACv9B,GAAG,CAACjN,UAAU,CAACmmB,KAAK,EAAEmqD,OAAO,EAAEn0E,GAAG,IAAI8Q,GAAG,CAACjN,UAAU,CAAC7D,GAAG,CAAC;MAChG07G,yBAAyB,CAACv3G,MAAM,CAAC43B,OAAO,CAACt/B,UAAU,EAAE0H,MAAM,CAAC43B,OAAO,CAAC4/E,WAAW,EAAE9mF,MAAM,CAAC;MACxFzsB,IAAI,GAAG,IAAIyzB,YAAY,CAAC13B,MAAM,CAACy3G,QAAQ,EAAEz3G,MAAM,CAAC1H,UAAU,EAAE0H,MAAM,CAAC43B,OAAO,CAACt/B,UAAU,EAAE0H,MAAM,CAAC43B,OAAO,CAAC4/E,WAAW,EAAEx3G,MAAM,CAACrI,OAAO,EAAEm5B,QAAQ,CAAC55B,OAAO,EAAEyV,GAAG,CAAC7U,QAAQ,EAAE6U,GAAG,CAAC7U,QAAQ,CAAC,EAAEigC,KAAK,EAAEr4B,UAAU,EAAEiN,GAAG,CAACjN,UAAU,EAAEiN,GAAG,CAAC8nB,eAAe,EAAEu7C,OAAO,EAAErjE,GAAG,CAACwf,QAAQ,EAAExf,GAAG,CAAC4L,IAAI,CAAC;IAC5Q;EACF;EACA,OAAO;IACLtU,IAAI;IACJysB;EACF,CAAC;AACH;AACA,SAASgnF,iBAAiBA,CAAC/qG,GAAG,EAAEzV,OAAO,EAAE2wG,aAAa,EAAE;EACtD,MAAMn3E,MAAM,GAAGinF,mBAAmB,CAAChrG,GAAG,CAAC;EACvC,MAAMirG,iBAAiB,GAAGjrG,GAAG,CAAC0E,UAAU,CAAC7hB,MAAM,GAAG,CAAC,GAAGqoH,4BAA4B,CAAClrG,GAAG,CAAC0E,UAAU,CAAC,CAAC,CAAC,EAAEw2F,aAAa,CAAC,GAAGA,aAAa,CAACxrB,YAAY,CAAC,EAAE,EAAE,KAAK,EAAE1vE,GAAG,CAACjN,UAAU,EAAE,CAAC,CAAC;EAC/K,MAAMtH,KAAK,GAAG,EAAE;EAChB,MAAMk/B,aAAa,GAAG,EAAE;EACxB,IAAIm9B,WAAW,GAAG,IAAI;EACtB,KAAK,MAAMxwD,IAAI,IAAI0I,GAAG,CAAC7U,QAAQ,EAAE;IAC/B,IAAI,EAAEmM,IAAI,YAAYw8D,KAAK,CAAC,EAAE;MAC5B;IACF;IACA,IAAI,CAACx8D,IAAI,CAAC3S,IAAI,KAAK,MAAM,IAAI2S,IAAI,CAACoN,UAAU,CAAC7hB,MAAM,KAAK,CAAC,KAAKyU,IAAI,CAAC3S,IAAI,KAAK,SAAS,EAAE;MACrFgmC,aAAa,CAAC7nC,IAAI,CAAC,IAAIgpC,YAAY,CAACx0B,IAAI,CAAC3S,IAAI,EAAE2S,IAAI,CAACvE,UAAU,EAAEuE,IAAI,CAACkoB,QAAQ,CAAC,CAAC;MAC/E;IACF;IACA,MAAM7zB,UAAU,GAAG2L,IAAI,CAAC3S,IAAI,KAAK,MAAM,GAAGumH,4BAA4B,CAAC5zG,IAAI,CAACoN,UAAU,CAAC,CAAC,CAAC,EAAEw2F,aAAa,CAAC,GAAG,IAAI;IAChH,MAAMl7F,GAAG,GAAG,IAAI6qB,eAAe,CAACl/B,UAAU,EAAEw4B,QAAQ,CAAC55B,OAAO,EAAE+M,IAAI,CAACnM,QAAQ,EAAEmM,IAAI,CAACnM,QAAQ,CAAC,EAAEmM,IAAI,CAACvE,UAAU,EAAEuE,IAAI,CAACwwB,eAAe,EAAExwB,IAAI,CAACywB,aAAa,EAAEzwB,IAAI,CAACkoB,QAAQ,EAAEloB,IAAI,CAACsU,IAAI,CAAC;IACjL,IAAIjgB,UAAU,KAAK,IAAI,EAAE;MACvBm8D,WAAW,GAAG9nD,GAAG;IACnB,CAAC,MAAM;MACLvU,KAAK,CAAC3I,IAAI,CAACkd,GAAG,CAAC;IACjB;EACF;EACA,IAAI8nD,WAAW,KAAK,IAAI,EAAE;IACxBr8D,KAAK,CAAC3I,IAAI,CAACglE,WAAW,CAAC;EACzB;EACA,OAAO;IACLxwD,IAAI,EAAE,IAAIozB,WAAW,CAACugF,iBAAiB,EAAEx/G,KAAK,EAAEk/B,aAAa,EAAE3qB,GAAG,CAACjN,UAAU,EAAEiN,GAAG,CAAC8nB,eAAe,EAAE9nB,GAAG,CAAC+nB,aAAa,EAAE/nB,GAAG,CAACwf,QAAQ,CAAC;IACpIuE;EACF,CAAC;AACH;AACA,SAAS4mF,sBAAsBA,CAAC98E,KAAK,EAAE9J,MAAM,EAAEm3E,aAAa,EAAE;EAC5D,IAAIrtE,KAAK,CAACnpB,UAAU,CAAC7hB,MAAM,KAAK,CAAC,EAAE;IACjCkhC,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC9P,KAAK,CAAC/F,eAAe,EAAE,uCAAuC,CAAC,CAAC;IAC3F,OAAO,IAAI;EACb;EACA,MAAM,CAACqjF,eAAe,EAAE,GAAGC,eAAe,CAAC,GAAGv9E,KAAK,CAACnpB,UAAU;EAC9D,MAAM1hB,KAAK,GAAGqoH,wBAAwB,CAACF,eAAe,EAAEpnF,MAAM,CAAC,EAAE/gC,KAAK,CAACwmH,2BAA2B,CAAC;EACnG,IAAI,CAACxmH,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,CAACuvB,IAAI,CAAC,CAAC,CAAC1vB,MAAM,KAAK,CAAC,EAAE;IAC1CkhC,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAACwtE,eAAe,CAACp4G,UAAU,EAAE,qGAAqG,CAAC,CAAC;IAC9J,OAAO,IAAI;EACb;EACA,MAAM,GAAG+3G,QAAQ,EAAEQ,aAAa,CAAC,GAAGtoH,KAAK;EACzC,IAAI+mH,8BAA8B,CAAC/hH,GAAG,CAAC8iH,QAAQ,CAAC,EAAE;IAChD/mF,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAACwtE,eAAe,CAACp4G,UAAU,EAAE,wCAAwCqJ,KAAK,CAACmZ,IAAI,CAACw0F,8BAA8B,CAAC,CAACtlH,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;EAC3J;EACA,MAAM8mH,YAAY,GAAGJ,eAAe,CAACx/G,UAAU,CAACgoB,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EAC7D,MAAM63F,YAAY,GAAG,IAAIjuE,eAAe,CAAC4tE,eAAe,CAACp4G,UAAU,CAACmmB,KAAK,EAAEiyF,eAAe,CAACp4G,UAAU,CAACmmB,KAAK,CAACojB,MAAM,CAACivE,YAAY,CAAC1oH,MAAM,CAAC,CAAC;EACxI,MAAMkB,MAAM,GAAG;IACb+mH,QAAQ,EAAE,IAAIh+E,QAAQ,CAACg+E,QAAQ,EAAE,WAAW,EAAEU,YAAY,EAAEA,YAAY,CAAC;IACzEvgF,OAAO,EAAE,IAAI;IACbt/B,UAAU,EAAEu/G,4BAA4B,CAACC,eAAe,EAAEjQ,aAAa,EAAEoQ,aAAa,CAAC;IACvFtgH,OAAO,EAAEoR,KAAK,CAACmZ,IAAI,CAACw0F,8BAA8B,EAAEwB,YAAY,IAAI;MAClE,MAAME,2BAA2B,GAAG,IAAIluE,eAAe,CAAC1P,KAAK,CAAC/F,eAAe,CAAC54B,GAAG,EAAE2+B,KAAK,CAAC/F,eAAe,CAAC54B,GAAG,CAAC;MAC7G,OAAO,IAAI49B,QAAQ,CAACy+E,YAAY,EAAEA,YAAY,EAAEE,2BAA2B,EAAEA,2BAA2B,CAAC;IAC3G,CAAC;EACH,CAAC;EACD,KAAK,MAAM7vG,KAAK,IAAIwvG,eAAe,EAAE;IACnC,MAAMM,QAAQ,GAAG9vG,KAAK,CAACjQ,UAAU,CAAC3I,KAAK,CAAC4mH,oBAAoB,CAAC;IAC7D,IAAI8B,QAAQ,KAAK,IAAI,EAAE;MACrB,MAAMC,aAAa,GAAG,IAAIpuE,eAAe,CAAC3hC,KAAK,CAAC7I,UAAU,CAACmmB,KAAK,CAACojB,MAAM,CAACovE,QAAQ,CAAC,CAAC,CAAC,CAAC7oH,MAAM,GAAG6oH,QAAQ,CAAC,CAAC,CAAC,CAAC7oH,MAAM,CAAC,EAAE+Y,KAAK,CAAC7I,UAAU,CAAC7D,GAAG,CAAC;MACvI08G,iBAAiB,CAAChwG,KAAK,CAAC7I,UAAU,EAAE24G,QAAQ,CAAC,CAAC,CAAC,EAAEC,aAAa,EAAEb,QAAQ,EAAE/mH,MAAM,CAACiH,OAAO,EAAE+4B,MAAM,CAAC;MACjG;IACF;IACA,MAAM8nF,UAAU,GAAGjwG,KAAK,CAACjQ,UAAU,CAAC3I,KAAK,CAACymH,sBAAsB,CAAC;IACjE,IAAIoC,UAAU,KAAK,IAAI,EAAE;MACvB,IAAI9nH,MAAM,CAACknC,OAAO,KAAK,IAAI,EAAE;QAC3BlH,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC/hC,KAAK,CAAC7I,UAAU,EAAE,gDAAgD,CAAC,CAAC;MACjG,CAAC,MAAM;QACL,MAAMpH,UAAU,GAAGu/G,4BAA4B,CAACtvG,KAAK,EAAEs/F,aAAa,EAAE2Q,UAAU,CAAC,CAAC,CAAC,CAAC;QACpF,IAAIlgH,UAAU,CAACqU,GAAG,YAAYyf,WAAW,EAAE;UACzCsE,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC9P,KAAK,CAAC/F,eAAe,EAAE,0CAA0C,CAAC,CAAC;QAChG;QACA,MAAM+iF,WAAW,GAAG,IAAIttE,eAAe,CAAC3hC,KAAK,CAAC7I,UAAU,CAACmmB,KAAK,EAAEtd,KAAK,CAAC7I,UAAU,CAACmmB,KAAK,CAACojB,MAAM,CAAC,OAAO,CAACz5C,MAAM,CAAC,CAAC;QAC9GkB,MAAM,CAACknC,OAAO,GAAG;UACft/B,UAAU;UACVk/G;QACF,CAAC;MACH;MACA;IACF;IACA9mF,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC/hC,KAAK,CAAC7I,UAAU,EAAE,qCAAqC6I,KAAK,CAACjQ,UAAU,GAAG,CAAC,CAAC;EACzG;EACA,OAAO5H,MAAM;AACf;AACA,SAAS6mH,yBAAyBA,CAACj/G,UAAU,EAAEwjF,eAAe,EAAEprD,MAAM,EAAE;EACtE,MAAMx5B,OAAO,GAAG,IAAIuhH,WAAW,CAAC,CAAC;EACjCngH,UAAU,CAACqU,GAAG,CAACrV,KAAK,CAACJ,OAAO,CAAC;EAC7B,IAAIA,OAAO,CAAC6qG,OAAO,EAAE;IACnBrxE,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAACwxC,eAAe,EAAE,uCAAuC,CAAC,CAAC;EACvF;AACF;AACA,SAASy8B,iBAAiBA,CAAC74G,UAAU,EAAEpH,UAAU,EAAEqtB,IAAI,EAAE+yF,YAAY,EAAE/gH,OAAO,EAAE+4B,MAAM,EAAE;EACtF,MAAMt5B,KAAK,GAAGkB,UAAU,CAACgoB,KAAK,CAAC,GAAG,CAAC;EACnC,IAAIsvD,SAAS,GAAGjqD,IAAI,CAACE,KAAK;EAC1B,KAAK,MAAMrB,IAAI,IAAIptB,KAAK,EAAE;IACxB,MAAMuhH,eAAe,GAAGn0F,IAAI,CAAClE,KAAK,CAAC,GAAG,CAAC;IACvC,MAAMhvB,IAAI,GAAGqnH,eAAe,CAACnpH,MAAM,KAAK,CAAC,GAAGmpH,eAAe,CAAC,CAAC,CAAC,CAACz5F,IAAI,CAAC,CAAC,GAAG,EAAE;IAC1E,MAAMg5F,YAAY,GAAGS,eAAe,CAACnpH,MAAM,KAAK,CAAC,GAAGmpH,eAAe,CAAC,CAAC,CAAC,CAACz5F,IAAI,CAAC,CAAC,GAAG,EAAE;IAClF,IAAI5tB,IAAI,CAAC9B,MAAM,KAAK,CAAC,IAAI0oH,YAAY,CAAC1oH,MAAM,KAAK,CAAC,EAAE;MAClDkhC,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC5qC,UAAU,EAAE,kGAAkG,CAAC,CAAC;IAC7I,CAAC,MAAM,IAAI,CAACg3G,8BAA8B,CAAC/hH,GAAG,CAACujH,YAAY,CAAC,EAAE;MAC5DxnF,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC5qC,UAAU,EAAE,qCAAqCw4G,YAAY,iCAAiCnvG,KAAK,CAACmZ,IAAI,CAACw0F,8BAA8B,CAAC,CAACtlH,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACpL,CAAC,MAAM,IAAIE,IAAI,KAAKonH,YAAY,EAAE;MAChChoF,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC5qC,UAAU,EAAE,iEAAiEg5G,YAAY,GAAG,CAAC,CAAC;IAC3H,CAAC,MAAM,IAAI/gH,OAAO,CAACspC,IAAI,CAACs7B,CAAC,IAAIA,CAAC,CAACjrE,IAAI,KAAKA,IAAI,CAAC,EAAE;MAC7Co/B,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC5qC,UAAU,EAAE,uCAAuCw4G,YAAY,GAAG,CAAC,CAAC;IACjG,CAAC,MAAM;MACL,MAAM,GAAGU,oBAAoB,EAAEC,OAAO,CAAC,GAAGF,eAAe,CAAC,CAAC,CAAC,CAAChpH,KAAK,CAAC8mH,4CAA4C,CAAC,IAAI,EAAE;MACtH,MAAMxlF,OAAO,GAAG2nF,oBAAoB,KAAKv5F,SAAS,IAAIs5F,eAAe,CAACnpH,MAAM,KAAK,CAAC,GAAG,IAAI06C,eAAe,CAAC0lC,SAAS,CAAC3mC,MAAM,CAAC2vE,oBAAoB,CAACppH,MAAM,CAAC,EAAEogF,SAAS,CAAC3mC,MAAM,CAAC2vE,oBAAoB,CAACppH,MAAM,GAAGqpH,OAAO,CAACrpH,MAAM,CAAC,CAAC,GAAGm2B,IAAI;MAC9N,IAAIuL,SAAS,GAAG7R,SAAS;MACzB,IAAIs5F,eAAe,CAACnpH,MAAM,KAAK,CAAC,EAAE;QAChC,MAAM,GAAGspH,sBAAsB,EAAEC,QAAQ,CAAC,GAAGJ,eAAe,CAAC,CAAC,CAAC,CAAChpH,KAAK,CAAC8mH,4CAA4C,CAAC,IAAI,EAAE;QACzHvlF,SAAS,GAAG4nF,sBAAsB,KAAKz5F,SAAS,GAAG,IAAI6qB,eAAe,CAAC0lC,SAAS,CAAC3mC,MAAM,CAAC0vE,eAAe,CAAC,CAAC,CAAC,CAACnpH,MAAM,GAAG,CAAC,GAAGspH,sBAAsB,CAACtpH,MAAM,CAAC,EAAEogF,SAAS,CAAC3mC,MAAM,CAAC0vE,eAAe,CAAC,CAAC,CAAC,CAACnpH,MAAM,GAAG,CAAC,GAAGspH,sBAAsB,CAACtpH,MAAM,GAAGupH,QAAQ,CAACvpH,MAAM,CAAC,CAAC,GAAG6vB,SAAS;MACxQ;MACA,MAAM3f,UAAU,GAAG,IAAIwqC,eAAe,CAACjZ,OAAO,CAACpL,KAAK,EAAEqL,SAAS,EAAEr1B,GAAG,IAAIo1B,OAAO,CAACp1B,GAAG,CAAC;MACpFlE,OAAO,CAAClI,IAAI,CAAC,IAAIgqC,QAAQ,CAACnoC,IAAI,EAAE4mH,YAAY,EAAEx4G,UAAU,EAAEuxB,OAAO,EAAEC,SAAS,CAAC,CAAC;IAChF;IACA0+C,SAAS,GAAGA,SAAS,CAAC3mC,MAAM,CAACzkB,IAAI,CAACh1B,MAAM,GAAG,CAAC,CAAC;EAC/C;AACF;AACA,SAASunH,yBAAyBA,CAACD,eAAe,EAAE;EAClD,MAAMpmF,MAAM,GAAG,EAAE;EACjB,IAAIsoF,OAAO,GAAG,KAAK;EACnB,KAAK,IAAIpoH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkmH,eAAe,CAACtnH,MAAM,EAAEoB,CAAC,EAAE,EAAE;IAC/C,MAAM4pC,KAAK,GAAGs8E,eAAe,CAAClmH,CAAC,CAAC;IAChC,IAAI4pC,KAAK,CAAClpC,IAAI,KAAK,MAAM,EAAE;MACzB,IAAI0nH,OAAO,EAAE;QACXtoF,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC9P,KAAK,CAAC/F,eAAe,EAAE,2CAA2C,CAAC,CAAC;MACjG,CAAC,MAAM,IAAIqiF,eAAe,CAACtnH,MAAM,GAAG,CAAC,IAAIoB,CAAC,GAAGkmH,eAAe,CAACtnH,MAAM,GAAG,CAAC,EAAE;QACvEkhC,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC9P,KAAK,CAAC/F,eAAe,EAAE,iDAAiD,CAAC,CAAC;MACvG,CAAC,MAAM,IAAI+F,KAAK,CAACnpB,UAAU,CAAC7hB,MAAM,GAAG,CAAC,EAAE;QACtCkhC,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC9P,KAAK,CAAC/F,eAAe,EAAE,oCAAoC,CAAC,CAAC;MAC1F;MACAukF,OAAO,GAAG,IAAI;IAChB,CAAC,MAAM,IAAI,CAAC1C,eAAe,CAACz1F,IAAI,CAAC2Z,KAAK,CAAClpC,IAAI,CAAC,EAAE;MAC5Co/B,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC9P,KAAK,CAAC/F,eAAe,EAAE,mCAAmC+F,KAAK,CAAClpC,IAAI,EAAE,CAAC,CAAC;IACrG;EACF;EACA,OAAOo/B,MAAM;AACf;AACA,SAASinF,mBAAmBA,CAAChrG,GAAG,EAAE;EAChC,MAAM+jB,MAAM,GAAG,EAAE;EACjB,IAAIuoF,UAAU,GAAG,KAAK;EACtB,IAAItsG,GAAG,CAAC0E,UAAU,CAAC7hB,MAAM,KAAK,CAAC,EAAE;IAC/BkhC,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC39B,GAAG,CAAC8nB,eAAe,EAAE,+CAA+C,CAAC,CAAC;IACjG,OAAO/D,MAAM;EACf;EACA,KAAK,MAAMzsB,IAAI,IAAI0I,GAAG,CAAC7U,QAAQ,EAAE;IAC/B,IAAImM,IAAI,YAAY8uB,OAAO,IAAI9uB,IAAI,YAAYivB,IAAI,IAAIjvB,IAAI,CAAC1S,KAAK,CAAC2tB,IAAI,CAAC,CAAC,CAAC1vB,MAAM,KAAK,CAAC,EAAE;MACrF;IACF;IACA,IAAI,EAAEyU,IAAI,YAAYw8D,KAAK,CAAC,IAAIx8D,IAAI,CAAC3S,IAAI,KAAK,MAAM,IAAI2S,IAAI,CAAC3S,IAAI,KAAK,SAAS,EAAE;MAC/Eo/B,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAACrmC,IAAI,CAACvE,UAAU,EAAE,0DAA0D,CAAC,CAAC;MACxG;IACF;IACA,IAAIuE,IAAI,CAAC3S,IAAI,KAAK,SAAS,EAAE;MAC3B,IAAI2nH,UAAU,EAAE;QACdvoF,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAACrmC,IAAI,CAACwwB,eAAe,EAAE,gDAAgD,CAAC,CAAC;MACrG,CAAC,MAAM,IAAIxwB,IAAI,CAACoN,UAAU,CAAC7hB,MAAM,GAAG,CAAC,EAAE;QACrCkhC,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAACrmC,IAAI,CAACwwB,eAAe,EAAE,uCAAuC,CAAC,CAAC;MAC5F;MACAwkF,UAAU,GAAG,IAAI;IACnB,CAAC,MAAM,IAAIh1G,IAAI,CAAC3S,IAAI,KAAK,MAAM,IAAI2S,IAAI,CAACoN,UAAU,CAAC7hB,MAAM,KAAK,CAAC,EAAE;MAC/DkhC,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAACrmC,IAAI,CAACwwB,eAAe,EAAE,6CAA6C,CAAC,CAAC;IAClG;EACF;EACA,OAAO/D,MAAM;AACf;AACA,SAASmnF,4BAA4BA,CAAClrG,GAAG,EAAEk7F,aAAa,EAAErjF,IAAI,EAAE;EAC9D,IAAIqB,KAAK;EACT,IAAIhqB,GAAG;EACP,IAAI,OAAO2oB,IAAI,KAAK,QAAQ,EAAE;IAC5BqB,KAAK,GAAGyvC,IAAI,CAACkwB,GAAG,CAAC,CAAC,EAAE74E,GAAG,CAACrU,UAAU,CAACgxC,WAAW,CAAC9kB,IAAI,CAAC,CAAC;IACrD3oB,GAAG,GAAGgqB,KAAK,GAAGrB,IAAI,CAACh1B,MAAM;EAC3B,CAAC,MAAM;IACLq2B,KAAK,GAAG,CAAC;IACThqB,GAAG,GAAG8Q,GAAG,CAACrU,UAAU,CAAC9I,MAAM;EAC7B;EACA,OAAOq4G,aAAa,CAACxrB,YAAY,CAAC1vE,GAAG,CAACrU,UAAU,CAAClI,KAAK,CAACy1B,KAAK,EAAEhqB,GAAG,CAAC,EAAE,KAAK,EAAE8Q,GAAG,CAACjN,UAAU,EAAEiN,GAAG,CAACjN,UAAU,CAACmmB,KAAK,CAACmjB,MAAM,GAAGnjB,KAAK,CAAC;AACjI;AACA,SAASoxF,+BAA+BA,CAACz8E,KAAK,EAAE9J,MAAM,EAAEm3E,aAAa,EAAE;EACrE,IAAIrtE,KAAK,CAACnpB,UAAU,CAAC7hB,MAAM,KAAK,CAAC,EAAE;IACjCkhC,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC9P,KAAK,CAAC/F,eAAe,EAAE,+CAA+C,CAAC,CAAC;IACnG,OAAO,IAAI;EACb;EACA,MAAMn8B,UAAU,GAAGu/G,4BAA4B,CAACr9E,KAAK,CAACnpB,UAAU,CAAC,CAAC,CAAC,EAAEw2F,aAAa,CAAC;EACnF,IAAItvE,eAAe,GAAG,IAAI;EAC1B,KAAK,IAAI3nC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4pC,KAAK,CAACnpB,UAAU,CAAC7hB,MAAM,EAAEoB,CAAC,EAAE,EAAE;IAChD,MAAM2X,KAAK,GAAGiyB,KAAK,CAACnpB,UAAU,CAACzgB,CAAC,CAAC;IACjC,MAAMsoH,UAAU,GAAG3wG,KAAK,CAACjQ,UAAU,CAAC3I,KAAK,CAAC0mH,yBAAyB,CAAC;IACpE,IAAI6C,UAAU,KAAK,IAAI,EAAE;MACvBxoF,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC/hC,KAAK,CAAC7I,UAAU,EAAE,uCAAuC6I,KAAK,CAACjQ,UAAU,GAAG,CAAC,CAAC;IAC3G,CAAC,MAAM,IAAIkiC,KAAK,CAAClpC,IAAI,KAAK,IAAI,IAAI,CAACglH,eAAe,CAACz1F,IAAI,CAAC2Z,KAAK,CAAClpC,IAAI,CAAC,EAAE;MACnEo/B,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC/hC,KAAK,CAAC7I,UAAU,EAAE,gEAAgE,CAAC,CAAC;IACjH,CAAC,MAAM,IAAI64B,eAAe,KAAK,IAAI,EAAE;MACnC7H,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC/hC,KAAK,CAAC7I,UAAU,EAAE,+CAA+C,CAAC,CAAC;IAChG,CAAC,MAAM;MACL,MAAMpO,IAAI,GAAG4nH,UAAU,CAAC,CAAC,CAAC,CAACh6F,IAAI,CAAC,CAAC;MACjC,IAAIs3F,kBAAkB,CAAC31F,IAAI,CAACvvB,IAAI,CAAC,EAAE;QACjC,MAAM6nH,aAAa,GAAG5wG,KAAK,CAAC7I,UAAU,CAACmmB,KAAK,CAACojB,MAAM,CAACiwE,UAAU,CAAC,CAAC,CAAC,CAAC1pH,MAAM,CAAC;QACzE,MAAM2oH,YAAY,GAAG,IAAIjuE,eAAe,CAACivE,aAAa,EAAEA,aAAa,CAAClwE,MAAM,CAAC33C,IAAI,CAAC9B,MAAM,CAAC,CAAC;QAC1F+oC,eAAe,GAAG,IAAIkB,QAAQ,CAACnoC,IAAI,EAAEA,IAAI,EAAE6mH,YAAY,EAAEA,YAAY,CAAC;MACxE,CAAC,MAAM;QACLznF,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC/hC,KAAK,CAAC7I,UAAU,EAAE,uDAAuD,CAAC,CAAC;MACxG;IACF;EACF;EACA,OAAO;IACLpH,UAAU;IACVigC;EACF,CAAC;AACH;AACA,SAASy/E,wBAAwBA,CAACzvG,KAAK,EAAEmoB,MAAM,EAAE;EAC/C,MAAMp4B,UAAU,GAAGiQ,KAAK,CAACjQ,UAAU;EACnC,MAAM8gH,UAAU,GAAG,MAAM;EACzB,IAAInzC,UAAU,GAAG,CAAC;EAClB,IAAIpgD,KAAK,GAAG,CAAC;EACb,IAAIhqB,GAAG,GAAGvD,UAAU,CAAC9I,MAAM,GAAG,CAAC;EAC/B,KAAK,IAAIoB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0H,UAAU,CAAC9I,MAAM,EAAEoB,CAAC,EAAE,EAAE;IAC1C,MAAMC,IAAI,GAAGyH,UAAU,CAAC1H,CAAC,CAAC;IAC1B,IAAIC,IAAI,KAAK,GAAG,EAAE;MAChBg1B,KAAK,GAAGj1B,CAAC,GAAG,CAAC;MACbq1E,UAAU,EAAE;IACd,CAAC,MAAM,IAAImzC,UAAU,CAACv4F,IAAI,CAAChwB,IAAI,CAAC,EAAE;MAChC;IACF,CAAC,MAAM;MACL;IACF;EACF;EACA,IAAIo1E,UAAU,KAAK,CAAC,EAAE;IACpB,OAAO3tE,UAAU;EACnB;EACA,KAAK,IAAI1H,CAAC,GAAG0H,UAAU,CAAC9I,MAAM,GAAG,CAAC,EAAEoB,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC/C,MAAMC,IAAI,GAAGyH,UAAU,CAAC1H,CAAC,CAAC;IAC1B,IAAIC,IAAI,KAAK,GAAG,EAAE;MAChBgL,GAAG,GAAGjL,CAAC;MACPq1E,UAAU,EAAE;MACZ,IAAIA,UAAU,KAAK,CAAC,EAAE;QACpB;MACF;IACF,CAAC,MAAM,IAAImzC,UAAU,CAACv4F,IAAI,CAAChwB,IAAI,CAAC,EAAE;MAChC;IACF,CAAC,MAAM;MACL;IACF;EACF;EACA,IAAIo1E,UAAU,KAAK,CAAC,EAAE;IACpBv1C,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC/hC,KAAK,CAAC7I,UAAU,EAAE,oCAAoC,CAAC,CAAC;IACnF,OAAO,IAAI;EACb;EACA,OAAOpH,UAAU,CAAClI,KAAK,CAACy1B,KAAK,EAAEhqB,GAAG,CAAC;AACrC;AACA,MAAM48G,WAAW,SAAS/rG,mBAAmB,CAAC;EAC5Cq1F,OAAO,GAAG,KAAK;EACfr0E,SAASA,CAAA,EAAG;IACV,IAAI,CAACq0E,OAAO,GAAG,IAAI;EACrB;AACF;AAEA,MAAMsX,YAAY,GAAG,oBAAoB;AACzC,MAAMC,iBAAiB,GAAG,MAAM;AAChC,MAAMC,sBAAsB,GAAG,IAAIrnH,GAAG,CAAC,CAAC,CAAC+1C,OAAO,EAAEE,OAAO,CAAC,EAAE,CAAClB,SAAS,EAAEE,SAAS,CAAC,EAAE,CAACxB,OAAO,EAAEC,OAAO,CAAC,CAAC,CAAC;AACxG,IAAI4zE,aAAa;AACjB,CAAC,UAAUA,aAAa,EAAE;EACxBA,aAAa,CAAC,MAAM,CAAC,GAAG,MAAM;EAC9BA,aAAa,CAAC,OAAO,CAAC,GAAG,OAAO;EAChCA,aAAa,CAAC,aAAa,CAAC,GAAG,aAAa;EAC5CA,aAAa,CAAC,WAAW,CAAC,GAAG,WAAW;EACxCA,aAAa,CAAC,OAAO,CAAC,GAAG,OAAO;EAChCA,aAAa,CAAC,UAAU,CAAC,GAAG,UAAU;EACtCA,aAAa,CAAC,OAAO,CAAC,GAAG,OAAO;AAClC,CAAC,EAAEA,aAAa,KAAKA,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC;AACzC,SAASC,iBAAiBA,CAAC;EACzBnhH,UAAU;EACVoH;AACF,CAAC,EAAEg3B,QAAQ,EAAEhG,MAAM,EAAE;EACnB,MAAMgpF,UAAU,GAAGphH,UAAU,CAAC2mB,OAAO,CAAC,OAAO,CAAC;EAC9C,MAAM06F,eAAe,GAAG,IAAIzvE,eAAe,CAACxqC,UAAU,CAACmmB,KAAK,CAACojB,MAAM,CAACywE,UAAU,CAAC,EAAEh6G,UAAU,CAACmmB,KAAK,CAACojB,MAAM,CAACywE,UAAU,GAAG,OAAO,CAAClqH,MAAM,CAAC,CAAC;EACtI,MAAMqlC,YAAY,GAAG+kF,eAAe,CAACthH,UAAU,EAAEoH,UAAU,CAAC;EAC5D,MAAMq1B,WAAW,GAAG8kF,cAAc,CAACvhH,UAAU,EAAEoH,UAAU,CAAC;EAC1D,IAAIg6G,UAAU,KAAK,CAAC,CAAC,EAAE;IACrBhpF,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC5qC,UAAU,EAAE,8CAA8C,CAAC,CAAC;EACzF,CAAC,MAAM;IACLo6G,YAAY,CAAC,OAAO,EAAEpjF,QAAQ,EAAEhG,MAAM,EAAE,IAAIyE,oBAAoB,CAACwkF,eAAe,EAAEj6G,UAAU,EAAEm1B,YAAY,EAAE,IAAI,EAAEE,WAAW,CAAC,CAAC;EACjI;AACF;AACA,SAASglF,gBAAgBA,CAAC;EACxBzhH,UAAU;EACVoH;AACF,CAAC,EAAEmoG,aAAa,EAAEnxE,QAAQ,EAAEhG,MAAM,EAAE;EAClC,MAAMspF,SAAS,GAAG1hH,UAAU,CAAC2mB,OAAO,CAAC,MAAM,CAAC;EAC5C,MAAMiW,cAAc,GAAG,IAAIgV,eAAe,CAACxqC,UAAU,CAACmmB,KAAK,CAACojB,MAAM,CAAC+wE,SAAS,CAAC,EAAEt6G,UAAU,CAACmmB,KAAK,CAACojB,MAAM,CAAC+wE,SAAS,GAAG,MAAM,CAACxqH,MAAM,CAAC,CAAC;EAClI,MAAMqlC,YAAY,GAAG+kF,eAAe,CAACthH,UAAU,EAAEoH,UAAU,CAAC;EAC5D,MAAMq1B,WAAW,GAAG8kF,cAAc,CAACvhH,UAAU,EAAEoH,UAAU,CAAC;EAC1D,IAAIs6G,SAAS,KAAK,CAAC,CAAC,EAAE;IACpBtpF,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC5qC,UAAU,EAAE,6CAA6C,CAAC,CAAC;EACxF,CAAC,MAAM;IACL,MAAMmmB,KAAK,GAAGo0F,yBAAyB,CAAC3hH,UAAU,EAAE0hH,SAAS,GAAG,CAAC,CAAC;IAClE,MAAME,MAAM,GAAGrS,aAAa,CAACxrB,YAAY,CAAC/jF,UAAU,CAAClI,KAAK,CAACy1B,KAAK,CAAC,EAAE,KAAK,EAAEnmB,UAAU,EAAEA,UAAU,CAACmmB,KAAK,CAACmjB,MAAM,GAAGnjB,KAAK,CAAC;IACtHi0F,YAAY,CAAC,MAAM,EAAEpjF,QAAQ,EAAEhG,MAAM,EAAE,IAAIuE,oBAAoB,CAACilF,MAAM,EAAEx6G,UAAU,EAAEm1B,YAAY,EAAEK,cAAc,EAAEH,WAAW,CAAC,CAAC;EACjI;AACF;AACA,SAASolF,cAAcA,CAAC;EACtB7hH,UAAU;EACVoH;AACF,CAAC,EAAEmoG,aAAa,EAAEnxE,QAAQ,EAAEhG,MAAM,EAAExpB,WAAW,EAAE;EAC/C,MAAMkzG,OAAO,GAAG9hH,UAAU,CAAC2mB,OAAO,CAAC,IAAI,CAAC;EACxC,MAAMsW,YAAY,GAAG,IAAI2U,eAAe,CAACxqC,UAAU,CAACmmB,KAAK,CAACojB,MAAM,CAACmxE,OAAO,CAAC,EAAE16G,UAAU,CAACmmB,KAAK,CAACojB,MAAM,CAACmxE,OAAO,GAAG,IAAI,CAAC5qH,MAAM,CAAC,CAAC;EAC1H,MAAMqlC,YAAY,GAAG+kF,eAAe,CAACthH,UAAU,EAAEoH,UAAU,CAAC;EAC5D,MAAMq1B,WAAW,GAAG8kF,cAAc,CAACvhH,UAAU,EAAEoH,UAAU,CAAC;EAC1D,IAAI06G,OAAO,KAAK,CAAC,CAAC,EAAE;IAClB1pF,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC5qC,UAAU,EAAE,2CAA2C,CAAC,CAAC;EACtF,CAAC,MAAM;IACL,MAAMmmB,KAAK,GAAGo0F,yBAAyB,CAAC3hH,UAAU,EAAE8hH,OAAO,GAAG,CAAC,CAAC;IAChE,MAAMC,kBAAkB,GAAG/hH,UAAU,CAACsoB,UAAU,CAAC,SAAS,CAAC;IAC3D,MAAMitD,MAAM,GAAG,IAAIysC,eAAe,CAAChiH,UAAU,EAAEuvG,aAAa,EAAEhiF,KAAK,EAAEnmB,UAAU,EAAEg3B,QAAQ,EAAEhG,MAAM,EAAE2pF,kBAAkB,GAAGE,oCAAoC,GAAGC,kCAAkC,EAAEH,kBAAkB,EAAExlF,YAAY,EAAEU,YAAY,EAAER,WAAW,CAAC;IAC/P84C,MAAM,CAAC3+E,KAAK,CAAC,CAAC;EAChB;AACF;AACA,SAAS0qH,eAAeA,CAACthH,UAAU,EAAEoH,UAAU,EAAE;EAC/C,IAAI,CAACpH,UAAU,CAACsoB,UAAU,CAAC,UAAU,CAAC,EAAE;IACtC,OAAO,IAAI;EACb;EACA,OAAO,IAAIspB,eAAe,CAACxqC,UAAU,CAACmmB,KAAK,EAAEnmB,UAAU,CAACmmB,KAAK,CAACojB,MAAM,CAAC,UAAU,CAACz5C,MAAM,CAAC,CAAC;AAC1F;AACA,SAASqqH,cAAcA,CAACvhH,UAAU,EAAEoH,UAAU,EAAE;EAC9C,IAAI,CAACpH,UAAU,CAACsoB,UAAU,CAAC,SAAS,CAAC,EAAE;IACrC,OAAO,IAAI;EACb;EACA,OAAO,IAAIspB,eAAe,CAACxqC,UAAU,CAACmmB,KAAK,EAAEnmB,UAAU,CAACmmB,KAAK,CAACojB,MAAM,CAAC,SAAS,CAACz5C,MAAM,CAAC,CAAC;AACzF;AACA,MAAM8qH,eAAe,CAAC;EACpBhiH,UAAU;EACVuvG,aAAa;EACbhiF,KAAK;EACLF,IAAI;EACJ+Q,QAAQ;EACRhG,MAAM;EACN+pF,SAAS;EACTJ,kBAAkB;EAClBxlF,YAAY;EACZU,YAAY;EACZR,WAAW;EACXh6B,KAAK,GAAG,CAAC;EACT8kE,MAAM;EACNvrE,WAAWA,CAACgE,UAAU,EAAEuvG,aAAa,EAAEhiF,KAAK,EAAEF,IAAI,EAAE+Q,QAAQ,EAAEhG,MAAM,EAAE+pF,SAAS,EAAEJ,kBAAkB,EAAExlF,YAAY,EAAEU,YAAY,EAAER,WAAW,EAAE;IAC5I,IAAI,CAACz8B,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACuvG,aAAa,GAAGA,aAAa;IAClC,IAAI,CAAChiF,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACF,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC+Q,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAChG,MAAM,GAAGA,MAAM;IACpB,IAAI,CAAC+pF,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACJ,kBAAkB,GAAGA,kBAAkB;IAC5C,IAAI,CAACxlF,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACU,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACR,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAAC8qC,MAAM,GAAG,IAAIwV,KAAK,CAAC,CAAC,CAAChU,QAAQ,CAAC/oE,UAAU,CAAClI,KAAK,CAACy1B,KAAK,CAAC,CAAC;EAC7D;EACA32B,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI,CAAC2wE,MAAM,CAACrwE,MAAM,GAAG,CAAC,IAAI,IAAI,CAACuL,KAAK,GAAG,IAAI,CAAC8kE,MAAM,CAACrwE,MAAM,EAAE;MAChE,MAAMqwB,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC,CAAC;MAC1B,IAAI,CAACA,KAAK,CAACo2D,YAAY,CAAC,CAAC,EAAE;QACzB,IAAI,CAACykC,eAAe,CAAC76F,KAAK,CAAC;QAC3B;MACF;MACA,IAAI,IAAI,CAAC86F,kBAAkB,CAAC50E,MAAM,CAAC,EAAE;QACnC,IAAI,CAAC60E,cAAc,CAAC/6F,KAAK,EAAE,EAAE,CAAC;QAC9B,IAAI,CAAClN,OAAO,CAAC,CAAC;MAChB,CAAC,MAAM,IAAI,IAAI,CAACgoG,kBAAkB,CAACh1E,OAAO,CAAC,EAAE;QAC3C,IAAI,CAAChzB,OAAO,CAAC,CAAC;QACd,MAAMkoG,UAAU,GAAG,IAAI,CAACnqF,MAAM,CAAClhC,MAAM;QACrC,MAAM6hB,UAAU,GAAG,IAAI,CAACypG,iBAAiB,CAAC,CAAC;QAC3C,IAAI,IAAI,CAACpqF,MAAM,CAAClhC,MAAM,KAAKqrH,UAAU,EAAE;UACrC;QACF;QACA,IAAI,CAACD,cAAc,CAAC/6F,KAAK,EAAExO,UAAU,CAAC;QACtC,IAAI,CAACsB,OAAO,CAAC,CAAC;MAChB,CAAC,MAAM,IAAI,IAAI,CAAC5X,KAAK,GAAG,IAAI,CAAC8kE,MAAM,CAACrwE,MAAM,GAAG,CAAC,EAAE;QAC9C,IAAI,CAACkrH,eAAe,CAAC,IAAI,CAAC76C,MAAM,CAAC,IAAI,CAAC9kE,KAAK,GAAG,CAAC,CAAC,CAAC;MACnD;MACA,IAAI,CAAC4X,OAAO,CAAC,CAAC;IAChB;EACF;EACAA,OAAOA,CAAA,EAAG;IACR,IAAI,CAAC5X,KAAK,EAAE;EACd;EACA4/G,kBAAkBA,CAAC9pH,IAAI,EAAE;IACvB,IAAI,IAAI,CAACkK,KAAK,KAAK,IAAI,CAAC8kE,MAAM,CAACrwE,MAAM,GAAG,CAAC,EAAE;MACzC,OAAO,IAAI;IACb;IACA,OAAO,IAAI,CAACqwE,MAAM,CAAC,IAAI,CAAC9kE,KAAK,GAAG,CAAC,CAAC,CAAC46E,WAAW,CAAC9kF,IAAI,CAAC;EACtD;EACAgvB,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI,CAACggD,MAAM,CAACvK,IAAI,CAACylD,GAAG,CAAC,IAAI,CAAChgH,KAAK,EAAE,IAAI,CAAC8kE,MAAM,CAACrwE,MAAM,GAAG,CAAC,CAAC,CAAC;EAClE;EACAorH,cAAcA,CAACtvE,UAAU,EAAEj6B,UAAU,EAAE;IACrC,MAAM2pG,oBAAoB,GAAG,IAAI,CAACr1F,IAAI,CAACE,KAAK,CAACojB,MAAM,CAAC,IAAI,CAACpjB,KAAK,GAAGylB,UAAU,CAACvwC,KAAK,GAAG,IAAI,CAAC8kE,MAAM,CAAC,CAAC,CAAC,CAAC9kE,KAAK,CAAC;IACzG,MAAMoxB,QAAQ,GAAG,IAAI+d,eAAe,CAAC8wE,oBAAoB,EAAEA,oBAAoB,CAAC/xE,MAAM,CAACqC,UAAU,CAACoqC,QAAQ,CAAClmF,MAAM,CAAC,CAAC;IACnH,MAAMwgF,OAAO,GAAGgrC,oBAAoB,CAAC/xE,MAAM,CAAC,IAAI,CAACppB,KAAK,CAAC,CAAC,CAAChkB,GAAG,GAAGyvC,UAAU,CAACvwC,KAAK,CAAC;IAChF,MAAMkgH,cAAc,GAAG3vE,UAAU,CAACvwC,KAAK,KAAK,CAAC;IAC7C,MAAMw6B,YAAY,GAAG0lF,cAAc,GAAG,IAAI,CAAC1lF,YAAY,GAAG,IAAI;IAC9D,MAAM2lF,kBAAkB,GAAGD,cAAc,GAAG,IAAI,CAACpmF,YAAY,GAAG,IAAI;IACpE,MAAMsmF,iBAAiB,GAAGF,cAAc,GAAG,IAAI,CAAClmF,WAAW,GAAG,IAAI;IAClE,MAAMr1B,UAAU,GAAG,IAAIwqC,eAAe,CAAC+wE,cAAc,GAAG,IAAI,CAACt1F,IAAI,CAACE,KAAK,GAAGm1F,oBAAoB,EAAEhrC,OAAO,CAAC;IACxG,IAAI;MACF,QAAQ1kC,UAAU,CAAC75C,QAAQ,CAAC,CAAC;QAC3B,KAAK+nH,aAAa,CAAC4B,IAAI;UACrB,IAAI,CAACtB,YAAY,CAAC,MAAM,EAAEuB,iBAAiB,CAAChqG,UAAU,EAAE8a,QAAQ,EAAEzsB,UAAU,EAAEw7G,kBAAkB,EAAE3lF,YAAY,EAAE4lF,iBAAiB,CAAC,CAAC;UACnI;QACF,KAAK3B,aAAa,CAAC8B,KAAK;UACtB,IAAI,CAACxB,YAAY,CAAC,OAAO,EAAEyB,kBAAkB,CAAClqG,UAAU,EAAE8a,QAAQ,EAAEzsB,UAAU,EAAE,IAAI,CAACm1B,YAAY,EAAE,IAAI,CAACU,YAAY,EAAE,IAAI,CAACR,WAAW,CAAC,CAAC;UACxI;QACF,KAAKykF,aAAa,CAACgC,WAAW;UAC5B,IAAI,CAAC1B,YAAY,CAAC,aAAa,EAAE2B,wBAAwB,CAACpqG,UAAU,EAAE8a,QAAQ,EAAEzsB,UAAU,EAAE,IAAI,CAACm1B,YAAY,EAAE,IAAI,CAACU,YAAY,EAAE,IAAI,CAACR,WAAW,EAAE,IAAI,CAAC0lF,SAAS,CAAC,CAAC;UACpK;QACF,KAAKjB,aAAa,CAACkC,SAAS;UAC1B,IAAI,CAAC5B,YAAY,CAAC,WAAW,EAAE6B,sBAAsB,CAACtqG,UAAU,EAAE8a,QAAQ,EAAEzsB,UAAU,EAAE,IAAI,CAACm1B,YAAY,EAAE,IAAI,CAACU,YAAY,EAAE,IAAI,CAACR,WAAW,CAAC,CAAC;UAChJ;QACF,KAAKykF,aAAa,CAACoC,KAAK;UACtB,IAAI,CAAC9B,YAAY,CAAC,OAAO,EAAE+B,kBAAkB,CAACxqG,UAAU,EAAE8a,QAAQ,EAAEzsB,UAAU,EAAE,IAAI,CAACm1B,YAAY,EAAE,IAAI,CAACU,YAAY,EAAE,IAAI,CAACR,WAAW,EAAE,IAAI,CAAC0lF,SAAS,CAAC,CAAC;UACxJ;QACF,KAAKjB,aAAa,CAACsC,QAAQ;UACzB,IAAI,CAAChC,YAAY,CAAC,UAAU,EAAEiC,qBAAqB,CAAC,IAAI,CAACl2F,KAAK,EAAE,IAAI,CAACw0F,kBAAkB,EAAE,IAAI,CAACxS,aAAa,EAAEx2F,UAAU,EAAE8a,QAAQ,EAAEzsB,UAAU,EAAE,IAAI,CAACm1B,YAAY,EAAE,IAAI,CAACU,YAAY,EAAE,IAAI,CAACR,WAAW,EAAE,IAAI,CAAC0lF,SAAS,CAAC,CAAC;UACvN;QACF;UACE,MAAM,IAAIzqH,KAAK,CAAC,8BAA8Bs7C,UAAU,GAAG,CAAC;MAChE;IACF,CAAC,CAAC,OAAOvxC,CAAC,EAAE;MACV,IAAI,CAACy8B,KAAK,CAAC8U,UAAU,EAAEvxC,CAAC,CAACtD,OAAO,CAAC;IACnC;EACF;EACAqkH,iBAAiBA,CAAA,EAAG;IAClB,MAAMzpG,UAAU,GAAG,EAAE;IACrB,IAAI,CAAC,IAAI,CAACwO,KAAK,CAAC,CAAC,CAAC81D,WAAW,CAAChwC,OAAO,CAAC,EAAE;MACtC,IAAI,CAAC+0E,eAAe,CAAC,IAAI,CAAC76F,KAAK,CAAC,CAAC,CAAC;MAClC,OAAOxO,UAAU;IACnB;IACA,IAAI,CAACsB,OAAO,CAAC,CAAC;IACd,MAAMqpG,eAAe,GAAG,EAAE;IAC1B,IAAIn8C,MAAM,GAAG,EAAE;IACf,OAAO,IAAI,CAAC9kE,KAAK,GAAG,IAAI,CAAC8kE,MAAM,CAACrwE,MAAM,EAAE;MACtC,MAAMqwB,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC,CAAC;MAC1B,IAAIA,KAAK,CAAC81D,WAAW,CAAC/vC,OAAO,CAAC,IAAIo2E,eAAe,CAACxsH,MAAM,KAAK,CAAC,EAAE;QAC9D,IAAIqwE,MAAM,CAACrwE,MAAM,EAAE;UACjB6hB,UAAU,CAAC5hB,IAAI,CAAC;YACd6I,UAAU,EAAE,IAAI,CAAC2jH,cAAc,CAACp8C,MAAM,CAAC;YACvCh6C,KAAK,EAAEg6C,MAAM,CAAC,CAAC,CAAC,CAAC9kE;UACnB,CAAC,CAAC;QACJ;QACA;MACF;MACA,IAAI8kB,KAAK,CAACtnB,IAAI,KAAK28E,SAAS,CAACU,SAAS,IAAI2jC,sBAAsB,CAAC5kH,GAAG,CAACkrB,KAAK,CAAC41D,QAAQ,CAAC,EAAE;QACpFumC,eAAe,CAACvsH,IAAI,CAAC8pH,sBAAsB,CAAChmH,GAAG,CAACssB,KAAK,CAAC41D,QAAQ,CAAC,CAAC;MAClE;MACA,IAAIumC,eAAe,CAACxsH,MAAM,GAAG,CAAC,IAAIqwB,KAAK,CAAC81D,WAAW,CAACqmC,eAAe,CAACA,eAAe,CAACxsH,MAAM,GAAG,CAAC,CAAC,CAAC,EAAE;QAChGwsH,eAAe,CAACr3F,GAAG,CAAC,CAAC;MACvB;MACA,IAAIq3F,eAAe,CAACxsH,MAAM,KAAK,CAAC,IAAIqwB,KAAK,CAAC81D,WAAW,CAAC5vC,MAAM,CAAC,IAAI85B,MAAM,CAACrwE,MAAM,GAAG,CAAC,EAAE;QAClF6hB,UAAU,CAAC5hB,IAAI,CAAC;UACd6I,UAAU,EAAE,IAAI,CAAC2jH,cAAc,CAACp8C,MAAM,CAAC;UACvCh6C,KAAK,EAAEg6C,MAAM,CAAC,CAAC,CAAC,CAAC9kE;QACnB,CAAC,CAAC;QACF,IAAI,CAAC4X,OAAO,CAAC,CAAC;QACdktD,MAAM,GAAG,EAAE;QACX;MACF;MACAA,MAAM,CAACpwE,IAAI,CAACowB,KAAK,CAAC;MAClB,IAAI,CAAClN,OAAO,CAAC,CAAC;IAChB;IACA,IAAI,CAAC,IAAI,CAACkN,KAAK,CAAC,CAAC,CAAC81D,WAAW,CAAC/vC,OAAO,CAAC,IAAIo2E,eAAe,CAACxsH,MAAM,GAAG,CAAC,EAAE;MACpE,IAAI,CAACgnC,KAAK,CAAC,IAAI,CAAC3W,KAAK,CAAC,CAAC,EAAE,8BAA8B,CAAC;IAC1D;IACA,IAAI,IAAI,CAAC9kB,KAAK,GAAG,IAAI,CAAC8kE,MAAM,CAACrwE,MAAM,GAAG,CAAC,IAAI,CAAC,IAAI,CAACqwE,MAAM,CAAC,IAAI,CAAC9kE,KAAK,GAAG,CAAC,CAAC,CAAC46E,WAAW,CAAC5vC,MAAM,CAAC,EAAE;MAC3F,IAAI,CAAC20E,eAAe,CAAC,IAAI,CAAC76C,MAAM,CAAC,IAAI,CAAC9kE,KAAK,GAAG,CAAC,CAAC,CAAC;IACnD;IACA,OAAOsW,UAAU;EACnB;EACA4qG,cAAcA,CAACp8C,MAAM,EAAE;IACrB,IAAIA,MAAM,CAACrwE,MAAM,KAAK,CAAC,EAAE;MACvB,OAAO,EAAE;IACX;IACA,OAAO,IAAI,CAAC8I,UAAU,CAAClI,KAAK,CAAC,IAAI,CAACy1B,KAAK,GAAGg6C,MAAM,CAAC,CAAC,CAAC,CAAC9kE,KAAK,EAAE,IAAI,CAAC8qB,KAAK,GAAGg6C,MAAM,CAACA,MAAM,CAACrwE,MAAM,GAAG,CAAC,CAAC,CAACqM,GAAG,CAAC;EACxG;EACAi+G,YAAYA,CAACxoH,IAAI,EAAEspC,OAAO,EAAE;IAC1Bk/E,YAAY,CAACxoH,IAAI,EAAE,IAAI,CAAColC,QAAQ,EAAE,IAAI,CAAChG,MAAM,EAAEkK,OAAO,CAAC;EACzD;EACApE,KAAKA,CAAC3W,KAAK,EAAEppB,OAAO,EAAE;IACpB,MAAMylH,QAAQ,GAAG,IAAI,CAACv2F,IAAI,CAACE,KAAK,CAACojB,MAAM,CAAC,IAAI,CAACpjB,KAAK,GAAGhG,KAAK,CAAC9kB,KAAK,CAAC;IACjE,MAAMohH,MAAM,GAAGD,QAAQ,CAACjzE,MAAM,CAACppB,KAAK,CAAChkB,GAAG,GAAGgkB,KAAK,CAAC9kB,KAAK,CAAC;IACvD,IAAI,CAAC21B,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC,IAAIJ,eAAe,CAACgyE,QAAQ,EAAEC,MAAM,CAAC,EAAE1lH,OAAO,CAAC,CAAC;EAClF;EACAikH,eAAeA,CAAC76F,KAAK,EAAE;IACrB,IAAI,CAAC2W,KAAK,CAAC3W,KAAK,EAAE,qBAAqBA,KAAK,GAAG,CAAC;EAClD;AACF;AACA,SAASi6F,YAAYA,CAACxoH,IAAI,EAAE8qH,WAAW,EAAE1rF,MAAM,EAAEkK,OAAO,EAAE;EACxD,IAAIwhF,WAAW,CAAC9qH,IAAI,CAAC,EAAE;IACrBo/B,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC1P,OAAO,CAACl7B,UAAU,EAAE,cAAcpO,IAAI,0BAA0B,CAAC,CAAC;EAC/F,CAAC,MAAM;IACL8qH,WAAW,CAAC9qH,IAAI,CAAC,GAAGspC,OAAO;EAC7B;AACF;AACA,SAASygF,iBAAiBA,CAAChqG,UAAU,EAAE8a,QAAQ,EAAEzsB,UAAU,EAAEm1B,YAAY,EAAEU,YAAY,EAAER,WAAW,EAAE;EACpG,IAAI1jB,UAAU,CAAC7hB,MAAM,GAAG,CAAC,EAAE;IACzB,MAAM,IAAIQ,KAAK,CAAC,IAAIwpH,aAAa,CAAC4B,IAAI,kCAAkC,CAAC;EAC3E;EACA,OAAO,IAAIhmF,mBAAmB,CAACjJ,QAAQ,EAAEzsB,UAAU,EAAEm1B,YAAY,EAAEU,YAAY,EAAER,WAAW,CAAC;AAC/F;AACA,SAASwmF,kBAAkBA,CAAClqG,UAAU,EAAE8a,QAAQ,EAAEzsB,UAAU,EAAEm1B,YAAY,EAAEU,YAAY,EAAER,WAAW,EAAE;EACrG,IAAI1jB,UAAU,CAAC7hB,MAAM,KAAK,CAAC,EAAE;IAC3B,MAAM,IAAIQ,KAAK,CAAC,IAAIwpH,aAAa,CAAC8B,KAAK,2CAA2C,CAAC;EACrF;EACA,MAAM7lF,KAAK,GAAG4mF,iBAAiB,CAAChrG,UAAU,CAAC,CAAC,CAAC,CAAC/Y,UAAU,CAAC;EACzD,IAAIm9B,KAAK,KAAK,IAAI,EAAE;IAClB,MAAM,IAAIzlC,KAAK,CAAC,0CAA0CwpH,aAAa,CAAC8B,KAAK,GAAG,CAAC;EACnF;EACA,OAAO,IAAI9lF,oBAAoB,CAACC,KAAK,EAAEtJ,QAAQ,EAAEzsB,UAAU,EAAEm1B,YAAY,EAAEU,YAAY,EAAER,WAAW,CAAC;AACvG;AACA,SAAS4mF,sBAAsBA,CAACtqG,UAAU,EAAE8a,QAAQ,EAAEzsB,UAAU,EAAEm1B,YAAY,EAAEU,YAAY,EAAER,WAAW,EAAE;EACzG,IAAI1jB,UAAU,CAAC7hB,MAAM,GAAG,CAAC,EAAE;IACzB,MAAM,IAAIQ,KAAK,CAAC,IAAIwpH,aAAa,CAACkC,SAAS,kCAAkC,CAAC;EAChF;EACA,OAAO,IAAIrmF,wBAAwB,CAAClJ,QAAQ,EAAEzsB,UAAU,EAAEm1B,YAAY,EAAEU,YAAY,EAAER,WAAW,CAAC;AACpG;AACA,SAAS8mF,kBAAkBA,CAACxqG,UAAU,EAAE8a,QAAQ,EAAEzsB,UAAU,EAAEm1B,YAAY,EAAEU,YAAY,EAAER,WAAW,EAAE0lF,SAAS,EAAE;EAChHA,SAAS,CAACjB,aAAa,CAACoC,KAAK,EAAEvqG,UAAU,CAAC;EAC1C,OAAO,IAAIikB,oBAAoB,CAACjkB,UAAU,CAAC,CAAC,CAAC,EAAE/Y,UAAU,IAAI,IAAI,EAAE6zB,QAAQ,EAAEzsB,UAAU,EAAEm1B,YAAY,EAAEU,YAAY,EAAER,WAAW,CAAC;AACnI;AACA,SAAS0mF,wBAAwBA,CAACpqG,UAAU,EAAE8a,QAAQ,EAAEzsB,UAAU,EAAEm1B,YAAY,EAAEU,YAAY,EAAER,WAAW,EAAE0lF,SAAS,EAAE;EACtHA,SAAS,CAACjB,aAAa,CAACgC,WAAW,EAAEnqG,UAAU,CAAC;EAChD,OAAO,IAAIqkB,0BAA0B,CAACrkB,UAAU,CAAC,CAAC,CAAC,EAAE/Y,UAAU,IAAI,IAAI,EAAE6zB,QAAQ,EAAEzsB,UAAU,EAAEm1B,YAAY,EAAEU,YAAY,EAAER,WAAW,CAAC;AACzI;AACA,SAASgnF,qBAAqBA,CAACl2F,KAAK,EAAEw0F,kBAAkB,EAAExS,aAAa,EAAEx2F,UAAU,EAAE8a,QAAQ,EAAEzsB,UAAU,EAAEm1B,YAAY,EAAEU,YAAY,EAAER,WAAW,EAAE0lF,SAAS,EAAE;EAC7JA,SAAS,CAACjB,aAAa,CAACsC,QAAQ,EAAEzqG,UAAU,CAAC;EAC7C,IAAI4H,SAAS;EACb,IAAI2c,OAAO;EACX,IAAIvkB,UAAU,CAAC7hB,MAAM,KAAK,CAAC,EAAE;IAC3BypB,SAAS,GAAG2c,OAAO,GAAG,IAAI;EAC5B,CAAC,MAAM,IAAI,CAACvkB,UAAU,CAAC,CAAC,CAAC,CAAC/Y,UAAU,CAACsoB,UAAU,CAAC,GAAG,CAAC,EAAE;IACpD3H,SAAS,GAAG5H,UAAU,CAAC,CAAC,CAAC,CAAC/Y,UAAU;IACpCs9B,OAAO,GAAG,IAAI;EAChB,CAAC,MAAM;IACL,MAAMskF,MAAM,GAAGrS,aAAa,CAACxrB,YAAY,CAAChrE,UAAU,CAAC,CAAC,CAAC,CAAC/Y,UAAU,EAAE,KAAK,EAAEoH,UAAU,EAAEA,UAAU,CAACmmB,KAAK,CAACmjB,MAAM,GAAGnjB,KAAK,GAAGxU,UAAU,CAAC,CAAC,CAAC,CAACwU,KAAK,CAAC;IAC7I,IAAI,EAAEq0F,MAAM,CAACvtG,GAAG,YAAYohB,UAAU,CAAC,EAAE;MACvC,MAAM,IAAI/9B,KAAK,CAAC,uEAAuE,CAAC;IAC1F,CAAC,MAAM,IAAIkqH,MAAM,CAACvtG,GAAG,CAACxU,IAAI,CAAC8oC,IAAI,CAACphC,GAAG,IAAIA,GAAG,CAACA,GAAG,KAAK,MAAM,CAAC,EAAE;MAC1D,MAAM,IAAI7P,KAAK,CAAC,uFAAuF,CAAC;IAC1G;IACA,MAAMssH,YAAY,GAAGpC,MAAM,CAACvtG,GAAG,CAACxU,IAAI,CAACu8D,SAAS,CAAC70D,GAAG,IAAIA,GAAG,CAACA,GAAG,KAAK,SAAS,CAAC;IAC5E,IAAIy8G,YAAY,KAAK,CAAC,CAAC,EAAE;MACvBrjG,SAAS,GAAG,IAAI;MAChB2c,OAAO,GAAGskF,MAAM,CAACvtG,GAAG;IACtB,CAAC,MAAM;MACL,MAAMpb,KAAK,GAAG2oH,MAAM,CAACvtG,GAAG,CAACc,MAAM,CAAC6uG,YAAY,CAAC;MAC7C,MAAMC,aAAa,GAAGA,CAAC9pE,CAAC,EAAE13C,KAAK,KAAKA,KAAK,KAAKuhH,YAAY;MAC1D,IAAI,EAAE/qH,KAAK,YAAYy7B,YAAY,CAAC,IAAI,EAAEz7B,KAAK,CAAC8S,QAAQ,YAAYioB,gBAAgB,CAAC,IAAI/6B,KAAK,CAAC8S,QAAQ,YAAYmoB,YAAY,EAAE;QAC/H,MAAM,IAAIx8B,KAAK,CAAC,kEAAkE,CAAC;MACrF;MACAipB,SAAS,GAAG1nB,KAAK,CAACD,IAAI;MACtBskC,OAAO,GAAG,IAAI7H,UAAU,CAACmsF,MAAM,CAACvtG,GAAG,CAACgZ,IAAI,EAAEu0F,MAAM,CAACvtG,GAAG,CAACjN,UAAU,EAAEw6G,MAAM,CAACvtG,GAAG,CAACxU,IAAI,CAACgZ,MAAM,CAACorG,aAAa,CAAC,EAAErC,MAAM,CAACvtG,GAAG,CAACc,MAAM,CAAC0D,MAAM,CAACorG,aAAa,CAAC,CAAC;IAClJ;EACF;EACA,IAAIlC,kBAAkB,IAAIphG,SAAS,KAAK,IAAI,EAAE;IAC5C,MAAM,IAAIjpB,KAAK,CAAC,sDAAsD,CAAC;EACzE,CAAC,MAAM,IAAI4lC,OAAO,EAAE;IAClB,MAAM4mF,WAAW,GAAGC,mBAAmB,CAACC,eAAe,CAAC9mF,OAAO,CAAC;IAChE,IAAI4mF,WAAW,KAAK,IAAI,EAAE;MACxB,MAAM,IAAIxsH,KAAK,CAAC,sDAAsD,GAAG,gDAAgDwsH,WAAW,CAACloH,WAAW,CAAChD,IAAI,aAAa,CAAC;IACrK;EACF;EACA,OAAO,IAAIqkC,uBAAuB,CAAC1c,SAAS,EAAE2c,OAAO,EAAEzJ,QAAQ,EAAEzsB,UAAU,EAAEm1B,YAAY,EAAEU,YAAY,EAAER,WAAW,CAAC;AACvH;AACA,SAASylF,kCAAkCA,CAACjiH,IAAI,EAAE8Y,UAAU,EAAE;EAC5D,IAAIA,UAAU,CAAC7hB,MAAM,GAAG,CAAC,EAAE;IACzB,MAAM,IAAIQ,KAAK,CAAC,IAAIuI,IAAI,gDAAgD,CAAC;EAC3E;AACF;AACA,SAASgiH,oCAAoCA,CAAChiH,IAAI,EAAE8Y,UAAU,EAAE;EAC9D,IAAI9Y,IAAI,KAAKihH,aAAa,CAACsC,QAAQ,EAAE;IACnC,IAAIzqG,UAAU,CAAC7hB,MAAM,GAAG,CAAC,EAAE;MACzB,MAAM,IAAIQ,KAAK,CAAC,sBAAsBuI,IAAI,uCAAuC,CAAC;IACpF;IACA;EACF;EACA,IAAI8Y,UAAU,CAAC7hB,MAAM,GAAG,CAAC,EAAE;IACzB,MAAM,IAAIQ,KAAK,CAAC,sBAAsBuI,IAAI,0BAA0B,CAAC;EACvE;AACF;AACA,SAAS0hH,yBAAyBA,CAAC1oH,KAAK,EAAEorH,aAAa,GAAG,CAAC,EAAE;EAC3D,IAAIC,iBAAiB,GAAG,KAAK;EAC7B,KAAK,IAAIhsH,CAAC,GAAG+rH,aAAa,EAAE/rH,CAAC,GAAGW,KAAK,CAAC/B,MAAM,EAAEoB,CAAC,EAAE,EAAE;IACjD,IAAI0oH,iBAAiB,CAACz4F,IAAI,CAACtvB,KAAK,CAACX,CAAC,CAAC,CAAC,EAAE;MACpCgsH,iBAAiB,GAAG,IAAI;IAC1B,CAAC,MAAM,IAAIA,iBAAiB,EAAE;MAC5B,OAAOhsH,CAAC;IACV;EACF;EACA,OAAO,CAAC,CAAC;AACX;AACA,SAASyrH,iBAAiBA,CAAC9qH,KAAK,EAAE;EAChC,MAAM5B,KAAK,GAAG4B,KAAK,CAAC5B,KAAK,CAAC0pH,YAAY,CAAC;EACvC,IAAI,CAAC1pH,KAAK,EAAE;IACV,OAAO,IAAI;EACb;EACA,MAAM,CAACktH,IAAI,EAAE9rD,KAAK,CAAC,GAAGphE,KAAK;EAC3B,OAAOwqF,UAAU,CAAC0iC,IAAI,CAAC,IAAI9rD,KAAK,KAAK,GAAG,GAAG,IAAI,GAAG,CAAC,CAAC;AACtD;AACA,MAAM0rD,mBAAmB,SAAS/vG,mBAAmB,CAAC;EACpD8vG,WAAW,GAAG,IAAI;EAClB,OAAOE,eAAeA,CAAC/vG,GAAG,EAAE;IAC1B,MAAMzV,OAAO,GAAG,IAAIulH,mBAAmB,CAAC,CAAC;IACzCvlH,OAAO,CAACI,KAAK,CAACqV,GAAG,CAAC;IAClB,OAAOzV,OAAO,CAACslH,WAAW;EAC5B;EACAllH,KAAKA,CAACqV,GAAG,EAAE;IACT,IAAI,EAAEA,GAAG,YAAY6jB,aAAa,CAAC,IAAI,EAAE7jB,GAAG,YAAYghB,gBAAgB,CAAC,IAAI,EAAEhhB,GAAG,YAAYkhB,YAAY,CAAC,IAAI,EAAElhB,GAAG,YAAYohB,UAAU,CAAC,EAAE;MAC3I,IAAI,CAACyuF,WAAW,GAAG7vG,GAAG;IACxB,CAAC,MAAM;MACL,KAAK,CAACrV,KAAK,CAACqV,GAAG,CAAC;IAClB;EACF;AACF;AAEA,MAAMmwG,qBAAqB,GAAG,oBAAoB;AAClD,MAAMC,mBAAmB,GAAG,kBAAkB;AAC9C,MAAMC,oBAAoB,GAAG,mBAAmB;AAChD,MAAMC,kBAAkB,GAAG,iBAAiB;AAC5C,MAAMC,qBAAqB,GAAG,wBAAwB;AACtD,MAAMC,yBAAyB,GAAG,YAAY;AAC9C,MAAMC,uBAAuB,GAAG,UAAU;AAC1C,MAAMC,sBAAsB,GAAG,SAAS;AACxC,MAAMC,oBAAoB,GAAG,OAAO;AACpC,SAASC,yBAAyBA,CAACjsH,IAAI,EAAE;EACvC,OAAOA,IAAI,KAAK,aAAa,IAAIA,IAAI,KAAK,SAAS,IAAIA,IAAI,KAAK,OAAO;AACzE;AACA,SAASksH,mBAAmBA,CAAC7wG,GAAG,EAAEmqG,eAAe,EAAE5/G,OAAO,EAAE2wG,aAAa,EAAE;EACzE,MAAMn3E,MAAM,GAAG,EAAE;EACjB,MAAM;IACJxpB,WAAW;IACXqvB,OAAO;IACPC;EACF,CAAC,GAAGinF,oBAAoB,CAAC3G,eAAe,EAAEpmF,MAAM,EAAEx5B,OAAO,CAAC;EAC1D,MAAM;IACJw/B,QAAQ;IACRC,gBAAgB;IAChBC;EACF,CAAC,GAAG8mF,oBAAoB,CAAC/wG,GAAG,EAAEk7F,aAAa,EAAEn3E,MAAM,CAAC;EACpD,IAAIitF,iBAAiB,GAAGhxG,GAAG,CAAC+nB,aAAa;EACzC,IAAIkpF,mBAAmB,GAAGjxG,GAAG,CAACjN,UAAU,CAAC7D,GAAG;EAC5C,IAAIi7G,eAAe,CAACtnH,MAAM,GAAG,CAAC,EAAE;IAC9B,MAAMquH,kBAAkB,GAAG/G,eAAe,CAACA,eAAe,CAACtnH,MAAM,GAAG,CAAC,CAAC;IACtEmuH,iBAAiB,GAAGE,kBAAkB,CAACnpF,aAAa;IACpDkpF,mBAAmB,GAAGC,kBAAkB,CAACn+G,UAAU,CAAC7D,GAAG;EACzD;EACA,MAAMiiH,6BAA6B,GAAG,IAAI5zE,eAAe,CAACv9B,GAAG,CAACjN,UAAU,CAACmmB,KAAK,EAAE+3F,mBAAmB,CAAC;EACpG,MAAM35G,IAAI,GAAG,IAAIqyB,aAAa,CAACxF,QAAQ,CAAC55B,OAAO,EAAEyV,GAAG,CAAC7U,QAAQ,EAAE6U,GAAG,CAAC7U,QAAQ,CAAC,EAAE4+B,QAAQ,EAAEC,gBAAgB,EAAEC,eAAe,EAAE1vB,WAAW,EAAEqvB,OAAO,EAAEC,KAAK,EAAE7pB,GAAG,CAACwf,QAAQ,EAAE2xF,6BAA6B,EAAEnxG,GAAG,CAACjN,UAAU,EAAEiN,GAAG,CAAC8nB,eAAe,EAAEkpF,iBAAiB,EAAEhxG,GAAG,CAAC4L,IAAI,CAAC;EACtQ,OAAO;IACLtU,IAAI;IACJysB;EACF,CAAC;AACH;AACA,SAAS+sF,oBAAoBA,CAAC3G,eAAe,EAAEpmF,MAAM,EAAEx5B,OAAO,EAAE;EAC9D,IAAIgQ,WAAW,GAAG,IAAI;EACtB,IAAIqvB,OAAO,GAAG,IAAI;EAClB,IAAIC,KAAK,GAAG,IAAI;EAChB,KAAK,MAAMgE,KAAK,IAAIs8E,eAAe,EAAE;IACnC,IAAI;MACF,IAAI,CAACyG,yBAAyB,CAAC/iF,KAAK,CAAClpC,IAAI,CAAC,EAAE;QAC1Co/B,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC9P,KAAK,CAAC/F,eAAe,EAAE,wBAAwB+F,KAAK,CAAClpC,IAAI,GAAG,CAAC,CAAC;QACzF;MACF;MACA,QAAQkpC,KAAK,CAAClpC,IAAI;QAChB,KAAK,aAAa;UAChB,IAAI4V,WAAW,KAAK,IAAI,EAAE;YACxBwpB,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC9P,KAAK,CAAC/F,eAAe,EAAE,mDAAmD,CAAC,CAAC;UACzG,CAAC,MAAM;YACLvtB,WAAW,GAAG62G,qBAAqB,CAACvjF,KAAK,EAAEtjC,OAAO,CAAC;UACrD;UACA;QACF,KAAK,SAAS;UACZ,IAAIq/B,OAAO,KAAK,IAAI,EAAE;YACpB7F,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC9P,KAAK,CAAC/F,eAAe,EAAE,+CAA+C,CAAC,CAAC;UACrG,CAAC,MAAM;YACL8B,OAAO,GAAGynF,iBAAiB,CAACxjF,KAAK,EAAEtjC,OAAO,CAAC;UAC7C;UACA;QACF,KAAK,OAAO;UACV,IAAIs/B,KAAK,KAAK,IAAI,EAAE;YAClB9F,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC9P,KAAK,CAAC/F,eAAe,EAAE,6CAA6C,CAAC,CAAC;UACnG,CAAC,MAAM;YACL+B,KAAK,GAAGynF,eAAe,CAACzjF,KAAK,EAAEtjC,OAAO,CAAC;UACzC;UACA;MACJ;IACF,CAAC,CAAC,OAAO6C,CAAC,EAAE;MACV22B,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC9P,KAAK,CAAC/F,eAAe,EAAE16B,CAAC,CAACtD,OAAO,CAAC,CAAC;IAC/D;EACF;EACA,OAAO;IACLyQ,WAAW;IACXqvB,OAAO;IACPC;EACF,CAAC;AACH;AACA,SAASunF,qBAAqBA,CAACpxG,GAAG,EAAEzV,OAAO,EAAE;EAC3C,IAAI6+B,WAAW,GAAG,IAAI;EACtB,KAAK,MAAMxtB,KAAK,IAAIoE,GAAG,CAAC0E,UAAU,EAAE;IAClC,IAAI8rG,yBAAyB,CAACt8F,IAAI,CAACtY,KAAK,CAACjQ,UAAU,CAAC,EAAE;MACpD,IAAIy9B,WAAW,IAAI,IAAI,EAAE;QACvB,MAAM,IAAI/lC,KAAK,CAAC,0DAA0D,CAAC;MAC7E;MACA,MAAMkuH,UAAU,GAAG7B,iBAAiB,CAAC9zG,KAAK,CAACjQ,UAAU,CAAClI,KAAK,CAAC6pH,yBAAyB,CAAC1xG,KAAK,CAACjQ,UAAU,CAAC,CAAC,CAAC;MACzG,IAAI4lH,UAAU,KAAK,IAAI,EAAE;QACvB,MAAM,IAAIluH,KAAK,CAAC,mDAAmD,CAAC;MACtE;MACA+lC,WAAW,GAAGmoF,UAAU;IAC1B,CAAC,MAAM;MACL,MAAM,IAAIluH,KAAK,CAAC,kDAAkDuY,KAAK,CAACjQ,UAAU,GAAG,CAAC;IACxF;EACF;EACA,OAAO,IAAIw9B,wBAAwB,CAAChF,QAAQ,CAAC55B,OAAO,EAAEyV,GAAG,CAAC7U,QAAQ,EAAE6U,GAAG,CAAC7U,QAAQ,CAAC,EAAEi+B,WAAW,EAAEppB,GAAG,CAACwf,QAAQ,EAAExf,GAAG,CAACjN,UAAU,EAAEiN,GAAG,CAAC8nB,eAAe,EAAE9nB,GAAG,CAAC+nB,aAAa,EAAE/nB,GAAG,CAAC4L,IAAI,CAAC;AACjL;AACA,SAASylG,iBAAiBA,CAACrxG,GAAG,EAAEzV,OAAO,EAAE;EACvC,IAAIg/B,SAAS,GAAG,IAAI;EACpB,IAAIH,WAAW,GAAG,IAAI;EACtB,KAAK,MAAMxtB,KAAK,IAAIoE,GAAG,CAAC0E,UAAU,EAAE;IAClC,IAAI+rG,uBAAuB,CAACv8F,IAAI,CAACtY,KAAK,CAACjQ,UAAU,CAAC,EAAE;MAClD,IAAI49B,SAAS,IAAI,IAAI,EAAE;QACrB,MAAM,IAAIlmC,KAAK,CAAC,oDAAoD,CAAC;MACvE;MACA,MAAMkuH,UAAU,GAAG7B,iBAAiB,CAAC9zG,KAAK,CAACjQ,UAAU,CAAClI,KAAK,CAAC6pH,yBAAyB,CAAC1xG,KAAK,CAACjQ,UAAU,CAAC,CAAC,CAAC;MACzG,IAAI4lH,UAAU,KAAK,IAAI,EAAE;QACvB,MAAM,IAAIluH,KAAK,CAAC,iDAAiD,CAAC;MACpE;MACAkmC,SAAS,GAAGgoF,UAAU;IACxB,CAAC,MAAM,IAAIf,yBAAyB,CAACt8F,IAAI,CAACtY,KAAK,CAACjQ,UAAU,CAAC,EAAE;MAC3D,IAAIy9B,WAAW,IAAI,IAAI,EAAE;QACvB,MAAM,IAAI/lC,KAAK,CAAC,sDAAsD,CAAC;MACzE;MACA,MAAMkuH,UAAU,GAAG7B,iBAAiB,CAAC9zG,KAAK,CAACjQ,UAAU,CAAClI,KAAK,CAAC6pH,yBAAyB,CAAC1xG,KAAK,CAACjQ,UAAU,CAAC,CAAC,CAAC;MACzG,IAAI4lH,UAAU,KAAK,IAAI,EAAE;QACvB,MAAM,IAAIluH,KAAK,CAAC,mDAAmD,CAAC;MACtE;MACA+lC,WAAW,GAAGmoF,UAAU;IAC1B,CAAC,MAAM;MACL,MAAM,IAAIluH,KAAK,CAAC,8CAA8CuY,KAAK,CAACjQ,UAAU,GAAG,CAAC;IACpF;EACF;EACA,OAAO,IAAI29B,oBAAoB,CAACnF,QAAQ,CAAC55B,OAAO,EAAEyV,GAAG,CAAC7U,QAAQ,EAAE6U,GAAG,CAAC7U,QAAQ,CAAC,EAAEo+B,SAAS,EAAEH,WAAW,EAAEppB,GAAG,CAACwf,QAAQ,EAAExf,GAAG,CAACjN,UAAU,EAAEiN,GAAG,CAAC8nB,eAAe,EAAE9nB,GAAG,CAAC+nB,aAAa,EAAE/nB,GAAG,CAAC4L,IAAI,CAAC;AACxL;AACA,SAAS0lG,eAAeA,CAACtxG,GAAG,EAAEzV,OAAO,EAAE;EACrC,IAAIyV,GAAG,CAAC0E,UAAU,CAAC7hB,MAAM,GAAG,CAAC,EAAE;IAC7B,MAAM,IAAIQ,KAAK,CAAC,qCAAqC,CAAC;EACxD;EACA,OAAO,IAAIomC,kBAAkB,CAACtF,QAAQ,CAAC55B,OAAO,EAAEyV,GAAG,CAAC7U,QAAQ,EAAE6U,GAAG,CAAC7U,QAAQ,CAAC,EAAE6U,GAAG,CAACwf,QAAQ,EAAExf,GAAG,CAACjN,UAAU,EAAEiN,GAAG,CAAC8nB,eAAe,EAAE9nB,GAAG,CAAC+nB,aAAa,EAAE/nB,GAAG,CAAC4L,IAAI,CAAC;AAC9J;AACA,SAASmlG,oBAAoBA,CAAC/wG,GAAG,EAAEk7F,aAAa,EAAEn3E,MAAM,EAAExpB,WAAW,EAAE;EACrE,MAAMwvB,QAAQ,GAAG,CAAC,CAAC;EACnB,MAAMC,gBAAgB,GAAG,CAAC,CAAC;EAC3B,MAAMC,eAAe,GAAG,CAAC,CAAC;EAC1B,KAAK,MAAMruB,KAAK,IAAIoE,GAAG,CAAC0E,UAAU,EAAE;IAClC,IAAIgsG,sBAAsB,CAACx8F,IAAI,CAACtY,KAAK,CAACjQ,UAAU,CAAC,EAAE;MACjDyhH,gBAAgB,CAACxxG,KAAK,EAAEs/F,aAAa,EAAEnxE,QAAQ,EAAEhG,MAAM,CAAC;IAC1D,CAAC,MAAM,IAAI4sF,oBAAoB,CAACz8F,IAAI,CAACtY,KAAK,CAACjQ,UAAU,CAAC,EAAE;MACtD6hH,cAAc,CAAC5xG,KAAK,EAAEs/F,aAAa,EAAEnxE,QAAQ,EAAEhG,MAAM,CAAC;IACxD,CAAC,MAAM,IAAIosF,qBAAqB,CAACj8F,IAAI,CAACtY,KAAK,CAACjQ,UAAU,CAAC,EAAE;MACvDyhH,gBAAgB,CAACxxG,KAAK,EAAEs/F,aAAa,EAAElxE,gBAAgB,EAAEjG,MAAM,CAAC;IAClE,CAAC,MAAM,IAAIqsF,mBAAmB,CAACl8F,IAAI,CAACtY,KAAK,CAACjQ,UAAU,CAAC,EAAE;MACrD6hH,cAAc,CAAC5xG,KAAK,EAAEs/F,aAAa,EAAElxE,gBAAgB,EAAEjG,MAAM,CAAC;IAChE,CAAC,MAAM,IAAIssF,oBAAoB,CAACn8F,IAAI,CAACtY,KAAK,CAACjQ,UAAU,CAAC,EAAE;MACtDyhH,gBAAgB,CAACxxG,KAAK,EAAEs/F,aAAa,EAAEjxE,eAAe,EAAElG,MAAM,CAAC;IACjE,CAAC,MAAM,IAAIusF,kBAAkB,CAACp8F,IAAI,CAACtY,KAAK,CAACjQ,UAAU,CAAC,EAAE;MACpD6hH,cAAc,CAAC5xG,KAAK,EAAEs/F,aAAa,EAAEjxE,eAAe,EAAElG,MAAM,CAAC;IAC/D,CAAC,MAAM,IAAIwsF,qBAAqB,CAACr8F,IAAI,CAACtY,KAAK,CAACjQ,UAAU,CAAC,EAAE;MACvDmhH,iBAAiB,CAAClxG,KAAK,EAAEquB,eAAe,EAAElG,MAAM,CAAC;IACnD,CAAC,MAAM;MACLA,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC/hC,KAAK,CAAC7I,UAAU,EAAE,sBAAsB,CAAC,CAAC;IACvE;EACF;EACA,IAAIk3B,eAAe,CAACs1E,KAAK,IAAIl2G,MAAM,CAACmC,IAAI,CAACy+B,eAAe,CAAC,CAACpnC,MAAM,GAAG,CAAC,EAAE;IACpEkhC,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC39B,GAAG,CAAC8nB,eAAe,EAAE,4EAA4E,CAAC,CAAC;EAChI;EACA,OAAO;IACLiC,QAAQ;IACRC,gBAAgB;IAChBC;EACF,CAAC;AACH;AAEA,MAAMunF,gBAAgB,GAAG,uDAAuD;AAChF,MAAMC,WAAW,GAAG,CAAC;AACrB,MAAMC,UAAU,GAAG,CAAC;AACpB,MAAMC,UAAU,GAAG,CAAC;AACpB,MAAMC,SAAS,GAAG,CAAC;AACnB,MAAMC,aAAa,GAAG,CAAC;AACvB,MAAMC,SAAS,GAAG,CAAC;AACnB,MAAMC,YAAY,GAAG,CAAC;AACtB,MAAMC,cAAc,GAAG;EACrBC,UAAU,EAAE;IACV/4F,KAAK,EAAE,IAAI;IACXhqB,GAAG,EAAE;EACP,CAAC;EACDgjH,QAAQ,EAAE;IACRh5F,KAAK,EAAE,GAAG;IACVhqB,GAAG,EAAE;EACP,CAAC;EACDijH,KAAK,EAAE;IACLj5F,KAAK,EAAE,GAAG;IACVhqB,GAAG,EAAE;EACP;AACF,CAAC;AACD,MAAMkjH,oBAAoB,GAAG,GAAG;AAChC,MAAMC,6BAA6B,GAAG,IAAIluE,GAAG,CAAC,CAAC,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,aAAa,EAAE,cAAc,EAAE,YAAY,CAAC,CAAC;AACvH,MAAMmuE,wCAAwC,GAAG,IAAInuE,GAAG,CAAC,CAAC,aAAa,EAAE,eAAe,CAAC,CAAC;AAC1F,SAASouE,mBAAmBA,CAACC,SAAS,EAAEtX,aAAa,EAAEjyE,OAAO,EAAE;EAC9D,MAAMwpF,WAAW,GAAG,IAAIC,eAAe,CAACxX,aAAa,EAAEjyE,OAAO,CAAC;EAC/D,MAAM0pF,QAAQ,GAAGxuF,QAAQ,CAACsuF,WAAW,EAAED,SAAS,EAAEA,SAAS,CAAC;EAC5D,MAAMI,SAAS,GAAG1X,aAAa,CAACn3E,MAAM,CAACr/B,MAAM,CAAC+tH,WAAW,CAAC1uF,MAAM,CAAC;EACjE,MAAMhgC,MAAM,GAAG;IACboG,KAAK,EAAEwoH,QAAQ;IACf5uF,MAAM,EAAE6uF,SAAS;IACjBC,SAAS,EAAEJ,WAAW,CAACI,SAAS;IAChClpD,MAAM,EAAE8oD,WAAW,CAAC9oD,MAAM;IAC1BmpD,kBAAkB,EAAEL,WAAW,CAACK;EAClC,CAAC;EACD,IAAI7pF,OAAO,CAAC8pF,mBAAmB,EAAE;IAC/BhvH,MAAM,CAACivH,YAAY,GAAGP,WAAW,CAACO,YAAY;EAChD;EACA,OAAOjvH,MAAM;AACf;AACA,MAAM2uH,eAAe,CAAC;EACpBxX,aAAa;EACbjyE,OAAO;EACPlF,MAAM,GAAG,EAAE;EACX4lC,MAAM,GAAG,EAAE;EACXkpD,SAAS,GAAG,EAAE;EACdC,kBAAkB,GAAG,EAAE;EACvBE,YAAY,GAAG,EAAE;EACjBC,WAAW,GAAG,KAAK;EACnBC,cAAc,GAAG,IAAI/uE,GAAG,CAAC,CAAC;EAC1Bx8C,WAAWA,CAACuzG,aAAa,EAAEjyE,OAAO,EAAE;IAClC,IAAI,CAACiyE,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACjyE,OAAO,GAAGA,OAAO;EACxB;EACAjB,YAAYA,CAAC7lC,OAAO,EAAE;IACpB,MAAMgxH,iBAAiB,GAAGxY,cAAc,CAACx4G,OAAO,CAACypB,IAAI,CAAC;IACtD,IAAIunG,iBAAiB,EAAE;MACrB,IAAI,IAAI,CAACF,WAAW,EAAE;QACpB,IAAI,CAACG,WAAW,CAAC,gHAAgH,EAAEjxH,OAAO,CAAC4Q,UAAU,CAAC;MACxJ;MACA,IAAI,CAACkgH,WAAW,GAAG,IAAI;IACzB;IACA,MAAMI,gBAAgB,GAAGxK,eAAe,CAAC1mH,OAAO,CAAC;IACjD,IAAIkxH,gBAAgB,CAACznH,IAAI,KAAKu9G,oBAAoB,CAAC/U,MAAM,EAAE;MACzD,OAAO,IAAI;IACb,CAAC,MAAM,IAAIif,gBAAgB,CAACznH,IAAI,KAAKu9G,oBAAoB,CAAC1iD,KAAK,EAAE;MAC/D,MAAM6sD,QAAQ,GAAGC,YAAY,CAACpxH,OAAO,CAAC;MACtC,IAAImxH,QAAQ,KAAK,IAAI,EAAE;QACrB,IAAI,CAAC3pD,MAAM,CAAC7mE,IAAI,CAACwwH,QAAQ,CAAC;MAC5B;MACA,OAAO,IAAI;IACb,CAAC,MAAM,IAAID,gBAAgB,CAACznH,IAAI,KAAKu9G,oBAAoB,CAACG,UAAU,IAAIrB,oBAAoB,CAACoL,gBAAgB,CAACtK,QAAQ,CAAC,EAAE;MACvH,IAAI,CAAC8J,SAAS,CAAC/vH,IAAI,CAACuwH,gBAAgB,CAACtK,QAAQ,CAAC;MAC9C,OAAO,IAAI;IACb;IACA,MAAMyK,iBAAiB,GAAG1tF,YAAY,CAAC3jC,OAAO,CAACwC,IAAI,CAAC;IACpD,MAAM;MACJ6iC,UAAU;MACVisF,WAAW;MACX7rF,UAAU;MACV8E,SAAS;MACTgnF,iBAAiB;MACjBC,wBAAwB;MACxBC,gBAAgB;MAChBC,wBAAwB;MACxBC;IACF,CAAC,GAAG,IAAI,CAACC,iBAAiB,CAAC5xH,OAAO,CAACE,KAAK,EAAEmxH,iBAAiB,CAAC;IAC5D,MAAM7rF,UAAU,GAAG,IAAI,CAACqsF,iBAAiB,CAAC7xH,OAAO,CAAC;IAClD,IAAIgJ,QAAQ;IACZ,IAAIkoH,gBAAgB,CAAC11D,WAAW,EAAE;MAChCxyD,QAAQ,GAAGg5B,QAAQ,CAAC8vF,oBAAoB,EAAE9xH,OAAO,CAACgJ,QAAQ,CAAC,CAAC+oH,IAAI,CAACC,QAAQ,CAAC;IAC5E,CAAC,MAAM;MACLhpH,QAAQ,GAAGg5B,QAAQ,CAAC,IAAI,EAAEhiC,OAAO,CAACgJ,QAAQ,EAAEhJ,OAAO,CAACgJ,QAAQ,CAAC;IAC/D;IACA,IAAIipH,aAAa;IACjB,IAAIf,gBAAgB,CAACznH,IAAI,KAAKu9G,oBAAoB,CAACE,UAAU,EAAE;MAC7D,MAAM7mH,QAAQ,GAAG6wH,gBAAgB,CAACvK,UAAU;MAC5C,MAAMzmH,KAAK,GAAGF,OAAO,CAACE,KAAK,CAAC2E,GAAG,CAAClD,IAAI,IAAI,IAAI,CAAC8vE,cAAc,CAAC9vE,IAAI,CAAC,CAAC;MAClEswH,aAAa,GAAG,IAAIxnF,OAAO,CAACpqC,QAAQ,EAAEH,KAAK,EAAE8I,QAAQ,EAAEhJ,OAAO,CAAC0lC,aAAa,EAAE1lC,OAAO,CAAC4Q,UAAU,EAAE5Q,OAAO,CAAC2lC,eAAe,EAAE3lC,OAAO,CAAC4lC,aAAa,EAAE5lC,OAAO,CAACypB,IAAI,CAAC;MAC/J,IAAI,CAACknG,kBAAkB,CAAChwH,IAAI,CAACN,QAAQ,CAAC;IACxC,CAAC,MAAM,IAAIgxH,iBAAiB,EAAE;MAC5B,MAAMnxH,KAAK,GAAG,IAAI,CAACgyH,4BAA4B,CAAClyH,OAAO,CAACwC,IAAI,EAAEivH,gBAAgB,EAAEE,aAAa,CAAC;MAC9FM,aAAa,GAAG,IAAI5nF,QAAQ,CAACrqC,OAAO,CAACwC,IAAI,EAAE6iC,UAAU,EAAEnlC,KAAK,CAACiyH,KAAK,EAAEb,WAAW,EAAE9rF,UAAU,EAAE,EAAE,EAAEx8B,QAAQ,EAAEy8B,UAAU,EAAE8E,SAAS,EAAEvqC,OAAO,CAAC0lC,aAAa,EAAE1lC,OAAO,CAAC4Q,UAAU,EAAE5Q,OAAO,CAAC2lC,eAAe,EAAE3lC,OAAO,CAAC4lC,aAAa,EAAE5lC,OAAO,CAACypB,IAAI,CAAC;IAC5O,CAAC,MAAM;MACL,MAAMvpB,KAAK,GAAG,IAAI,CAACgyH,4BAA4B,CAAClyH,OAAO,CAACwC,IAAI,EAAEivH,gBAAgB,EAAEE,aAAa,CAAC;MAC9F,IAAI3xH,OAAO,CAACwC,IAAI,KAAK,cAAc,EAAE;QACnC,KAAK,MAAM2vH,KAAK,IAAIjyH,KAAK,CAACiyH,KAAK,EAAE;UAC/B,IAAIA,KAAK,CAAC1oH,IAAI,KAAKw5B,WAAW,CAACquB,SAAS,EAAE;YACxC,IAAI,CAAC2/D,WAAW,CAAC,sFAAsF,EAAEkB,KAAK,CAACvhH,UAAU,CAAC;UAC5H;QACF;MACF;MACAqhH,aAAa,GAAG,IAAI9sF,SAAS,CAACnlC,OAAO,CAACwC,IAAI,EAAE6iC,UAAU,EAAEnlC,KAAK,CAACiyH,KAAK,EAAEb,WAAW,EAAE9rF,UAAU,EAAEx8B,QAAQ,EAAEy8B,UAAU,EAAEzlC,OAAO,CAAC0lC,aAAa,EAAE1lC,OAAO,CAAC4Q,UAAU,EAAE5Q,OAAO,CAAC2lC,eAAe,EAAE3lC,OAAO,CAAC4lC,aAAa,EAAE5lC,OAAO,CAAC4J,MAAM,EAAE5J,OAAO,CAACypB,IAAI,CAAC;IAC9O;IACA,IAAI+nG,wBAAwB,EAAE;MAC5BS,aAAa,GAAG,IAAI,CAACG,cAAc,CAACH,aAAa,EAAEP,wBAAwB,EAAEH,iBAAiB,EAAEI,aAAa,EAAEN,iBAAiB,EAAEL,iBAAiB,CAAC;IACtJ;IACA,IAAIA,iBAAiB,EAAE;MACrB,IAAI,CAACF,WAAW,GAAG,KAAK;IAC1B;IACA,OAAOmB,aAAa;EACtB;EACAxgD,cAAcA,CAAChwE,SAAS,EAAE;IACxB,OAAO,IAAI8iC,aAAa,CAAC9iC,SAAS,CAACe,IAAI,EAAEf,SAAS,CAACgB,KAAK,EAAEhB,SAAS,CAACmP,UAAU,EAAEnP,SAAS,CAAC0gC,OAAO,EAAE1gC,SAAS,CAAC2gC,SAAS,EAAE3gC,SAAS,CAACgoB,IAAI,CAAC;EACzI;EACA9gB,SAASA,CAACC,IAAI,EAAE;IACd,OAAO,IAAI,CAACmoH,cAAc,CAAClrH,GAAG,CAAC+C,IAAI,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC00F,2BAA2B,CAAC10F,IAAI,CAACnG,KAAK,EAAEmG,IAAI,CAACgI,UAAU,EAAEhI,IAAI,CAACmoE,MAAM,EAAEnoE,IAAI,CAAC6gB,IAAI,CAAC;EACrI;EACA0nD,cAAcA,CAACmU,SAAS,EAAE;IACxB,IAAI,CAACA,SAAS,CAAC77D,IAAI,EAAE;MACnB,OAAO,IAAI;IACb;IACA,IAAI,CAAC+uF,cAAc,CAAClzB,SAAS,CAAC77D,IAAI,CAAC,EAAE;MACnC,MAAM,IAAIvoB,KAAK,CAAC,iBAAiBokF,SAAS,CAAC77D,IAAI,CAACjkB,WAAW,4BAA4B8/E,SAAS,CAAC10E,UAAU,CAACjO,QAAQ,CAAC,CAAC,wBAAwB,CAAC;IACjJ;IACA,MAAMgF,OAAO,GAAG29E,SAAS,CAAC77D,IAAI;IAC9B,MAAMwhB,IAAI,GAAG,CAAC,CAAC;IACf,MAAMC,YAAY,GAAG,CAAC,CAAC;IACvBhkC,MAAM,CAACmC,IAAI,CAAC1B,OAAO,CAACujC,YAAY,CAAC,CAACtoC,OAAO,CAACmO,GAAG,IAAI;MAC/C,MAAMtO,KAAK,GAAGkF,OAAO,CAACujC,YAAY,CAACn6B,GAAG,CAAC;MACvC,IAAIA,GAAG,CAAC+gB,UAAU,CAACkgB,mBAAmB,CAAC,EAAE;QACvC,MAAMqgF,YAAY,GAAGthH,GAAG,CAACqf,IAAI,CAAC,CAAC;QAC/B,MAAMvS,GAAG,GAAG,IAAI,CAACk7F,aAAa,CAACpqB,4BAA4B,CAAClsF,KAAK,CAACmG,IAAI,EAAEnG,KAAK,CAACmO,UAAU,CAAC;QACzFq6B,IAAI,CAAConF,YAAY,CAAC,GAAG,IAAIhuF,SAAS,CAACxmB,GAAG,EAAEpb,KAAK,CAACmO,UAAU,CAAC;MAC3D,CAAC,MAAM;QACLs6B,YAAY,CAACn6B,GAAG,CAAC,GAAG,IAAI,CAACusF,2BAA2B,CAAC76F,KAAK,CAACmG,IAAI,EAAEnG,KAAK,CAACmO,UAAU,EAAE,IAAI,CAAC;MAC1F;IACF,CAAC,CAAC;IACF,OAAO,IAAIm6B,KAAK,CAACE,IAAI,EAAEC,YAAY,EAAEo6C,SAAS,CAAC10E,UAAU,EAAEjJ,OAAO,CAAC;EACrE;EACA4pE,kBAAkBA,CAACiU,aAAa,EAAE;IAChC,OAAO,IAAI;EACb;EACA9T,YAAYA,CAAC95C,OAAO,EAAE;IACpB,IAAI,IAAI,CAACkP,OAAO,CAAC8pF,mBAAmB,EAAE;MACpC,IAAI,CAACC,YAAY,CAAClwH,IAAI,CAAC,IAAIqjC,SAAS,CAACpM,OAAO,CAACn1B,KAAK,IAAI,EAAE,EAAEm1B,OAAO,CAAChnB,UAAU,CAAC,CAAC;IAChF;IACA,OAAO,IAAI;EACb;EACAm5B,mBAAmBA,CAACgC,IAAI,EAAEljC,OAAO,EAAE;IACjC,MAAMpG,KAAK,GAAG,IAAI,CAACs2G,aAAa,CAACxrB,YAAY,CAACxhD,IAAI,CAACtpC,KAAK,EAAE,KAAK,EAAEspC,IAAI,CAAC3J,SAAS,EAAE2J,IAAI,CAAC3J,SAAS,CAACrL,KAAK,CAACmjB,MAAM,CAAC;IAC7G,IAAIz3C,KAAK,CAACm/B,MAAM,CAAClhC,MAAM,KAAK,CAAC,IAAI+B,KAAK,CAACob,GAAG,YAAYyf,WAAW,EAAE;MACjE,IAAI,CAAC2zF,WAAW,CAAC,wCAAwC,EAAEllF,IAAI,CAAC3J,SAAS,CAAC;IAC5E;IACA,OAAO,IAAIyH,gBAAgB,CAACkC,IAAI,CAACvpC,IAAI,EAAEC,KAAK,EAAEspC,IAAI,CAACn7B,UAAU,EAAEm7B,IAAI,CAAC1O,QAAQ,EAAE0O,IAAI,CAAC3J,SAAS,CAAC;EAC/F;EACA8H,cAAcA,CAAC0B,SAAS,EAAE;IACxB,MAAMolF,iBAAiB,GAAGxY,cAAc,CAAC5sE,SAAS,CAACniB,IAAI,CAAC;IACxD,IAAIunG,iBAAiB,EAAE;MACrB,IAAI,IAAI,CAACF,WAAW,EAAE;QACpB,IAAI,CAACG,WAAW,CAAC,iHAAiH,EAAErlF,SAAS,CAACh7B,UAAU,CAAC;MAC3J;MACA,IAAI,CAACkgH,WAAW,GAAG,IAAI;IACzB;IACA,IAAIllF,SAAS,CAACjsB,OAAO,KAAK,IAAI,IAAIuwG,6BAA6B,CAACrqH,GAAG,CAAC+lC,SAAS,CAACjsB,OAAO,CAAC,EAAE;MACtF,IAAI,CAACsxG,WAAW,CAAC,aAAarlF,SAAS,CAACjsB,OAAO,qCAAqC,EAAEisB,SAAS,CAACjG,eAAe,CAAC;MAChH,OAAO,IAAI;IACb;IACA,MAAM;MACJN,UAAU;MACVisF,WAAW;MACX7rF,UAAU;MACV8rF,iBAAiB;MACjBC,wBAAwB;MACxBC,gBAAgB;MAChBC,wBAAwB;MACxBC;IACF,CAAC,GAAG,IAAI,CAACC,iBAAiB,CAAChmF,SAAS,CAAC1rC,KAAK,EAAE,KAAK,CAAC;IAClD,IAAI,CAACoyH,8BAA8B,CAAC7sF,UAAU,CAAC;IAC/C,MAAMD,UAAU,GAAG,IAAI,CAACqsF,iBAAiB,CAACjmF,SAAS,CAAC;IACpD,IAAI5iC,QAAQ;IACZ,IAAI4iC,SAAS,CAAC1rC,KAAK,CAACi0C,IAAI,CAACxyC,IAAI,IAAIA,IAAI,CAACa,IAAI,KAAK,eAAe,CAAC,EAAE;MAC/DwG,QAAQ,GAAGg5B,QAAQ,CAAC8vF,oBAAoB,EAAElmF,SAAS,CAAC5iC,QAAQ,CAAC,CAAC+oH,IAAI,CAACC,QAAQ,CAAC;IAC9E,CAAC,MAAM;MACLhpH,QAAQ,GAAGg5B,QAAQ,CAAC,IAAI,EAAE4J,SAAS,CAAC5iC,QAAQ,EAAE4iC,SAAS,CAAC5iC,QAAQ,CAAC;IACnE;IACA,MAAM9I,KAAK,GAAG,IAAI,CAACgyH,4BAA4B,CAACtmF,SAAS,CAACjsB,OAAO,EAAE8xG,gBAAgB,EAAEE,aAAa,CAAC;IACnG,IAAIx8G,IAAI,GAAG,IAAI60B,WAAW,CAAC4B,SAAS,CAAC3B,aAAa,EAAE2B,SAAS,CAACjsB,OAAO,EAAEisB,SAAS,CAAC/H,QAAQ,EAAEwB,UAAU,EAAEnlC,KAAK,CAACiyH,KAAK,EAAEb,WAAW,EAAE9rF,UAAU,EAAEx8B,QAAQ,EAAEy8B,UAAU,EAAEmG,SAAS,CAAClG,aAAa,EAAEkG,SAAS,CAACh7B,UAAU,EAAEg7B,SAAS,CAACjG,eAAe,EAAEiG,SAAS,CAAChG,aAAa,EAAEgG,SAAS,CAACniB,IAAI,CAAC;IACrR,IAAI+nG,wBAAwB,EAAE;MAC5Br8G,IAAI,GAAG,IAAI,CAACi9G,cAAc,CAACj9G,IAAI,EAAEu8G,wBAAwB,EAAEH,iBAAiB,EAAEI,aAAa,EAAE,KAAK,EAAEX,iBAAiB,CAAC;IACxH;IACA,IAAIA,iBAAiB,EAAE;MACrB,IAAI,CAACF,WAAW,GAAG,KAAK;IAC1B;IACA,OAAO37G,IAAI;EACb;EACAi1B,cAAcA,CAAA,EAAG;IACf,OAAO,IAAI;EACb;EACA0nC,mBAAmBA,CAAA,EAAG;IACpB,OAAO,IAAI;EACb;EACAF,UAAUA,CAAClmC,KAAK,EAAE7iC,OAAO,EAAE;IACzB,MAAMoD,KAAK,GAAGgO,KAAK,CAACC,OAAO,CAACrR,OAAO,CAAC,GAAGA,OAAO,CAACsnB,OAAO,CAACub,KAAK,CAAC,GAAG,CAAC,CAAC;IAClE,IAAIz/B,KAAK,KAAK,CAAC,CAAC,EAAE;MAChB,MAAM,IAAI/K,KAAK,CAAC,+FAA+F,CAAC;IAClH;IACA,IAAI,IAAI,CAAC6vH,cAAc,CAAClrH,GAAG,CAAC6lC,KAAK,CAAC,EAAE;MAClC,OAAO,IAAI;IACb;IACA,IAAI9pC,MAAM,GAAG,IAAI;IACjB,QAAQ8pC,KAAK,CAAClpC,IAAI;MAChB,KAAK,OAAO;QACVZ,MAAM,GAAG8sH,mBAAmB,CAAChjF,KAAK,EAAE,IAAI,CAAC6mF,mBAAmB,CAACtmH,KAAK,EAAEpD,OAAO,EAAE4lH,yBAAyB,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC1V,aAAa,CAAC;QAClI;MACF,KAAK,QAAQ;QACXn3G,MAAM,GAAGgnH,iBAAiB,CAACl9E,KAAK,EAAE,IAAI,EAAE,IAAI,CAACqtE,aAAa,CAAC;QAC3D;MACF,KAAK,KAAK;QACRn3G,MAAM,GAAG2mH,aAAa,CAAC78E,KAAK,EAAE,IAAI,CAAC6mF,mBAAmB,CAACtmH,KAAK,EAAEpD,OAAO,EAAEg/G,uBAAuB,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC9O,aAAa,CAAC;QAC1H;MACF,KAAK,IAAI;QACPn3G,MAAM,GAAGmmH,aAAa,CAACr8E,KAAK,EAAE,IAAI,CAAC6mF,mBAAmB,CAACtmH,KAAK,EAAEpD,OAAO,EAAEi/G,sBAAsB,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC/O,aAAa,CAAC;QACzH;MACF;QACE,IAAIljB,YAAY;QAChB,IAAI44B,yBAAyB,CAAC/iF,KAAK,CAAClpC,IAAI,CAAC,EAAE;UACzCqzF,YAAY,GAAG,IAAInqD,KAAK,CAAClpC,IAAI,gDAAgD;UAC7E,IAAI,CAACuuH,cAAc,CAAChtE,GAAG,CAACrY,KAAK,CAAC;QAChC,CAAC,MAAM,IAAIm8E,uBAAuB,CAACn8E,KAAK,CAAClpC,IAAI,CAAC,EAAE;UAC9CqzF,YAAY,GAAG,IAAInqD,KAAK,CAAClpC,IAAI,8CAA8C;UAC3E,IAAI,CAACuuH,cAAc,CAAChtE,GAAG,CAACrY,KAAK,CAAC;QAChC,CAAC,MAAM,IAAIo8E,sBAAsB,CAACp8E,KAAK,CAAClpC,IAAI,CAAC,EAAE;UAC7CqzF,YAAY,GAAG,IAAInqD,KAAK,CAAClpC,IAAI,yDAAyD;UACtF,IAAI,CAACuuH,cAAc,CAAChtE,GAAG,CAACrY,KAAK,CAAC;QAChC,CAAC,MAAM;UACLmqD,YAAY,GAAG,uBAAuBnqD,KAAK,CAAClpC,IAAI,GAAG;QACrD;QACAZ,MAAM,GAAG;UACPuT,IAAI,EAAE,IAAIw0B,YAAY,CAAC+B,KAAK,CAAClpC,IAAI,EAAEkpC,KAAK,CAAC96B,UAAU,EAAE86B,KAAK,CAACrO,QAAQ,CAAC;UACpEuE,MAAM,EAAE,CAAC,IAAI4Z,UAAU,CAAC9P,KAAK,CAAC96B,UAAU,EAAEilF,YAAY,CAAC;QACzD,CAAC;QACD;IACJ;IACA,IAAI,CAACj0D,MAAM,CAACjhC,IAAI,CAAC,GAAGiB,MAAM,CAACggC,MAAM,CAAC;IAClC,OAAOhgC,MAAM,CAACuT,IAAI;EACpB;EACAo9G,mBAAmBA,CAACC,iBAAiB,EAAEC,QAAQ,EAAE95C,SAAS,EAAE;IAC1D,MAAM+5C,aAAa,GAAG,EAAE;IACxB,KAAK,IAAI5wH,CAAC,GAAG0wH,iBAAiB,GAAG,CAAC,EAAE1wH,CAAC,GAAG2wH,QAAQ,CAAC/xH,MAAM,EAAEoB,CAAC,EAAE,EAAE;MAC5D,MAAMqT,IAAI,GAAGs9G,QAAQ,CAAC3wH,CAAC,CAAC;MACxB,IAAIqT,IAAI,YAAY8uB,OAAO,EAAE;QAC3B;MACF;MACA,IAAI9uB,IAAI,YAAYivB,IAAI,IAAIjvB,IAAI,CAAC1S,KAAK,CAAC2tB,IAAI,CAAC,CAAC,CAAC1vB,MAAM,KAAK,CAAC,EAAE;QAC1D,IAAI,CAACqwH,cAAc,CAAChtE,GAAG,CAAC5uC,IAAI,CAAC;QAC7B;MACF;MACA,IAAI,EAAEA,IAAI,YAAYw8D,KAAK,CAAC,IAAI,CAACgH,SAAS,CAACxjE,IAAI,CAAC3S,IAAI,CAAC,EAAE;QACrD;MACF;MACAkwH,aAAa,CAAC/xH,IAAI,CAACwU,IAAI,CAAC;MACxB,IAAI,CAAC47G,cAAc,CAAChtE,GAAG,CAAC5uC,IAAI,CAAC;IAC/B;IACA,OAAOu9G,aAAa;EACtB;EACAR,4BAA4BA,CAACvrH,WAAW,EAAE2xF,UAAU,EAAEq6B,aAAa,EAAE;IACnE,MAAMR,KAAK,GAAG,EAAE;IAChB,MAAM/yG,OAAO,GAAG,EAAE;IAClBk5E,UAAU,CAAC11F,OAAO,CAACiO,IAAI,IAAI;MACzB,MAAM4Y,IAAI,GAAGkpG,aAAa,CAAC9hH,IAAI,CAACrO,IAAI,CAAC;MACrC,IAAIqO,IAAI,CAACwxB,SAAS,EAAE;QAClBjjB,OAAO,CAACze,IAAI,CAAC,IAAI4jC,aAAa,CAAC1zB,IAAI,CAACrO,IAAI,EAAEqO,IAAI,CAACrH,UAAU,CAACstB,MAAM,IAAI,EAAE,EAAEjmB,IAAI,CAACD,UAAU,EAAEC,IAAI,CAACsxB,OAAO,EAAEtxB,IAAI,CAACuxB,SAAS,EAAE3Y,IAAI,CAAC,CAAC;MAC/H,CAAC,MAAM;QACL,MAAMmpG,GAAG,GAAG,IAAI,CAAC7Z,aAAa,CAAC6K,0BAA0B,CAACj9G,WAAW,EAAEkK,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC;QACzFshH,KAAK,CAACxxH,IAAI,CAAC8jC,cAAc,CAACC,wBAAwB,CAACkuF,GAAG,EAAEnpG,IAAI,CAAC,CAAC;MAChE;IACF,CAAC,CAAC;IACF,OAAO;MACL0oG,KAAK;MACL/yG;IACF,CAAC;EACH;EACAwyG,iBAAiBA,CAAC1xH,KAAK,EAAEmxH,iBAAiB,EAAE;IAC1C,MAAMI,gBAAgB,GAAG,EAAE;IAC3B,MAAMH,WAAW,GAAG,EAAE;IACtB,MAAM/mF,SAAS,GAAG,EAAE;IACpB,MAAM9E,UAAU,GAAG,EAAE;IACrB,MAAMJ,UAAU,GAAG,EAAE;IACrB,MAAMssF,aAAa,GAAG,CAAC,CAAC;IACxB,MAAMD,wBAAwB,GAAG,EAAE;IACnC,MAAMH,iBAAiB,GAAG,EAAE;IAC5B,IAAIC,wBAAwB,GAAG,KAAK;IACpC,KAAK,MAAM/vH,SAAS,IAAIvB,KAAK,EAAE;MAC7B,IAAI2yH,UAAU,GAAG,KAAK;MACtB,MAAMC,cAAc,GAAGC,sBAAsB,CAACtxH,SAAS,CAACe,IAAI,CAAC;MAC7D,IAAIwwH,iBAAiB,GAAG,KAAK;MAC7B,IAAIvxH,SAAS,CAACgoB,IAAI,EAAE;QAClBkoG,aAAa,CAAClwH,SAAS,CAACe,IAAI,CAAC,GAAGf,SAAS,CAACgoB,IAAI;MAChD;MACA,IAAIqpG,cAAc,CAAChhG,UAAU,CAACm+F,oBAAoB,CAAC,EAAE;QACnD,IAAIuB,wBAAwB,EAAE;UAC5B,IAAI,CAACP,WAAW,CAAC,8FAA8F,EAAExvH,SAAS,CAACmP,UAAU,CAAC;QACxI;QACAoiH,iBAAiB,GAAG,IAAI;QACxBxB,wBAAwB,GAAG,IAAI;QAC/B,MAAMtjD,aAAa,GAAGzsE,SAAS,CAACgB,KAAK;QACrC,MAAMurF,WAAW,GAAG8kC,cAAc,CAACv4E,SAAS,CAAC01E,oBAAoB,CAACvvH,MAAM,CAAC;QACzE,MAAMuyH,eAAe,GAAG,EAAE;QAC1B,MAAM/kC,mBAAmB,GAAGzsF,SAAS,CAAC2gC,SAAS,GAAG3gC,SAAS,CAAC2gC,SAAS,CAACiZ,SAAS,CAACnB,MAAM,GAAGz4C,SAAS,CAACmP,UAAU,CAACyqC,SAAS,CAACnB,MAAM,GAAGz4C,SAAS,CAACe,IAAI,CAAC9B,MAAM;QACtJ,IAAI,CAACq4G,aAAa,CAACmJ,0BAA0B,CAACl0B,WAAW,EAAE9f,aAAa,EAAEzsE,SAAS,CAACmP,UAAU,EAAEs9E,mBAAmB,EAAE,EAAE,EAAEwjC,wBAAwB,EAAEuB,eAAe,EAAE,IAAI,CAAC;QACzK1B,iBAAiB,CAAC5wH,IAAI,CAAC,GAAGsyH,eAAe,CAACpuH,GAAG,CAAC4oE,CAAC,IAAI,IAAI9iC,QAAQ,CAAC8iC,CAAC,CAACjrE,IAAI,EAAEirE,CAAC,CAAChrE,KAAK,EAAEgrE,CAAC,CAAC78D,UAAU,EAAE68D,CAAC,CAACtrC,OAAO,EAAEsrC,CAAC,CAACrrC,SAAS,CAAC,CAAC,CAAC;MAC1H,CAAC,MAAM;QACLywF,UAAU,GAAG,IAAI,CAACK,cAAc,CAAC7B,iBAAiB,EAAE5vH,SAAS,EAAE,EAAE,EAAEgwH,gBAAgB,EAAEH,WAAW,EAAE/mF,SAAS,EAAE9E,UAAU,CAAC;MAC1H;MACA,IAAI,CAACotF,UAAU,IAAI,CAACG,iBAAiB,EAAE;QACrC3tF,UAAU,CAAC1kC,IAAI,CAAC,IAAI,CAAC8wE,cAAc,CAAChwE,SAAS,CAAC,CAAC;MACjD;IACF;IACA,OAAO;MACL4jC,UAAU;MACVisF,WAAW;MACX7rF,UAAU;MACV8E,SAAS;MACTgnF,iBAAiB;MACjBC,wBAAwB;MACxBC,gBAAgB;MAChBC,wBAAwB;MACxBC;IACF,CAAC;EACH;EACAuB,cAAcA,CAAC7B,iBAAiB,EAAE5vH,SAAS,EAAE0xH,mBAAmB,EAAE1B,gBAAgB,EAAEH,WAAW,EAAE/mF,SAAS,EAAE9E,UAAU,EAAE;IACtH,MAAMjjC,IAAI,GAAGuwH,sBAAsB,CAACtxH,SAAS,CAACe,IAAI,CAAC;IACnD,MAAMC,KAAK,GAAGhB,SAAS,CAACgB,KAAK;IAC7B,MAAMmgH,OAAO,GAAGnhH,SAAS,CAACmP,UAAU;IACpC,MAAMqsB,cAAc,GAAGx7B,SAAS,CAAC2gC,SAAS,GAAG3gC,SAAS,CAAC2gC,SAAS,CAACiZ,SAAS,CAACnB,MAAM,GAAG0oE,OAAO,CAACvnE,SAAS,CAACnB,MAAM;IAC5G,SAASk5E,aAAaA,CAACxQ,OAAO,EAAExhH,MAAM,EAAEo7C,UAAU,EAAE;MAClD,MAAM62E,uBAAuB,GAAG5xH,SAAS,CAACe,IAAI,CAAC9B,MAAM,GAAG8B,IAAI,CAAC9B,MAAM;MACnE,MAAM4yH,YAAY,GAAG1Q,OAAO,CAAC7rF,KAAK,CAACojB,MAAM,CAAC/4C,MAAM,CAACV,MAAM,GAAG2yH,uBAAuB,CAAC;MAClF,MAAME,UAAU,GAAGD,YAAY,CAACn5E,MAAM,CAACqC,UAAU,CAAC97C,MAAM,CAAC;MACzD,OAAO,IAAI06C,eAAe,CAACk4E,YAAY,EAAEC,UAAU,EAAED,YAAY,EAAE92E,UAAU,CAAC;IAChF;IACA,MAAMg3E,SAAS,GAAGhxH,IAAI,CAAC3B,KAAK,CAACwuH,gBAAgB,CAAC;IAC9C,IAAImE,SAAS,EAAE;MACb,IAAIA,SAAS,CAAClE,WAAW,CAAC,IAAI,IAAI,EAAE;QAClC,MAAM9yE,UAAU,GAAGg3E,SAAS,CAAC5D,YAAY,CAAC;QAC1C,MAAMztF,OAAO,GAAGixF,aAAa,CAACxQ,OAAO,EAAE4Q,SAAS,CAAClE,WAAW,CAAC,EAAE9yE,UAAU,CAAC;QAC1E,IAAI,CAACu8D,aAAa,CAAC8I,oBAAoB,CAACrlE,UAAU,EAAE/5C,KAAK,EAAE,KAAK,EAAE,KAAK,EAAEmgH,OAAO,EAAE3lF,cAAc,EAAEx7B,SAAS,CAAC2gC,SAAS,EAAE+wF,mBAAmB,EAAE1B,gBAAgB,EAAEtvF,OAAO,CAAC;MACxK,CAAC,MAAM,IAAIqxF,SAAS,CAACjE,UAAU,CAAC,EAAE;QAChC,IAAI8B,iBAAiB,EAAE;UACrB,MAAM70E,UAAU,GAAGg3E,SAAS,CAAC5D,YAAY,CAAC;UAC1C,MAAMztF,OAAO,GAAGixF,aAAa,CAACxQ,OAAO,EAAE4Q,SAAS,CAACjE,UAAU,CAAC,EAAE/yE,UAAU,CAAC;UACzE,IAAI,CAACi3E,aAAa,CAACj3E,UAAU,EAAE/5C,KAAK,EAAEmgH,OAAO,EAAEzgF,OAAO,EAAE1gC,SAAS,CAAC2gC,SAAS,EAAEmI,SAAS,CAAC;QACzF,CAAC,MAAM;UACL,IAAI,CAAC0mF,WAAW,CAAC,mDAAmD,EAAErO,OAAO,CAAC;QAChF;MACF,CAAC,MAAM,IAAI4Q,SAAS,CAAChE,UAAU,CAAC,EAAE;QAChC,MAAMhzE,UAAU,GAAGg3E,SAAS,CAAC5D,YAAY,CAAC;QAC1C,MAAMztF,OAAO,GAAGixF,aAAa,CAACxQ,OAAO,EAAE4Q,SAAS,CAAChE,UAAU,CAAC,EAAEhzE,UAAU,CAAC;QACzE,IAAI,CAACk3E,cAAc,CAACl3E,UAAU,EAAE/5C,KAAK,EAAEmgH,OAAO,EAAEzgF,OAAO,EAAE1gC,SAAS,CAAC2gC,SAAS,EAAEqD,UAAU,CAAC;MAC3F,CAAC,MAAM,IAAI+tF,SAAS,CAAC/D,SAAS,CAAC,EAAE;QAC/B,MAAMt3B,MAAM,GAAG,EAAE;QACjB,MAAM37C,UAAU,GAAGg3E,SAAS,CAAC5D,YAAY,CAAC;QAC1C,MAAMztF,OAAO,GAAGixF,aAAa,CAACxQ,OAAO,EAAE4Q,SAAS,CAAC/D,SAAS,CAAC,EAAEjzE,UAAU,CAAC;QACxE,IAAI,CAACu8D,aAAa,CAACkJ,UAAU,CAACzlE,UAAU,EAAE/5C,KAAK,EAAE,KAAK,EAAEmgH,OAAO,EAAEnhH,SAAS,CAAC2gC,SAAS,IAAIwgF,OAAO,EAAEuQ,mBAAmB,EAAEh7B,MAAM,EAAEh2D,OAAO,CAAC;QACtIwxF,SAAS,CAACx7B,MAAM,EAAEm5B,WAAW,CAAC;MAChC,CAAC,MAAM,IAAIkC,SAAS,CAAC9D,aAAa,CAAC,EAAE;QACnC,MAAMlzE,UAAU,GAAGg3E,SAAS,CAAC5D,YAAY,CAAC;QAC1C,MAAMztF,OAAO,GAAGixF,aAAa,CAACxQ,OAAO,EAAE4Q,SAAS,CAAC9D,aAAa,CAAC,EAAElzE,UAAU,CAAC;QAC5E,IAAI,CAACu8D,aAAa,CAAC8I,oBAAoB,CAACrlE,UAAU,EAAE/5C,KAAK,EAAE,KAAK,EAAE,IAAI,EAAEmgH,OAAO,EAAE3lF,cAAc,EAAEx7B,SAAS,CAAC2gC,SAAS,EAAE+wF,mBAAmB,EAAE1B,gBAAgB,EAAEtvF,OAAO,CAAC;QACrK,IAAI,CAACyxF,oBAAoB,CAACp3E,UAAU,EAAE/5C,KAAK,EAAEmgH,OAAO,EAAEnhH,SAAS,CAAC2gC,SAAS,EAAE+wF,mBAAmB,EAAE7B,WAAW,EAAEnvF,OAAO,EAAElF,cAAc,CAAC;MACvI,CAAC,MAAM,IAAIu2F,SAAS,CAAC7D,SAAS,CAAC,EAAE;QAC/B,MAAMxtF,OAAO,GAAGixF,aAAa,CAACxQ,OAAO,EAAE,EAAE,EAAEpgH,IAAI,CAAC;QAChD,IAAI,CAACu2G,aAAa,CAAC+J,gBAAgB,CAACtgH,IAAI,EAAEC,KAAK,EAAEmgH,OAAO,EAAE3lF,cAAc,EAAEx7B,SAAS,CAAC2gC,SAAS,EAAE+wF,mBAAmB,EAAE1B,gBAAgB,EAAEtvF,OAAO,CAAC;MAChJ;MACA,OAAO,IAAI;IACb;IACA,IAAI0xF,MAAM,GAAG,IAAI;IACjB,IAAIrxH,IAAI,CAACsvB,UAAU,CAAC+9F,cAAc,CAACC,UAAU,CAAC/4F,KAAK,CAAC,EAAE;MACpD88F,MAAM,GAAGhE,cAAc,CAACC,UAAU;IACpC,CAAC,MAAM,IAAIttH,IAAI,CAACsvB,UAAU,CAAC+9F,cAAc,CAACE,QAAQ,CAACh5F,KAAK,CAAC,EAAE;MACzD88F,MAAM,GAAGhE,cAAc,CAACE,QAAQ;IAClC,CAAC,MAAM,IAAIvtH,IAAI,CAACsvB,UAAU,CAAC+9F,cAAc,CAACG,KAAK,CAACj5F,KAAK,CAAC,EAAE;MACtD88F,MAAM,GAAGhE,cAAc,CAACG,KAAK;IAC/B;IACA,IAAI6D,MAAM,KAAK,IAAI,IAAIrxH,IAAI,CAAC0tE,QAAQ,CAAC2jD,MAAM,CAAC9mH,GAAG,CAAC,IAAIvK,IAAI,CAAC9B,MAAM,GAAGmzH,MAAM,CAAC98F,KAAK,CAACr2B,MAAM,GAAGmzH,MAAM,CAAC9mH,GAAG,CAACrM,MAAM,EAAE;MACzG,MAAM87C,UAAU,GAAGh6C,IAAI,CAAC+3C,SAAS,CAACs5E,MAAM,CAAC98F,KAAK,CAACr2B,MAAM,EAAE8B,IAAI,CAAC9B,MAAM,GAAGmzH,MAAM,CAAC9mH,GAAG,CAACrM,MAAM,CAAC;MACvF,MAAMyhC,OAAO,GAAGixF,aAAa,CAACxQ,OAAO,EAAEiR,MAAM,CAAC98F,KAAK,EAAEylB,UAAU,CAAC;MAChE,IAAIq3E,MAAM,CAAC98F,KAAK,KAAK84F,cAAc,CAACC,UAAU,CAAC/4F,KAAK,EAAE;QACpD,IAAI,CAACgiF,aAAa,CAAC8I,oBAAoB,CAACrlE,UAAU,EAAE/5C,KAAK,EAAE,KAAK,EAAE,IAAI,EAAEmgH,OAAO,EAAE3lF,cAAc,EAAEx7B,SAAS,CAAC2gC,SAAS,EAAE+wF,mBAAmB,EAAE1B,gBAAgB,EAAEtvF,OAAO,CAAC;QACrK,IAAI,CAACyxF,oBAAoB,CAACp3E,UAAU,EAAE/5C,KAAK,EAAEmgH,OAAO,EAAEnhH,SAAS,CAAC2gC,SAAS,EAAE+wF,mBAAmB,EAAE7B,WAAW,EAAEnvF,OAAO,EAAElF,cAAc,CAAC;MACvI,CAAC,MAAM,IAAI42F,MAAM,CAAC98F,KAAK,KAAK84F,cAAc,CAACE,QAAQ,CAACh5F,KAAK,EAAE;QACzD,IAAI,CAACgiF,aAAa,CAAC8I,oBAAoB,CAACrlE,UAAU,EAAE/5C,KAAK,EAAE,KAAK,EAAE,KAAK,EAAEmgH,OAAO,EAAE3lF,cAAc,EAAEx7B,SAAS,CAAC2gC,SAAS,EAAE+wF,mBAAmB,EAAE1B,gBAAgB,EAAEtvF,OAAO,CAAC;MACxK,CAAC,MAAM;QACL,MAAMg2D,MAAM,GAAG,EAAE;QACjB,IAAI,CAAC4gB,aAAa,CAACkJ,UAAU,CAACzlE,UAAU,EAAE/5C,KAAK,EAAE,KAAK,EAAEmgH,OAAO,EAAEnhH,SAAS,CAAC2gC,SAAS,IAAIwgF,OAAO,EAAEuQ,mBAAmB,EAAEh7B,MAAM,EAAEh2D,OAAO,CAAC;QACtIwxF,SAAS,CAACx7B,MAAM,EAAEm5B,WAAW,CAAC;MAChC;MACA,OAAO,IAAI;IACb;IACA,MAAMnvF,OAAO,GAAGixF,aAAa,CAACxQ,OAAO,EAAE,EAAE,EAAEpgH,IAAI,CAAC;IAChD,MAAMqwH,UAAU,GAAG,IAAI,CAAC9Z,aAAa,CAACyK,0BAA0B,CAAChhH,IAAI,EAAEC,KAAK,EAAEmgH,OAAO,EAAEnhH,SAAS,CAAC2gC,SAAS,EAAE+wF,mBAAmB,EAAE1B,gBAAgB,EAAEtvF,OAAO,EAAE1gC,SAAS,CAAC+vE,WAAW,IAAI,IAAI,CAAC;IAC1L,OAAOqhD,UAAU;EACnB;EACAhB,iBAAiBA,CAAC18G,IAAI,EAAE;IACtB,MAAMxO,WAAW,GAAGwO,IAAI,YAAYwnB,SAAS,GAAGxnB,IAAI,CAACwK,OAAO,GAAGxK,IAAI,CAAC3S,IAAI;IACxE,MAAMgjC,UAAU,GAAG,EAAE;IACrB,MAAMsuF,cAAc,GAAG,IAAI9xE,GAAG,CAAC,CAAC;IAChC,KAAK,MAAMnW,SAAS,IAAI12B,IAAI,CAACqwB,UAAU,EAAE;MACvC,IAAIuuF,OAAO,GAAG,KAAK;MACnB,KAAK,MAAMpyH,IAAI,IAAIkqC,SAAS,CAAC3rC,KAAK,EAAE;QAClC,IAAIyB,IAAI,CAACa,IAAI,CAACsvB,UAAU,CAACm+F,oBAAoB,CAAC,EAAE;UAC9C8D,OAAO,GAAG,IAAI;UACd,IAAI,CAAC9C,WAAW,CAAC,8BAA8BtvH,IAAI,CAACa,IAAI,+CAA+C,EAAEb,IAAI,CAACiP,UAAU,CAAC;QAC3H,CAAC,MAAM,IAAIu/G,wCAAwC,CAACtqH,GAAG,CAAClE,IAAI,CAACa,IAAI,CAAC,EAAE;UAClEuxH,OAAO,GAAG,IAAI;UACd,IAAI,CAAC9C,WAAW,CAAC,cAActvH,IAAI,CAACa,IAAI,2CAA2C,EAAEb,IAAI,CAACiP,UAAU,CAAC;QACvG;MACF;MACA,IAAI,CAACmjH,OAAO,IAAID,cAAc,CAACjuH,GAAG,CAACgmC,SAAS,CAACrpC,IAAI,CAAC,EAAE;QAClDuxH,OAAO,GAAG,IAAI;QACd,IAAI,CAAC9C,WAAW,CAAC,2BAA2BplF,SAAS,CAACrpC,IAAI,sCAAsC,EAAEqpC,SAAS,CAACj7B,UAAU,CAAC;MACzH;MACA,IAAImjH,OAAO,EAAE;QACX;MACF;MACA,MAAM;QACJ1uF,UAAU;QACVosF,gBAAgB;QAChBH,WAAW;QACX7rF,UAAU;QACVksF;MACF,CAAC,GAAG,IAAI,CAACC,iBAAiB,CAAC/lF,SAAS,CAAC3rC,KAAK,EAAE,KAAK,CAAC;MAClD,IAAI,CAACoyH,8BAA8B,CAAC7sF,UAAU,CAAC;MAC/C,MAAM;QACJ0sF,KAAK,EAAE7sF;MACT,CAAC,GAAG,IAAI,CAAC4sF,4BAA4B,CAACvrH,WAAW,EAAE8qH,gBAAgB,EAAEE,aAAa,CAAC;MACnF,KAAK,MAAMjiG,KAAK,IAAI4V,MAAM,EAAE;QAC1B,IAAI5V,KAAK,CAACjmB,IAAI,KAAKw5B,WAAW,CAAC0R,QAAQ,IAAIjlB,KAAK,CAACjmB,IAAI,KAAKw5B,WAAW,CAAC2R,MAAM,EAAE;UAC5Em/E,OAAO,GAAG,IAAI;UACd,IAAI,CAAC9C,WAAW,CAAC,iDAAiD,EAAEvhG,KAAK,CAAC9e,UAAU,CAAC;QACvF;MACF;MACA,IAAImjH,OAAO,EAAE;QACX;MACF;MACAD,cAAc,CAAC/vE,GAAG,CAAClY,SAAS,CAACrpC,IAAI,CAAC;MAClCgjC,UAAU,CAAC7kC,IAAI,CAAC,IAAIwpC,WAAW,CAAC0B,SAAS,CAACrpC,IAAI,EAAE6iC,UAAU,EAAEC,MAAM,EAAEgsF,WAAW,EAAE7rF,UAAU,EAAEoG,SAAS,CAACj7B,UAAU,EAAEi7B,SAAS,CAAClG,eAAe,EAAEkG,SAAS,CAACjG,aAAa,EAAErV,SAAS,CAAC,CAAC;IACpL;IACA,OAAOiV,UAAU;EACnB;EACAwuF,yBAAyBA,CAAC3uF,UAAU,EAAE;IACpC,OAAOA,UAAU,CAAChjB,MAAM,CAAC9Z,CAAC,IAAI,CAACA,CAAC,CAAC/F,IAAI,CAACsvB,UAAU,CAAC,UAAU,CAAC,CAAC;EAC/D;EACAmiG,qBAAqBA,CAAC5uF,UAAU,EAAE;IAChC,OAAOA,UAAU,CAAChjB,MAAM,CAAC9Z,CAAC,IAAIA,CAAC,CAACkB,IAAI,KAAKw5B,WAAW,CAAC+zB,SAAS,CAAC;EACjE;EACAo7D,cAAcA,CAACj9G,IAAI,EAAE++G,kBAAkB,EAAE3C,iBAAiB,EAAEI,aAAa,EAAEN,iBAAiB,EAAEL,iBAAiB,EAAE;IAC/G,MAAM9wH,KAAK,GAAG,IAAI,CAACgyH,4BAA4B,CAAC,aAAa,EAAEgC,kBAAkB,EAAEvC,aAAa,CAAC;IACjG,MAAMrnF,aAAa,GAAG,EAAE;IACxBpqC,KAAK,CAACkf,OAAO,CAACxc,OAAO,CAACjB,IAAI,IAAI2oC,aAAa,CAAC3pC,IAAI,CAACgB,IAAI,CAAC,CAAC;IACvDzB,KAAK,CAACiyH,KAAK,CAACvvH,OAAO,CAACjB,IAAI,IAAI2oC,aAAa,CAAC3pC,IAAI,CAACgB,IAAI,CAAC,CAAC;IACrD,MAAMwyH,YAAY,GAAG;MACnB9uF,UAAU,EAAE,EAAE;MACdC,MAAM,EAAE,EAAE;MACVC,OAAO,EAAE;IACX,CAAC;IACD,IAAIpwB,IAAI,YAAYgwB,SAAS,IAAIhwB,IAAI,YAAY60B,WAAW,EAAE;MAC5DmqF,YAAY,CAAC9uF,UAAU,CAAC1kC,IAAI,CAAC,GAAG,IAAI,CAACqzH,yBAAyB,CAAC7+G,IAAI,CAACkwB,UAAU,CAAC,CAAC;MAChF8uF,YAAY,CAAC7uF,MAAM,CAAC3kC,IAAI,CAAC,GAAG,IAAI,CAACszH,qBAAqB,CAAC9+G,IAAI,CAACmwB,MAAM,CAAC,CAAC;MACpE6uF,YAAY,CAAC5uF,OAAO,CAAC5kC,IAAI,CAAC,GAAGwU,IAAI,CAACowB,OAAO,CAAC;IAC5C;IACA,MAAM9b,IAAI,GAAG4nG,iBAAiB,IAAIL,iBAAiB,GAAGzgG,SAAS,GAAGpb,IAAI,CAACsU,IAAI;IAC3E,IAAIjnB,IAAI;IACR,IAAI2S,IAAI,YAAY60B,WAAW,EAAE;MAC/BxnC,IAAI,GAAG2S,IAAI,CAACwK,OAAO;IACrB,CAAC,MAAM,IAAIxK,IAAI,YAAYk1B,QAAQ,EAAE;MACnC7nC,IAAI,GAAG,IAAI;IACb,CAAC,MAAM;MACLA,IAAI,GAAG2S,IAAI,CAAC3S,IAAI;IAClB;IACA,OAAO,IAAI6nC,QAAQ,CAAC7nC,IAAI,EAAE2xH,YAAY,CAAC9uF,UAAU,EAAE8uF,YAAY,CAAC7uF,MAAM,EAAE6uF,YAAY,CAAC5uF,OAAO,EAAE,EAAE,EAAE+E,aAAa,EAAE,CAACn1B,IAAI,CAAC,EAAE,EAAE,EAAEo8G,iBAAiB,EAAE,KAAK,EAAEp8G,IAAI,CAACvE,UAAU,EAAEuE,IAAI,CAACwwB,eAAe,EAAExwB,IAAI,CAACywB,aAAa,EAAEnc,IAAI,CAAC;EACzN;EACA6zE,2BAA2BA,CAAC76F,KAAK,EAAEmO,UAAU,EAAEw9E,kBAAkB,EAAE3kE,IAAI,EAAE;IACvE,MAAM2qG,WAAW,GAAGhwC,WAAW,CAAC3hF,KAAK,CAAC;IACtC,MAAMqS,IAAI,GAAG,IAAI,CAACikG,aAAa,CAAC5qB,kBAAkB,CAACimC,WAAW,EAAExjH,UAAU,EAAEw9E,kBAAkB,CAAC;IAC/F,OAAOt5E,IAAI,GAAG,IAAIuvB,SAAS,CAACvvB,IAAI,EAAElE,UAAU,EAAE6Y,IAAI,CAAC,GAAG,IAAI0a,MAAM,CAACiwF,WAAW,EAAExjH,UAAU,CAAC;EAC3F;EACA6iH,aAAaA,CAACj3E,UAAU,EAAE/5C,KAAK,EAAEmO,UAAU,EAAEuxB,OAAO,EAAEC,SAAS,EAAEmI,SAAS,EAAE;IAC1E,IAAIiS,UAAU,CAACrsB,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE;MAChC,IAAI,CAAC8gG,WAAW,CAAC,sCAAsC,EAAErgH,UAAU,CAAC;IACtE,CAAC,MAAM,IAAI4rC,UAAU,CAAC97C,MAAM,KAAK,CAAC,EAAE;MAClC,IAAI,CAACuwH,WAAW,CAAC,+BAA+B,EAAErgH,UAAU,CAAC;IAC/D;IACA25B,SAAS,CAAC5pC,IAAI,CAAC,IAAIgqC,QAAQ,CAAC6R,UAAU,EAAE/5C,KAAK,EAAEmO,UAAU,EAAEuxB,OAAO,EAAEC,SAAS,CAAC,CAAC;EACjF;EACAsxF,cAAcA,CAACl3E,UAAU,EAAE/5C,KAAK,EAAEmO,UAAU,EAAEuxB,OAAO,EAAEC,SAAS,EAAEqD,UAAU,EAAE;IAC5E,IAAI+W,UAAU,CAACrsB,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE;MAChC,IAAI,CAAC8gG,WAAW,CAAC,uCAAuC,EAAErgH,UAAU,CAAC;IACvE,CAAC,MAAM,IAAI4rC,UAAU,CAAC97C,MAAM,KAAK,CAAC,EAAE;MAClC,IAAI,CAACuwH,WAAW,CAAC,gCAAgC,EAAErgH,UAAU,CAAC;IAChE,CAAC,MAAM,IAAI60B,UAAU,CAAC0M,IAAI,CAAChoB,SAAS,IAAIA,SAAS,CAAC3nB,IAAI,KAAKg6C,UAAU,CAAC,EAAE;MACtE,IAAI,CAACy0E,WAAW,CAAC,eAAez0E,UAAU,6BAA6B,EAAE5rC,UAAU,CAAC;IACtF;IACA60B,UAAU,CAAC9kC,IAAI,CAAC,IAAIkqC,SAAS,CAAC2R,UAAU,EAAE/5C,KAAK,EAAEmO,UAAU,EAAEuxB,OAAO,EAAEC,SAAS,CAAC,CAAC;EACnF;EACAwxF,oBAAoBA,CAACpxH,IAAI,EAAEgH,UAAU,EAAEoH,UAAU,EAAEwxB,SAAS,EAAEigF,oBAAoB,EAAEiP,WAAW,EAAEnvF,OAAO,EAAElF,cAAc,EAAE;IACxH,MAAMk7D,MAAM,GAAG,EAAE;IACjB,IAAI,CAAC4gB,aAAa,CAACkJ,UAAU,CAAC,GAAGz/G,IAAI,QAAQ,EAAEgH,UAAU,EAAE,IAAI,EAAEoH,UAAU,EAAEwxB,SAAS,IAAIxxB,UAAU,EAAEyxG,oBAAoB,EAAElqB,MAAM,EAAEh2D,OAAO,CAAC;IAC5IwxF,SAAS,CAACx7B,MAAM,EAAEm5B,WAAW,CAAC;EAChC;EACAgB,8BAA8BA,CAAC7sF,UAAU,EAAE;IACzC,IAAIA,UAAU,CAAC/kC,MAAM,KAAK,CAAC,EAAE;MAC3B;IACF;IACA,MAAM2zH,SAAS,GAAG,IAAIryE,GAAG,CAAC,CAAC;IAC3B,KAAK,MAAMtoB,GAAG,IAAI+L,UAAU,EAAE;MAC5B,IAAI/L,GAAG,CAACj3B,KAAK,CAAC/B,MAAM,GAAG,CAAC,EAAE;QACxB,IAAI,CAACuwH,WAAW,CAAC,8DAA8D,EAAEv3F,GAAG,CAAC0I,SAAS,IAAI1I,GAAG,CAAC9oB,UAAU,CAAC;MACnH,CAAC,MAAM,IAAIyjH,SAAS,CAACxuH,GAAG,CAAC6zB,GAAG,CAACl3B,IAAI,CAAC,EAAE;QAClC,IAAI,CAACyuH,WAAW,CAAC,2CAA2C,EAAEv3F,GAAG,CAAC9oB,UAAU,CAAC;MAC/E,CAAC,MAAM;QACLyjH,SAAS,CAACtwE,GAAG,CAACrqB,GAAG,CAACl3B,IAAI,CAAC;MACzB;IACF;EACF;EACAyuH,WAAWA,CAACtpH,OAAO,EAAEiJ,UAAU,EAAE6qC,KAAK,GAAGF,eAAe,CAACI,KAAK,EAAE;IAC9D,IAAI,CAAC/Z,MAAM,CAACjhC,IAAI,CAAC,IAAI66C,UAAU,CAAC5qC,UAAU,EAAEjJ,OAAO,EAAE8zC,KAAK,CAAC,CAAC;EAC9D;AACF;AACA,MAAM64E,kBAAkB,CAAC;EACvBzuF,YAAYA,CAAChoB,GAAG,EAAE;IAChB,MAAMqzG,gBAAgB,GAAGxK,eAAe,CAAC7oG,GAAG,CAAC;IAC7C,IAAIqzG,gBAAgB,CAACznH,IAAI,KAAKu9G,oBAAoB,CAAC/U,MAAM,IAAIif,gBAAgB,CAACznH,IAAI,KAAKu9G,oBAAoB,CAAC1iD,KAAK,IAAI4sD,gBAAgB,CAACznH,IAAI,KAAKu9G,oBAAoB,CAACG,UAAU,EAAE;MAC9K,OAAO,IAAI;IACb;IACA,MAAMn+G,QAAQ,GAAGg5B,QAAQ,CAAC,IAAI,EAAEnkB,GAAG,CAAC7U,QAAQ,EAAE,IAAI,CAAC;IACnD,OAAO,IAAIm8B,SAAS,CAACtnB,GAAG,CAACrb,IAAI,EAAEw/B,QAAQ,CAAC,IAAI,EAAEnkB,GAAG,CAAC3d,KAAK,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE8I,QAAQ,EAAE,EAAE,EAAE6U,GAAG,CAAC6nB,aAAa,EAAE7nB,GAAG,CAACjN,UAAU,EAAEiN,GAAG,CAAC8nB,eAAe,EAAE9nB,GAAG,CAAC+nB,aAAa,EAAE/nB,GAAG,CAACjU,MAAM,CAAC;EAC5K;EACA8nE,YAAYA,CAAC95C,OAAO,EAAE;IACpB,OAAO,IAAI;EACb;EACA65C,cAAcA,CAAChwE,SAAS,EAAE;IACxB,OAAO,IAAI8iC,aAAa,CAAC9iC,SAAS,CAACe,IAAI,EAAEf,SAAS,CAACgB,KAAK,EAAEhB,SAAS,CAACmP,UAAU,EAAEnP,SAAS,CAAC0gC,OAAO,EAAE1gC,SAAS,CAAC2gC,SAAS,EAAE3gC,SAAS,CAACgoB,IAAI,CAAC;EACzI;EACA9gB,SAASA,CAACC,IAAI,EAAE;IACd,OAAO,IAAIu7B,MAAM,CAACv7B,IAAI,CAACnG,KAAK,EAAEmG,IAAI,CAACgI,UAAU,CAAC;EAChD;EACAugE,cAAcA,CAACmU,SAAS,EAAE;IACxB,OAAO,IAAI;EACb;EACA/T,kBAAkBA,CAACiU,aAAa,EAAE;IAChC,OAAO,IAAI;EACb;EACA5T,UAAUA,CAAClmC,KAAK,EAAE7iC,OAAO,EAAE;IACzB,MAAMb,KAAK,GAAG,CAAC,IAAIm8B,MAAM,CAACuH,KAAK,CAAC/F,eAAe,CAAChjC,QAAQ,CAAC,CAAC,EAAE+oC,KAAK,CAAC/F,eAAe,CAAC,EAAE,GAAG3D,QAAQ,CAAC,IAAI,EAAE0J,KAAK,CAAC1iC,QAAQ,CAAC,CAAC;IACtH,IAAI0iC,KAAK,CAAC9F,aAAa,KAAK,IAAI,EAAE;MAChC59B,KAAK,CAACrH,IAAI,CAAC,IAAIwjC,MAAM,CAACuH,KAAK,CAAC9F,aAAa,CAACjjC,QAAQ,CAAC,CAAC,EAAE+oC,KAAK,CAAC9F,aAAa,CAAC,CAAC;IAC7E;IACA,OAAO59B,KAAK;EACd;EACA8pE,mBAAmBA,CAAC6T,SAAS,EAAE98E,OAAO,EAAE;IACtC,OAAO,IAAI;EACb;EACAkhC,mBAAmBA,CAACgC,IAAI,EAAEljC,OAAO,EAAE;IACjC,OAAO,IAAIs7B,MAAM,CAAC,QAAQ4H,IAAI,CAACvpC,IAAI,MAAMupC,IAAI,CAACtpC,KAAK,GAAG,EAAEspC,IAAI,CAACn7B,UAAU,CAAC;EAC1E;EACAs5B,cAAcA,CAACrsB,GAAG,EAAEhV,OAAO,EAAE;IAC3B,MAAMG,QAAQ,GAAGg5B,QAAQ,CAAC,IAAI,EAAEnkB,GAAG,CAAC7U,QAAQ,EAAE,IAAI,CAAC;IACnD,OAAO,IAAIm8B,SAAS,CAACtnB,GAAG,CAACgmB,QAAQ,EAAE7B,QAAQ,CAAC,IAAI,EAAEnkB,GAAG,CAAC3d,KAAK,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE8I,QAAQ,EAAE,EAAE,EAAE6U,GAAG,CAAC6nB,aAAa,EAAE7nB,GAAG,CAACjN,UAAU,EAAEiN,GAAG,CAAC8nB,eAAe,EAAE9nB,GAAG,CAAC+nB,aAAa,EAAE,KAAK,CAAC;EAC3K;EACAwE,cAAcA,CAACyB,SAAS,EAAEhjC,OAAO,EAAE;IACjC,OAAO,IAAI;EACb;AACF;AACA,MAAMipH,oBAAoB,GAAG,IAAIwC,kBAAkB,CAAC,CAAC;AACrD,SAASvB,sBAAsBA,CAACjqE,QAAQ,EAAE;EACxC,OAAO,SAAS,CAAC/2B,IAAI,CAAC+2B,QAAQ,CAAC,GAAGA,QAAQ,CAACvO,SAAS,CAAC,CAAC,CAAC,GAAGuO,QAAQ;AACpE;AACA,SAAS6qE,SAASA,CAACx7B,MAAM,EAAEm5B,WAAW,EAAE;EACtCA,WAAW,CAAC3wH,IAAI,CAAC,GAAGw3F,MAAM,CAACtzF,GAAG,CAACoG,CAAC,IAAI25B,UAAU,CAACE,eAAe,CAAC75B,CAAC,CAAC,CAAC,CAAC;AACrE;AACA,SAASmmH,YAAYA,CAACj8G,IAAI,EAAE;EAC1B,IAAIA,IAAI,CAACnM,QAAQ,CAACtI,MAAM,KAAK,CAAC,IAAI,EAAEyU,IAAI,CAACnM,QAAQ,CAAC,CAAC,CAAC,YAAYo7B,IAAI,CAAC,EAAE;IACrE,OAAO,IAAI;EACb,CAAC,MAAM;IACL,OAAOjvB,IAAI,CAACnM,QAAQ,CAAC,CAAC,CAAC,CAACvG,KAAK;EAC/B;AACF;AAEA,MAAM8xH,oBAAoB,GAAG,CAAC,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;AACpD,SAASC,aAAaA,CAAC7+G,QAAQ,EAAE8+G,WAAW,EAAE3tF,OAAO,GAAG,CAAC,CAAC,EAAE;EAC1D,MAAM;IACJ4tF,mBAAmB;IACnB50B;EACF,CAAC,GAAGh5D,OAAO;EACX,MAAMiuC,mBAAmB,GAAGjuC,OAAO,CAAC6tF,kBAAkB,IAAI,KAAK;EAC/D,MAAM5b,aAAa,GAAG6b,iBAAiB,CAAC7/C,mBAAmB,CAAC;EAC5D,MAAM8/C,UAAU,GAAG,IAAI7T,UAAU,CAAC,CAAC;EACnC,MAAM8T,WAAW,GAAGD,UAAU,CAACz0H,KAAK,CAACuV,QAAQ,EAAE8+G,WAAW,EAAE;IAC1DpgD,kBAAkB,EAAEkgD,oBAAoB;IACxC,GAAGztF,OAAO;IACVstC,sBAAsB,EAAE,IAAI;IAC5BS,cAAc,EAAE/tC,OAAO,CAACiuF,iBAAiB,IAAI,IAAI;IACjDjgD,WAAW,EAAEhuC,OAAO,CAACkuF,eAAe,IAAI,IAAI;IAC5CjgD;EACF,CAAC,CAAC;EACF,IAAI,CAACjuC,OAAO,CAACmuF,kCAAkC,IAAIH,WAAW,CAAClzF,MAAM,IAAIkzF,WAAW,CAAClzF,MAAM,CAAClhC,MAAM,GAAG,CAAC,EAAE;IACtG,MAAMw0H,cAAc,GAAG;MACrBR,mBAAmB;MACnB9yF,MAAM,EAAEkzF,WAAW,CAAClzF,MAAM;MAC1B55B,KAAK,EAAE,EAAE;MACT0oH,SAAS,EAAE,EAAE;MACblpD,MAAM,EAAE,EAAE;MACVmpD,kBAAkB,EAAE;IACtB,CAAC;IACD,IAAI7pF,OAAO,CAAC8pF,mBAAmB,EAAE;MAC/BsE,cAAc,CAACrE,YAAY,GAAG,EAAE;IAClC;IACA,OAAOqE,cAAc;EACvB;EACA,IAAIv2C,SAAS,GAAGm2C,WAAW,CAACn2C,SAAS;EACrC,MAAM0d,iBAAiB,GAAG,EAAEv1D,OAAO,CAACw9C,6BAA6B,IAAI,IAAI,CAAC;EAC1E,MAAM6wC,eAAe,GAAG,IAAIv1B,eAAe,CAAC,CAAC80B,mBAAmB,EAAE50B,+BAA+B,EAAEvvE,SAAS,EAAEuW,OAAO,CAACw9C,6BAA6B,EAAE+X,iBAAiB,CAAC;EACvK,MAAM+4B,cAAc,GAAGD,eAAe,CAAC90B,kBAAkB,CAAC1hB,SAAS,CAAC;EACpE,IAAI,CAAC73C,OAAO,CAACmuF,kCAAkC,IAAIG,cAAc,CAACxzF,MAAM,IAAIwzF,cAAc,CAACxzF,MAAM,CAAClhC,MAAM,GAAG,CAAC,EAAE;IAC5G,MAAMw0H,cAAc,GAAG;MACrBR,mBAAmB;MACnB9yF,MAAM,EAAEwzF,cAAc,CAACxzF,MAAM;MAC7B55B,KAAK,EAAE,EAAE;MACT0oH,SAAS,EAAE,EAAE;MACblpD,MAAM,EAAE,EAAE;MACVmpD,kBAAkB,EAAE;IACtB,CAAC;IACD,IAAI7pF,OAAO,CAAC8pF,mBAAmB,EAAE;MAC/BsE,cAAc,CAACrE,YAAY,GAAG,EAAE;IAClC;IACA,OAAOqE,cAAc;EACvB;EACAv2C,SAAS,GAAGy2C,cAAc,CAACz2C,SAAS;EACpC,IAAI,CAAC+1C,mBAAmB,EAAE;IACxB/1C,SAAS,GAAG38C,QAAQ,CAAC,IAAIqiD,iBAAiB,CAAC,IAAI,EAAE9zD,SAAS,EAAE,KAAK,CAAC,EAAEouD,SAAS,CAAC;IAC9E,IAAIw2C,eAAe,CAACp1B,WAAW,EAAE;MAC/BphB,SAAS,GAAG38C,QAAQ,CAAC,IAAI49D,eAAe,CAAC,KAAK,EAAErvE,SAAS,EAAEA,SAAS,EAAE,IAAI,EAAE8rE,iBAAiB,CAAC,EAAE1d,SAAS,CAAC;IAC5G;EACF;EACA,MAAM;IACJ32E,KAAK;IACL45B,MAAM;IACN8uF,SAAS;IACTlpD,MAAM;IACNmpD,kBAAkB;IAClBE;EACF,CAAC,GAAGT,mBAAmB,CAACzxC,SAAS,EAAEo6B,aAAa,EAAE;IAChD6X,mBAAmB,EAAE,CAAC,CAAC9pF,OAAO,CAAC8pF;EACjC,CAAC,CAAC;EACFhvF,MAAM,CAACjhC,IAAI,CAAC,GAAGm0H,WAAW,CAAClzF,MAAM,EAAE,GAAGwzF,cAAc,CAACxzF,MAAM,CAAC;EAC5D,MAAMszF,cAAc,GAAG;IACrBR,mBAAmB;IACnB9yF,MAAM,EAAEA,MAAM,CAAClhC,MAAM,GAAG,CAAC,GAAGkhC,MAAM,GAAG,IAAI;IACzC55B,KAAK;IACL0oH,SAAS;IACTlpD,MAAM;IACNmpD;EACF,CAAC;EACD,IAAI7pF,OAAO,CAAC8pF,mBAAmB,EAAE;IAC/BsE,cAAc,CAACrE,YAAY,GAAGA,YAAY;EAC5C;EACA,OAAOqE,cAAc;AACvB;AACA,MAAMG,eAAe,GAAG,IAAIt9B,wBAAwB,CAAC,CAAC;AACtD,SAAS68B,iBAAiBA,CAAC7/C,mBAAmB,GAAG,KAAK,EAAE;EACtD,OAAO,IAAIysC,aAAa,CAAC,IAAI3iC,MAAM,CAAC,IAAI0H,KAAK,CAAC,CAAC,EAAExR,mBAAmB,CAAC,EAAEsgD,eAAe,EAAE,EAAE,CAAC;AAC7F;AAEA,MAAMC,kBAAkB,GAAG,QAAQ;AACnC,MAAMC,SAAS,GAAG,WAAWD,kBAAkB,EAAE;AACjD,MAAME,YAAY,GAAG,cAAcF,kBAAkB,EAAE;AACvD,SAASG,mBAAmBA,CAACz7F,IAAI,EAAE2+E,YAAY,EAAEI,aAAa,EAAE;EAC9D,MAAM55D,aAAa,GAAG,IAAIlL,aAAa,CAAC,CAAC;EACzC,MAAM1uC,SAAS,GAAGyB,yBAAyB,CAACgzB,IAAI,CAAC35B,QAAQ,CAAC;EAC1D8+C,aAAa,CAACz6C,GAAG,CAAC,MAAM,EAAEs1B,IAAI,CAACvwB,IAAI,CAAChH,KAAK,CAAC;EAC1C,IAAI8C,SAAS,CAAC7E,MAAM,GAAG,CAAC,EAAE;IACxBy+C,aAAa,CAACz6C,GAAG,CAAC,WAAW,EAAEwuC,SAAS,CAAC3tC,SAAS,CAAC,CAAC;EACtD;EACA,IAAIy0B,IAAI,CAAC8mF,OAAO,CAACpgH,MAAM,GAAG,CAAC,EAAE;IAC3By+C,aAAa,CAACz6C,GAAG,CAAC,gBAAgB,EAAEm8G,4BAA4B,CAAC7mF,IAAI,CAAC8mF,OAAO,EAAEnI,YAAY,EAAE3+E,IAAI,CAACx3B,IAAI,CAAC,CAAC;EAC1G;EACA,IAAIw3B,IAAI,CAACqmF,WAAW,CAAC3/G,MAAM,EAAE;IAC3By+C,aAAa,CAACz6C,GAAG,CAAC,WAAW,EAAE07G,yBAAyB,CAACpmF,IAAI,CAACqmF,WAAW,EAAE1H,YAAY,EAAE3+E,IAAI,CAACx3B,IAAI,CAAC,CAAC;EACtG;EACA28C,aAAa,CAACz6C,GAAG,CAAC,cAAc,EAAEgxH,0BAA0B,CAAC17F,IAAI,CAACiC,IAAI,EAAEjC,IAAI,CAAC27F,cAAc,EAAE5c,aAAa,EAAEJ,YAAY,EAAE3+E,IAAI,CAAC35B,QAAQ,IAAI,EAAE,EAAE25B,IAAI,CAACx3B,IAAI,EAAE28C,aAAa,CAAC,CAAC;EACzKA,aAAa,CAACz6C,GAAG,CAAC,QAAQ,EAAEyuC,0CAA0C,CAACnZ,IAAI,CAACsL,MAAM,EAAE,IAAI,CAAC,CAAC;EAC1F6Z,aAAa,CAACz6C,GAAG,CAAC,SAAS,EAAEyuC,0CAA0C,CAACnZ,IAAI,CAACuL,OAAO,CAAC,CAAC;EACtF,IAAIvL,IAAI,CAAC47F,QAAQ,KAAK,IAAI,EAAE;IAC1Bz2E,aAAa,CAACz6C,GAAG,CAAC,UAAU,EAAEga,UAAU,CAACsb,IAAI,CAAC47F,QAAQ,CAAC/wH,GAAG,CAACoG,CAAC,IAAImU,OAAO,CAACnU,CAAC,CAAC,CAAC,CAAC,CAAC;EAC/E;EACA,IAAI+uB,IAAI,CAAC6nB,YAAY,KAAK,KAAK,EAAE;IAC/B1C,aAAa,CAACz6C,GAAG,CAAC,YAAY,EAAE0a,OAAO,CAAC,KAAK,CAAC,CAAC;EACjD;EACA,IAAI4a,IAAI,CAAC8Z,QAAQ,EAAE;IACjBqL,aAAa,CAACz6C,GAAG,CAAC,SAAS,EAAE0a,OAAO,CAAC,IAAI,CAAC,CAAC;EAC7C;EACA,OAAO+/B,aAAa;AACtB;AACA,SAAS02E,WAAWA,CAAC12E,aAAa,EAAEnlB,IAAI,EAAE;EACxC,MAAM87F,QAAQ,GAAG,EAAE;EACnB,MAAM12E,SAAS,GAAGplB,IAAI,CAAColB,SAAS;EAChC,MAAM22E,aAAa,GAAG/7F,IAAI,CAAC+7F,aAAa;EACxC,IAAI32E,SAAS,IAAI22E,aAAa,EAAE;IAC9B,MAAMzgH,IAAI,GAAG,CAAC8pC,SAAS,IAAI,IAAI1jC,gBAAgB,CAAC,EAAE,CAAC,CAAC;IACpD,IAAIq6G,aAAa,EAAE;MACjBzgH,IAAI,CAAC3U,IAAI,CAACo1H,aAAa,CAAC;IAC1B;IACAD,QAAQ,CAACn1H,IAAI,CAACyd,UAAU,CAACwE,WAAW,CAACoL,gBAAgB,CAAC,CAAC/c,MAAM,CAACqE,IAAI,CAAC,CAAC;EACtE;EACA,IAAI0kB,IAAI,CAACg8F,cAAc,EAAEt1H,MAAM,EAAE;IAC/Bo1H,QAAQ,CAACn1H,IAAI,CAACyd,UAAU,CAACwE,WAAW,CAACqL,qBAAqB,CAAC,CAAChd,MAAM,CAAC,CAACglH,8BAA8B,CAACj8F,IAAI,CAACg8F,cAAc,CAAC,CAAC,CAAC,CAAC;EAC5H;EACA,IAAIh8F,IAAI,CAACk8F,eAAe,EAAE;IACxBJ,QAAQ,CAACn1H,IAAI,CAACyd,UAAU,CAACwE,WAAW,CAACmL,wBAAwB,CAAC,CAAC;EACjE;EACA,IAAIiM,IAAI,CAACm8F,SAAS,CAACC,aAAa,EAAE;IAChCN,QAAQ,CAACn1H,IAAI,CAACyd,UAAU,CAACwE,WAAW,CAACkL,kBAAkB,CAAC,CAAC;EAC3D;EACA,IAAI,gBAAgB,IAAIkM,IAAI,IAAIA,IAAI,CAACq8F,cAAc,EAAE31H,MAAM,EAAE;IAC3D,MAAM41H,kBAAkB,GAAGt8F,IAAI,CAACq8F,cAAc,CAACxxH,GAAG,CAAC0xH,aAAa,IAAIn3G,OAAO,CAACm3G,aAAa,CAAC,CAAC;IAC3FT,QAAQ,CAACn1H,IAAI,CAACyd,UAAU,CAACwE,WAAW,CAACsL,qBAAqB,CAAC,CAACjd,MAAM,CAAC,CAACyN,UAAU,CAAC43G,kBAAkB,CAAC,CAAC,CAAC,CAAC;EACvG;EACA,IAAIR,QAAQ,CAACp1H,MAAM,EAAE;IACnBy+C,aAAa,CAACz6C,GAAG,CAAC,UAAU,EAAEga,UAAU,CAACo3G,QAAQ,CAAC,CAAC;EACrD;AACF;AACA,SAASU,4BAA4BA,CAACx8F,IAAI,EAAE2+E,YAAY,EAAEI,aAAa,EAAE;EACvE,MAAM55D,aAAa,GAAGs2E,mBAAmB,CAACz7F,IAAI,EAAE2+E,YAAY,EAAEI,aAAa,CAAC;EAC5E8c,WAAW,CAAC12E,aAAa,EAAEnlB,IAAI,CAAC;EAChC,MAAMxwB,UAAU,GAAG4U,UAAU,CAACwE,WAAW,CAAC+I,eAAe,CAAC,CAAC1a,MAAM,CAAC,CAACkuC,aAAa,CAAC/K,YAAY,CAAC,CAAC,CAAC,EAAE7jB,SAAS,EAAE,IAAI,CAAC;EAClH,MAAM9mB,IAAI,GAAGgtH,mBAAmB,CAACz8F,IAAI,CAAC;EACtC,OAAO;IACLxwB,UAAU;IACVC,IAAI;IACJkQ,UAAU,EAAE;EACd,CAAC;AACH;AACA,SAAS+8G,4BAA4BA,CAAC18F,IAAI,EAAE2+E,YAAY,EAAEI,aAAa,EAAE;EACvE,MAAM55D,aAAa,GAAGs2E,mBAAmB,CAACz7F,IAAI,EAAE2+E,YAAY,EAAEI,aAAa,CAAC;EAC5E8c,WAAW,CAAC12E,aAAa,EAAEnlB,IAAI,CAAC;EAChC,MAAM35B,QAAQ,GAAG25B,IAAI,CAAC35B,QAAQ,IAAIN,WAAW,CAACK,KAAK,CAAC45B,IAAI,CAAC35B,QAAQ,CAAC;EAClE,MAAMs2H,aAAa,GAAGt2H,QAAQ,IAAIA,QAAQ,CAAC,CAAC,CAAC;EAC7C,IAAIs2H,aAAa,EAAE;IACjB,MAAMC,kBAAkB,GAAGD,aAAa,CAACt0H,QAAQ,CAAC,CAAC;IACnD,IAAIu0H,kBAAkB,CAACl2H,MAAM,EAAE;MAC7By+C,aAAa,CAACz6C,GAAG,CAAC,OAAO,EAAEi0G,YAAY,CAAC93F,eAAe,CAACnC,UAAU,CAACk4G,kBAAkB,CAAC/xH,GAAG,CAACpC,KAAK,IAAIA,KAAK,IAAI,IAAI,GAAG2c,OAAO,CAAC3c,KAAK,CAAC,GAAG2c,OAAO,CAACmR,SAAS,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;IAClK;EACF;EACA,MAAMsmG,gBAAgB,GAAG78F,IAAI,CAACx3B,IAAI;EAClC,IAAI++D,mBAAmB,GAAG,IAAI;EAC9B,IAAIvnC,IAAI,CAAC5U,KAAK,CAAC27C,IAAI,KAAK,CAAC,IAAI/mC,IAAI,CAAC5U,KAAK,CAAC0xG,cAAc,KAAK,IAAI,EAAE;IAC/D,MAAMp0D,MAAM,GAAG,GAAGm0D,gBAAgB,UAAU;IAC5Cle,YAAY,CAACh/F,UAAU,CAAChZ,IAAI,CAAC,IAAIyZ,cAAc,CAACsoD,MAAM,EAAE1oC,IAAI,CAAC5U,KAAK,CAAC0xG,cAAc,EAAEvmG,SAAS,EAAEhU,YAAY,CAAC+E,KAAK,CAAC,CAAC;IAClHigD,mBAAmB,GAAGpjD,QAAQ,CAACukD,MAAM,CAAC;EACxC;EACA,MAAMk2C,eAAe,GAAG5+E,IAAI,CAAC6nB,YAAY,IAAI,CAAC7nB,IAAI,CAAC+8F,wBAAwB,GAAGp2D,uBAAuB,CAACoE,OAAO,GAAGpE,uBAAuB,CAACq2D,IAAI;EAC5I,MAAMvf,GAAG,GAAGiB,eAAe,CAAC1+E,IAAI,CAACx3B,IAAI,EAAEw3B,IAAI,CAACrkB,QAAQ,CAAC3N,KAAK,EAAE2wG,YAAY,EAAEC,eAAe,EAAE5+E,IAAI,CAAConC,uBAAuB,EAAEpnC,IAAI,CAACqnC,kBAAkB,EAAErnC,IAAI,CAAC5U,KAAK,EAAEm8C,mBAAmB,EAAEvnC,IAAI,CAACwnC,oBAAoB,EAAEy9C,iCAAiC,CAAC,CAAC,CAAC;EAClPrrD,SAAS,CAAC6jD,GAAG,EAAE/2C,kBAAkB,CAACkB,IAAI,CAAC;EACvC,MAAMq1D,UAAU,GAAGzf,cAAc,CAACC,GAAG,EAAEkB,YAAY,CAAC;EACpD,IAAIlB,GAAG,CAAC31C,gBAAgB,KAAK,IAAI,EAAE;IACjC3iB,aAAa,CAACz6C,GAAG,CAAC,oBAAoB,EAAE+yG,GAAG,CAAC31C,gBAAgB,CAAC;EAC/D;EACA3iB,aAAa,CAACz6C,GAAG,CAAC,OAAO,EAAE0a,OAAO,CAACq4F,GAAG,CAACl4C,IAAI,CAAC5D,KAAK,CAAC,CAAC;EACnDxc,aAAa,CAACz6C,GAAG,CAAC,MAAM,EAAE0a,OAAO,CAACq4F,GAAG,CAACl4C,IAAI,CAACt0B,IAAI,CAAC,CAAC;EACjD,IAAIwsE,GAAG,CAACp1C,MAAM,CAAC3hE,MAAM,GAAG,CAAC,EAAE;IACzB,IAAI+2G,GAAG,CAACn1C,kBAAkB,CAAC5hE,MAAM,GAAG,CAAC,EAAE;MACrCy+C,aAAa,CAACz6C,GAAG,CAAC,QAAQ,EAAEqa,OAAO,CAAC,EAAE,EAAE,CAAC,GAAG04F,GAAG,CAACn1C,kBAAkB,EAAE,IAAI/kD,eAAe,CAACmB,UAAU,CAAC+4F,GAAG,CAACp1C,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IACpH,CAAC,MAAM;MACLljB,aAAa,CAACz6C,GAAG,CAAC,QAAQ,EAAEga,UAAU,CAAC+4F,GAAG,CAACp1C,MAAM,CAAC,CAAC;IACrD;EACF;EACAljB,aAAa,CAACz6C,GAAG,CAAC,UAAU,EAAEuyH,UAAU,CAAC;EACzC,IAAIj9F,IAAI,CAACk9F,uBAAuB,KAAK,CAAC,IAAIl9F,IAAI,CAACgmB,YAAY,CAACt/C,MAAM,GAAG,CAAC,EAAE;IACtEy+C,aAAa,CAACz6C,GAAG,CAAC,cAAc,EAAEyyH,sBAAsB,CAACz4G,UAAU,CAACsb,IAAI,CAACgmB,YAAY,CAACn7C,GAAG,CAACknC,IAAI,IAAIA,IAAI,CAACtiC,IAAI,CAAC,CAAC,EAAEuwB,IAAI,CAACk9F,uBAAuB,CAAC,CAAC;EAC/I,CAAC,MAAM,IAAIl9F,IAAI,CAACk9F,uBAAuB,KAAK,CAAC,EAAE;IAC7C,MAAM5hH,IAAI,GAAG,CAAC0kB,IAAI,CAACvwB,IAAI,CAAChH,KAAK,CAAC;IAC9B,IAAIu3B,IAAI,CAACo9F,UAAU,EAAE;MACnB9hH,IAAI,CAAC3U,IAAI,CAACq5B,IAAI,CAACo9F,UAAU,CAAC;IAC5B;IACAj4E,aAAa,CAACz6C,GAAG,CAAC,cAAc,EAAE0Z,UAAU,CAACwE,WAAW,CAACwI,uBAAuB,CAAC,CAACna,MAAM,CAACqE,IAAI,CAAC,CAAC;EACjG;EACA,IAAI0kB,IAAI,CAACq9F,aAAa,KAAK,IAAI,EAAE;IAC/Br9F,IAAI,CAACq9F,aAAa,GAAGtxH,mBAAmB,CAACuxH,QAAQ;EACnD;EACA,IAAIC,SAAS,GAAG,CAAC,CAACv9F,IAAI,CAACq8F,cAAc,EAAE31H,MAAM;EAC7C,IAAIs5B,IAAI,CAACwtC,MAAM,IAAIxtC,IAAI,CAACwtC,MAAM,CAAC9mE,MAAM,EAAE;IACrC,MAAM82H,WAAW,GAAGx9F,IAAI,CAACq9F,aAAa,IAAItxH,mBAAmB,CAACuxH,QAAQ,GAAGG,aAAa,CAACz9F,IAAI,CAACwtC,MAAM,EAAEguD,YAAY,EAAED,SAAS,CAAC,GAAGv7F,IAAI,CAACwtC,MAAM;IAC1I,MAAMkwD,UAAU,GAAGF,WAAW,CAAC3rH,MAAM,CAAC,CAACjK,MAAM,EAAE+1H,KAAK,KAAK;MACvD,IAAIA,KAAK,CAACvnG,IAAI,CAAC,CAAC,CAAC1vB,MAAM,GAAG,CAAC,EAAE;QAC3BkB,MAAM,CAACjB,IAAI,CAACg4G,YAAY,CAAC93F,eAAe,CAACzB,OAAO,CAACu4G,KAAK,CAAC,CAAC,CAAC;MAC3D;MACA,OAAO/1H,MAAM;IACf,CAAC,EAAE,EAAE,CAAC;IACN,IAAI81H,UAAU,CAACh3H,MAAM,GAAG,CAAC,EAAE;MACzB62H,SAAS,GAAG,IAAI;MAChBp4E,aAAa,CAACz6C,GAAG,CAAC,QAAQ,EAAEga,UAAU,CAACg5G,UAAU,CAAC,CAAC;IACrD;EACF;EACA,IAAI,CAACH,SAAS,IAAIv9F,IAAI,CAACq9F,aAAa,KAAKtxH,mBAAmB,CAACuxH,QAAQ,EAAE;IACrEt9F,IAAI,CAACq9F,aAAa,GAAGtxH,mBAAmB,CAACiI,IAAI;EAC/C;EACA,IAAIgsB,IAAI,CAACq9F,aAAa,KAAKtxH,mBAAmB,CAACuxH,QAAQ,EAAE;IACvDn4E,aAAa,CAACz6C,GAAG,CAAC,eAAe,EAAE0a,OAAO,CAAC4a,IAAI,CAACq9F,aAAa,CAAC,CAAC;EACjE;EACA,IAAIr9F,IAAI,CAAC49F,UAAU,KAAK,IAAI,EAAE;IAC5Bz4E,aAAa,CAACz6C,GAAG,CAAC,MAAM,EAAEka,UAAU,CAAC,CAAC;MACpC7N,GAAG,EAAE,WAAW;MAChBtO,KAAK,EAAEu3B,IAAI,CAAC49F,UAAU;MACtB77G,MAAM,EAAE;IACV,CAAC,CAAC,CAAC,CAAC;EACN;EACA,IAAIie,IAAI,CAAC69F,eAAe,KAAK,IAAI,EAAE;IACjC,IAAI,OAAO79F,IAAI,CAAC69F,eAAe,KAAK,QAAQ,IAAI79F,IAAI,CAAC69F,eAAe,KAAK5xH,uBAAuB,CAAC6xH,OAAO,EAAE;MACxG34E,aAAa,CAACz6C,GAAG,CAAC,iBAAiB,EAAE0a,OAAO,CAAC4a,IAAI,CAAC69F,eAAe,CAAC,CAAC;IACrE,CAAC,MAAM,IAAI,OAAO79F,IAAI,CAAC69F,eAAe,KAAK,QAAQ,EAAE;MACnD14E,aAAa,CAACz6C,GAAG,CAAC,iBAAiB,EAAEs1B,IAAI,CAAC69F,eAAe,CAAC;IAC5D;EACF;EACA,MAAMruH,UAAU,GAAG4U,UAAU,CAACwE,WAAW,CAACyI,eAAe,CAAC,CAACpa,MAAM,CAAC,CAACkuC,aAAa,CAAC/K,YAAY,CAAC,CAAC,CAAC,EAAE7jB,SAAS,EAAE,IAAI,CAAC;EAClH,MAAM9mB,IAAI,GAAGsuH,mBAAmB,CAAC/9F,IAAI,CAAC;EACtC,OAAO;IACLxwB,UAAU;IACVC,IAAI;IACJkQ,UAAU,EAAE;EACd,CAAC;AACH;AACA,SAASo+G,mBAAmBA,CAAC/9F,IAAI,EAAE;EACjC,MAAMxrB,UAAU,GAAGwpH,6BAA6B,CAACh+F,IAAI,CAAC;EACtDxrB,UAAU,CAAC7N,IAAI,CAACs3H,iBAAiB,CAACj+F,IAAI,CAACrkB,QAAQ,CAACg7G,kBAAkB,CAAC,CAAC;EACpEniH,UAAU,CAAC7N,IAAI,CAAC4d,cAAc,CAACa,OAAO,CAAC4a,IAAI,CAAC6nB,YAAY,CAAC,CAAC,CAAC;EAC3DrzC,UAAU,CAAC7N,IAAI,CAACu3H,wBAAwB,CAACl+F,IAAI,CAAC,CAAC;EAC/C,IAAIA,IAAI,CAAC8Z,QAAQ,EAAE;IACjBtlC,UAAU,CAAC7N,IAAI,CAAC4d,cAAc,CAACa,OAAO,CAAC4a,IAAI,CAAC8Z,QAAQ,CAAC,CAAC,CAAC;EACzD;EACA,OAAOv1B,cAAc,CAACH,UAAU,CAACwE,WAAW,CAAC4I,oBAAoB,EAAEhd,UAAU,CAAC,CAAC;AACjF;AACA,SAAS2oH,sBAAsBA,CAACgB,IAAI,EAAEp3D,IAAI,EAAE;EAC1C,QAAQA,IAAI;IACV,KAAK,CAAC;MACJ,OAAOo3D,IAAI;IACb,KAAK,CAAC;MACJ,OAAOp5G,OAAO,CAAC,EAAE,EAAEo5G,IAAI,CAAC;IAC1B,KAAK,CAAC;MACJ,MAAMC,YAAY,GAAGD,IAAI,CAACtnH,IAAI,CAAC,KAAK,CAAC,CAACI,MAAM,CAAC,CAACmN,UAAU,CAACwE,WAAW,CAAC+H,iBAAiB,CAAC,CAAC,CAAC;MACzF,OAAO5L,OAAO,CAAC,EAAE,EAAEq5G,YAAY,CAAC;IAClC,KAAK,CAAC;MACJ,MAAM,IAAIl3H,KAAK,CAAC,wDAAwD,CAAC;EAC7E;AACF;AACA,SAASm3H,YAAYA,CAACluH,GAAG,EAAE;EACzB,OAAOoU,cAAc,CAACa,OAAO,CAACjV,GAAG,CAAC,CAAC;AACrC;AACA,SAASmuH,4BAA4BA,CAACzzH,GAAG,EAAE;EACzC,MAAM0zH,SAAS,GAAGrxH,MAAM,CAACmC,IAAI,CAACxE,GAAG,CAAC,CAACA,GAAG,CAACkM,GAAG,IAAI;IAC5C,MAAMtO,KAAK,GAAGwX,KAAK,CAACC,OAAO,CAACrV,GAAG,CAACkM,GAAG,CAAC,CAAC,GAAGlM,GAAG,CAACkM,GAAG,CAAC,CAAC,CAAC,CAAC,GAAGlM,GAAG,CAACkM,GAAG,CAAC;IAC9D,OAAO;MACLA,GAAG;MACHtO,KAAK,EAAE2c,OAAO,CAAC3c,KAAK,CAAC;MACrBsZ,MAAM,EAAE;IACV,CAAC;EACH,CAAC,CAAC;EACF,OAAO6C,UAAU,CAAC25G,SAAS,CAAC;AAC9B;AACA,SAASN,iBAAiBA,CAACO,GAAG,EAAE;EAC9B,OAAOA,GAAG,CAAC93H,MAAM,GAAG,CAAC,GAAG6d,cAAc,CAACG,UAAU,CAAC85G,GAAG,CAAC3zH,GAAG,CAACpC,KAAK,IAAI2c,OAAO,CAAC3c,KAAK,CAAC,CAAC,CAAC,CAAC,GAAGsN,SAAS;AAClG;AACA,SAASioH,6BAA6BA,CAACh+F,IAAI,EAAE;EAC3C,MAAMy+F,eAAe,GAAGz+F,IAAI,CAAC35B,QAAQ,KAAK,IAAI,GAAG25B,IAAI,CAAC35B,QAAQ,CAAC6B,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,GAAG,IAAI;EACxF,OAAO,CAACu2B,kBAAkB,CAACuB,IAAI,CAACvwB,IAAI,CAACA,IAAI,EAAEuwB,IAAI,CAAC2B,iBAAiB,CAAC,EAAE88F,eAAe,KAAK,IAAI,GAAGJ,YAAY,CAACI,eAAe,CAAC,GAAG1oH,SAAS,EAAEiqB,IAAI,CAAC47F,QAAQ,KAAK,IAAI,GAAGqC,iBAAiB,CAACj+F,IAAI,CAAC47F,QAAQ,CAAC,GAAG7lH,SAAS,EAAEwO,cAAc,CAACm6G,uBAAuB,CAAC1+F,IAAI,CAAC,CAAC,EAAEzb,cAAc,CAAC+5G,4BAA4B,CAACt+F,IAAI,CAACuL,OAAO,CAAC,CAAC,EAAE0yF,iBAAiB,CAACj+F,IAAI,CAAC8mF,OAAO,CAACj8G,GAAG,CAAC8zH,CAAC,IAAIA,CAAC,CAAC9gC,YAAY,CAAC,CAAC,CAAC;AACvX;AACA,SAAS6gC,uBAAuBA,CAAC1+F,IAAI,EAAE;EACrC,OAAOpb,UAAU,CAAC1X,MAAM,CAACmC,IAAI,CAAC2wB,IAAI,CAACsL,MAAM,CAAC,CAACzgC,GAAG,CAACkM,GAAG,IAAI;IACpD,MAAMtO,KAAK,GAAGu3B,IAAI,CAACsL,MAAM,CAACv0B,GAAG,CAAC;IAC9B,MAAM4N,MAAM,GAAG,CAAC;MACd5N,GAAG,EAAE,OAAO;MACZtO,KAAK,EAAE2c,OAAO,CAAC3c,KAAK,CAACixC,mBAAmB,CAAC;MACzC33B,MAAM,EAAE;IACV,CAAC,EAAE;MACDhL,GAAG,EAAE,UAAU;MACftO,KAAK,EAAE2c,OAAO,CAAC3c,KAAK,CAACm2H,QAAQ,CAAC;MAC9B78G,MAAM,EAAE;IACV,CAAC,CAAC;IACF,IAAItZ,KAAK,CAACqxC,QAAQ,EAAE;MAClBn1B,MAAM,CAAChe,IAAI,CAAC;QACVoQ,GAAG,EAAE,UAAU;QACftO,KAAK,EAAE2c,OAAO,CAAC3c,KAAK,CAACqxC,QAAQ,CAAC;QAC9B/3B,MAAM,EAAE;MACV,CAAC,CAAC;IACJ;IACA,OAAO;MACLhL,GAAG;MACHtO,KAAK,EAAEmc,UAAU,CAACD,MAAM,CAAC;MACzB5C,MAAM,EAAE;IACV,CAAC;EACH,CAAC,CAAC,CAAC;AACL;AACA,SAAS06G,mBAAmBA,CAACz8F,IAAI,EAAE;EACjC,MAAMxrB,UAAU,GAAGwpH,6BAA6B,CAACh+F,IAAI,CAAC;EACtDxrB,UAAU,CAAC7N,IAAI,CAACoP,SAAS,CAAC;EAC1BvB,UAAU,CAAC7N,IAAI,CAAC4d,cAAc,CAACa,OAAO,CAAC4a,IAAI,CAAC6nB,YAAY,CAAC,CAAC,CAAC;EAC3DrzC,UAAU,CAAC7N,IAAI,CAACu3H,wBAAwB,CAACl+F,IAAI,CAAC,CAAC;EAC/C,IAAIA,IAAI,CAAC8Z,QAAQ,EAAE;IACjBtlC,UAAU,CAAC7N,IAAI,CAAC4d,cAAc,CAACa,OAAO,CAAC4a,IAAI,CAAC8Z,QAAQ,CAAC,CAAC,CAAC;EACzD;EACA,OAAOv1B,cAAc,CAACH,UAAU,CAACwE,WAAW,CAACiJ,oBAAoB,EAAErd,UAAU,CAAC,CAAC;AACjF;AACA,SAASknH,0BAA0BA,CAACmD,oBAAoB,EAAElD,cAAc,EAAE5c,aAAa,EAAEJ,YAAY,EAAEt4G,QAAQ,EAAEmC,IAAI,EAAE28C,aAAa,EAAE;EACpI,MAAM9T,QAAQ,GAAG0tE,aAAa,CAAC4I,yBAAyB,CAACkX,oBAAoB,CAACvgC,UAAU,EAAEq9B,cAAc,CAAC;EACzG,MAAMmD,aAAa,GAAG/f,aAAa,CAAC+I,4BAA4B,CAAC+W,oBAAoB,CAACvtF,SAAS,EAAEqqF,cAAc,CAAC;EAChH,IAAIkD,oBAAoB,CAACE,iBAAiB,CAACC,SAAS,EAAE;IACpDH,oBAAoB,CAACxzF,UAAU,CAAC,OAAO,CAAC,GAAGjmB,OAAO,CAACy5G,oBAAoB,CAACE,iBAAiB,CAACC,SAAS,CAAC;EACtG;EACA,IAAIH,oBAAoB,CAACE,iBAAiB,CAACE,SAAS,EAAE;IACpDJ,oBAAoB,CAACxzF,UAAU,CAAC,OAAO,CAAC,GAAGjmB,OAAO,CAACy5G,oBAAoB,CAACE,iBAAiB,CAACE,SAAS,CAAC;EACtG;EACA,MAAMC,OAAO,GAAGpgB,iBAAiB,CAAC;IAChC7uE,aAAa,EAAEznC,IAAI;IACnB02G,iBAAiB,EAAE74G,QAAQ;IAC3Bi4F,UAAU,EAAEjtD,QAAQ;IACpB8sD,MAAM,EAAE2gC,aAAa;IACrBzzF,UAAU,EAAEwzF,oBAAoB,CAACxzF;EACnC,CAAC,EAAE0zE,aAAa,EAAEJ,YAAY,CAAC;EAC/B/kD,SAAS,CAACslE,OAAO,EAAEx4D,kBAAkB,CAACuC,IAAI,CAAC;EAC3C9jB,aAAa,CAACz6C,GAAG,CAAC,WAAW,EAAEw0H,OAAO,CAAC35D,IAAI,CAACl6B,UAAU,CAAC;EACvD,MAAM0vE,QAAQ,GAAGmkB,OAAO,CAAC35D,IAAI,CAACt0B,IAAI;EAClC,IAAI8pE,QAAQ,KAAK,IAAI,IAAIA,QAAQ,GAAG,CAAC,EAAE;IACrC51D,aAAa,CAACz6C,GAAG,CAAC,UAAU,EAAE0a,OAAO,CAAC21F,QAAQ,CAAC,CAAC;EAClD;EACA,OAAOoD,uBAAuB,CAAC+gB,OAAO,CAAC;AACzC;AACA,MAAMC,YAAY,GAAG,qCAAqC;AAC1D,SAASC,iBAAiBA,CAACn9F,IAAI,EAAE;EAC/B,MAAMoJ,UAAU,GAAG,CAAC,CAAC;EACrB,MAAMiG,SAAS,GAAG,CAAC,CAAC;EACpB,MAAMgtD,UAAU,GAAG,CAAC,CAAC;EACrB,MAAMygC,iBAAiB,GAAG,CAAC,CAAC;EAC5B,KAAK,MAAMhoH,GAAG,IAAI7J,MAAM,CAACmC,IAAI,CAAC4yB,IAAI,CAAC,EAAE;IACnC,MAAMx5B,KAAK,GAAGw5B,IAAI,CAAClrB,GAAG,CAAC;IACvB,MAAMo4C,OAAO,GAAGp4C,GAAG,CAAClQ,KAAK,CAACs4H,YAAY,CAAC;IACvC,IAAIhwE,OAAO,KAAK,IAAI,EAAE;MACpB,QAAQp4C,GAAG;QACT,KAAK,OAAO;UACV,IAAI,OAAOtO,KAAK,KAAK,QAAQ,EAAE;YAC7B,MAAM,IAAIvB,KAAK,CAAC,8BAA8B,CAAC;UACjD;UACA63H,iBAAiB,CAACE,SAAS,GAAGx2H,KAAK;UACnC;QACF,KAAK,OAAO;UACV,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;YAC7B,MAAM,IAAIvB,KAAK,CAAC,8BAA8B,CAAC;UACjD;UACA63H,iBAAiB,CAACC,SAAS,GAAGv2H,KAAK;UACnC;QACF;UACE,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;YAC7B4iC,UAAU,CAACt0B,GAAG,CAAC,GAAGqO,OAAO,CAAC3c,KAAK,CAAC;UAClC,CAAC,MAAM;YACL4iC,UAAU,CAACt0B,GAAG,CAAC,GAAGtO,KAAK;UACzB;MACJ;IACF,CAAC,MAAM,IAAI0mD,OAAO,CAAC,CAAC,CAAC,IAAI,IAAI,EAAE;MAC7B,IAAI,OAAO1mD,KAAK,KAAK,QAAQ,EAAE;QAC7B,MAAM,IAAIvB,KAAK,CAAC,iCAAiC,CAAC;MACpD;MACAo3F,UAAU,CAACnvC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG1mD,KAAK;IAChC,CAAC,MAAM,IAAI0mD,OAAO,CAAC,CAAC,CAAC,IAAI,IAAI,EAAE;MAC7B,IAAI,OAAO1mD,KAAK,KAAK,QAAQ,EAAE;QAC7B,MAAM,IAAIvB,KAAK,CAAC,8BAA8B,CAAC;MACjD;MACAoqC,SAAS,CAAC6d,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG1mD,KAAK;IAC/B;EACF;EACA,OAAO;IACL4iC,UAAU;IACViG,SAAS;IACTgtD,UAAU;IACVygC;EACF,CAAC;AACH;AACA,SAASM,kBAAkBA,CAAChuF,QAAQ,EAAEz6B,UAAU,EAAE;EAChD,MAAMmoG,aAAa,GAAG6b,iBAAiB,CAAC,CAAC;EACzC7b,aAAa,CAAC+I,4BAA4B,CAACz2E,QAAQ,CAACC,SAAS,EAAE16B,UAAU,CAAC;EAC1EmoG,aAAa,CAAC4I,yBAAyB,CAACt2E,QAAQ,CAACitD,UAAU,EAAE1nF,UAAU,CAAC;EACxE,OAAOmoG,aAAa,CAACn3E,MAAM;AAC7B;AACA,SAAS61F,aAAaA,CAACjwD,MAAM,EAAEnnE,QAAQ,EAAEgiD,YAAY,EAAE;EACrD,MAAMi3E,SAAS,GAAG,IAAIp3E,SAAS,CAAC,CAAC;EACjC,OAAOslB,MAAM,CAAC3iE,GAAG,CAAC8yH,KAAK,IAAI;IACzB,OAAO2B,SAAS,CAACn3E,WAAW,CAACw1E,KAAK,EAAEt3H,QAAQ,EAAEgiD,YAAY,CAAC;EAC7D,CAAC,CAAC;AACJ;AACA,SAASk3E,gBAAgBA,CAAC5B,KAAK,EAAE6B,mBAAmB,EAAE;EACpD,MAAMF,SAAS,GAAG,IAAIp3E,SAAS,CAAC,CAAC;EACjC,MAAM7hD,QAAQ,GAAGm5H,mBAAmB,GAAGhE,YAAY,CAACtzH,OAAO,CAACozH,kBAAkB,EAAEkE,mBAAmB,CAAC,GAAGhE,YAAY;EACnH,MAAMnzE,YAAY,GAAGm3E,mBAAmB,GAAGjE,SAAS,CAACrzH,OAAO,CAACozH,kBAAkB,EAAEkE,mBAAmB,CAAC,GAAGjE,SAAS;EACjH,OAAO+D,SAAS,CAACn3E,WAAW,CAACw1E,KAAK,EAAEt3H,QAAQ,EAAEgiD,YAAY,CAAC;AAC7D;AACA,SAAS61E,wBAAwBA,CAACl+F,IAAI,EAAE;EACtC,IAAI,CAACA,IAAI,CAACg8F,cAAc,EAAEt1H,MAAM,EAAE;IAChC,OAAOqP,SAAS;EAClB;EACA,OAAOwO,cAAc,CAACG,UAAU,CAACsb,IAAI,CAACg8F,cAAc,CAACnxH,GAAG,CAAC40H,QAAQ,IAAI76G,UAAU,CAAC,CAAC;IAC/E7N,GAAG,EAAE,WAAW;IAChBtO,KAAK,EAAEgc,UAAU,CAACg7G,QAAQ,CAAC5tF,SAAS,CAACpiC,IAAI,CAAC;IAC1CsS,MAAM,EAAE;EACV,CAAC,EAAE;IACDhL,GAAG,EAAE,QAAQ;IACbtO,KAAK,EAAE61H,4BAA4B,CAACmB,QAAQ,CAACn0F,MAAM,IAAI,CAAC,CAAC,CAAC;IAC1DvpB,MAAM,EAAE;EACV,CAAC,EAAE;IACDhL,GAAG,EAAE,SAAS;IACdtO,KAAK,EAAE61H,4BAA4B,CAACmB,QAAQ,CAACl0F,OAAO,IAAI,CAAC,CAAC,CAAC;IAC3DxpB,MAAM,EAAE;EACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACR;AACA,SAASk6G,8BAA8BA,CAACD,cAAc,EAAE;EACtD,MAAMz/G,WAAW,GAAG,EAAE;EACtB,IAAImjH,aAAa,GAAG,KAAK;EACzB,KAAK,MAAM54H,OAAO,IAAIk1H,cAAc,EAAE;IACpC,IAAI,CAACl1H,OAAO,CAACwkC,MAAM,IAAI,CAACxkC,OAAO,CAACykC,OAAO,EAAE;MACvChvB,WAAW,CAAC5V,IAAI,CAACG,OAAO,CAAC+qC,SAAS,CAACpiC,IAAI,CAAC;IAC1C,CAAC,MAAM;MACL,MAAMJ,IAAI,GAAG,CAAC;QACZ0H,GAAG,EAAE,WAAW;QAChBtO,KAAK,EAAE3B,OAAO,CAAC+qC,SAAS,CAACpiC,IAAI;QAC7BsS,MAAM,EAAE;MACV,CAAC,CAAC;MACF,IAAIjb,OAAO,CAACwkC,MAAM,EAAE;QAClB,MAAMq0F,aAAa,GAAGC,gCAAgC,CAAC94H,OAAO,CAACwkC,MAAM,CAAC;QACtE,IAAIq0F,aAAa,EAAE;UACjBtwH,IAAI,CAAC1I,IAAI,CAAC;YACRoQ,GAAG,EAAE,QAAQ;YACbtO,KAAK,EAAEk3H,aAAa;YACpB59G,MAAM,EAAE;UACV,CAAC,CAAC;QACJ;MACF;MACA,IAAIjb,OAAO,CAACykC,OAAO,EAAE;QACnB,MAAMs0F,cAAc,GAAGD,gCAAgC,CAAC94H,OAAO,CAACykC,OAAO,CAAC;QACxE,IAAIs0F,cAAc,EAAE;UAClBxwH,IAAI,CAAC1I,IAAI,CAAC;YACRoQ,GAAG,EAAE,SAAS;YACdtO,KAAK,EAAEo3H,cAAc;YACrB99G,MAAM,EAAE;UACV,CAAC,CAAC;QACJ;MACF;MACAxF,WAAW,CAAC5V,IAAI,CAACie,UAAU,CAACvV,IAAI,CAAC,CAAC;IACpC;IACA,IAAIvI,OAAO,CAACg5H,kBAAkB,EAAE;MAC9BJ,aAAa,GAAG,IAAI;IACtB;EACF;EACA,OAAOA,aAAa,GAAG,IAAIhgH,YAAY,CAAC,EAAE,EAAE,CAAC,IAAI6D,eAAe,CAACmB,UAAU,CAACnI,WAAW,CAAC,CAAC,CAAC,CAAC,GAAGmI,UAAU,CAACnI,WAAW,CAAC;AACvH;AACA,SAASqjH,gCAAgCA,CAAChsB,OAAO,EAAE;EACjD,MAAMt3F,QAAQ,GAAG,EAAE;EACnB,KAAK,MAAM23B,UAAU,IAAI2/D,OAAO,EAAE;IAChC,IAAIA,OAAO,CAAC7/D,cAAc,CAACE,UAAU,CAAC,EAAE;MACtC33B,QAAQ,CAAC3V,IAAI,CAACye,OAAO,CAAC6uB,UAAU,CAAC,EAAE7uB,OAAO,CAACwuF,OAAO,CAAC3/D,UAAU,CAAC,CAAC,CAAC;IAClE;EACF;EACA,OAAO33B,QAAQ,CAAC5V,MAAM,GAAG,CAAC,GAAGge,UAAU,CAACpI,QAAQ,CAAC,GAAG,IAAI;AAC1D;AACA,SAASyjH,4BAA4BA,CAAC//F,IAAI,EAAE;EAC1C,MAAMggG,cAAc,GAAG,EAAE;EACzB,IAAIhgG,IAAI,CAAC+mC,IAAI,KAAK,CAAC,EAAE;IACnB,KAAK,MAAMnlC,GAAG,IAAI5B,IAAI,CAACigG,YAAY,EAAE;MACnC,IAAIr+F,GAAG,CAACs+F,YAAY,EAAE;QACpB,MAAMC,OAAO,GAAGp7G,OAAO,CAAC,CAAC,IAAIvF,OAAO,CAAC,GAAG,EAAEtK,YAAY,CAAC,CAAC,EAAEiP,QAAQ,CAAC,GAAG,CAAC,CAACtN,IAAI,CAAC+qB,GAAG,CAACw+F,eAAe,GAAG,SAAS,GAAGx+F,GAAG,CAACy+F,UAAU,CAAC,CAAC;QAC/H,MAAMj8G,UAAU,GAAG,IAAIlF,iBAAiB,CAAC0iB,GAAG,CAAC0+F,UAAU,CAAC,CAACzpH,IAAI,CAAC,MAAM,CAAC,CAACI,MAAM,CAAC,CAACkpH,OAAO,CAAC,CAAC;QACvFH,cAAc,CAACr5H,IAAI,CAACyd,UAAU,CAAC;MACjC,CAAC,MAAM;QACL47G,cAAc,CAACr5H,IAAI,CAACi7B,GAAG,CAAC2+F,aAAa,CAAC;MACxC;IACF;EACF,CAAC,MAAM;IACL,KAAK,MAAM;MACTF,UAAU;MACVC,UAAU;MACVF;IACF,CAAC,IAAIpgG,IAAI,CAACigG,YAAY,EAAE;MACtB,MAAME,OAAO,GAAGp7G,OAAO,CAAC,CAAC,IAAIvF,OAAO,CAAC,GAAG,EAAEtK,YAAY,CAAC,CAAC,EAAEiP,QAAQ,CAAC,GAAG,CAAC,CAACtN,IAAI,CAACupH,eAAe,GAAG,SAAS,GAAGC,UAAU,CAAC,CAAC;MACvH,MAAMj8G,UAAU,GAAG,IAAIlF,iBAAiB,CAACohH,UAAU,CAAC,CAACzpH,IAAI,CAAC,MAAM,CAAC,CAACI,MAAM,CAAC,CAACkpH,OAAO,CAAC,CAAC;MACnFH,cAAc,CAACr5H,IAAI,CAACyd,UAAU,CAAC;IACjC;EACF;EACA,OAAOW,OAAO,CAAC,EAAE,EAAEL,UAAU,CAACs7G,cAAc,CAAC,CAAC;AAChD;AAEA,MAAMQ,2BAA2B,SAAS58G,mBAAmB,CAAC;EAC5DpV,KAAKA,CAAC2M,IAAI,EAAE;IACV,IAAIA,IAAI,YAAYusB,aAAa,EAAE;MACjC,IAAI,CAACl5B,KAAK,CAAC2M,IAAI,CAAC0I,GAAG,CAAC;IACtB,CAAC,MAAM;MACL1I,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC;IAClB;EACF;EACAq9B,YAAYA,CAAC7lC,OAAO,EAAE;IACpB,IAAI,CAACy6H,qBAAqB,CAACz6H,OAAO,CAACqlC,UAAU,CAAC;IAC9C,IAAI,CAACo1F,qBAAqB,CAACz6H,OAAO,CAACslC,MAAM,CAAC;IAC1C,IAAI,CAACm1F,qBAAqB,CAACz6H,OAAO,CAACulC,OAAO,CAAC;IAC3C,IAAI,CAACk1F,qBAAqB,CAACz6H,OAAO,CAACwlC,UAAU,CAAC;IAC9C,IAAI,CAACi1F,qBAAqB,CAACz6H,OAAO,CAACylC,UAAU,CAAC;IAC9C,IAAI,CAACg1F,qBAAqB,CAACz6H,OAAO,CAACgJ,QAAQ,CAAC;EAC9C;EACAwhC,aAAaA,CAAC70B,QAAQ,EAAE;IACtB,IAAI,CAAC8kH,qBAAqB,CAAC9kH,QAAQ,CAAC0vB,UAAU,CAAC;IAC/C,IAAI,CAACo1F,qBAAqB,CAAC9kH,QAAQ,CAAC2vB,MAAM,CAAC;IAC3C,IAAI,CAACm1F,qBAAqB,CAAC9kH,QAAQ,CAAC4vB,OAAO,CAAC;IAC5C,IAAI,CAACk1F,qBAAqB,CAAC9kH,QAAQ,CAAC6vB,UAAU,CAAC;IAC/C,IAAI,CAACi1F,qBAAqB,CAAC9kH,QAAQ,CAAC20B,aAAa,CAAC;IAClD,IAAI,CAACmwF,qBAAqB,CAAC9kH,QAAQ,CAAC40B,SAAS,CAAC;IAC9C,IAAI,CAACkwF,qBAAqB,CAAC9kH,QAAQ,CAAC8vB,UAAU,CAAC;IAC/C,IAAI,CAACg1F,qBAAqB,CAAC9kH,QAAQ,CAAC3M,QAAQ,CAAC;EAC/C;EACA0hC,YAAYA,CAACjY,OAAO,EAAE;IACpB,IAAI,CAACgoG,qBAAqB,CAAChoG,OAAO,CAACzpB,QAAQ,CAAC;EAC9C;EACA27B,mBAAmBA,CAACljC,SAAS,EAAE;IAC7B,IAAI,CAAC+G,KAAK,CAAC/G,SAAS,CAACgB,KAAK,CAAC;EAC7B;EACAyiC,eAAeA,CAACzjC,SAAS,EAAE;IACzB,IAAI,CAAC+G,KAAK,CAAC/G,SAAS,CAAC22B,OAAO,CAAC;EAC/B;EACAkM,cAAcA,CAAC17B,IAAI,EAAE;IACnB,IAAI,CAACJ,KAAK,CAACI,IAAI,CAACnG,KAAK,CAAC;EACxB;EACAyG,QAAQA,CAACC,GAAG,EAAE;IACZjC,MAAM,CAACmC,IAAI,CAACF,GAAG,CAAC8hC,IAAI,CAAC,CAACroC,OAAO,CAACmO,GAAG,IAAI,IAAI,CAACvI,KAAK,CAACW,GAAG,CAAC8hC,IAAI,CAACl6B,GAAG,CAAC,CAAC,CAAC;IAC/D7J,MAAM,CAACmC,IAAI,CAACF,GAAG,CAAC+hC,YAAY,CAAC,CAACtoC,OAAO,CAACmO,GAAG,IAAI,IAAI,CAACvI,KAAK,CAACW,GAAG,CAAC+hC,YAAY,CAACn6B,GAAG,CAAC,CAAC,CAAC;EACjF;EACAm3B,kBAAkBA,CAACuD,QAAQ,EAAE;IAC3BA,QAAQ,CAACzJ,QAAQ,CAAC,IAAI,CAAC;EACzB;EACAkE,oBAAoBA,CAAC4F,OAAO,EAAE;IAC5B,IAAIA,OAAO,YAAY3F,oBAAoB,EAAE;MAC3C,IAAI,CAAC39B,KAAK,CAACsjC,OAAO,CAACrpC,KAAK,CAAC;IAC3B,CAAC,MAAM,IAAIqpC,OAAO,YAAYjF,uBAAuB,IAAIiF,OAAO,CAAChF,OAAO,KAAK,IAAI,EAAE;MACjF,IAAI,CAACt+B,KAAK,CAACsjC,OAAO,CAAChF,OAAO,CAAC;IAC7B;EACF;EACAI,6BAA6BA,CAACwE,KAAK,EAAE;IACnC,IAAI,CAAC+uF,qBAAqB,CAAC/uF,KAAK,CAAC1iC,QAAQ,CAAC;EAC5C;EACAu+B,uBAAuBA,CAACmE,KAAK,EAAE;IAC7B,IAAI,CAAC+uF,qBAAqB,CAAC/uF,KAAK,CAAC1iC,QAAQ,CAAC;EAC5C;EACAq+B,yBAAyBA,CAACqE,KAAK,EAAE;IAC/B,IAAI,CAAC+uF,qBAAqB,CAAC/uF,KAAK,CAAC1iC,QAAQ,CAAC;EAC5C;EACAy/B,gBAAgBA,CAACiD,KAAK,EAAE;IACtB,IAAI,CAACljC,KAAK,CAACkjC,KAAK,CAACliC,UAAU,CAAC;IAC5B,IAAI,CAACixH,qBAAqB,CAAC/uF,KAAK,CAACpiC,KAAK,CAAC;EACzC;EACAq/B,oBAAoBA,CAAC+C,KAAK,EAAE;IAC1BA,KAAK,CAACliC,UAAU,IAAI,IAAI,CAAChB,KAAK,CAACkjC,KAAK,CAACliC,UAAU,CAAC;IAChD,IAAI,CAACixH,qBAAqB,CAAC/uF,KAAK,CAAC1iC,QAAQ,CAAC;EAC5C;EACAkgC,iBAAiBA,CAACwC,KAAK,EAAE;IACvBA,KAAK,CAAC7C,IAAI,CAACrgC,KAAK,CAAC,IAAI,CAAC;IACtB,IAAI,CAACiyH,qBAAqB,CAAC/uF,KAAK,CAAC1C,gBAAgB,CAAC;IAClD,IAAI,CAACxgC,KAAK,CAACkjC,KAAK,CAACliC,UAAU,CAAC;IAC5B,IAAI,CAACixH,qBAAqB,CAAC/uF,KAAK,CAAC1iC,QAAQ,CAAC;IAC1C0iC,KAAK,CAACzC,KAAK,EAAEzgC,KAAK,CAAC,IAAI,CAAC;EAC1B;EACA4gC,sBAAsBA,CAACsC,KAAK,EAAE;IAC5B,IAAI,CAAC+uF,qBAAqB,CAAC/uF,KAAK,CAAC1iC,QAAQ,CAAC;EAC5C;EACAugC,YAAYA,CAACmC,KAAK,EAAE;IAClB,IAAI,CAAC+uF,qBAAqB,CAAC/uF,KAAK,CAACpC,QAAQ,CAAC;EAC5C;EACAI,kBAAkBA,CAACgC,KAAK,EAAE;IACxBA,KAAK,CAACliC,UAAU,IAAI,IAAI,CAAChB,KAAK,CAACkjC,KAAK,CAACliC,UAAU,CAAC;IAChDkiC,KAAK,CAACjC,eAAe,EAAEjhC,KAAK,CAAC,IAAI,CAAC;IAClC,IAAI,CAACiyH,qBAAqB,CAAC/uF,KAAK,CAAC1iC,QAAQ,CAAC;EAC5C;EACA+gC,mBAAmBA,CAACgC,IAAI,EAAE;IACxB,IAAI,CAACvjC,KAAK,CAACujC,IAAI,CAACtpC,KAAK,CAAC;EACxB;EACAynC,cAAcA,CAAC0B,SAAS,EAAE;IACxB,IAAI,CAAC6uF,qBAAqB,CAAC7uF,SAAS,CAACvG,UAAU,CAAC;IAChD,IAAI,CAACo1F,qBAAqB,CAAC7uF,SAAS,CAACtG,MAAM,CAAC;IAC5C,IAAI,CAACm1F,qBAAqB,CAAC7uF,SAAS,CAACrG,OAAO,CAAC;IAC7C,IAAI,CAACk1F,qBAAqB,CAAC7uF,SAAS,CAACpG,UAAU,CAAC;IAChD,IAAI,CAACi1F,qBAAqB,CAAC7uF,SAAS,CAACnG,UAAU,CAAC;IAChD,IAAI,CAACg1F,qBAAqB,CAAC7uF,SAAS,CAAC5iC,QAAQ,CAAC;EAChD;EACAohC,cAAcA,CAACyB,SAAS,EAAE;IACxB,IAAI,CAAC4uF,qBAAqB,CAAC5uF,SAAS,CAACxG,UAAU,CAAC;IAChD,IAAI,CAACo1F,qBAAqB,CAAC5uF,SAAS,CAACvG,MAAM,CAAC;IAC5C,IAAI,CAACm1F,qBAAqB,CAAC5uF,SAAS,CAACtG,OAAO,CAAC;IAC7C,IAAI,CAACk1F,qBAAqB,CAAC5uF,SAAS,CAACpG,UAAU,CAAC;EAClD;EACAmF,aAAaA,CAACzsB,QAAQ,EAAE,CAAC;EACzB2sB,cAAcA,CAAC3gB,SAAS,EAAE,CAAC;EAC3Bqa,kBAAkBA,CAAC/iC,SAAS,EAAE,CAAC;EAC/BkH,SAASA,CAACC,IAAI,EAAE,CAAC;EACjBghC,iBAAiBA,CAAC8B,KAAK,EAAE,CAAC;EAC1B+uF,qBAAqBA,CAACzyH,KAAK,EAAE;IAC3B,KAAK,MAAMmN,IAAI,IAAInN,KAAK,EAAE;MACxB,IAAI,CAACQ,KAAK,CAAC2M,IAAI,CAAC;IAClB;EACF;AACF;AAEA,SAAS0jE,IAAIA,CAAC6hD,QAAQ,EAAEC,cAAc,EAAE;EACtC,MAAMC,OAAO,GAAG,IAAI54E,GAAG,CAAC24E,cAAc,CAAC;EACvC,OAAOD,QAAQ,CAACr4G,MAAM,CAACwmB,IAAI,IAAI,CAAC+xF,OAAO,CAAC/0H,GAAG,CAACgjC,IAAI,CAAC,CAAC;AACpD;AACA,SAASgyF,8BAA8BA,CAACllH,QAAQ,EAAEmlH,kBAAkB,EAAE;EACpE,MAAM92H,OAAO,GAAG,IAAIjB,eAAe,CAAC,CAAC;EACrC,KAAK,MAAM1C,QAAQ,IAAIy6H,kBAAkB,EAAE;IACzC,MAAMC,aAAa,GAAG;MACpB16H,QAAQ;MACRu1H,QAAQ,EAAE,IAAI;MACdtwF,MAAM,EAAE;QACN01F,sBAAsBA,CAAA,EAAG;UACvB,OAAO,KAAK;QACd;MACF,CAAC;MACDz1F,OAAO,EAAE;QACPy1F,sBAAsBA,CAAA,EAAG;UACvB,OAAO,KAAK;QACd;MACF;IACF,CAAC;IACDh3H,OAAO,CAACd,cAAc,CAACnD,WAAW,CAACK,KAAK,CAACC,QAAQ,CAAC,EAAE,CAAC06H,aAAa,CAAC,CAAC;EACtE;EACA,MAAM7F,cAAc,GAAGV,aAAa,CAAC7+G,QAAQ,EAAE,EAAE,CAAC;EAClD,MAAMslH,MAAM,GAAG,IAAIC,cAAc,CAACl3H,OAAO,CAAC;EAC1C,MAAMmuH,KAAK,GAAG8I,MAAM,CAACz9E,IAAI,CAAC;IACxB7nC,QAAQ,EAAEu/G,cAAc,CAACltH;EAC3B,CAAC,CAAC;EACF,MAAMmzH,uBAAuB,GAAGhJ,KAAK,CAACiJ,wBAAwB,CAAC,CAAC,CAACv2H,GAAG,CAACo5F,GAAG,IAAIA,GAAG,CAAC59F,QAAQ,CAAC;EACzF,MAAMg7H,4BAA4B,GAAGlJ,KAAK,CAACmJ,iBAAiB,CAAC,CAAC,CAACz2H,GAAG,CAACo5F,GAAG,IAAIA,GAAG,CAAC59F,QAAQ,CAAC;EACvF,MAAMk7H,UAAU,GAAGpJ,KAAK,CAACqJ,mBAAmB,CAAC,CAAC;EAC9C,OAAO;IACLh2F,UAAU,EAAE;MACVi2F,OAAO,EAAEN,uBAAuB;MAChCO,eAAe,EAAE7iD,IAAI,CAACwiD,4BAA4B,EAAEF,uBAAuB;IAC7E,CAAC;IACDQ,KAAK,EAAE;MACLF,OAAO,EAAEF,UAAU;MACnBG,eAAe,EAAE7iD,IAAI,CAACs5C,KAAK,CAACyJ,YAAY,CAAC,CAAC,EAAEL,UAAU;IACxD;EACF,CAAC;AACH;AACA,MAAML,cAAc,CAAC;EACnBW,gBAAgB;EAChBr2H,WAAWA,CAACq2H,gBAAgB,EAAE;IAC5B,IAAI,CAACA,gBAAgB,GAAGA,gBAAgB;EAC1C;EACAr+E,IAAIA,CAAChjB,MAAM,EAAE;IACX,IAAI,CAACA,MAAM,CAAC7kB,QAAQ,IAAI,CAAC6kB,MAAM,CAACyB,IAAI,EAAE;MACpC,MAAM,IAAI/6B,KAAK,CAAC,uCAAuC,CAAC;IAC1D;IACA,MAAMskC,UAAU,GAAG,IAAIpiC,GAAG,CAAC,CAAC;IAC5B,MAAM04H,eAAe,GAAG,EAAE;IAC1B,MAAMC,iBAAiB,GAAG,IAAI/5E,GAAG,CAAC,CAAC;IACnC,MAAM3W,QAAQ,GAAG,IAAIjoC,GAAG,CAAC,CAAC;IAC1B,MAAMqiC,UAAU,GAAG,IAAIriC,GAAG,CAAC,CAAC;IAC5B,MAAM44H,kBAAkB,GAAG,IAAI54H,GAAG,CAAC,CAAC;IACpC,MAAMmT,WAAW,GAAG,IAAInT,GAAG,CAAC,CAAC;IAC7B,MAAM64H,OAAO,GAAG,IAAI74H,GAAG,CAAC,CAAC;IACzB,MAAM84H,YAAY,GAAG,IAAI94H,GAAG,CAAC,CAAC;IAC9B,MAAM+4H,SAAS,GAAG,IAAIn6E,GAAG,CAAC,CAAC;IAC3B,MAAMu5E,UAAU,GAAG,IAAIv5E,GAAG,CAAC,CAAC;IAC5B,MAAMo6E,WAAW,GAAG,EAAE;IACtB,IAAI5hG,MAAM,CAAC7kB,QAAQ,EAAE;MACnB,MAAM4zD,KAAK,GAAGoB,KAAK,CAACuH,KAAK,CAAC13C,MAAM,CAAC7kB,QAAQ,CAAC;MAC1C0mH,yBAAyB,CAAC9yD,KAAK,EAAEyyD,kBAAkB,CAAC;MACpDM,eAAe,CAACpqD,KAAK,CAAC13C,MAAM,CAAC7kB,QAAQ,EAAE,IAAI,CAACkmH,gBAAgB,EAAEr2F,UAAU,EAAEs2F,eAAe,EAAEC,iBAAiB,EAAE1wF,QAAQ,EAAE5F,UAAU,CAAC;MACnI82F,cAAc,CAACC,cAAc,CAAChiG,MAAM,CAAC7kB,QAAQ,EAAE4zD,KAAK,EAAEhzD,WAAW,EAAE0lH,OAAO,EAAEC,YAAY,EAAEC,SAAS,EAAEZ,UAAU,EAAEa,WAAW,CAAC;IAC/H;IACA,IAAI5hG,MAAM,CAACyB,IAAI,EAAE;MACfuJ,UAAU,CAAC9gC,GAAG,CAAC81B,MAAM,CAACyB,IAAI,CAAC9mB,IAAI,EAAEqlB,MAAM,CAACyB,IAAI,CAACuJ,UAAU,CAAC;MACxD+2F,cAAc,CAACC,cAAc,CAAChiG,MAAM,CAACyB,IAAI,CAAC9mB,IAAI,EAAEw1D,KAAK,CAACuH,KAAK,CAAC13C,MAAM,CAACyB,IAAI,CAAC9mB,IAAI,CAAC,EAAEoB,WAAW,EAAE0lH,OAAO,EAAEC,YAAY,EAAEC,SAAS,EAAEZ,UAAU,EAAEa,WAAW,CAAC;IACxJ;IACA,OAAO,IAAIK,aAAa,CAACjiG,MAAM,EAAEgL,UAAU,EAAEs2F,eAAe,EAAEC,iBAAiB,EAAE1wF,QAAQ,EAAE5F,UAAU,EAAElvB,WAAW,EAAE0lH,OAAO,EAAEC,YAAY,EAAEF,kBAAkB,EAAEG,SAAS,EAAEZ,UAAU,EAAEa,WAAW,CAAC;EACpM;AACF;AACA,MAAMzxD,KAAK,CAAC;EACVwE,WAAW;EACX3+B,QAAQ;EACRksF,aAAa,GAAG,IAAIt5H,GAAG,CAAC,CAAC;EACzBu5H,kBAAkB,GAAG,IAAI36E,GAAG,CAAC,CAAC;EAC9B46E,WAAW,GAAG,IAAIx5H,GAAG,CAAC,CAAC;EACvBy5H,UAAU;EACVr3H,WAAWA,CAAC2pE,WAAW,EAAE3+B,QAAQ,EAAE;IACjC,IAAI,CAAC2+B,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAAC3+B,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACqsF,UAAU,GAAG1tD,WAAW,KAAK,IAAI,IAAIA,WAAW,CAAC0tD,UAAU,GAAG,IAAI,GAAGrsF,QAAQ,YAAYhJ,aAAa;EAC7G;EACA,OAAOs1F,YAAYA,CAAA,EAAG;IACpB,OAAO,IAAInyD,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC;EAC9B;EACA,OAAOuH,KAAKA,CAACv8D,QAAQ,EAAE;IACrB,MAAM4zD,KAAK,GAAGoB,KAAK,CAACmyD,YAAY,CAAC,CAAC;IAClCvzD,KAAK,CAACwzD,MAAM,CAACpnH,QAAQ,CAAC;IACtB,OAAO4zD,KAAK;EACd;EACAwzD,MAAMA,CAACC,WAAW,EAAE;IAClB,IAAIA,WAAW,YAAY3yF,QAAQ,EAAE;MACnC2yF,WAAW,CAACzyF,SAAS,CAAC3nC,OAAO,CAACuS,IAAI,IAAI,IAAI,CAACy1B,aAAa,CAACz1B,IAAI,CAAC,CAAC;MAC/D6nH,WAAW,CAACh0H,QAAQ,CAACpG,OAAO,CAACuS,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC;IACxD,CAAC,MAAM,IAAIw0H,WAAW,YAAYxzF,aAAa,EAAE;MAC/C,IAAIwzF,WAAW,CAACvzF,eAAe,KAAK,IAAI,EAAE;QACxC,IAAI,CAACmB,aAAa,CAACoyF,WAAW,CAACvzF,eAAe,CAAC;MACjD;MACAuzF,WAAW,CAACh0H,QAAQ,CAACpG,OAAO,CAACuS,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC;IACxD,CAAC,MAAM,IAAIw0H,WAAW,YAAYp0F,YAAY,EAAE;MAC9C,IAAI,CAACgC,aAAa,CAACoyF,WAAW,CAACn0F,IAAI,CAAC;MACpCm0F,WAAW,CAACh0F,gBAAgB,CAACpmC,OAAO,CAAC6qE,CAAC,IAAI,IAAI,CAAC7iC,aAAa,CAAC6iC,CAAC,CAAC,CAAC;MAChEuvD,WAAW,CAACh0H,QAAQ,CAACpG,OAAO,CAACuS,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC;IACxD,CAAC,MAAM,IAAIw0H,WAAW,YAAYt0F,eAAe,IAAIs0F,WAAW,YAAY7zF,iBAAiB,IAAI6zF,WAAW,YAAYx1F,aAAa,IAAIw1F,WAAW,YAAY11F,kBAAkB,IAAI01F,WAAW,YAAYh2F,wBAAwB,IAAIg2F,WAAW,YAAY71F,oBAAoB,IAAI61F,WAAW,YAAYvyF,OAAO,EAAE;MACtTuyF,WAAW,CAACh0H,QAAQ,CAACpG,OAAO,CAACuS,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC;IACxD,CAAC,MAAM,IAAI,EAAEw0H,WAAW,YAAY7xF,WAAW,CAAC,EAAE;MAChD6xF,WAAW,CAACp6H,OAAO,CAACuS,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC;IAC/C;EACF;EACAq9B,YAAYA,CAAC7lC,OAAO,EAAE;IACpB,IAAI,CAACi9H,gBAAgB,CAACj9H,OAAO,CAAC;EAChC;EACAwqC,aAAaA,CAAC70B,QAAQ,EAAE;IACtBA,QAAQ,CAAC6vB,UAAU,CAAC5iC,OAAO,CAACuS,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC;IACrDmN,QAAQ,CAAC8vB,UAAU,CAAC7iC,OAAO,CAACuS,IAAI,IAAI,IAAI,CAAC21B,cAAc,CAAC31B,IAAI,CAAC,CAAC;IAC9D,IAAI,CAAC+nH,gBAAgB,CAACvnH,QAAQ,CAAC;EACjC;EACAi1B,aAAaA,CAACzsB,QAAQ,EAAE;IACtB,IAAI,CAACg/G,YAAY,CAACh/G,QAAQ,CAAC;EAC7B;EACA2sB,cAAcA,CAAC3gB,SAAS,EAAE;IACxB,IAAI,CAACgzG,YAAY,CAAChzG,SAAS,CAAC;EAC9B;EACA+d,kBAAkBA,CAACuD,QAAQ,EAAE;IAC3B,IAAI,CAACyxF,gBAAgB,CAACzxF,QAAQ,CAAC;IAC/BA,QAAQ,CAACrzB,WAAW,EAAE5P,KAAK,CAAC,IAAI,CAAC;IACjCijC,QAAQ,CAAChE,OAAO,EAAEj/B,KAAK,CAAC,IAAI,CAAC;IAC7BijC,QAAQ,CAAC/D,KAAK,EAAEl/B,KAAK,CAAC,IAAI,CAAC;EAC7B;EACA0+B,6BAA6BA,CAACwE,KAAK,EAAE;IACnC,IAAI,CAACwxF,gBAAgB,CAACxxF,KAAK,CAAC;EAC9B;EACAnE,uBAAuBA,CAACmE,KAAK,EAAE;IAC7B,IAAI,CAACwxF,gBAAgB,CAACxxF,KAAK,CAAC;EAC9B;EACArE,yBAAyBA,CAACqE,KAAK,EAAE;IAC/B,IAAI,CAACwxF,gBAAgB,CAACxxF,KAAK,CAAC;EAC9B;EACAjD,gBAAgBA,CAACiD,KAAK,EAAE;IACtBA,KAAK,CAACpiC,KAAK,CAAC1G,OAAO,CAACuS,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC;EAC/C;EACAmgC,oBAAoBA,CAAC+C,KAAK,EAAE;IAC1B,IAAI,CAACwxF,gBAAgB,CAACxxF,KAAK,CAAC;EAC9B;EACAxC,iBAAiBA,CAACwC,KAAK,EAAE;IACvB,IAAI,CAACwxF,gBAAgB,CAACxxF,KAAK,CAAC;IAC5BA,KAAK,CAACzC,KAAK,EAAEzgC,KAAK,CAAC,IAAI,CAAC;EAC1B;EACA4gC,sBAAsBA,CAACsC,KAAK,EAAE;IAC5B,IAAI,CAACwxF,gBAAgB,CAACxxF,KAAK,CAAC;EAC9B;EACAnC,YAAYA,CAACmC,KAAK,EAAE;IAClBA,KAAK,CAACpC,QAAQ,CAAC1mC,OAAO,CAACuS,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC;EAClD;EACAkhC,kBAAkBA,CAACgC,KAAK,EAAE;IACxB,IAAI,CAACwxF,gBAAgB,CAACxxF,KAAK,CAAC;EAC9B;EACAhB,YAAYA,CAACjY,OAAO,EAAE;IACpB,IAAI,CAACyqG,gBAAgB,CAACzqG,OAAO,CAAC;EAChC;EACAsX,mBAAmBA,CAACgC,IAAI,EAAE;IACxB,IAAI,CAACoxF,YAAY,CAACpxF,IAAI,CAAC;EACzB;EACA7B,cAAcA,CAAC0B,SAAS,EAAE;IACxB,IAAI,CAACqxF,gBAAgB,CAACrxF,SAAS,CAAC;EAClC;EACAxB,cAAcA,CAACyB,SAAS,EAAE;IACxBA,SAAS,CAACpG,UAAU,CAAC7iC,OAAO,CAAC9B,OAAO,IAAI,IAAI,CAACgqC,cAAc,CAAChqC,OAAO,CAAC,CAAC;EACvE;EACA6jC,mBAAmBA,CAAChjC,IAAI,EAAE,CAAC;EAC3BujC,eAAeA,CAACH,KAAK,EAAE,CAAC;EACxBT,cAAcA,CAAC17B,IAAI,EAAE,CAAC;EACtBD,SAASA,CAACC,IAAI,EAAE,CAAC;EACjB47B,kBAAkBA,CAAC7iC,IAAI,EAAE,CAAC;EAC1BuH,QAAQA,CAACC,GAAG,EAAE,CAAC;EACf+8B,oBAAoBA,CAAC4F,OAAO,EAAE,CAAC;EAC/BlC,iBAAiBA,CAAC8B,KAAK,EAAE,CAAC;EAC1BuxF,gBAAgBA,CAAC9nH,IAAI,EAAE;IACrBA,IAAI,CAACqwB,UAAU,CAAC5iC,OAAO,CAAC9B,OAAO,IAAIA,OAAO,CAAC0H,KAAK,CAAC,IAAI,CAAC,CAAC;IACvD2M,IAAI,CAACswB,UAAU,CAAC7iC,OAAO,CAAC9B,OAAO,IAAI,IAAI,CAACgqC,cAAc,CAAChqC,OAAO,CAAC,CAAC;IAChEqU,IAAI,CAACnM,QAAQ,CAACpG,OAAO,CAAC9B,OAAO,IAAIA,OAAO,CAAC0H,KAAK,CAAC,IAAI,CAAC,CAAC;IACrD,IAAI,CAACm0H,kBAAkB,CAAC54E,GAAG,CAAC5uC,IAAI,CAAC;EACnC;EACAgoH,YAAYA,CAACC,KAAK,EAAE;IAClB,IAAI,CAAC,IAAI,CAACV,aAAa,CAAC72H,GAAG,CAACu3H,KAAK,CAAC56H,IAAI,CAAC,EAAE;MACvC,IAAI,CAACk6H,aAAa,CAACh4H,GAAG,CAAC04H,KAAK,CAAC56H,IAAI,EAAE46H,KAAK,CAAC;IAC3C;EACF;EACAC,MAAMA,CAAC76H,IAAI,EAAE;IACX,IAAI,IAAI,CAACk6H,aAAa,CAAC72H,GAAG,CAACrD,IAAI,CAAC,EAAE;MAChC,OAAO,IAAI,CAACk6H,aAAa,CAACj4H,GAAG,CAACjC,IAAI,CAAC;IACrC,CAAC,MAAM,IAAI,IAAI,CAAC2sE,WAAW,KAAK,IAAI,EAAE;MACpC,OAAO,IAAI,CAACA,WAAW,CAACkuD,MAAM,CAAC76H,IAAI,CAAC;IACtC,CAAC,MAAM;MACL,OAAO,IAAI;IACb;EACF;EACA86H,aAAaA,CAACnoH,IAAI,EAAE;IAClB,MAAM3U,GAAG,GAAG,IAAI,CAACo8H,WAAW,CAACn4H,GAAG,CAAC0Q,IAAI,CAAC;IACtC,IAAI3U,GAAG,KAAK+vB,SAAS,EAAE;MACrB,MAAM,IAAIrvB,KAAK,CAAC,oCAAoCiU,IAAI,YAAY,CAAC;IACvE;IACA,OAAO3U,GAAG;EACZ;EACA08H,gBAAgBA,CAAC/nH,IAAI,EAAE;IACrB,MAAMo0D,KAAK,GAAG,IAAIoB,KAAK,CAAC,IAAI,EAAEx1D,IAAI,CAAC;IACnCo0D,KAAK,CAACwzD,MAAM,CAAC5nH,IAAI,CAAC;IAClB,IAAI,CAACynH,WAAW,CAACl4H,GAAG,CAACyQ,IAAI,EAAEo0D,KAAK,CAAC;EACnC;AACF;AACA,MAAM+yD,eAAe,CAAC;EACpBT,gBAAgB;EAChBr2F,UAAU;EACVs2F,eAAe;EACfC,iBAAiB;EACjB1wF,QAAQ;EACR5F,UAAU;EACV83F,cAAc,GAAG,KAAK;EACtB/3H,WAAWA,CAACq2H,gBAAgB,EAAEr2F,UAAU,EAAEs2F,eAAe,EAAEC,iBAAiB,EAAE1wF,QAAQ,EAAE5F,UAAU,EAAE;IAClG,IAAI,CAACo2F,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACr2F,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACs2F,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,iBAAiB,GAAGA,iBAAiB;IAC1C,IAAI,CAAC1wF,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC5F,UAAU,GAAGA,UAAU;EAC9B;EACA,OAAOysC,KAAKA,CAACv8D,QAAQ,EAAEkmH,gBAAgB,EAAEr2F,UAAU,EAAEs2F,eAAe,EAAEC,iBAAiB,EAAE1wF,QAAQ,EAAE5F,UAAU,EAAE;IAC7G,MAAMzhC,OAAO,GAAG,IAAIs4H,eAAe,CAACT,gBAAgB,EAAEr2F,UAAU,EAAEs2F,eAAe,EAAEC,iBAAiB,EAAE1wF,QAAQ,EAAE5F,UAAU,CAAC;IAC3HzhC,OAAO,CAAC+4H,MAAM,CAACpnH,QAAQ,CAAC;EAC1B;EACAonH,MAAMA,CAACpnH,QAAQ,EAAE;IACfA,QAAQ,CAAC/S,OAAO,CAACuS,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC;EAC5C;EACAq9B,YAAYA,CAAC7lC,OAAO,EAAE;IACpB,IAAI,CAACw9H,sBAAsB,CAACx9H,OAAO,CAAC;EACtC;EACAwqC,aAAaA,CAAC70B,QAAQ,EAAE;IACtB,IAAI,CAAC6nH,sBAAsB,CAAC7nH,QAAQ,CAAC;EACvC;EACAuyB,kBAAkBA,CAACuD,QAAQ,EAAE;IAC3B,MAAMgyF,eAAe,GAAG,IAAI,CAACF,cAAc;IAC3C,IAAI,CAACA,cAAc,GAAG,IAAI;IAC1B9xF,QAAQ,CAACziC,QAAQ,CAACpG,OAAO,CAACqG,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC;IACrD,IAAI,CAAC+0H,cAAc,GAAGE,eAAe;IACrChyF,QAAQ,CAACrzB,WAAW,EAAE5P,KAAK,CAAC,IAAI,CAAC;IACjCijC,QAAQ,CAAChE,OAAO,EAAEj/B,KAAK,CAAC,IAAI,CAAC;IAC7BijC,QAAQ,CAAC/D,KAAK,EAAEl/B,KAAK,CAAC,IAAI,CAAC;EAC7B;EACA0+B,6BAA6BA,CAACwE,KAAK,EAAE;IACnCA,KAAK,CAAC1iC,QAAQ,CAACpG,OAAO,CAACqG,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC;EACpD;EACA++B,uBAAuBA,CAACmE,KAAK,EAAE;IAC7BA,KAAK,CAAC1iC,QAAQ,CAACpG,OAAO,CAACqG,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC;EACpD;EACA6+B,yBAAyBA,CAACqE,KAAK,EAAE;IAC/BA,KAAK,CAAC1iC,QAAQ,CAACpG,OAAO,CAACqG,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC;EACpD;EACAigC,gBAAgBA,CAACiD,KAAK,EAAE;IACtBA,KAAK,CAACpiC,KAAK,CAAC1G,OAAO,CAACuS,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC;EAC/C;EACAmgC,oBAAoBA,CAAC+C,KAAK,EAAE;IAC1BA,KAAK,CAAC1iC,QAAQ,CAACpG,OAAO,CAACuS,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC;EAClD;EACA0gC,iBAAiBA,CAACwC,KAAK,EAAE;IACvBA,KAAK,CAAC7C,IAAI,CAACrgC,KAAK,CAAC,IAAI,CAAC;IACtBkjC,KAAK,CAAC1C,gBAAgB,CAACpmC,OAAO,CAAC6qE,CAAC,IAAIA,CAAC,CAACjlE,KAAK,CAAC,IAAI,CAAC,CAAC;IAClDkjC,KAAK,CAAC1iC,QAAQ,CAACpG,OAAO,CAACuS,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC;IAChDkjC,KAAK,CAACzC,KAAK,EAAEzgC,KAAK,CAAC,IAAI,CAAC;EAC1B;EACA4gC,sBAAsBA,CAACsC,KAAK,EAAE;IAC5BA,KAAK,CAAC1iC,QAAQ,CAACpG,OAAO,CAACuS,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC;EAClD;EACA+gC,YAAYA,CAACmC,KAAK,EAAE;IAClBA,KAAK,CAACpC,QAAQ,CAAC1mC,OAAO,CAACuS,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC;EAClD;EACAkhC,kBAAkBA,CAACgC,KAAK,EAAE;IACxBA,KAAK,CAACjC,eAAe,EAAEjhC,KAAK,CAAC,IAAI,CAAC;IAClCkjC,KAAK,CAAC1iC,QAAQ,CAACpG,OAAO,CAACuS,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC;EAClD;EACAkiC,YAAYA,CAACjY,OAAO,EAAE;IACpBA,OAAO,CAACzpB,QAAQ,CAACpG,OAAO,CAACqG,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC;EACtD;EACA0hC,cAAcA,CAAC/0B,IAAI,EAAE;IACnB,IAAI,IAAI,CAAC0mH,gBAAgB,YAAYl2H,mBAAmB,EAAE;MACxD,MAAM+3H,gBAAgB,GAAG,IAAI,CAAC7B,gBAAgB,CAACh7H,KAAK,CAACsU,IAAI,CAAC80B,aAAa,CAAC;MACxE,IAAIyzF,gBAAgB,CAACh9H,MAAM,GAAG,CAAC,EAAE;QAC/B,IAAI,CAACi9H,qCAAqC,CAACxoH,IAAI,EAAEuoH,gBAAgB,CAAC;MACpE,CAAC,MAAM;QACL,IAAI,CAAC3B,iBAAiB,CAACh4E,GAAG,CAAC5uC,IAAI,CAAC80B,aAAa,CAAC;MAChD;IACF;IACA90B,IAAI,CAACqwB,UAAU,CAAC5iC,OAAO,CAACipC,SAAS,IAAIA,SAAS,CAACrjC,KAAK,CAAC,IAAI,CAAC,CAAC;IAC3D2M,IAAI,CAACnM,QAAQ,CAACpG,OAAO,CAACqG,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC;EACnD;EACA4hC,cAAcA,CAACj1B,IAAI,EAAE;IACnB,IAAI,IAAI,CAAC0mH,gBAAgB,YAAYl2H,mBAAmB,EAAE;MACxD,MAAM6/B,UAAU,GAAG,IAAI,CAACq2F,gBAAgB,CAACh7H,KAAK,CAACsU,IAAI,CAAC3S,IAAI,CAAC;MACzD,IAAIgjC,UAAU,CAAC9kC,MAAM,GAAG,CAAC,EAAE;QACzB,IAAI,CAACi9H,qCAAqC,CAACxoH,IAAI,EAAEqwB,UAAU,CAAC;MAC9D,CAAC,MAAM;QACL,IAAI,CAACu2F,iBAAiB,CAACh4E,GAAG,CAAC5uC,IAAI,CAAC3S,IAAI,CAAC;MACvC;IACF;EACF;EACAg7H,sBAAsBA,CAACroH,IAAI,EAAE;IAC3B,IAAI,IAAI,CAAC0mH,gBAAgB,YAAY94H,eAAe,EAAE;MACpD,MAAMyiC,UAAU,GAAG,EAAE;MACrB,MAAM5kC,WAAW,GAAGyzC,yBAAyB,CAACl/B,IAAI,CAAC;MACnD,IAAI,CAAC0mH,gBAAgB,CAACh7H,KAAK,CAACD,WAAW,EAAE,CAAC+iD,CAAC,EAAErjD,OAAO,KAAKklC,UAAU,CAAC7kC,IAAI,CAAC,GAAGL,OAAO,CAAC,CAAC;MACrF,IAAI,CAACs9H,uCAAuC,CAACzoH,IAAI,EAAEqwB,UAAU,CAAC;IAChE,CAAC,MAAM;MACLrwB,IAAI,CAACswB,UAAU,CAAC7iC,OAAO,CAAC82B,GAAG,IAAI;QAC7B,IAAIA,GAAG,CAACj3B,KAAK,CAAC2tB,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;UAC3B,IAAI,CAACqV,UAAU,CAAC/gC,GAAG,CAACg1B,GAAG,EAAEvkB,IAAI,CAAC;QAChC;MACF,CAAC,CAAC;IACJ;IACAA,IAAI,CAACqwB,UAAU,CAAC5iC,OAAO,CAACipC,SAAS,IAAIA,SAAS,CAACrjC,KAAK,CAAC,IAAI,CAAC,CAAC;IAC3D2M,IAAI,CAACnM,QAAQ,CAACpG,OAAO,CAACqG,KAAK,IAAIA,KAAK,CAACT,KAAK,CAAC,IAAI,CAAC,CAAC;EACnD;EACAq1H,sBAAsBA,CAAC1oH,IAAI,EAAEqwB,UAAU,EAAE;IACvC,IAAIA,UAAU,CAAC9kC,MAAM,GAAG,CAAC,EAAE;MACzB,IAAI,CAAC8kC,UAAU,CAAC9gC,GAAG,CAACyQ,IAAI,EAAEqwB,UAAU,CAAC;MACrC,IAAI,CAAC,IAAI,CAAC+3F,cAAc,EAAE;QACxB,IAAI,CAACzB,eAAe,CAACn7H,IAAI,CAAC,GAAG6kC,UAAU,CAAC;MAC1C;IACF;EACF;EACAm4F,qCAAqCA,CAACxoH,IAAI,EAAEqwB,UAAU,EAAE;IACtD,IAAIA,UAAU,CAAC9kC,MAAM,KAAK,CAAC,EAAE;MAC3B;IACF;IACA,IAAI,CAACm9H,sBAAsB,CAAC1oH,IAAI,EAAEqwB,UAAU,CAAC;IAC7C,MAAMs4F,UAAU,GAAGA,CAAC9jG,IAAI,EAAEv4B,SAAS,EAAEs8H,MAAM,KAAK;MAC9C,IAAI/jG,IAAI,CAAC+jG,MAAM,CAAC,CAAC/C,sBAAsB,CAACv5H,SAAS,CAACe,IAAI,CAAC,EAAE;QACvD,IAAI,CAAC6oC,QAAQ,CAAC3mC,GAAG,CAACjD,SAAS,EAAEu4B,IAAI,CAAC;MACpC;IACF,CAAC;IACD,KAAK,MAAM6R,SAAS,IAAIrG,UAAU,EAAE;MAClCrwB,IAAI,CAACmwB,MAAM,CAAC1iC,OAAO,CAAC8sB,KAAK,IAAIouG,UAAU,CAACjyF,SAAS,EAAEnc,KAAK,EAAE,QAAQ,CAAC,CAAC;MACpEva,IAAI,CAACkwB,UAAU,CAACziC,OAAO,CAACjB,IAAI,IAAIm8H,UAAU,CAACjyF,SAAS,EAAElqC,IAAI,EAAE,QAAQ,CAAC,CAAC;MACtEwT,IAAI,CAACowB,OAAO,CAAC3iC,OAAO,CAACy7G,MAAM,IAAIyf,UAAU,CAACjyF,SAAS,EAAEwyE,MAAM,EAAE,SAAS,CAAC,CAAC;IAC1E;IACAlpG,IAAI,CAACswB,UAAU,CAAC7iC,OAAO,CAAC82B,GAAG,IAAI,IAAI,CAAC+L,UAAU,CAAC/gC,GAAG,CAACg1B,GAAG,EAAE;MACtDmS,SAAS,EAAErG,UAAU,CAAC,CAAC,CAAC;MACxBrwB,IAAI,EAAEA;IACR,CAAC,CAAC,CAAC;EACL;EACAyoH,uCAAuCA,CAACzoH,IAAI,EAAEqwB,UAAU,EAAE;IACxD,IAAI,CAACq4F,sBAAsB,CAAC1oH,IAAI,EAAEqwB,UAAU,CAAC;IAC7CrwB,IAAI,CAACswB,UAAU,CAAC7iC,OAAO,CAAC82B,GAAG,IAAI;MAC7B,IAAIskG,SAAS,GAAG,IAAI;MACpB,IAAItkG,GAAG,CAACj3B,KAAK,CAAC2tB,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;QAC3B4tG,SAAS,GAAGx4F,UAAU,CAAC2O,IAAI,CAAC8pD,GAAG,IAAIA,GAAG,CAACggC,WAAW,CAAC,IAAI,IAAI;MAC7D,CAAC,MAAM;QACLD,SAAS,GAAGx4F,UAAU,CAAC2O,IAAI,CAAC8pD,GAAG,IAAIA,GAAG,CAAC23B,QAAQ,KAAK,IAAI,IAAI33B,GAAG,CAAC23B,QAAQ,CAACzjF,IAAI,CAAC1vC,KAAK,IAAIA,KAAK,KAAKi3B,GAAG,CAACj3B,KAAK,CAAC,CAAC,IAAI,IAAI;QACpH,IAAIu7H,SAAS,KAAK,IAAI,EAAE;UACtB;QACF;MACF;MACA,IAAIA,SAAS,KAAK,IAAI,EAAE;QACtB,IAAI,CAACv4F,UAAU,CAAC/gC,GAAG,CAACg1B,GAAG,EAAE;UACvBmS,SAAS,EAAEmyF,SAAS;UACpB7oH;QACF,CAAC,CAAC;MACJ,CAAC,MAAM;QACL,IAAI,CAACswB,UAAU,CAAC/gC,GAAG,CAACg1B,GAAG,EAAEvkB,IAAI,CAAC;MAChC;IACF,CAAC,CAAC;IACF,MAAM+oH,mBAAmB,GAAGA,CAACz8H,SAAS,EAAEs8H,MAAM,KAAK;MACjD,MAAM9/B,GAAG,GAAGz4D,UAAU,CAAC2O,IAAI,CAAC8pD,GAAG,IAAIA,GAAG,CAAC8/B,MAAM,CAAC,CAAC/C,sBAAsB,CAACv5H,SAAS,CAACe,IAAI,CAAC,CAAC;MACtF,MAAMwyF,OAAO,GAAGiJ,GAAG,KAAK1tE,SAAS,GAAG0tE,GAAG,GAAG9oF,IAAI;MAC9C,IAAI,CAACk2B,QAAQ,CAAC3mC,GAAG,CAACjD,SAAS,EAAEuzF,OAAO,CAAC;IACvC,CAAC;IACD7/E,IAAI,CAACmwB,MAAM,CAAC1iC,OAAO,CAAC8sB,KAAK,IAAIwuG,mBAAmB,CAACxuG,KAAK,EAAE,QAAQ,CAAC,CAAC;IAClEva,IAAI,CAACkwB,UAAU,CAACziC,OAAO,CAACjB,IAAI,IAAIu8H,mBAAmB,CAACv8H,IAAI,EAAE,QAAQ,CAAC,CAAC;IACpE,IAAIwT,IAAI,YAAYk1B,QAAQ,EAAE;MAC5Bl1B,IAAI,CAACm1B,aAAa,CAAC1nC,OAAO,CAACjB,IAAI,IAAIu8H,mBAAmB,CAACv8H,IAAI,EAAE,QAAQ,CAAC,CAAC;IACzE;IACAwT,IAAI,CAACowB,OAAO,CAAC3iC,OAAO,CAACy7G,MAAM,IAAI6f,mBAAmB,CAAC7f,MAAM,EAAE,SAAS,CAAC,CAAC;EACxE;EACAzzE,aAAaA,CAACzsB,QAAQ,EAAE,CAAC;EACzB2sB,cAAcA,CAAC3gB,SAAS,EAAE,CAAC;EAC3Bqa,kBAAkBA,CAAC/iC,SAAS,EAAE,CAAC;EAC/BkjC,mBAAmBA,CAACljC,SAAS,EAAE,CAAC;EAChCyjC,eAAeA,CAACzjC,SAAS,EAAE,CAAC;EAC5B08H,0BAA0BA,CAAChpH,IAAI,EAAE,CAAC;EAClCxM,SAASA,CAACC,IAAI,EAAE,CAAC;EACjB07B,cAAcA,CAAC17B,IAAI,EAAE,CAAC;EACtBM,QAAQA,CAACC,GAAG,EAAE,CAAC;EACf+8B,oBAAoBA,CAAC4F,OAAO,EAAE,CAAC;EAC/BlC,iBAAiBA,CAAC8B,KAAK,EAAE,CAAC;EAC1B3B,mBAAmBA,CAACgC,IAAI,EAAE,CAAC;AAC7B;AACA,MAAMwwF,cAAc,SAAS/B,2BAA2B,CAAC;EACvDnvF,QAAQ;EACR4wF,OAAO;EACPE,SAAS;EACTZ,UAAU;EACVa,WAAW;EACXF,YAAY;EACZ3yD,KAAK;EACL/4B,QAAQ;EACRiL,KAAK;EACL2iF,SAAS,GAAGjpH,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC;EACpChD,WAAWA,CAAC6lC,QAAQ,EAAE4wF,OAAO,EAAEE,SAAS,EAAEZ,UAAU,EAAEa,WAAW,EAAEF,YAAY,EAAE3yD,KAAK,EAAE/4B,QAAQ,EAAEiL,KAAK,EAAE;IACvG,KAAK,CAAC,CAAC;IACP,IAAI,CAACpQ,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC4wF,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACE,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACZ,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACa,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACF,YAAY,GAAGA,YAAY;IAChC,IAAI,CAAC3yD,KAAK,GAAGA,KAAK;IAClB,IAAI,CAAC/4B,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACiL,KAAK,GAAGA,KAAK;EACpB;EACA,OAAO+gF,cAAcA,CAACQ,WAAW,EAAEzzD,KAAK,EAAEhzD,WAAW,EAAE0lH,OAAO,EAAEC,YAAY,EAAEC,SAAS,EAAEZ,UAAU,EAAEa,WAAW,EAAE;IAChH,MAAMzmH,QAAQ,GAAGqnH,WAAW,YAAY3yF,QAAQ,GAAG2yF,WAAW,GAAG,IAAI;IACrE,MAAM/B,MAAM,GAAG,IAAIsB,cAAc,CAAChmH,WAAW,EAAE0lH,OAAO,EAAEE,SAAS,EAAEZ,UAAU,EAAEa,WAAW,EAAEF,YAAY,EAAE3yD,KAAK,EAAE5zD,QAAQ,EAAE,CAAC,CAAC;IAC7HslH,MAAM,CAAC8B,MAAM,CAACC,WAAW,CAAC;EAC5B;EACAD,MAAMA,CAACC,WAAW,EAAE;IAClB,IAAIA,WAAW,YAAY3yF,QAAQ,EAAE;MACnC2yF,WAAW,CAACzyF,SAAS,CAAC3nC,OAAO,CAAC,IAAI,CAACw7H,SAAS,CAAC;MAC7CpB,WAAW,CAACh0H,QAAQ,CAACpG,OAAO,CAAC,IAAI,CAACw7H,SAAS,CAAC;MAC5C,IAAI,CAAClC,YAAY,CAACx3H,GAAG,CAACs4H,WAAW,EAAE,IAAI,CAACvhF,KAAK,CAAC;IAChD,CAAC,MAAM,IAAIuhF,WAAW,YAAYxzF,aAAa,EAAE;MAC/C,IAAIwzF,WAAW,CAACvzF,eAAe,KAAK,IAAI,EAAE;QACxC,IAAI,CAAC20F,SAAS,CAACpB,WAAW,CAACvzF,eAAe,CAAC;MAC7C;MACAuzF,WAAW,CAACh0H,QAAQ,CAACpG,OAAO,CAAC,IAAI,CAACw7H,SAAS,CAAC;MAC5C,IAAI,CAAClC,YAAY,CAACx3H,GAAG,CAACs4H,WAAW,EAAE,IAAI,CAACvhF,KAAK,CAAC;IAChD,CAAC,MAAM,IAAIuhF,WAAW,YAAYp0F,YAAY,EAAE;MAC9C,IAAI,CAACw1F,SAAS,CAACpB,WAAW,CAACn0F,IAAI,CAAC;MAChCm0F,WAAW,CAACh0F,gBAAgB,CAACpmC,OAAO,CAAC6qE,CAAC,IAAI,IAAI,CAAC2wD,SAAS,CAAC3wD,CAAC,CAAC,CAAC;MAC5DuvD,WAAW,CAACl0F,OAAO,CAACtgC,KAAK,CAAC,IAAI,CAAC;MAC/Bw0H,WAAW,CAACh0H,QAAQ,CAACpG,OAAO,CAAC,IAAI,CAACw7H,SAAS,CAAC;MAC5C,IAAI,CAAClC,YAAY,CAACx3H,GAAG,CAACs4H,WAAW,EAAE,IAAI,CAACvhF,KAAK,CAAC;IAChD,CAAC,MAAM,IAAIuhF,WAAW,YAAYx1F,aAAa,EAAE;MAC/C,IAAI,IAAI,CAAC+hC,KAAK,CAAC/4B,QAAQ,KAAKwsF,WAAW,EAAE;QACvC,MAAM,IAAI97H,KAAK,CAAC,gEAAgE87H,WAAW,EAAE,CAAC;MAChG;MACA,IAAI,CAACZ,WAAW,CAACz7H,IAAI,CAAC,CAACq8H,WAAW,EAAE,IAAI,CAACzzD,KAAK,CAAC,CAAC;MAChDyzD,WAAW,CAACh0H,QAAQ,CAACpG,OAAO,CAACuS,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC;MACtD,IAAI,CAAC0zH,YAAY,CAACx3H,GAAG,CAACs4H,WAAW,EAAE,IAAI,CAACvhF,KAAK,CAAC;IAChD,CAAC,MAAM,IAAIuhF,WAAW,YAAYt0F,eAAe,IAAIs0F,WAAW,YAAY7zF,iBAAiB,IAAI6zF,WAAW,YAAY11F,kBAAkB,IAAI01F,WAAW,YAAYh2F,wBAAwB,IAAIg2F,WAAW,YAAY71F,oBAAoB,IAAI61F,WAAW,YAAYvyF,OAAO,EAAE;MAC9QuyF,WAAW,CAACh0H,QAAQ,CAACpG,OAAO,CAACuS,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC;MACtD,IAAI,CAAC0zH,YAAY,CAACx3H,GAAG,CAACs4H,WAAW,EAAE,IAAI,CAACvhF,KAAK,CAAC;IAChD,CAAC,MAAM,IAAIuhF,WAAW,YAAY7xF,WAAW,EAAE;MAC7C,IAAI,CAAC+wF,YAAY,CAACx3H,GAAG,CAACs4H,WAAW,EAAE,CAAC,CAAC;IACvC,CAAC,MAAM;MACLA,WAAW,CAACp6H,OAAO,CAAC,IAAI,CAACw7H,SAAS,CAAC;IACrC;EACF;EACA5zF,aAAaA,CAAC70B,QAAQ,EAAE;IACtBA,QAAQ,CAAC2vB,MAAM,CAAC1iC,OAAO,CAAC,IAAI,CAACw7H,SAAS,CAAC;IACvCzoH,QAAQ,CAAC4vB,OAAO,CAAC3iC,OAAO,CAAC,IAAI,CAACw7H,SAAS,CAAC;IACxCzoH,QAAQ,CAAC6vB,UAAU,CAAC5iC,OAAO,CAAC,IAAI,CAACw7H,SAAS,CAAC;IAC3CzoH,QAAQ,CAAC20B,aAAa,CAAC1nC,OAAO,CAAC,IAAI,CAACw7H,SAAS,CAAC;IAC9CzoH,QAAQ,CAAC8vB,UAAU,CAAC7iC,OAAO,CAAC,IAAI,CAACw7H,SAAS,CAAC;IAC3C,IAAI,CAAClB,gBAAgB,CAACvnH,QAAQ,CAAC;EACjC;EACAi1B,aAAaA,CAACzsB,QAAQ,EAAE;IACtB,IAAI,IAAI,CAACqyB,QAAQ,KAAK,IAAI,EAAE;MAC1B,IAAI,CAACyrF,OAAO,CAACv3H,GAAG,CAACyZ,QAAQ,EAAE,IAAI,CAACqyB,QAAQ,CAAC;IAC3C;EACF;EACA1F,cAAcA,CAAC3gB,SAAS,EAAE;IACxB,IAAI,IAAI,CAACqmB,QAAQ,KAAK,IAAI,EAAE;MAC1B,IAAI,CAACyrF,OAAO,CAACv3H,GAAG,CAACylB,SAAS,EAAE,IAAI,CAACqmB,QAAQ,CAAC;IAC5C;EACF;EACAtI,kBAAkBA,CAACuD,QAAQ,EAAE;IAC3B,IAAI,CAACyxF,gBAAgB,CAACzxF,QAAQ,CAAC;IAC/BA,QAAQ,CAAC7D,QAAQ,CAACy1E,IAAI,EAAE56G,KAAK,CAAC+F,KAAK,CAAC,IAAI,CAAC;IACzCijC,QAAQ,CAAC5D,gBAAgB,CAACw1E,IAAI,EAAE56G,KAAK,CAAC+F,KAAK,CAAC,IAAI,CAAC;IACjDijC,QAAQ,CAAC3D,eAAe,CAACu1E,IAAI,EAAE56G,KAAK,CAAC+F,KAAK,CAAC,IAAI,CAAC;IAChDijC,QAAQ,CAAC3D,eAAe,CAACs1E,KAAK,EAAE50G,KAAK,CAAC,IAAI,CAAC;IAC3CijC,QAAQ,CAACrzB,WAAW,IAAI,IAAI,CAACgmH,SAAS,CAAC3yF,QAAQ,CAACrzB,WAAW,CAAC;IAC5DqzB,QAAQ,CAAChE,OAAO,IAAI,IAAI,CAAC22F,SAAS,CAAC3yF,QAAQ,CAAChE,OAAO,CAAC;IACpDgE,QAAQ,CAAC/D,KAAK,IAAI,IAAI,CAAC02F,SAAS,CAAC3yF,QAAQ,CAAC/D,KAAK,CAAC;EAClD;EACAR,6BAA6BA,CAACwE,KAAK,EAAE;IACnC,IAAI,CAACwxF,gBAAgB,CAACxxF,KAAK,CAAC;EAC9B;EACAnE,uBAAuBA,CAACmE,KAAK,EAAE;IAC7B,IAAI,CAACwxF,gBAAgB,CAACxxF,KAAK,CAAC;EAC9B;EACArE,yBAAyBA,CAACqE,KAAK,EAAE;IAC/B,IAAI,CAACwxF,gBAAgB,CAACxxF,KAAK,CAAC;EAC9B;EACA/C,oBAAoBA,CAAC+C,KAAK,EAAE;IAC1BA,KAAK,CAACliC,UAAU,EAAEhB,KAAK,CAAC,IAAI,CAAC;IAC7B,IAAI,CAAC00H,gBAAgB,CAACxxF,KAAK,CAAC;EAC9B;EACAxC,iBAAiBA,CAACwC,KAAK,EAAE;IACvBA,KAAK,CAACliC,UAAU,CAAChB,KAAK,CAAC,IAAI,CAAC;IAC5B,IAAI,CAAC00H,gBAAgB,CAACxxF,KAAK,CAAC;IAC5BA,KAAK,CAACzC,KAAK,EAAEzgC,KAAK,CAAC,IAAI,CAAC;EAC1B;EACA4gC,sBAAsBA,CAACsC,KAAK,EAAE;IAC5B,IAAI,CAACwxF,gBAAgB,CAACxxF,KAAK,CAAC;EAC9B;EACAhC,kBAAkBA,CAACgC,KAAK,EAAE;IACxBA,KAAK,CAACliC,UAAU,EAAEhB,KAAK,CAAC,IAAI,CAAC;IAC7B,IAAI,CAAC00H,gBAAgB,CAACxxF,KAAK,CAAC;EAC9B;EACAhB,YAAYA,CAACjY,OAAO,EAAE;IACpB,IAAI,CAACyqG,gBAAgB,CAACzqG,OAAO,CAAC;EAChC;EACAsX,mBAAmBA,CAACgC,IAAI,EAAE;IACxB,KAAK,CAAChC,mBAAmB,CAACgC,IAAI,CAAC;IAC/B,IAAI,IAAI,CAACyE,QAAQ,KAAK,IAAI,EAAE;MAC1B,IAAI,CAACyrF,OAAO,CAACv3H,GAAG,CAACqnC,IAAI,EAAE,IAAI,CAACyE,QAAQ,CAAC;IACvC;EACF;EACA5R,SAASA,CAAC/gB,GAAG,EAAEhV,OAAO,EAAE;IACtB,IAAI,CAACszH,SAAS,CAACp4E,GAAG,CAAClmC,GAAG,CAACrb,IAAI,CAAC;IAC5B,IAAI,CAAC,IAAI,CAAC+mE,KAAK,CAACszD,UAAU,EAAE;MAC1B,IAAI,CAACtB,UAAU,CAACx3E,GAAG,CAAClmC,GAAG,CAACrb,IAAI,CAAC;IAC/B;IACA,OAAO,KAAK,CAACo8B,SAAS,CAAC/gB,GAAG,EAAEhV,OAAO,CAAC;EACtC;EACAs1B,iBAAiBA,CAACtgB,GAAG,EAAEhV,OAAO,EAAE;IAC9B,IAAI,CAACw1H,QAAQ,CAACxgH,GAAG,EAAEA,GAAG,CAACrb,IAAI,CAAC;IAC5B,OAAO,KAAK,CAAC27B,iBAAiB,CAACtgB,GAAG,EAAEhV,OAAO,CAAC;EAC9C;EACAw1B,qBAAqBA,CAACxgB,GAAG,EAAEhV,OAAO,EAAE;IAClC,IAAI,CAACw1H,QAAQ,CAACxgH,GAAG,EAAEA,GAAG,CAACrb,IAAI,CAAC;IAC5B,OAAO,KAAK,CAAC67B,qBAAqB,CAACxgB,GAAG,EAAEhV,OAAO,CAAC;EAClD;EACAq0H,gBAAgBA,CAAC/nH,IAAI,EAAE;IACrB,MAAMmpH,UAAU,GAAG,IAAI,CAAC/0D,KAAK,CAAC+zD,aAAa,CAACnoH,IAAI,CAAC;IACjD,MAAM8lH,MAAM,GAAG,IAAIsB,cAAc,CAAC,IAAI,CAAClxF,QAAQ,EAAE,IAAI,CAAC4wF,OAAO,EAAE,IAAI,CAACE,SAAS,EAAE,IAAI,CAACZ,UAAU,EAAE,IAAI,CAACa,WAAW,EAAE,IAAI,CAACF,YAAY,EAAEoC,UAAU,EAAEnpH,IAAI,EAAE,IAAI,CAACsmC,KAAK,GAAG,CAAC,CAAC;IACtKw/E,MAAM,CAAC8B,MAAM,CAAC5nH,IAAI,CAAC;EACrB;EACAkpH,QAAQA,CAACxgH,GAAG,EAAErb,IAAI,EAAE;IAClB,IAAI,EAAEqb,GAAG,CAACtI,QAAQ,YAAYioB,gBAAgB,CAAC,IAAI3f,GAAG,CAACtI,QAAQ,YAAYmoB,YAAY,EAAE;MACvF;IACF;IACA,MAAMlD,MAAM,GAAG,IAAI,CAAC+uC,KAAK,CAAC8zD,MAAM,CAAC76H,IAAI,CAAC;IACtC,IAAIg4B,MAAM,KAAK,IAAI,EAAE;MACnB,IAAI,CAAC6Q,QAAQ,CAAC3mC,GAAG,CAACmZ,GAAG,EAAE2c,MAAM,CAAC;IAChC;EACF;AACF;AACA,MAAMiiG,aAAa,CAAC;EAClBjiG,MAAM;EACNgL,UAAU;EACVs2F,eAAe;EACfC,iBAAiB;EACjB1wF,QAAQ;EACR5F,UAAU;EACV84F,WAAW;EACXtC,OAAO;EACPC,YAAY;EACZF,kBAAkB;EAClBG,SAAS;EACTZ,UAAU;EACViD,cAAc;EACdC,cAAc;EACdj5H,WAAWA,CAACg1B,MAAM,EAAEgL,UAAU,EAAEs2F,eAAe,EAAEC,iBAAiB,EAAE1wF,QAAQ,EAAE5F,UAAU,EAAE84F,WAAW,EAAEtC,OAAO,EAAEC,YAAY,EAAEF,kBAAkB,EAAEG,SAAS,EAAEZ,UAAU,EAAEmD,WAAW,EAAE;IACpL,IAAI,CAAClkG,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACgL,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACs2F,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,iBAAiB,GAAGA,iBAAiB;IAC1C,IAAI,CAAC1wF,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC5F,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAC84F,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACtC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACF,kBAAkB,GAAGA,kBAAkB;IAC5C,IAAI,CAACG,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACZ,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACiD,cAAc,GAAGE,WAAW,CAAC75H,GAAG,CAAC/D,OAAO,IAAIA,OAAO,CAAC,CAAC,CAAC,CAAC;IAC5D,IAAI,CAAC29H,cAAc,GAAG,IAAIr7H,GAAG,CAACs7H,WAAW,CAAC;EAC5C;EACAC,kBAAkBA,CAACxpH,IAAI,EAAE;IACvB,OAAO,IAAI,CAAC6mH,kBAAkB,CAACv3H,GAAG,CAAC0Q,IAAI,CAAC,IAAI,IAAI6sC,GAAG,CAAC,CAAC;EACvD;EACA48E,mBAAmBA,CAACzpH,IAAI,EAAE;IACxB,OAAO,IAAI,CAACqwB,UAAU,CAAC/gC,GAAG,CAAC0Q,IAAI,CAAC,IAAI,IAAI;EAC1C;EACA0pH,kBAAkBA,CAACnlG,GAAG,EAAE;IACtB,OAAO,IAAI,CAAC+L,UAAU,CAAChhC,GAAG,CAACi1B,GAAG,CAAC,IAAI,IAAI;EACzC;EACAolG,oBAAoBA,CAAC9pC,OAAO,EAAE;IAC5B,OAAO,IAAI,CAAC3pD,QAAQ,CAAC5mC,GAAG,CAACuwF,OAAO,CAAC,IAAI,IAAI;EAC3C;EACA+pC,mBAAmBA,CAACjqH,IAAI,EAAE;IACxB,OAAO,IAAI,CAACypH,WAAW,CAAC95H,GAAG,CAACqQ,IAAI,CAAC,IAAI,IAAI;EAC3C;EACAkqH,yBAAyBA,CAACC,MAAM,EAAE;IAChC,OAAO,IAAI,CAAChD,OAAO,CAACx3H,GAAG,CAACw6H,MAAM,CAAC,IAAI,IAAI;EACzC;EACAC,eAAeA,CAAC/pH,IAAI,EAAE;IACpB,OAAO,IAAI,CAAC+mH,YAAY,CAACz3H,GAAG,CAAC0Q,IAAI,CAAC,IAAI,CAAC;EACzC;EACAmmH,iBAAiBA,CAAA,EAAG;IAClB,MAAM52H,GAAG,GAAG,IAAIs9C,GAAG,CAAC,CAAC;IACrB,IAAI,CAACxc,UAAU,CAAC5iC,OAAO,CAACu8H,IAAI,IAAIA,IAAI,CAACv8H,OAAO,CAACq7F,GAAG,IAAIv5F,GAAG,CAACq/C,GAAG,CAACk6C,GAAG,CAAC,CAAC,CAAC;IAClE,OAAOhkF,KAAK,CAACmZ,IAAI,CAAC1uB,GAAG,CAACia,MAAM,CAAC,CAAC,CAAC;EACjC;EACAy8G,wBAAwBA,CAAA,EAAG;IACzB,MAAM12H,GAAG,GAAG,IAAIs9C,GAAG,CAAC,IAAI,CAAC85E,eAAe,CAAC;IACzC,OAAO7hH,KAAK,CAACmZ,IAAI,CAAC1uB,GAAG,CAACia,MAAM,CAAC,CAAC,CAAC;EACjC;EACAi9G,YAAYA,CAAA,EAAG;IACb,OAAO3hH,KAAK,CAACmZ,IAAI,CAAC,IAAI,CAAC+oG,SAAS,CAAC;EACnC;EACAX,mBAAmBA,CAAA,EAAG;IACpB,OAAOvhH,KAAK,CAACmZ,IAAI,CAAC,IAAI,CAACmoG,UAAU,CAAC;EACpC;EACA6D,cAAcA,CAAA,EAAG;IACf,OAAO,IAAI,CAACZ,cAAc;EAC5B;EACAa,wBAAwBA,CAAC3zF,KAAK,EAAEI,OAAO,EAAE;IACvC,IAAI,EAAEA,OAAO,YAAYlF,0BAA0B,CAAC,IAAI,EAAEkF,OAAO,YAAYjF,uBAAuB,CAAC,IAAI,EAAEiF,OAAO,YAAYtF,oBAAoB,CAAC,EAAE;MACnJ,OAAO,IAAI;IACb;IACA,MAAMhkC,IAAI,GAAGspC,OAAO,CAAC3hB,SAAS;IAC9B,IAAI3nB,IAAI,KAAK,IAAI,EAAE;MACjB,IAAIg4B,MAAM,GAAG,IAAI;MACjB,IAAIkR,KAAK,CAACtzB,WAAW,KAAK,IAAI,EAAE;QAC9B,KAAK,MAAMnP,KAAK,IAAIyiC,KAAK,CAACtzB,WAAW,CAACpP,QAAQ,EAAE;UAC9C,IAAIC,KAAK,YAAY+6B,SAAS,EAAE;YAC9B;UACF;UACA,IAAIxJ,MAAM,KAAK,IAAI,EAAE;YACnB,OAAO,IAAI;UACb;UACA,IAAIvxB,KAAK,YAAYk8B,SAAS,EAAE;YAC9B3K,MAAM,GAAGvxB,KAAK;UAChB;QACF;MACF;MACA,OAAOuxB,MAAM;IACf;IACA,MAAM8kG,UAAU,GAAG,IAAI,CAACC,iBAAiB,CAAC7zF,KAAK,EAAElpC,IAAI,CAAC;IACtD,IAAI88H,UAAU,YAAYz0F,SAAS,IAAI,IAAI,CAACm0F,yBAAyB,CAACM,UAAU,CAAC,KAAK5zF,KAAK,EAAE;MAC3F,MAAMlR,MAAM,GAAG,IAAI,CAACqkG,kBAAkB,CAACS,UAAU,CAAC;MAClD,IAAI9kG,MAAM,KAAK,IAAI,EAAE;QACnB,OAAO,IAAI,CAACglG,wBAAwB,CAAChlG,MAAM,CAAC;MAC9C;IACF;IACA,IAAIkR,KAAK,CAACtzB,WAAW,KAAK,IAAI,EAAE;MAC9B,MAAMqnH,gBAAgB,GAAG,IAAI,CAACF,iBAAiB,CAAC7zF,KAAK,CAACtzB,WAAW,EAAE5V,IAAI,CAAC;MACxE,MAAMk9H,mBAAmB,GAAGD,gBAAgB,YAAY50F,SAAS,GAAG,IAAI,CAACg0F,kBAAkB,CAACY,gBAAgB,CAAC,GAAG,IAAI;MACpH,IAAIC,mBAAmB,KAAK,IAAI,EAAE;QAChC,OAAO,IAAI,CAACF,wBAAwB,CAACE,mBAAmB,CAAC;MAC3D;IACF;IACA,OAAO,IAAI;EACb;EACA7C,UAAUA,CAAC78H,OAAO,EAAE;IAClB,KAAK,MAAM0rC,KAAK,IAAI,IAAI,CAAC8yF,cAAc,EAAE;MACvC,IAAI,CAAC,IAAI,CAACC,cAAc,CAAC54H,GAAG,CAAC6lC,KAAK,CAAC,EAAE;QACnC;MACF;MACA,MAAMk4C,KAAK,GAAG,CAAC,IAAI,CAAC66C,cAAc,CAACh6H,GAAG,CAACinC,KAAK,CAAC,CAAC;MAC9C,OAAOk4C,KAAK,CAACljF,MAAM,GAAG,CAAC,EAAE;QACvB,MAAMI,OAAO,GAAG8iF,KAAK,CAAC/tD,GAAG,CAAC,CAAC;QAC3B,IAAI/0B,OAAO,CAAC67H,kBAAkB,CAAC92H,GAAG,CAAC7F,OAAO,CAAC,EAAE;UAC3C,OAAO,IAAI;QACb;QACA4jF,KAAK,CAACjjF,IAAI,CAAC,GAAGG,OAAO,CAAC87H,WAAW,CAACj+G,MAAM,CAAC,CAAC,CAAC;MAC7C;IACF;IACA,OAAO,KAAK;EACd;EACAghH,yBAAyBA,CAACn9H,IAAI,EAAE;IAC9B,OAAO,CAAC,IAAI,CAACu5H,iBAAiB,CAACl2H,GAAG,CAACrD,IAAI,CAAC;EAC1C;EACA+8H,iBAAiBA,CAAC/uF,QAAQ,EAAEhuC,IAAI,EAAE;IAChC,MAAMo9H,QAAQ,GAAG,IAAI,CAACjB,kBAAkB,CAACnuF,QAAQ,CAAC;IAClD,KAAK,MAAMqzC,MAAM,IAAI+7C,QAAQ,EAAE;MAC7B,IAAI/7C,MAAM,CAACrhF,IAAI,KAAKA,IAAI,EAAE;QACxB,OAAOqhF,MAAM;MACf;IACF;IACA,OAAO,IAAI;EACb;EACA27C,wBAAwBA,CAAChlG,MAAM,EAAE;IAC/B,IAAIA,MAAM,YAAY2K,SAAS,EAAE;MAC/B,OAAO3K,MAAM;IACf;IACA,IAAIA,MAAM,YAAY6P,QAAQ,IAAI7P,MAAM,CAACrlB,IAAI,YAAY60B,WAAW,IAAIxP,MAAM,CAACrlB,IAAI,YAAYg1B,WAAW,IAAI3P,MAAM,CAACrlB,IAAI,YAAYg2B,WAAW,EAAE;MAChJ,OAAO,IAAI;IACb;IACA,OAAO,IAAI,CAACq0F,wBAAwB,CAAChlG,MAAM,CAACrlB,IAAI,CAAC;EACnD;AACF;AACA,SAASknH,yBAAyBA,CAACwD,SAAS,EAAEC,gBAAgB,EAAE;EAC9D,MAAMC,SAAS,GAAG,IAAI38H,GAAG,CAAC,CAAC;EAC3B,SAAS48H,oBAAoBA,CAACz2D,KAAK,EAAE;IACnC,IAAIw2D,SAAS,CAACl6H,GAAG,CAAC0jE,KAAK,CAAC/4B,QAAQ,CAAC,EAAE;MACjC,OAAOuvF,SAAS,CAACt7H,GAAG,CAAC8kE,KAAK,CAAC/4B,QAAQ,CAAC;IACtC;IACA,MAAMyvF,eAAe,GAAG12D,KAAK,CAACmzD,aAAa;IAC3C,IAAIkD,QAAQ;IACZ,IAAIr2D,KAAK,CAAC4F,WAAW,KAAK,IAAI,EAAE;MAC9BywD,QAAQ,GAAG,IAAIx8H,GAAG,CAAC,CAAC,GAAG48H,oBAAoB,CAACz2D,KAAK,CAAC4F,WAAW,CAAC,EAAE,GAAG8wD,eAAe,CAAC,CAAC;IACtF,CAAC,MAAM;MACLL,QAAQ,GAAG,IAAIx8H,GAAG,CAAC68H,eAAe,CAAC;IACrC;IACAF,SAAS,CAACr7H,GAAG,CAAC6kE,KAAK,CAAC/4B,QAAQ,EAAEovF,QAAQ,CAAC;IACvC,OAAOA,QAAQ;EACjB;EACA,MAAMM,eAAe,GAAG,CAACL,SAAS,CAAC;EACnC,OAAOK,eAAe,CAACx/H,MAAM,GAAG,CAAC,EAAE;IACjC,MAAM6oE,KAAK,GAAG22D,eAAe,CAACrqG,GAAG,CAAC,CAAC;IACnC,KAAK,MAAMyoG,UAAU,IAAI/0D,KAAK,CAACqzD,WAAW,CAACj+G,MAAM,CAAC,CAAC,EAAE;MACnDuhH,eAAe,CAACv/H,IAAI,CAAC29H,UAAU,CAAC;IAClC;IACA0B,oBAAoB,CAACz2D,KAAK,CAAC;EAC7B;EACA,KAAK,MAAM,CAAC5zD,QAAQ,EAAEiqH,QAAQ,CAAC,IAAIG,SAAS,EAAE;IAC5CD,gBAAgB,CAACp7H,GAAG,CAACiR,QAAQ,EAAE,IAAIqsC,GAAG,CAAC49E,QAAQ,CAACjhH,MAAM,CAAC,CAAC,CAAC,CAAC;EAC5D;AACF;AAEA,MAAMwhH,cAAc,CAAC;AAErB,MAAMC,kBAAkB,CAAC;EACvBC,YAAY;EACZ/4H,aAAa,GAAGA,aAAa;EAC7B64H,cAAc,GAAGA,cAAc;EAC/BG,qBAAqB,GAAG,IAAIvoC,wBAAwB,CAAC,CAAC;EACtDvyF,WAAWA,CAAC66H,YAAY,GAAG,IAAI5iF,YAAY,CAAC,CAAC,EAAE;IAC7C,IAAI,CAAC4iF,YAAY,GAAGA,YAAY;EAClC;EACAE,WAAWA,CAACC,cAAc,EAAEC,YAAY,EAAEC,MAAM,EAAE;IAChD,MAAMh/E,QAAQ,GAAG;MACfl/C,IAAI,EAAEk+H,MAAM,CAACl+H,IAAI;MACjBiH,IAAI,EAAE4vB,aAAa,CAACqnG,MAAM,CAACj3H,IAAI,CAAC;MAChCkyB,iBAAiB,EAAE,CAAC;MACpBrB,IAAI,EAAE,IAAI;MACVsnB,QAAQ,EAAE8+E,MAAM,CAAC9+E,QAAQ;MACzBzwC,IAAI,EAAEuvH,MAAM,CAACvvH,IAAI;MACjB0wC,YAAY,EAAE6+E,MAAM,CAAC7+E;IACvB,CAAC;IACD,MAAMrhD,GAAG,GAAGihD,uBAAuB,CAACC,QAAQ,CAAC;IAC7C,OAAO,IAAI,CAACi/E,aAAa,CAACngI,GAAG,CAACgJ,UAAU,EAAEg3H,cAAc,EAAEC,YAAY,EAAE,EAAE,CAAC;EAC7E;EACAG,sBAAsBA,CAACJ,cAAc,EAAEC,YAAY,EAAEI,WAAW,EAAE;IAChE,MAAM7mG,IAAI,GAAG8mG,kCAAkC,CAACD,WAAW,CAAC;IAC5D,MAAMrgI,GAAG,GAAGihD,uBAAuB,CAACznB,IAAI,CAAC;IACzC,OAAO,IAAI,CAAC2mG,aAAa,CAACngI,GAAG,CAACgJ,UAAU,EAAEg3H,cAAc,EAAEC,YAAY,EAAE,EAAE,CAAC;EAC7E;EACA3rF,iBAAiBA,CAAC0rF,cAAc,EAAEC,YAAY,EAAEC,MAAM,EAAE;IACtD,MAAM;MACJl3H,UAAU;MACVmQ;IACF,CAAC,GAAGm7B,iBAAiB,CAAC;MACpBtyC,IAAI,EAAEk+H,MAAM,CAACl+H,IAAI;MACjBiH,IAAI,EAAE4vB,aAAa,CAACqnG,MAAM,CAACj3H,IAAI,CAAC;MAChCkyB,iBAAiB,EAAE+kG,MAAM,CAAC/kG,iBAAiB;MAC3C6Z,UAAU,EAAEurF,iBAAiB,CAACL,MAAM,CAAClrF,UAAU,CAAC;MAChDP,QAAQ,EAAE+rF,2BAA2B,CAACN,MAAM,EAAE,UAAU,CAAC;MACzDtrF,UAAU,EAAE6rF,cAAc,CAACP,MAAM,EAAE,YAAY,CAAC;MAChDrrF,QAAQ,EAAE2rF,2BAA2B,CAACN,MAAM,EAAE,UAAU,CAAC;MACzDprF,WAAW,EAAE0rF,2BAA2B,CAACN,MAAM,EAAE,aAAa,CAAC;MAC/DpmG,IAAI,EAAEomG,MAAM,CAACpmG,IAAI,EAAEz1B,GAAG,CAACq8H,2BAA2B;IACpD,CAAC,EAAE,IAAI,CAAC;IACR,OAAO,IAAI,CAACP,aAAa,CAACn3H,UAAU,EAAEg3H,cAAc,EAAEC,YAAY,EAAE9mH,UAAU,CAAC;EACjF;EACAwnH,4BAA4BA,CAACX,cAAc,EAAEC,YAAY,EAAEC,MAAM,EAAE;IACjE,MAAM;MACJl3H,UAAU;MACVmQ;IACF,CAAC,GAAGm7B,iBAAiB,CAAC;MACpBtyC,IAAI,EAAEk+H,MAAM,CAACj3H,IAAI,CAACjH,IAAI;MACtBiH,IAAI,EAAE4vB,aAAa,CAACqnG,MAAM,CAACj3H,IAAI,CAAC;MAChCkyB,iBAAiB,EAAE,CAAC;MACpB6Z,UAAU,EAAEurF,iBAAiB,CAACL,MAAM,CAAClrF,UAAU,CAAC;MAChDP,QAAQ,EAAE+rF,2BAA2B,CAACN,MAAM,EAAE,UAAU,CAAC;MACzDtrF,UAAU,EAAE6rF,cAAc,CAACP,MAAM,EAAE,YAAY,CAAC;MAChDrrF,QAAQ,EAAE2rF,2BAA2B,CAACN,MAAM,EAAE,UAAU,CAAC;MACzDprF,WAAW,EAAE0rF,2BAA2B,CAACN,MAAM,EAAE,aAAa,CAAC;MAC/DpmG,IAAI,EAAEomG,MAAM,CAACpmG,IAAI,EAAEz1B,GAAG,CAACu8H,kCAAkC;IAC3D,CAAC,EAAE,IAAI,CAAC;IACR,OAAO,IAAI,CAACT,aAAa,CAACn3H,UAAU,EAAEg3H,cAAc,EAAEC,YAAY,EAAE9mH,UAAU,CAAC;EACjF;EACAulC,eAAeA,CAACshF,cAAc,EAAEC,YAAY,EAAEC,MAAM,EAAE;IACpD,MAAM1mG,IAAI,GAAG;MACXx3B,IAAI,EAAEk+H,MAAM,CAACl+H,IAAI;MACjBiH,IAAI,EAAE4vB,aAAa,CAACqnG,MAAM,CAACj3H,IAAI,CAAC;MAChC21C,SAAS,EAAEshF,MAAM,CAACthF,SAAS,IAAIshF,MAAM,CAACthF,SAAS,CAAC1+C,MAAM,GAAG,CAAC,GAAG,IAAIwU,eAAe,CAACwrH,MAAM,CAACthF,SAAS,CAAC,GAAG,IAAI;MACzGC,OAAO,EAAEqhF,MAAM,CAACrhF,OAAO,CAACx6C,GAAG,CAAC/C,CAAC,IAAI,IAAIoT,eAAe,CAACpT,CAAC,CAAC;IACzD,CAAC;IACD,MAAMtB,GAAG,GAAG0+C,eAAe,CAACllB,IAAI,CAAC;IACjC,OAAO,IAAI,CAAC2mG,aAAa,CAACngI,GAAG,CAACgJ,UAAU,EAAEg3H,cAAc,EAAEC,YAAY,EAAE,EAAE,CAAC;EAC7E;EACAY,0BAA0BA,CAACb,cAAc,EAAEC,YAAY,EAAEI,WAAW,EAAE;IACpE,MAAM7mG,IAAI,GAAGsnG,sCAAsC,CAACT,WAAW,CAAC;IAChE,MAAMrgI,GAAG,GAAG0+C,eAAe,CAACllB,IAAI,CAAC;IACjC,OAAO,IAAI,CAAC2mG,aAAa,CAACngI,GAAG,CAACgJ,UAAU,EAAEg3H,cAAc,EAAEC,YAAY,EAAE,EAAE,CAAC;EAC7E;EACA/gF,eAAeA,CAAC8gF,cAAc,EAAEC,YAAY,EAAEC,MAAM,EAAE;IACpD,MAAM1mG,IAAI,GAAG;MACXiiB,IAAI,EAAEwD,sBAAsB,CAACE,MAAM;MACnCl2C,IAAI,EAAE4vB,aAAa,CAACqnG,MAAM,CAACj3H,IAAI,CAAC;MAChCm2C,SAAS,EAAE8gF,MAAM,CAAC9gF,SAAS,CAAC/6C,GAAG,CAACw0B,aAAa,CAAC;MAC9C2mB,YAAY,EAAE0gF,MAAM,CAAC1gF,YAAY,CAACn7C,GAAG,CAACw0B,aAAa,CAAC;MACpDsnB,sBAAsB,EAAE,IAAI;MAC5BtB,OAAO,EAAEqhF,MAAM,CAACrhF,OAAO,CAACx6C,GAAG,CAACw0B,aAAa,CAAC;MAC1CqnB,kBAAkB,EAAE,IAAI;MACxBT,OAAO,EAAEygF,MAAM,CAACzgF,OAAO,CAACp7C,GAAG,CAACw0B,aAAa,CAAC;MAC1CymB,iBAAiB,EAAEN,mBAAmB,CAACO,MAAM;MAC7CF,oBAAoB,EAAE,KAAK;MAC3BQ,OAAO,EAAEqgF,MAAM,CAACrgF,OAAO,GAAGqgF,MAAM,CAACrgF,OAAO,CAACx7C,GAAG,CAACw0B,aAAa,CAAC,GAAG,IAAI;MAClEzxB,EAAE,EAAE84H,MAAM,CAAC94H,EAAE,GAAG,IAAIsN,eAAe,CAACwrH,MAAM,CAAC94H,EAAE,CAAC,GAAG;IACnD,CAAC;IACD,MAAMpH,GAAG,GAAGk/C,eAAe,CAAC1lB,IAAI,CAAC;IACjC,OAAO,IAAI,CAAC2mG,aAAa,CAACngI,GAAG,CAACgJ,UAAU,EAAEg3H,cAAc,EAAEC,YAAY,EAAE,EAAE,CAAC;EAC7E;EACAc,0BAA0BA,CAACf,cAAc,EAAEC,YAAY,EAAEI,WAAW,EAAE;IACpE,MAAMr3H,UAAU,GAAG+2C,oCAAoC,CAACsgF,WAAW,CAAC;IACpE,OAAO,IAAI,CAACF,aAAa,CAACn3H,UAAU,EAAEg3H,cAAc,EAAEC,YAAY,EAAE,EAAE,CAAC;EACzE;EACAe,gBAAgBA,CAAChB,cAAc,EAAEC,YAAY,EAAEC,MAAM,EAAE;IACrD,MAAM1mG,IAAI,GAAGynG,gCAAgC,CAACf,MAAM,CAAC;IACrD,OAAO,IAAI,CAACgB,wBAAwB,CAAClB,cAAc,EAAEC,YAAY,EAAEzmG,IAAI,CAAC;EAC1E;EACA2nG,2BAA2BA,CAACnB,cAAc,EAAEC,YAAY,EAAEI,WAAW,EAAE;IACrE,MAAMlL,cAAc,GAAG,IAAI,CAACiM,qBAAqB,CAAC,WAAW,EAAEf,WAAW,CAACp3H,IAAI,CAACjH,IAAI,EAAEi+H,YAAY,CAAC;IACnG,MAAMzmG,IAAI,GAAG6nG,uCAAuC,CAAChB,WAAW,EAAElL,cAAc,CAAC;IACjF,OAAO,IAAI,CAAC+L,wBAAwB,CAAClB,cAAc,EAAEC,YAAY,EAAEzmG,IAAI,CAAC;EAC1E;EACA0nG,wBAAwBA,CAAClB,cAAc,EAAEC,YAAY,EAAEzmG,IAAI,EAAE;IAC3D,MAAM2+E,YAAY,GAAG,IAAIr4F,YAAY,CAAC,CAAC;IACvC,MAAMy4F,aAAa,GAAG6b,iBAAiB,CAAC,CAAC;IACzC,MAAMp0H,GAAG,GAAGg2H,4BAA4B,CAACx8F,IAAI,EAAE2+E,YAAY,EAAEI,aAAa,CAAC;IAC3E,OAAO,IAAI,CAAC4nB,aAAa,CAACngI,GAAG,CAACgJ,UAAU,EAAEg3H,cAAc,EAAEC,YAAY,EAAE9nB,YAAY,CAACh/F,UAAU,CAAC;EAClG;EACAmoH,gBAAgBA,CAACtB,cAAc,EAAEC,YAAY,EAAEC,MAAM,EAAE;IACrD,MAAM;MACJ/qH,QAAQ;MACRyP;IACF,CAAC,GAAG28G,gBAAgB,CAACrB,MAAM,CAAC/qH,QAAQ,EAAE+qH,MAAM,CAACl+H,IAAI,EAAEi+H,YAAY,EAAEC,MAAM,CAAChM,mBAAmB,EAAEnkG,SAAS,CAAC;IACvG,MAAMyJ,IAAI,GAAG;MACX,GAAG0mG,MAAM;MACT,GAAGe,gCAAgC,CAACf,MAAM,CAAC;MAC3CrgI,QAAQ,EAAEqgI,MAAM,CAACrgI,QAAQ,IAAI,IAAI,CAACigI,qBAAqB,CAACnnC,8BAA8B,CAAC,CAAC;MACxFxjF,QAAQ;MACRqqC,YAAY,EAAE0gF,MAAM,CAAC1gF,YAAY,CAACn7C,GAAG,CAACm9H,kCAAkC,CAAC;MACzE9K,uBAAuB,EAAE,CAAC;MAC1B9xG,KAAK;MACLoiD,MAAM,EAAE,CAAC,GAAGk5D,MAAM,CAACl5D,MAAM,EAAE,GAAG7xD,QAAQ,CAAC6xD,MAAM,CAAC;MAC9C6vD,aAAa,EAAEqJ,MAAM,CAACrJ,aAAa;MACnCQ,eAAe,EAAE6I,MAAM,CAAC7I,eAAe,IAAI,IAAI;MAC/CD,UAAU,EAAE8I,MAAM,CAAC9I,UAAU,IAAI,IAAI,GAAG,IAAI1iH,eAAe,CAACwrH,MAAM,CAAC9I,UAAU,CAAC,GAAG,IAAI;MACrF7B,aAAa,EAAE2K,MAAM,CAAC3K,aAAa,IAAI,IAAI,GAAG,IAAI7gH,eAAe,CAACwrH,MAAM,CAAC3K,aAAa,CAAC,GAAG,IAAI;MAC9F30D,uBAAuB,EAAE,EAAE;MAC3BC,kBAAkB,EAAE,IAAI;MACxBG,oBAAoB,EAAE;IACxB,CAAC;IACD,MAAMygE,sBAAsB,GAAG,SAASvB,MAAM,CAACl+H,IAAI,KAAK;IACxD,OAAO,IAAI,CAAC0/H,wBAAwB,CAAC1B,cAAc,EAAEyB,sBAAsB,EAAEjoG,IAAI,CAAC;EACpF;EACAmoG,2BAA2BA,CAAC3B,cAAc,EAAEC,YAAY,EAAEI,WAAW,EAAE;IACrE,MAAMlL,cAAc,GAAG,IAAI,CAACiM,qBAAqB,CAAC,WAAW,EAAEf,WAAW,CAACp3H,IAAI,CAACjH,IAAI,EAAEi+H,YAAY,CAAC;IACnG,MAAMzmG,IAAI,GAAGooG,uCAAuC,CAACvB,WAAW,EAAElL,cAAc,EAAE8K,YAAY,CAAC;IAC/F,OAAO,IAAI,CAACyB,wBAAwB,CAAC1B,cAAc,EAAEC,YAAY,EAAEzmG,IAAI,CAAC;EAC1E;EACAkoG,wBAAwBA,CAAC1B,cAAc,EAAEC,YAAY,EAAEzmG,IAAI,EAAE;IAC3D,MAAM2+E,YAAY,GAAG,IAAIr4F,YAAY,CAAC,CAAC;IACvC,MAAMy4F,aAAa,GAAG6b,iBAAiB,CAAC,CAAC;IACzC,MAAMp0H,GAAG,GAAGk2H,4BAA4B,CAAC18F,IAAI,EAAE2+E,YAAY,EAAEI,aAAa,CAAC;IAC3E,OAAO,IAAI,CAAC4nB,aAAa,CAACngI,GAAG,CAACgJ,UAAU,EAAEg3H,cAAc,EAAEC,YAAY,EAAE9nB,YAAY,CAACh/F,UAAU,CAAC;EAClG;EACA0oH,cAAcA,CAAC7B,cAAc,EAAEC,YAAY,EAAEzmG,IAAI,EAAE;IACjD,MAAMsoG,UAAU,GAAGvoG,sBAAsB,CAAC;MACxCv3B,IAAI,EAAEw3B,IAAI,CAACx3B,IAAI;MACfiH,IAAI,EAAE4vB,aAAa,CAACW,IAAI,CAACvwB,IAAI,CAAC;MAC9BkyB,iBAAiB,EAAE3B,IAAI,CAAC2B,iBAAiB;MACzCrB,IAAI,EAAEioG,gCAAgC,CAACvoG,IAAI,CAACM,IAAI,CAAC;MACjDE,MAAM,EAAER,IAAI,CAACQ;IACf,CAAC,CAAC;IACF,OAAO,IAAI,CAACmmG,aAAa,CAAC2B,UAAU,CAAC94H,UAAU,EAAEg3H,cAAc,EAAEC,YAAY,EAAE6B,UAAU,CAAC3oH,UAAU,CAAC;EACvG;EACA6oH,yBAAyBA,CAAChC,cAAc,EAAEC,YAAY,EAAEzmG,IAAI,EAAE;IAC5D,MAAMsoG,UAAU,GAAGvoG,sBAAsB,CAAC;MACxCv3B,IAAI,EAAEw3B,IAAI,CAACvwB,IAAI,CAACjH,IAAI;MACpBiH,IAAI,EAAE4vB,aAAa,CAACW,IAAI,CAACvwB,IAAI,CAAC;MAC9BkyB,iBAAiB,EAAE,CAAC;MACpBrB,IAAI,EAAErgB,KAAK,CAACC,OAAO,CAAC8f,IAAI,CAACM,IAAI,CAAC,GAAGN,IAAI,CAACM,IAAI,CAACz1B,GAAG,CAACu8H,kCAAkC,CAAC,GAAGpnG,IAAI,CAACM,IAAI;MAC9FE,MAAM,EAAER,IAAI,CAACQ;IACf,CAAC,CAAC;IACF,OAAO,IAAI,CAACmmG,aAAa,CAAC2B,UAAU,CAAC94H,UAAU,EAAEg3H,cAAc,EAAEC,YAAY,EAAE6B,UAAU,CAAC3oH,UAAU,CAAC;EACvG;EACAioH,qBAAqBA,CAAC3lF,IAAI,EAAEC,QAAQ,EAAErpB,SAAS,EAAE;IAC/C,OAAOmpB,mBAAmB,CAACC,IAAI,EAAEC,QAAQ,EAAErpB,SAAS,CAAC;EACvD;EACA8tG,aAAaA,CAACn/G,GAAG,EAAE3Y,OAAO,EAAEgqB,SAAS,EAAE4vG,aAAa,EAAE;IACpD,MAAM9oH,UAAU,GAAG,CAAC,GAAG8oH,aAAa,EAAE,IAAIroH,cAAc,CAAC,MAAM,EAAEoH,GAAG,EAAE+O,SAAS,EAAEhU,YAAY,CAACyiC,QAAQ,CAAC,CAAC;IACxG,MAAMx+C,GAAG,GAAG,IAAI,CAAC6/H,YAAY,CAAC3iF,kBAAkB,CAAC7qB,SAAS,EAAElZ,UAAU,EAAE,IAAI4lC,cAAc,CAAC12C,OAAO,CAAC,EAAE,IAAI,CAAC;IAC1G,OAAOrI,GAAG,CAAC,MAAM,CAAC;EACpB;AACF;AACA,SAASkiI,wBAAwBA,CAAChC,MAAM,EAAE;EACxC,OAAO;IACL,GAAGA,MAAM;IACT5sF,QAAQ,EAAE4sF,MAAM,CAAC5sF,QAAQ;IACzB6kC,SAAS,EAAEgqD,qBAAqB,CAACjC,MAAM,CAAC/nD,SAAS,CAAC;IAClDhN,IAAI,EAAE+0D,MAAM,CAAC/0D,IAAI,GAAG,IAAIz2D,eAAe,CAACwrH,MAAM,CAAC/0D,IAAI,CAAC,GAAG,IAAI;IAC3D2zC,MAAM,EAAEohB,MAAM,CAACphB,MAAM;IACrBC,uBAAuB,EAAEmhB,MAAM,CAACnhB;EAClC,CAAC;AACH;AACA,SAASqjB,iCAAiCA,CAAC/B,WAAW,EAAE;EACtD,OAAO;IACLhpC,YAAY,EAAEgpC,WAAW,CAAChpC,YAAY;IACtC39B,KAAK,EAAE2mE,WAAW,CAAC3mE,KAAK,IAAI,KAAK;IACjCye,SAAS,EAAEgqD,qBAAqB,CAAC9B,WAAW,CAACloD,SAAS,CAAC;IACvD0mC,WAAW,EAAEwhB,WAAW,CAACxhB,WAAW,IAAI,KAAK;IAC7C1zC,IAAI,EAAEk1D,WAAW,CAACl1D,IAAI,GAAG,IAAIz2D,eAAe,CAAC2rH,WAAW,CAACl1D,IAAI,CAAC,GAAG,IAAI;IACrE2zC,MAAM,EAAEuhB,WAAW,CAACvhB,MAAM,IAAI,KAAK;IACnCC,uBAAuB,EAAEshB,WAAW,CAACthB,uBAAuB,IAAI,IAAI;IACpEzrE,QAAQ,EAAE,CAAC,CAAC+sF,WAAW,CAAC/sF;EAC1B,CAAC;AACH;AACA,SAAS6uF,qBAAqBA,CAAChqD,SAAS,EAAE;EACxC,OAAO1+D,KAAK,CAACC,OAAO,CAACy+D,SAAS,CAAC,GAAGA,SAAS,GAAGh/C,+BAA+B,CAAC,IAAIzkB,eAAe,CAACyjE,SAAS,CAAC,EAAE,CAAC,CAAC;AAClH;AACA,SAAS8oD,gCAAgCA,CAACf,MAAM,EAAE;EAChD,MAAMmC,kBAAkB,GAAGC,gBAAgB,CAACpC,MAAM,CAACp7F,MAAM,IAAI,EAAE,CAAC;EAChE,MAAMy9F,mBAAmB,GAAGC,uBAAuB,CAACtC,MAAM,CAACn7F,OAAO,IAAI,EAAE,CAAC;EACzE,MAAM09F,YAAY,GAAGvC,MAAM,CAACuC,YAAY;EACxC,MAAMC,cAAc,GAAG,CAAC,CAAC;EACzB,MAAMC,eAAe,GAAG,CAAC,CAAC;EAC1B,KAAK,MAAMC,KAAK,IAAIH,YAAY,EAAE;IAChC,IAAIA,YAAY,CAACl1F,cAAc,CAACq1F,KAAK,CAAC,EAAE;MACtCH,YAAY,CAACG,KAAK,CAAC,CAACxgI,OAAO,CAACygI,GAAG,IAAI;QACjC,IAAIC,OAAO,CAACD,GAAG,CAAC,EAAE;UAChBH,cAAc,CAACE,KAAK,CAAC,GAAG;YACtB1vF,mBAAmB,EAAE2vF,GAAG,CAAC/sE,KAAK,IAAI8sE,KAAK;YACvC3vF,iBAAiB,EAAE2vF,KAAK;YACxBxK,QAAQ,EAAEyK,GAAG,CAACzK,QAAQ,IAAI,KAAK;YAC/B9kF,QAAQ,EAAE,CAAC,CAACuvF,GAAG,CAACvvF,QAAQ;YACxBD,iBAAiB,EAAEwvF,GAAG,CAACzvE,SAAS,IAAI,IAAI,GAAG,IAAI1+C,eAAe,CAACmuH,GAAG,CAACzvE,SAAS,CAAC,GAAG;UAClF,CAAC;QACH,CAAC,MAAM,IAAI2vE,QAAQ,CAACF,GAAG,CAAC,EAAE;UACxBF,eAAe,CAACC,KAAK,CAAC,GAAGC,GAAG,CAAC/sE,KAAK,IAAI8sE,KAAK;QAC7C;MACF,CAAC,CAAC;IACJ;EACF;EACA,MAAMpN,cAAc,GAAG0K,MAAM,CAAC1K,cAAc,EAAEt1H,MAAM,GAAGggI,MAAM,CAAC1K,cAAc,CAACnxH,GAAG,CAAC2+H,aAAa,IAAI;IAChG,OAAO,OAAOA,aAAa,KAAK,UAAU,GAAG;MAC3C33F,SAAS,EAAExS,aAAa,CAACmqG,aAAa,CAAC;MACvCl+F,MAAM,EAAE,IAAI;MACZC,OAAO,EAAE,IAAI;MACbu0F,kBAAkB,EAAE;IACtB,CAAC,GAAG;MACFjuF,SAAS,EAAExS,aAAa,CAACmqG,aAAa,CAAC33F,SAAS,CAAC;MACjDiuF,kBAAkB,EAAE,KAAK;MACzBx0F,MAAM,EAAEk+F,aAAa,CAACl+F,MAAM,GAAG09F,uBAAuB,CAACQ,aAAa,CAACl+F,MAAM,CAAC,GAAG,IAAI;MACnFC,OAAO,EAAEi+F,aAAa,CAACj+F,OAAO,GAAGy9F,uBAAuB,CAACQ,aAAa,CAACj+F,OAAO,CAAC,GAAG;IACpF,CAAC;EACH,CAAC,CAAC,GAAG,IAAI;EACT,OAAO;IACL,GAAGm7F,MAAM;IACT/kG,iBAAiB,EAAE,CAAC;IACpBg6F,cAAc,EAAE+K,MAAM,CAAC/K,cAAc;IACrClsH,IAAI,EAAE4vB,aAAa,CAACqnG,MAAM,CAACj3H,IAAI,CAAC;IAChC6wB,IAAI,EAAE,IAAI;IACV2B,IAAI,EAAE;MACJ,GAAGwnG,mBAAmB,CAAC/C,MAAM,CAACuC,YAAY,EAAEvC,MAAM,CAAC/K,cAAc,EAAE+K,MAAM,CAACzkG,IAAI;IAChF,CAAC;IACDqJ,MAAM,EAAE;MACN,GAAGu9F,kBAAkB;MACrB,GAAGK;IACL,CAAC;IACD39F,OAAO,EAAE;MACP,GAAGw9F,mBAAmB;MACtB,GAAGI;IACL,CAAC;IACDriB,OAAO,EAAE4f,MAAM,CAAC5f,OAAO,CAACj8G,GAAG,CAAC69H,wBAAwB,CAAC;IACrDtjF,SAAS,EAAEshF,MAAM,CAACthF,SAAS,IAAI,IAAI,GAAG,IAAIlqC,eAAe,CAACwrH,MAAM,CAACthF,SAAS,CAAC,GAAG,IAAI;IAClFihE,WAAW,EAAEqgB,MAAM,CAACrgB,WAAW,CAACx7G,GAAG,CAAC69H,wBAAwB,CAAC;IAC7D1M;EACF,CAAC;AACH;AACA,SAAS6L,uCAAuCA,CAAChB,WAAW,EAAElL,cAAc,EAAE;EAC5E,MAAMK,cAAc,GAAG6K,WAAW,CAAC7K,cAAc,EAAEt1H,MAAM,GAAGmgI,WAAW,CAAC7K,cAAc,CAACnxH,GAAG,CAACo5F,GAAG,KAAK;IACjGpyD,SAAS,EAAExS,aAAa,CAAC4kE,GAAG,CAACpyD,SAAS,CAAC;IACvCiuF,kBAAkB,EAAE,KAAK;IACzBx0F,MAAM,EAAE24D,GAAG,CAAC34D,MAAM,GAAGo+F,8BAA8B,CAACzlC,GAAG,CAAC34D,MAAM,CAAC,GAAG,IAAI;IACtEC,OAAO,EAAE04D,GAAG,CAAC14D,OAAO,GAAGm+F,8BAA8B,CAACzlC,GAAG,CAAC14D,OAAO,CAAC,GAAG;EACvE,CAAC,CAAC,CAAC,GAAG,IAAI;EACV,OAAO;IACL/iC,IAAI,EAAEq+H,WAAW,CAACp3H,IAAI,CAACjH,IAAI;IAC3BiH,IAAI,EAAE4vB,aAAa,CAACwnG,WAAW,CAACp3H,IAAI,CAAC;IACrCksH,cAAc;IACdt1H,QAAQ,EAAEwgI,WAAW,CAACxgI,QAAQ,IAAI,IAAI;IACtCilC,MAAM,EAAEu7F,WAAW,CAACv7F,MAAM,GAAGq+F,oCAAoC,CAAC9C,WAAW,CAACv7F,MAAM,CAAC,GAAG,CAAC,CAAC;IAC1FC,OAAO,EAAEs7F,WAAW,CAACt7F,OAAO,IAAI,CAAC,CAAC;IAClCtJ,IAAI,EAAE2nG,gCAAgC,CAAC/C,WAAW,CAAC5kG,IAAI,CAAC;IACxD6kF,OAAO,EAAE,CAAC+f,WAAW,CAAC/f,OAAO,IAAI,EAAE,EAAEj8G,GAAG,CAAC+9H,iCAAiC,CAAC;IAC3EviB,WAAW,EAAE,CAACwgB,WAAW,CAACxgB,WAAW,IAAI,EAAE,EAAEx7G,GAAG,CAAC+9H,iCAAiC,CAAC;IACnFxjF,SAAS,EAAEyhF,WAAW,CAACzhF,SAAS,KAAK7uB,SAAS,GAAG,IAAIrb,eAAe,CAAC2rH,WAAW,CAACzhF,SAAS,CAAC,GAAG,IAAI;IAClGw2E,QAAQ,EAAEiL,WAAW,CAACjL,QAAQ,IAAI,IAAI;IACtCM,eAAe,EAAE2K,WAAW,CAAC3K,eAAe,IAAI,KAAK;IACrDC,SAAS,EAAE;MACTC,aAAa,EAAEyK,WAAW,CAACzK,aAAa,IAAI;IAC9C,CAAC;IACD97F,IAAI,EAAE,IAAI;IACVqB,iBAAiB,EAAE,CAAC;IACpBkmB,YAAY,EAAEg/E,WAAW,CAACh/E,YAAY,IAAIjwB,iCAAiC,CAACivG,WAAW,CAAChvG,OAAO,CAAC;IAChGiiB,QAAQ,EAAE+sF,WAAW,CAAC/sF,QAAQ,IAAI,KAAK;IACvCkiF;EACF,CAAC;AACH;AACA,SAAS4N,gCAAgCA,CAAC3nG,IAAI,GAAG,CAAC,CAAC,EAAE;EACnD,OAAO;IACLoJ,UAAU,EAAEw+F,gCAAgC,CAAC5nG,IAAI,CAACoJ,UAAU,IAAI,CAAC,CAAC,CAAC;IACnEiG,SAAS,EAAErP,IAAI,CAACqP,SAAS,IAAI,CAAC,CAAC;IAC/BgtD,UAAU,EAAEr8D,IAAI,CAACq8D,UAAU,IAAI,CAAC,CAAC;IACjCygC,iBAAiB,EAAE;MACjBE,SAAS,EAAEh9F,IAAI,CAAC6nG,cAAc;MAC9B9K,SAAS,EAAE/8F,IAAI,CAAC8nG;IAClB;EACF,CAAC;AACH;AACA,SAASL,8BAA8BA,CAAC97D,KAAK,EAAE;EAC7C,IAAIhmE,MAAM,GAAG,IAAI;EACjB,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8lE,KAAK,CAAClnE,MAAM,EAAEoB,CAAC,IAAI,CAAC,EAAE;IACxCF,MAAM,GAAGA,MAAM,IAAI,CAAC,CAAC;IACrBA,MAAM,CAACgmE,KAAK,CAAC9lE,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG8lE,KAAK,CAAC9lE,CAAC,CAAC;EACjC;EACA,OAAOF,MAAM;AACf;AACA,SAASiiI,gCAAgCA,CAACpzD,GAAG,EAAE;EAC7C,MAAM7uE,MAAM,GAAG,CAAC,CAAC;EACjB,KAAK,MAAMmP,GAAG,IAAI7J,MAAM,CAACmC,IAAI,CAAConE,GAAG,CAAC,EAAE;IAClC7uE,MAAM,CAACmP,GAAG,CAAC,GAAG,IAAImE,eAAe,CAACu7D,GAAG,CAAC1/D,GAAG,CAAC,CAAC;EAC7C;EACA,OAAOnP,MAAM;AACf;AACA,SAASwgI,uCAAuCA,CAACr2F,IAAI,EAAE4pF,cAAc,EAAE8K,YAAY,EAAE;EACnF,MAAM;IACJ9qH,QAAQ;IACRyP;EACF,CAAC,GAAG28G,gBAAgB,CAACh2F,IAAI,CAACp2B,QAAQ,EAAEo2B,IAAI,CAACtiC,IAAI,CAACjH,IAAI,EAAEi+H,YAAY,EAAE10F,IAAI,CAAC2oF,mBAAmB,IAAI,KAAK,EAAE3oF,IAAI,CAACi4F,sBAAsB,CAAC;EACjI,MAAMhkF,YAAY,GAAG,EAAE;EACvB,IAAIjU,IAAI,CAACkuF,YAAY,EAAE;IACrB,KAAK,MAAMgK,QAAQ,IAAIl4F,IAAI,CAACkuF,YAAY,EAAE;MACxC,QAAQgK,QAAQ,CAAChoF,IAAI;QACnB,KAAK,WAAW;QAChB,KAAK,WAAW;UACd+D,YAAY,CAACr/C,IAAI,CAACujI,qCAAqC,CAACD,QAAQ,CAAC,CAAC;UAClE;QACF,KAAK,MAAM;UACTjkF,YAAY,CAACr/C,IAAI,CAACwjI,gCAAgC,CAACF,QAAQ,CAAC,CAAC;UAC7D;MACJ;IACF;EACF,CAAC,MAAM,IAAIl4F,IAAI,CAACq4F,UAAU,IAAIr4F,IAAI,CAACvG,UAAU,IAAIuG,IAAI,CAAC4vF,KAAK,EAAE;IAC3D5vF,IAAI,CAACq4F,UAAU,IAAIpkF,YAAY,CAACr/C,IAAI,CAAC,GAAGorC,IAAI,CAACq4F,UAAU,CAACv/H,GAAG,CAACo5F,GAAG,IAAIimC,qCAAqC,CAACjmC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC;IACrHlyD,IAAI,CAACvG,UAAU,IAAIwa,YAAY,CAACr/C,IAAI,CAAC,GAAGorC,IAAI,CAACvG,UAAU,CAAC3gC,GAAG,CAACo5F,GAAG,IAAIimC,qCAAqC,CAACjmC,GAAG,CAAC,CAAC,CAAC;IAC/GlyD,IAAI,CAAC4vF,KAAK,IAAI37E,YAAY,CAACr/C,IAAI,CAAC,GAAG0jI,wBAAwB,CAACt4F,IAAI,CAAC4vF,KAAK,CAAC,CAAC;EAC1E;EACA,MAAM5E,wBAAwB,GAAG/2E,YAAY,CAAC7N,IAAI,CAAC,CAAC;IAClD8J;EACF,CAAC,KAAKA,IAAI,KAAKz0C,wBAAwB,CAACo1B,SAAS,IAAIqf,IAAI,KAAKz0C,wBAAwB,CAACq1B,QAAQ,CAAC;EAChG,OAAO;IACL,GAAGglG,uCAAuC,CAAC91F,IAAI,EAAE4pF,cAAc,CAAC;IAChEhgH,QAAQ;IACR6xD,MAAM,EAAEz7B,IAAI,CAACy7B,MAAM,IAAI,EAAE;IACzBxnB,YAAY;IACZ+1E,aAAa,EAAEhqF,IAAI,CAACgqF,aAAa,KAAKxlG,SAAS,GAAG,IAAIrb,eAAe,CAAC62B,IAAI,CAACgqF,aAAa,CAAC,GAAG,IAAI;IAChG6B,UAAU,EAAE7rF,IAAI,CAAC6rF,UAAU,KAAKrnG,SAAS,GAAG,IAAIrb,eAAe,CAAC62B,IAAI,CAAC6rF,UAAU,CAAC,GAAG,IAAI;IACvFxyG,KAAK;IACLyyG,eAAe,EAAE9rF,IAAI,CAAC8rF,eAAe,IAAI5xH,uBAAuB,CAAC6xH,OAAO;IACxET,aAAa,EAAEtrF,IAAI,CAACsrF,aAAa,IAAItxH,mBAAmB,CAACuxH,QAAQ;IACjEJ,uBAAuB,EAAE,CAAC;IAC1B91D,uBAAuB,EAAE,EAAE;IAC3BC,kBAAkB,EAAE,IAAI;IACxBG,oBAAoB,EAAE,IAAI;IAC1Bu1D;EACF,CAAC;AACH;AACA,SAASiL,kCAAkCA,CAACnB,WAAW,EAAE;EACvD,OAAO;IACL,GAAGA,WAAW;IACdp3H,IAAI,EAAE,IAAIyL,eAAe,CAAC2rH,WAAW,CAACp3H,IAAI;EAC5C,CAAC;AACH;AACA,SAASy6H,qCAAqCA,CAACrD,WAAW,EAAE5C,WAAW,GAAG,IAAI,EAAE;EAC9E,OAAO;IACLhiF,IAAI,EAAEz0C,wBAAwB,CAACo1B,SAAS;IACxCqhG,WAAW,EAAEA,WAAW,IAAI4C,WAAW,CAAC5kF,IAAI,KAAK,WAAW;IAC5D57C,QAAQ,EAAEwgI,WAAW,CAACxgI,QAAQ;IAC9BoJ,IAAI,EAAE,IAAIyL,eAAe,CAAC2rH,WAAW,CAACp3H,IAAI,CAAC;IAC3C67B,MAAM,EAAEu7F,WAAW,CAACv7F,MAAM,IAAI,EAAE;IAChCC,OAAO,EAAEs7F,WAAW,CAACt7F,OAAO,IAAI,EAAE;IAClCqwF,QAAQ,EAAEiL,WAAW,CAACjL,QAAQ,IAAI;EACpC,CAAC;AACH;AACA,SAASyO,wBAAwBA,CAAC1I,KAAK,EAAE;EACvC,IAAI,CAACA,KAAK,EAAE;IACV,OAAO,EAAE;EACX;EACA,OAAOz0H,MAAM,CAACmC,IAAI,CAACsyH,KAAK,CAAC,CAAC92H,GAAG,CAACrC,IAAI,IAAI;IACpC,OAAO;MACLy5C,IAAI,EAAEz0C,wBAAwB,CAAC20B,IAAI;MACnC35B,IAAI;MACJiH,IAAI,EAAE,IAAIyL,eAAe,CAACymH,KAAK,CAACn5H,IAAI,CAAC;IACvC,CAAC;EACH,CAAC,CAAC;AACJ;AACA,SAAS2hI,gCAAgCA,CAACn6G,IAAI,EAAE;EAC9C,OAAO;IACLiyB,IAAI,EAAEz0C,wBAAwB,CAAC20B,IAAI;IACnC35B,IAAI,EAAEwnB,IAAI,CAACxnB,IAAI;IACfiH,IAAI,EAAE,IAAIyL,eAAe,CAAC8U,IAAI,CAACvgB,IAAI;EACrC,CAAC;AACH;AACA,SAASs4H,gBAAgBA,CAACpsH,QAAQ,EAAEumC,QAAQ,EAAEukF,YAAY,EAAE/L,mBAAmB,EAAEsP,sBAAsB,EAAE;EACvG,MAAM5Y,MAAM,GAAGoJ,aAAa,CAAC7+G,QAAQ,EAAE8qH,YAAY,EAAE;IACnD/L;EACF,CAAC,CAAC;EACF,IAAItJ,MAAM,CAACxpF,MAAM,KAAK,IAAI,EAAE;IAC1B,MAAMA,MAAM,GAAGwpF,MAAM,CAACxpF,MAAM,CAAC/8B,GAAG,CAACy/H,GAAG,IAAIA,GAAG,CAAC3hI,QAAQ,CAAC,CAAC,CAAC,CAACL,IAAI,CAAC,IAAI,CAAC;IAClE,MAAM,IAAIpB,KAAK,CAAC,iDAAiDg7C,QAAQ,KAAKta,MAAM,EAAE,CAAC;EACzF;EACA,MAAMq5F,MAAM,GAAG,IAAIC,cAAc,CAAC,IAAI,CAAC;EACvC,MAAMqJ,WAAW,GAAGtJ,MAAM,CAACz9E,IAAI,CAAC;IAC9B7nC,QAAQ,EAAEy1G,MAAM,CAACpjH;EACnB,CAAC,CAAC;EACF,OAAO;IACL2N,QAAQ,EAAEy1G,MAAM;IAChBhmG,KAAK,EAAEo/G,8BAA8B,CAACD,WAAW,EAAEP,sBAAsB;EAC3E,CAAC;AACH;AACA,SAAShD,2BAA2BA,CAACvwD,GAAG,EAAEvnD,QAAQ,EAAE;EAClD,IAAIunD,GAAG,CAAC1iC,cAAc,CAAC7kB,QAAQ,CAAC,EAAE;IAChC,OAAOyQ,+BAA+B,CAAC,IAAIzkB,eAAe,CAACu7D,GAAG,CAACvnD,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC;EAC/E,CAAC,MAAM;IACL,OAAOqH,SAAS;EAClB;AACF;AACA,SAAS0wG,cAAcA,CAACxwD,GAAG,EAAEvnD,QAAQ,EAAE;EACrC,IAAIunD,GAAG,CAAC1iC,cAAc,CAAC7kB,QAAQ,CAAC,EAAE;IAChC,OAAO,IAAIhU,eAAe,CAACu7D,GAAG,CAACvnD,QAAQ,CAAC,CAAC;EAC3C,CAAC,MAAM;IACL,OAAOqH,SAAS;EAClB;AACF;AACA,SAASwwG,iBAAiBA,CAACvrF,UAAU,EAAE;EACrC,MAAMhsC,UAAU,GAAG,OAAOgsC,UAAU,KAAK,UAAU,GAAG,IAAItgC,eAAe,CAACsgC,UAAU,CAAC,GAAG,IAAIr/B,WAAW,CAACq/B,UAAU,IAAI,IAAI,CAAC;EAC3H,OAAO7b,+BAA+B,CAACnwB,UAAU,EAAE,CAAC,CAAC;AACvD;AACA,SAAS+4H,gCAAgCA,CAACkC,OAAO,EAAE;EACjD,OAAOA,OAAO,IAAI,IAAI,GAAG,IAAI,GAAGA,OAAO,CAAC5/H,GAAG,CAACq8H,2BAA2B,CAAC;AAC1E;AACA,SAASA,2BAA2BA,CAACR,MAAM,EAAE;EAC3C,MAAMgE,cAAc,GAAGhE,MAAM,CAACj/H,SAAS,IAAI,IAAI;EAC/C,MAAMkjI,QAAQ,GAAGjE,MAAM,CAAC3vG,KAAK,KAAK,IAAI,GAAG,IAAI,GAAG,IAAI7b,eAAe,CAACwrH,MAAM,CAAC3vG,KAAK,CAAC;EACjF,MAAMA,KAAK,GAAG2zG,cAAc,GAAG,IAAIxvH,eAAe,CAACwrH,MAAM,CAACj/H,SAAS,CAAC,GAAGkjI,QAAQ;EAC/E,OAAOC,0BAA0B,CAAC7zG,KAAK,EAAE2zG,cAAc,EAAEhE,MAAM,CAACzkG,IAAI,EAAEykG,MAAM,CAACxkG,QAAQ,EAAEwkG,MAAM,CAAC3kG,IAAI,EAAE2kG,MAAM,CAAC1kG,QAAQ,CAAC;AACtH;AACA,SAASolG,kCAAkCA,CAACV,MAAM,EAAE;EAClD,MAAMgE,cAAc,GAAGhE,MAAM,CAACj/H,SAAS,IAAI,KAAK;EAChD,MAAMsvB,KAAK,GAAG2vG,MAAM,CAAC3vG,KAAK,KAAK,IAAI,GAAG,IAAI,GAAG,IAAI7b,eAAe,CAACwrH,MAAM,CAAC3vG,KAAK,CAAC;EAC9E,OAAO6zG,0BAA0B,CAAC7zG,KAAK,EAAE2zG,cAAc,EAAEhE,MAAM,CAACzkG,IAAI,IAAI,KAAK,EAAEykG,MAAM,CAACxkG,QAAQ,IAAI,KAAK,EAAEwkG,MAAM,CAAC3kG,IAAI,IAAI,KAAK,EAAE2kG,MAAM,CAAC1kG,QAAQ,IAAI,KAAK,CAAC;AAC1J;AACA,SAAS4oG,0BAA0BA,CAAC7zG,KAAK,EAAE2zG,cAAc,EAAEzoG,IAAI,EAAEC,QAAQ,EAAEH,IAAI,EAAEC,QAAQ,EAAE;EACzF,MAAMF,iBAAiB,GAAG4oG,cAAc,GAAGtlH,OAAO,CAAC,SAAS,CAAC,GAAG,IAAI;EACpE,OAAO;IACL2R,KAAK;IACL+K,iBAAiB;IACjBG,IAAI;IACJC,QAAQ;IACRH,IAAI;IACJC;EACF,CAAC;AACH;AACA,SAASwoG,8BAA8BA,CAACD,WAAW,EAAEP,sBAAsB,EAAE;EAC3E,MAAMxF,cAAc,GAAG+F,WAAW,CAACnF,cAAc,CAAC,CAAC;EACnD,MAAM/yE,MAAM,GAAG,IAAIjpD,GAAG,CAAC,CAAC;EACxB,KAAK,IAAItB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG08H,cAAc,CAAC99H,MAAM,EAAEoB,CAAC,EAAE,EAAE;IAC9C,MAAM+iI,YAAY,GAAGb,sBAAsB,GAAGliI,CAAC,CAAC;IAChDuqD,MAAM,CAAC3nD,GAAG,CAAC85H,cAAc,CAAC18H,CAAC,CAAC,EAAE+iI,YAAY,GAAG,IAAI3vH,eAAe,CAAC2vH,YAAY,CAAC,GAAG,IAAI,CAAC;EACxF;EACA,OAAO;IACL9jE,IAAI,EAAE,CAAC;IACP1U;EACF,CAAC;AACH;AACA,SAASo3E,mBAAmBA,CAACR,YAAY,EAAEryH,UAAU,EAAEqrB,IAAI,EAAE;EAC3D,MAAMoP,QAAQ,GAAG+tF,iBAAiB,CAACn9F,IAAI,IAAI,CAAC,CAAC,CAAC;EAC9C,MAAM2F,MAAM,GAAGy3F,kBAAkB,CAAChuF,QAAQ,EAAEz6B,UAAU,CAAC;EACvD,IAAIgxB,MAAM,CAAClhC,MAAM,EAAE;IACjB,MAAM,IAAIQ,KAAK,CAAC0gC,MAAM,CAAC/8B,GAAG,CAAC6iC,KAAK,IAAIA,KAAK,CAAC76B,GAAG,CAAC,CAACvK,IAAI,CAAC,IAAI,CAAC,CAAC;EAC5D;EACA,KAAK,MAAM8gI,KAAK,IAAIH,YAAY,EAAE;IAChC,IAAIA,YAAY,CAACl1F,cAAc,CAACq1F,KAAK,CAAC,EAAE;MACtCH,YAAY,CAACG,KAAK,CAAC,CAACxgI,OAAO,CAACygI,GAAG,IAAI;QACjC,IAAI1f,aAAa,CAAC0f,GAAG,CAAC,EAAE;UACtBh4F,QAAQ,CAACitD,UAAU,CAAC+qC,GAAG,CAACyB,gBAAgB,IAAI1B,KAAK,CAAC,GAAGzqG,2BAA2B,CAAC,MAAM,EAAEyqG,KAAK,CAAC;QACjG,CAAC,MAAM,IAAI2B,cAAc,CAAC1B,GAAG,CAAC,EAAE;UAC9Bh4F,QAAQ,CAACC,SAAS,CAAC+3F,GAAG,CAAC1e,SAAS,IAAIye,KAAK,CAAC,GAAG,GAAGA,KAAK,IAAI,CAACC,GAAG,CAAC/tH,IAAI,IAAI,EAAE,EAAEhT,IAAI,CAAC,GAAG,CAAC,GAAG;QACxF;MACF,CAAC,CAAC;IACJ;EACF;EACA,OAAO+oC,QAAQ;AACjB;AACA,SAASs4E,aAAaA,CAAClhH,KAAK,EAAE;EAC5B,OAAOA,KAAK,CAACuiI,cAAc,KAAK,aAAa;AAC/C;AACA,SAASD,cAAcA,CAACtiI,KAAK,EAAE;EAC7B,OAAOA,KAAK,CAACuiI,cAAc,KAAK,cAAc;AAChD;AACA,SAAS1B,OAAOA,CAAC7gI,KAAK,EAAE;EACtB,OAAOA,KAAK,CAACuiI,cAAc,KAAK,OAAO;AACzC;AACA,SAASzB,QAAQA,CAAC9gI,KAAK,EAAE;EACvB,OAAOA,KAAK,CAACuiI,cAAc,KAAK,QAAQ;AAC1C;AACA,SAASrB,oCAAoCA,CAACr+F,MAAM,EAAE;EACpD,OAAOp+B,MAAM,CAACmC,IAAI,CAACi8B,MAAM,CAAC,CAACz5B,MAAM,CAAC,CAACjK,MAAM,EAAEqjI,iBAAiB,KAAK;IAC/D,MAAMxiI,KAAK,GAAG6iC,MAAM,CAAC2/F,iBAAiB,CAAC;IACvC,IAAI,OAAOxiI,KAAK,KAAK,QAAQ,IAAIwX,KAAK,CAACC,OAAO,CAACzX,KAAK,CAAC,EAAE;MACrDb,MAAM,CAACqjI,iBAAiB,CAAC,GAAGC,6BAA6B,CAACziI,KAAK,CAAC;IAClE,CAAC,MAAM;MACLb,MAAM,CAACqjI,iBAAiB,CAAC,GAAG;QAC1BvxF,mBAAmB,EAAEjxC,KAAK,CAACwrC,UAAU;QACrCwF,iBAAiB,EAAEwxF,iBAAiB;QACpCpxF,iBAAiB,EAAEpxC,KAAK,CAACoxC,iBAAiB,KAAK,IAAI,GAAG,IAAI3+B,eAAe,CAACzS,KAAK,CAACoxC,iBAAiB,CAAC,GAAG,IAAI;QACzG+kF,QAAQ,EAAEn2H,KAAK,CAAC0iI,UAAU;QAC1BrxF,QAAQ,EAAErxC,KAAK,CAACqxC;MAClB,CAAC;IACH;IACA,OAAOlyC,MAAM;EACf,CAAC,EAAE,CAAC,CAAC,CAAC;AACR;AACA,SAASsjI,6BAA6BA,CAACziI,KAAK,EAAE;EAC5C,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC7B,OAAO;MACLixC,mBAAmB,EAAEjxC,KAAK;MAC1BgxC,iBAAiB,EAAEhxC,KAAK;MACxBoxC,iBAAiB,EAAE,IAAI;MACvB+kF,QAAQ,EAAE,KAAK;MACf9kF,QAAQ,EAAE;IACZ,CAAC;EACH;EACA,OAAO;IACLJ,mBAAmB,EAAEjxC,KAAK,CAAC,CAAC,CAAC;IAC7BgxC,iBAAiB,EAAEhxC,KAAK,CAAC,CAAC,CAAC;IAC3BoxC,iBAAiB,EAAEpxC,KAAK,CAAC,CAAC,CAAC,GAAG,IAAIyS,eAAe,CAACzS,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI;IAClEm2H,QAAQ,EAAE,KAAK;IACf9kF,QAAQ,EAAE;EACZ,CAAC;AACH;AACA,SAASgvF,gBAAgBA,CAACnkH,MAAM,EAAE;EAChC,OAAOA,MAAM,CAAC9S,MAAM,CAAC,CAACvL,OAAO,EAAEmC,KAAK,KAAK;IACvC,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC7B,MAAM,CAACixC,mBAAmB,EAAED,iBAAiB,CAAC,GAAG2xF,kBAAkB,CAAC3iI,KAAK,CAAC;MAC1EnC,OAAO,CAACmzC,iBAAiB,CAAC,GAAG;QAC3BC,mBAAmB;QACnBD,iBAAiB;QACjBmlF,QAAQ,EAAE,KAAK;QACf9kF,QAAQ,EAAE,KAAK;QACfD,iBAAiB,EAAE;MACrB,CAAC;IACH,CAAC,MAAM;MACLvzC,OAAO,CAACmC,KAAK,CAACD,IAAI,CAAC,GAAG;QACpBkxC,mBAAmB,EAAEjxC,KAAK,CAAC6zD,KAAK,IAAI7zD,KAAK,CAACD,IAAI;QAC9CixC,iBAAiB,EAAEhxC,KAAK,CAACD,IAAI;QAC7Bo2H,QAAQ,EAAEn2H,KAAK,CAACm2H,QAAQ,IAAI,KAAK;QACjC9kF,QAAQ,EAAE,KAAK;QACfD,iBAAiB,EAAEpxC,KAAK,CAACmxD,SAAS,IAAI,IAAI,GAAG,IAAI1+C,eAAe,CAACzS,KAAK,CAACmxD,SAAS,CAAC,GAAG;MACtF,CAAC;IACH;IACA,OAAOtzD,OAAO;EAChB,CAAC,EAAE,CAAC,CAAC,CAAC;AACR;AACA,SAAS0iI,uBAAuBA,CAACrkH,MAAM,EAAE;EACvC,OAAOA,MAAM,CAAC9S,MAAM,CAAC,CAACvL,OAAO,EAAEmC,KAAK,KAAK;IACvC,MAAM,CAAC6zD,KAAK,EAAE+uE,SAAS,CAAC,GAAGD,kBAAkB,CAAC3iI,KAAK,CAAC;IACpDnC,OAAO,CAAC+kI,SAAS,CAAC,GAAG/uE,KAAK;IAC1B,OAAOh2D,OAAO;EAChB,CAAC,EAAE,CAAC,CAAC,CAAC;AACR;AACA,SAAS8kI,kBAAkBA,CAAC3iI,KAAK,EAAE;EACjC,MAAM,CAAC4iI,SAAS,EAAE3xF,mBAAmB,CAAC,GAAGjxC,KAAK,CAAC+uB,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC3sB,GAAG,CAACsF,GAAG,IAAIA,GAAG,CAACimB,IAAI,CAAC,CAAC,CAAC;EACnF,OAAO,CAACsjB,mBAAmB,IAAI2xF,SAAS,EAAEA,SAAS,CAAC;AACtD;AACA,SAASvE,kCAAkCA,CAACD,WAAW,EAAE;EACvD,OAAO;IACLr+H,IAAI,EAAEq+H,WAAW,CAACp3H,IAAI,CAACjH,IAAI;IAC3BiH,IAAI,EAAE4vB,aAAa,CAACwnG,WAAW,CAACp3H,IAAI,CAAC;IACrCkyB,iBAAiB,EAAE,CAAC;IACpBimB,QAAQ,EAAEi/E,WAAW,CAACr+H,IAAI;IAC1B83B,IAAI,EAAE,IAAI;IACVnpB,IAAI,EAAE0vH,WAAW,CAAC1vH,IAAI,IAAI,IAAI;IAC9B0wC,YAAY,EAAEg/E,WAAW,CAACh/E,YAAY,IAAIjwB,iCAAiC,CAACivG,WAAW,CAAChvG,OAAO;EACjG,CAAC;AACH;AACA,SAASyvG,sCAAsCA,CAACT,WAAW,EAAE;EAC3D,OAAO;IACLr+H,IAAI,EAAEq+H,WAAW,CAACp3H,IAAI,CAACjH,IAAI;IAC3BiH,IAAI,EAAE4vB,aAAa,CAACwnG,WAAW,CAACp3H,IAAI,CAAC;IACrC21C,SAAS,EAAEyhF,WAAW,CAACzhF,SAAS,KAAK7uB,SAAS,IAAIswG,WAAW,CAACzhF,SAAS,CAAC1+C,MAAM,GAAG,CAAC,GAAG,IAAIwU,eAAe,CAAC2rH,WAAW,CAACzhF,SAAS,CAAC,GAAG,IAAI;IACtIC,OAAO,EAAEwhF,WAAW,CAACxhF,OAAO,KAAK9uB,SAAS,GAAGswG,WAAW,CAACxhF,OAAO,CAACx6C,GAAG,CAAC/C,CAAC,IAAI,IAAIoT,eAAe,CAACpT,CAAC,CAAC,CAAC,GAAG;EACtG,CAAC;AACH;AACA,SAASwjI,aAAaA,CAACC,MAAM,EAAE;EAC7B,MAAMC,EAAE,GAAGD,MAAM,CAACC,EAAE,KAAKD,MAAM,CAACC,EAAE,GAAG,CAAC,CAAC,CAAC;EACxCA,EAAE,CAACC,eAAe,GAAG,IAAIrF,kBAAkB,CAAC,CAAC;AAC/C;AAEA,MAAMsF,cAAc,CAAC;EACnBC,oBAAoB;EACpBjR,mBAAmB;EACnBkR,yBAAyB;EACzBpgI,WAAWA,CAAC;IACVmgI,oBAAoB,GAAG5/H,mBAAmB,CAACuxH,QAAQ;IACnD5C,mBAAmB;IACnBkR;EACF,CAAC,GAAG,CAAC,CAAC,EAAE;IACN,IAAI,CAACD,oBAAoB,GAAGA,oBAAoB;IAChD,IAAI,CAACjR,mBAAmB,GAAGmR,0BAA0B,CAACx1G,WAAW,CAACqkG,mBAAmB,CAAC,CAAC;IACvF,IAAI,CAACkR,yBAAyB,GAAGA,yBAAyB,KAAK,IAAI;EACrE;AACF;AACA,SAASC,0BAA0BA,CAACC,yBAAyB,EAAEC,cAAc,GAAG,KAAK,EAAE;EACrF,OAAOD,yBAAyB,KAAK,IAAI,GAAGC,cAAc,GAAGD,yBAAyB;AACxF;AAEA,MAAME,UAAU,GAAG,MAAM;AACzB,MAAMC,iBAAiB,GAAG,OAAO;AACjC,MAAMC,2BAA2B,GAAG,SAAS;AAC7C,MAAMC,iBAAiB,GAAG,GAAG;AAC7B,MAAMC,YAAY,GAAG,IAAI;AACzB,IAAIC,kBAAkB,GAAG,KAAK;AAC9B,SAASC,eAAeA,CAACt+H,KAAK,EAAEu+H,YAAY,EAAEC,aAAa,EAAEliD,6BAA6B,EAAE;EAC1F,MAAMl8E,OAAO,GAAG,IAAIimC,QAAQ,CAACk4F,YAAY,EAAEC,aAAa,EAAEliD,6BAA6B,CAAC;EACxF,OAAOl8E,OAAO,CAACq+H,OAAO,CAACz+H,KAAK,CAAC;AAC/B;AACA,SAAS0+H,iBAAiBA,CAAC1+H,KAAK,EAAE2+H,YAAY,EAAEJ,YAAY,EAAEC,aAAa,EAAE;EAC3E,MAAMp+H,OAAO,GAAG,IAAIimC,QAAQ,CAACk4F,YAAY,EAAEC,aAAa,CAAC;EACzD,OAAOp+H,OAAO,CAACw+H,KAAK,CAAC5+H,KAAK,EAAE2+H,YAAY,CAAC;AAC3C;AACA,MAAME,gBAAgB,CAAC;EACrB12F,QAAQ;EACRvO,MAAM;EACNp8B,WAAWA,CAAC2qC,QAAQ,EAAEvO,MAAM,EAAE;IAC5B,IAAI,CAACuO,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACvO,MAAM,GAAGA,MAAM;EACtB;AACF;AACA,IAAIklG,YAAY;AAChB,CAAC,UAAUA,YAAY,EAAE;EACvBA,YAAY,CAACA,YAAY,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;EACrDA,YAAY,CAACA,YAAY,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;AACnD,CAAC,EAAEA,YAAY,KAAKA,YAAY,GAAG,CAAC,CAAC,CAAC,CAAC;AACvC,MAAMz4F,QAAQ,CAAC;EACb04F,aAAa;EACbC,cAAc;EACdC,8BAA8B;EAC9BC,MAAM;EACNC,WAAW;EACXC,eAAe;EACfC,YAAY;EACZC,oBAAoB;EACpBC,cAAc;EACdC,gBAAgB;EAChBC,MAAM;EACNC,uBAAuB;EACvB1nC,OAAO;EACP2nC,KAAK;EACLC,SAAS;EACTC,aAAa;EACbC,kBAAkB;EAClBtiI,WAAWA,CAACuhI,aAAa,EAAEC,cAAc,EAAEC,8BAA8B,GAAG,IAAI,EAAE;IAChF,IAAI,CAACF,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACC,8BAA8B,GAAGA,8BAA8B;EACtE;EACAR,OAAOA,CAACz+H,KAAK,EAAE;IACb,IAAI,CAAC+/H,KAAK,CAACjB,YAAY,CAACkB,OAAO,CAAC;IAChChgI,KAAK,CAACpF,OAAO,CAACuS,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IAC7C,IAAI,IAAI,CAAC6+H,YAAY,EAAE;MACrB,IAAI,CAAC3mC,YAAY,CAAC14F,KAAK,CAACA,KAAK,CAACtH,MAAM,GAAG,CAAC,CAAC,EAAE,gBAAgB,CAAC;IAC9D;IACA,OAAO,IAAImmI,gBAAgB,CAAC,IAAI,CAACe,SAAS,EAAE,IAAI,CAAC5nC,OAAO,CAAC;EAC3D;EACA4mC,KAAKA,CAAC5+H,KAAK,EAAE2+H,YAAY,EAAE;IACzB,IAAI,CAACoB,KAAK,CAACjB,YAAY,CAACmB,KAAK,CAAC;IAC9B,IAAI,CAACJ,aAAa,GAAGlB,YAAY;IACjC,MAAMuB,OAAO,GAAG,IAAI9iG,OAAO,CAAC,SAAS,EAAE,EAAE,EAAE,EAAE,EAAEp9B,KAAK,EAAE,KAAK,EAAEuoB,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAE,KAAK,CAAC;IACpG,MAAM43G,cAAc,GAAGD,OAAO,CAAC1/H,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC;IAChD,IAAI,IAAI,CAAC6+H,YAAY,EAAE;MACrB,IAAI,CAAC3mC,YAAY,CAAC14F,KAAK,CAACA,KAAK,CAACtH,MAAM,GAAG,CAAC,CAAC,EAAE,gBAAgB,CAAC;IAC9D;IACA,OAAO,IAAIg+E,eAAe,CAACypD,cAAc,CAACn/H,QAAQ,EAAE,IAAI,CAACg3F,OAAO,CAAC;EACnE;EACAzuB,kBAAkBA,CAAC62D,OAAO,EAAEv/H,OAAO,EAAE;IACnC,MAAMW,UAAU,GAAGw4B,QAAQ,CAAC,IAAI,EAAEomG,OAAO,CAAC5+H,UAAU,EAAEX,OAAO,CAAC;IAC9D,IAAI,IAAI,CAAC8+H,KAAK,KAAKb,YAAY,CAACmB,KAAK,EAAE;MACrC,OAAO,IAAI72D,aAAa,CAACg3D,OAAO,CAAC3lI,KAAK,EAAE+G,UAAU,EAAE4+H,OAAO,CAACx3H,UAAU,EAAEw3H,OAAO,CAAC/2D,eAAe,EAAE+2D,OAAO,CAAC92D,aAAa,CAAC;IACzH;EACF;EACAH,cAAcA,CAAChoE,GAAG,EAAEN,OAAO,EAAE;IAC3B,IAAI,CAACw/H,sBAAsB,CAACl/H,GAAG,CAAC;IAChC,MAAMm/H,QAAQ,GAAG,IAAI,CAACb,MAAM;IAC5B,IAAI,CAAC,IAAI,CAACA,MAAM,EAAE;MAChB,IAAI,IAAI,CAACc,wBAAwB,EAAE;QACjC,IAAI,CAACC,WAAW,CAAC,CAACr/H,GAAG,CAAC,CAAC;MACzB;MACA,IAAI,CAACs+H,MAAM,GAAG,IAAI;IACpB;IACA,MAAMn+H,KAAK,GAAG04B,QAAQ,CAAC,IAAI,EAAE74B,GAAG,CAACG,KAAK,EAAET,OAAO,CAAC;IAChD,IAAI,IAAI,CAAC8+H,KAAK,KAAKb,YAAY,CAACmB,KAAK,EAAE;MACrC9+H,GAAG,GAAG,IAAI6nE,SAAS,CAAC7nE,GAAG,CAAC8nE,WAAW,EAAE9nE,GAAG,CAACM,IAAI,EAAEH,KAAK,EAAEH,GAAG,CAACyH,UAAU,EAAEzH,GAAG,CAAC+nE,qBAAqB,CAAC;IAClG;IACA,IAAI,CAACu2D,MAAM,GAAGa,QAAQ;IACtB,OAAOn/H,GAAG;EACZ;EACAuoE,YAAYA,CAAC95C,OAAO,EAAE/uB,OAAO,EAAE;IAC7B,MAAM4/H,SAAS,GAAGC,iBAAiB,CAAC9wG,OAAO,CAAC;IAC5C,IAAI6wG,SAAS,IAAI,IAAI,CAACF,wBAAwB,EAAE;MAC9C,IAAI,CAAC7nC,YAAY,CAAC9oE,OAAO,EAAE,uDAAuD,CAAC;MACnF;IACF;IACA,MAAM+wG,SAAS,GAAGC,iBAAiB,CAAChxG,OAAO,CAAC;IAC5C,IAAI+wG,SAAS,IAAI,CAAC,IAAI,CAACtB,YAAY,EAAE;MACnC,IAAI,CAAC3mC,YAAY,CAAC9oE,OAAO,EAAE,mCAAmC,CAAC;MAC/D;IACF;IACA,IAAI,CAAC,IAAI,CAACuvG,WAAW,IAAI,CAAC,IAAI,CAACM,MAAM,EAAE;MACrC,IAAI,CAAC,IAAI,CAACJ,YAAY,EAAE;QACtB,IAAIoB,SAAS,EAAE;UACb,IAAI,CAACpC,kBAAkB,IAAIloB,OAAO,IAAIA,OAAO,CAAC0qB,IAAI,EAAE;YAClDxC,kBAAkB,GAAG,IAAI;YACzB,MAAM/qF,OAAO,GAAG1jB,OAAO,CAAChnB,UAAU,CAAC0qC,OAAO,GAAG,KAAK1jB,OAAO,CAAChnB,UAAU,CAAC0qC,OAAO,EAAE,GAAG,EAAE;YACnF6iE,OAAO,CAAC0qB,IAAI,CAAC,wEAAwEjxG,OAAO,CAAChnB,UAAU,CAACmmB,KAAK,GAAGukB,OAAO,GAAG,CAAC;UAC7H;UACA,IAAI,CAAC+rF,YAAY,GAAG,IAAI;UACxB,IAAI,CAACG,gBAAgB,GAAG,IAAI,CAACN,MAAM;UACnC,IAAI,CAACK,cAAc,GAAG,EAAE;UACxB,IAAI,CAACD,oBAAoB,GAAG1vG,OAAO,CAACn1B,KAAK,CAACP,OAAO,CAACgkI,2BAA2B,EAAE,EAAE,CAAC,CAAC91G,IAAI,CAAC,CAAC;UACzF,IAAI,CAAC04G,wBAAwB,CAAClxG,OAAO,CAAC;QACxC;MACF,CAAC,MAAM;QACL,IAAI+wG,SAAS,EAAE;UACb,IAAI,IAAI,CAACzB,MAAM,IAAI,IAAI,CAACM,gBAAgB,EAAE;YACxC,IAAI,CAACuB,yBAAyB,CAACnxG,OAAO,EAAE,IAAI,CAAC2vG,cAAc,CAAC;YAC5D,IAAI,CAACF,YAAY,GAAG,KAAK;YACzB,MAAM1/H,OAAO,GAAG,IAAI,CAAC6gI,WAAW,CAAC,IAAI,CAACjB,cAAc,EAAE,IAAI,CAACD,oBAAoB,CAAC;YAChF,MAAMt/H,KAAK,GAAG,IAAI,CAACghI,iBAAiB,CAACpxG,OAAO,EAAEjwB,OAAO,CAAC;YACtD,OAAOq6B,QAAQ,CAAC,IAAI,EAAEh6B,KAAK,CAAC;UAC9B,CAAC,MAAM;YACL,IAAI,CAAC04F,YAAY,CAAC9oE,OAAO,EAAE,iDAAiD,CAAC;YAC7E;UACF;QACF;MACF;IACF;EACF;EACAjvB,SAASA,CAACC,IAAI,EAAEC,OAAO,EAAE;IACvB,IAAI,IAAI,CAAC0/H,wBAAwB,EAAE;MACjC,IAAI,CAACF,sBAAsB,CAACz/H,IAAI,CAAC;IACnC;IACA,OAAOA,IAAI;EACb;EACAi9B,YAAYA,CAACpvB,EAAE,EAAE5N,OAAO,EAAE;IACxB,OAAO,IAAI,CAACw0F,iBAAiB,CAAC5mF,EAAE,EAAE5N,OAAO,CAAC;EAC5C;EACA4oE,cAAcA,CAAChwE,SAAS,EAAEoH,OAAO,EAAE;IACjC,MAAM,IAAI3H,KAAK,CAAC,kBAAkB,CAAC;EACrC;EACA0wE,UAAUA,CAAClmC,KAAK,EAAE7iC,OAAO,EAAE;IACzBm5B,QAAQ,CAAC,IAAI,EAAE0J,KAAK,CAAC1iC,QAAQ,EAAEH,OAAO,CAAC;EACzC;EACAipE,mBAAmBA,CAAC6T,SAAS,EAAE98E,OAAO,EAAE,CAAC;EACzCkhC,mBAAmBA,CAACgC,IAAI,EAAEljC,OAAO,EAAE,CAAC;EACpCqhC,cAAcA,CAAC0B,SAAS,EAAE/iC,OAAO,EAAE;IACjC,OAAO,IAAI,CAACw0F,iBAAiB,CAACzxD,SAAS,EAAE/iC,OAAO,CAAC;EACnD;EACAuhC,cAAcA,CAACyB,SAAS,EAAEhjC,OAAO,EAAE;IACjC,MAAM,IAAI3H,KAAK,CAAC,kBAAkB,CAAC;EACrC;EACA6mI,KAAKA,CAAChnE,IAAI,EAAE;IACV,IAAI,CAAC4mE,KAAK,GAAG5mE,IAAI;IACjB,IAAI,CAACsmE,YAAY,GAAG,KAAK;IACzB,IAAI,CAACF,WAAW,GAAG,KAAK;IACxB,IAAI,CAACD,MAAM,GAAG,CAAC;IACf,IAAI,CAACO,MAAM,GAAG,KAAK;IACnB,IAAI,CAACC,uBAAuB,GAAGn3G,SAAS;IACxC,IAAI,CAACyvE,OAAO,GAAG,EAAE;IACjB,IAAI,CAAC4nC,SAAS,GAAG,EAAE;IACnB,IAAI,CAACR,eAAe,GAAG,KAAK;IAC5B,IAAI,CAACU,kBAAkB,GAAG3rC,wBAAwB,CAACmD,wBAAwB,EAAE,CAAC,IAAI,CAAC2nC,8BAA8B,EAAE,IAAI,CAACA,8BAA8B,CAAC;EACzJ;EACA5pC,iBAAiBA,CAACloF,IAAI,EAAEtM,OAAO,EAAE;IAC/B,IAAI,CAACw/H,sBAAsB,CAAClzH,IAAI,CAAC;IACjC,IAAI,CAAC+xH,MAAM,EAAE;IACb,MAAM+B,aAAa,GAAG,IAAI,CAAC9B,WAAW;IACtC,MAAM+B,iBAAiB,GAAG,IAAI,CAAC9B,eAAe;IAC9C,IAAI+B,UAAU,GAAG,EAAE;IACnB,IAAIC,oBAAoB,GAAG74G,SAAS;IACpC,MAAMmyD,QAAQ,GAAGvtE,IAAI,YAAYwnB,SAAS,GAAGxnB,IAAI,CAACwK,OAAO,GAAGxK,IAAI,CAAC3S,IAAI;IACrE,MAAM6mI,QAAQ,GAAGC,YAAY,CAACn0H,IAAI,CAAC;IACnC,MAAM8mG,QAAQ,GAAGotB,QAAQ,GAAGA,QAAQ,CAAC5mI,KAAK,GAAG,EAAE;IAC/C,MAAM8mI,UAAU,GAAG,IAAI,CAACxC,aAAa,CAAC50F,IAAI,CAAChxC,GAAG,IAAIuhF,QAAQ,KAAKvhF,GAAG,CAAC,IAAI,CAAC,IAAI,CAACsmI,MAAM,IAAI,CAAC,IAAI,CAACc,wBAAwB;IACrH,MAAMiB,kBAAkB,GAAG,CAACN,iBAAiB,IAAIK,UAAU;IAC3D,IAAI,CAACnC,eAAe,GAAG8B,iBAAiB,IAAIK,UAAU;IACtD,IAAI,CAAC,IAAI,CAAChB,wBAAwB,IAAI,CAAC,IAAI,CAACd,MAAM,EAAE;MAClD,IAAI4B,QAAQ,IAAIG,kBAAkB,EAAE;QAClC,IAAI,CAACrC,WAAW,GAAG,IAAI;QACvB,MAAMx/H,OAAO,GAAG,IAAI,CAAC6gI,WAAW,CAACrzH,IAAI,CAACnM,QAAQ,EAAEizG,QAAQ,CAAC;QACzDmtB,oBAAoB,GAAG,IAAI,CAACJ,iBAAiB,CAAC7zH,IAAI,EAAExN,OAAO,CAAC;MAC9D;MACA,IAAI,IAAI,CAACggI,KAAK,IAAIb,YAAY,CAACkB,OAAO,EAAE;QACtC,MAAMyB,cAAc,GAAGJ,QAAQ,IAAIG,kBAAkB;QACrD,IAAIC,cAAc,EAAE,IAAI,CAACX,wBAAwB,CAAC3zH,IAAI,CAAC;QACvD6sB,QAAQ,CAAC,IAAI,EAAE7sB,IAAI,CAACnM,QAAQ,CAAC;QAC7B,IAAIygI,cAAc,EAAE,IAAI,CAACV,yBAAyB,CAAC5zH,IAAI,EAAEA,IAAI,CAACnM,QAAQ,CAAC;MACzE;IACF,CAAC,MAAM;MACL,IAAIqgI,QAAQ,IAAIG,kBAAkB,EAAE;QAClC,IAAI,CAAC9oC,YAAY,CAACvrF,IAAI,EAAE,yEAAyE,CAAC;MACpG;MACA,IAAI,IAAI,CAACwyH,KAAK,IAAIb,YAAY,CAACkB,OAAO,EAAE;QACtChmG,QAAQ,CAAC,IAAI,EAAE7sB,IAAI,CAACnM,QAAQ,CAAC;MAC/B;IACF;IACA,IAAI,IAAI,CAAC2+H,KAAK,KAAKb,YAAY,CAACmB,KAAK,EAAE;MACrC,MAAMyB,UAAU,GAAGN,oBAAoB,IAAIj0H,IAAI,CAACnM,QAAQ;MACxD0gI,UAAU,CAAC9mI,OAAO,CAACqG,KAAK,IAAI;QAC1B,MAAM0gI,OAAO,GAAG1gI,KAAK,CAACT,KAAK,CAAC,IAAI,EAAEK,OAAO,CAAC;QAC1C,IAAI8gI,OAAO,IAAI,CAAC,IAAI,CAACpB,wBAAwB,EAAE;UAC7CY,UAAU,GAAGA,UAAU,CAAC5mI,MAAM,CAAConI,OAAO,CAAC;QACzC;MACF,CAAC,CAAC;IACJ;IACA,IAAI,CAACC,kBAAkB,CAACz0H,IAAI,CAAC;IAC7B,IAAI,CAAC+xH,MAAM,EAAE;IACb,IAAI,CAACC,WAAW,GAAG8B,aAAa;IAChC,IAAI,CAAC7B,eAAe,GAAG8B,iBAAiB;IACxC,IAAI,IAAI,CAACvB,KAAK,KAAKb,YAAY,CAACmB,KAAK,EAAE;MACrC,IAAI9yH,IAAI,YAAYiwB,OAAO,EAAE;QAC3B,OAAO,IAAIA,OAAO,CAACjwB,IAAI,CAAC3S,IAAI,EAAE,IAAI,CAACqnI,oBAAoB,CAAC10H,IAAI,CAAC,EAAE,IAAI,CAAC20H,oBAAoB,CAAC30H,IAAI,CAAC,EAAEg0H,UAAU,EAAEh0H,IAAI,CAACuwB,aAAa,EAAEvwB,IAAI,CAACvE,UAAU,EAAEuE,IAAI,CAACwwB,eAAe,EAAExwB,IAAI,CAACywB,aAAa,EAAEzwB,IAAI,CAACvL,MAAM,CAAC;MACzM,CAAC,MAAM;QACL,OAAO,IAAI+yB,SAAS,CAACxnB,IAAI,CAAC80B,aAAa,EAAE90B,IAAI,CAACwK,OAAO,EAAExK,IAAI,CAAC0uB,QAAQ,EAAE,IAAI,CAACgmG,oBAAoB,CAAC10H,IAAI,CAAC,EAAE,IAAI,CAAC20H,oBAAoB,CAAC30H,IAAI,CAAC,EAAEg0H,UAAU,EAAEh0H,IAAI,CAACuwB,aAAa,EAAEvwB,IAAI,CAACvE,UAAU,EAAEuE,IAAI,CAACwwB,eAAe,EAAExwB,IAAI,CAACywB,aAAa,CAAC;MACpO;IACF;IACA,OAAO,IAAI;EACb;EACAgkG,kBAAkBA,CAACnzH,EAAE,EAAE;IACrB,MAAMszH,uBAAuB,GAAG,CAAC,CAAC;IAClC,MAAMC,iBAAiB,GAAG,IAAI,CAAChD,cAAc,CAACvwH,EAAE,YAAYkmB,SAAS,GAAGlmB,EAAE,CAACkJ,OAAO,IAAI,EAAE,GAAGlJ,EAAE,CAACjU,IAAI,CAAC,IAAI,EAAE;IACzGiU,EAAE,CAACvW,KAAK,CAACmiB,MAAM,CAAC1gB,IAAI,IAAIA,IAAI,YAAY2vD,SAAS,IAAI3vD,IAAI,CAACa,IAAI,CAACsvB,UAAU,CAACm0G,iBAAiB,CAAC,CAAC,CAACrjI,OAAO,CAACjB,IAAI,IAAI;MAC5GooI,uBAAuB,CAACpoI,IAAI,CAACa,IAAI,CAAClB,KAAK,CAAC2kI,iBAAiB,CAACvlI,MAAM,CAAC,CAAC,GAAGiB,IAAI,CAACc,KAAK;IACjF,CAAC,CAAC;IACFgU,EAAE,CAACvW,KAAK,CAAC0C,OAAO,CAACjB,IAAI,IAAI;MACvB,IAAIA,IAAI,CAACa,IAAI,IAAIunI,uBAAuB,EAAE;QACxC,IAAI,CAACvB,WAAW,CAAC,CAAC7mI,IAAI,CAAC,EAAEooI,uBAAuB,CAACpoI,IAAI,CAACa,IAAI,CAAC,CAAC;MAC9D,CAAC,MAAM,IAAIwnI,iBAAiB,CAAC73F,IAAI,CAAC3vC,IAAI,IAAIb,IAAI,CAACa,IAAI,KAAKA,IAAI,CAAC,EAAE;QAC7D,IAAI,CAACgmI,WAAW,CAAC,CAAC7mI,IAAI,CAAC,CAAC;MAC1B;IACF,CAAC,CAAC;EACJ;EACA6mI,WAAWA,CAAC3qH,GAAG,EAAEosH,OAAO,EAAE;IACxB,IAAIpsH,GAAG,CAACnd,MAAM,IAAI,CAAC,IAAI,IAAI,CAACwpI,sBAAsB,CAACrsH,GAAG,CAAC,IAAI,IAAI,CAACssH,gCAAgC,CAACtsH,GAAG,CAAC,IAAI,IAAI,CAACusH,yBAAyB,CAACvsH,GAAG,CAAC,EAAE;MAC5I,OAAO,IAAI;IACb;IACA,MAAM;MACJ5V,OAAO;MACP0P,WAAW;MACX/P;IACF,CAAC,GAAGyiI,iBAAiB,CAACJ,OAAO,CAAC;IAC9B,MAAMtiI,OAAO,GAAG,IAAI,CAACmgI,kBAAkB,CAACjqH,GAAG,EAAE5V,OAAO,EAAE0P,WAAW,EAAE/P,EAAE,CAAC;IACtE,IAAI,CAACggI,SAAS,CAACjnI,IAAI,CAACgH,OAAO,CAAC;IAC5B,OAAOA,OAAO;EAChB;EACAuiI,sBAAsBA,CAACrsH,GAAG,EAAE;IAC1B,IAAI,CAACysH,UAAU,CAACzsH,GAAG,CAAC,EAAE,OAAO,KAAK;IAClC,MAAM1I,IAAI,GAAG0I,GAAG,CAAC,CAAC,CAAC;IACnB,OAAO1I,IAAI,CAAC1S,KAAK,CAAC2tB,IAAI,CAAC,CAAC,KAAK,EAAE;EACjC;EACA+5G,gCAAgCA,CAACtsH,GAAG,EAAE;IACpC,IAAI,CAACysH,UAAU,CAACzsH,GAAG,CAAC,EAAE,OAAO,KAAK;IAClC,MAAMkzD,MAAM,GAAGlzD,GAAG,CAAC,CAAC,CAAC,CAAC2zD,WAAW,IAAI,EAAE;IACvC,MAAM+4D,cAAc,GAAGx5D,MAAM,CAAC1uD,MAAM,CAAC0O,KAAK,IAAIA,KAAK,CAACtnB,IAAI,KAAK,EAAE,CAAC;IAChE,MAAM+gI,SAAS,GAAGz5D,MAAM,CAAC1uD,MAAM,CAAC0O,KAAK,IAAIA,KAAK,CAACtnB,IAAI,KAAK,EAAE,CAAC,CAAC5E,GAAG,CAACksB,KAAK,IAAIA,KAAK,CAACzoB,KAAK,CAAC,CAAC,CAAC,CAAC8nB,IAAI,CAAC,CAAC,CAAC,CAAC9tB,IAAI,CAAC,EAAE,CAAC;IACxG,OAAOioI,cAAc,CAAC7pI,MAAM,KAAK,CAAC,IAAI8pI,SAAS,KAAK,EAAE;EACxD;EACAJ,yBAAyBA,CAACvsH,GAAG,EAAE;IAC7B,IAAI,CAAC4sH,UAAU,CAAC5sH,GAAG,CAAC,EAAE,OAAO,KAAK;IAClC,MAAMkzD,MAAM,GAAGlzD,GAAG,CAAC,CAAC,CAAC,CAACkzD,MAAM;IAC5B,MAAMw5D,cAAc,GAAGx5D,MAAM,CAAC1uD,MAAM,CAAC0O,KAAK,IAAIA,KAAK,CAACtnB,IAAI,KAAK,CAAC,CAAC;IAC/D,MAAM+gI,SAAS,GAAGz5D,MAAM,CAAC1uD,MAAM,CAAC0O,KAAK,IAAIA,KAAK,CAACtnB,IAAI,KAAK,CAAC,CAAC,CAAC5E,GAAG,CAACksB,KAAK,IAAIA,KAAK,CAACzoB,KAAK,CAAC,CAAC,CAAC,CAAC8nB,IAAI,CAAC,CAAC,CAAC,CAAC9tB,IAAI,CAAC,EAAE,CAAC;IACvG,OAAOioI,cAAc,CAAC7pI,MAAM,KAAK,CAAC,IAAI8pI,SAAS,KAAK,EAAE;EACxD;EACAxB,iBAAiBA,CAACvyH,EAAE,EAAE9O,OAAO,EAAE;IAC7B,IAAIA,OAAO,IAAI,IAAI,CAACggI,KAAK,KAAKb,YAAY,CAACmB,KAAK,EAAE;MAChD,MAAMjgI,KAAK,GAAG,IAAI,CAAC6/H,aAAa,CAACpjI,GAAG,CAACkD,OAAO,CAAC;MAC7C,IAAIK,KAAK,EAAE;QACT,OAAOA,KAAK;MACd;MACA,IAAI,CAAC04F,YAAY,CAACjqF,EAAE,EAAE,2CAA2C,IAAI,CAACoxH,aAAa,CAAC/2F,MAAM,CAACnpC,OAAO,CAAC,GAAG,CAAC;IACzG;IACA,OAAO,EAAE;EACX;EACAkiI,oBAAoBA,CAAC10H,IAAI,EAAE;IACzB,MAAMu1H,qBAAqB,GAAG,CAAC,CAAC;IAChC,MAAMC,oBAAoB,GAAG,EAAE;IAC/Bx1H,IAAI,CAACjV,KAAK,CAAC0C,OAAO,CAACjB,IAAI,IAAI;MACzB,IAAIA,IAAI,CAACa,IAAI,CAACsvB,UAAU,CAACm0G,iBAAiB,CAAC,EAAE;QAC3CyE,qBAAqB,CAAC/oI,IAAI,CAACa,IAAI,CAAClB,KAAK,CAAC2kI,iBAAiB,CAACvlI,MAAM,CAAC,CAAC,GAAG2pI,iBAAiB,CAAC1oI,IAAI,CAACc,KAAK,CAAC;MAClG;IACF,CAAC,CAAC;IACF0S,IAAI,CAACjV,KAAK,CAAC0C,OAAO,CAACjB,IAAI,IAAI;MACzB,IAAIA,IAAI,CAACa,IAAI,KAAKwjI,UAAU,IAAIrkI,IAAI,CAACa,IAAI,CAACsvB,UAAU,CAACm0G,iBAAiB,CAAC,EAAE;QACvE;MACF;MACA,IAAItkI,IAAI,CAACc,KAAK,IAAId,IAAI,CAACc,KAAK,IAAI,EAAE,IAAIioI,qBAAqB,CAAC38F,cAAc,CAACpsC,IAAI,CAACa,IAAI,CAAC,EAAE;QACrF,MAAM;UACJyF,OAAO;UACP0P,WAAW;UACX/P;QACF,CAAC,GAAG8iI,qBAAqB,CAAC/oI,IAAI,CAACa,IAAI,CAAC;QACpC,MAAMmF,OAAO,GAAG,IAAI,CAACmgI,kBAAkB,CAAC,CAACnmI,IAAI,CAAC,EAAEsG,OAAO,EAAE0P,WAAW,EAAE/P,EAAE,CAAC;QACzE,MAAMI,KAAK,GAAG,IAAI,CAAC6/H,aAAa,CAACpjI,GAAG,CAACkD,OAAO,CAAC;QAC7C,IAAIK,KAAK,EAAE;UACT,IAAIA,KAAK,CAACtH,MAAM,IAAI,CAAC,EAAE;YACrBiqI,oBAAoB,CAAChqI,IAAI,CAAC,IAAI2wD,SAAS,CAAC3vD,IAAI,CAACa,IAAI,EAAE,EAAE,EAAEb,IAAI,CAACiP,UAAU,EAAE2f,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,CAAC,CAAC;UACtH,CAAC,MAAM,IAAIvoB,KAAK,CAAC,CAAC,CAAC,YAAYo8B,IAAI,EAAE;YACnC,MAAM3hC,KAAK,GAAGuF,KAAK,CAAC,CAAC,CAAC,CAACvF,KAAK;YAC5BkoI,oBAAoB,CAAChqI,IAAI,CAAC,IAAI2wD,SAAS,CAAC3vD,IAAI,CAACa,IAAI,EAAEC,KAAK,EAAEd,IAAI,CAACiP,UAAU,EAAE2f,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,CAAC,CAAC;UACzH,CAAC,MAAM;YACL,IAAI,CAACmwE,YAAY,CAACvrF,IAAI,EAAE,yCAAyCxT,IAAI,CAACa,IAAI,UAAUoF,EAAE,IAAI,IAAI,CAACigI,aAAa,CAAC/2F,MAAM,CAACnpC,OAAO,CAAC,IAAI,CAAC;UACnI;QACF,CAAC,MAAM;UACL,IAAI,CAAC+4F,YAAY,CAACvrF,IAAI,EAAE,0CAA0CxT,IAAI,CAACa,IAAI,UAAUoF,EAAE,IAAI,IAAI,CAACigI,aAAa,CAAC/2F,MAAM,CAACnpC,OAAO,CAAC,IAAI,CAAC;QACpI;MACF,CAAC,MAAM;QACLgjI,oBAAoB,CAAChqI,IAAI,CAACgB,IAAI,CAAC;MACjC;IACF,CAAC,CAAC;IACF,OAAOgpI,oBAAoB;EAC7B;EACAb,oBAAoBA,CAAC30H,IAAI,EAAE;IACzB,OAAOA,IAAI,CAACqwB,UAAU,CAAC3gC,GAAG,CAACo5F,GAAG,IAAI,IAAIrhE,SAAS,CAACqhE,GAAG,CAACz7F,IAAI,EAAE,IAAI,CAACqnI,oBAAoB,CAAC5rC,GAAG,CAAC,EAAEA,GAAG,CAACrtF,UAAU,EAAEqtF,GAAG,CAACt4D,eAAe,EAAEs4D,GAAG,CAACr4D,aAAa,CAAC,CAAC;EACpJ;EACAyiG,sBAAsBA,CAAClzH,IAAI,EAAE;IAC3B,IAAI,IAAI,CAACkyH,YAAY,IAAI,CAAC,IAAI,CAACI,MAAM,IAAI,IAAI,CAACP,MAAM,IAAI,IAAI,CAACM,gBAAgB,EAAE;MAC7E,IAAI,CAACD,cAAc,CAAC5mI,IAAI,CAACwU,IAAI,CAAC;IAChC;EACF;EACA2zH,wBAAwBA,CAAC3zH,IAAI,EAAE;IAC7B,IAAI,IAAI,CAACozH,wBAAwB,EAAE;MACjC,IAAI,CAAC7nC,YAAY,CAACvrF,IAAI,EAAE,0BAA0B,CAAC;IACrD,CAAC,MAAM;MACL,IAAI,CAACuyH,uBAAuB,GAAG,IAAI,CAACE,SAAS,CAAClnI,MAAM;IACtD;EACF;EACA,IAAI6nI,wBAAwBA,CAAA,EAAG;IAC7B,OAAO,IAAI,CAACb,uBAAuB,KAAK,KAAK,CAAC;EAChD;EACAqB,yBAAyBA,CAAC5zH,IAAI,EAAEy1H,cAAc,EAAE;IAC9C,IAAI,CAAC,IAAI,CAACrC,wBAAwB,EAAE;MAClC,IAAI,CAAC7nC,YAAY,CAACvrF,IAAI,EAAE,wBAAwB,CAAC;MACjD;IACF;IACA,MAAMoxC,UAAU,GAAG,IAAI,CAACmhF,uBAAuB;IAC/C,MAAMmD,mBAAmB,GAAGD,cAAc,CAAC/+H,MAAM,CAAC,CAAC0B,KAAK,EAAE4H,IAAI,KAAK5H,KAAK,IAAI4H,IAAI,YAAY8uB,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;IAChH,IAAI4mG,mBAAmB,IAAI,CAAC,EAAE;MAC5B,KAAK,IAAI/oI,CAAC,GAAG,IAAI,CAAC8lI,SAAS,CAAClnI,MAAM,GAAG,CAAC,EAAEoB,CAAC,IAAIykD,UAAU,EAAEzkD,CAAC,EAAE,EAAE;QAC5D,MAAM+b,GAAG,GAAG,IAAI,CAAC+pH,SAAS,CAAC9lI,CAAC,CAAC,CAACkG,KAAK;QACnC,IAAI,EAAE6V,GAAG,CAACnd,MAAM,IAAI,CAAC,IAAImd,GAAG,CAAC,CAAC,CAAC,YAAY4uB,MAAM,CAAC,EAAE;UAClD,IAAI,CAACm7F,SAAS,CAAC9hE,MAAM,CAAChkE,CAAC,EAAE,CAAC,CAAC;UAC3B;QACF;MACF;IACF;IACA,IAAI,CAAC4lI,uBAAuB,GAAGn3G,SAAS;EAC1C;EACAmwE,YAAYA,CAACvrF,IAAI,EAAEtI,GAAG,EAAE;IACtB,IAAI,CAACmzF,OAAO,CAACr/F,IAAI,CAAC,IAAI66C,UAAU,CAACrmC,IAAI,CAACvE,UAAU,EAAE/D,GAAG,CAAC,CAAC;EACzD;AACF;AACA,SAAS67H,iBAAiBA,CAACx7F,CAAC,EAAE;EAC5B,OAAO,CAAC,EAAEA,CAAC,YAAYjJ,OAAO,IAAIiJ,CAAC,CAACzqC,KAAK,IAAIyqC,CAAC,CAACzqC,KAAK,CAACqvB,UAAU,CAAC,MAAM,CAAC,CAAC;AAC1E;AACA,SAAS82G,iBAAiBA,CAAC17F,CAAC,EAAE;EAC5B,OAAO,CAAC,EAAEA,CAAC,YAAYjJ,OAAO,IAAIiJ,CAAC,CAACzqC,KAAK,IAAIyqC,CAAC,CAACzqC,KAAK,KAAK,OAAO,CAAC;AACnE;AACA,SAAS6mI,YAAYA,CAACvvH,CAAC,EAAE;EACvB,OAAOA,CAAC,CAAC7Z,KAAK,CAACi0C,IAAI,CAACxyC,IAAI,IAAIA,IAAI,YAAY2vD,SAAS,IAAI3vD,IAAI,CAACa,IAAI,KAAKwjI,UAAU,CAAC,IAAI,IAAI;AAC5F;AACA,SAASqE,iBAAiBA,CAAC5gH,IAAI,EAAE;EAC/B,IAAI,CAACA,IAAI,EAAE,OAAO;IAChBxhB,OAAO,EAAE,EAAE;IACX0P,WAAW,EAAE,EAAE;IACf/P,EAAE,EAAE;EACN,CAAC;EACD,MAAMk5F,OAAO,GAAGr3E,IAAI,CAAC0G,OAAO,CAACi2G,YAAY,CAAC;EAC1C,MAAMrlC,SAAS,GAAGt3E,IAAI,CAAC0G,OAAO,CAACg2G,iBAAiB,CAAC;EACjD,MAAM,CAACnlC,cAAc,EAAEp5F,EAAE,CAAC,GAAGk5F,OAAO,GAAG,CAAC,CAAC,GAAG,CAACr3E,IAAI,CAACnoB,KAAK,CAAC,CAAC,EAAEw/F,OAAO,CAAC,EAAEr3E,IAAI,CAACnoB,KAAK,CAACw/F,OAAO,GAAG,CAAC,CAAC,CAAC,GAAG,CAACr3E,IAAI,EAAE,EAAE,CAAC;EAC1G,MAAM,CAACxhB,OAAO,EAAE0P,WAAW,CAAC,GAAGopF,SAAS,GAAG,CAAC,CAAC,GAAG,CAACC,cAAc,CAAC1/F,KAAK,CAAC,CAAC,EAAEy/F,SAAS,CAAC,EAAEC,cAAc,CAAC1/F,KAAK,CAACy/F,SAAS,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,EAAEC,cAAc,CAAC;EAChJ,OAAO;IACL/4F,OAAO;IACP0P,WAAW;IACX/P,EAAE,EAAEA,EAAE,CAACwoB,IAAI,CAAC;EACd,CAAC;AACH;AACA,SAASq6G,UAAUA,CAAC5sH,GAAG,EAAE;EACvB,OAAOA,GAAG,CAACnd,MAAM,KAAK,CAAC,IAAImd,GAAG,CAAC,CAAC,CAAC,YAAYumB,IAAI;AACnD;AACA,SAASkmG,UAAUA,CAACzsH,GAAG,EAAE;EACvB,OAAOA,GAAG,CAACnd,MAAM,KAAK,CAAC,IAAImd,GAAG,CAAC,CAAC,CAAC,YAAYyzC,SAAS;AACxD;AAEA,MAAMw5E,gBAAgB,CAAC;EACrBnoD,cAAc,GAAG,KAAK;EACtBY,uBAAuB,GAAG,IAAI;EAC9B35E,MAAM,GAAG,KAAK;EACdo3E,aAAa,GAAG,KAAK;EACrBS,YAAY,GAAG,IAAI;EACnBkC,2BAA2B,GAAG,KAAK;EACnConD,kBAAkBA,CAACC,aAAa,EAAE;IAChC,OAAO,KAAK;EACd;EACAtpD,eAAeA,CAACl/E,IAAI,EAAE;IACpB,OAAO,KAAK;EACd;EACA44E,cAAcA,CAAA,EAAG;IACf,OAAO/3C,cAAc,CAAC+2D,aAAa;EACrC;AACF;AACA,MAAM6wC,eAAe,GAAG,IAAIH,gBAAgB,CAAC,CAAC;AAC9C,SAASI,mBAAmBA,CAACvrH,OAAO,EAAE;EACpC,OAAOsrH,eAAe;AACxB;AAEA,MAAME,SAAS,SAASvsD,QAAQ,CAAC;EAC/Bp5E,WAAWA,CAAA,EAAG;IACZ,KAAK,CAAC0lI,mBAAmB,CAAC;EAC5B;EACA9qI,KAAKA,CAAC02B,MAAM,EAAE3d,GAAG,EAAE2tB,OAAO,GAAG,CAAC,CAAC,EAAE;IAC/B,OAAO,KAAK,CAAC1mC,KAAK,CAAC02B,MAAM,EAAE3d,GAAG,EAAE;MAC9B,GAAG2tB,OAAO;MACV+tC,cAAc,EAAE,KAAK;MACrBC,WAAW,EAAE,KAAK;MAClBC,mBAAmB,EAAE;IACvB,CAAC,CAAC;EACJ;AACF;AAEA,MAAMq2D,UAAU,GAAG,KAAK;AACxB,MAAMC,QAAQ,GAAG,uCAAuC;AACxD,MAAMC,sBAAsB,GAAG,IAAI;AACnC,MAAMC,kBAAkB,GAAG,GAAG;AAC9B,MAAMC,aAAa,GAAG,KAAK;AAC3B,MAAMC,SAAS,GAAG,MAAM;AACxB,MAAMC,aAAa,GAAG,QAAQ;AAC9B,MAAMC,mBAAmB,GAAG,YAAY;AACxC,MAAMC,cAAc,GAAG,WAAW;AAClC,MAAMC,aAAa,GAAG,QAAQ;AAC9B,MAAMC,WAAW,GAAG,YAAY;AAChC,MAAMC,kBAAkB,GAAG,eAAe;AAC1C,MAAMC,YAAY,GAAG,SAAS;AAC9B,MAAMC,KAAK,SAAS3+F,UAAU,CAAC;EAC7B4C,KAAKA,CAACC,QAAQ,EAAEC,MAAM,EAAE;IACtB,MAAMhoC,OAAO,GAAG,IAAI8jI,eAAe,CAAC,CAAC;IACrC,MAAMC,UAAU,GAAG,EAAE;IACrBh8F,QAAQ,CAACvtC,OAAO,CAAC+E,OAAO,IAAI;MAC1B,IAAIykI,WAAW,GAAG,EAAE;MACpBzkI,OAAO,CAACwrB,OAAO,CAACvwB,OAAO,CAACk0B,MAAM,IAAI;QAChC,IAAIu1G,eAAe,GAAG,IAAIj9F,GAAG,CAAC28F,kBAAkB,EAAE;UAChDO,OAAO,EAAE;QACX,CAAC,CAAC;QACFD,eAAe,CAACrjI,QAAQ,CAACrI,IAAI,CAAC,IAAI4uC,EAAE,CAAC,EAAE,CAAC,EAAE,IAAIH,GAAG,CAAC48F,YAAY,EAAE;UAC9D,cAAc,EAAE;QAClB,CAAC,EAAE,CAAC,IAAI38F,MAAM,CAACvY,MAAM,CAACsV,QAAQ,CAAC,CAAC,CAAC,EAAE,IAAImD,EAAE,CAAC,EAAE,CAAC,EAAE,IAAIH,GAAG,CAAC48F,YAAY,EAAE;UACnE,cAAc,EAAE;QAClB,CAAC,EAAE,CAAC,IAAI38F,MAAM,CAAC,GAAGvY,MAAM,CAACuV,SAAS,EAAE,CAAC,CAAC,CAAC,EAAE,IAAIkD,EAAE,CAAC,CAAC,CAAC,CAAC;QACnD68F,WAAW,CAACzrI,IAAI,CAAC,IAAI4uC,EAAE,CAAC,CAAC,CAAC,EAAE88F,eAAe,CAAC;MAC9C,CAAC,CAAC;MACF,MAAME,SAAS,GAAG,IAAIn9F,GAAG,CAAC08F,WAAW,EAAE;QACrClkI,EAAE,EAAED,OAAO,CAACC,EAAE;QACd4kI,QAAQ,EAAE;MACZ,CAAC,CAAC;MACFD,SAAS,CAACvjI,QAAQ,CAACrI,IAAI,CAAC,IAAI4uC,EAAE,CAAC,CAAC,CAAC,EAAE,IAAIH,GAAG,CAACs8F,aAAa,EAAE,CAAC,CAAC,EAAEtjI,OAAO,CAACsoC,SAAS,CAAC/oC,OAAO,CAACK,KAAK,CAAC,CAAC,EAAE,GAAGokI,WAAW,CAAC;MAChH,IAAIzkI,OAAO,CAACgQ,WAAW,EAAE;QACvB40H,SAAS,CAACvjI,QAAQ,CAACrI,IAAI,CAAC,IAAI4uC,EAAE,CAAC,CAAC,CAAC,EAAE,IAAIH,GAAG,CAAC,MAAM,EAAE;UACjDq9F,QAAQ,EAAE,GAAG;UACbr5G,IAAI,EAAE;QACR,CAAC,EAAE,CAAC,IAAIic,MAAM,CAAC1nC,OAAO,CAACgQ,WAAW,CAAC,CAAC,CAAC,CAAC;MACxC;MACA,IAAIhQ,OAAO,CAACM,OAAO,EAAE;QACnBskI,SAAS,CAACvjI,QAAQ,CAACrI,IAAI,CAAC,IAAI4uC,EAAE,CAAC,CAAC,CAAC,EAAE,IAAIH,GAAG,CAAC,MAAM,EAAE;UACjDq9F,QAAQ,EAAE,GAAG;UACbr5G,IAAI,EAAE;QACR,CAAC,EAAE,CAAC,IAAIic,MAAM,CAAC1nC,OAAO,CAACM,OAAO,CAAC,CAAC,CAAC,CAAC;MACpC;MACAskI,SAAS,CAACvjI,QAAQ,CAACrI,IAAI,CAAC,IAAI4uC,EAAE,CAAC,CAAC,CAAC,CAAC;MAClC48F,UAAU,CAACxrI,IAAI,CAAC,IAAI4uC,EAAE,CAAC,CAAC,CAAC,EAAEg9F,SAAS,CAAC;IACvC,CAAC,CAAC;IACF,MAAMv2H,IAAI,GAAG,IAAIo5B,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,GAAG+8F,UAAU,EAAE,IAAI58F,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5D,MAAMpd,IAAI,GAAG,IAAIid,GAAG,CAAC,MAAM,EAAE;MAC3B,iBAAiB,EAAEgB,MAAM,IAAIk7F,sBAAsB;MACnDkB,QAAQ,EAAE,WAAW;MACrBrsH,QAAQ,EAAE;IACZ,CAAC,EAAE,CAAC,IAAIovB,EAAE,CAAC,CAAC,CAAC,EAAEv5B,IAAI,EAAE,IAAIu5B,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAChC,MAAMm9F,KAAK,GAAG,IAAIt9F,GAAG,CAAC,OAAO,EAAE;MAC7Bvd,OAAO,EAAEu5G,UAAU;MACnBuB,KAAK,EAAEtB;IACT,CAAC,EAAE,CAAC,IAAI97F,EAAE,CAAC,CAAC,CAAC,EAAEpd,IAAI,EAAE,IAAIod,EAAE,CAAC,CAAC,CAAC,CAAC;IAC/B,OAAOR,WAAW,CAAC,CAAC,IAAIC,WAAW,CAAC;MAClCnd,OAAO,EAAE,KAAK;MACd8e,QAAQ,EAAE;IACZ,CAAC,CAAC,EAAE,IAAIpB,EAAE,CAAC,CAAC,EAAEm9F,KAAK,EAAE,IAAIn9F,EAAE,CAAC,CAAC,CAAC,CAAC;EACjC;EACAsB,IAAIA,CAACpe,OAAO,EAAEtZ,GAAG,EAAE;IACjB,MAAMyzH,WAAW,GAAG,IAAIC,WAAW,CAAC,CAAC;IACrC,MAAM;MACJz8F,MAAM;MACN08F,WAAW;MACXlrG;IACF,CAAC,GAAGgrG,WAAW,CAACxsI,KAAK,CAACqyB,OAAO,EAAEtZ,GAAG,CAAC;IACnC,MAAM4zH,gBAAgB,GAAG,CAAC,CAAC;IAC3B,MAAMlvF,SAAS,GAAG,IAAImvF,WAAW,CAAC,CAAC;IACnC9lI,MAAM,CAACmC,IAAI,CAACyjI,WAAW,CAAC,CAAClqI,OAAO,CAACqqI,KAAK,IAAI;MACxC,MAAM;QACJC,SAAS;QACTtrG,MAAM,EAAE32B;MACV,CAAC,GAAG4yC,SAAS,CAACsvF,OAAO,CAACL,WAAW,CAACG,KAAK,CAAC,EAAE9zH,GAAG,CAAC;MAC9CyoB,MAAM,CAACjhC,IAAI,CAAC,GAAGsK,CAAC,CAAC;MACjB8hI,gBAAgB,CAACE,KAAK,CAAC,GAAGC,SAAS;IACrC,CAAC,CAAC;IACF,IAAItrG,MAAM,CAAClhC,MAAM,EAAE;MACjB,MAAM,IAAIQ,KAAK,CAAC,wBAAwB0gC,MAAM,CAACt/B,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;IAC9D;IACA,OAAO;MACL8tC,MAAM,EAAEA,MAAM;MACd28F;IACF,CAAC;EACH;EACAj8F,MAAMA,CAACnpC,OAAO,EAAE;IACd,OAAOD,QAAQ,CAACC,OAAO,CAAC;EAC1B;AACF;AACA,IAAIukI,eAAe,GAAG,MAAMkB,aAAa,CAAC;EACxCzkI,SAASA,CAACC,IAAI,EAAEC,OAAO,EAAE;IACvB,OAAO,CAAC,IAAIwmC,MAAM,CAACzmC,IAAI,CAACnG,KAAK,CAAC,CAAC;EACjC;EACAqG,cAAcA,CAACC,SAAS,EAAEF,OAAO,EAAE;IACjC,MAAMb,KAAK,GAAG,EAAE;IAChBe,SAAS,CAACC,QAAQ,CAACpG,OAAO,CAACuS,IAAI,IAAInN,KAAK,CAACrH,IAAI,CAAC,GAAGwU,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;IACnE,OAAOR,KAAK;EACd;EACAkB,QAAQA,CAACC,GAAG,EAAEN,OAAO,EAAE;IACrB,MAAMb,KAAK,GAAG,CAAC,IAAIqnC,MAAM,CAAC,IAAIlmC,GAAG,CAACwjC,qBAAqB,KAAKxjC,GAAG,CAACM,IAAI,IAAI,CAAC,CAAC;IAC1EvC,MAAM,CAACmC,IAAI,CAACF,GAAG,CAACG,KAAK,CAAC,CAAC1G,OAAO,CAACmI,CAAC,IAAI;MAClC/C,KAAK,CAACrH,IAAI,CAAC,IAAI0uC,MAAM,CAAC,GAAGtkC,CAAC,IAAI,CAAC,EAAE,GAAG5B,GAAG,CAACG,KAAK,CAACyB,CAAC,CAAC,CAACvC,KAAK,CAAC,IAAI,CAAC,EAAE,IAAI6mC,MAAM,CAAC,IAAI,CAAC,CAAC;IACjF,CAAC,CAAC;IACFrnC,KAAK,CAACrH,IAAI,CAAC,IAAI0uC,MAAM,CAAC,GAAG,CAAC,CAAC;IAC3B,OAAOrnC,KAAK;EACd;EACA0B,mBAAmBA,CAACC,EAAE,EAAEd,OAAO,EAAE;IAC/B,MAAMwkI,KAAK,GAAGC,cAAc,CAAC3jI,EAAE,CAACxI,GAAG,CAAC;IACpC,IAAIwI,EAAE,CAACC,MAAM,EAAE;MACb,OAAO,CAAC,IAAIwlC,GAAG,CAACm8F,kBAAkB,EAAE;QAClC3jI,EAAE,EAAE+B,EAAE,CAACE,SAAS;QAChBwjI,KAAK;QACL,YAAY,EAAE,IAAI1jI,EAAE,CAACxI,GAAG;MAC1B,CAAC,CAAC,CAAC;IACL;IACA,MAAM8vC,UAAU,GAAG,IAAI7B,GAAG,CAACm8F,kBAAkB,EAAE;MAC7C3jI,EAAE,EAAE+B,EAAE,CAACE,SAAS;MAChBwjI,KAAK;MACL,YAAY,EAAE,IAAI1jI,EAAE,CAACxI,GAAG;IAC1B,CAAC,CAAC;IACF,MAAMiwC,UAAU,GAAG,IAAIhC,GAAG,CAACm8F,kBAAkB,EAAE;MAC7C3jI,EAAE,EAAE+B,EAAE,CAACG,SAAS;MAChBujI,KAAK;MACL,YAAY,EAAE,KAAK1jI,EAAE,CAACxI,GAAG;IAC3B,CAAC,CAAC;IACF,OAAO,CAAC8vC,UAAU,EAAE,GAAG,IAAI,CAACP,SAAS,CAAC/mC,EAAE,CAACX,QAAQ,CAAC,EAAEooC,UAAU,CAAC;EACjE;EACArnC,gBAAgBA,CAACJ,EAAE,EAAEd,OAAO,EAAE;IAC5B,OAAO,CAAC,IAAIumC,GAAG,CAACm8F,kBAAkB,EAAE;MAClC3jI,EAAE,EAAE+B,EAAE,CAACnH,IAAI;MACX,YAAY,EAAE,KAAKmH,EAAE,CAAClH,KAAK;IAC7B,CAAC,CAAC,CAAC;EACL;EACAwH,qBAAqBA,CAACN,EAAE,EAAEd,OAAO,EAAE;IACjC,MAAMwkI,KAAK,GAAG,KAAK1jI,EAAE,CAACnH,IAAI,CAACE,WAAW,CAAC,CAAC,CAACR,OAAO,CAAC,YAAY,EAAE,GAAG,CAAC,EAAE;IACrE,MAAM+uC,UAAU,GAAG,IAAI7B,GAAG,CAACm8F,kBAAkB,EAAE;MAC7C3jI,EAAE,EAAE+B,EAAE,CAACE,SAAS;MAChBwjI,KAAK;MACL,YAAY,EAAE,IAAI1jI,EAAE,CAACnH,IAAI;IAC3B,CAAC,CAAC;IACF,MAAM4uC,UAAU,GAAG,IAAIhC,GAAG,CAACm8F,kBAAkB,EAAE;MAC7C3jI,EAAE,EAAE+B,EAAE,CAACG,SAAS;MAChBujI,KAAK;MACL,YAAY,EAAE;IAChB,CAAC,CAAC;IACF,OAAO,CAACp8F,UAAU,EAAE,GAAG,IAAI,CAACP,SAAS,CAAC/mC,EAAE,CAACX,QAAQ,CAAC,EAAEooC,UAAU,CAAC;EACjE;EACApnC,mBAAmBA,CAACL,EAAE,EAAEd,OAAO,EAAE;IAC/B,MAAM0kI,SAAS,GAAG,IAAI5jI,EAAE,CAAClH,KAAK,CAAC+G,UAAU,KAAKG,EAAE,CAAClH,KAAK,CAACgH,IAAI,KAAKvC,MAAM,CAACmC,IAAI,CAACM,EAAE,CAAClH,KAAK,CAAC6G,KAAK,CAAC,CAACzE,GAAG,CAACpC,KAAK,IAAIA,KAAK,GAAG,QAAQ,CAAC,CAACH,IAAI,CAAC,GAAG,CAAC,GAAG;IACvI,OAAO,CAAC,IAAI8sC,GAAG,CAACm8F,kBAAkB,EAAE;MAClC3jI,EAAE,EAAE+B,EAAE,CAACnH,IAAI;MACX,YAAY,EAAE+qI;IAChB,CAAC,CAAC,CAAC;EACL;EACA78F,SAASA,CAAC1oC,KAAK,EAAE;IACf,OAAO,EAAE,CAACzF,MAAM,CAAC,GAAGyF,KAAK,CAACnD,GAAG,CAACsQ,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;EAC1D;AACF,CAAC;AACD,MAAMqkI,WAAW,CAAC;EAChBW,aAAa;EACbxtC,OAAO;EACPytC,YAAY;EACZC,OAAO,GAAG,IAAI;EACdttI,KAAKA,CAACssI,KAAK,EAAEvzH,GAAG,EAAE;IAChB,IAAI,CAACq0H,aAAa,GAAG,IAAI;IACzB,IAAI,CAACC,YAAY,GAAG,CAAC,CAAC;IACtB,MAAME,GAAG,GAAG,IAAIxC,SAAS,CAAC,CAAC,CAAC/qI,KAAK,CAACssI,KAAK,EAAEvzH,GAAG,CAAC;IAC7C,IAAI,CAAC6mF,OAAO,GAAG2tC,GAAG,CAAC/rG,MAAM;IACzBI,QAAQ,CAAC,IAAI,EAAE2rG,GAAG,CAAChvD,SAAS,EAAE,IAAI,CAAC;IACnC,OAAO;MACLmuD,WAAW,EAAE,IAAI,CAACW,YAAY;MAC9B7rG,MAAM,EAAE,IAAI,CAACo+D,OAAO;MACpB5vD,MAAM,EAAE,IAAI,CAACs9F;IACf,CAAC;EACH;EACA7nG,YAAYA,CAAC7lC,OAAO,EAAE6I,OAAO,EAAE;IAC7B,QAAQ7I,OAAO,CAACwC,IAAI;MAClB,KAAKspI,WAAW;QACd,IAAI,CAAC0B,aAAa,GAAG,IAAI;QACzB,MAAMI,MAAM,GAAG5tI,OAAO,CAACE,KAAK,CAACi0C,IAAI,CAACxyC,IAAI,IAAIA,IAAI,CAACa,IAAI,KAAK,IAAI,CAAC;QAC7D,IAAI,CAACorI,MAAM,EAAE;UACX,IAAI,CAACC,SAAS,CAAC7tI,OAAO,EAAE,IAAI8rI,WAAW,6BAA6B,CAAC;QACvE,CAAC,MAAM;UACL,MAAMlkI,EAAE,GAAGgmI,MAAM,CAACnrI,KAAK;UACvB,IAAI,IAAI,CAACgrI,YAAY,CAAC1/F,cAAc,CAACnmC,EAAE,CAAC,EAAE;YACxC,IAAI,CAACimI,SAAS,CAAC7tI,OAAO,EAAE,mCAAmC4H,EAAE,EAAE,CAAC;UAClE,CAAC,MAAM;YACLo6B,QAAQ,CAAC,IAAI,EAAEhiC,OAAO,CAACgJ,QAAQ,EAAE,IAAI,CAAC;YACtC,IAAI,OAAO,IAAI,CAACwkI,aAAa,KAAK,QAAQ,EAAE;cAC1C,IAAI,CAACC,YAAY,CAAC7lI,EAAE,CAAC,GAAG,IAAI,CAAC4lI,aAAa;YAC5C,CAAC,MAAM;cACL,IAAI,CAACK,SAAS,CAAC7tI,OAAO,EAAE,WAAW4H,EAAE,uBAAuB,CAAC;YAC/D;UACF;QACF;QACA;MACF,KAAK8jI,aAAa;MAClB,KAAKC,mBAAmB;MACxB,KAAKC,cAAc;QACjB;MACF,KAAKC,aAAa;QAChB,MAAMiC,cAAc,GAAG9tI,OAAO,CAAC2lC,eAAe,CAAC54B,GAAG,CAACmtC,MAAM;QACzD,MAAM6zF,YAAY,GAAG/tI,OAAO,CAAC4lC,aAAa,CAAC7O,KAAK,CAACmjB,MAAM;QACvD,MAAMznB,OAAO,GAAGzyB,OAAO,CAAC2lC,eAAe,CAAC5O,KAAK,CAAC5E,IAAI,CAACM,OAAO;QAC1D,MAAMu7G,SAAS,GAAGv7G,OAAO,CAACnxB,KAAK,CAACwsI,cAAc,EAAEC,YAAY,CAAC;QAC7D,IAAI,CAACP,aAAa,GAAGQ,SAAS;QAC9B;MACF,KAAKvC,SAAS;QACZ,MAAMwC,UAAU,GAAGjuI,OAAO,CAACE,KAAK,CAACi0C,IAAI,CAACxyC,IAAI,IAAIA,IAAI,CAACa,IAAI,KAAK,iBAAiB,CAAC;QAC9E,IAAIyrI,UAAU,EAAE;UACd,IAAI,CAACP,OAAO,GAAGO,UAAU,CAACxrI,KAAK;QACjC;QACAu/B,QAAQ,CAAC,IAAI,EAAEhiC,OAAO,CAACgJ,QAAQ,EAAE,IAAI,CAAC;QACtC;MACF;QACEg5B,QAAQ,CAAC,IAAI,EAAEhiC,OAAO,CAACgJ,QAAQ,EAAE,IAAI,CAAC;IAC1C;EACF;EACAyoE,cAAcA,CAAChwE,SAAS,EAAEoH,OAAO,EAAE,CAAC;EACpCF,SAASA,CAACC,IAAI,EAAEC,OAAO,EAAE,CAAC;EAC1B6oE,YAAYA,CAAC95C,OAAO,EAAE/uB,OAAO,EAAE,CAAC;EAChCsoE,cAAcA,CAACmU,SAAS,EAAEz8E,OAAO,EAAE,CAAC;EACpC0oE,kBAAkBA,CAACiU,aAAa,EAAE38E,OAAO,EAAE,CAAC;EAC5C+oE,UAAUA,CAAClmC,KAAK,EAAE7iC,OAAO,EAAE,CAAC;EAC5BipE,mBAAmBA,CAAC6T,SAAS,EAAE98E,OAAO,EAAE,CAAC;EACzCkhC,mBAAmBA,CAACgC,IAAI,EAAEljC,OAAO,EAAE,CAAC;EACpCqhC,cAAcA,CAAC0B,SAAS,EAAE/iC,OAAO,EAAE,CAAC;EACpCuhC,cAAcA,CAACyB,SAAS,EAAEhjC,OAAO,EAAE,CAAC;EACpCglI,SAASA,CAAC14H,IAAI,EAAExN,OAAO,EAAE;IACvB,IAAI,CAACq4F,OAAO,CAACr/F,IAAI,CAAC,IAAI66C,UAAU,CAACrmC,IAAI,CAACvE,UAAU,EAAEjJ,OAAO,CAAC,CAAC;EAC7D;AACF;AACA,IAAIqlI,WAAW,GAAG,MAAMkB,SAAS,CAAC;EAChCluC,OAAO;EACPmtC,OAAOA,CAACxlI,OAAO,EAAEwR,GAAG,EAAE;IACpB,MAAMg1H,MAAM,GAAG,IAAIhD,SAAS,CAAC,CAAC,CAAC/qI,KAAK,CAACuH,OAAO,EAAEwR,GAAG,EAAE;MACjDi7D,sBAAsB,EAAE;IAC1B,CAAC,CAAC;IACF,IAAI,CAAC4rB,OAAO,GAAGmuC,MAAM,CAACvsG,MAAM;IAC5B,MAAMsrG,SAAS,GAAG,IAAI,CAACltC,OAAO,CAACt/F,MAAM,GAAG,CAAC,IAAIytI,MAAM,CAACxvD,SAAS,CAACj+E,MAAM,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC6B,MAAM,CAAC,GAAGy/B,QAAQ,CAAC,IAAI,EAAEmsG,MAAM,CAACxvD,SAAS,CAAC,CAAC;IAC/H,OAAO;MACLuuD,SAAS,EAAEA,SAAS;MACpBtrG,MAAM,EAAE,IAAI,CAACo+D;IACf,CAAC;EACH;EACAr3F,SAASA,CAACC,IAAI,EAAEC,OAAO,EAAE;IACvB,OAAO,IAAI4jC,MAAM,CAAC7jC,IAAI,CAACnG,KAAK,EAAEmG,IAAI,CAACgI,UAAU,CAAC;EAChD;EACAi1B,YAAYA,CAACpvB,EAAE,EAAE5N,OAAO,EAAE;IACxB,IAAI4N,EAAE,CAACjU,IAAI,KAAK+oI,kBAAkB,EAAE;MAClC,MAAM6C,QAAQ,GAAG33H,EAAE,CAACvW,KAAK,CAACi0C,IAAI,CAACxyC,IAAI,IAAIA,IAAI,CAACa,IAAI,KAAK,IAAI,CAAC;MAC1D,IAAI4rI,QAAQ,EAAE;QACZ,OAAO,IAAIvhG,WAAW,CAAC,EAAE,EAAEuhG,QAAQ,CAAC3rI,KAAK,EAAEgU,EAAE,CAAC7F,UAAU,CAAC;MAC3D;MACA,IAAI,CAACi9H,SAAS,CAACp3H,EAAE,EAAE,IAAI80H,kBAAkB,6BAA6B,CAAC;MACvE,OAAO,IAAI;IACb;IACA,IAAI90H,EAAE,CAACjU,IAAI,KAAKgpI,aAAa,EAAE;MAC7B,OAAO,EAAE,CAACjpI,MAAM,CAAC,GAAGy/B,QAAQ,CAAC,IAAI,EAAEvrB,EAAE,CAACzN,QAAQ,CAAC,CAAC;IAClD;IACA,IAAI,CAAC6kI,SAAS,CAACp3H,EAAE,EAAE,gBAAgB,CAAC;IACpC,OAAO,IAAI;EACb;EACA06D,cAAcA,CAAChoE,GAAG,EAAEN,OAAO,EAAE;IAC3B,MAAMwlI,OAAO,GAAG,CAAC,CAAC;IAClBrsG,QAAQ,CAAC,IAAI,EAAE74B,GAAG,CAACG,KAAK,CAAC,CAAC1G,OAAO,CAACmI,CAAC,IAAI;MACrCsjI,OAAO,CAACtjI,CAAC,CAACtI,KAAK,CAAC,GAAG,IAAIiqC,SAAS,CAAC3hC,CAAC,CAAC/C,KAAK,EAAEmB,GAAG,CAACyH,UAAU,CAAC;IAC3D,CAAC,CAAC;IACF,OAAO,IAAIo6B,GAAG,CAAC7hC,GAAG,CAAC8nE,WAAW,EAAE9nE,GAAG,CAACM,IAAI,EAAE4kI,OAAO,EAAEllI,GAAG,CAACyH,UAAU,CAAC;EACpE;EACA2gE,kBAAkBA,CAAC62D,OAAO,EAAEv/H,OAAO,EAAE;IACnC,OAAO;MACLpG,KAAK,EAAE2lI,OAAO,CAAC3lI,KAAK;MACpBuF,KAAK,EAAEg6B,QAAQ,CAAC,IAAI,EAAEomG,OAAO,CAAC5+H,UAAU;IAC1C,CAAC;EACH;EACAkoE,YAAYA,CAAC95C,OAAO,EAAE/uB,OAAO,EAAE,CAAC;EAChC4oE,cAAcA,CAAChwE,SAAS,EAAEoH,OAAO,EAAE,CAAC;EACpC+oE,UAAUA,CAAClmC,KAAK,EAAE7iC,OAAO,EAAE,CAAC;EAC5BipE,mBAAmBA,CAAC6T,SAAS,EAAE98E,OAAO,EAAE,CAAC;EACzCkhC,mBAAmBA,CAACgC,IAAI,EAAEljC,OAAO,EAAE,CAAC;EACpCqhC,cAAcA,CAAC0B,SAAS,EAAE/iC,OAAO,EAAE;IACjC,IAAI,CAACglI,SAAS,CAACjiG,SAAS,EAAE,iBAAiB,CAAC;EAC9C;EACAxB,cAAcA,CAACyB,SAAS,EAAEhjC,OAAO,EAAE;IACjC,IAAI,CAACglI,SAAS,CAAChiG,SAAS,EAAE,iBAAiB,CAAC;EAC9C;EACAgiG,SAASA,CAAC14H,IAAI,EAAExN,OAAO,EAAE;IACvB,IAAI,CAACq4F,OAAO,CAACr/F,IAAI,CAAC,IAAI66C,UAAU,CAACrmC,IAAI,CAACvE,UAAU,EAAEjJ,OAAO,CAAC,CAAC;EAC7D;AACF,CAAC;AACD,SAAS2lI,cAAcA,CAACnsI,GAAG,EAAE;EAC3B,QAAQA,GAAG,CAACuB,WAAW,CAAC,CAAC;IACvB,KAAK,IAAI;MACP,OAAO,IAAI;IACb,KAAK,KAAK;MACR,OAAO,OAAO;IAChB;MACE,OAAO,KAAKvB,GAAG,EAAE;EACrB;AACF;AAEA,MAAMmtI,QAAQ,GAAG,KAAK;AACtB,MAAMC,MAAM,GAAG,uCAAuC;AACtD,MAAMC,oBAAoB,GAAG,IAAI;AACjC,MAAMC,kBAAkB,GAAG,IAAI;AAC/B,MAAMC,yBAAyB,GAAG,IAAI;AACtC,MAAMC,WAAW,GAAG,KAAK;AACzB,MAAMC,UAAU,GAAG,OAAO;AAC1B,MAAMC,WAAW,GAAG,QAAQ;AAC5B,MAAMC,WAAW,GAAG,QAAQ;AAC5B,MAAMC,SAAS,GAAG,MAAM;AACxB,MAAMC,MAAM,SAAS1hG,UAAU,CAAC;EAC9B4C,KAAKA,CAACC,QAAQ,EAAEC,MAAM,EAAE;IACtB,MAAMhoC,OAAO,GAAG,IAAIglI,aAAa,CAAC,CAAC;IACnC,MAAMnrE,KAAK,GAAG,EAAE;IAChB9xB,QAAQ,CAACvtC,OAAO,CAAC+E,OAAO,IAAI;MAC1B,MAAMy7B,IAAI,GAAG,IAAIgM,GAAG,CAAC2/F,SAAS,EAAE;QAC9BnnI,EAAE,EAAED,OAAO,CAACC;MACd,CAAC,CAAC;MACF,MAAMqnI,KAAK,GAAG,IAAI7/F,GAAG,CAAC,OAAO,CAAC;MAC9B,IAAIznC,OAAO,CAACgQ,WAAW,IAAIhQ,OAAO,CAACM,OAAO,EAAE;QAC1C,IAAIN,OAAO,CAACgQ,WAAW,EAAE;UACvBs3H,KAAK,CAACjmI,QAAQ,CAACrI,IAAI,CAAC,IAAI4uC,EAAE,CAAC,CAAC,CAAC,EAAE,IAAIH,GAAG,CAAC,MAAM,EAAE;YAC7C8/F,QAAQ,EAAE;UACZ,CAAC,EAAE,CAAC,IAAI7/F,MAAM,CAAC1nC,OAAO,CAACgQ,WAAW,CAAC,CAAC,CAAC,CAAC;QACxC;QACA,IAAIhQ,OAAO,CAACM,OAAO,EAAE;UACnBgnI,KAAK,CAACjmI,QAAQ,CAACrI,IAAI,CAAC,IAAI4uC,EAAE,CAAC,CAAC,CAAC,EAAE,IAAIH,GAAG,CAAC,MAAM,EAAE;YAC7C8/F,QAAQ,EAAE;UACZ,CAAC,EAAE,CAAC,IAAI7/F,MAAM,CAAC1nC,OAAO,CAACM,OAAO,CAAC,CAAC,CAAC,CAAC;QACpC;MACF;MACAN,OAAO,CAACwrB,OAAO,CAACvwB,OAAO,CAACk0B,MAAM,IAAI;QAChCm4G,KAAK,CAACjmI,QAAQ,CAACrI,IAAI,CAAC,IAAI4uC,EAAE,CAAC,CAAC,CAAC,EAAE,IAAIH,GAAG,CAAC,MAAM,EAAE;UAC7C8/F,QAAQ,EAAE;QACZ,CAAC,EAAE,CAAC,IAAI7/F,MAAM,CAAC,GAAGvY,MAAM,CAACsV,QAAQ,IAAItV,MAAM,CAACuV,SAAS,GAAGvV,MAAM,CAACyV,OAAO,KAAKzV,MAAM,CAACuV,SAAS,GAAG,GAAG,GAAGvV,MAAM,CAACyV,OAAO,GAAG,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;MAC/H,CAAC,CAAC;MACF0iG,KAAK,CAACjmI,QAAQ,CAACrI,IAAI,CAAC,IAAI4uC,EAAE,CAAC,CAAC,CAAC,CAAC;MAC9BnM,IAAI,CAACp6B,QAAQ,CAACrI,IAAI,CAAC,IAAI4uC,EAAE,CAAC,CAAC,CAAC,EAAE0/F,KAAK,CAAC;MACpC,MAAMv7G,OAAO,GAAG,IAAI0b,GAAG,CAAC,SAAS,CAAC;MAClC1b,OAAO,CAAC1qB,QAAQ,CAACrI,IAAI,CAAC,IAAI4uC,EAAE,CAAC,CAAC,CAAC,EAAE,IAAIH,GAAG,CAACy/F,WAAW,EAAE,CAAC,CAAC,EAAEzmI,OAAO,CAACsoC,SAAS,CAAC/oC,OAAO,CAACK,KAAK,CAAC,CAAC,EAAE,IAAIunC,EAAE,CAAC,CAAC,CAAC,CAAC;MACvGnM,IAAI,CAACp6B,QAAQ,CAACrI,IAAI,CAAC,IAAI4uC,EAAE,CAAC,CAAC,CAAC,EAAE7b,OAAO,EAAE,IAAI6b,EAAE,CAAC,CAAC,CAAC,CAAC;MACjD0yB,KAAK,CAACthE,IAAI,CAAC,IAAI4uC,EAAE,CAAC,CAAC,CAAC,EAAEnM,IAAI,CAAC;IAC7B,CAAC,CAAC;IACF,MAAMjR,IAAI,GAAG,IAAIid,GAAG,CAAC,MAAM,EAAE;MAC3B,UAAU,EAAE,aAAa;MACzBxnC,EAAE,EAAE;IACN,CAAC,EAAE,CAAC,GAAGq6D,KAAK,EAAE,IAAI1yB,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IACzB,MAAMm9F,KAAK,GAAG,IAAIt9F,GAAG,CAACw/F,UAAU,EAAE;MAChC/8G,OAAO,EAAEy8G,QAAQ;MACjB3B,KAAK,EAAE4B,MAAM;MACbY,OAAO,EAAE/+F,MAAM,IAAIo+F;IACrB,CAAC,EAAE,CAAC,IAAIj/F,EAAE,CAAC,CAAC,CAAC,EAAEpd,IAAI,EAAE,IAAIod,EAAE,CAAC,CAAC,CAAC,CAAC;IAC/B,OAAOR,WAAW,CAAC,CAAC,IAAIC,WAAW,CAAC;MAClCnd,OAAO,EAAE,KAAK;MACd8e,QAAQ,EAAE;IACZ,CAAC,CAAC,EAAE,IAAIpB,EAAE,CAAC,CAAC,EAAEm9F,KAAK,EAAE,IAAIn9F,EAAE,CAAC,CAAC,CAAC,CAAC;EACjC;EACAsB,IAAIA,CAACpe,OAAO,EAAEtZ,GAAG,EAAE;IACjB,MAAMi2H,YAAY,GAAG,IAAIC,YAAY,CAAC,CAAC;IACvC,MAAM;MACJj/F,MAAM;MACN08F,WAAW;MACXlrG;IACF,CAAC,GAAGwtG,YAAY,CAAChvI,KAAK,CAACqyB,OAAO,EAAEtZ,GAAG,CAAC;IACpC,MAAM4zH,gBAAgB,GAAG,CAAC,CAAC;IAC3B,MAAMlvF,SAAS,GAAG,IAAIyxF,WAAW,CAAC,CAAC;IACnCpoI,MAAM,CAACmC,IAAI,CAACyjI,WAAW,CAAC,CAAClqI,OAAO,CAACqqI,KAAK,IAAI;MACxC,MAAM;QACJC,SAAS;QACTtrG,MAAM,EAAE32B;MACV,CAAC,GAAG4yC,SAAS,CAACsvF,OAAO,CAACL,WAAW,CAACG,KAAK,CAAC,EAAE9zH,GAAG,CAAC;MAC9CyoB,MAAM,CAACjhC,IAAI,CAAC,GAAGsK,CAAC,CAAC;MACjB8hI,gBAAgB,CAACE,KAAK,CAAC,GAAGC,SAAS;IACrC,CAAC,CAAC;IACF,IAAItrG,MAAM,CAAClhC,MAAM,EAAE;MACjB,MAAM,IAAIQ,KAAK,CAAC,yBAAyB0gC,MAAM,CAACt/B,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;IAC/D;IACA,OAAO;MACL8tC,MAAM,EAAEA,MAAM;MACd28F;IACF,CAAC;EACH;EACAj8F,MAAMA,CAACnpC,OAAO,EAAE;IACd,OAAOO,aAAa,CAACP,OAAO,CAAC;EAC/B;AACF;AACA,MAAMylI,aAAa,CAAC;EAClBmC,kBAAkB,GAAG,CAAC;EACtB5mI,SAASA,CAACC,IAAI,EAAEC,OAAO,EAAE;IACvB,OAAO,CAAC,IAAIwmC,MAAM,CAACzmC,IAAI,CAACnG,KAAK,CAAC,CAAC;EACjC;EACAqG,cAAcA,CAACC,SAAS,EAAEF,OAAO,EAAE;IACjC,MAAMb,KAAK,GAAG,EAAE;IAChBe,SAAS,CAACC,QAAQ,CAACpG,OAAO,CAACuS,IAAI,IAAInN,KAAK,CAACrH,IAAI,CAAC,GAAGwU,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;IACnE,OAAOR,KAAK;EACd;EACAkB,QAAQA,CAACC,GAAG,EAAEN,OAAO,EAAE;IACrB,MAAMb,KAAK,GAAG,CAAC,IAAIqnC,MAAM,CAAC,IAAIlmC,GAAG,CAACwjC,qBAAqB,KAAKxjC,GAAG,CAACM,IAAI,IAAI,CAAC,CAAC;IAC1EvC,MAAM,CAACmC,IAAI,CAACF,GAAG,CAACG,KAAK,CAAC,CAAC1G,OAAO,CAACmI,CAAC,IAAI;MAClC/C,KAAK,CAACrH,IAAI,CAAC,IAAI0uC,MAAM,CAAC,GAAGtkC,CAAC,IAAI,CAAC,EAAE,GAAG5B,GAAG,CAACG,KAAK,CAACyB,CAAC,CAAC,CAACvC,KAAK,CAAC,IAAI,CAAC,EAAE,IAAI6mC,MAAM,CAAC,IAAI,CAAC,CAAC;IACjF,CAAC,CAAC;IACFrnC,KAAK,CAACrH,IAAI,CAAC,IAAI0uC,MAAM,CAAC,GAAG,CAAC,CAAC;IAC3B,OAAOrnC,KAAK;EACd;EACA0B,mBAAmBA,CAACC,EAAE,EAAEd,OAAO,EAAE;IAC/B,MAAMY,IAAI,GAAG+lI,aAAa,CAAC7lI,EAAE,CAACxI,GAAG,CAAC;IAClC,IAAIwI,EAAE,CAACC,MAAM,EAAE;MACb,MAAM6lI,KAAK,GAAG,IAAIrgG,GAAG,CAACq/F,kBAAkB,EAAE;QACxC7mI,EAAE,EAAE,CAAC,IAAI,CAAC2nI,kBAAkB,EAAE,EAAE5sI,QAAQ,CAAC,CAAC;QAC1C+sI,KAAK,EAAE/lI,EAAE,CAACE,SAAS;QACnBJ,IAAI,EAAEA,IAAI;QACVkmI,IAAI,EAAE,IAAIhmI,EAAE,CAACxI,GAAG;MAClB,CAAC,CAAC;MACF,OAAO,CAACsuI,KAAK,CAAC;IAChB;IACA,MAAMG,KAAK,GAAG,IAAIxgG,GAAG,CAACs/F,yBAAyB,EAAE;MAC/C9mI,EAAE,EAAE,CAAC,IAAI,CAAC2nI,kBAAkB,EAAE,EAAE5sI,QAAQ,CAAC,CAAC;MAC1CktI,UAAU,EAAElmI,EAAE,CAACE,SAAS;MACxBimI,QAAQ,EAAEnmI,EAAE,CAACG,SAAS;MACtBL,IAAI,EAAEA,IAAI;MACVsmI,SAAS,EAAE,IAAIpmI,EAAE,CAACxI,GAAG,GAAG;MACxB6uI,OAAO,EAAE,KAAKrmI,EAAE,CAACxI,GAAG;IACtB,CAAC,CAAC;IACF,MAAM6G,KAAK,GAAG,EAAE,CAACzF,MAAM,CAAC,GAAGoH,EAAE,CAACX,QAAQ,CAACnE,GAAG,CAACsQ,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;IACrE,IAAIR,KAAK,CAACtH,MAAM,EAAE;MAChBsH,KAAK,CAACpF,OAAO,CAACuS,IAAI,IAAIy6H,KAAK,CAAC5mI,QAAQ,CAACrI,IAAI,CAACwU,IAAI,CAAC,CAAC;IAClD,CAAC,MAAM;MACLy6H,KAAK,CAAC5mI,QAAQ,CAACrI,IAAI,CAAC,IAAI0uC,MAAM,CAAC,EAAE,CAAC,CAAC;IACrC;IACA,OAAO,CAACugG,KAAK,CAAC;EAChB;EACA7lI,gBAAgBA,CAACJ,EAAE,EAAEd,OAAO,EAAE;IAC5B,MAAMonI,KAAK,GAAG,CAAC,IAAI,CAACV,kBAAkB,EAAE,EAAE5sI,QAAQ,CAAC,CAAC;IACpD,OAAO,CAAC,IAAIysC,GAAG,CAACq/F,kBAAkB,EAAE;MAClC7mI,EAAE,EAAEqoI,KAAK;MACTP,KAAK,EAAE/lI,EAAE,CAACnH,IAAI;MACdmtI,IAAI,EAAE,KAAKhmI,EAAE,CAAClH,KAAK;IACrB,CAAC,CAAC,CAAC;EACL;EACAwH,qBAAqBA,CAACN,EAAE,EAAEd,OAAO,EAAE;IACjC,MAAM+mI,KAAK,GAAG,IAAIxgG,GAAG,CAACs/F,yBAAyB,EAAE;MAC/C9mI,EAAE,EAAE,CAAC,IAAI,CAAC2nI,kBAAkB,EAAE,EAAE5sI,QAAQ,CAAC,CAAC;MAC1CktI,UAAU,EAAElmI,EAAE,CAACE,SAAS;MACxBimI,QAAQ,EAAEnmI,EAAE,CAACG,SAAS;MACtBL,IAAI,EAAE,OAAO;MACbsmI,SAAS,EAAE,IAAIpmI,EAAE,CAACnH,IAAI,EAAE;MACxBwtI,OAAO,EAAE;IACX,CAAC,CAAC;IACF,MAAMhoI,KAAK,GAAG,EAAE,CAACzF,MAAM,CAAC,GAAGoH,EAAE,CAACX,QAAQ,CAACnE,GAAG,CAACsQ,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;IACrE,IAAIR,KAAK,CAACtH,MAAM,EAAE;MAChBsH,KAAK,CAACpF,OAAO,CAACuS,IAAI,IAAIy6H,KAAK,CAAC5mI,QAAQ,CAACrI,IAAI,CAACwU,IAAI,CAAC,CAAC;IAClD,CAAC,MAAM;MACLy6H,KAAK,CAAC5mI,QAAQ,CAACrI,IAAI,CAAC,IAAI0uC,MAAM,CAAC,EAAE,CAAC,CAAC;IACrC;IACA,OAAO,CAACugG,KAAK,CAAC;EAChB;EACA5lI,mBAAmBA,CAACL,EAAE,EAAEd,OAAO,EAAE;IAC/B,MAAMS,KAAK,GAAGpC,MAAM,CAACmC,IAAI,CAACM,EAAE,CAAClH,KAAK,CAAC6G,KAAK,CAAC,CAACzE,GAAG,CAACpC,KAAK,IAAIA,KAAK,GAAG,QAAQ,CAAC,CAACH,IAAI,CAAC,GAAG,CAAC;IAClF,MAAM2tI,KAAK,GAAG,CAAC,IAAI,CAACV,kBAAkB,EAAE,EAAE5sI,QAAQ,CAAC,CAAC;IACpD,OAAO,CAAC,IAAIysC,GAAG,CAACq/F,kBAAkB,EAAE;MAClC7mI,EAAE,EAAEqoI,KAAK;MACTP,KAAK,EAAE/lI,EAAE,CAACnH,IAAI;MACdmtI,IAAI,EAAE,IAAIhmI,EAAE,CAAClH,KAAK,CAAC+G,UAAU,KAAKG,EAAE,CAAClH,KAAK,CAACgH,IAAI,KAAKH,KAAK;IAC3D,CAAC,CAAC,CAAC;EACL;EACAonC,SAASA,CAAC1oC,KAAK,EAAE;IACf,IAAI,CAACunI,kBAAkB,GAAG,CAAC;IAC3B,OAAO,EAAE,CAAChtI,MAAM,CAAC,GAAGyF,KAAK,CAACnD,GAAG,CAACsQ,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;EAC1D;AACF;AACA,MAAM6mI,YAAY,CAAC;EACjB7B,aAAa;EACbxtC,OAAO;EACPytC,YAAY;EACZC,OAAO,GAAG,IAAI;EACdttI,KAAKA,CAACssI,KAAK,EAAEvzH,GAAG,EAAE;IAChB,IAAI,CAACq0H,aAAa,GAAG,IAAI;IACzB,IAAI,CAACC,YAAY,GAAG,CAAC,CAAC;IACtB,MAAME,GAAG,GAAG,IAAIxC,SAAS,CAAC,CAAC,CAAC/qI,KAAK,CAACssI,KAAK,EAAEvzH,GAAG,CAAC;IAC7C,IAAI,CAAC6mF,OAAO,GAAG2tC,GAAG,CAAC/rG,MAAM;IACzBI,QAAQ,CAAC,IAAI,EAAE2rG,GAAG,CAAChvD,SAAS,EAAE,IAAI,CAAC;IACnC,OAAO;MACLmuD,WAAW,EAAE,IAAI,CAACW,YAAY;MAC9B7rG,MAAM,EAAE,IAAI,CAACo+D,OAAO;MACpB5vD,MAAM,EAAE,IAAI,CAACs9F;IACf,CAAC;EACH;EACA7nG,YAAYA,CAAC7lC,OAAO,EAAE6I,OAAO,EAAE;IAC7B,QAAQ7I,OAAO,CAACwC,IAAI;MAClB,KAAKusI,SAAS;QACZ,IAAI,CAACvB,aAAa,GAAG,IAAI;QACzB,MAAMI,MAAM,GAAG5tI,OAAO,CAACE,KAAK,CAACi0C,IAAI,CAACxyC,IAAI,IAAIA,IAAI,CAACa,IAAI,KAAK,IAAI,CAAC;QAC7D,IAAI,CAACorI,MAAM,EAAE;UACX,IAAI,CAACC,SAAS,CAAC7tI,OAAO,EAAE,IAAI+uI,SAAS,6BAA6B,CAAC;QACrE,CAAC,MAAM;UACL,MAAMnnI,EAAE,GAAGgmI,MAAM,CAACnrI,KAAK;UACvB,IAAI,IAAI,CAACgrI,YAAY,CAAC1/F,cAAc,CAACnmC,EAAE,CAAC,EAAE;YACxC,IAAI,CAACimI,SAAS,CAAC7tI,OAAO,EAAE,mCAAmC4H,EAAE,EAAE,CAAC;UAClE,CAAC,MAAM;YACLo6B,QAAQ,CAAC,IAAI,EAAEhiC,OAAO,CAACgJ,QAAQ,EAAE,IAAI,CAAC;YACtC,IAAI,OAAO,IAAI,CAACwkI,aAAa,KAAK,QAAQ,EAAE;cAC1C,IAAI,CAACC,YAAY,CAAC7lI,EAAE,CAAC,GAAG,IAAI,CAAC4lI,aAAa;YAC5C,CAAC,MAAM;cACL,IAAI,CAACK,SAAS,CAAC7tI,OAAO,EAAE,WAAW4H,EAAE,uBAAuB,CAAC;YAC/D;UACF;QACF;QACA;MACF,KAAKinI,WAAW;QACd;MACF,KAAKC,WAAW;QACd,MAAMhB,cAAc,GAAG9tI,OAAO,CAAC2lC,eAAe,CAAC54B,GAAG,CAACmtC,MAAM;QACzD,MAAM6zF,YAAY,GAAG/tI,OAAO,CAAC4lC,aAAa,CAAC7O,KAAK,CAACmjB,MAAM;QACvD,MAAMznB,OAAO,GAAGzyB,OAAO,CAAC2lC,eAAe,CAAC5O,KAAK,CAAC5E,IAAI,CAACM,OAAO;QAC1D,MAAMu7G,SAAS,GAAGv7G,OAAO,CAACnxB,KAAK,CAACwsI,cAAc,EAAEC,YAAY,CAAC;QAC7D,IAAI,CAACP,aAAa,GAAGQ,SAAS;QAC9B;MACF,KAAKY,UAAU;QACb,MAAMX,UAAU,GAAGjuI,OAAO,CAACE,KAAK,CAACi0C,IAAI,CAACxyC,IAAI,IAAIA,IAAI,CAACa,IAAI,KAAK,SAAS,CAAC;QACtE,IAAIyrI,UAAU,EAAE;UACd,IAAI,CAACP,OAAO,GAAGO,UAAU,CAACxrI,KAAK;QACjC;QACA,MAAMytI,WAAW,GAAGlwI,OAAO,CAACE,KAAK,CAACi0C,IAAI,CAACxyC,IAAI,IAAIA,IAAI,CAACa,IAAI,KAAK,SAAS,CAAC;QACvE,IAAI0tI,WAAW,EAAE;UACf,MAAMr+G,OAAO,GAAGq+G,WAAW,CAACztI,KAAK;UACjC,IAAIovB,OAAO,KAAK,KAAK,EAAE;YACrB,IAAI,CAACg8G,SAAS,CAAC7tI,OAAO,EAAE,0BAA0B6xB,OAAO,8CAA8C,CAAC;UAC1G,CAAC,MAAM;YACLmQ,QAAQ,CAAC,IAAI,EAAEhiC,OAAO,CAACgJ,QAAQ,EAAE,IAAI,CAAC;UACxC;QACF;QACA;MACF;QACEg5B,QAAQ,CAAC,IAAI,EAAEhiC,OAAO,CAACgJ,QAAQ,EAAE,IAAI,CAAC;IAC1C;EACF;EACAyoE,cAAcA,CAAChwE,SAAS,EAAEoH,OAAO,EAAE,CAAC;EACpCF,SAASA,CAACC,IAAI,EAAEC,OAAO,EAAE,CAAC;EAC1B6oE,YAAYA,CAAC95C,OAAO,EAAE/uB,OAAO,EAAE,CAAC;EAChCsoE,cAAcA,CAACmU,SAAS,EAAEz8E,OAAO,EAAE,CAAC;EACpC0oE,kBAAkBA,CAACiU,aAAa,EAAE38E,OAAO,EAAE,CAAC;EAC5C+oE,UAAUA,CAAClmC,KAAK,EAAE7iC,OAAO,EAAE,CAAC;EAC5BipE,mBAAmBA,CAAC6T,SAAS,EAAE98E,OAAO,EAAE,CAAC;EACzCkhC,mBAAmBA,CAACgC,IAAI,EAAEljC,OAAO,EAAE,CAAC;EACpCqhC,cAAcA,CAAC0B,SAAS,EAAE/iC,OAAO,EAAE,CAAC;EACpCuhC,cAAcA,CAACyB,SAAS,EAAEhjC,OAAO,EAAE,CAAC;EACpCglI,SAASA,CAAC14H,IAAI,EAAExN,OAAO,EAAE;IACvB,IAAI,CAACq4F,OAAO,CAACr/F,IAAI,CAAC,IAAI66C,UAAU,CAACrmC,IAAI,CAACvE,UAAU,EAAEjJ,OAAO,CAAC,CAAC;EAC7D;AACF;AACA,IAAI2nI,WAAW,GAAG,MAAMpB,SAAS,CAAC;EAChCluC,OAAO;EACPmtC,OAAOA,CAACxlI,OAAO,EAAEwR,GAAG,EAAE;IACpB,MAAMg1H,MAAM,GAAG,IAAIhD,SAAS,CAAC,CAAC,CAAC/qI,KAAK,CAACuH,OAAO,EAAEwR,GAAG,EAAE;MACjDi7D,sBAAsB,EAAE;IAC1B,CAAC,CAAC;IACF,IAAI,CAAC4rB,OAAO,GAAGmuC,MAAM,CAACvsG,MAAM;IAC5B,MAAMsrG,SAAS,GAAG,IAAI,CAACltC,OAAO,CAACt/F,MAAM,GAAG,CAAC,IAAIytI,MAAM,CAACxvD,SAAS,CAACj+E,MAAM,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC6B,MAAM,CAAC,GAAGy/B,QAAQ,CAAC,IAAI,EAAEmsG,MAAM,CAACxvD,SAAS,CAAC,CAAC;IAC/H,OAAO;MACLuuD,SAAS;MACTtrG,MAAM,EAAE,IAAI,CAACo+D;IACf,CAAC;EACH;EACAr3F,SAASA,CAACC,IAAI,EAAEC,OAAO,EAAE;IACvB,OAAO,IAAI4jC,MAAM,CAAC7jC,IAAI,CAACnG,KAAK,EAAEmG,IAAI,CAACgI,UAAU,CAAC;EAChD;EACAi1B,YAAYA,CAACpvB,EAAE,EAAE5N,OAAO,EAAE;IACxB,QAAQ4N,EAAE,CAACjU,IAAI;MACb,KAAKisI,kBAAkB;QACrB,MAAML,QAAQ,GAAG33H,EAAE,CAACvW,KAAK,CAACi0C,IAAI,CAACxyC,IAAI,IAAIA,IAAI,CAACa,IAAI,KAAK,OAAO,CAAC;QAC7D,IAAI4rI,QAAQ,EAAE;UACZ,OAAO,CAAC,IAAIvhG,WAAW,CAAC,EAAE,EAAEuhG,QAAQ,CAAC3rI,KAAK,EAAEgU,EAAE,CAAC7F,UAAU,CAAC,CAAC;QAC7D;QACA,IAAI,CAACi9H,SAAS,CAACp3H,EAAE,EAAE,IAAIg4H,kBAAkB,gCAAgC,CAAC;QAC1E;MACF,KAAKC,yBAAyB;QAC5B,MAAMyB,SAAS,GAAG15H,EAAE,CAACvW,KAAK,CAACi0C,IAAI,CAACxyC,IAAI,IAAIA,IAAI,CAACa,IAAI,KAAK,YAAY,CAAC;QACnE,MAAM4tI,OAAO,GAAG35H,EAAE,CAACvW,KAAK,CAACi0C,IAAI,CAACxyC,IAAI,IAAIA,IAAI,CAACa,IAAI,KAAK,UAAU,CAAC;QAC/D,IAAI,CAAC2tI,SAAS,EAAE;UACd,IAAI,CAACtC,SAAS,CAACp3H,EAAE,EAAE,IAAIg4H,kBAAkB,qCAAqC,CAAC;QACjF,CAAC,MAAM,IAAI,CAAC2B,OAAO,EAAE;UACnB,IAAI,CAACvC,SAAS,CAACp3H,EAAE,EAAE,IAAIg4H,kBAAkB,mCAAmC,CAAC;QAC/E,CAAC,MAAM;UACL,MAAM4B,OAAO,GAAGF,SAAS,CAAC1tI,KAAK;UAC/B,MAAM6tI,KAAK,GAAGF,OAAO,CAAC3tI,KAAK;UAC3B,MAAMuF,KAAK,GAAG,EAAE;UAChB,OAAOA,KAAK,CAACzF,MAAM,CAAC,IAAIsqC,WAAW,CAAC,EAAE,EAAEwjG,OAAO,EAAE55H,EAAE,CAAC7F,UAAU,CAAC,EAAE,GAAG6F,EAAE,CAACzN,QAAQ,CAACnE,GAAG,CAACsQ,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,EAAE,IAAIqkC,WAAW,CAAC,EAAE,EAAEyjG,KAAK,EAAE75H,EAAE,CAAC7F,UAAU,CAAC,CAAC;QACjK;QACA;MACF,KAAK+9H,WAAW;QACd,OAAO,EAAE,CAACpsI,MAAM,CAAC,GAAGy/B,QAAQ,CAAC,IAAI,EAAEvrB,EAAE,CAACzN,QAAQ,CAAC,CAAC;MAClD;QACE,IAAI,CAAC6kI,SAAS,CAACp3H,EAAE,EAAE,gBAAgB,CAAC;IACxC;IACA,OAAO,IAAI;EACb;EACA06D,cAAcA,CAAChoE,GAAG,EAAEN,OAAO,EAAE;IAC3B,MAAMwlI,OAAO,GAAG,CAAC,CAAC;IAClBrsG,QAAQ,CAAC,IAAI,EAAE74B,GAAG,CAACG,KAAK,CAAC,CAAC1G,OAAO,CAACmI,CAAC,IAAI;MACrCsjI,OAAO,CAACtjI,CAAC,CAACtI,KAAK,CAAC,GAAG,IAAIiqC,SAAS,CAAC3hC,CAAC,CAAC/C,KAAK,EAAEmB,GAAG,CAACyH,UAAU,CAAC;IAC3D,CAAC,CAAC;IACF,OAAO,IAAIo6B,GAAG,CAAC7hC,GAAG,CAAC8nE,WAAW,EAAE9nE,GAAG,CAACM,IAAI,EAAE4kI,OAAO,EAAEllI,GAAG,CAACyH,UAAU,CAAC;EACpE;EACA2gE,kBAAkBA,CAAC62D,OAAO,EAAEv/H,OAAO,EAAE;IACnC,OAAO;MACLpG,KAAK,EAAE2lI,OAAO,CAAC3lI,KAAK;MACpBuF,KAAK,EAAE,EAAE,CAACzF,MAAM,CAAC,GAAGy/B,QAAQ,CAAC,IAAI,EAAEomG,OAAO,CAAC5+H,UAAU,CAAC;IACxD,CAAC;EACH;EACAkoE,YAAYA,CAAC95C,OAAO,EAAE/uB,OAAO,EAAE,CAAC;EAChC4oE,cAAcA,CAAChwE,SAAS,EAAEoH,OAAO,EAAE,CAAC;EACpC+oE,UAAUA,CAAClmC,KAAK,EAAE7iC,OAAO,EAAE,CAAC;EAC5BipE,mBAAmBA,CAAC6T,SAAS,EAAE98E,OAAO,EAAE,CAAC;EACzCkhC,mBAAmBA,CAACgC,IAAI,EAAEljC,OAAO,EAAE,CAAC;EACpCqhC,cAAcA,CAAC0B,SAAS,EAAE/iC,OAAO,EAAE;IACjC,IAAI,CAACglI,SAAS,CAACjiG,SAAS,EAAE,iBAAiB,CAAC;EAC9C;EACAxB,cAAcA,CAACyB,SAAS,EAAEhjC,OAAO,EAAE;IACjC,IAAI,CAACglI,SAAS,CAAChiG,SAAS,EAAE,iBAAiB,CAAC;EAC9C;EACAgiG,SAASA,CAAC14H,IAAI,EAAExN,OAAO,EAAE;IACvB,IAAI,CAACq4F,OAAO,CAACr/F,IAAI,CAAC,IAAI66C,UAAU,CAACrmC,IAAI,CAACvE,UAAU,EAAEjJ,OAAO,CAAC,CAAC;EAC7D;AACF,CAAC;AACD,SAAS6nI,aAAaA,CAACruI,GAAG,EAAE;EAC1B,QAAQA,GAAG,CAACuB,WAAW,CAAC,CAAC;IACvB,KAAK,IAAI;IACT,KAAK,GAAG;IACR,KAAK,GAAG;IACR,KAAK,GAAG;MACN,OAAO,KAAK;IACd,KAAK,KAAK;MACR,OAAO,OAAO;IAChB,KAAK,GAAG;MACN,OAAO,MAAM;IACf;MACE,OAAO,OAAO;EAClB;AACF;AAEA,MAAM6tI,iBAAiB,GAAG,mBAAmB;AAC7C,MAAMC,gBAAgB,GAAG,aAAa;AACtC,MAAMC,gBAAgB,GAAG,IAAI;AAC7B,MAAMC,GAAG,SAASpjG,UAAU,CAAC;EAC3B4C,KAAKA,CAACC,QAAQ,EAAEC,MAAM,EAAE;IACtB,MAAM,IAAIlvC,KAAK,CAAC,aAAa,CAAC;EAChC;EACA2vC,IAAIA,CAACpe,OAAO,EAAEtZ,GAAG,EAAE;IACjB,MAAMw3H,SAAS,GAAG,IAAIC,SAAS,CAAC,CAAC;IACjC,MAAM;MACJxgG,MAAM;MACN08F,WAAW;MACXlrG;IACF,CAAC,GAAG+uG,SAAS,CAACvwI,KAAK,CAACqyB,OAAO,EAAEtZ,GAAG,CAAC;IACjC,MAAM4zH,gBAAgB,GAAG,CAAC,CAAC;IAC3B,MAAMlvF,SAAS,GAAG,IAAIqwF,SAAS,CAAC,CAAC;IACjChnI,MAAM,CAACmC,IAAI,CAACyjI,WAAW,CAAC,CAAClqI,OAAO,CAACqqI,KAAK,IAAI;MACxC,MAAM4D,OAAO,GAAG,SAAAA,CAAA,EAAY;QAC1B,MAAM;UACJ3D,SAAS;UACTtrG;QACF,CAAC,GAAGic,SAAS,CAACsvF,OAAO,CAACL,WAAW,CAACG,KAAK,CAAC,EAAE9zH,GAAG,CAAC;QAC9C,IAAIyoB,MAAM,CAAClhC,MAAM,EAAE;UACjB,MAAM,IAAIQ,KAAK,CAAC,sBAAsB0gC,MAAM,CAACt/B,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;QAC5D;QACA,OAAO4qI,SAAS;MAClB,CAAC;MACD4D,kBAAkB,CAAC/D,gBAAgB,EAAEE,KAAK,EAAE4D,OAAO,CAAC;IACtD,CAAC,CAAC;IACF,IAAIjvG,MAAM,CAAClhC,MAAM,EAAE;MACjB,MAAM,IAAIQ,KAAK,CAAC,sBAAsB0gC,MAAM,CAACt/B,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;IAC5D;IACA,OAAO;MACL8tC,MAAM,EAAEA,MAAM;MACd28F;IACF,CAAC;EACH;EACAj8F,MAAMA,CAACnpC,OAAO,EAAE;IACd,OAAOmpC,MAAM,CAACnpC,OAAO,CAAC;EACxB;EACA4lC,gBAAgBA,CAAC5lC,OAAO,EAAE;IACxB,OAAO,IAAI6lC,uBAAuB,CAAC7lC,OAAO,EAAEkmC,YAAY,CAAC;EAC3D;AACF;AACA,SAASijG,kBAAkBA,CAAC3gG,QAAQ,EAAEvoC,EAAE,EAAEipI,OAAO,EAAE;EACjD3pI,MAAM,CAAC6pI,cAAc,CAAC5gG,QAAQ,EAAEvoC,EAAE,EAAE;IAClCopI,YAAY,EAAE,IAAI;IAClBC,UAAU,EAAE,IAAI;IAChBxsI,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,MAAMhC,KAAK,GAAGouI,OAAO,CAAC,CAAC;MACvB3pI,MAAM,CAAC6pI,cAAc,CAAC5gG,QAAQ,EAAEvoC,EAAE,EAAE;QAClCqpI,UAAU,EAAE,IAAI;QAChBxuI;MACF,CAAC,CAAC;MACF,OAAOA,KAAK;IACd,CAAC;IACDiC,GAAG,EAAEi/C,CAAC,IAAI;MACR,MAAM,IAAIziD,KAAK,CAAC,wCAAwC,CAAC;IAC3D;EACF,CAAC,CAAC;AACJ;AACA,MAAM0vI,SAAS,CAAC;EACdM,YAAY;EACZlxC,OAAO;EACPytC,YAAY;EACZC,OAAO,GAAG,IAAI;EACdttI,KAAKA,CAAC+wI,GAAG,EAAEh4H,GAAG,EAAE;IACd,IAAI,CAAC+3H,YAAY,GAAG,CAAC;IACrB,IAAI,CAACzD,YAAY,GAAG,CAAC,CAAC;IACtB,MAAME,GAAG,GAAG,IAAIxC,SAAS,CAAC,CAAC,CAAC/qI,KAAK,CAAC+wI,GAAG,EAAEh4H,GAAG,CAAC;IAC3C,IAAI,CAAC6mF,OAAO,GAAG2tC,GAAG,CAAC/rG,MAAM;IACzBI,QAAQ,CAAC,IAAI,EAAE2rG,GAAG,CAAChvD,SAAS,CAAC;IAC7B,OAAO;MACLmuD,WAAW,EAAE,IAAI,CAACW,YAAY;MAC9B7rG,MAAM,EAAE,IAAI,CAACo+D,OAAO;MACpB5vD,MAAM,EAAE,IAAI,CAACs9F;IACf,CAAC;EACH;EACA7nG,YAAYA,CAAC7lC,OAAO,EAAE6I,OAAO,EAAE;IAC7B,QAAQ7I,OAAO,CAACwC,IAAI;MAClB,KAAK+tI,iBAAiB;QACpB,IAAI,CAACW,YAAY,EAAE;QACnB,IAAI,IAAI,CAACA,YAAY,GAAG,CAAC,EAAE;UACzB,IAAI,CAACrD,SAAS,CAAC7tI,OAAO,EAAE,IAAIuwI,iBAAiB,8BAA8B,CAAC;QAC9E;QACA,MAAMa,QAAQ,GAAGpxI,OAAO,CAACE,KAAK,CAACi0C,IAAI,CAACxyC,IAAI,IAAIA,IAAI,CAACa,IAAI,KAAK,MAAM,CAAC;QACjE,IAAI4uI,QAAQ,EAAE;UACZ,IAAI,CAAC1D,OAAO,GAAG0D,QAAQ,CAAC3uI,KAAK;QAC/B;QACAu/B,QAAQ,CAAC,IAAI,EAAEhiC,OAAO,CAACgJ,QAAQ,EAAE,IAAI,CAAC;QACtC,IAAI,CAACkoI,YAAY,EAAE;QACnB;MACF,KAAKV,gBAAgB;QACnB,MAAM5C,MAAM,GAAG5tI,OAAO,CAACE,KAAK,CAACi0C,IAAI,CAACxyC,IAAI,IAAIA,IAAI,CAACa,IAAI,KAAK,IAAI,CAAC;QAC7D,IAAI,CAACorI,MAAM,EAAE;UACX,IAAI,CAACC,SAAS,CAAC7tI,OAAO,EAAE,IAAIwwI,gBAAgB,6BAA6B,CAAC;QAC5E,CAAC,MAAM;UACL,MAAM5oI,EAAE,GAAGgmI,MAAM,CAACnrI,KAAK;UACvB,IAAI,IAAI,CAACgrI,YAAY,CAAC1/F,cAAc,CAACnmC,EAAE,CAAC,EAAE;YACxC,IAAI,CAACimI,SAAS,CAAC7tI,OAAO,EAAE,mCAAmC4H,EAAE,EAAE,CAAC;UAClE,CAAC,MAAM;YACL,MAAMkmI,cAAc,GAAG9tI,OAAO,CAAC2lC,eAAe,CAAC54B,GAAG,CAACmtC,MAAM;YACzD,MAAM6zF,YAAY,GAAG/tI,OAAO,CAAC4lC,aAAa,CAAC7O,KAAK,CAACmjB,MAAM;YACvD,MAAMznB,OAAO,GAAGzyB,OAAO,CAAC2lC,eAAe,CAAC5O,KAAK,CAAC5E,IAAI,CAACM,OAAO;YAC1D,MAAMu7G,SAAS,GAAGv7G,OAAO,CAACnxB,KAAK,CAACwsI,cAAc,EAAEC,YAAY,CAAC;YAC7D,IAAI,CAACN,YAAY,CAAC7lI,EAAE,CAAC,GAAGomI,SAAS;UACnC;QACF;QACA;MACF;QACE,IAAI,CAACH,SAAS,CAAC7tI,OAAO,EAAE,gBAAgB,CAAC;IAC7C;EACF;EACAyxE,cAAcA,CAAChwE,SAAS,EAAEoH,OAAO,EAAE,CAAC;EACpCF,SAASA,CAACC,IAAI,EAAEC,OAAO,EAAE,CAAC;EAC1B6oE,YAAYA,CAAC95C,OAAO,EAAE/uB,OAAO,EAAE,CAAC;EAChCsoE,cAAcA,CAACmU,SAAS,EAAEz8E,OAAO,EAAE,CAAC;EACpC0oE,kBAAkBA,CAACiU,aAAa,EAAE38E,OAAO,EAAE,CAAC;EAC5C+oE,UAAUA,CAAClmC,KAAK,EAAE7iC,OAAO,EAAE,CAAC;EAC5BipE,mBAAmBA,CAACpmC,KAAK,EAAE7iC,OAAO,EAAE,CAAC;EACrCkhC,mBAAmBA,CAACgC,IAAI,EAAEljC,OAAO,EAAE,CAAC;EACpCqhC,cAAcA,CAAC0B,SAAS,EAAE/iC,OAAO,EAAE;IACjC,IAAI,CAACglI,SAAS,CAACjiG,SAAS,EAAE,iBAAiB,CAAC;EAC9C;EACAxB,cAAcA,CAACyB,SAAS,EAAEhjC,OAAO,EAAE;IACjC,IAAI,CAACglI,SAAS,CAAChiG,SAAS,EAAE,iBAAiB,CAAC;EAC9C;EACAgiG,SAASA,CAAC14H,IAAI,EAAExN,OAAO,EAAE;IACvB,IAAI,CAACq4F,OAAO,CAACr/F,IAAI,CAAC,IAAI66C,UAAU,CAACrmC,IAAI,CAACvE,UAAU,EAAEjJ,OAAO,CAAC,CAAC;EAC7D;AACF;AACA,MAAMumI,SAAS,CAAC;EACdluC,OAAO;EACPmtC,OAAOA,CAACxlI,OAAO,EAAEwR,GAAG,EAAE;IACpB,MAAMg1H,MAAM,GAAG,IAAIhD,SAAS,CAAC,CAAC,CAAC/qI,KAAK,CAACuH,OAAO,EAAEwR,GAAG,EAAE;MACjDi7D,sBAAsB,EAAE;IAC1B,CAAC,CAAC;IACF,IAAI,CAAC4rB,OAAO,GAAGmuC,MAAM,CAACvsG,MAAM;IAC5B,MAAMsrG,SAAS,GAAG,IAAI,CAACltC,OAAO,CAACt/F,MAAM,GAAG,CAAC,IAAIytI,MAAM,CAACxvD,SAAS,CAACj+E,MAAM,IAAI,CAAC,GAAG,EAAE,GAAGshC,QAAQ,CAAC,IAAI,EAAEmsG,MAAM,CAACxvD,SAAS,CAAC;IACjH,OAAO;MACLuuD,SAAS;MACTtrG,MAAM,EAAE,IAAI,CAACo+D;IACf,CAAC;EACH;EACAr3F,SAASA,CAACC,IAAI,EAAEC,OAAO,EAAE;IACvB,OAAO,IAAI4jC,MAAM,CAAC7jC,IAAI,CAACnG,KAAK,EAAEmG,IAAI,CAACgI,UAAU,CAAC;EAChD;EACAugE,cAAcA,CAAChoE,GAAG,EAAEN,OAAO,EAAE;IAC3B,MAAMwlI,OAAO,GAAG,CAAC,CAAC;IAClBrsG,QAAQ,CAAC,IAAI,EAAE74B,GAAG,CAACG,KAAK,CAAC,CAAC1G,OAAO,CAACmI,CAAC,IAAI;MACrCsjI,OAAO,CAACtjI,CAAC,CAACtI,KAAK,CAAC,GAAG,IAAIiqC,SAAS,CAAC3hC,CAAC,CAAC/C,KAAK,EAAEmB,GAAG,CAACyH,UAAU,CAAC;IAC3D,CAAC,CAAC;IACF,OAAO,IAAIo6B,GAAG,CAAC7hC,GAAG,CAAC8nE,WAAW,EAAE9nE,GAAG,CAACM,IAAI,EAAE4kI,OAAO,EAAEllI,GAAG,CAACyH,UAAU,CAAC;EACpE;EACA2gE,kBAAkBA,CAAC62D,OAAO,EAAEv/H,OAAO,EAAE;IACnC,OAAO;MACLpG,KAAK,EAAE2lI,OAAO,CAAC3lI,KAAK;MACpBuF,KAAK,EAAEg6B,QAAQ,CAAC,IAAI,EAAEomG,OAAO,CAAC5+H,UAAU;IAC1C,CAAC;EACH;EACAq8B,YAAYA,CAACpvB,EAAE,EAAE5N,OAAO,EAAE;IACxB,IAAI4N,EAAE,CAACjU,IAAI,KAAKiuI,gBAAgB,EAAE;MAChC,MAAMrC,QAAQ,GAAG33H,EAAE,CAACvW,KAAK,CAACi0C,IAAI,CAACxyC,IAAI,IAAIA,IAAI,CAACa,IAAI,KAAK,MAAM,CAAC;MAC5D,IAAI4rI,QAAQ,EAAE;QACZ,OAAO,IAAIvhG,WAAW,CAAC,EAAE,EAAEuhG,QAAQ,CAAC3rI,KAAK,EAAEgU,EAAE,CAAC7F,UAAU,CAAC;MAC3D;MACA,IAAI,CAACi9H,SAAS,CAACp3H,EAAE,EAAE,IAAIg6H,gBAAgB,+BAA+B,CAAC;IACzE,CAAC,MAAM;MACL,IAAI,CAAC5C,SAAS,CAACp3H,EAAE,EAAE,gBAAgB,CAAC;IACtC;IACA,OAAO,IAAI;EACb;EACAi7D,YAAYA,CAAC95C,OAAO,EAAE/uB,OAAO,EAAE,CAAC;EAChC4oE,cAAcA,CAAChwE,SAAS,EAAEoH,OAAO,EAAE,CAAC;EACpC+oE,UAAUA,CAAClmC,KAAK,EAAE7iC,OAAO,EAAE,CAAC;EAC5BipE,mBAAmBA,CAACpmC,KAAK,EAAE7iC,OAAO,EAAE,CAAC;EACrCkhC,mBAAmBA,CAACgC,IAAI,EAAEljC,OAAO,EAAE,CAAC;EACpCqhC,cAAcA,CAAC0B,SAAS,EAAE/iC,OAAO,EAAE;IACjC,IAAI,CAACglI,SAAS,CAACjiG,SAAS,EAAE,iBAAiB,CAAC;EAC9C;EACAxB,cAAcA,CAACyB,SAAS,EAAEhjC,OAAO,EAAE;IACjC,IAAI,CAACglI,SAAS,CAAChiG,SAAS,EAAE,iBAAiB,CAAC;EAC9C;EACAgiG,SAASA,CAAC14H,IAAI,EAAExN,OAAO,EAAE;IACvB,IAAI,CAACq4F,OAAO,CAACr/F,IAAI,CAAC,IAAI66C,UAAU,CAACrmC,IAAI,CAACvE,UAAU,EAAEjJ,OAAO,CAAC,CAAC;EAC7D;AACF;AAEA,MAAM0pI,iBAAiB,CAAC;EACtBC,iBAAiB;EACjBxgG,MAAM;EACNygG,aAAa;EACbC,WAAW;EACXhsI,WAAWA,CAAC8rI,iBAAiB,GAAG,CAAC,CAAC,EAAElhG,MAAM,EAAEU,MAAM,EAAEygG,aAAa,EAAEE,0BAA0B,GAAGjrI,0BAA0B,CAACkrI,OAAO,EAAEvzB,OAAO,EAAE;IAC3I,IAAI,CAACmzB,iBAAiB,GAAGA,iBAAiB;IAC1C,IAAI,CAACxgG,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACygG,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,WAAW,GAAG,IAAIG,iBAAiB,CAACL,iBAAiB,EAAElhG,MAAM,EAAEU,MAAM,EAAEygG,aAAa,EAAEE,0BAA0B,EAAEtzB,OAAO,CAAC;EACjI;EACA,OAAOttE,IAAIA,CAACpe,OAAO,EAAEtZ,GAAG,EAAEy3D,UAAU,EAAE6gE,0BAA0B,EAAEtzB,OAAO,EAAE;IACzE,MAAM;MACJ/tE,MAAM;MACN28F;IACF,CAAC,GAAGn8D,UAAU,CAAC//B,IAAI,CAACpe,OAAO,EAAEtZ,GAAG,CAAC;IACjC,MAAMy4H,QAAQ,GAAGjiH,CAAC,IAAIihD,UAAU,CAAC9/B,MAAM,CAACnhB,CAAC,CAAC;IAC1C,MAAM4hH,aAAa,GAAG5hH,CAAC,IAAIihD,UAAU,CAACrjC,gBAAgB,CAAC5d,CAAC,CAAC;IACzD,OAAO,IAAI0hH,iBAAiB,CAACtE,gBAAgB,EAAE38F,MAAM,EAAEwhG,QAAQ,EAAEL,aAAa,EAAEE,0BAA0B,EAAEtzB,OAAO,CAAC;EACtH;EACA15G,GAAGA,CAACotI,MAAM,EAAE;IACV,MAAMC,IAAI,GAAG,IAAI,CAACN,WAAW,CAACrE,OAAO,CAAC0E,MAAM,CAAC;IAC7C,IAAIC,IAAI,CAAClwG,MAAM,CAAClhC,MAAM,EAAE;MACtB,MAAM,IAAIQ,KAAK,CAAC4wI,IAAI,CAAClwG,MAAM,CAACt/B,IAAI,CAAC,IAAI,CAAC,CAAC;IACzC;IACA,OAAOwvI,IAAI,CAAC9pI,KAAK;EACnB;EACAnC,GAAGA,CAACgsI,MAAM,EAAE;IACV,OAAO,IAAI,CAAC/gG,MAAM,CAAC+gG,MAAM,CAAC,IAAI,IAAI,CAACP,iBAAiB;EACtD;AACF;AACA,MAAMK,iBAAiB,CAAC;EACtBL,iBAAiB;EACjB5D,OAAO;EACPqE,OAAO;EACPC,cAAc;EACdC,2BAA2B;EAC3BC,QAAQ;EACRC,OAAO;EACPnyC,OAAO,GAAG,EAAE;EACZoyC,aAAa,GAAG,EAAE;EAClBC,OAAO;EACP7sI,WAAWA,CAAC8rI,iBAAiB,GAAG,CAAC,CAAC,EAAE5D,OAAO,EAAEqE,OAAO,EAAEC,cAAc,EAAEC,2BAA2B,EAAEC,QAAQ,EAAE;IAC3G,IAAI,CAACZ,iBAAiB,GAAGA,iBAAiB;IAC1C,IAAI,CAAC5D,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACqE,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACC,2BAA2B,GAAGA,2BAA2B;IAC9D,IAAI,CAACC,QAAQ,GAAGA,QAAQ;EAC1B;EACA/E,OAAOA,CAAC0E,MAAM,EAAE;IACd,IAAI,CAACO,aAAa,CAAC1xI,MAAM,GAAG,CAAC;IAC7B,IAAI,CAACs/F,OAAO,CAACt/F,MAAM,GAAG,CAAC;IACvB,MAAMkI,IAAI,GAAG,IAAI,CAAC0pI,cAAc,CAACT,MAAM,CAAC;IACxC,MAAM14H,GAAG,GAAG04H,MAAM,CAAC7pI,KAAK,CAAC,CAAC,CAAC,CAAC4I,UAAU,CAACmmB,KAAK,CAAC5E,IAAI,CAAChZ,GAAG;IACrD,MAAM24H,IAAI,GAAG,IAAI9wB,UAAU,CAAC,CAAC,CAAC5gH,KAAK,CAACwI,IAAI,EAAEuQ,GAAG,EAAE;MAC7Ci7D,sBAAsB,EAAE;IAC1B,CAAC,CAAC;IACF,OAAO;MACLpsE,KAAK,EAAE8pI,IAAI,CAACnzD,SAAS;MACrB/8C,MAAM,EAAE,CAAC,GAAG,IAAI,CAACo+D,OAAO,EAAE,GAAG8xC,IAAI,CAAClwG,MAAM;IAC1C,CAAC;EACH;EACAj5B,SAASA,CAACC,IAAI,EAAEC,OAAO,EAAE;IACvB,OAAOqmC,SAAS,CAACtmC,IAAI,CAACnG,KAAK,CAAC;EAC9B;EACAqG,cAAcA,CAACC,SAAS,EAAEF,OAAO,EAAE;IACjC,OAAOE,SAAS,CAACC,QAAQ,CAACnE,GAAG,CAACqoC,CAAC,IAAIA,CAAC,CAAC1kC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAClG,IAAI,CAAC,EAAE,CAAC;EAC5D;EACA4G,QAAQA,CAACC,GAAG,EAAEN,OAAO,EAAE;IACrB,MAAMS,KAAK,GAAGpC,MAAM,CAACmC,IAAI,CAACF,GAAG,CAACG,KAAK,CAAC,CAACzE,GAAG,CAAC0E,CAAC,IAAI,GAAGA,CAAC,KAAKJ,GAAG,CAACG,KAAK,CAACC,CAAC,CAAC,CAACf,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC;IACnF,MAAMgX,GAAG,GAAG,IAAI,CAAC2yH,OAAO,CAACjnG,YAAY,CAAC6C,cAAc,CAAC5kC,GAAG,CAACK,UAAU,CAAC,GAAG,IAAI,CAAC2oI,OAAO,CAACjnG,YAAY,CAAC/hC,GAAG,CAACK,UAAU,CAAC,CAACZ,IAAI,GAAGO,GAAG,CAACK,UAAU;IACtI,OAAO,IAAIgW,GAAG,KAAKrW,GAAG,CAACM,IAAI,KAAKH,KAAK,CAAChH,IAAI,CAAC,GAAG,CAAC,GAAG;EACpD;EACAyH,gBAAgBA,CAACJ,EAAE,EAAEd,OAAO,EAAE;IAC5B,MAAM80F,MAAM,GAAG,IAAI,CAAC00C,OAAO,CAAC1oI,EAAE,CAACnH,IAAI,CAAC;IACpC,IAAI,IAAI,CAAC2vI,OAAO,CAACjnG,YAAY,CAAC6C,cAAc,CAAC4vD,MAAM,CAAC,EAAE;MACpD,OAAO,IAAI,CAACw0C,OAAO,CAACjnG,YAAY,CAACyyD,MAAM,CAAC,CAAC/0F,IAAI;IAC/C;IACA,IAAI,IAAI,CAACupI,OAAO,CAACjmG,oBAAoB,CAAC6B,cAAc,CAAC4vD,MAAM,CAAC,EAAE;MAC5D,OAAO,IAAI,CAAC20C,cAAc,CAAC,IAAI,CAACH,OAAO,CAACjmG,oBAAoB,CAACyxD,MAAM,CAAC,CAAC;IACvE;IACA,IAAI,CAACkwC,SAAS,CAAClkI,EAAE,EAAE,wBAAwBA,EAAE,CAACnH,IAAI,GAAG,CAAC;IACtD,OAAO,EAAE;EACX;EACAkH,mBAAmBA,CAACC,EAAE,EAAEd,OAAO,EAAE;IAC/B,MAAM1H,GAAG,GAAG,GAAGwI,EAAE,CAACxI,GAAG,EAAE;IACvB,MAAMjB,KAAK,GAAGgH,MAAM,CAACmC,IAAI,CAACM,EAAE,CAACzJ,KAAK,CAAC,CAAC2E,GAAG,CAACrC,IAAI,IAAI,GAAGA,IAAI,KAAKmH,EAAE,CAACzJ,KAAK,CAACsC,IAAI,CAAC,GAAG,CAAC,CAACF,IAAI,CAAC,GAAG,CAAC;IACxF,IAAIqH,EAAE,CAACC,MAAM,EAAE;MACb,OAAO,IAAIzI,GAAG,IAAIjB,KAAK,IAAI;IAC7B;IACA,MAAM8I,QAAQ,GAAGW,EAAE,CAACX,QAAQ,CAACnE,GAAG,CAACkG,CAAC,IAAIA,CAAC,CAACvC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAClG,IAAI,CAAC,EAAE,CAAC;IAC7D,OAAO,IAAInB,GAAG,IAAIjB,KAAK,IAAI8I,QAAQ,KAAK7H,GAAG,GAAG;EAChD;EACA6I,mBAAmBA,CAACL,EAAE,EAAEd,OAAO,EAAE;IAC/B,OAAO,IAAI,CAACypI,cAAc,CAAC,IAAI,CAACH,OAAO,CAACjmG,oBAAoB,CAACviC,EAAE,CAACnH,IAAI,CAAC,CAAC;EACxE;EACAyH,qBAAqBA,CAACN,EAAE,EAAEd,OAAO,EAAE;IACjC,MAAMqI,MAAM,GAAGvH,EAAE,CAAC4Y,UAAU,CAAC7hB,MAAM,KAAK,CAAC,GAAG,EAAE,GAAG,KAAKiJ,EAAE,CAAC4Y,UAAU,CAACjgB,IAAI,CAAC,IAAI,CAAC,GAAG;IACjF,MAAM0G,QAAQ,GAAGW,EAAE,CAACX,QAAQ,CAACnE,GAAG,CAACkG,CAAC,IAAIA,CAAC,CAACvC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAClG,IAAI,CAAC,EAAE,CAAC;IAC7D,OAAO,IAAIqH,EAAE,CAACnH,IAAI,GAAG0O,MAAM,KAAKlI,QAAQ,GAAG;EAC7C;EACAspI,cAAcA,CAACT,MAAM,EAAE;IACrB,MAAMjqI,EAAE,GAAG,IAAI,CAACmqI,OAAO,CAACF,MAAM,CAAC;IAC/B,MAAMU,MAAM,GAAG,IAAI,CAACP,cAAc,GAAG,IAAI,CAACA,cAAc,CAACH,MAAM,CAAC,GAAG,IAAI;IACvE,IAAI7pI,KAAK;IACT,IAAI,CAACoqI,aAAa,CAACzxI,IAAI,CAAC;MACtBkM,GAAG,EAAE,IAAI,CAACslI,OAAO;MACjBI,MAAM,EAAE,IAAI,CAACF;IACf,CAAC,CAAC;IACF,IAAI,CAACF,OAAO,GAAGN,MAAM;IACrB,IAAI,IAAI,CAACP,iBAAiB,CAACvjG,cAAc,CAACnmC,EAAE,CAAC,EAAE;MAC7CI,KAAK,GAAG,IAAI,CAACspI,iBAAiB,CAAC1pI,EAAE,CAAC;MAClC,IAAI,CAACyqI,OAAO,GAAG7vI,IAAI,IAAI+vI,MAAM,GAAGA,MAAM,CAACvkG,cAAc,CAACxrC,IAAI,CAAC,GAAGA,IAAI;IACpE,CAAC,MAAM;MACL,IAAI,IAAI,CAACyvI,2BAA2B,KAAKzrI,0BAA0B,CAACtF,KAAK,EAAE;QACzE,MAAMy2B,GAAG,GAAG,IAAI,CAAC+1G,OAAO,GAAG,gBAAgB,IAAI,CAACA,OAAO,GAAG,GAAG,EAAE;QAC/D,IAAI,CAACG,SAAS,CAACgE,MAAM,CAAC7pI,KAAK,CAAC,CAAC,CAAC,EAAE,oCAAoCJ,EAAE,IAAI+vB,GAAG,EAAE,CAAC;MAClF,CAAC,MAAM,IAAI,IAAI,CAACu6G,QAAQ,IAAI,IAAI,CAACD,2BAA2B,KAAKzrI,0BAA0B,CAACkrI,OAAO,EAAE;QACnG,MAAM/5G,GAAG,GAAG,IAAI,CAAC+1G,OAAO,GAAG,gBAAgB,IAAI,CAACA,OAAO,GAAG,GAAG,EAAE;QAC/D,IAAI,CAACwE,QAAQ,CAACrJ,IAAI,CAAC,oCAAoCjhI,EAAE,IAAI+vB,GAAG,EAAE,CAAC;MACrE;MACA3vB,KAAK,GAAG6pI,MAAM,CAAC7pI,KAAK;MACpB,IAAI,CAACqqI,OAAO,GAAG7vI,IAAI,IAAIA,IAAI;IAC7B;IACA,MAAMoG,IAAI,GAAGZ,KAAK,CAACnD,GAAG,CAACsQ,IAAI,IAAIA,IAAI,CAAC3M,KAAK,CAAC,IAAI,CAAC,CAAC,CAAClG,IAAI,CAAC,EAAE,CAAC;IACzD,MAAMuG,OAAO,GAAG,IAAI,CAACupI,aAAa,CAACv8G,GAAG,CAAC,CAAC;IACxC,IAAI,CAACs8G,OAAO,GAAGtpI,OAAO,CAACgE,GAAG;IAC1B,IAAI,CAACwlI,OAAO,GAAGxpI,OAAO,CAAC0pI,MAAM;IAC7B,OAAO3pI,IAAI;EACb;EACAilI,SAASA,CAACp3H,EAAE,EAAE5J,GAAG,EAAE;IACjB,IAAI,CAACmzF,OAAO,CAACr/F,IAAI,CAAC,IAAI66C,UAAU,CAAC/kC,EAAE,CAAC7F,UAAU,EAAE/D,GAAG,CAAC,CAAC;EACvD;AACF;AAEA,MAAM2lI,cAAc,CAAC;EACnBC,WAAW;EACXjgE,gBAAgB;EAChBkgE,kBAAkB;EAClBltI,WAAWA,CAACitI,WAAW,EAAE9L,YAAY,EAAEgM,kBAAkB,EAAEC,kBAAkB,GAAGpsI,0BAA0B,CAACkrI,OAAO,EAAEvzB,OAAO,EAAE;IAC3H,IAAI,CAACs0B,WAAW,GAAGA,WAAW;IAC9B,IAAI9L,YAAY,EAAE;MAChB,MAAM/1D,UAAU,GAAGiiE,gBAAgB,CAACF,kBAAkB,CAAC;MACvD,IAAI,CAACD,kBAAkB,GAAGrB,iBAAiB,CAACxgG,IAAI,CAAC81F,YAAY,EAAE,MAAM,EAAE/1D,UAAU,EAAEgiE,kBAAkB,EAAEz0B,OAAO,CAAC;IACjH,CAAC,MAAM;MACL,IAAI,CAACu0B,kBAAkB,GAAG,IAAIrB,iBAAiB,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE3pI,QAAQ,EAAE6oB,SAAS,EAAEqiH,kBAAkB,EAAEz0B,OAAO,CAAC;IAC7G;EACF;EACA/9G,KAAKA,CAAC02B,MAAM,EAAE3d,GAAG,EAAE2tB,OAAO,GAAG,CAAC,CAAC,EAAE;IAC/B,MAAMguF,WAAW,GAAG,IAAI,CAAC2d,WAAW,CAACryI,KAAK,CAAC02B,MAAM,EAAE3d,GAAG,EAAE;MACtD,GAAG2tB;IACL,CAAC,CAAC;IACF,IAAIguF,WAAW,CAAClzF,MAAM,CAAClhC,MAAM,EAAE;MAC7B,OAAO,IAAIg+E,eAAe,CAACo2C,WAAW,CAACn2C,SAAS,EAAEm2C,WAAW,CAAClzF,MAAM,CAAC;IACvE;IACA,OAAO8kG,iBAAiB,CAAC5R,WAAW,CAACn2C,SAAS,EAAE,IAAI,CAAC+zD,kBAAkB,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;EAClF;AACF;AACA,SAASG,gBAAgBA,CAACC,MAAM,EAAE;EAChCA,MAAM,GAAG,CAACA,MAAM,IAAI,KAAK,EAAEpwI,WAAW,CAAC,CAAC;EACxC,QAAQowI,MAAM;IACZ,KAAK,KAAK;MACR,OAAO,IAAI7iG,GAAG,CAAC,CAAC;IAClB,KAAK,KAAK;MACR,OAAO,IAAIygG,GAAG,CAAC,CAAC;IAClB,KAAK,QAAQ;IACb,KAAK,MAAM;MACT,OAAO,IAAI1B,MAAM,CAAC,CAAC;IACrB,KAAK,OAAO;IACZ,KAAK,KAAK;IACV;MACE,OAAO,IAAI/C,KAAK,CAAC,CAAC;EACtB;AACF;AAEA,MAAM8G,aAAa,CAAC;EAClBN,WAAW;EACX1L,aAAa;EACbC,cAAc;EACd0G,OAAO;EACPsF,mBAAmB;EACnBpL,SAAS,GAAG,EAAE;EACdpiI,WAAWA,CAACitI,WAAW,EAAE1L,aAAa,EAAEC,cAAc,EAAE0G,OAAO,GAAG,IAAI,EAAEsF,mBAAmB,GAAG,IAAI,EAAE;IAClG,IAAI,CAACP,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAAC1L,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,cAAc,GAAGA,cAAc;IACpC,IAAI,CAAC0G,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACsF,mBAAmB,GAAGA,mBAAmB;EAChD;EACAC,kBAAkBA,CAACn8G,MAAM,EAAE3d,GAAG,EAAE;IAC9B,MAAM+5H,gBAAgB,GAAG,IAAI,CAACT,WAAW,CAACryI,KAAK,CAAC02B,MAAM,EAAE3d,GAAG,EAAE;MAC3Di7D,sBAAsB,EAAE;IAC1B,CAAC,CAAC;IACF,IAAI8+D,gBAAgB,CAACtxG,MAAM,CAAClhC,MAAM,EAAE;MAClC,OAAOwyI,gBAAgB,CAACtxG,MAAM;IAChC;IACA,MAAM+8C,SAAS,GAAG,IAAI,CAACq0D,mBAAmB,GAAGE,gBAAgB,CAACv0D,SAAS,GAAGgG,oBAAoB,CAAC,IAAIN,iBAAiB,CAAC,KAAK,CAAC,EAAE6uD,gBAAgB,CAACv0D,SAAS,CAAC;IACxJ,MAAMw0D,gBAAgB,GAAG7M,eAAe,CAAC3nD,SAAS,EAAE,IAAI,CAACooD,aAAa,EAAE,IAAI,CAACC,cAAc,EAAE,IAAI,CAACgM,mBAAmB,CAAC;IACtH,IAAIG,gBAAgB,CAACvxG,MAAM,CAAClhC,MAAM,EAAE;MAClC,OAAOyyI,gBAAgB,CAACvxG,MAAM;IAChC;IACA,IAAI,CAACgmG,SAAS,CAACjnI,IAAI,CAAC,GAAGwyI,gBAAgB,CAAChjG,QAAQ,CAAC;IACjD,OAAO,EAAE;EACX;EACAijG,WAAWA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACxL,SAAS;EACvB;EACA13F,KAAKA,CAAC0gC,UAAU,EAAEyiE,aAAa,EAAE;IAC/B,MAAMljG,QAAQ,GAAG,CAAC,CAAC;IACnB,MAAMmjG,aAAa,GAAG,IAAIC,mBAAmB,CAAC,CAAC;IAC/C,IAAI,CAAC3L,SAAS,CAAChlI,OAAO,CAAC+E,OAAO,IAAI;MAChC,MAAMC,EAAE,GAAGgpE,UAAU,CAAC9/B,MAAM,CAACnpC,OAAO,CAAC;MACrC,IAAI,CAACwoC,QAAQ,CAACpC,cAAc,CAACnmC,EAAE,CAAC,EAAE;QAChCuoC,QAAQ,CAACvoC,EAAE,CAAC,GAAGD,OAAO;MACxB,CAAC,MAAM;QACLwoC,QAAQ,CAACvoC,EAAE,CAAC,CAACurB,OAAO,CAACxyB,IAAI,CAAC,GAAGgH,OAAO,CAACwrB,OAAO,CAAC;MAC/C;IACF,CAAC,CAAC;IACF,MAAMqgH,OAAO,GAAGtsI,MAAM,CAACmC,IAAI,CAAC8mC,QAAQ,CAAC,CAACtrC,GAAG,CAAC+C,EAAE,IAAI;MAC9C,MAAM2qI,MAAM,GAAG3hE,UAAU,CAACrjC,gBAAgB,CAAC4C,QAAQ,CAACvoC,EAAE,CAAC,CAAC;MACxD,MAAM6rI,GAAG,GAAGtjG,QAAQ,CAACvoC,EAAE,CAAC;MACxB,MAAMI,KAAK,GAAGuqI,MAAM,GAAGe,aAAa,CAACnG,OAAO,CAACsG,GAAG,CAACzrI,KAAK,EAAEuqI,MAAM,CAAC,GAAGkB,GAAG,CAACzrI,KAAK;MAC3E,IAAI0rI,kBAAkB,GAAG,IAAIznG,OAAO,CAACjkC,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEyrI,GAAG,CAACxrI,OAAO,EAAEwrI,GAAG,CAAC97H,WAAW,EAAE/P,EAAE,CAAC;MACrF8rI,kBAAkB,CAACvgH,OAAO,GAAGsgH,GAAG,CAACtgH,OAAO;MACxC,IAAIkgH,aAAa,EAAE;QACjBK,kBAAkB,CAACvgH,OAAO,CAACvwB,OAAO,CAACk0B,MAAM,IAAIA,MAAM,CAACsV,QAAQ,GAAGinG,aAAa,CAACv8G,MAAM,CAACsV,QAAQ,CAAC,CAAC;MAChG;MACA,OAAOsnG,kBAAkB;IAC3B,CAAC,CAAC;IACF,OAAO9iE,UAAU,CAAC1gC,KAAK,CAACsjG,OAAO,EAAE,IAAI,CAAC9F,OAAO,CAAC;EAChD;AACF;AACA,MAAM6F,mBAAmB,SAAStmG,YAAY,CAAC;EAC7CkgG,OAAOA,CAACnlI,KAAK,EAAEuqI,MAAM,EAAE;IACrB,OAAOA,MAAM,GAAGvqI,KAAK,CAACnD,GAAG,CAACqoC,CAAC,IAAIA,CAAC,CAAC1kC,KAAK,CAAC,IAAI,EAAE+pI,MAAM,CAAC,CAAC,GAAGvqI,KAAK;EAC/D;EACA0B,mBAAmBA,CAACC,EAAE,EAAE4oI,MAAM,EAAE;IAC9B,MAAM1oI,SAAS,GAAG0oI,MAAM,CAAC1kG,YAAY,CAAClkC,EAAE,CAACE,SAAS,CAAC;IACnD,MAAMC,SAAS,GAAGH,EAAE,CAACG,SAAS,GAAGyoI,MAAM,CAAC1kG,YAAY,CAAClkC,EAAE,CAACG,SAAS,CAAC,GAAGH,EAAE,CAACG,SAAS;IACjF,MAAMd,QAAQ,GAAGW,EAAE,CAACX,QAAQ,CAACnE,GAAG,CAACqoC,CAAC,IAAIA,CAAC,CAAC1kC,KAAK,CAAC,IAAI,EAAE+pI,MAAM,CAAC,CAAC;IAC5D,OAAO,IAAI3lG,cAAc,CAACjjC,EAAE,CAACxI,GAAG,EAAEwI,EAAE,CAACzJ,KAAK,EAAE2J,SAAS,EAAEC,SAAS,EAAEd,QAAQ,EAAEW,EAAE,CAACC,MAAM,EAAED,EAAE,CAACiH,UAAU,EAAEjH,EAAE,CAACg8B,eAAe,EAAEh8B,EAAE,CAACi8B,aAAa,CAAC;EAC7I;EACA37B,qBAAqBA,CAACN,EAAE,EAAE4oI,MAAM,EAAE;IAChC,MAAM1oI,SAAS,GAAG0oI,MAAM,CAAC1kG,YAAY,CAAClkC,EAAE,CAACE,SAAS,CAAC;IACnD,MAAMC,SAAS,GAAGH,EAAE,CAACG,SAAS,GAAGyoI,MAAM,CAAC1kG,YAAY,CAAClkC,EAAE,CAACG,SAAS,CAAC,GAAGH,EAAE,CAACG,SAAS;IACjF,MAAMd,QAAQ,GAAGW,EAAE,CAACX,QAAQ,CAACnE,GAAG,CAACqoC,CAAC,IAAIA,CAAC,CAAC1kC,KAAK,CAAC,IAAI,EAAE+pI,MAAM,CAAC,CAAC;IAC5D,OAAO,IAAIvlG,gBAAgB,CAACrjC,EAAE,CAACnH,IAAI,EAAEmH,EAAE,CAAC4Y,UAAU,EAAE1Y,SAAS,EAAEC,SAAS,EAAEd,QAAQ,EAAEW,EAAE,CAACiH,UAAU,EAAEjH,EAAE,CAACg8B,eAAe,EAAEh8B,EAAE,CAACi8B,aAAa,CAAC;EAC1I;EACA77B,gBAAgBA,CAACJ,EAAE,EAAE4oI,MAAM,EAAE;IAC3B,OAAO,IAAI1lG,WAAW,CAACljC,EAAE,CAAClH,KAAK,EAAE8vI,MAAM,CAAC1kG,YAAY,CAAClkC,EAAE,CAACnH,IAAI,CAAC,EAAEmH,EAAE,CAACiH,UAAU,CAAC;EAC/E;EACA5G,mBAAmBA,CAACL,EAAE,EAAE4oI,MAAM,EAAE;IAC9B,OAAO,IAAIzlG,cAAc,CAACnjC,EAAE,CAAClH,KAAK,EAAE8vI,MAAM,CAAC1kG,YAAY,CAAClkC,EAAE,CAACnH,IAAI,CAAC,EAAEmH,EAAE,CAACiH,UAAU,CAAC;EAClF;AACF;AAEA,SAAS+iI,oBAAoBA,CAACjyF,QAAQ,EAAE;EACtC,MAAMP,MAAM,GAAGyyF,4BAA4B,CAAClyF,QAAQ,CAAC;EACrD,OAAO3iC,OAAO,CAAC,EAAE,EAAE,CAACia,wBAAwB,CAACmoB,MAAM,CAAC,CAAC9sC,MAAM,CAAC,CAAC,CAAC,CAAC,CAACpD,MAAM,CAAC,EAAE,CAAC;AAC5E;AACA,SAAS2iI,4BAA4BA,CAAClyF,QAAQ,EAAE;EAC9C,OAAOtjC,UAAU,CAACwE,WAAW,CAACiK,gBAAgB,CAAC,CAAC5b,MAAM,CAAC,CAACywC,QAAQ,CAACj4C,IAAI,EAAEi4C,QAAQ,CAACmyF,UAAU,EAAEnyF,QAAQ,CAACoyF,cAAc,IAAI10H,OAAO,CAAC,IAAI,CAAC,EAAEsiC,QAAQ,CAACqyF,cAAc,IAAI30H,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;AAClL;AACA,SAAS40H,6BAA6BA,CAACtyF,QAAQ,EAAEu4E,YAAY,EAAE;EAC7D,IAAIA,YAAY,KAAK,IAAI,IAAIA,YAAY,CAACv5H,MAAM,KAAK,CAAC,EAAE;IACtD,OAAOizI,oBAAoB,CAACjyF,QAAQ,CAAC;EACvC;EACA,OAAOuyF,oCAAoC,CAACvyF,QAAQ,EAAEu4E,YAAY,CAACp1H,GAAG,CAAC+2B,GAAG,IAAI,IAAIpiB,OAAO,CAACoiB,GAAG,CAACy+F,UAAU,EAAEnrH,YAAY,CAAC,CAAC,EAAEglI,qCAAqC,CAACja,YAAY,CAAC,CAAC;AAChL;AACA,SAASka,+BAA+BA,CAACzyF,QAAQ,EAAE0yF,aAAa,EAAEC,uBAAuB,EAAE;EACzF,OAAOJ,oCAAoC,CAACvyF,QAAQ,EAAE2yF,uBAAuB,CAACxvI,GAAG,CAACrC,IAAI,IAAI,IAAIgX,OAAO,CAAChX,IAAI,EAAE0M,YAAY,CAAC,CAAC,EAAEklI,aAAa,CAAC;AAC5I;AACA,SAASH,oCAAoCA,CAACvyF,QAAQ,EAAE4yF,aAAa,EAAEtoC,oBAAoB,EAAE;EAC3F,MAAMuoC,oBAAoB,GAAGX,4BAA4B,CAAClyF,QAAQ,CAAC;EACnE,MAAM8yF,mBAAmB,GAAGz1H,OAAO,CAACu1H,aAAa,EAAE,CAACC,oBAAoB,CAAClgI,MAAM,CAAC,CAAC,CAAC,CAAC;EACnF,MAAMogI,iBAAiB,GAAGr2H,UAAU,CAACwE,WAAW,CAACkK,qBAAqB,CAAC,CAAC7b,MAAM,CAAC,CAACywC,QAAQ,CAACj4C,IAAI,EAAEuiG,oBAAoB,EAAEwoC,mBAAmB,CAAC,CAAC;EAC1I,OAAOz1H,OAAO,CAAC,EAAE,EAAE,CAACia,wBAAwB,CAACy7G,iBAAiB,CAAC,CAACpgI,MAAM,CAAC,CAAC,CAAC,CAAC,CAACpD,MAAM,CAAC,EAAE,CAAC;AACvF;AACA,SAASijI,qCAAqCA,CAACja,YAAY,EAAE;EAC3D,MAAMya,cAAc,GAAGza,YAAY,CAACp1H,GAAG,CAAC,CAAC;IACvCw1H,UAAU;IACVC,UAAU;IACVF;EACF,CAAC,KAAK;IACJ,MAAMD,OAAO,GAAGp7G,OAAO,CAAC,CAAC,IAAIvF,OAAO,CAAC,GAAG,EAAEtK,YAAY,CAAC,CAAC,EAAEiP,QAAQ,CAAC,GAAG,CAAC,CAACtN,IAAI,CAACupH,eAAe,GAAG,SAAS,GAAGC,UAAU,CAAC,CAAC;IACvH,OAAO,IAAInhH,iBAAiB,CAACohH,UAAU,CAAC,CAACzpH,IAAI,CAAC,MAAM,CAAC,CAACI,MAAM,CAAC,CAACkpH,OAAO,CAAC,CAAC;EACzE,CAAC,CAAC;EACF,OAAOp7G,OAAO,CAAC,EAAE,EAAEL,UAAU,CAACg2H,cAAc,CAAC,CAAC;AAChD;AAEA,MAAMC,gCAAgC,GAAG,QAAQ;AACjD,MAAMC,4CAA4C,GAAG,QAAQ;AAC7D,SAASC,2BAA2BA,CAACnzF,QAAQ,EAAE;EAC7C,MAAMvC,aAAa,GAAG,IAAIlL,aAAa,CAAC,CAAC;EACzCkL,aAAa,CAACz6C,GAAG,CAAC,YAAY,EAAE0a,OAAO,CAACu1H,gCAAgC,CAAC,CAAC;EAC1Ex1F,aAAa,CAACz6C,GAAG,CAAC,SAAS,EAAE0a,OAAO,CAAC,QAAQ,CAAC,CAAC;EAC/C+/B,aAAa,CAACz6C,GAAG,CAAC,UAAU,EAAE0Z,UAAU,CAACwE,WAAW,CAAC3b,IAAI,CAAC,CAAC;EAC3Dk4C,aAAa,CAACz6C,GAAG,CAAC,MAAM,EAAEg9C,QAAQ,CAACj4C,IAAI,CAAC;EACxC01C,aAAa,CAACz6C,GAAG,CAAC,YAAY,EAAEg9C,QAAQ,CAACmyF,UAAU,CAAC;EACpD10F,aAAa,CAACz6C,GAAG,CAAC,gBAAgB,EAAEg9C,QAAQ,CAACoyF,cAAc,CAAC;EAC5D30F,aAAa,CAACz6C,GAAG,CAAC,gBAAgB,EAAEg9C,QAAQ,CAACqyF,cAAc,CAAC;EAC5D,OAAO31H,UAAU,CAACwE,WAAW,CAAC+J,oBAAoB,CAAC,CAAC1b,MAAM,CAAC,CAACkuC,aAAa,CAAC/K,YAAY,CAAC,CAAC,CAAC,CAAC;AAC5F;AACA,SAAS0gG,oCAAoCA,CAACpzF,QAAQ,EAAEu4E,YAAY,EAAE;EACpE,IAAIA,YAAY,KAAK,IAAI,IAAIA,YAAY,CAACv5H,MAAM,KAAK,CAAC,EAAE;IACtD,OAAOm0I,2BAA2B,CAACnzF,QAAQ,CAAC;EAC9C;EACA,MAAMvC,aAAa,GAAG,IAAIlL,aAAa,CAAC,CAAC;EACzC,MAAM8gG,2BAA2B,GAAG,IAAI9gG,aAAa,CAAC,CAAC;EACvD8gG,2BAA2B,CAACrwI,GAAG,CAAC,YAAY,EAAEg9C,QAAQ,CAACmyF,UAAU,CAAC;EAClEkB,2BAA2B,CAACrwI,GAAG,CAAC,gBAAgB,EAAEg9C,QAAQ,CAACoyF,cAAc,IAAI10H,OAAO,CAAC,IAAI,CAAC,CAAC;EAC3F21H,2BAA2B,CAACrwI,GAAG,CAAC,gBAAgB,EAAEg9C,QAAQ,CAACqyF,cAAc,IAAI30H,OAAO,CAAC,IAAI,CAAC,CAAC;EAC3F+/B,aAAa,CAACz6C,GAAG,CAAC,YAAY,EAAE0a,OAAO,CAACw1H,4CAA4C,CAAC,CAAC;EACtFz1F,aAAa,CAACz6C,GAAG,CAAC,SAAS,EAAE0a,OAAO,CAAC,QAAQ,CAAC,CAAC;EAC/C+/B,aAAa,CAACz6C,GAAG,CAAC,UAAU,EAAE0Z,UAAU,CAACwE,WAAW,CAAC3b,IAAI,CAAC,CAAC;EAC3Dk4C,aAAa,CAACz6C,GAAG,CAAC,MAAM,EAAEg9C,QAAQ,CAACj4C,IAAI,CAAC;EACxC01C,aAAa,CAACz6C,GAAG,CAAC,qBAAqB,EAAEwvI,qCAAqC,CAACja,YAAY,CAAC,CAAC;EAC7F96E,aAAa,CAACz6C,GAAG,CAAC,iBAAiB,EAAEqa,OAAO,CAACk7G,YAAY,CAACp1H,GAAG,CAAC+2B,GAAG,IAAI,IAAIpiB,OAAO,CAACoiB,GAAG,CAACy+F,UAAU,EAAEnrH,YAAY,CAAC,CAAC,EAAE6lI,2BAA2B,CAAC3gG,YAAY,CAAC,CAAC,CAAC,CAAC;EAC7J,OAAOh2B,UAAU,CAACwE,WAAW,CAACgK,yBAAyB,CAAC,CAAC3b,MAAM,CAAC,CAACkuC,aAAa,CAAC/K,YAAY,CAAC,CAAC,CAAC,CAAC;AACjG;AAEA,SAAS4gG,sBAAsBA,CAACr2H,MAAM,EAAE4zH,MAAM,EAAE;EAC9C,IAAI5zH,MAAM,KAAK,IAAI,IAAIA,MAAM,CAACje,MAAM,KAAK,CAAC,EAAE;IAC1C,OAAO,IAAI;EACb;EACA,OAAOge,UAAU,CAACC,MAAM,CAAC9Z,GAAG,CAACpC,KAAK,IAAI8vI,MAAM,CAAC9vI,KAAK,CAAC,CAAC,CAAC;AACvD;AACA,SAASwyI,oBAAoBA,CAACC,MAAM,EAAE3C,MAAM,EAAE;EAC5C,MAAM52H,OAAO,GAAGzU,MAAM,CAACmC,IAAI,CAAC6rI,MAAM,CAAC,CAACrwI,GAAG,CAACkM,GAAG,IAAI;IAC7C,MAAMtO,KAAK,GAAGyyI,MAAM,CAACnkI,GAAG,CAAC;IACzB,OAAO;MACLA,GAAG;MACHtO,KAAK,EAAE8vI,MAAM,CAAC9vI,KAAK,CAAC;MACpBsZ,MAAM,EAAE;IACV,CAAC;EACH,CAAC,CAAC;EACF,IAAIJ,OAAO,CAACjb,MAAM,GAAG,CAAC,EAAE;IACtB,OAAOke,UAAU,CAACjD,OAAO,CAAC;EAC5B,CAAC,MAAM;IACL,OAAO,IAAI;EACb;AACF;AACA,SAASw5H,mBAAmBA,CAAC76G,IAAI,EAAE;EACjC,IAAIA,IAAI,KAAK,SAAS,EAAE;IACtB,OAAOlb,OAAO,CAAC,SAAS,CAAC;EAC3B,CAAC,MAAM,IAAIkb,IAAI,KAAK,IAAI,EAAE;IACxB,OAAOlb,OAAO,CAAC,IAAI,CAAC;EACtB,CAAC,MAAM;IACL,OAAOV,UAAU,CAAC4b,IAAI,CAACz1B,GAAG,CAACuwI,iBAAiB,CAAC,CAAC;EAChD;AACF;AACA,SAASA,iBAAiBA,CAACx5G,GAAG,EAAE;EAC9B,MAAMy5G,OAAO,GAAG,IAAIphG,aAAa,CAAC,CAAC;EACnCohG,OAAO,CAAC3wI,GAAG,CAAC,OAAO,EAAEk3B,GAAG,CAAC7K,KAAK,CAAC;EAC/B,IAAI6K,GAAG,CAACE,iBAAiB,KAAK,IAAI,EAAE;IAClCu5G,OAAO,CAAC3wI,GAAG,CAAC,WAAW,EAAE0a,OAAO,CAAC,IAAI,CAAC,CAAC;EACzC;EACA,IAAIwc,GAAG,CAACK,IAAI,EAAE;IACZo5G,OAAO,CAAC3wI,GAAG,CAAC,MAAM,EAAE0a,OAAO,CAAC,IAAI,CAAC,CAAC;EACpC;EACA,IAAIwc,GAAG,CAACM,QAAQ,EAAE;IAChBm5G,OAAO,CAAC3wI,GAAG,CAAC,UAAU,EAAE0a,OAAO,CAAC,IAAI,CAAC,CAAC;EACxC;EACA,IAAIwc,GAAG,CAACG,IAAI,EAAE;IACZs5G,OAAO,CAAC3wI,GAAG,CAAC,MAAM,EAAE0a,OAAO,CAAC,IAAI,CAAC,CAAC;EACpC;EACA,IAAIwc,GAAG,CAACI,QAAQ,EAAE;IAChBq5G,OAAO,CAAC3wI,GAAG,CAAC,UAAU,EAAE0a,OAAO,CAAC,IAAI,CAAC,CAAC;EACxC;EACA,OAAOi2H,OAAO,CAACjhG,YAAY,CAAC,CAAC;AAC/B;AAEA,SAASkhG,mCAAmCA,CAACt7G,IAAI,EAAE;EACjD,MAAMmlB,aAAa,GAAGo2F,4BAA4B,CAACv7G,IAAI,CAAC;EACxD,MAAMxwB,UAAU,GAAG4U,UAAU,CAACwE,WAAW,CAACgJ,gBAAgB,CAAC,CAAC3a,MAAM,CAAC,CAACkuC,aAAa,CAAC/K,YAAY,CAAC,CAAC,CAAC,CAAC;EAClG,MAAM3qC,IAAI,GAAGgtH,mBAAmB,CAACz8F,IAAI,CAAC;EACtC,OAAO;IACLxwB,UAAU;IACVC,IAAI;IACJkQ,UAAU,EAAE;EACd,CAAC;AACH;AACA,SAAS47H,4BAA4BA,CAACv7G,IAAI,EAAE;EAC1C,MAAMmlB,aAAa,GAAG,IAAIlL,aAAa,CAAC,CAAC;EACzC,MAAMuhG,UAAU,GAAGC,iCAAiC,CAACz7G,IAAI,CAAC;EAC1DmlB,aAAa,CAACz6C,GAAG,CAAC,YAAY,EAAE0a,OAAO,CAACo2H,UAAU,CAAC,CAAC;EACpDr2F,aAAa,CAACz6C,GAAG,CAAC,SAAS,EAAE0a,OAAO,CAAC,QAAQ,CAAC,CAAC;EAC/C+/B,aAAa,CAACz6C,GAAG,CAAC,MAAM,EAAEs1B,IAAI,CAACvwB,IAAI,CAAChH,KAAK,CAAC;EAC1C,IAAIu3B,IAAI,CAAC6nB,YAAY,KAAKtxB,SAAS,EAAE;IACnC4uB,aAAa,CAACz6C,GAAG,CAAC,cAAc,EAAE0a,OAAO,CAAC4a,IAAI,CAAC6nB,YAAY,CAAC,CAAC;EAC/D;EACA,IAAI7nB,IAAI,CAAC8Z,QAAQ,EAAE;IACjBqL,aAAa,CAACz6C,GAAG,CAAC,UAAU,EAAE0a,OAAO,CAAC4a,IAAI,CAAC8Z,QAAQ,CAAC,CAAC;EACvD;EACA,IAAI9Z,IAAI,CAAC35B,QAAQ,KAAK,IAAI,EAAE;IAC1B8+C,aAAa,CAACz6C,GAAG,CAAC,UAAU,EAAE0a,OAAO,CAAC4a,IAAI,CAAC35B,QAAQ,CAAC,CAAC;EACvD;EACA8+C,aAAa,CAACz6C,GAAG,CAAC,QAAQ,EAAEgxI,0BAA0B,CAAC17G,IAAI,CAAC,GAAG27G,2BAA2B,CAAC37G,IAAI,CAACsL,MAAM,CAAC,GAAGswG,2BAA2B,CAAC57G,IAAI,CAACsL,MAAM,CAAC,CAAC;EACnJ6Z,aAAa,CAACz6C,GAAG,CAAC,SAAS,EAAEyuC,0CAA0C,CAACnZ,IAAI,CAACuL,OAAO,CAAC,CAAC;EACtF4Z,aAAa,CAACz6C,GAAG,CAAC,MAAM,EAAEmxI,mBAAmB,CAAC77G,IAAI,CAACiC,IAAI,CAAC,CAAC;EACzDkjB,aAAa,CAACz6C,GAAG,CAAC,WAAW,EAAEs1B,IAAI,CAAColB,SAAS,CAAC;EAC9C,IAAIplB,IAAI,CAAC8mF,OAAO,CAACpgH,MAAM,GAAG,CAAC,EAAE;IAC3By+C,aAAa,CAACz6C,GAAG,CAAC,SAAS,EAAEga,UAAU,CAACsb,IAAI,CAAC8mF,OAAO,CAACj8G,GAAG,CAACixI,YAAY,CAAC,CAAC,CAAC;EAC1E;EACA,IAAI97G,IAAI,CAACqmF,WAAW,CAAC3/G,MAAM,GAAG,CAAC,EAAE;IAC/By+C,aAAa,CAACz6C,GAAG,CAAC,aAAa,EAAEga,UAAU,CAACsb,IAAI,CAACqmF,WAAW,CAACx7G,GAAG,CAACixI,YAAY,CAAC,CAAC,CAAC;EAClF;EACA,IAAI97G,IAAI,CAAC47F,QAAQ,KAAK,IAAI,EAAE;IAC1Bz2E,aAAa,CAACz6C,GAAG,CAAC,UAAU,EAAEwuC,SAAS,CAAClZ,IAAI,CAAC47F,QAAQ,CAAC,CAAC;EACzD;EACA,IAAI57F,IAAI,CAACk8F,eAAe,EAAE;IACxB/2E,aAAa,CAACz6C,GAAG,CAAC,iBAAiB,EAAE0a,OAAO,CAAC,IAAI,CAAC,CAAC;EACrD;EACA,IAAI4a,IAAI,CAACm8F,SAAS,CAACC,aAAa,EAAE;IAChCj3E,aAAa,CAACz6C,GAAG,CAAC,eAAe,EAAE0a,OAAO,CAAC,IAAI,CAAC,CAAC;EACnD;EACA,IAAI4a,IAAI,CAACg8F,cAAc,EAAEt1H,MAAM,EAAE;IAC/By+C,aAAa,CAACz6C,GAAG,CAAC,gBAAgB,EAAEqxI,oBAAoB,CAAC/7G,IAAI,CAACg8F,cAAc,CAAC,CAAC;EAChF;EACA72E,aAAa,CAACz6C,GAAG,CAAC,UAAU,EAAE0Z,UAAU,CAACwE,WAAW,CAAC3b,IAAI,CAAC,CAAC;EAC3D,OAAOk4C,aAAa;AACtB;AACA,SAASs2F,iCAAiCA,CAACz7G,IAAI,EAAE;EAC/C,IAAIw7G,UAAU,GAAG,QAAQ;EACzB,MAAMQ,8BAA8B,GAAG9uI,MAAM,CAACyX,MAAM,CAACqb,IAAI,CAACsL,MAAM,CAAC,CAAC6M,IAAI,CAACziB,KAAK,IAAIA,KAAK,CAACmkB,iBAAiB,KAAK,IAAI,CAAC;EACjH,IAAImiG,8BAA8B,EAAE;IAClCR,UAAU,GAAG,QAAQ;EACvB;EACA,IAAIE,0BAA0B,CAAC17G,IAAI,CAAC,EAAE;IACpCw7G,UAAU,GAAG,QAAQ;EACvB;EACA,IAAIx7G,IAAI,CAAC8mF,OAAO,CAAC3uE,IAAI,CAACwmF,CAAC,IAAIA,CAAC,CAAC7kF,QAAQ,CAAC,IAAI9Z,IAAI,CAACqmF,WAAW,CAACluE,IAAI,CAACwmF,CAAC,IAAIA,CAAC,CAAC7kF,QAAQ,CAAC,EAAE;IAChF0hG,UAAU,GAAG,QAAQ;EACvB;EACA,OAAOA,UAAU;AACnB;AACA,SAASE,0BAA0BA,CAAC17G,IAAI,EAAE;EACxC,OAAO9yB,MAAM,CAACyX,MAAM,CAACqb,IAAI,CAACsL,MAAM,CAAC,CAAC6M,IAAI,CAACziB,KAAK,IAAIA,KAAK,CAACokB,QAAQ,CAAC;AACjE;AACA,SAASgiG,YAAYA,CAAC12B,KAAK,EAAE;EAC3B,MAAMplF,IAAI,GAAG,IAAIia,aAAa,CAAC,CAAC;EAChCja,IAAI,CAACt1B,GAAG,CAAC,cAAc,EAAE0a,OAAO,CAACggG,KAAK,CAACvnB,YAAY,CAAC,CAAC;EACrD,IAAIunB,KAAK,CAACllD,KAAK,EAAE;IACflgC,IAAI,CAACt1B,GAAG,CAAC,OAAO,EAAE0a,OAAO,CAAC,IAAI,CAAC,CAAC;EAClC;EACA4a,IAAI,CAACt1B,GAAG,CAAC,WAAW,EAAEuV,KAAK,CAACC,OAAO,CAACklG,KAAK,CAACzmC,SAAS,CAAC,GAAGzlC,SAAS,CAACksE,KAAK,CAACzmC,SAAS,CAAC,GAAG/+C,oCAAoC,CAACwlF,KAAK,CAACzmC,SAAS,CAAC,CAAC;EAC1I,IAAI,CAACymC,KAAK,CAACG,uBAAuB,EAAE;IAClCvlF,IAAI,CAACt1B,GAAG,CAAC,yBAAyB,EAAE0a,OAAO,CAAC,KAAK,CAAC,CAAC;EACrD;EACA,IAAIggG,KAAK,CAACC,WAAW,EAAE;IACrBrlF,IAAI,CAACt1B,GAAG,CAAC,aAAa,EAAE0a,OAAO,CAAC,IAAI,CAAC,CAAC;EACxC;EACA4a,IAAI,CAACt1B,GAAG,CAAC,MAAM,EAAE06G,KAAK,CAACzzC,IAAI,CAAC;EAC5B,IAAIyzC,KAAK,CAACE,MAAM,EAAE;IAChBtlF,IAAI,CAACt1B,GAAG,CAAC,QAAQ,EAAE0a,OAAO,CAAC,IAAI,CAAC,CAAC;EACnC;EACA,IAAIggG,KAAK,CAACtrE,QAAQ,EAAE;IAClB9Z,IAAI,CAACt1B,GAAG,CAAC,UAAU,EAAE0a,OAAO,CAAC,IAAI,CAAC,CAAC;EACrC;EACA,OAAO4a,IAAI,CAACoa,YAAY,CAAC,CAAC;AAC5B;AACA,SAASyhG,mBAAmBA,CAAC77G,IAAI,EAAE;EACjC,MAAMi8G,YAAY,GAAG,IAAIhiG,aAAa,CAAC,CAAC;EACxCgiG,YAAY,CAACvxI,GAAG,CAAC,YAAY,EAAEuwI,oBAAoB,CAACj7G,IAAI,CAACqL,UAAU,EAAE77B,UAAU,IAAIA,UAAU,CAAC,CAAC;EAC/FysI,YAAY,CAACvxI,GAAG,CAAC,WAAW,EAAEuwI,oBAAoB,CAACj7G,IAAI,CAACsR,SAAS,EAAElsB,OAAO,CAAC,CAAC;EAC5E62H,YAAY,CAACvxI,GAAG,CAAC,YAAY,EAAEuwI,oBAAoB,CAACj7G,IAAI,CAACs+D,UAAU,EAAEl5E,OAAO,CAAC,CAAC;EAC9E,IAAI4a,IAAI,CAAC++F,iBAAiB,CAACC,SAAS,EAAE;IACpCid,YAAY,CAACvxI,GAAG,CAAC,gBAAgB,EAAE0a,OAAO,CAAC4a,IAAI,CAAC++F,iBAAiB,CAACC,SAAS,CAAC,CAAC;EAC/E;EACA,IAAIh/F,IAAI,CAAC++F,iBAAiB,CAACE,SAAS,EAAE;IACpCgd,YAAY,CAACvxI,GAAG,CAAC,gBAAgB,EAAE0a,OAAO,CAAC4a,IAAI,CAAC++F,iBAAiB,CAACE,SAAS,CAAC,CAAC;EAC/E;EACA,IAAIgd,YAAY,CAACt3H,MAAM,CAACje,MAAM,GAAG,CAAC,EAAE;IAClC,OAAOu1I,YAAY,CAAC7hG,YAAY,CAAC,CAAC;EACpC,CAAC,MAAM;IACL,OAAO,IAAI;EACb;AACF;AACA,SAAS2hG,oBAAoBA,CAAC/f,cAAc,EAAE;EAC5C,MAAMz/G,WAAW,GAAGy/G,cAAc,CAACnxH,GAAG,CAAC/D,OAAO,IAAI;IAChD,MAAMuI,IAAI,GAAG,CAAC;MACZ0H,GAAG,EAAE,WAAW;MAChBtO,KAAK,EAAE3B,OAAO,CAACg5H,kBAAkB,GAAGjgG,kBAAkB,CAAC/4B,OAAO,CAAC+qC,SAAS,CAACpiC,IAAI,CAAC,GAAG3I,OAAO,CAAC+qC,SAAS,CAACpiC,IAAI;MACvGsS,MAAM,EAAE;IACV,CAAC,CAAC;IACF,MAAM49G,aAAa,GAAG74H,OAAO,CAACwkC,MAAM,GAAGs0F,gCAAgC,CAAC94H,OAAO,CAACwkC,MAAM,CAAC,GAAG,IAAI;IAC9F,MAAMu0F,cAAc,GAAG/4H,OAAO,CAACykC,OAAO,GAAGq0F,gCAAgC,CAAC94H,OAAO,CAACykC,OAAO,CAAC,GAAG,IAAI;IACjG,IAAIo0F,aAAa,EAAE;MACjBtwH,IAAI,CAAC1I,IAAI,CAAC;QACRoQ,GAAG,EAAE,QAAQ;QACbtO,KAAK,EAAEk3H,aAAa;QACpB59G,MAAM,EAAE;MACV,CAAC,CAAC;IACJ;IACA,IAAI89G,cAAc,EAAE;MAClBxwH,IAAI,CAAC1I,IAAI,CAAC;QACRoQ,GAAG,EAAE,SAAS;QACdtO,KAAK,EAAEo3H,cAAc;QACrB99G,MAAM,EAAE;MACV,CAAC,CAAC;IACJ;IACA,OAAO6C,UAAU,CAACvV,IAAI,CAAC;EACzB,CAAC,CAAC;EACF,OAAOqV,UAAU,CAACnI,WAAW,CAAC;AAChC;AACA,SAASo/H,2BAA2BA,CAACrwG,MAAM,EAAE;EAC3C,MAAMj8B,IAAI,GAAGnC,MAAM,CAACmsC,mBAAmB,CAAC/N,MAAM,CAAC;EAC/C,IAAIj8B,IAAI,CAAC3I,MAAM,KAAK,CAAC,EAAE;IACrB,OAAO,IAAI;EACb;EACA,OAAOke,UAAU,CAACvV,IAAI,CAACxE,GAAG,CAACyuC,YAAY,IAAI;IACzC,MAAM7wC,KAAK,GAAG6iC,MAAM,CAACgO,YAAY,CAAC;IAClC,OAAO;MACLviC,GAAG,EAAEuiC,YAAY;MACjBv3B,MAAM,EAAE62B,6BAA6B,CAAC7gB,IAAI,CAACuhB,YAAY,CAAC;MACxD7wC,KAAK,EAAEmc,UAAU,CAAC,CAAC;QACjB7N,GAAG,EAAE,mBAAmB;QACxBgL,MAAM,EAAE,KAAK;QACbtZ,KAAK,EAAEywC,SAAS,CAACzwC,KAAK,CAACgxC,iBAAiB;MAC1C,CAAC,EAAE;QACD1iC,GAAG,EAAE,YAAY;QACjBgL,MAAM,EAAE,KAAK;QACbtZ,KAAK,EAAEywC,SAAS,CAACzwC,KAAK,CAACixC,mBAAmB;MAC5C,CAAC,EAAE;QACD3iC,GAAG,EAAE,UAAU;QACfgL,MAAM,EAAE,KAAK;QACbtZ,KAAK,EAAEywC,SAAS,CAACzwC,KAAK,CAACqxC,QAAQ;MACjC,CAAC,EAAE;QACD/iC,GAAG,EAAE,YAAY;QACjBgL,MAAM,EAAE,KAAK;QACbtZ,KAAK,EAAEywC,SAAS,CAACzwC,KAAK,CAACm2H,QAAQ;MACjC,CAAC,EAAE;QACD7nH,GAAG,EAAE,mBAAmB;QACxBgL,MAAM,EAAE,KAAK;QACbtZ,KAAK,EAAEA,KAAK,CAACoxC,iBAAiB,IAAIv3B;MACpC,CAAC,CAAC;IACJ,CAAC;EACH,CAAC,CAAC,CAAC;AACL;AACA,SAASs5H,2BAA2BA,CAACtwG,MAAM,EAAE;EAC3C,MAAMj8B,IAAI,GAAGnC,MAAM,CAACmsC,mBAAmB,CAAC/N,MAAM,CAAC;EAC/C,IAAIj8B,IAAI,CAAC3I,MAAM,KAAK,CAAC,EAAE;IACrB,OAAO,IAAI;EACb;EACA,OAAOke,UAAU,CAACvV,IAAI,CAACxE,GAAG,CAACyuC,YAAY,IAAI;IACzC,MAAM7wC,KAAK,GAAG6iC,MAAM,CAACgO,YAAY,CAAC;IAClC,MAAMrF,UAAU,GAAGxrC,KAAK,CAACixC,mBAAmB;IAC5C,MAAMC,sBAAsB,GAAG1F,UAAU,KAAKqF,YAAY;IAC1D,IAAI1xC,MAAM;IACV,IAAI+xC,sBAAsB,IAAIlxC,KAAK,CAACoxC,iBAAiB,KAAK,IAAI,EAAE;MAC9D,MAAMl1B,MAAM,GAAG,CAACu0B,SAAS,CAACjF,UAAU,CAAC,EAAEiF,SAAS,CAACI,YAAY,CAAC,CAAC;MAC/D,IAAI7wC,KAAK,CAACoxC,iBAAiB,KAAK,IAAI,EAAE;QACpCl1B,MAAM,CAAChe,IAAI,CAAC8B,KAAK,CAACoxC,iBAAiB,CAAC;MACtC;MACAjyC,MAAM,GAAG8c,UAAU,CAACC,MAAM,CAAC;IAC7B,CAAC,MAAM;MACL/c,MAAM,GAAGsxC,SAAS,CAACjF,UAAU,CAAC;IAChC;IACA,OAAO;MACLl9B,GAAG,EAAEuiC,YAAY;MACjBv3B,MAAM,EAAE62B,6BAA6B,CAAC7gB,IAAI,CAACuhB,YAAY,CAAC;MACxD7wC,KAAK,EAAEb;IACT,CAAC;EACH,CAAC,CAAC,CAAC;AACL;AAEA,SAASs0I,mCAAmCA,CAACl8G,IAAI,EAAErkB,QAAQ,EAAEwgI,sBAAsB,EAAE;EACnF,MAAMh3F,aAAa,GAAGi3F,4BAA4B,CAACp8G,IAAI,EAAErkB,QAAQ,EAAEwgI,sBAAsB,CAAC;EAC1F,MAAM3sI,UAAU,GAAG4U,UAAU,CAACwE,WAAW,CAAC0I,gBAAgB,CAAC,CAACra,MAAM,CAAC,CAACkuC,aAAa,CAAC/K,YAAY,CAAC,CAAC,CAAC,CAAC;EAClG,MAAM3qC,IAAI,GAAGsuH,mBAAmB,CAAC/9F,IAAI,CAAC;EACtC,OAAO;IACLxwB,UAAU;IACVC,IAAI;IACJkQ,UAAU,EAAE;EACd,CAAC;AACH;AACA,SAASy8H,4BAA4BA,CAACp8G,IAAI,EAAErkB,QAAQ,EAAE0gI,YAAY,EAAE;EAClE,MAAMl3F,aAAa,GAAGo2F,4BAA4B,CAACv7G,IAAI,CAAC;EACxD,MAAMs8G,YAAY,GAAG,IAAIC,oBAAoB,CAAC,CAAC;EAC/CnuG,UAAU,CAACkuG,YAAY,EAAE3gI,QAAQ,CAAC3N,KAAK,CAAC;EACxCm3C,aAAa,CAACz6C,GAAG,CAAC,UAAU,EAAE8xI,qBAAqB,CAAC7gI,QAAQ,EAAE0gI,YAAY,CAAC,CAAC;EAC5E,IAAIA,YAAY,CAACI,QAAQ,EAAE;IACzBt3F,aAAa,CAACz6C,GAAG,CAAC,UAAU,EAAE0a,OAAO,CAAC,IAAI,CAAC,CAAC;EAC9C;EACA,IAAIk3H,YAAY,CAACI,SAAS,EAAE;IAC1Bv3F,aAAa,CAACz6C,GAAG,CAAC,YAAY,EAAE0a,OAAO,CAAC,QAAQ,CAAC,CAAC;EACpD;EACA+/B,aAAa,CAACz6C,GAAG,CAAC,QAAQ,EAAEswI,sBAAsB,CAACh7G,IAAI,CAACwtC,MAAM,EAAEpoD,OAAO,CAAC,CAAC;EACzE+/B,aAAa,CAACz6C,GAAG,CAAC,cAAc,EAAEiyI,+BAA+B,CAAC38G,IAAI,CAAC,CAAC;EACxEmlB,aAAa,CAACz6C,GAAG,CAAC,eAAe,EAAEs1B,IAAI,CAAC+7F,aAAa,CAAC;EACtD52E,aAAa,CAACz6C,GAAG,CAAC,YAAY,EAAEs1B,IAAI,CAAC49F,UAAU,CAAC;EAChD,IAAI59F,IAAI,CAAC69F,eAAe,KAAK,IAAI,EAAE;IACjC,IAAI,OAAO79F,IAAI,CAAC69F,eAAe,KAAK,QAAQ,EAAE;MAC5C,MAAM,IAAI32H,KAAK,CAAC,0DAA0D,CAAC;IAC7E;IACAi+C,aAAa,CAACz6C,GAAG,CAAC,iBAAiB,EAAE0Z,UAAU,CAACwE,WAAW,CAAC3c,uBAAuB,CAAC,CAAC4K,IAAI,CAAC5K,uBAAuB,CAAC+zB,IAAI,CAAC69F,eAAe,CAAC,CAAC,CAAC;EAC3I;EACA,IAAI79F,IAAI,CAACq9F,aAAa,KAAKtxH,mBAAmB,CAACuxH,QAAQ,EAAE;IACvDn4E,aAAa,CAACz6C,GAAG,CAAC,eAAe,EAAE0Z,UAAU,CAACwE,WAAW,CAAC5c,iBAAiB,CAAC,CAAC6K,IAAI,CAAC9K,mBAAmB,CAACi0B,IAAI,CAACq9F,aAAa,CAAC,CAAC,CAAC;EAC7H;EACA,IAAI1hH,QAAQ,CAAC++G,mBAAmB,KAAK,IAAI,EAAE;IACzCv1E,aAAa,CAACz6C,GAAG,CAAC,qBAAqB,EAAE0a,OAAO,CAAC,IAAI,CAAC,CAAC;EACzD;EACA,IAAI4a,IAAI,CAAC5U,KAAK,CAAC27C,IAAI,KAAK,CAAC,EAAE;IACzB,MAAM61E,SAAS,GAAG,EAAE;IACpB,IAAIC,YAAY,GAAG,KAAK;IACxB,KAAK,MAAMv8G,IAAI,IAAIN,IAAI,CAAC5U,KAAK,CAACinC,MAAM,CAAC1tC,MAAM,CAAC,CAAC,EAAE;MAC7C,IAAI2b,IAAI,KAAK,IAAI,EAAE;QACjBs8G,SAAS,CAACj2I,IAAI,CAACye,OAAO,CAAC,IAAI,CAAC,CAAC;MAC/B,CAAC,MAAM;QACLw3H,SAAS,CAACj2I,IAAI,CAAC25B,IAAI,CAAC;QACpBu8G,YAAY,GAAG,IAAI;MACrB;IACF;IACA,IAAIA,YAAY,EAAE;MAChB13F,aAAa,CAACz6C,GAAG,CAAC,wBAAwB,EAAEga,UAAU,CAACk4H,SAAS,CAAC,CAAC;IACpE;EACF,CAAC,MAAM;IACL,MAAM,IAAI11I,KAAK,CAAC,6DAA6D,CAAC;EAChF;EACA,OAAOi+C,aAAa;AACtB;AACA,SAASq3F,qBAAqBA,CAAC7gI,QAAQ,EAAE0gI,YAAY,EAAE;EACrD,IAAIA,YAAY,CAACS,+BAA+B,KAAK,IAAI,EAAE;IACzD,OAAOT,YAAY,CAACS,+BAA+B;EACrD;EACA,IAAIT,YAAY,CAACI,QAAQ,EAAE;IACzB,OAAOr3H,OAAO,CAACi3H,YAAY,CAAC5jH,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC;EAClD;EACA,MAAM0+F,QAAQ,GAAGklB,YAAY,CAAC5jH,OAAO;EACrC,MAAMN,IAAI,GAAG,IAAIgpB,eAAe,CAACg2E,QAAQ,EAAEklB,YAAY,CAACxjH,SAAS,CAAC;EAClE,MAAMkE,KAAK,GAAG,IAAIkjB,aAAa,CAAC9nB,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAC9C,MAAMplB,GAAG,GAAGgqI,kBAAkB,CAAC5kH,IAAI,EAAEg/F,QAAQ,CAAC;EAC9C,MAAMt6F,IAAI,GAAG,IAAIukB,eAAe,CAACrkB,KAAK,EAAEhqB,GAAG,CAAC;EAC5C,OAAOqS,OAAO,CAAC+xG,QAAQ,EAAE,IAAI,EAAEt6F,IAAI,CAAC;AACtC;AACA,SAASkgH,kBAAkBA,CAAC5kH,IAAI,EAAEg/F,QAAQ,EAAE;EAC1C,MAAMzwH,MAAM,GAAGywH,QAAQ,CAACzwH,MAAM;EAC9B,IAAIs2I,SAAS,GAAG,CAAC;EACjB,IAAIC,aAAa,GAAG,CAAC;EACrB,IAAIxgH,IAAI,GAAG,CAAC;EACZ,GAAG;IACDugH,SAAS,GAAG7lB,QAAQ,CAAChhG,OAAO,CAAC,IAAI,EAAE8mH,aAAa,CAAC;IACjD,IAAID,SAAS,KAAK,CAAC,CAAC,EAAE;MACpBC,aAAa,GAAGD,SAAS,GAAG,CAAC;MAC7BvgH,IAAI,EAAE;IACR;EACF,CAAC,QAAQugH,SAAS,KAAK,CAAC,CAAC;EACzB,OAAO,IAAI/8F,aAAa,CAAC9nB,IAAI,EAAEzxB,MAAM,EAAE+1B,IAAI,EAAE/1B,MAAM,GAAGu2I,aAAa,CAAC;AACtE;AACA,SAASN,+BAA+BA,CAAC38G,IAAI,EAAE;EAC7C,MAAMk9G,QAAQ,GAAGl9G,IAAI,CAACk9F,uBAAuB,KAAK,CAAC,GAAGr9F,kBAAkB,GAAG/kB,IAAI,IAAIA,IAAI;EACvF,IAAIklB,IAAI,CAACk9F,uBAAuB,KAAK,CAAC,EAAE;IACtC,MAAM,IAAIh2H,KAAK,CAAC,uBAAuB,CAAC;EAC1C;EACA,OAAO8zI,sBAAsB,CAACh7G,IAAI,CAACgmB,YAAY,EAAEjU,IAAI,IAAI;IACvD,QAAQA,IAAI,CAACkQ,IAAI;MACf,KAAKz0C,wBAAwB,CAACo1B,SAAS;QACrC,MAAMu6G,OAAO,GAAG,IAAIljG,aAAa,CAAC,CAAC;QACnCkjG,OAAO,CAACzyI,GAAG,CAAC,MAAM,EAAE0a,OAAO,CAAC2sB,IAAI,CAACkyF,WAAW,GAAG,WAAW,GAAG,WAAW,CAAC,CAAC;QAC1EkZ,OAAO,CAACzyI,GAAG,CAAC,MAAM,EAAEwyI,QAAQ,CAACnrG,IAAI,CAACtiC,IAAI,CAAC,CAAC;QACxC0tI,OAAO,CAACzyI,GAAG,CAAC,UAAU,EAAE0a,OAAO,CAAC2sB,IAAI,CAAC1rC,QAAQ,CAAC,CAAC;QAC/C82I,OAAO,CAACzyI,GAAG,CAAC,QAAQ,EAAEswI,sBAAsB,CAACjpG,IAAI,CAACzG,MAAM,EAAElmB,OAAO,CAAC,CAAC;QACnE+3H,OAAO,CAACzyI,GAAG,CAAC,SAAS,EAAEswI,sBAAsB,CAACjpG,IAAI,CAACxG,OAAO,EAAEnmB,OAAO,CAAC,CAAC;QACrE+3H,OAAO,CAACzyI,GAAG,CAAC,UAAU,EAAEswI,sBAAsB,CAACjpG,IAAI,CAAC6pF,QAAQ,EAAEx2G,OAAO,CAAC,CAAC;QACvE,OAAO+3H,OAAO,CAAC/iG,YAAY,CAAC,CAAC;MAC/B,KAAK5sC,wBAAwB,CAAC20B,IAAI;QAChC,MAAMi7G,QAAQ,GAAG,IAAInjG,aAAa,CAAC,CAAC;QACpCmjG,QAAQ,CAAC1yI,GAAG,CAAC,MAAM,EAAE0a,OAAO,CAAC,MAAM,CAAC,CAAC;QACrCg4H,QAAQ,CAAC1yI,GAAG,CAAC,MAAM,EAAEwyI,QAAQ,CAACnrG,IAAI,CAACtiC,IAAI,CAAC,CAAC;QACzC2tI,QAAQ,CAAC1yI,GAAG,CAAC,MAAM,EAAE0a,OAAO,CAAC2sB,IAAI,CAACvpC,IAAI,CAAC,CAAC;QACxC,OAAO40I,QAAQ,CAAChjG,YAAY,CAAC,CAAC;MAChC,KAAK5sC,wBAAwB,CAACq1B,QAAQ;QACpC,MAAMw6G,YAAY,GAAG,IAAIpjG,aAAa,CAAC,CAAC;QACxCojG,YAAY,CAAC3yI,GAAG,CAAC,MAAM,EAAE0a,OAAO,CAAC,UAAU,CAAC,CAAC;QAC7Ci4H,YAAY,CAAC3yI,GAAG,CAAC,MAAM,EAAEwyI,QAAQ,CAACnrG,IAAI,CAACtiC,IAAI,CAAC,CAAC;QAC7C,OAAO4tI,YAAY,CAACjjG,YAAY,CAAC,CAAC;IACtC;EACF,CAAC,CAAC;AACJ;AACA,MAAMmiG,oBAAoB,SAAShrG,kBAAkB,CAAC;EACpDmrG,SAAS,GAAG,KAAK;EACjBxuG,kBAAkBA,CAAA,EAAG;IACnB,IAAI,CAACwuG,SAAS,GAAG,IAAI;EACvB;EACAxvG,6BAA6BA,CAAA,EAAG;IAC9B,IAAI,CAACwvG,SAAS,GAAG,IAAI;EACvB;EACArvG,yBAAyBA,CAAA,EAAG;IAC1B,IAAI,CAACqvG,SAAS,GAAG,IAAI;EACvB;EACAnvG,uBAAuBA,CAAA,EAAG;IACxB,IAAI,CAACmvG,SAAS,GAAG,IAAI;EACvB;EACAntG,YAAYA,CAAA,EAAG;IACb,IAAI,CAACmtG,SAAS,GAAG,IAAI;EACvB;EACAhtG,kBAAkBA,CAAA,EAAG;IACnB,IAAI,CAACgtG,SAAS,GAAG,IAAI;EACvB;EACAxtG,iBAAiBA,CAAA,EAAG;IAClB,IAAI,CAACwtG,SAAS,GAAG,IAAI;EACvB;EACAttG,sBAAsBA,CAAA,EAAG;IACvB,IAAI,CAACstG,SAAS,GAAG,IAAI;EACvB;EACAjuG,gBAAgBA,CAAA,EAAG;IACjB,IAAI,CAACiuG,SAAS,GAAG,IAAI;EACvB;EACA/tG,oBAAoBA,CAAA,EAAG;IACrB,IAAI,CAAC+tG,SAAS,GAAG,IAAI;EACvB;AACF;AAEA,MAAMY,gCAAgC,GAAG,QAAQ;AACjD,SAASC,6BAA6BA,CAACv9G,IAAI,EAAE;EAC3C,MAAMmlB,aAAa,GAAG,IAAIlL,aAAa,CAAC,CAAC;EACzCkL,aAAa,CAACz6C,GAAG,CAAC,YAAY,EAAE0a,OAAO,CAACk4H,gCAAgC,CAAC,CAAC;EAC1En4F,aAAa,CAACz6C,GAAG,CAAC,SAAS,EAAE0a,OAAO,CAAC,QAAQ,CAAC,CAAC;EAC/C+/B,aAAa,CAACz6C,GAAG,CAAC,UAAU,EAAE0Z,UAAU,CAACwE,WAAW,CAAC3b,IAAI,CAAC,CAAC;EAC3Dk4C,aAAa,CAACz6C,GAAG,CAAC,MAAM,EAAEs1B,IAAI,CAACvwB,IAAI,CAAChH,KAAK,CAAC;EAC1C08C,aAAa,CAACz6C,GAAG,CAAC,MAAM,EAAEywI,mBAAmB,CAACn7G,IAAI,CAACM,IAAI,CAAC,CAAC;EACzD6kB,aAAa,CAACz6C,GAAG,CAAC,QAAQ,EAAE0Z,UAAU,CAACwE,WAAW,CAACtb,aAAa,CAAC,CAACuJ,IAAI,CAACvJ,aAAa,CAAC0yB,IAAI,CAACQ,MAAM,CAAC,CAAC,CAAC;EACnG,OAAO;IACLhxB,UAAU,EAAE4U,UAAU,CAACwE,WAAW,CAAC8I,cAAc,CAAC,CAACza,MAAM,CAAC,CAACkuC,aAAa,CAAC/K,YAAY,CAAC,CAAC,CAAC,CAAC;IACzFz6B,UAAU,EAAE,EAAE;IACdlQ,IAAI,EAAE+xB,iBAAiB,CAACxB,IAAI;EAC9B,CAAC;AACH;AAEA,MAAMw9G,gCAAgC,GAAG,QAAQ;AACjD,SAASC,oCAAoCA,CAACz9G,IAAI,EAAE;EAClD,MAAMmlB,aAAa,GAAGu4F,6BAA6B,CAAC19G,IAAI,CAAC;EACzD,MAAMxwB,UAAU,GAAG4U,UAAU,CAACwE,WAAW,CAACmI,iBAAiB,CAAC,CAAC9Z,MAAM,CAAC,CAACkuC,aAAa,CAAC/K,YAAY,CAAC,CAAC,CAAC,CAAC;EACnG,MAAM3qC,IAAI,GAAGgsC,oBAAoB,CAACzb,IAAI,CAAC;EACvC,OAAO;IACLxwB,UAAU;IACVC,IAAI;IACJkQ,UAAU,EAAE;EACd,CAAC;AACH;AACA,SAAS+9H,6BAA6BA,CAAC19G,IAAI,EAAE;EAC3C,MAAMmlB,aAAa,GAAG,IAAIlL,aAAa,CAAC,CAAC;EACzCkL,aAAa,CAACz6C,GAAG,CAAC,YAAY,EAAE0a,OAAO,CAACo4H,gCAAgC,CAAC,CAAC;EAC1Er4F,aAAa,CAACz6C,GAAG,CAAC,SAAS,EAAE0a,OAAO,CAAC,QAAQ,CAAC,CAAC;EAC/C+/B,aAAa,CAACz6C,GAAG,CAAC,UAAU,EAAE0Z,UAAU,CAACwE,WAAW,CAAC3b,IAAI,CAAC,CAAC;EAC3Dk4C,aAAa,CAACz6C,GAAG,CAAC,MAAM,EAAEs1B,IAAI,CAACvwB,IAAI,CAAChH,KAAK,CAAC;EAC1C,IAAIu3B,IAAI,CAACwb,UAAU,KAAKjlB,SAAS,EAAE;IACjC,MAAMilB,UAAU,GAAG5b,oCAAoC,CAACI,IAAI,CAACwb,UAAU,CAAC;IACxE,IAAIA,UAAU,CAAC/yC,KAAK,KAAK,IAAI,EAAE;MAC7B08C,aAAa,CAACz6C,GAAG,CAAC,YAAY,EAAE8wC,UAAU,CAAC;IAC7C;EACF;EACA,IAAIxb,IAAI,CAACib,QAAQ,KAAK1kB,SAAS,EAAE;IAC/B4uB,aAAa,CAACz6C,GAAG,CAAC,UAAU,EAAEk1B,oCAAoC,CAACI,IAAI,CAACib,QAAQ,CAAC,CAAC;EACpF;EACA,IAAIjb,IAAI,CAACsb,WAAW,KAAK/kB,SAAS,EAAE;IAClC4uB,aAAa,CAACz6C,GAAG,CAAC,aAAa,EAAEk1B,oCAAoC,CAACI,IAAI,CAACsb,WAAW,CAAC,CAAC;EAC1F;EACA,IAAItb,IAAI,CAACqb,QAAQ,KAAK9kB,SAAS,EAAE;IAC/B4uB,aAAa,CAACz6C,GAAG,CAAC,UAAU,EAAEk1B,oCAAoC,CAACI,IAAI,CAACqb,QAAQ,CAAC,CAAC;EACpF;EACA,IAAIrb,IAAI,CAACob,UAAU,KAAK7kB,SAAS,EAAE;IACjC4uB,aAAa,CAACz6C,GAAG,CAAC,YAAY,EAAEs1B,IAAI,CAACob,UAAU,CAAC;EAClD;EACA,IAAIpb,IAAI,CAACM,IAAI,KAAK/J,SAAS,EAAE;IAC3B4uB,aAAa,CAACz6C,GAAG,CAAC,MAAM,EAAEga,UAAU,CAACsb,IAAI,CAACM,IAAI,CAACz1B,GAAG,CAACuwI,iBAAiB,CAAC,CAAC,CAAC;EACzE;EACA,OAAOj2F,aAAa;AACtB;AAEA,MAAMw4F,gCAAgC,GAAG,QAAQ;AACjD,SAASC,kCAAkCA,CAAC59G,IAAI,EAAE;EAChD,MAAMmlB,aAAa,GAAG04F,2BAA2B,CAAC79G,IAAI,CAAC;EACvD,MAAMxwB,UAAU,GAAG4U,UAAU,CAACwE,WAAW,CAACqJ,eAAe,CAAC,CAAChb,MAAM,CAAC,CAACkuC,aAAa,CAAC/K,YAAY,CAAC,CAAC,CAAC,CAAC;EACjG,MAAM3qC,IAAI,GAAG61C,kBAAkB,CAACtlB,IAAI,CAAC;EACrC,OAAO;IACLxwB,UAAU;IACVC,IAAI;IACJkQ,UAAU,EAAE;EACd,CAAC;AACH;AACA,SAASk+H,2BAA2BA,CAAC79G,IAAI,EAAE;EACzC,MAAMmlB,aAAa,GAAG,IAAIlL,aAAa,CAAC,CAAC;EACzCkL,aAAa,CAACz6C,GAAG,CAAC,YAAY,EAAE0a,OAAO,CAACu4H,gCAAgC,CAAC,CAAC;EAC1Ex4F,aAAa,CAACz6C,GAAG,CAAC,SAAS,EAAE0a,OAAO,CAAC,QAAQ,CAAC,CAAC;EAC/C+/B,aAAa,CAACz6C,GAAG,CAAC,UAAU,EAAE0Z,UAAU,CAACwE,WAAW,CAAC3b,IAAI,CAAC,CAAC;EAC3Dk4C,aAAa,CAACz6C,GAAG,CAAC,MAAM,EAAEs1B,IAAI,CAACvwB,IAAI,CAAChH,KAAK,CAAC;EAC1C08C,aAAa,CAACz6C,GAAG,CAAC,WAAW,EAAEs1B,IAAI,CAAColB,SAAS,CAAC;EAC9C,IAAIplB,IAAI,CAACqlB,OAAO,CAAC3+C,MAAM,GAAG,CAAC,EAAE;IAC3By+C,aAAa,CAACz6C,GAAG,CAAC,SAAS,EAAEga,UAAU,CAACsb,IAAI,CAACqlB,OAAO,CAAC,CAAC;EACxD;EACA,OAAOF,aAAa;AACtB;AAEA,MAAM24F,gCAAgC,GAAG,QAAQ;AACjD,SAASC,kCAAkCA,CAAC/9G,IAAI,EAAE;EAChD,MAAMmlB,aAAa,GAAG64F,2BAA2B,CAACh+G,IAAI,CAAC;EACvD,MAAMxwB,UAAU,GAAG4U,UAAU,CAACwE,WAAW,CAACyJ,eAAe,CAAC,CAACpb,MAAM,CAAC,CAACkuC,aAAa,CAAC/K,YAAY,CAAC,CAAC,CAAC,CAAC;EACjG,MAAM3qC,IAAI,GAAG62C,kBAAkB,CAACtmB,IAAI,CAAC;EACrC,OAAO;IACLxwB,UAAU;IACVC,IAAI;IACJkQ,UAAU,EAAE;EACd,CAAC;AACH;AACA,SAASq+H,2BAA2BA,CAACh+G,IAAI,EAAE;EACzC,MAAMmlB,aAAa,GAAG,IAAIlL,aAAa,CAAC,CAAC;EACzC,IAAIja,IAAI,CAACiiB,IAAI,KAAKwD,sBAAsB,CAACe,KAAK,EAAE;IAC9C,MAAM,IAAIt/C,KAAK,CAAC,uFAAuF,CAAC;EAC1G;EACAi+C,aAAa,CAACz6C,GAAG,CAAC,YAAY,EAAE0a,OAAO,CAAC04H,gCAAgC,CAAC,CAAC;EAC1E34F,aAAa,CAACz6C,GAAG,CAAC,SAAS,EAAE0a,OAAO,CAAC,QAAQ,CAAC,CAAC;EAC/C+/B,aAAa,CAACz6C,GAAG,CAAC,UAAU,EAAE0Z,UAAU,CAACwE,WAAW,CAAC3b,IAAI,CAAC,CAAC;EAC3Dk4C,aAAa,CAACz6C,GAAG,CAAC,MAAM,EAAEs1B,IAAI,CAACvwB,IAAI,CAAChH,KAAK,CAAC;EAC1C,IAAIu3B,IAAI,CAAC4lB,SAAS,CAACl/C,MAAM,GAAG,CAAC,EAAE;IAC7By+C,aAAa,CAACz6C,GAAG,CAAC,WAAW,EAAE60B,WAAW,CAACS,IAAI,CAAC4lB,SAAS,EAAE5lB,IAAI,CAAC6lB,oBAAoB,CAAC,CAAC;EACxF;EACA,IAAI7lB,IAAI,CAACgmB,YAAY,CAACt/C,MAAM,GAAG,CAAC,EAAE;IAChCy+C,aAAa,CAACz6C,GAAG,CAAC,cAAc,EAAE60B,WAAW,CAACS,IAAI,CAACgmB,YAAY,EAAEhmB,IAAI,CAAC6lB,oBAAoB,CAAC,CAAC;EAC9F;EACA,IAAI7lB,IAAI,CAACqlB,OAAO,CAAC3+C,MAAM,GAAG,CAAC,EAAE;IAC3By+C,aAAa,CAACz6C,GAAG,CAAC,SAAS,EAAE60B,WAAW,CAACS,IAAI,CAACqlB,OAAO,EAAErlB,IAAI,CAAC6lB,oBAAoB,CAAC,CAAC;EACpF;EACA,IAAI7lB,IAAI,CAACimB,OAAO,CAACv/C,MAAM,GAAG,CAAC,EAAE;IAC3By+C,aAAa,CAACz6C,GAAG,CAAC,SAAS,EAAE60B,WAAW,CAACS,IAAI,CAACimB,OAAO,EAAEjmB,IAAI,CAAC6lB,oBAAoB,CAAC,CAAC;EACpF;EACA,IAAI7lB,IAAI,CAACqmB,OAAO,KAAK,IAAI,IAAIrmB,IAAI,CAACqmB,OAAO,CAAC3/C,MAAM,GAAG,CAAC,EAAE;IACpDy+C,aAAa,CAACz6C,GAAG,CAAC,SAAS,EAAEga,UAAU,CAACsb,IAAI,CAACqmB,OAAO,CAACx7C,GAAG,CAAC60B,GAAG,IAAIA,GAAG,CAACj3B,KAAK,CAAC,CAAC,CAAC;EAC9E;EACA,IAAIu3B,IAAI,CAACpyB,EAAE,KAAK,IAAI,EAAE;IACpBu3C,aAAa,CAACz6C,GAAG,CAAC,IAAI,EAAEs1B,IAAI,CAACpyB,EAAE,CAAC;EAClC;EACA,OAAOu3C,aAAa;AACtB;AAEA,MAAM84F,8BAA8B,GAAG,QAAQ;AAC/C,SAASC,8BAA8BA,CAACl+G,IAAI,EAAE;EAC5C,MAAMmlB,aAAa,GAAGg5F,uBAAuB,CAACn+G,IAAI,CAAC;EACnD,MAAMxwB,UAAU,GAAG4U,UAAU,CAACwE,WAAW,CAAC8J,WAAW,CAAC,CAACzb,MAAM,CAAC,CAACkuC,aAAa,CAAC/K,YAAY,CAAC,CAAC,CAAC,CAAC;EAC7F,MAAM3qC,IAAI,GAAGq4C,cAAc,CAAC9nB,IAAI,CAAC;EACjC,OAAO;IACLxwB,UAAU;IACVC,IAAI;IACJkQ,UAAU,EAAE;EACd,CAAC;AACH;AACA,SAASw+H,uBAAuBA,CAACn+G,IAAI,EAAE;EACrC,MAAMmlB,aAAa,GAAG,IAAIlL,aAAa,CAAC,CAAC;EACzCkL,aAAa,CAACz6C,GAAG,CAAC,YAAY,EAAE0a,OAAO,CAAC64H,8BAA8B,CAAC,CAAC;EACxE94F,aAAa,CAACz6C,GAAG,CAAC,SAAS,EAAE0a,OAAO,CAAC,QAAQ,CAAC,CAAC;EAC/C+/B,aAAa,CAACz6C,GAAG,CAAC,UAAU,EAAE0Z,UAAU,CAACwE,WAAW,CAAC3b,IAAI,CAAC,CAAC;EAC3Dk4C,aAAa,CAACz6C,GAAG,CAAC,MAAM,EAAEs1B,IAAI,CAACvwB,IAAI,CAAChH,KAAK,CAAC;EAC1C,IAAIu3B,IAAI,CAAC6nB,YAAY,KAAKtxB,SAAS,EAAE;IACnC4uB,aAAa,CAACz6C,GAAG,CAAC,cAAc,EAAE0a,OAAO,CAAC4a,IAAI,CAAC6nB,YAAY,CAAC,CAAC;EAC/D;EACA1C,aAAa,CAACz6C,GAAG,CAAC,MAAM,EAAE0a,OAAO,CAAC4a,IAAI,CAAC4nB,QAAQ,IAAI5nB,IAAI,CAACx3B,IAAI,CAAC,CAAC;EAC9D,IAAIw3B,IAAI,CAAC7oB,IAAI,KAAK,KAAK,EAAE;IACvBguC,aAAa,CAACz6C,GAAG,CAAC,MAAM,EAAE0a,OAAO,CAAC4a,IAAI,CAAC7oB,IAAI,CAAC,CAAC;EAC/C;EACA,OAAOguC,aAAa;AACtB;AAEA,SAASi5F,qBAAqBA,CAACC,SAAS,EAAE;EACxC,MAAMC,eAAe,GAAG;IACtBh0I,SAAS,EAAE+zI,SAAS,CAAC/zI;EACvB,CAAC;EACD,IAAI+zI,SAAS,CAACjsG,QAAQ,EAAE;IACtBksG,eAAe,CAAClsG,QAAQ,GAAGisG,SAAS,CAACjsG,QAAQ;IAC7CksG,eAAe,CAACC,UAAU,GAAGF,SAAS,CAACE,UAAU;EACnD;EACA,IAAIF,SAAS,CAACG,qBAAqB,EAAE;IACnCF,eAAe,CAACE,qBAAqB,GAAGp5H,OAAO,CAAC,IAAI,CAAC;EACvD;EACA,MAAM+hC,MAAM,GAAG/iC,UAAU,CAACwE,WAAW,CAACmK,iBAAiB,CAAC,CAAC9b,MAAM,CAAC,CAAConI,SAAS,CAAC5uI,IAAI,EAAE+mE,UAAU,CAAC8nE,eAAe,CAAC,CAAC,CAAC;EAC9G,MAAMj3F,IAAI,GAAGtiC,OAAO,CAAC,EAAE,EAAE,CAACia,wBAAwB,CAACmoB,MAAM,CAAC,CAAC9sC,MAAM,CAAC,CAAC,CAAC,CAAC;EACrE,OAAOgtC,IAAI,CAACpwC,MAAM,CAAC,EAAE,CAAC;AACxB;AAEA,SAASwnI,qBAAqBA,CAACz+G,IAAI,EAAE;EACnC,MAAMnhB,UAAU,GAAG,GAAG;EACtB,MAAM6/H,QAAQ,GAAG,GAAG;EACpB,MAAMC,aAAa,GAAG,GAAG;EACzB,MAAMC,MAAM,GAAG,IAAI;EACnB,MAAMC,kBAAkB,GAAG,GAAG7+G,IAAI,CAAC11B,SAAS,UAAU;EACtD,MAAMw0I,UAAU,GAAG9+G,IAAI,CAAC++G,qBAAqB,CAACl0I,GAAG,CAAC+2B,GAAG,IAAI;IACvD,OAAO,IAAIhjB,YAAY,CAAC;MACtBC,UAAU,EAAE+iB,GAAG,CAAC/iB,UAAU;MAC1BrW,IAAI,EAAE;IACR,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,MAAMw2I,WAAW,GAAG76H,QAAQ,CAACtF,UAAU,CAAC,CAAChI,IAAI,CAAC,SAAS,CAAC;EACxD,MAAMooI,WAAW,GAAG76H,UAAU,CAACwE,WAAW,CAACgI,eAAe,CAAC,CAAC3Z,MAAM,CAAC,CAAC+oB,IAAI,CAACvwB,IAAI,EAAEuvI,WAAW,EAAEt6H,UAAU,CAACo6H,UAAU,CAAC,EAAEp6H,UAAU,CAACsb,IAAI,CAACk/G,iBAAiB,CAACr0I,GAAG,CAACqxB,CAAC,IAAIA,CAAC,CAACijH,qBAAqB,CAAC,CAAC,EAAEh7H,QAAQ,CAAC,QAAQ,CAAC,CAACtN,IAAI,CAAC,MAAM,CAAC,EAAEsN,QAAQ,CAACy6H,MAAM,CAAC,CAAC,CAAC;EAC7O,MAAMQ,eAAe,GAAGr6H,OAAO,CAAC,CAAC,IAAIvF,OAAO,CAACX,UAAU,CAAC,CAAC,EAAEmgI,WAAW,CAAC/lI,GAAG,CAACgmI,WAAW,CAAC,CAAC;EACxF,MAAM9/H,GAAG,GAAGiF,UAAU,CAACwE,WAAW,CAACiI,qBAAqB,CAAC,CAAC5Z,MAAM,CAAC,CAACkN,QAAQ,CAACy6H,MAAM,CAAC,EAAEz6H,QAAQ,CAACw6H,aAAa,CAAC,EAAEx6H,QAAQ,CAAC,QAAQ,CAAC,CAACtN,IAAI,CAAC,MAAM,CAAC,CAACA,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;EAC1J,MAAMwoI,cAAc,GAAG,IAAIz/H,mBAAmB,CAACi/H,kBAAkB,EAAE,CAAC,IAAIr/H,OAAO,CAACm/H,aAAa,CAAC,CAAC,EAAE,CAAC,IAAIz/H,iBAAiB,CAACC,GAAG,EAAE,IAAI,EAAE,cAAc,CAAC,CAACtI,IAAI,CAAC,MAAM,CAAC,CAACI,MAAM,CAAC,CAACmoI,eAAe,CAAC,CAAC,CAAC/kI,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,EAAEkI,YAAY,CAAC+E,KAAK,CAAC;EAC9N,MAAMg4H,cAAc,GAAGv6H,OAAO,CAAC,CAAC,IAAIvF,OAAO,CAACk/H,QAAQ,CAAC,CAAC,EAAEv6H,QAAQ,CAACu6H,QAAQ,CAAC,CAAC7nI,IAAI,CAAC,IAAI,CAAC,CAACoB,SAAS,CAACkM,QAAQ,CAACy6H,MAAM,CAAC,CAAC,CAAC3lI,GAAG,CAACkL,QAAQ,CAAC06H,kBAAkB,CAAC,CAAC5nI,MAAM,CAAC,CAACkN,QAAQ,CAACu6H,QAAQ,CAAC,CAAC7nI,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;EACnM,MAAM0oI,WAAW,GAAGp7H,QAAQ,CAAC06H,kBAAkB,CAAC,CAAC5nI,MAAM,CAAC,CAACkN,QAAQ,CAAC,MAAM,CAAC,CAACtN,IAAI,CAAC,KAAK,CAAC,CAACI,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC;EAClG,MAAMuoI,OAAO,GAAGr7H,QAAQ,CAAC,QAAQ,CAAC,CAACtN,IAAI,CAAC,MAAM,CAAC,CAACA,IAAI,CAAC,KAAK,CAAC;EAC3D,MAAM4oI,WAAW,GAAGD,OAAO,CAAC7kI,KAAK,CAAC,CAAC,CAAC9D,IAAI,CAAC,IAAI,CAAC,CAACI,MAAM,CAAC,CAACmO,OAAO,CAAC,0BAA0B,CAAC,EAAEk6H,cAAc,CAAC,CAAC;EAC5G,OAAOv6H,OAAO,CAAC,EAAE,EAAE,CAAC,IAAI3E,cAAc,CAACw+H,MAAM,EAAEx5H,OAAO,CAACs6H,kBAAkB,CAAC,GAAG1/G,IAAI,CAACoS,QAAQ,IAAIpS,IAAI,CAAC11B,SAAS,EAAE,CAAC,CAAC,EAAE,IAAI,EAAEiY,YAAY,CAAC+E,KAAK,CAAC,EAAE+3H,cAAc,EAAErgH,wBAAwB,CAACugH,WAAW,CAAC,CAACllI,MAAM,CAAC,CAAC,EAAE2kB,wBAAwB,CAACwgH,OAAO,CAACvmI,GAAG,CAACwmI,WAAW,CAAC,CAAC,CAACplI,MAAM,CAAC,CAAC,CAAC,CAAC,CAACpD,MAAM,CAAC,EAAE,CAAC;AACvR;AACA,SAAS0oI,wBAAwBA,CAACC,WAAW,EAAEC,kBAAkB,EAAE7/G,IAAI,EAAE;EACvE,MAAM8+G,UAAU,GAAG,cAAc;EACjC,MAAM5nI,MAAM,GAAG,CAAC8oB,IAAI,CAAC11B,SAAS,EAAEw0I,UAAU,CAAC,CAACj0I,GAAG,CAACrC,IAAI,IAAI,IAAIgX,OAAO,CAAChX,IAAI,EAAE0M,YAAY,CAAC,CAAC;EACxF,MAAM8G,IAAI,GAAG,EAAE;EACf,KAAK,MAAM64D,KAAK,IAAI70C,IAAI,CAACk/G,iBAAiB,EAAE;IAC1ChoI,MAAM,CAACvQ,IAAI,CAAC,IAAI6Y,OAAO,CAACq1D,KAAK,CAACrsE,IAAI,CAAC,CAAC;EACtC;EACA,KAAK,IAAIV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGk4B,IAAI,CAAC++G,qBAAqB,CAACr4I,MAAM,EAAEoB,CAAC,EAAE,EAAE;IAC1DkU,IAAI,CAACrV,IAAI,CAAC,IAAIyZ,cAAc,CAAC4f,IAAI,CAAC++G,qBAAqB,CAACj3I,CAAC,CAAC,CAACg4I,YAAY,EAAE37H,QAAQ,CAAC26H,UAAU,CAAC,CAAC/nI,GAAG,CAACqO,OAAO,CAACtd,CAAC,CAAC,CAAC,EAAEoN,YAAY,EAAEqN,YAAY,CAAC+E,KAAK,CAAC,CAAC;EACnJ;EACAtL,IAAI,CAACrV,IAAI,CAAC,GAAGk5I,kBAAkB,CAAC;EAChC,KAAK,MAAMzW,KAAK,IAAIwW,WAAW,EAAE;IAC/B,IAAIxW,KAAK,CAAC3zE,WAAW,KAAK,IAAI,EAAE;MAC9Bz5C,IAAI,CAACrV,IAAI,CAACwd,QAAQ,CAAC6b,IAAI,CAAC11B,SAAS,CAAC,CAACuM,IAAI,CAACuyH,KAAK,CAAC5gI,IAAI,CAAC,CAACkC,GAAG,CAAC0+H,KAAK,CAAC3zE,WAAW,CAAC,CAACp7C,MAAM,CAAC,CAAC,CAAC;MACpF,KAAK,MAAM6I,IAAI,IAAIkmH,KAAK,CAACzpH,UAAU,EAAE;QACnC3D,IAAI,CAACrV,IAAI,CAACuc,IAAI,CAAC;MACjB;IACF;EACF;EACA,OAAO,IAAItD,mBAAmB,CAAC,GAAGogB,IAAI,CAAC11B,SAAS,iBAAiB,EAAE4M,MAAM,EAAE8E,IAAI,EAAE,IAAI,EAAEuG,YAAY,CAAC+E,KAAK,CAAC;AAC5G;AAEA,MAAMy4H,OAAO,GAAG,IAAI7oH,OAAO,CAAC,QAAQ,CAAC;AAErCo0G,aAAa,CAAC7zG,OAAO,CAAC;AAEtB,SAAS0L,GAAG,EAAEC,WAAW,EAAEsE,aAAa,EAAExE,kBAAkB,EAAExuB,SAAS,EAAEsL,iBAAiB,EAAEs3C,SAAS,EAAE/xB,MAAM,EAAEtvB,cAAc,EAAE4B,kBAAkB,EAAE8sB,WAAW,EAAED,eAAe,EAAEuE,WAAW,EAAE0uC,KAAK,EAAEE,cAAc,EAAE3uC,oBAAoB,EAAE90B,WAAW,EAAED,eAAe,EAAEhI,sBAAsB,EAAEy6B,IAAI,EAAEhD,KAAK,EAAE33B,uBAAuB,EAAEu0H,2BAA2B,EAAEp+G,SAAS,EAAE6nB,OAAO,EAAEyhG,cAAc,EAAEtF,kBAAkB,EAAEzjG,SAAS,EAAEmB,WAAW,EAAEpsB,eAAe,EAAE4O,YAAY,EAAEvgB,WAAW,EAAEs/F,4BAA4B,EAAEnwF,YAAY,EAAE0K,mBAAmB,EAAEQ,cAAc,EAAEwiB,SAAS,EAAEm7D,wBAAwB,EAAE7+E,iBAAiB,EAAEqwE,GAAG,EAAEnkD,OAAO,EAAEgyD,qBAAqB,EAAEpiE,qBAAqB,EAAEsI,WAAW,IAAIC,SAAS,EAAEyzC,SAAS,EAAEI,aAAa,EAAEzgE,UAAU,EAAEoxB,iBAAiB,EAAEztB,mBAAmB,EAAE/F,cAAc,EAAEqK,YAAY,EAAEG,iBAAiB,EAAEzR,aAAa,EAAEoS,YAAY,EAAEsnG,UAAU,EAAE/mB,iBAAiB,EAAEu4C,cAAc,EAAE/0H,MAAM,EAAE+f,gBAAgB,EAAElsB,eAAe,EAAE6tB,eAAe,IAAIC,aAAa,EAAE8/D,mBAAmB,EAAE9tF,kBAAkB,EAAEuL,YAAY,EAAE8gC,YAAY,EAAEnf,SAAS,EAAE9hB,cAAc,EAAEstB,cAAc,EAAEy8C,KAAK,EAAExnD,YAAY,EAAErjB,gBAAgB,EAAEvF,WAAW,EAAE8oB,UAAU,EAAEjjB,cAAc,EAAE6iB,gBAAgB,EAAExnB,eAAe,EAAExI,OAAO,EAAEkkI,aAAa,EAAEhjI,SAAS,EAAE3J,gBAAgB,EAAE0qE,YAAY,EAAEpwC,aAAa,EAAEpnB,OAAO,EAAEmB,iBAAiB,EAAE8mB,uBAAuB,EAAEia,UAAU,EAAED,eAAe,EAAEtB,aAAa,EAAEkB,eAAe,EAAEC,eAAe,EAAEre,SAAS,EAAE2hD,eAAe,EAAE77C,WAAW,EAAED,eAAe,EAAEV,cAAc,EAAEM,kBAAkB,EAAEQ,cAAc,EAAE67C,MAAM,EAAEz+C,SAAS,EAAElC,YAAY,EAAEtb,WAAW,IAAIo3H,aAAa,EAAEv6F,sBAAsB,EAAED,mBAAmB,EAAE07E,cAAc,EAAE1zH,wBAAwB,EAAEwJ,WAAW,EAAEF,YAAY,EAAEyD,WAAW,EAAEqJ,mBAAmB,EAAE4tB,gBAAgB,EAAE/J,wBAAwB,EAAE1rB,4BAA4B,EAAEoqH,cAAc,EAAE5iH,eAAe,EAAEk6E,MAAM,EAAEb,eAAe,EAAEhnF,WAAW,EAAEmxB,QAAQ,EAAEvC,aAAa,EAAEJ,gBAAgB,EAAEl6B,eAAe,EAAEJ,mBAAmB,EAAEf,eAAe,EAAE4C,mBAAmB,EAAE2nC,UAAU,EAAEi/C,kBAAkB,EAAEzvE,SAAS,EAAEP,YAAY,EAAEssE,WAAW,EAAExC,eAAe,EAAEhjD,cAAc,EAAEpC,qBAAqB,EAAEvrB,yBAAyB,EAAE+2E,0BAA0B,EAAEtrD,eAAe,EAAEE,sBAAsB,EAAE3qB,0BAA0B,EAAEL,mBAAmB,EAAE+tB,IAAI,EAAE1G,YAAY,EAAEqJ,SAAS,IAAIkzG,gBAAgB,EAAEx1G,cAAc,IAAIy1G,qBAAqB,EAAE/zG,oBAAoB,IAAIg0G,2BAA2B,EAAEv1G,UAAU,IAAIw1G,iBAAiB,EAAE/1G,SAAS,IAAIg2G,gBAAgB,EAAErwG,WAAW,IAAIswG,gBAAgB,EAAE7vG,OAAO,IAAI8vG,cAAc,EAAE/yG,aAAa,IAAIgzG,oBAAoB,EAAElzG,kBAAkB,IAAImzG,yBAAyB,EAAEtzG,oBAAoB,IAAIuzG,2BAA2B,EAAE1zG,wBAAwB,IAAI2zG,+BAA+B,EAAE70G,eAAe,IAAI80G,sBAAsB,EAAEzwG,WAAW,IAAI0wG,gBAAgB,EAAE11G,SAAS,IAAI21G,cAAc,EAAElyG,YAAY,IAAImyG,mBAAmB,EAAE5xG,iBAAiB,IAAI6xG,wBAAwB,EAAE7vG,WAAW,IAAI8vG,kBAAkB,EAAEz0G,oBAAoB,IAAI00G,2BAA2B,EAAEnwG,KAAK,IAAIowG,UAAU,EAAE70G,mBAAmB,IAAI80G,0BAA0B,EAAE/xG,OAAO,IAAIgyG,cAAc,EAAE7xG,aAAa,IAAI8xG,oBAAoB,EAAE/0G,wBAAwB,IAAIg1G,+BAA+B,EAAE30G,0BAA0B,IAAI40G,iCAAiC,EAAE3xG,gBAAgB,IAAI4xG,qBAAqB,EAAEp1G,oBAAoB,IAAIq1G,2BAA2B,EAAEnwG,kBAAkB,IAAIowG,uBAAuB,EAAE9wG,SAAS,IAAI+wG,gBAAgB,EAAErzG,WAAW,IAAIszG,kBAAkB,EAAEnzG,eAAe,IAAIozG,sBAAsB,EAAEzxG,QAAQ,IAAI0xG,eAAe,EAAE53G,MAAM,IAAI63G,WAAW,EAAEz3G,aAAa,IAAI03G,oBAAoB,EAAEv1G,oBAAoB,IAAIw1G,2BAA2B,EAAEvyG,YAAY,IAAIwyG,mBAAmB,EAAExxG,QAAQ,IAAIyxG,eAAe,EAAEv1G,uBAAuB,IAAIw1G,8BAA8B,EAAE31D,KAAK,EAAEN,SAAS,EAAEp3E,gBAAgB,EAAEyvE,SAAS,EAAEp3E,IAAI,EAAEyG,YAAY,EAAE+G,UAAU,EAAEyrB,gBAAgB,EAAET,KAAK,EAAE7vB,aAAa,EAAEqK,iBAAiB,EAAE0/H,OAAO,EAAEj4G,eAAe,EAAE5Q,OAAO,EAAEnrB,mBAAmB,IAAIC,iBAAiB,EAAEgP,QAAQ,EAAEwrB,cAAc,EAAEtrB,eAAe,EAAE+2H,KAAK,EAAE+C,MAAM,EAAE/+F,GAAG,EAAEk7F,SAAS,EAAEuF,GAAG,EAAEh5C,aAAa,EAAE0gD,qBAAqB,EAAEzE,oBAAoB,EAAEK,6BAA6B,EAAEc,oCAAoC,EAAEpe,4BAA4B,EAAEme,2BAA2B,EAAEqB,mCAAmC,EAAEZ,mCAAmC,EAAEiC,6BAA6B,EAAEE,oCAAoC,EAAEG,kCAAkC,EAAEG,kCAAkC,EAAEG,8BAA8B,EAAEne,4BAA4B,EAAEvD,4BAA4B,EAAEz8F,sBAAsB,EAAE0+G,qBAAqB,EAAEkB,wBAAwB,EAAE7kG,iBAAiB,EAAEoK,eAAe,EAAEQ,eAAe,EAAEy0F,+BAA+B,EAAE1yF,uBAAuB,EAAEh5C,YAAY,EAAExB,IAAI,EAAEotC,yBAAyB,EAAEoB,oBAAoB,EAAE9b,+BAA+B,EAAEX,wBAAwB,EAAElzB,mCAAmC,EAAEyzH,gBAAgB,EAAE/oG,YAAY,EAAEqqG,8BAA8B,EAAEpgC,oBAAoB,EAAE72D,WAAW,EAAEjL,2BAA2B,EAAE2jB,cAAc,EAAE7Y,aAAa,EAAEC,WAAW,EAAEC,YAAY,EAAEzlB,YAAY,EAAEjB,cAAc,EAAEmC,OAAO,EAAER,UAAU,EAAEg2G,iBAAiB,EAAE9wF,cAAc,EAAElkB,UAAU,IAAI08H,SAAS,EAAEljB,iBAAiB,EAAE5E,aAAa,EAAEqR,0BAA0B,EAAEP,aAAa,EAAEtpF,mBAAmB,EAAES,kBAAkB,EAAEuiE,gCAAgC,EAAE17E,WAAW,EAAE8E,UAAU,IAAIm0G,eAAe,EAAEljB,kBAAkB,EAAEr3F,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}